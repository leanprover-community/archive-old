[
    {
        "content": "<p>This is a translation of the core of the code for the interactive theorem prover described in \"Handbook of Practical Logic and Automated Reasoning\" by John Harrison [https://www.cl.cam.ac.uk/~jrh13/atp/index.html]. I'm wondering if I have done this correctly and if it can be extended for theorems in ZFC by adding the axioms for ZFC in the manner that I have added the first. Also, I am not certain if I am missing something, but the code for axiomExistsEq does not seem to match its 'x not free in t' comment.</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"kr\">import</span> <span class=\"nn\">Data.List</span>\n<span class=\"kr\">import</span> <span class=\"nn\">Prelude</span> <span class=\"k\">hiding</span> <span class=\"p\">(</span><span class=\"kt\">False</span><span class=\"p\">,</span> <span class=\"kt\">True</span><span class=\"p\">)</span>\n<span class=\"kr\">import</span> <span class=\"k\">qualified</span> <span class=\"nn\">Prelude</span> <span class=\"p\">(</span><span class=\"kt\">Bool</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">))</span>\n\n<span class=\"kr\">data</span> <span class=\"kt\">Formula</span> <span class=\"n\">a</span> <span class=\"ow\">=</span> <span class=\"kt\">False</span>\n               <span class=\"o\">|</span> <span class=\"kt\">True</span>\n               <span class=\"o\">|</span> <span class=\"kt\">Atom</span> <span class=\"n\">a</span>\n               <span class=\"o\">|</span> <span class=\"kt\">Not</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span>\n               <span class=\"o\">|</span> <span class=\"kt\">And</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span>\n               <span class=\"o\">|</span> <span class=\"kt\">Or</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span>\n               <span class=\"o\">|</span> <span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span>\n               <span class=\"o\">|</span> <span class=\"kt\">Iff</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span>\n               <span class=\"o\">|</span> <span class=\"kt\">Forall</span> <span class=\"kt\">String</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span>\n               <span class=\"o\">|</span> <span class=\"kt\">Exists</span> <span class=\"kt\">String</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span>\n                 <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"c1\">-- Func \"c\" [] : A constant named c</span>\n<span class=\"kr\">data</span> <span class=\"kt\">Term</span> <span class=\"ow\">=</span> <span class=\"kt\">Var</span> <span class=\"kt\">String</span>\n          <span class=\"o\">|</span> <span class=\"kt\">Func</span> <span class=\"kt\">String</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span>\n            <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"c1\">-- Pred \"P\" [] : A propositional variable named P</span>\n<span class=\"kr\">data</span> <span class=\"kt\">FOL</span> <span class=\"ow\">=</span> <span class=\"kt\">Pred</span> <span class=\"kt\">String</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span>\n           <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"kr\">type</span> <span class=\"kt\">Thm</span> <span class=\"ow\">=</span> <span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span>\n\n\n<span class=\"nf\">mkEq</span> <span class=\"ow\">::</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span>\n<span class=\"nf\">mkEq</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"kt\">Atom</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"s\">\"=\"</span> <span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">])</span>\n\n<span class=\"nf\">occursIn</span> <span class=\"ow\">::</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">occursIn</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">|</span> <span class=\"n\">s</span> <span class=\"o\">==</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"kt\">Prelude</span><span class=\"o\">.</span><span class=\"kt\">True</span>\n<span class=\"nf\">occursIn</span> <span class=\"kr\">_</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"kr\">_</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Prelude</span><span class=\"o\">.</span><span class=\"kt\">False</span>\n<span class=\"nf\">occursIn</span> <span class=\"n\">s</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"kr\">_</span> <span class=\"n\">args</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">any</span> <span class=\"p\">(</span><span class=\"n\">occursIn</span> <span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"n\">args</span>\n\n<span class=\"nf\">freeIn</span> <span class=\"ow\">::</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">freeIn</span> <span class=\"kr\">_</span> <span class=\"kt\">False</span> <span class=\"ow\">=</span> <span class=\"kt\">Prelude</span><span class=\"o\">.</span><span class=\"kt\">False</span>\n<span class=\"nf\">freeIn</span> <span class=\"kr\">_</span> <span class=\"kt\">True</span> <span class=\"ow\">=</span> <span class=\"kt\">Prelude</span><span class=\"o\">.</span><span class=\"kt\">False</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"kt\">Atom</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"kr\">_</span> <span class=\"n\">args</span><span class=\"p\">))</span> <span class=\"ow\">=</span> <span class=\"n\">any</span> <span class=\"p\">(</span><span class=\"n\">occursIn</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"n\">args</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">freeIn</span> <span class=\"n\">t</span> <span class=\"n\">p</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"kt\">And</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"p\">(</span><span class=\"n\">freeIn</span> <span class=\"n\">t</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"o\">||</span> <span class=\"p\">(</span><span class=\"n\">freeIn</span> <span class=\"n\">t</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"kt\">Or</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"p\">(</span><span class=\"n\">freeIn</span> <span class=\"n\">t</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"o\">||</span> <span class=\"p\">(</span><span class=\"n\">freeIn</span> <span class=\"n\">t</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"p\">(</span><span class=\"n\">freeIn</span> <span class=\"n\">t</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"o\">||</span> <span class=\"p\">(</span><span class=\"n\">freeIn</span> <span class=\"n\">t</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"kt\">Iff</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"p\">(</span><span class=\"n\">freeIn</span> <span class=\"n\">t</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"o\">||</span> <span class=\"p\">(</span><span class=\"n\">freeIn</span> <span class=\"n\">t</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">y</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"p\">(</span><span class=\"n\">not</span> <span class=\"p\">(</span><span class=\"n\">occursIn</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"n\">t</span><span class=\"p\">))</span> <span class=\"o\">&amp;&amp;</span> <span class=\"p\">(</span><span class=\"n\">freeIn</span> <span class=\"n\">t</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"kt\">Exists</span> <span class=\"n\">y</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"p\">(</span><span class=\"n\">not</span> <span class=\"p\">(</span><span class=\"n\">occursIn</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"n\">t</span><span class=\"p\">))</span> <span class=\"o\">&amp;&amp;</span> <span class=\"p\">(</span><span class=\"n\">freeIn</span> <span class=\"n\">t</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n\n<span class=\"nf\">itList2</span> <span class=\"ow\">::</span> <span class=\"p\">(</span><span class=\"n\">t1</span> <span class=\"ow\">-&gt;</span> <span class=\"n\">t2</span> <span class=\"ow\">-&gt;</span> <span class=\"n\">t3</span> <span class=\"ow\">-&gt;</span> <span class=\"n\">t3</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"n\">t1</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"n\">t2</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"n\">t3</span> <span class=\"ow\">-&gt;</span> <span class=\"n\">t3</span>\n<span class=\"nf\">itList2</span> <span class=\"kr\">_</span> <span class=\"kt\">[]</span> <span class=\"kt\">[]</span> <span class=\"n\">b</span> <span class=\"ow\">=</span> <span class=\"n\">b</span>\n<span class=\"nf\">itList2</span> <span class=\"n\">f</span> <span class=\"p\">(</span><span class=\"n\">h1</span> <span class=\"kt\">:</span> <span class=\"n\">t1</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">h2</span> <span class=\"kt\">:</span> <span class=\"n\">t2</span><span class=\"p\">)</span> <span class=\"n\">b</span> <span class=\"ow\">=</span> <span class=\"n\">f</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"p\">(</span><span class=\"n\">itList2</span> <span class=\"n\">f</span> <span class=\"n\">t1</span> <span class=\"n\">t2</span> <span class=\"n\">b</span><span class=\"p\">)</span>\n<span class=\"nf\">itList2</span> <span class=\"kr\">_</span> <span class=\"kr\">_</span> <span class=\"kr\">_</span> <span class=\"kr\">_</span> <span class=\"ow\">=</span> <span class=\"ne\">error</span> <span class=\"s\">\"itList2\"</span>\n\n\n<span class=\"c1\">-- if |- p ==&gt; q and |- p then |- q</span>\n<span class=\"nf\">modusPonens</span> <span class=\"ow\">::</span> <span class=\"kt\">Thm</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Thm</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Thm</span>\n<span class=\"nf\">modusPonens</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p'</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"n\">p</span> <span class=\"o\">|</span> <span class=\"n\">p</span> <span class=\"o\">==</span> <span class=\"n\">p'</span> <span class=\"ow\">=</span> <span class=\"n\">q</span>\n                         <span class=\"o\">|</span> <span class=\"n\">otherwise</span> <span class=\"ow\">=</span> <span class=\"ne\">error</span> <span class=\"s\">\"modusPonens: p != p'\"</span>\n<span class=\"nf\">modusPonens</span> <span class=\"kr\">_</span> <span class=\"kr\">_</span> <span class=\"ow\">=</span> <span class=\"ne\">error</span> <span class=\"s\">\"modusPonens: pattern match\"</span>\n\n<span class=\"c1\">-- if |- p then |- forall x. p</span>\n<span class=\"nf\">gen</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Thm</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Thm</span>\n<span class=\"nf\">gen</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"ow\">=</span> <span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"n\">p</span>\n\n<span class=\"c1\">-- |- p ==&gt; (q ==&gt; p)</span>\n<span class=\"nf\">axiomAddImp</span> <span class=\"ow\">::</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Thm</span>\n<span class=\"nf\">axiomAddImp</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">q</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n\n<span class=\"c1\">-- |- (p ==&gt; q ==&gt; r) ==&gt; (p ==&gt; q) ==&gt; (p ==&gt; r)</span>\n<span class=\"nf\">axiomDistribImp</span> <span class=\"ow\">::</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Thm</span>\n<span class=\"nf\">axiomDistribImp</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"ow\">=</span> <span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">q</span> <span class=\"n\">r</span><span class=\"p\">))</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">r</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- ((p ==&gt; false) ==&gt; false) ==&gt; p</span>\n<span class=\"nf\">axiomDoubleNeg</span> <span class=\"ow\">::</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Thm</span>\n<span class=\"nf\">axiomDoubleNeg</span> <span class=\"n\">p</span> <span class=\"ow\">=</span> <span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"kt\">False</span><span class=\"p\">)</span> <span class=\"kt\">False</span><span class=\"p\">)</span> <span class=\"n\">p</span>\n\n<span class=\"c1\">-- |- (forall x. p ==&gt; q) ==&gt; (forall x. p) ==&gt; (forall x. q)</span>\n<span class=\"nf\">axiomAllImp</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Thm</span>\n<span class=\"nf\">axiomAllImp</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"n\">q</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- p ==&gt; forall x. p [x not free in p]</span>\n<span class=\"nf\">axiomImpAll</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Thm</span>\n<span class=\"nf\">axiomImpAll</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">not</span> <span class=\"p\">(</span><span class=\"n\">freeIn</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n                  <span class=\"kr\">then</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n                  <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"axiomImpAll: variable free in formula\"</span>\n\n<span class=\"c1\">-- |- exists x. x = t [x not free in t]</span>\n<span class=\"nf\">axiomExistsEq</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Thm</span>\n<span class=\"nf\">axiomExistsEq</span> <span class=\"n\">x</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">not</span> <span class=\"p\">(</span><span class=\"n\">occursIn</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"n\">t</span><span class=\"p\">)</span>\n                    <span class=\"kr\">then</span> <span class=\"p\">(</span><span class=\"kt\">Exists</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"n\">mkEq</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"n\">t</span><span class=\"p\">))</span>\n                    <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"axiomExistsEq: variable free in term\"</span>\n\n<span class=\"c1\">-- |- t = t</span>\n<span class=\"nf\">axiomEqRefl</span> <span class=\"ow\">::</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Thm</span>\n<span class=\"nf\">axiomEqRefl</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"n\">mkEq</span> <span class=\"n\">t</span> <span class=\"n\">t</span>\n\n<span class=\"c1\">-- |- s1 = t1 ==&gt; ... ==&gt; sn = tn ==&gt; f(s1,..,sn) = f(t1,..,tn)</span>\n<span class=\"nf\">axiomFunCong</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Thm</span>\n<span class=\"nf\">axiomFunCong</span> <span class=\"n\">f</span> <span class=\"n\">lefts</span> <span class=\"n\">rights</span> <span class=\"ow\">=</span>\n       <span class=\"n\">itList2</span> <span class=\"p\">(</span><span class=\"nf\">\\</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">p</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"n\">mkEq</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"n\">p</span><span class=\"p\">))</span> <span class=\"n\">lefts</span> <span class=\"n\">rights</span>\n               <span class=\"p\">(</span><span class=\"n\">mkEq</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"n\">f</span> <span class=\"n\">lefts</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"n\">f</span> <span class=\"n\">rights</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- s1 = t1 ==&gt; ... ==&gt; sn = tn ==&gt; P(s1,..,sn) ==&gt; P(t1,..,tn)</span>\n<span class=\"nf\">axiomPredCong</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Thm</span>\n<span class=\"nf\">axiomPredCong</span> <span class=\"n\">p</span> <span class=\"n\">lefts</span> <span class=\"n\">rights</span> <span class=\"ow\">=</span>\n       <span class=\"n\">itList2</span> <span class=\"p\">(</span><span class=\"nf\">\\</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">p</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"n\">mkEq</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"n\">p</span><span class=\"p\">))</span> <span class=\"n\">lefts</span> <span class=\"n\">rights</span>\n               <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Atom</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"n\">p</span> <span class=\"n\">lefts</span><span class=\"p\">))</span> <span class=\"p\">(</span><span class=\"kt\">Atom</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"n\">p</span> <span class=\"n\">rights</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">-- |- (p &lt;=&gt; q) ==&gt; p ==&gt; q</span>\n<span class=\"nf\">axiomIffImp1</span> <span class=\"ow\">::</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Thm</span>\n<span class=\"nf\">axiomIffImp1</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Iff</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n\n<span class=\"c1\">-- |- (p &lt;=&gt; q) ==&gt; q ==&gt; p</span>\n<span class=\"nf\">axiomIffImp2</span> <span class=\"ow\">::</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Thm</span>\n<span class=\"nf\">axiomIffImp2</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Iff</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">q</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n\n<span class=\"c1\">-- |- (p ==&gt; q) ==&gt; (q ==&gt; p) ==&gt; (p &lt;=&gt; q)</span>\n<span class=\"nf\">axiomImpIff</span> <span class=\"ow\">::</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Thm</span>\n<span class=\"nf\">axiomImpIff</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">q</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Iff</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- true &lt;=&gt; (false ==&gt; false)</span>\n<span class=\"nf\">axiomTrue</span> <span class=\"ow\">::</span> <span class=\"kt\">Thm</span>\n<span class=\"nf\">axiomTrue</span> <span class=\"ow\">=</span> <span class=\"kt\">Iff</span> <span class=\"kt\">True</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"kt\">False</span> <span class=\"kt\">False</span><span class=\"p\">)</span>\n\n<span class=\"c1\">-- |- ~p &lt;=&gt; (p ==&gt; false)</span>\n<span class=\"nf\">axiomNot</span> <span class=\"ow\">::</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Thm</span>\n<span class=\"nf\">axiomNot</span> <span class=\"n\">p</span> <span class=\"ow\">=</span> <span class=\"kt\">Iff</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"kt\">False</span><span class=\"p\">)</span>\n\n<span class=\"c1\">-- |- p /\\ q &lt;=&gt; (p ==&gt; q ==&gt; false) ==&gt; false</span>\n<span class=\"nf\">axiomAnd</span> <span class=\"ow\">::</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Thm</span>\n<span class=\"nf\">axiomAnd</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Iff</span> <span class=\"p\">(</span><span class=\"kt\">And</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">q</span> <span class=\"kt\">False</span><span class=\"p\">))</span> <span class=\"kt\">False</span><span class=\"p\">)</span>\n\n<span class=\"c1\">-- |- p \\/ q &lt;=&gt; ~(~p /\\ ~q)</span>\n<span class=\"nf\">axiomOr</span> <span class=\"ow\">::</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Thm</span>\n<span class=\"nf\">axiomOr</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Iff</span> <span class=\"p\">(</span><span class=\"kt\">Or</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"p\">(</span><span class=\"kt\">And</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">q</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">-- |- (exists x. p) &lt;=&gt; ~(forall x. ~p)</span>\n<span class=\"nf\">axiomExists</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Thm</span>\n<span class=\"nf\">axiomExists</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"ow\">=</span> <span class=\"kt\">Iff</span> <span class=\"p\">(</span><span class=\"kt\">Exists</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)))</span>\n\n<span class=\"nf\">concl</span> <span class=\"ow\">::</span> <span class=\"kt\">Thm</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span>\n<span class=\"nf\">concl</span> <span class=\"n\">c</span> <span class=\"ow\">=</span> <span class=\"n\">c</span>\n\n\n<span class=\"c1\">-- ZFC</span>\n\n<span class=\"nf\">mkElem</span> <span class=\"ow\">::</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span>\n<span class=\"nf\">mkElem</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"kt\">Atom</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"s\">\"in\"</span> <span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">])</span>\n\n<span class=\"c1\">-- |- forall x. forall y. forall z. (z \\in x &lt;==&gt; z \\in y) =&gt; (x = y)</span>\n<span class=\"nf\">axiomExtensionality</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Thm</span>\n<span class=\"nf\">axiomExtensionality</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"ow\">=</span> <span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">y</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">z</span> <span class=\"p\">(</span><span class=\"kt\">Iff</span> <span class=\"p\">(</span><span class=\"n\">mkElem</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"n\">z</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"n\">x</span> <span class=\"kt\">[]</span><span class=\"p\">))</span> <span class=\"p\">(</span><span class=\"n\">mkElem</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"n\">z</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"n\">y</span> <span class=\"kt\">[]</span><span class=\"p\">))))))</span> <span class=\"p\">(</span><span class=\"n\">mkEq</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"n\">y</span><span class=\"p\">))</span>\n\n\n<span class=\"c1\">-- Derived</span>\n\n<span class=\"nf\">impRefl</span> <span class=\"ow\">::</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"kt\">FOL</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Thm</span>\n<span class=\"nf\">impRefl</span> <span class=\"n\">p</span> <span class=\"ow\">=</span> <span class=\"n\">modusPonens</span> <span class=\"p\">(</span><span class=\"n\">modusPonens</span> <span class=\"p\">(</span><span class=\"n\">axiomDistribImp</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">axiomAddImp</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">p</span><span class=\"p\">)))</span> <span class=\"p\">(</span><span class=\"n\">axiomAddImp</span> <span class=\"n\">p</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\">-- Example: *Main&gt; impRefl (Atom (Pred \"P\" []))</span>\n</code></pre></div>",
        "id": 266648402,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641180626
    },
    {
        "content": "<p>man this code is so cool!!! it's very clean and readable <span aria-label=\"heart eyes\" class=\"emoji emoji-1f60d\" role=\"img\" title=\"heart eyes\">:heart_eyes:</span> I have a suggestion though: you don't need to use String to represent bound variables <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> in fact you can use something similar to <a href=\"https://en.m.wikipedia.org/wiki/De_Bruijn_index\">de Bruijn indexing</a>. this would simplify the implementation even more</p>",
        "id": 266649962,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1641182846
    },
    {
        "content": "<p>Thank you. It is pretty much just a direct translation from the book (I hope).</p>",
        "id": 266650130,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641183051
    },
    {
        "content": "<p>It seems that FOL and set theory define different notions of predicates and functions, the latter being in terms of subsets of sets. How are these reconciled in FOL + ZFC?</p>",
        "id": 266712277,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641230649
    },
    {
        "content": "<p>Well, these exist on different levels: a FOL predicate is a piece of syntax, while a subset in ZFC is something internal. So I'm not sure in what sense they could or should be reconciled. Of course they are related by some axioms, such as the axiom schema of separation.</p>",
        "id": 266716028,
        "sender_full_name": "Reid Barton",
        "timestamp": 1641232362
    },
    {
        "content": "<p>Note that in the context of ZFC, a \"class\" is really just a FOL predicate with one free variable.</p>",
        "id": 266716131,
        "sender_full_name": "Reid Barton",
        "timestamp": 1641232420
    },
    {
        "content": "<p>I guess my core question is, how can I create code in a similar manner as above, but for proving theorems in ZFC (or the set theory most often used in textbooks, I think it is ZFC?)</p>",
        "id": 266716794,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641232759
    },
    {
        "content": "<p>Maybe you can find <a href=\"https://github.com/flypitch/flypitch/blob/master/src/zfc.lean\">this</a> helpful. It has been used to prove the independence of the continuum hypothesis.</p>",
        "id": 266718018,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1641233363
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/266716794\">said</a>:</p>\n<blockquote>\n<p>I guess my core question is, how can I create code in a similar manner as above, but for proving theorems in ZFC (or the set theory most often used in textbooks, I think it is ZFC?)</p>\n</blockquote>\n<p>In principle you just add the axioms of ZFC, and then the theorems you can prove from those axioms are the theorems of ZFC.<br>\nIn practice, I guess you would pretty quickly learn the origin of the phrase \"proof assistant\".</p>",
        "id": 266718457,
        "sender_full_name": "Reid Barton",
        "timestamp": 1641233517
    },
    {
        "content": "<p>you might want to take a look <a href=\"https://github.com/been-jamming/CORE\">https://github.com/been-jamming/CORE</a> <a href=\"http://been-jamming.github.io/CORE/\">been-jamming.github.io/CORE/</a></p>\n<p>fair warning: code isn't production quality though</p>",
        "id": 266720348,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1641234502
    },
    {
        "content": "<p>How does the axiom of replacement get translated, since we do not have quantification over formulas in FOL?</p>",
        "id": 266720469,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641234578
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/266720469\">said</a>:</p>\n<blockquote>\n<p>How does the axiom of replacement get translated, since we do not have quantification over formulas in FOL?</p>\n</blockquote>\n<p>in CORE, a toy theorem prover I linked, it does allow quantification over formulas <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> so maybe if you want a ZFC theorem prover that works you can just do whatever CORE does <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> but I'm not an expert so I'm not sure whether that's an orthodox way of doing things or not</p>",
        "id": 266721072,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1641234931
    },
    {
        "content": "<p>Same way you implemented the rest of the axioms, which (like replacement) are actually axiom schemas--the quantification is at the meta level, not internal.</p>",
        "id": 266721362,
        "sender_full_name": "Reid Barton",
        "timestamp": 1641235109
    },
    {
        "content": "<p>Does the grammar get changed to this:</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"kr\">type</span> <span class=\"kt\">Var</span> <span class=\"ow\">=</span> <span class=\"kt\">String</span>\n\n<span class=\"kr\">data</span> <span class=\"kt\">Formula</span> <span class=\"ow\">=</span> <span class=\"kt\">False</span>\n             <span class=\"o\">|</span> <span class=\"kt\">True</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Eq</span> <span class=\"kt\">Var</span> <span class=\"kt\">Var</span>\n             <span class=\"o\">|</span> <span class=\"kt\">In</span> <span class=\"kt\">Var</span> <span class=\"kt\">Var</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Not</span> <span class=\"kt\">Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">And</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Or</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Imp</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Iff</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Forall</span> <span class=\"kt\">Var</span> <span class=\"kt\">Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Exists</span> <span class=\"kt\">Var</span> <span class=\"kt\">Formula</span>\n               <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"kr\">type</span> <span class=\"kt\">Thm</span> <span class=\"ow\">=</span> <span class=\"kt\">Formula</span>\n</code></pre></div>",
        "id": 266721527,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641235237
    },
    {
        "content": "<p>Oh yes, you need to add the signature of the theory (here just the binary relation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∈</mo></mrow><annotation encoding=\"application/x-tex\">\\in</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">∈</span></span></span></span>) to the language, and then maybe add axioms saying that it is preserved by replacing things by equal things?<br>\nI didn't notice before that the statement of <code>axiomExtensionality</code> was nonsense, it needs to be an axiom about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∈</mo></mrow><annotation encoding=\"application/x-tex\">\\in</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">∈</span></span></span></span>, of course!</p>",
        "id": 266721790,
        "sender_full_name": "Reid Barton",
        "timestamp": 1641235424
    },
    {
        "content": "<p>I think it looks right now--since there aren't any function symbols, a \"term\" can only possibly be a variable.</p>",
        "id": 266721978,
        "sender_full_name": "Reid Barton",
        "timestamp": 1641235540
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"kr\">type</span> <span class=\"kt\">Thm</span> <span class=\"ow\">=</span> <span class=\"kt\">Formula</span>\n</code></pre></div>\n<p>Normally one would use something more robust than a type synonym to dissuade the user from treating an arbitrary formula as a theorem.</p>",
        "id": 266722052,
        "sender_full_name": "Reid Barton",
        "timestamp": 1641235581
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/266722052\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"kr\">type</span> <span class=\"kt\">Thm</span> <span class=\"ow\">=</span> <span class=\"kt\">Formula</span>\n</code></pre></div>\n<p>Normally one would use something more robust than a type synonym to dissuade the user from treating an arbitrary formula as a theorem.</p>\n</blockquote>\n<p>Yeah, I'm not sure how to do that in Haskell yet.</p>",
        "id": 266722225,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641235685
    },
    {
        "content": "<p>you probably want a newtype, not just a type alias</p>",
        "id": 266722294,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1641235728
    },
    {
        "content": "<p>The usual way is to put everything that can construct judgments (like <code>Thm</code>) in a single module, make <code>Thm</code> a newtype, export <code>Thm</code> and the field selector from that module, but don't export the constructor of <code>Thm</code>.</p>",
        "id": 266722658,
        "sender_full_name": "Reid Barton",
        "timestamp": 1641235918
    },
    {
        "content": "<p>I see.</p>",
        "id": 266722732,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641235942
    },
    {
        "content": "<p>Then you have a guarantee that (barring the use of stuff like <code>unsafeCoerce</code>) the only way to construct values of type <code>Thm</code> is using the methods exported from that module, and so once you check that they really correspond to the axioms of whatever system you're interested in, then you know that any <code>t :: Thm</code> constructed anywhere in the program must be a valid theorem. This is the \"LCF approach\" as I understand it.</p>",
        "id": 266723253,
        "sender_full_name": "Reid Barton",
        "timestamp": 1641236203
    },
    {
        "content": "<p>Something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"kr\">import</span> <span class=\"nn\">Prelude</span> <span class=\"k\">hiding</span> <span class=\"p\">(</span><span class=\"kt\">False</span><span class=\"p\">,</span> <span class=\"kt\">True</span><span class=\"p\">)</span>\n<span class=\"kr\">import</span> <span class=\"k\">qualified</span> <span class=\"nn\">Prelude</span> <span class=\"p\">(</span><span class=\"kt\">Bool</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">))</span>\n\n<span class=\"kr\">module</span> <span class=\"nn\">ITP</span> <span class=\"p\">(</span><span class=\"kt\">Theorem</span><span class=\"p\">,</span> <span class=\"nf\">modusPonens</span><span class=\"p\">,</span> <span class=\"nf\">etc</span><span class=\"o\">.</span><span class=\"p\">)</span>\n\n<span class=\"kr\">type</span> <span class=\"kt\">Var</span> <span class=\"ow\">=</span> <span class=\"kt\">String</span>\n\n<span class=\"kr\">data</span> <span class=\"kt\">Formula</span> <span class=\"ow\">=</span> <span class=\"kt\">False</span>\n             <span class=\"o\">|</span> <span class=\"kt\">True</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Eq</span> <span class=\"kt\">Var</span> <span class=\"kt\">Var</span> <span class=\"c1\">-- Var = Var</span>\n             <span class=\"o\">|</span> <span class=\"kt\">In</span> <span class=\"kt\">Var</span> <span class=\"kt\">Var</span> <span class=\"c1\">-- Var ∈ Var</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Not</span> <span class=\"kt\">Formula</span> <span class=\"c1\">-- ¬ Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">And</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Formula</span> <span class=\"c1\">-- Formula ∧ Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Or</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Formula</span> <span class=\"c1\">-- Formula ∨ Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Imp</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Formula</span> <span class=\"c1\">-- Formula → Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Iff</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Formula</span> <span class=\"c1\">-- Formula ↔ Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Forall</span> <span class=\"kt\">Var</span> <span class=\"kt\">Formula</span> <span class=\"c1\">-- ∀ Var. Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Exists</span> <span class=\"kt\">Var</span> <span class=\"kt\">Formula</span> <span class=\"c1\">-- ∃ Var. Formula</span>\n               <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"kr\">newtype</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"kt\">Formula</span>\n</code></pre></div>",
        "id": 266723522,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641236337
    },
    {
        "content": "<p>Right, except you probably also want to export a function <code>Theorem -&gt; Formula</code>, so that you can check what you proved</p>",
        "id": 266723716,
        "sender_full_name": "Reid Barton",
        "timestamp": 1641236406
    },
    {
        "content": "<p>And you want to export <code>Formula(..)</code> too</p>",
        "id": 266723836,
        "sender_full_name": "Reid Barton",
        "timestamp": 1641236439
    },
    {
        "content": "<p>You will need it to apply axiom schemas</p>",
        "id": 266723862,
        "sender_full_name": "Reid Barton",
        "timestamp": 1641236449
    },
    {
        "content": "<p>Of course for the moment there's no need to worry about any of this.</p>",
        "id": 266723915,
        "sender_full_name": "Reid Barton",
        "timestamp": 1641236474
    },
    {
        "content": "<p>Ok.</p>",
        "id": 266724064,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641236529
    },
    {
        "content": "<p>I looked at the way that metamath implements the axiom schemes. I'm not sure I understand why the set variables are required to be distinct.<br>\n<a href=\"http://cn.metamath.org/mpeuni/mmset.html#staxioms\">http://cn.metamath.org/mpeuni/mmset.html#staxioms</a></p>",
        "id": 266846177,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641321257
    },
    {
        "content": "<p>In order for metamath expressions to act like standard FOL expressions, you usually want all textually distinct variables to have distinctness conditions, because otherwise you get bound variable collapse issues when <code>\\forall x, \\exists y, P(x, y)</code> becomes <code>\\forall x, \\exists x, P(x, x)</code> (which is equivalent to <code>\\forall x, \\exists y, P(y, y)</code>)</p>",
        "id": 266846719,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641321571
    },
    {
        "content": "<p>In some cases the distinctness is not required, but the safest thing is to assume it in the axioms and maybe prove the non-distinct version as a derived theorem</p>",
        "id": 266846831,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641321621
    },
    {
        "content": "<p>Note that this is not distinctness in the sense that the set values are unequal (what you would write <code>x != y</code> in ZFC or lean), but rather that the <em>variables</em> are not the same variable</p>",
        "id": 266846954,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641321705
    },
    {
        "content": "<p>I see. Thank you.</p>",
        "id": 266855326,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641326306
    },
    {
        "content": "<p>Can the lambda calculus be formulated in such a way that the Curry–Howard correspondence has the same first order logic as that used with axiomatic set theory, that is, no functions and just the equality and member of predicates?</p>",
        "id": 266874460,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641336115
    },
    {
        "content": "<p>Is this correct for the logic of ZFC?</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"kr\">type</span> <span class=\"kt\">Var</span> <span class=\"ow\">=</span> <span class=\"kt\">String</span>\n\n<span class=\"kr\">data</span> <span class=\"kt\">Formula</span> <span class=\"ow\">=</span> <span class=\"kt\">Not</span> <span class=\"kt\">Formula</span> <span class=\"c1\">-- ~ Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Imp</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Formula</span> <span class=\"c1\">-- Formula -&gt; Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Forall</span> <span class=\"kt\">Var</span> <span class=\"kt\">Formula</span> <span class=\"c1\">-- forall Var. Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Eq</span> <span class=\"kt\">Var</span> <span class=\"kt\">Var</span> <span class=\"c1\">-- Var = Var</span>\n             <span class=\"o\">|</span> <span class=\"kt\">In</span> <span class=\"kt\">Var</span> <span class=\"kt\">Var</span> <span class=\"c1\">-- Var \\in Var</span>\n               <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"kr\">newtype</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"kt\">Formula</span>\n\n\n<span class=\"nf\">subFor</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span>\n<span class=\"nf\">subFor</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Not</span> <span class=\"p\">(</span><span class=\"n\">subFor</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n<span class=\"nf\">subFor</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"n\">subFor</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">subFor</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n<span class=\"nf\">subFor</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">z</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">z</span> <span class=\"o\">/=</span> <span class=\"n\">x</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">z</span> <span class=\"o\">/=</span> <span class=\"n\">y</span> <span class=\"kr\">then</span> <span class=\"kt\">Forall</span> <span class=\"n\">z</span> <span class=\"p\">(</span><span class=\"n\">subFor</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"subFor\"</span>\n<span class=\"nf\">subFor</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"o\">|</span> <span class=\"n\">x</span> <span class=\"o\">/=</span> <span class=\"n\">s</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">x</span> <span class=\"o\">/=</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"kt\">Eq</span> <span class=\"n\">s</span> <span class=\"n\">t</span>\n                    <span class=\"o\">|</span> <span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"n\">s</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">x</span> <span class=\"o\">/=</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"kt\">Eq</span> <span class=\"n\">y</span> <span class=\"n\">t</span>\n                    <span class=\"o\">|</span> <span class=\"n\">x</span> <span class=\"o\">/=</span> <span class=\"n\">s</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"kt\">Eq</span> <span class=\"n\">s</span> <span class=\"n\">y</span>\n                    <span class=\"o\">|</span> <span class=\"n\">otherwise</span> <span class=\"ow\">=</span> <span class=\"kt\">Eq</span> <span class=\"n\">y</span> <span class=\"n\">y</span>\n<span class=\"nf\">subFor</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">In</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"o\">|</span> <span class=\"n\">x</span> <span class=\"o\">/=</span> <span class=\"n\">s</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">x</span> <span class=\"o\">/=</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"kt\">In</span> <span class=\"n\">s</span> <span class=\"n\">t</span>\n                    <span class=\"o\">|</span> <span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"n\">s</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">x</span> <span class=\"o\">/=</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"kt\">In</span> <span class=\"n\">y</span> <span class=\"n\">t</span>\n                    <span class=\"o\">|</span> <span class=\"n\">x</span> <span class=\"o\">/=</span> <span class=\"n\">s</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"kt\">In</span> <span class=\"n\">s</span> <span class=\"n\">y</span>\n                    <span class=\"o\">|</span> <span class=\"n\">otherwise</span> <span class=\"ow\">=</span> <span class=\"kt\">In</span> <span class=\"n\">y</span> <span class=\"n\">y</span>\n\n\n<span class=\"nf\">freeIn</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">freeIn</span> <span class=\"n\">x</span> <span class=\"n\">p</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">freeIn</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"o\">||</span> <span class=\"n\">freeIn</span> <span class=\"n\">x</span> <span class=\"n\">q</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">y</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">x</span> <span class=\"o\">/=</span> <span class=\"n\">y</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">freeIn</span> <span class=\"n\">x</span> <span class=\"n\">p</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"n\">s</span> <span class=\"o\">||</span> <span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"n\">t</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">In</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"n\">s</span> <span class=\"o\">||</span> <span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"n\">t</span>\n\n\n<span class=\"c1\">-- Propositional calculus</span>\n\n<span class=\"c1\">-- |- (p -&gt; (q -&gt; p))</span>\n<span class=\"nf\">prop_1</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">prop_1</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">q</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- ((p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r)))</span>\n<span class=\"nf\">prop_2</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">prop_2</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">q</span> <span class=\"n\">r</span><span class=\"p\">))</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">r</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">-- |- ((~p -&gt; ~q) -&gt; (q -&gt; p))</span>\n<span class=\"nf\">prop_3</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">prop_3</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">q</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- p &amp; |- (p -&gt; q) =&gt; |- q</span>\n<span class=\"nf\">mp</span> <span class=\"ow\">::</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">mp</span> <span class=\"p\">(</span><span class=\"kt\">Theorem</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p'</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">p</span> <span class=\"o\">==</span> <span class=\"n\">p'</span> <span class=\"kr\">then</span> <span class=\"kt\">Theorem</span> <span class=\"n\">q</span> <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"mp\"</span>\n<span class=\"nf\">mp</span> <span class=\"kr\">_</span> <span class=\"kr\">_</span> <span class=\"ow\">=</span> <span class=\"ne\">error</span> <span class=\"s\">\"mp\"</span>\n\n\n<span class=\"c1\">-- Predicate calculus</span>\n\n<span class=\"c1\">-- |- p =&gt; |- forall x. p</span>\n<span class=\"nf\">gen</span> <span class=\"ow\">::</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">gen</span> <span class=\"p\">(</span><span class=\"kt\">Theorem</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">x</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n\n<span class=\"c1\">-- |- ((forall x. (p -&gt; q)) -&gt; (forall x. p) -&gt; (forall x. q))</span>\n<span class=\"nf\">pred_1</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">pred_1</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"n\">q</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">-- |- (forall x. p -&gt; p [y/x]) provided p admits y for x</span>\n<span class=\"nf\">pred_2</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">pred_2</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">p</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">subFor</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- (p -&gt; forall x. p) provided x is not free in p</span>\n<span class=\"nf\">pred_3</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">pred_3</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">not</span> <span class=\"p\">(</span><span class=\"n\">freeIn</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"kr\">then</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">))</span> <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"pred_3\"</span>\n\n\n<span class=\"c1\">-- Equality</span>\n\n<span class=\"c1\">-- |- forall x. x = x</span>\n<span class=\"nf\">eq_1</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">eq_1</span> <span class=\"n\">x</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- (x = y -&gt; (x = z -&gt; y = z))</span>\n<span class=\"nf\">eq_2</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">eq_2</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">x</span> <span class=\"n\">z</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">-- |- (x = y -&gt; (x \\in z -&gt; y \\in z))</span>\n<span class=\"nf\">eq_3</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">eq_3</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">In</span> <span class=\"n\">x</span> <span class=\"n\">z</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">In</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">-- |- (x = y -&gt; (z \\in x -&gt; z \\in y))</span>\n<span class=\"nf\">eq_4</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">eq_4</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">In</span> <span class=\"n\">z</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">In</span> <span class=\"n\">z</span> <span class=\"n\">y</span><span class=\"p\">)))</span>\n</code></pre></div>",
        "id": 266895878,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641355737
    },
    {
        "content": "<p>No, wait, I think the subFor function is wrong.</p>",
        "id": 266895978,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641355857
    },
    {
        "content": "<p>Amended (I think).</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"kr\">type</span> <span class=\"kt\">Var</span> <span class=\"ow\">=</span> <span class=\"kt\">String</span>\n\n<span class=\"kr\">data</span> <span class=\"kt\">Formula</span> <span class=\"ow\">=</span> <span class=\"kt\">Not</span> <span class=\"kt\">Formula</span> <span class=\"c1\">-- ~ Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Imp</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Formula</span> <span class=\"c1\">-- Formula -&gt; Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Forall</span> <span class=\"kt\">Var</span> <span class=\"kt\">Formula</span> <span class=\"c1\">-- forall Var. Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Eq</span> <span class=\"kt\">Var</span> <span class=\"kt\">Var</span> <span class=\"c1\">-- Var = Var</span>\n             <span class=\"o\">|</span> <span class=\"kt\">In</span> <span class=\"kt\">Var</span> <span class=\"kt\">Var</span> <span class=\"c1\">-- Var \\in Var</span>\n               <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"kr\">newtype</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"kt\">Formula</span>\n\n\n<span class=\"nf\">subFor</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span>\n<span class=\"nf\">subFor</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Not</span> <span class=\"p\">(</span><span class=\"n\">subFor</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n<span class=\"nf\">subFor</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"n\">subFor</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">subFor</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n<span class=\"nf\">subFor</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">z</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"o\">|</span> <span class=\"n\">z</span> <span class=\"o\">==</span> <span class=\"n\">x</span> <span class=\"ow\">=</span> <span class=\"kt\">Forall</span> <span class=\"n\">z</span> <span class=\"n\">p</span>\n                        <span class=\"o\">|</span> <span class=\"n\">otherwise</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">z</span> <span class=\"o\">/=</span> <span class=\"n\">y</span> <span class=\"kr\">then</span> <span class=\"kt\">Forall</span> <span class=\"n\">z</span> <span class=\"p\">(</span><span class=\"n\">subFor</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"subFor\"</span>\n<span class=\"nf\">subFor</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"o\">|</span> <span class=\"n\">x</span> <span class=\"o\">/=</span> <span class=\"n\">s</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">x</span> <span class=\"o\">/=</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"kt\">Eq</span> <span class=\"n\">s</span> <span class=\"n\">t</span>\n                    <span class=\"o\">|</span> <span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"n\">s</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">x</span> <span class=\"o\">/=</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"kt\">Eq</span> <span class=\"n\">y</span> <span class=\"n\">t</span>\n                    <span class=\"o\">|</span> <span class=\"n\">x</span> <span class=\"o\">/=</span> <span class=\"n\">s</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"kt\">Eq</span> <span class=\"n\">s</span> <span class=\"n\">y</span>\n                    <span class=\"o\">|</span> <span class=\"n\">otherwise</span> <span class=\"ow\">=</span> <span class=\"kt\">Eq</span> <span class=\"n\">y</span> <span class=\"n\">y</span>\n<span class=\"nf\">subFor</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">In</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"o\">|</span> <span class=\"n\">x</span> <span class=\"o\">/=</span> <span class=\"n\">s</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">x</span> <span class=\"o\">/=</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"kt\">In</span> <span class=\"n\">s</span> <span class=\"n\">t</span>\n                    <span class=\"o\">|</span> <span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"n\">s</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">x</span> <span class=\"o\">/=</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"kt\">In</span> <span class=\"n\">y</span> <span class=\"n\">t</span>\n                    <span class=\"o\">|</span> <span class=\"n\">x</span> <span class=\"o\">/=</span> <span class=\"n\">s</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"kt\">In</span> <span class=\"n\">s</span> <span class=\"n\">y</span>\n                    <span class=\"o\">|</span> <span class=\"n\">otherwise</span> <span class=\"ow\">=</span> <span class=\"kt\">In</span> <span class=\"n\">y</span> <span class=\"n\">y</span>\n\n\n<span class=\"nf\">freeIn</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">freeIn</span> <span class=\"n\">x</span> <span class=\"n\">p</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">freeIn</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"o\">||</span> <span class=\"n\">freeIn</span> <span class=\"n\">x</span> <span class=\"n\">q</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">y</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">x</span> <span class=\"o\">/=</span> <span class=\"n\">y</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">freeIn</span> <span class=\"n\">x</span> <span class=\"n\">p</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"n\">s</span> <span class=\"o\">||</span> <span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"n\">t</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">In</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"n\">s</span> <span class=\"o\">||</span> <span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"n\">t</span>\n\n\n<span class=\"c1\">-- Propositional calculus</span>\n\n<span class=\"c1\">-- |- (p -&gt; (q -&gt; p))</span>\n<span class=\"nf\">prop_1</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">prop_1</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">q</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- ((p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r)))</span>\n<span class=\"nf\">prop_2</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">prop_2</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">q</span> <span class=\"n\">r</span><span class=\"p\">))</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">r</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">-- |- ((~p -&gt; ~q) -&gt; (q -&gt; p))</span>\n<span class=\"nf\">prop_3</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">prop_3</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">q</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- p &amp; |- (p -&gt; q) =&gt; |- q</span>\n<span class=\"nf\">mp</span> <span class=\"ow\">::</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">mp</span> <span class=\"p\">(</span><span class=\"kt\">Theorem</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p'</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">p</span> <span class=\"o\">==</span> <span class=\"n\">p'</span> <span class=\"kr\">then</span> <span class=\"kt\">Theorem</span> <span class=\"n\">q</span> <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"mp\"</span>\n<span class=\"nf\">mp</span> <span class=\"kr\">_</span> <span class=\"kr\">_</span> <span class=\"ow\">=</span> <span class=\"ne\">error</span> <span class=\"s\">\"mp\"</span>\n\n\n<span class=\"c1\">-- Predicate calculus</span>\n\n<span class=\"c1\">-- |- p =&gt; |- forall x. p</span>\n<span class=\"nf\">gen</span> <span class=\"ow\">::</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">gen</span> <span class=\"p\">(</span><span class=\"kt\">Theorem</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">x</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n\n<span class=\"c1\">-- |- ((forall x. (p -&gt; q)) -&gt; (forall x. p) -&gt; (forall x. q))</span>\n<span class=\"nf\">pred_1</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">pred_1</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"n\">q</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">-- |- (forall x. p -&gt; p [y/x]) provided p admits y for x</span>\n<span class=\"nf\">pred_2</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">pred_2</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">p</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">subFor</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- (p -&gt; forall x. p) provided x is not free in p</span>\n<span class=\"nf\">pred_3</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">pred_3</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">not</span> <span class=\"p\">(</span><span class=\"n\">freeIn</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"kr\">then</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">))</span> <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"pred_3\"</span>\n\n\n<span class=\"c1\">-- Equality</span>\n\n<span class=\"c1\">-- |- forall x. x = x</span>\n<span class=\"nf\">eq_1</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">eq_1</span> <span class=\"n\">x</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- (x = y -&gt; (x = z -&gt; y = z))</span>\n<span class=\"nf\">eq_2</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">eq_2</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">x</span> <span class=\"n\">z</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">-- |- (x = y -&gt; (x \\in z -&gt; y \\in z))</span>\n<span class=\"nf\">eq_3</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">eq_3</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">In</span> <span class=\"n\">x</span> <span class=\"n\">z</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">In</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">-- |- (x = y -&gt; (z \\in x -&gt; z \\in y))</span>\n<span class=\"nf\">eq_4</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">eq_4</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">In</span> <span class=\"n\">z</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">In</span> <span class=\"n\">z</span> <span class=\"n\">y</span><span class=\"p\">)))</span>\n</code></pre></div>",
        "id": 266896146,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641356070
    },
    {
        "content": "<p>Hmm, no, still wrong. Sorry for the spam.</p>",
        "id": 266896458,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641356437
    },
    {
        "content": "<p>Is this correct for the logic of ZFC?</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"kr\">type</span> <span class=\"kt\">Var</span> <span class=\"ow\">=</span> <span class=\"kt\">String</span>\n\n<span class=\"kr\">data</span> <span class=\"kt\">Formula</span> <span class=\"ow\">=</span> <span class=\"kt\">Not</span> <span class=\"kt\">Formula</span> <span class=\"c1\">-- ~ Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Imp</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Formula</span> <span class=\"c1\">-- Formula -&gt; Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Forall</span> <span class=\"kt\">Var</span> <span class=\"kt\">Formula</span> <span class=\"c1\">-- forall Var. Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Eq</span> <span class=\"kt\">Var</span> <span class=\"kt\">Var</span> <span class=\"c1\">-- Var = Var</span>\n             <span class=\"o\">|</span> <span class=\"kt\">In</span> <span class=\"kt\">Var</span> <span class=\"kt\">Var</span> <span class=\"c1\">-- Var \\in Var</span>\n               <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"kr\">newtype</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"kt\">Formula</span>\n\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">An occurrence of a variable $v$ in a formula $P$ is bound if and only if</span>\n<span class=\"cm\">it occurs in a subformula of $P$ of the form $\\forall v Q$. An occurrence</span>\n<span class=\"cm\">of $v$ in $P$ is free if and only if it is not a bound occurrence. The</span>\n<span class=\"cm\">variable $v$ is free or bound in $P$ according as it has a free or bound</span>\n<span class=\"cm\"> occurrence in $P$.</span>\n\n<span class=\"cm\">If $P$ is a formula, $v$ is a variable, and $t$ is a term, then $P(t/v)$ is</span>\n<span class=\"cm\">the result of replacing each free occurrence of $v$ in $P$ by an occurrence</span>\n<span class=\"cm\">of $t$.</span>\n\n<span class=\"cm\">If $v$ and $u$ are variables and $P$ is a formula, then $P$ admits $u$ for $v$</span>\n<span class=\"cm\">if and only if there is no free occurrence of $v$ in $P$ that becomes a</span>\n<span class=\"cm\">bound occurrence of $u$ in $P(u/v)$. If $t$ is a term, then $P$ admits $t$ for</span>\n<span class=\"cm\">$v$ if and only if $P$ admits for $v$ every variable in $t$.</span>\n<span class=\"cm\">-}</span>\n\n<span class=\"c1\">-- occursIn v p = v occurs in p</span>\n<span class=\"nf\">occursIn</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">occursIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">occursIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span>\n<span class=\"nf\">occursIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">occursIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"o\">||</span> <span class=\"n\">occursIn</span> <span class=\"n\">v</span> <span class=\"n\">q</span>\n<span class=\"nf\">occursIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"kr\">_</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">occursIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span>\n<span class=\"nf\">occursIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">x</span> <span class=\"o\">||</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">y</span>\n<span class=\"nf\">occursIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">In</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">x</span> <span class=\"o\">||</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">y</span>\n\n<span class=\"c1\">-- freeIn v p = there exists an occurrence of v in p that is free.</span>\n<span class=\"nf\">freeIn</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"o\">||</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">q</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">v</span> <span class=\"o\">/=</span> <span class=\"n\">x</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">x</span> <span class=\"o\">||</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">y</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">In</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">x</span> <span class=\"o\">||</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">y</span>\n\n<span class=\"c1\">-- admitsFor p u v [] = p admits u for v = there is no free occurrence of</span>\n<span class=\"c1\">-- v in p that becomes a bound occurrence of u in p(u/v).</span>\n<span class=\"c1\">-- xs is the list of binding variables that p is in the scope of.</span>\n<span class=\"nf\">admitsFor</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">Var</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">admitsFor</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">xs</span> <span class=\"ow\">=</span> <span class=\"n\">admitsFor</span> <span class=\"n\">p</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">xs</span>\n<span class=\"nf\">admitsFor</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">xs</span> <span class=\"ow\">=</span> <span class=\"n\">admitsFor</span> <span class=\"n\">p</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">xs</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">admitsFor</span> <span class=\"n\">q</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">xs</span>\n<span class=\"nf\">admitsFor</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">xs</span> <span class=\"ow\">=</span> <span class=\"n\">admitsFor</span> <span class=\"n\">p</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"kt\">:</span> <span class=\"n\">xs</span><span class=\"p\">)</span>\n<span class=\"nf\">admitsFor</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">xs</span> <span class=\"ow\">=</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">/=</span> <span class=\"n\">x</span> <span class=\"o\">||</span> <span class=\"n\">elem</span> <span class=\"n\">v</span> <span class=\"n\">xs</span> <span class=\"o\">||</span> <span class=\"n\">not</span> <span class=\"p\">(</span><span class=\"n\">elem</span> <span class=\"n\">u</span> <span class=\"n\">xs</span><span class=\"p\">))</span> <span class=\"o\">&amp;&amp;</span>\n                            <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">/=</span> <span class=\"n\">y</span> <span class=\"o\">||</span> <span class=\"n\">elem</span> <span class=\"n\">v</span> <span class=\"n\">xs</span> <span class=\"o\">||</span> <span class=\"n\">not</span> <span class=\"p\">(</span><span class=\"n\">elem</span> <span class=\"n\">u</span> <span class=\"n\">xs</span><span class=\"p\">))</span>\n<span class=\"nf\">admitsFor</span> <span class=\"p\">(</span><span class=\"kt\">In</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">xs</span> <span class=\"ow\">=</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">/=</span> <span class=\"n\">x</span> <span class=\"o\">||</span> <span class=\"n\">elem</span> <span class=\"n\">v</span> <span class=\"n\">xs</span> <span class=\"o\">||</span> <span class=\"n\">not</span> <span class=\"p\">(</span><span class=\"n\">elem</span> <span class=\"n\">u</span> <span class=\"n\">xs</span><span class=\"p\">))</span> <span class=\"o\">&amp;&amp;</span>\n                            <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">/=</span> <span class=\"n\">y</span> <span class=\"o\">||</span> <span class=\"n\">elem</span> <span class=\"n\">v</span> <span class=\"n\">xs</span> <span class=\"o\">||</span> <span class=\"n\">not</span> <span class=\"p\">(</span><span class=\"n\">elem</span> <span class=\"n\">u</span> <span class=\"n\">xs</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- subFor t v p = p(v/t) = the result of replacing each free occurrence of</span>\n<span class=\"c1\">-- v in P by an occurrence of t.</span>\n<span class=\"nf\">subFor</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span>\n<span class=\"nf\">subFor</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Not</span> <span class=\"p\">(</span><span class=\"n\">subFor</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n<span class=\"nf\">subFor</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"n\">subFor</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">subFor</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n<span class=\"nf\">subFor</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"o\">|</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">x</span> <span class=\"ow\">=</span> <span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"n\">p</span>\n                        <span class=\"o\">|</span> <span class=\"n\">otherwise</span> <span class=\"ow\">=</span> <span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"n\">subFor</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n<span class=\"nf\">subFor</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"o\">|</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">x</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">y</span> <span class=\"ow\">=</span> <span class=\"kt\">Eq</span> <span class=\"n\">t</span> <span class=\"n\">t</span>\n                    <span class=\"o\">|</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">x</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">v</span> <span class=\"o\">/=</span> <span class=\"n\">y</span> <span class=\"ow\">=</span> <span class=\"kt\">Eq</span> <span class=\"n\">t</span> <span class=\"n\">y</span>\n                    <span class=\"o\">|</span> <span class=\"n\">v</span> <span class=\"o\">/=</span> <span class=\"n\">x</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">y</span> <span class=\"ow\">=</span> <span class=\"kt\">Eq</span> <span class=\"n\">x</span> <span class=\"n\">t</span>\n                    <span class=\"o\">|</span> <span class=\"n\">otherwise</span> <span class=\"ow\">=</span> <span class=\"kt\">Eq</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n<span class=\"nf\">subFor</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">In</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"o\">|</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">x</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">y</span> <span class=\"ow\">=</span> <span class=\"kt\">In</span> <span class=\"n\">t</span> <span class=\"n\">t</span>\n                    <span class=\"o\">|</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">x</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">v</span> <span class=\"o\">/=</span> <span class=\"n\">y</span> <span class=\"ow\">=</span> <span class=\"kt\">In</span> <span class=\"n\">t</span> <span class=\"n\">y</span>\n                    <span class=\"o\">|</span> <span class=\"n\">v</span> <span class=\"o\">/=</span> <span class=\"n\">x</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">y</span> <span class=\"ow\">=</span> <span class=\"kt\">In</span> <span class=\"n\">x</span> <span class=\"n\">t</span>\n                    <span class=\"o\">|</span> <span class=\"n\">otherwise</span> <span class=\"ow\">=</span> <span class=\"kt\">In</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n\n\n<span class=\"c1\">-- Propositional calculus</span>\n\n<span class=\"c1\">-- |- (p -&gt; (q -&gt; p))</span>\n<span class=\"nf\">prop_1</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">prop_1</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">q</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- ((p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r)))</span>\n<span class=\"nf\">prop_2</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">prop_2</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">q</span> <span class=\"n\">r</span><span class=\"p\">))</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">r</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">-- |- ((~p -&gt; ~q) -&gt; (q -&gt; p))</span>\n<span class=\"nf\">prop_3</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">prop_3</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">q</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- p &amp; |- (p -&gt; q) =&gt; |- q</span>\n<span class=\"nf\">mp</span> <span class=\"ow\">::</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">mp</span> <span class=\"p\">(</span><span class=\"kt\">Theorem</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p'</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">p</span> <span class=\"o\">==</span> <span class=\"n\">p'</span> <span class=\"kr\">then</span> <span class=\"kt\">Theorem</span> <span class=\"n\">q</span> <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"mp\"</span>\n<span class=\"nf\">mp</span> <span class=\"kr\">_</span> <span class=\"kr\">_</span> <span class=\"ow\">=</span> <span class=\"ne\">error</span> <span class=\"s\">\"mp\"</span>\n\n\n<span class=\"c1\">-- Predicate calculus</span>\n\n<span class=\"c1\">-- |- p =&gt; |- forall v. p</span>\n<span class=\"nf\">gen</span> <span class=\"ow\">::</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">gen</span> <span class=\"p\">(</span><span class=\"kt\">Theorem</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n\n<span class=\"c1\">-- |- ((forall v. (p -&gt; q)) -&gt; (forall v. p) -&gt; (forall v. q))</span>\n<span class=\"nf\">pred_1</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">pred_1</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"n\">q</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">-- |- (forall v. p -&gt; p [t/v]) provided p admits t for v</span>\n<span class=\"nf\">pred_2</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">pred_2</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">admitsFor</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"kt\">[]</span>\n               <span class=\"kr\">then</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">subFor</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n               <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"pred_2\"</span>\n\n<span class=\"c1\">-- |- (p -&gt; forall v. p) provided v is not free in p</span>\n<span class=\"nf\">pred_3</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">pred_3</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">not</span> <span class=\"p\">(</span><span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n             <span class=\"kr\">then</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n             <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"pred_3\"</span>\n\n\n<span class=\"c1\">-- Equality</span>\n\n<span class=\"c1\">-- |- forall x. x = x</span>\n<span class=\"nf\">eq_1</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">eq_1</span> <span class=\"n\">x</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- (x = y -&gt; (x = z -&gt; y = z))</span>\n<span class=\"nf\">eq_2</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">eq_2</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">x</span> <span class=\"n\">z</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">-- |- (x = y -&gt; (x \\in z -&gt; y \\in z))</span>\n<span class=\"nf\">eq_3</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">eq_3</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">In</span> <span class=\"n\">x</span> <span class=\"n\">z</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">In</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">-- |- (x = y -&gt; (z \\in x -&gt; z \\in y))</span>\n<span class=\"nf\">eq_4</span> <span class=\"ow\">::</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">eq_4</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">In</span> <span class=\"n\">z</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">In</span> <span class=\"n\">z</span> <span class=\"n\">y</span><span class=\"p\">)))</span>\n</code></pre></div>",
        "id": 266902993,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641365077
    },
    {
        "content": "<p>This code is soooo cool! One thing: you can use pattern synonyms to define <code>mkEq</code>, and it will not only serve as a function but it can <em>also</em> be used to pattern match</p>",
        "id": 266967586,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1641405295
    },
    {
        "content": "<p>Thank you. It is in large part just a translation from the OCaml code in  \"Handbook of Practical Logic and Automated Reasoning\" by John Harrison [https://www.cl.cam.ac.uk/~jrh13/atp/index.html].</p>",
        "id": 266972249,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641407529
    },
    {
        "content": "<p>I'm not sure how the axioms change if I change to De Bruijn indexing or locally nameless variables. Do they? Do pred_2 and pred_3 change?</p>",
        "id": 266982887,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641412619
    },
    {
        "content": "<p>You are probably going to have to figure out several subtleties if you go to dBI</p>",
        "id": 266997646,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1641420125
    },
    {
        "content": "<p>The tradition in first order logic is to use named variables, and there're lots of irks and quirks that are well-studied, like eigenvariables and stuff</p>",
        "id": 266997819,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1641420235
    },
    {
        "content": "<p>This is because variables never go into context. In type theories like Lean's, there may be something like <code>x : nat</code> before the turnstile; In first order logic, only propositions ever do. Hilbert-style systems even don't allow anything to go \"before the turnstile\", in some sense</p>",
        "id": 266998132,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1641420390
    },
    {
        "content": "<p>A lot of the weird restrictions on free variable occurence in FOL can be very well explained by writing them out in type theoretic (aka higher order logic) style, and realizing that they do no more than implicitly handling non-propositional terms in the context</p>",
        "id": 266998463,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1641420577
    },
    {
        "content": "<p>I don't think non-propositional terms themselves account for free variable restrictions. The analogue of free variable restrictions in type theory is scope restriction: an expression can only depend on the variables in scope (it carries its context with it, and can't be used in a context which does not extend the original). Also, substitution needs to know to avoid variables under a lambda</p>",
        "id": 267000601,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641421569
    },
    {
        "content": "<p>Here's a standard example of scope violation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">existsi</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The proof by <code>refl</code> (to prove <code>?m = y</code>) would work if not for the fact that <code>?m</code> has a scope that does not include <code>y</code></p>",
        "id": 267001039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641421794
    },
    {
        "content": "<p>Is the code correct as is?</p>",
        "id": 267004153,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641423652
    },
    {
        "content": "<p>no, it gives an error at <code>refl</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">apply</span> <span class=\"n\">tactic</span><span class=\"o\">,</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">unify</span>\n  <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n<span class=\"k\">with</span>\n  <span class=\"bp\">?</span><span class=\"n\">m_3</span> <span class=\"bp\">=</span> <span class=\"bp\">?</span><span class=\"n\">m_3</span>\n</code></pre></div>",
        "id": 267006575,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641425164
    },
    {
        "content": "<p>I'm sorry, I meant the Haskell code.</p>",
        "id": 267006833,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641425336
    },
    {
        "content": "<p>I have code to define formulas with locally nameless variables and convert them to and from named variables, but I'm not sure how to define substitution for them, that is, the result of replacing one term by another in a formula. I'm not sure I understand the advantage of the locally nameless terms in this case, because if you are trying to replace a free variable by one that will become bound, then don't you still have to check and alpha convert for that?</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"c1\">-- Adapted from https://boarders.github.io/posts/locally-nameless/</span>\n\n<span class=\"kr\">import</span> <span class=\"nn\">Prelude</span> <span class=\"k\">hiding</span> <span class=\"p\">(</span><span class=\"kt\">False</span><span class=\"p\">,</span> <span class=\"kt\">True</span><span class=\"p\">)</span>\n<span class=\"kr\">import</span> <span class=\"k\">qualified</span> <span class=\"nn\">Prelude</span> <span class=\"p\">(</span><span class=\"kt\">Bool</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">))</span>\n\n<span class=\"kr\">import</span> <span class=\"nn\">Data.List</span>\n<span class=\"kr\">import</span> <span class=\"nn\">Data.Map</span>\n\n\n<span class=\"c1\">-- Func \"c\" [] : A constant named c</span>\n<span class=\"kr\">data</span> <span class=\"kt\">Term</span> <span class=\"n\">a</span> <span class=\"ow\">=</span> <span class=\"kt\">Var</span> <span class=\"n\">a</span>\n            <span class=\"o\">|</span> <span class=\"kt\">Func</span> <span class=\"kt\">String</span> <span class=\"p\">[</span><span class=\"kt\">Term</span> <span class=\"n\">a</span><span class=\"p\">]</span>\n              <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"kr\">data</span> <span class=\"kt\">Formula</span> <span class=\"n\">a</span> <span class=\"ow\">=</span> <span class=\"kt\">False</span>\n               <span class=\"o\">|</span> <span class=\"kt\">True</span>\n               <span class=\"o\">|</span> <span class=\"kt\">Pred</span> <span class=\"kt\">String</span> <span class=\"p\">[</span><span class=\"kt\">Term</span> <span class=\"n\">a</span><span class=\"p\">]</span>        <span class=\"c1\">-- Pred \"P\" [] : A propositional variable named P</span>\n               <span class=\"o\">|</span> <span class=\"kt\">Not</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span>             <span class=\"c1\">-- ~ Formula</span>\n               <span class=\"o\">|</span> <span class=\"kt\">And</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"c1\">-- Formula /\\ Formula</span>\n               <span class=\"o\">|</span> <span class=\"kt\">Or</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span>  <span class=\"c1\">-- Formula \\/ Formula</span>\n               <span class=\"o\">|</span> <span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"c1\">-- Formula -&gt; Formula</span>\n               <span class=\"o\">|</span> <span class=\"kt\">Iff</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"c1\">-- Formula &lt;-&gt; Formula</span>\n               <span class=\"o\">|</span> <span class=\"kt\">Forall</span> <span class=\"n\">a</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span>        <span class=\"c1\">-- forall Var. Formula</span>\n               <span class=\"o\">|</span> <span class=\"kt\">Exists</span> <span class=\"n\">a</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span>        <span class=\"c1\">-- exists Var. Formula</span>\n                 <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\">-- The type of named variables.</span>\n<span class=\"kr\">type</span> <span class=\"kt\">NV</span> <span class=\"ow\">=</span> <span class=\"kt\">String</span>\n\n\n<span class=\"c1\">-- The type of locally nameless variables.</span>\n<span class=\"kr\">data</span> <span class=\"kt\">LN</span> <span class=\"ow\">=</span> <span class=\"kt\">F</span> <span class=\"kt\">String</span> <span class=\"c1\">-- The name of a free variable or a binding variable.</span>\n        <span class=\"o\">|</span> <span class=\"kt\">B</span> <span class=\"kt\">Int</span>    <span class=\"c1\">-- The De Bruijn index of a bound variable.</span>\n          <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span><span class=\"p\">,</span> <span class=\"kt\">Show</span><span class=\"p\">)</span>\n\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Translates a named variable formula to a locally nameless formula.</span>\n<span class=\"cm\">Keeps the name of each free variable and binding variable. Changes the name of</span>\n<span class=\"cm\">each bound variable to its De Bruijn index.</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">formulaToLN</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"kt\">NV</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"kt\">LN</span>\n<span class=\"nf\">formulaToLN</span> <span class=\"n\">formula</span> <span class=\"ow\">=</span> <span class=\"n\">go</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"n\">empty</span> <span class=\"n\">formula</span>\n  <span class=\"kr\">where</span>\n    <span class=\"cm\">{-</span>\n<span class=\"cm\">    The mapping is from the name of each binding variable to its De Bruijn</span>\n<span class=\"cm\">    index at the current depth.</span>\n<span class=\"cm\">    -}</span>\n    <span class=\"n\">go</span> <span class=\"ow\">::</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"kt\">Map</span> <span class=\"kt\">String</span> <span class=\"kt\">Int</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"kt\">NV</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"kt\">LN</span>\n    <span class=\"n\">go</span> <span class=\"kr\">_</span> <span class=\"kt\">False</span> <span class=\"ow\">=</span> <span class=\"kt\">False</span>\n    <span class=\"n\">go</span> <span class=\"kr\">_</span> <span class=\"kt\">True</span> <span class=\"ow\">=</span> <span class=\"kt\">True</span>\n    <span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"n\">name</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Pred</span> <span class=\"n\">name</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">map</span> <span class=\"p\">(</span><span class=\"n\">termToLN</span> <span class=\"n\">env</span><span class=\"p\">)</span> <span class=\"n\">terms</span><span class=\"p\">)</span>\n      <span class=\"kr\">where</span>\n        <span class=\"c1\">-- Translates a named variable term to a locally nameless term.</span>\n        <span class=\"cm\">{-</span>\n<span class=\"cm\">        The mapping is from the name of each binding variable to its De Bruijn</span>\n<span class=\"cm\">        index at the current depth.</span>\n<span class=\"cm\">        -}</span>\n        <span class=\"n\">termToLN</span> <span class=\"ow\">::</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"kt\">Map</span> <span class=\"kt\">String</span> <span class=\"kt\">Int</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"kt\">NV</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"kt\">LN</span>\n        <span class=\"n\">termToLN</span> <span class=\"n\">env</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"n\">name</span><span class=\"p\">)</span> <span class=\"ow\">=</span>\n          <span class=\"kr\">case</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"n\">lookup</span> <span class=\"n\">name</span> <span class=\"n\">env</span> <span class=\"kr\">of</span>\n            <span class=\"cm\">{-</span>\n<span class=\"cm\">            The variable name is a key in the map. Therefore it has the same</span>\n<span class=\"cm\">            name as a binding variable. Therefore it is a bound variable.</span>\n<span class=\"cm\">            Then the De Bruijn index of the binding variable it matches is</span>\n<span class=\"cm\">            used.</span>\n<span class=\"cm\">            -}</span>\n            <span class=\"kt\">Just</span> <span class=\"n\">index</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"p\">(</span><span class=\"kt\">B</span> <span class=\"n\">index</span><span class=\"p\">)</span>\n            <span class=\"cm\">{-</span>\n<span class=\"cm\">            The variable name is not a key in the map. Therefore it is a free</span>\n<span class=\"cm\">            variable. Then its name is kept.</span>\n<span class=\"cm\">            -}</span>\n            <span class=\"kt\">Nothing</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"p\">(</span><span class=\"kt\">F</span> <span class=\"n\">name</span><span class=\"p\">)</span>\n        <span class=\"n\">termToLN</span> <span class=\"n\">env</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"n\">name</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Func</span> <span class=\"n\">name</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">map</span> <span class=\"p\">(</span><span class=\"n\">termToLN</span> <span class=\"n\">env</span><span class=\"p\">)</span> <span class=\"n\">terms</span><span class=\"p\">)</span>\n    <span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Not</span> <span class=\"p\">(</span><span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n    <span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"p\">(</span><span class=\"kt\">And</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">And</span> <span class=\"p\">(</span><span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n    <span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"p\">(</span><span class=\"kt\">Or</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Or</span> <span class=\"p\">(</span><span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n    <span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n    <span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"p\">(</span><span class=\"kt\">Iff</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Iff</span> <span class=\"p\">(</span><span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n    <span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">name</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span>\n      <span class=\"cm\">{-</span>\n<span class=\"cm\">      Since a binding variable has been gone under, the De Bruijn index of</span>\n<span class=\"cm\">      each binding variable at the current depth is increased by 1 and the</span>\n<span class=\"cm\">      De Bruijn index of the encountered binding variable at the current</span>\n<span class=\"cm\">      depth is set to 0.</span>\n<span class=\"cm\">      -}</span>\n      <span class=\"kr\">let</span> <span class=\"n\">env'</span> <span class=\"ow\">=</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"n\">insert</span> <span class=\"n\">name</span> <span class=\"mi\">0</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"n\">map</span> <span class=\"p\">(</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">env</span><span class=\"p\">)</span> <span class=\"kr\">in</span>\n      <span class=\"kt\">Forall</span> <span class=\"p\">(</span><span class=\"kt\">F</span> <span class=\"n\">name</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">go</span> <span class=\"n\">env'</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"c1\">-- The name of the binding variable is kept.</span>\n    <span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"p\">(</span><span class=\"kt\">Exists</span> <span class=\"n\">name</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span>\n      <span class=\"kr\">let</span> <span class=\"n\">env'</span> <span class=\"ow\">=</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"n\">insert</span> <span class=\"n\">name</span> <span class=\"mi\">0</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"n\">map</span> <span class=\"p\">(</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">env</span><span class=\"p\">)</span> <span class=\"kr\">in</span>\n      <span class=\"kt\">Exists</span> <span class=\"p\">(</span><span class=\"kt\">F</span> <span class=\"n\">name</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">go</span> <span class=\"n\">env'</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"c1\">-- The name of the binding variable is kept.</span>\n\n\n<span class=\"c1\">-- Translates a locally nameless formula to a named variable formula.</span>\n<span class=\"nf\">formulaFromLN</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"kt\">LN</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"kt\">NV</span>\n<span class=\"nf\">formulaFromLN</span> <span class=\"n\">formula</span> <span class=\"ow\">=</span> <span class=\"n\">go</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"n\">empty</span> <span class=\"n\">formula</span>\n  <span class=\"kr\">where</span>\n    <span class=\"cm\">{-</span>\n<span class=\"cm\">    The mapping is from the De Bruijn index of each binding variable at the</span>\n<span class=\"cm\">    current depth to its name.</span>\n<span class=\"cm\">    -}</span>\n    <span class=\"n\">go</span> <span class=\"ow\">::</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"kt\">Map</span> <span class=\"kt\">Int</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"kt\">LN</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"kt\">NV</span>\n    <span class=\"n\">go</span> <span class=\"kr\">_</span> <span class=\"kt\">False</span> <span class=\"ow\">=</span> <span class=\"kt\">False</span>\n    <span class=\"n\">go</span> <span class=\"kr\">_</span> <span class=\"kt\">True</span> <span class=\"ow\">=</span> <span class=\"kt\">True</span>\n    <span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"n\">name</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Pred</span> <span class=\"n\">name</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">map</span> <span class=\"p\">(</span><span class=\"n\">termFromLN</span> <span class=\"n\">env</span><span class=\"p\">)</span> <span class=\"n\">terms</span><span class=\"p\">)</span>\n      <span class=\"kr\">where</span>\n        <span class=\"c1\">-- Translates a locally nameless term to a named variable term.</span>\n        <span class=\"cm\">{-</span>\n<span class=\"cm\">        The mapping is from the De Bruijn index of each binding variable at the</span>\n<span class=\"cm\">        current depth to its name.</span>\n<span class=\"cm\">        -}</span>\n        <span class=\"n\">termFromLN</span> <span class=\"ow\">::</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"kt\">Map</span> <span class=\"kt\">Int</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"kt\">LN</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"kt\">NV</span>\n        <span class=\"n\">termFromLN</span> <span class=\"n\">env</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"ow\">=</span>\n          <span class=\"kr\">case</span> <span class=\"n\">v</span> <span class=\"kr\">of</span>\n            <span class=\"c1\">-- This is a free variable.</span>\n            <span class=\"kt\">F</span> <span class=\"n\">name</span>  <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"n\">name</span>\n            <span class=\"c1\">-- This is a bound variable.</span>\n            <span class=\"kt\">B</span> <span class=\"n\">index</span> <span class=\"ow\">-&gt;</span> <span class=\"kr\">case</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"n\">lookup</span> <span class=\"n\">index</span> <span class=\"n\">env</span> <span class=\"kr\">of</span>\n                         <span class=\"kt\">Just</span> <span class=\"n\">name</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Var</span> <span class=\"n\">name</span>\n                         <span class=\"kt\">Nothing</span> <span class=\"ow\">-&gt;</span> <span class=\"ne\">error</span> <span class=\"s\">\"Bound variable has no binder.\"</span>\n        <span class=\"n\">termFromLN</span> <span class=\"n\">env</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"n\">name</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Func</span> <span class=\"n\">name</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">map</span> <span class=\"p\">(</span><span class=\"n\">termFromLN</span> <span class=\"n\">env</span><span class=\"p\">)</span> <span class=\"n\">terms</span><span class=\"p\">)</span>\n    <span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Not</span> <span class=\"p\">(</span><span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n    <span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"p\">(</span><span class=\"kt\">And</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">And</span> <span class=\"p\">(</span><span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n    <span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"p\">(</span><span class=\"kt\">Or</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Or</span> <span class=\"p\">(</span><span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n    <span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n    <span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"p\">(</span><span class=\"kt\">Iff</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Iff</span> <span class=\"p\">(</span><span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n    <span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span>\n      <span class=\"kr\">case</span> <span class=\"n\">v</span> <span class=\"kr\">of</span>\n        <span class=\"kt\">B</span> <span class=\"kr\">_</span> <span class=\"ow\">-&gt;</span> <span class=\"ne\">error</span> <span class=\"s\">\"Bound variable at binding site.\"</span>\n        <span class=\"cm\">{-</span>\n<span class=\"cm\">        Since a binding variable has been gone under, the</span>\n<span class=\"cm\">        De Bruijn index of each binding variable at the</span>\n<span class=\"cm\">        current depth is increased by 1 and the De Bruijn</span>\n<span class=\"cm\">        index of the encountered binding variable at the</span>\n<span class=\"cm\">        current depth is set to 0.</span>\n<span class=\"cm\">        -}</span>\n        <span class=\"kt\">F</span> <span class=\"n\">name</span> <span class=\"ow\">-&gt;</span> <span class=\"kr\">let</span> <span class=\"n\">env'</span> <span class=\"ow\">=</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"n\">insert</span> <span class=\"mi\">0</span> <span class=\"n\">name</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"n\">mapKeysMonotonic</span> <span class=\"p\">(</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">env</span><span class=\"p\">)</span> <span class=\"kr\">in</span>\n                             <span class=\"kt\">Forall</span> <span class=\"n\">name</span> <span class=\"p\">(</span><span class=\"n\">go</span> <span class=\"n\">env'</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n    <span class=\"n\">go</span> <span class=\"n\">env</span> <span class=\"p\">(</span><span class=\"kt\">Exists</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span>\n      <span class=\"kr\">case</span> <span class=\"n\">v</span> <span class=\"kr\">of</span>\n        <span class=\"kt\">B</span> <span class=\"kr\">_</span> <span class=\"ow\">-&gt;</span> <span class=\"ne\">error</span> <span class=\"s\">\"Bound variable at binding site.\"</span>\n        <span class=\"kt\">F</span> <span class=\"n\">name</span> <span class=\"ow\">-&gt;</span> <span class=\"kr\">let</span> <span class=\"n\">env'</span> <span class=\"ow\">=</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"n\">insert</span> <span class=\"mi\">0</span> <span class=\"n\">name</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"n\">mapKeysMonotonic</span> <span class=\"p\">(</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">env</span><span class=\"p\">)</span> <span class=\"kr\">in</span>\n                             <span class=\"kt\">Exists</span> <span class=\"n\">name</span> <span class=\"p\">(</span><span class=\"n\">go</span> <span class=\"n\">env'</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n</code></pre></div>",
        "id": 267328206,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641692604
    },
    {
        "content": "<p>Or do you only replace bound variables, even in the natural deduction rules?</p>",
        "id": 267328262,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641692676
    },
    {
        "content": "<p>That is, the <code>a[b/c]</code> instances in these rules:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">ForallIntro</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">gamma</span> <span class=\"bp\">|-</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">not</span> <span class=\"n\">free</span> <span class=\"k\">in</span> <span class=\"n\">gamma</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">gamma</span> <span class=\"bp\">|-</span> <span class=\"k\">forall</span> <span class=\"n\">x.</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n<span class=\"n\">ForallElim</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">gamma</span> <span class=\"bp\">|-</span> <span class=\"k\">forall</span> <span class=\"n\">x.</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">admits</span> <span class=\"n\">t</span> <span class=\"n\">for</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">gamma</span> <span class=\"bp\">|-</span> <span class=\"n\">p</span><span class=\"o\">[</span><span class=\"n\">t</span><span class=\"bp\">/</span><span class=\"n\">x</span><span class=\"o\">])</span>\n<span class=\"n\">ExistsIntro</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">gamma</span> <span class=\"bp\">|-</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">admits</span> <span class=\"n\">x</span> <span class=\"n\">for</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">gamma</span> <span class=\"bp\">|-</span> <span class=\"n\">exists</span> <span class=\"n\">x.</span> <span class=\"n\">p</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"bp\">/</span><span class=\"n\">t</span><span class=\"o\">])</span>\n<span class=\"n\">ExistsElim</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">gamma</span> <span class=\"bp\">|-</span> <span class=\"n\">exists</span> <span class=\"n\">x.</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">gamma</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"o\">[</span><span class=\"n\">y</span><span class=\"bp\">/</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"bp\">|-</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"n\">not</span> <span class=\"n\">free</span> <span class=\"k\">in</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"n\">not</span> <span class=\"n\">free</span> <span class=\"k\">in</span> <span class=\"n\">gamma</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">gamma</span> <span class=\"bp\">|-</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n<span class=\"n\">Substitution</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">gamma</span> <span class=\"bp\">|-</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">gamma</span> <span class=\"bp\">|-</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"o\">[</span><span class=\"n\">t</span><span class=\"bp\">/</span><span class=\"n\">s</span><span class=\"o\">])</span>\n</code></pre></div>",
        "id": 267328399,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641692819
    },
    {
        "content": "<p>The full code for reference:<br>\n<a href=\"/user_uploads/3121/U_K1bfiA6zq-1hP6s5Qybd1L/nd.hs\">nd.hs</a></p>",
        "id": 267328475,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641692898
    },
    {
        "content": "<p>You can read the paper by Conor McBride on locally nameless. It's easily understandable, and demonstrates exactly how it is beneficial.</p>",
        "id": 267340670,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1641711740
    },
    {
        "content": "<p>In particular, every time you move inside a binder, you generate a free name (which, remarkably, doesn't require a monad or anything whatsoever) and substitute every occurence of the variable being unbound.</p>",
        "id": 267340688,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1641711832
    },
    {
        "content": "<p>And when you move out, you abstract one named variable into an unnamed one, and bind it. This pair of <code>instantiate</code> and <code>abstract</code> functions enables clean and intuitive manipulation.</p>",
        "id": 267340743,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1641711905
    },
    {
        "content": "<p>Is that McBride &amp; McKinna, “I am not a Number—I am a Free Variable” (<a href=\"https://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf\">https://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf</a>)?</p>",
        "id": 267343155,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1641715213
    },
    {
        "content": "<p>yep</p>",
        "id": 267347546,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1641719330
    },
    {
        "content": "<p>The functional pearl version is slightly better in terms of formatting and convention, but that's a matter of taste.</p>",
        "id": 267347598,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1641719370
    },
    {
        "content": "<p>In the lambda calculus you are only substituting for variables bound by a lambda, correct? But in the rules for natural deduction, you are also substituting for variables that are not bound (by a forall or exists), like in the ExistsElim and Substitution rules listed above?</p>",
        "id": 267363509,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641742713
    },
    {
        "content": "<p>Can the natural deduction rules be derived from the axioms of the first system?</p>",
        "id": 267377770,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641762420
    },
    {
        "content": "<p>Are there any forums that are more broadly dedicated to mathematical logic and,or its implementation in code that would be better suited to these kinds of questions? I only know of this and <a href=\"https://math.stackexchange.com/\">https://math.stackexchange.com/</a>.</p>",
        "id": 267379103,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641764334
    },
    {
        "content": "<p>Updated to full classical FOL + equality:</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"kr\">import</span> <span class=\"nn\">Data.List</span>\n\n\n<span class=\"kr\">data</span> <span class=\"kt\">Term</span> <span class=\"n\">a</span> <span class=\"ow\">=</span> <span class=\"kt\">Var</span> <span class=\"n\">a</span>\n            <span class=\"o\">|</span> <span class=\"kt\">Func</span> <span class=\"kt\">String</span> <span class=\"p\">[</span><span class=\"kt\">Term</span> <span class=\"n\">a</span><span class=\"p\">]</span> <span class=\"c1\">-- Func \"c\" [] : A constant named \"c\" ; -- Func \"f\" [v] : A function named \"f\" of one variable v</span>\n              <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"kr\">data</span> <span class=\"kt\">Formula</span> <span class=\"n\">a</span> <span class=\"ow\">=</span> <span class=\"kt\">Pred</span> <span class=\"kt\">String</span> <span class=\"p\">[</span><span class=\"kt\">Term</span> <span class=\"n\">a</span><span class=\"p\">]</span> <span class=\"c1\">-- Pred \"P\" [] : A propositional variable named \"P\" ; Pred \"Eq\" [s, t] : s = t</span>\n               <span class=\"o\">|</span> <span class=\"kt\">Not</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span>\n               <span class=\"o\">|</span> <span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span>\n               <span class=\"o\">|</span> <span class=\"kt\">Forall</span> <span class=\"n\">a</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span>\n                 <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"kr\">newtype</span> <span class=\"kt\">Theorem</span> <span class=\"n\">a</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Formula</span> <span class=\"n\">a</span><span class=\"p\">)</span>\n                    <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">From \"First Order Mathematical Logic\" by Angelo Margaris:</span>\n\n<span class=\"cm\">An occurrence of a variable $v$ in a formula $P$ is bound if and only if</span>\n<span class=\"cm\">it occurs in a subformula of $P$ of the form $\\forall v Q$. An occurrence</span>\n<span class=\"cm\">of $v$ in $P$ is free if and only if it is not a bound occurrence. The</span>\n<span class=\"cm\">variable $v$ is free or bound in $P$ according as it has a free or bound</span>\n<span class=\"cm\"> occurrence in $P$.</span>\n\n<span class=\"cm\">If $P$ is a formula, $v$ is a variable, and $t$ is a term, then $P(t/v)$ is</span>\n<span class=\"cm\">the result of replacing each free occurrence of $v$ in $P$ by an occurrence</span>\n<span class=\"cm\">of $t$.</span>\n\n<span class=\"cm\">If $v$ and $u$ are variables and $P$ is a formula, then $P$ admits $u$ for $v$</span>\n<span class=\"cm\">if and only if there is no free occurrence of $v$ in $P$ that becomes a</span>\n<span class=\"cm\">bound occurrence of $u$ in $P(u/v)$. If $t$ is a term, then $P$ admits $t$ for</span>\n<span class=\"cm\">$v$ if and only if $P$ admits for $v$ every variable in $t$.</span>\n<span class=\"cm\">-}</span>\n\n\n<span class=\"c1\">-- occursInTerm v t = there exists an occurrence of v in t.</span>\n<span class=\"nf\">occursInTerm</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">occursInTerm</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"n\">v'</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">v'</span>\n<span class=\"nf\">occursInTerm</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"kr\">_</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">any</span> <span class=\"p\">(</span><span class=\"n\">occursInTerm</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span>\n\n<span class=\"c1\">-- freeIn v p = there exists an occurrence of v in p that is free.</span>\n<span class=\"nf\">freeIn</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"kr\">_</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">any</span> <span class=\"p\">(</span><span class=\"n\">occursInTerm</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"o\">||</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">q</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v'</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">v</span> <span class=\"o\">/=</span> <span class=\"n\">v'</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span>\n\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">subInFormula p t v = p(t/v) = the result of replacing each free occurrence of</span>\n<span class=\"cm\">v in p by an occurrence of t.</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">subInFormula</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"kt\">String</span>\n<span class=\"nf\">subInFormula</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"n\">name</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"kt\">Pred</span> <span class=\"n\">name</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">map</span> <span class=\"p\">(</span><span class=\"nf\">\\</span><span class=\"n\">t'</span> <span class=\"ow\">-&gt;</span> <span class=\"n\">subInTerm</span> <span class=\"n\">t'</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span><span class=\"p\">)</span>\n  <span class=\"kr\">where</span>\n    <span class=\"cm\">{-</span>\n<span class=\"cm\">    subInTerm s t v = the result of replacing each occurrence of v in s by</span>\n<span class=\"cm\">    an occurrence of t.</span>\n<span class=\"cm\">    -}</span>\n    <span class=\"n\">subInTerm</span> <span class=\"ow\">::</span> <span class=\"kt\">Term</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"kt\">String</span>\n    <span class=\"n\">subInTerm</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"n\">v'</span><span class=\"p\">)</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">v'</span> <span class=\"kr\">then</span> <span class=\"n\">t</span> <span class=\"kr\">else</span> <span class=\"kt\">Var</span> <span class=\"n\">v'</span>\n    <span class=\"n\">subInTerm</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"n\">name</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"kt\">Func</span> <span class=\"n\">name</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">map</span> <span class=\"p\">(</span><span class=\"nf\">\\</span><span class=\"n\">t'</span> <span class=\"ow\">-&gt;</span> <span class=\"n\">subInTerm</span> <span class=\"n\">t'</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span><span class=\"p\">)</span>\n<span class=\"nf\">subInFormula</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"kt\">Not</span> <span class=\"p\">(</span><span class=\"n\">subInFormula</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n<span class=\"nf\">subInFormula</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"n\">subInFormula</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">subInFormula</span> <span class=\"n\">q</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n<span class=\"nf\">subInFormula</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v'</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">v'</span> <span class=\"kr\">then</span> <span class=\"kt\">Forall</span> <span class=\"n\">v'</span> <span class=\"n\">p</span> <span class=\"kr\">else</span> <span class=\"kt\">Forall</span> <span class=\"n\">v'</span> <span class=\"p\">(</span><span class=\"n\">subInFormula</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">admitsVar p u v = p admits u for v = there is no free occurrence of</span>\n<span class=\"cm\">v in p that becomes a bound occurrence of u in p(u/v).</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">admitsVar</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">admitsVar</span> <span class=\"n\">p</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"n\">go</span> <span class=\"n\">p</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"kt\">[]</span>\n  <span class=\"kr\">where</span>\n    <span class=\"n\">go</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">String</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n    <span class=\"n\">go</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"kr\">_</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">binders</span> <span class=\"ow\">=</span> <span class=\"n\">not</span> <span class=\"p\">(</span><span class=\"n\">any</span> <span class=\"p\">(</span><span class=\"n\">occursInTerm</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"o\">||</span> <span class=\"n\">elem</span> <span class=\"n\">v</span> <span class=\"n\">binders</span> <span class=\"o\">||</span> <span class=\"n\">notElem</span> <span class=\"n\">u</span> <span class=\"n\">binders</span>\n    <span class=\"n\">go</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">binders</span> <span class=\"ow\">=</span> <span class=\"n\">go</span> <span class=\"n\">p</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">binders</span>\n    <span class=\"n\">go</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">binders</span> <span class=\"ow\">=</span> <span class=\"n\">go</span> <span class=\"n\">p</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">binders</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">go</span> <span class=\"n\">q</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">binders</span>\n    <span class=\"n\">go</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v'</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">binders</span> <span class=\"ow\">=</span> <span class=\"n\">go</span> <span class=\"n\">p</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"n\">v'</span> <span class=\"kt\">:</span> <span class=\"n\">binders</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">admitsTerm p t v = p admits for v every variable in t.</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">admitsTerm</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">admitsTerm</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"n\">u</span><span class=\"p\">)</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"n\">admitsVar</span> <span class=\"n\">p</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"nf\">admitsTerm</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"kr\">_</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"n\">all</span> <span class=\"p\">(</span><span class=\"nf\">\\</span><span class=\"n\">t</span> <span class=\"ow\">-&gt;</span> <span class=\"n\">admitsTerm</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span>\n\n\n<span class=\"c1\">-- Propositional calculus</span>\n\n<span class=\"c1\">-- |- (p -&gt; (q -&gt; p))</span>\n<span class=\"nf\">prop_1</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span> <span class=\"kt\">String</span>\n<span class=\"nf\">prop_1</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">q</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- ((p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r)))</span>\n<span class=\"nf\">prop_2</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span> <span class=\"kt\">String</span>\n<span class=\"nf\">prop_2</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">q</span> <span class=\"n\">r</span><span class=\"p\">))</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">r</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">-- |- ((~p -&gt; ~q) -&gt; (q -&gt; p))</span>\n<span class=\"nf\">prop_3</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span> <span class=\"kt\">String</span>\n<span class=\"nf\">prop_3</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">q</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- p &amp; |- (p -&gt; q) =&gt; |- q</span>\n<span class=\"nf\">mp</span> <span class=\"ow\">::</span> <span class=\"kt\">Theorem</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span> <span class=\"kt\">String</span>\n<span class=\"nf\">mp</span> <span class=\"p\">(</span><span class=\"kt\">Theorem</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p'</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">p</span> <span class=\"o\">==</span> <span class=\"n\">p'</span> <span class=\"kr\">then</span> <span class=\"kt\">Theorem</span> <span class=\"n\">q</span> <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"mp\"</span>\n<span class=\"nf\">mp</span> <span class=\"kr\">_</span> <span class=\"kr\">_</span> <span class=\"ow\">=</span> <span class=\"ne\">error</span> <span class=\"s\">\"mp\"</span>\n\n\n<span class=\"c1\">-- Predicate calculus</span>\n\n<span class=\"c1\">-- |- p =&gt; |- forall v. p</span>\n<span class=\"nf\">gen</span> <span class=\"ow\">::</span> <span class=\"kt\">Theorem</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span> <span class=\"kt\">String</span>\n<span class=\"nf\">gen</span> <span class=\"p\">(</span><span class=\"kt\">Theorem</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n\n<span class=\"c1\">-- |- ((forall v. (p -&gt; q)) -&gt; (forall v. p) -&gt; (forall v. q))</span>\n<span class=\"nf\">pred_1</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span> <span class=\"kt\">String</span>\n<span class=\"nf\">pred_1</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"n\">q</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">-- |- (forall v. p -&gt; p [t/v]) provided p admits t for v</span>\n<span class=\"nf\">pred_2</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span> <span class=\"kt\">String</span>\n<span class=\"nf\">pred_2</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">admitsTerm</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"kr\">then</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">subInFormula</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">))</span> <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"pred_2\"</span>\n\n<span class=\"c1\">-- |- (p -&gt; forall v. p) provided v is not free in p</span>\n<span class=\"nf\">pred_3</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span> <span class=\"kt\">String</span>\n<span class=\"nf\">pred_3</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">not</span> <span class=\"p\">(</span><span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"kr\">then</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">))</span> <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"pred_3\"</span>\n\n\n<span class=\"c1\">-- Equality</span>\n\n<span class=\"nf\">itList2</span> <span class=\"ow\">::</span> <span class=\"p\">(</span><span class=\"n\">t1</span> <span class=\"ow\">-&gt;</span> <span class=\"n\">t2</span> <span class=\"ow\">-&gt;</span> <span class=\"n\">t3</span> <span class=\"ow\">-&gt;</span> <span class=\"n\">t3</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"n\">t1</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"n\">t2</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"n\">t3</span> <span class=\"ow\">-&gt;</span> <span class=\"n\">t3</span>\n<span class=\"nf\">itList2</span> <span class=\"kr\">_</span> <span class=\"kt\">[]</span> <span class=\"kt\">[]</span> <span class=\"n\">b</span> <span class=\"ow\">=</span> <span class=\"n\">b</span>\n<span class=\"nf\">itList2</span> <span class=\"n\">f</span> <span class=\"p\">(</span><span class=\"n\">h1</span> <span class=\"kt\">:</span> <span class=\"n\">t1</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">h2</span> <span class=\"kt\">:</span> <span class=\"n\">t2</span><span class=\"p\">)</span> <span class=\"n\">b</span> <span class=\"ow\">=</span> <span class=\"n\">f</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"p\">(</span><span class=\"n\">itList2</span> <span class=\"n\">f</span> <span class=\"n\">t1</span> <span class=\"n\">t2</span> <span class=\"n\">b</span><span class=\"p\">)</span>\n<span class=\"nf\">itList2</span> <span class=\"kr\">_</span> <span class=\"kr\">_</span> <span class=\"kr\">_</span> <span class=\"kr\">_</span> <span class=\"ow\">=</span> <span class=\"ne\">error</span> <span class=\"s\">\"itList2\"</span>\n\n<span class=\"c1\">-- |- t = t</span>\n<span class=\"nf\">eq_1</span> <span class=\"ow\">::</span> <span class=\"kt\">Term</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span> <span class=\"kt\">String</span>\n<span class=\"nf\">eq_1</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"s\">\"Eq\"</span> <span class=\"p\">[</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">])</span>\n\n<span class=\"c1\">-- |- s1 = t1 ==&gt; ... ==&gt; sn = tn ==&gt; f(s1,..,sn) = f(t1,..,tn)</span>\n<span class=\"nf\">eq_2</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">Term</span> <span class=\"kt\">String</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">Term</span> <span class=\"kt\">String</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span> <span class=\"kt\">String</span>\n<span class=\"nf\">eq_2</span> <span class=\"n\">f</span> <span class=\"n\">lefts</span> <span class=\"n\">rights</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span>\n       <span class=\"n\">itList2</span> <span class=\"p\">(</span><span class=\"nf\">\\</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">p</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"s\">\"Eq\"</span> <span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">])</span> <span class=\"n\">p</span><span class=\"p\">))</span> <span class=\"n\">lefts</span> <span class=\"n\">rights</span>\n               <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"s\">\"Eq\"</span> <span class=\"p\">[(</span><span class=\"kt\">Func</span> <span class=\"n\">f</span> <span class=\"n\">lefts</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"n\">f</span> <span class=\"n\">rights</span><span class=\"p\">)])</span>\n       <span class=\"p\">)</span>\n\n<span class=\"c1\">-- |- s1 = t1 ==&gt; ... ==&gt; sn = tn ==&gt; P(s1,..,sn) ==&gt; P(t1,..,tn)</span>\n<span class=\"nf\">eq_3</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">Term</span> <span class=\"kt\">String</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">Term</span> <span class=\"kt\">String</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span> <span class=\"kt\">String</span>\n<span class=\"nf\">eq_3</span> <span class=\"n\">p</span> <span class=\"n\">lefts</span> <span class=\"n\">rights</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span>\n       <span class=\"n\">itList2</span> <span class=\"p\">(</span><span class=\"nf\">\\</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">p</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"s\">\"Eq\"</span> <span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">])</span> <span class=\"n\">p</span><span class=\"p\">))</span> <span class=\"n\">lefts</span> <span class=\"n\">rights</span>\n               <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"n\">p</span> <span class=\"n\">lefts</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"n\">p</span> <span class=\"n\">rights</span><span class=\"p\">))</span>\n       <span class=\"p\">)</span>\n</code></pre></div>",
        "id": 267398777,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641794525
    },
    {
        "content": "<p>I'm not certain how this code gets changed if de Bruijn indexes are used instead, especially the axioms.</p>",
        "id": 267399031,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641794857
    },
    {
        "content": "<p>For dBI's you get rid of all the occurence-related stuff, so all the <code>admits</code> disappear. (Or rather, takes another form.)</p>",
        "id": 267399471,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1641795430
    },
    {
        "content": "<p>Why do they disappear, or what other form do they take?</p>",
        "id": 267399555,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641795527
    },
    {
        "content": "<p>You can change <code>admitsTerm</code> to a constant <code>True</code>, because with dBI, accidental binding <em>never</em> happens.</p>",
        "id": 267400321,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1641796542
    },
    {
        "content": "<p>So it is safe in the logic to make all alpha equivalent terms equal? (Which I think happens in dBI?)</p>",
        "id": 267400709,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641797076
    },
    {
        "content": "<p>The substitution just changes to different alpha equivalent terms to avoid accidental bindings right?</p>",
        "id": 267400742,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641797147
    },
    {
        "content": "<p>There is no alpha equivalence with dBI, there is only strict equality.</p>",
        "id": 267401203,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1641797757
    },
    {
        "content": "<p>Substitution don't need to care about accidental bindings, there are none.</p>",
        "id": 267401261,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1641797805
    },
    {
        "content": "<p>I think I see. Thank you.</p>",
        "id": 267401368,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641798001
    },
    {
        "content": "<p>How do you check if an arbitrary variable is free in a formula using de Bruijn indexes? That is, how do you implement the <code>freeIn</code> function that is used in <code>pred_3</code>?</p>",
        "id": 267524987,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641863706
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"139442\">@Patrick Thomas</span> something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"nf\">freeIn</span> <span class=\"ow\">::</span> <span class=\"kt\">Int</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"kr\">_</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">any</span> <span class=\"p\">(</span><span class=\"n\">occursInTerm</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"o\">||</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">q</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">freeIn</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">p</span>\n</code></pre></div>",
        "id": 267526984,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641865433
    },
    {
        "content": "<p>Should there be an underscore after <code>Forall</code>, ie, <code>freeIn v (Forall _ p) = freeIn (v + 1) p</code>?</p>",
        "id": 267527288,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641865704
    },
    {
        "content": "<p>No, I guess there wouldn't be, would there.</p>",
        "id": 267527331,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641865788
    },
    {
        "content": "<p>only if you want to track the variable name as metadata, it's not part of the main de bruijn implementation</p>",
        "id": 267527595,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641866087
    },
    {
        "content": "<p>So if a standalone variable becomes bound, its \"name\" before becoming bound is irrecoverably lost, because it gets changed to the index of its new binder?</p>",
        "id": 267527729,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641866221
    },
    {
        "content": "<p>In pure de bruijn there are no names to begin with, so nothing is lost. In locally nameless, the variable name is lost when you abstract a named variable, so you put it in the binder's metadata (the <code>var_name</code> field in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/expr.pi/src\">src#expr.pi</a>)</p>",
        "id": 267527832,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641866322
    },
    {
        "content": "<p>I'm not sure I understand. If there are no names to begin with, how do you compare variables? The <code>v</code> in the function <code>freeIn</code> isn't the name?</p>",
        "id": 267528065,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641866489
    },
    {
        "content": "<p>Or maybe identifier is a better term than name?</p>",
        "id": 267528151,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641866576
    },
    {
        "content": "<p>If you want to consider the numbers in de bruijn variables as \"names\", then it's not true that they are lost when abstracting, they just get bumped up by 1</p>",
        "id": 267528267,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641866704
    },
    {
        "content": "<p>free variables in de bruijn are represented as variables with numbers greater than the current binder depth</p>",
        "id": 267528290,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641866743
    },
    {
        "content": "<p>But if the get bound, they are lost right? For example, we start out with the standalone variable \"5\". If we want to bind it, it becomes <code>lam 1</code>?</p>",
        "id": 267528486,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641866960
    },
    {
        "content": "<p>As in, x -&gt; forall x.</p>",
        "id": 267528553,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641867016
    },
    {
        "content": "<p><code>lam 0</code>, but yes</p>",
        "id": 267528584,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641867098
    },
    {
        "content": "<p>If it's about to be bound then it should already be variable 0</p>",
        "id": 267528640,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641867141
    },
    {
        "content": "<p>so all you have to do is put the <code>lam</code> constructor on</p>",
        "id": 267528670,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641867188
    },
    {
        "content": "<p>Why would it already be zero?</p>",
        "id": 267528695,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641867235
    },
    {
        "content": "<p>because you already know the order that variables will be bound and have arranged the free vars to come in that order</p>",
        "id": 267528753,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641867273
    },
    {
        "content": "<p>if you can't do that then de bruijn doesn't have any extra advantages compared to locally nameless</p>",
        "id": 267528765,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641867299
    },
    {
        "content": "<p>but for example if you are generating the term by traversing an expression from the outside in, it is not hard to arrange things so that you know what variable is the next one to be bound</p>",
        "id": 267528804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641867345
    },
    {
        "content": "<p>You mean in going from named variables to de bruijn?</p>",
        "id": 267528884,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641867419
    },
    {
        "content": "<p>yes</p>",
        "id": 267528896,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641867435
    },
    {
        "content": "<p>which is probably something you have to do if you are writing a proof assistant and users write terms with named variables</p>",
        "id": 267528918,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641867469
    },
    {
        "content": "<p>Do you have to keep track of all of this as a global state for the entire proof, or just individually for each separate term?</p>",
        "id": 267529097,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641867673
    },
    {
        "content": "<p>Just for each term right?</p>",
        "id": 267529175,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641867809
    },
    {
        "content": "<p>Would this be a useful kernal for a proof assistant? What would its drawbacks be in comparison to others? Are there any advantages?</p>",
        "id": 267529471,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641868191
    },
    {
        "content": "<p>How do <code>gen</code> and <code>pred_3</code> get modified? Do you no longer specify which variable to bind with the forall?</p>",
        "id": 267687122,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641969349
    },
    {
        "content": "<p>Is that going to break the logic, that you can no longer pick which variable to bind?</p>",
        "id": 267687292,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1641969594
    },
    {
        "content": "<p>You still get to specify a name, because free variables have names.</p>",
        "id": 267692348,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1641974990
    },
    {
        "content": "<p>For <code>pred_3</code>, since <code>v</code> is not free, it doesn't matter.</p>",
        "id": 267692467,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1641975084
    },
    {
        "content": "<p>In McBride's terminology, if you want to generalize the variable with name <code>\"x\"</code> in <code>p</code>, you simply compute <code>p1 = abstract \"x\" p</code>, and then the resulting formula is just <code>Forall p1</code></p>",
        "id": 267692615,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1641975204
    },
    {
        "content": "<p>The rule of thumb: Free variables always have names, bound variables always have no name; The only exception is when a variable is in the process of becoming bound/free, in which case it is free but has no name.</p>",
        "id": 267692734,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1641975278
    },
    {
        "content": "<p>Thank you.</p>",
        "id": 267740743,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642001673
    },
    {
        "content": "<p>Oh, sorry, I meant using de bruijn indexes.</p>",
        "id": 267741269,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642001882
    },
    {
        "content": "<p>Pure de Bruijn indexes are indeed more difficult, but if you do some free variable permutation it should still work out. (Disclaimer: I never wrote anything in pure dBI)</p>",
        "id": 267742782,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642002490
    },
    {
        "content": "<p>I see.</p>",
        "id": 267749598,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642005278
    },
    {
        "content": "<p>Am I better off than using locally nameless?</p>",
        "id": 267811530,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642036378
    },
    {
        "content": "<p>The other way to handle free variables in pure de bruijn is to never abstract them. So for example let's say you have a haskell like setup where there are some global definitions and a lambda operator, then the global definitions can be free de bruijn variables with arbitrary values, and the local variables are all bound in some scope. Then for the bound variables you always use numbers 0, 1, 2, .. based on binder depth, and for the free variables it doesn't matter what number you use since they will never be abstracted</p>",
        "id": 267822478,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642047873
    },
    {
        "content": "<p>I'm sorry, I'm not sure I follow what you mean. This is for a proof checker? This changes the axioms somehow?</p>",
        "id": 267823202,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642048769
    },
    {
        "content": "<p>If you want to construct a bunch of terms in lambda calculus like this (FOL terms work just the same way)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">app</span> <span class=\"bp\">=</span> <span class=\"bp\">\\</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n<span class=\"n\">foo</span> <span class=\"bp\">=</span> <span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">\\</span><span class=\"n\">x</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">app</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">app</span>\n<span class=\"n\">bar</span> <span class=\"bp\">=</span> <span class=\"bp\">\\</span><span class=\"n\">x</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">foo</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>then you can do that by setting, say <code>app = #0</code>, <code>foo = #1</code> and <code>bar = #2</code> and you get the de bruijn terms:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">app</span> <span class=\"bp\">=</span> <span class=\"n\">lam</span> <span class=\"o\">(</span><span class=\"n\">lam</span> <span class=\"o\">(</span><span class=\"bp\">#</span><span class=\"mi\">1</span> <span class=\"bp\">#</span><span class=\"mi\">0</span><span class=\"o\">))</span>\n<span class=\"n\">foo</span> <span class=\"bp\">=</span> <span class=\"bp\">#</span><span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">lam</span> <span class=\"o\">(</span><span class=\"bp\">#</span><span class=\"mi\">1</span> <span class=\"bp\">#</span><span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"bp\">#</span><span class=\"mi\">0</span>\n<span class=\"n\">bar</span> <span class=\"bp\">=</span> <span class=\"n\">lam</span> <span class=\"o\">(</span><span class=\"bp\">#</span><span class=\"mi\">2</span> <span class=\"bp\">#</span><span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 267828699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642054931
    },
    {
        "content": "<p>so in this example <code>#0 (lam (#1 #0)) #0</code> references the free variable <code>#0</code> which is <code>app</code>, and we're never going to abstract it so we could do the same thing if it was some other number; if <code>app</code> was instead <code>#n</code> then the term would be <code>#n (lam (#(n+1) #0)) #n</code></p>",
        "id": 267828823,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642055087
    },
    {
        "content": "<p>so this is handling global definitions and definitions with bound variables using only pure de bruijn, not locally nameless</p>",
        "id": 267828854,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642055144
    },
    {
        "content": "<p>How do we know that we are never going to abstract <code>app</code>?</p>",
        "id": 267877116,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642084605
    },
    {
        "content": "<p>In the \"I am not a number - I am a free variable\" paper (<a href=\"https://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf\">https://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf</a>), what does being a closed expression mean in the sentence \"From now on, outside of these operations, we maintain the invariant that Expr is only used for closed expressions and that Scopes have just one dangling index.\" I understand the usual meaning to be no free variables, but earlier they say \"Meanwhile, instantiate image turns a scope into an expression by replacing the outer de Bruijn index (initially B 0) with image, which we presume is closed. Of course, F name is closed, so we can use instantiate (F name) to invert abstract name.\" but F name is a free variable right?</p>",
        "id": 267972889,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642136615
    },
    {
        "content": "<p>Also, how does pred_3 get implemented in the manner described in the paper, if v is not free in p, and thus has no name to refer to and may not even occur in p.</p>",
        "id": 267973628,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642137423
    },
    {
        "content": "<p>pred_3 is basically saying you can go from <code>forall x. (x = y)</code> to <code>forall x. (forall x. (x = y))</code> right? But now <code>x</code> has two binders, and I don't see how that can be expressed in either de bruijn or the method of the paper.</p>",
        "id": 267973993,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642137864
    },
    {
        "content": "<p>No, <code>x</code> doesn't have two binders. The two <code>x</code> are different. And this axiom is but an awkward way we dealt with binders back in the day when dBI's were not invented.</p>",
        "id": 267976727,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642141649
    },
    {
        "content": "<p>I think it is really worth writing something McBride-style to reformulate FOL with locally nameless. I'll search for related literature when I'm free.</p>",
        "id": 267976897,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642141908
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/267972889\">said</a>:</p>\n<blockquote>\n<p>In the \"I am not a number - I am a free variable\" paper (<a href=\"https://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf\">https://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf</a>), what does being a closed expression mean in the sentence \"From now on, outside of these operations, we maintain the invariant that Expr is only used for closed expressions and that Scopes have just one dangling index.\"</p>\n</blockquote>\n<p>They explain this sentence a bit more elsewhere:</p>\n<blockquote>\n<p>For the most part, we shall pretend that Expr is the type of closed expressions—those with no ‘dangling’ bound variables pointing out of scope, and that Scope has one dangling bound variable, called B 0 at the top level.</p>\n</blockquote>\n<p>So \"closed\" here means having no free <code>B</code> variables; free <code>F</code> variables are allowed</p>",
        "id": 267978804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642144439
    },
    {
        "content": "<p>The equivalent of <code>pred_3</code> says that <code>imp p (forall p)</code> where <code>p</code> is an <code>Expr</code>, i.e. it is a \"closed\" expression containing no free <code>B</code> variables. There are no side conditions required because the closedness of <code>p</code> suffices, and this is ensured using typing and good discipline in the McBride formulation</p>",
        "id": 267980434,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642146130
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"404479\">Trebor Huang</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/267976727\">said</a>:</p>\n<blockquote>\n<p>No, <code>x</code> doesn't have two binders. The two <code>x</code> are different. And this axiom is but an awkward way we dealt with binders back in the day when dBI's were not invented.</p>\n</blockquote>\n<p>By the way, I'm still in favor of using named variables for theorem proving, I don't think that it is simply an outdated technology. The reason is because the <code>abstract</code> and <code>instantiate</code> operations are linear in the size of the expression, and locally nameless has you doing those operations all the time, to inspect an expression or really do anything at all with it. That means that most basic operations are somewhere around O(n^2) which isn't great.</p>\n<p>What's more, that's O(n^2) in the <em>tree form</em> of the expression, meaning that if your expression has high duplication (which is very common in dependent type theory) then you can get an exponential blowup here. I believe it is possible to treat the expression in a DAG-like way, but it is quite difficult to do so because the same subexpression can mean different things depending on what binders it is under (the same numbers can refer to different binders), so caching the result of an analysis or transformation has to include a large amount of context and if you aren't careful you will end up having so many contexts that you are back to exponential time.</p>",
        "id": 267980827,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642146572
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/267877116\">said</a>:</p>\n<blockquote>\n<p>How do we know that we are never going to abstract <code>app</code>?</p>\n</blockquote>\n<p>Because we always know, at the point we read an <code>app</code> token, whether it is referring to a free or bound variable. If we had an expression like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">baz</span> <span class=\"bp\">=</span> <span class=\"bp\">\\</span><span class=\"n\">app</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">app</span>\n</code></pre></div>\n<p>then we would first encounter the <code>app</code> binder, record that <code>app</code> is local variable <code>#0</code>, and then when we see the reference to <code>app</code> later we use <code>#0</code> (so the generated term is <code>lam #0</code>). By comparison, if we had</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">baz</span> <span class=\"bp\">=</span> <span class=\"bp\">\\</span><span class=\"n\">x</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">app</span>\n</code></pre></div>\n<p>we would record that <code>x</code> is local variable <code>#0</code> (and the binder depth is 1), and when we see a reference to <code>app</code> we search the context, see that it is not present, but find <code>app</code> in the global context (with number <code>#0</code>), so we increment that by the binder depth and produce <code>lam #1</code>.</p>",
        "id": 267981310,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642146962
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"404479\">Trebor Huang</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/267976727\">said</a>:</p>\n<blockquote>\n<p>No, <code>x</code> doesn't have two binders. The two <code>x</code> are different. And this axiom is but an awkward way we dealt with binders back in the day when dBI's were not invented.</p>\n</blockquote>\n<p>The two <code>x</code> are different? Why? Is that an implied specification in the logic?</p>",
        "id": 268101612,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642217216
    },
    {
        "content": "<p>To be honest, I'm not sure I understand what <code>gen</code> and <code>pred_3</code> do differently, or how they are used.</p>",
        "id": 268101618,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642217242
    },
    {
        "content": "<p>I think MetaMath avoids the issues of free and bound variables by somehow finding a set of axioms that don't require conditions involving them? And then these axioms that I have can somehow be derived from those? And vice versa maybe?</p>",
        "id": 268101622,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642217275
    },
    {
        "content": "<p>Kind of an aside, but I can see coming up with a set of tautologies, or statements that are valid in every model (if I remember the terminology right), but how did they go about figuring out axioms that also made the theory complete, even for propositional calculus, let alone predicate calculus?</p>",
        "id": 268101661,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642217301
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268101618\">said</a>:</p>\n<blockquote>\n<p>To be honest, I'm not sure I understand what <code>gen</code> and <code>pred_3</code> do differently, or how they are used.</p>\n</blockquote>\n<p>I mean, I think one (I'm not sure which) is used to do something like:<br>\nLet x be any set that satisfies some condition. Prove x has some property. Obtain that all sets under the condition have that property.<br>\nBut I'm not sure about the other.</p>",
        "id": 268101918,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642217644
    },
    {
        "content": "<ul>\n<li>The propositional axioms remain the same, which should be clear to you.</li>\n<li><code>gen</code> goes from <code>p</code> to <code>Forall (abstract v p)</code>, note that the <code>Forall</code> constructor does not take a variable name; instead it takes a <code>Scope</code> in McBride's terminology.</li>\n<li><code>pred_1</code> shouldn't be a problem.</li>\n<li><code>pred_2</code> goes from <code>Forall p</code> to <code>instantiate t p</code>, no additional check needed.</li>\n<li><code>pred_3</code> goes from <code>p</code> to <code>Forall p</code>, no check needed, no additional computation needed.</li>\n</ul>",
        "id": 268105897,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642223842
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 268106479,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642224784
    },
    {
        "content": "<p>Now I just need to understand why that works for <code>pred_3</code> :)</p>",
        "id": 268107292,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642226152
    },
    {
        "content": "<p>In <code>pred_3</code>, <code>p</code> is an <code>Expr</code>, meaning that it has no free <code>B</code> variables and in particular no <code>B 0</code>. Therefore <code>Forall p</code> will introduce a bound variable which has no occurrences in <code>p</code>, which is what we want. No variable lifting is required because everything is numbered from the innermost quantifiers out.</p>",
        "id": 268107411,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642226288
    },
    {
        "content": "<p>Regarding completeness of propositional and predicate calculus, I don't think they were easy theorems to find but the theory was all worked out in the 40s or so</p>",
        "id": 268107545,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642226422
    },
    {
        "content": "<p>Completeness of propositional calculus is pretty easy</p>",
        "id": 268107565,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642226437
    },
    {
        "content": "<p>See <a href=\"https://en.wikipedia.org/wiki/G%C3%B6del%27s_completeness_theorem\">https://en.wikipedia.org/wiki/G%C3%B6del%27s_completeness_theorem</a></p>",
        "id": 268107605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642226516
    },
    {
        "content": "<p>Why do we want a bound variable that has no occurrence in p? Isn't the condition that it just not be free in p?</p>",
        "id": 268107643,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642226528
    },
    {
        "content": "<p>I mean not free</p>",
        "id": 268107650,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642226548
    },
    {
        "content": "<p>In de bruijn that means that outside the scope of binders there are no <code>B</code>'s, under 1 binder there is only <code>B 0</code>, under 2 binders there are <code>B 0</code> and <code>B 1</code> and so on</p>",
        "id": 268107666,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642226594
    },
    {
        "content": "<p>The haskell type system doesn't enforce this in McBride's presentation, so you have to just maintain it as a discipline</p>",
        "id": 268107749,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642226667
    },
    {
        "content": "<p>similarly for <code>Scope</code>, which is like <code>Expr</code> except it allows <code>B 0</code> outside binders, <code>B 0, B 1</code> under 1 binder and so on</p>",
        "id": 268107768,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642226715
    },
    {
        "content": "<p>So in the statement as given, v can not be free in p right/ So this means it either falls under the scope of a forall v p, or does not occur in p at all right?</p>",
        "id": 268107926,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642226887
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268107643\">said</a>:</p>\n<blockquote>\n<p>Why do we want a bound variable that has no occurrence in p? Isn't the condition that it just not be free in p?</p>\n</blockquote>\n<p>Actually de bruijn doesn't really make a distinction here. There are no <code>B</code> variables in <code>p</code> that would refer to the variable introduced in <code>Forall p</code></p>",
        "id": 268107927,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642226888
    },
    {
        "content": "<p>Wait, oops, sorry, I thought we were talking about locally nameless...</p>",
        "id": 268107962,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642226955
    },
    {
        "content": "<p>I am</p>",
        "id": 268107965,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642226960
    },
    {
        "content": "<p>sorry to confuse</p>",
        "id": 268107971,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642226969
    },
    {
        "content": "<p>No problem.</p>",
        "id": 268107979,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642226979
    },
    {
        "content": "<p>the <code>F</code> variables don't really play a role here</p>",
        "id": 268107980,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642226980
    },
    {
        "content": "<p>The \"v not free in p\" condition is expressed by the fact that <code>p</code> is an <code>Expr</code> even though <code>Forall</code> normally takes a <code>Scope</code>as its argument</p>",
        "id": 268108038,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642227038
    },
    {
        "content": "<p>every <code>Expr</code> is a <code>Scope</code>, but not vice versa; the <code>Scope</code>s that are not <code>Expr</code>s are exactly those with a free occurrence of <code>B 0</code></p>",
        "id": 268108076,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642227119
    },
    {
        "content": "<p>Isn't that a different definition of free? The named variable version means is not in the scope of a forall v or v not occurring. The locally nameless is that that there is no B0. I think?</p>",
        "id": 268108179,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642227242
    },
    {
        "content": "<p>remember that when I say <code>B 0</code>, I mean <code>B 1</code> when under a binder, <code>B 2</code> under two binders and so on. Anything that would be interpreted as referring to the outer <code>Forall</code> binder we're introducing</p>",
        "id": 268108246,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642227306
    },
    {
        "content": "<p>We don't have to worry about name clashes with a \"forall v\" somewhere in the term because that's the whole point of de bruijn variables</p>",
        "id": 268108261,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642227336
    },
    {
        "content": "<p>If you had something like <code>forall v, v</code> this would be rendered in LN as <code>Forall (B 0)</code>, which does not contain any free <code>B 0</code> (because the only variable that appears is under 1 binder, and is not <code>B 1</code>)</p>",
        "id": 268108335,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642227406
    },
    {
        "content": "<p>on the other hand <code>forall w, v</code> would be <code>Forall (B 1)</code> which does contain a free <code>B 0</code></p>",
        "id": 268108356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642227450
    },
    {
        "content": "<p>(in locally nameless you might also translate that as <code>Forall (F \"v\")</code> but let's suppose this is a <code>Scope</code>)</p>",
        "id": 268108414,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642227511
    },
    {
        "content": "<p>In the latter case it still does not contain a free <code>B 0</code>, so we would be allowed to use the <code>pred_3</code> rule and get <code>Forall (F \"v\") -&gt; Forall (Forall (F \"v\"))</code> which would be rendered as <code>forall x, v -&gt; forall y, forall x, v</code></p>",
        "id": 268108513,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642227626
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 268108616,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642227770
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 268108709,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642227900
    },
    {
        "content": "<p>In the named variable version, we can use <code>pred_3</code> to get <code>Forall x. (Pred P x) -&gt; Forall x. Forall x. (Pred P x)</code> right? What does this actually mean? Trebor says the two x are different?</p>",
        "id": 268109152,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642228496
    },
    {
        "content": "<p>In locally nameless that's <code>Forall (Pred P (B 0)) -&gt; Forall (Forall (Pred P (B 0)))</code>.</p>",
        "id": 268109412,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642228836
    },
    {
        "content": "<p>The variable <code>x</code> refers to the inner <code>Forall</code>, hence <code>B 0</code>.</p>",
        "id": 268109427,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642228864
    },
    {
        "content": "<p>And the x in the named version is only bound by the inside forall x?</p>",
        "id": 268109493,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642228976
    },
    {
        "content": "<p>Yes.</p>",
        "id": 268109513,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642229021
    },
    {
        "content": "<p>Hmm.</p>",
        "id": 268109518,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642229038
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 268109575,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642229098
    },
    {
        "content": "<p>So forall x, forall x, x is the same as forall y, forall x, x (in the named version)?</p>",
        "id": 268109592,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642229144
    },
    {
        "content": "<p>Yep.</p>",
        "id": 268109594,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642229157
    },
    {
        "content": "<p>Hmm.</p>",
        "id": 268109646,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642229197
    },
    {
        "content": "<p>Think of the indices as lines connecting the nameless variable to the binders. So in this case, <code>B 0</code> means \"A nameless variable with a line connecting it to the inner <code>Forall</code>. And think of named variables in the usual way. Then, a <code>Scope</code> would have some dangling lines.</p>\n<p>Then <code>abstract</code> just takes a variable name, searches for all occurences of that variable, make them nameless, and draw a bunch of lines from them, so if you put the result under a <code>Forall</code>, you just collect the dangling lines and connect the other side to the <code>Forall</code>.</p>\n<p><code>instantiate</code> takes a <code>Scope</code>, which has dangling lines, and replace the other end of the dangling lines with the expression you give.</p>",
        "id": 268109647,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642229202
    },
    {
        "content": "<p>So (in the named version) is the 'v not free in p' condition the same as 'v does not occur in p', given that forall x, forall x, x is the same as forall y, forall x, x.</p>",
        "id": 268109734,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642229389
    },
    {
        "content": "<p>Yep, that's the crux of alpha equivalence.</p>",
        "id": 268109780,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642229409
    },
    {
        "content": "<p>You can change the variable names anyway you like, as long as they still refer to the same things.</p>",
        "id": 268109797,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642229474
    },
    {
        "content": "<p>Why doesn't the named version just state \"does not occur in\" instead of \"not free in\"?</p>",
        "id": 268109869,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642229559
    },
    {
        "content": "<p>I mean, could it? Would it be the same logic?</p>",
        "id": 268109900,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642229642
    },
    {
        "content": "<p>Some versions do that, but then you need to additionally state the rules to make variable changes like <code>forall x. forall x. P(x)</code> to <code>forall y. forall x. P(x)</code></p>",
        "id": 268109955,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642229682
    },
    {
        "content": "<p>I see. A rule for alpha conversion?</p>",
        "id": 268109967,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642229715
    },
    {
        "content": "<p>Yes. I think one of the papers linked from the metamath homepage discusses that, but I can't remember which.</p>",
        "id": 268109974,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642229746
    },
    {
        "content": "<p>I think I might see then. If there is no dangling B0 in p (required if p is an expression), then forall p does not bind any variable that occurs in p, because it just binds dangling B0's?</p>",
        "id": 268110245,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642230075
    },
    {
        "content": "<p>Yes that's right.</p>",
        "id": 268110254,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642230099
    },
    {
        "content": "<p>Hence it is equivalent to the named version, given alpha equivalence?</p>",
        "id": 268110307,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642230128
    },
    {
        "content": "<p>Yeah, actually it is very much like quotienting the alpha equivalence</p>",
        "id": 268110417,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642230318
    },
    {
        "content": "<p>Cool! Thank you!</p>",
        "id": 268110431,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642230360
    },
    {
        "content": "<p>It's like how the set of irreducible fractions corresponds to the equivalence classes of fractions under <code>a/b ~ c/d</code> where <code>ad = bc</code></p>",
        "id": 268110482,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642230412
    },
    {
        "content": "<p>Aside question: What does the octopus emoji mean?</p>",
        "id": 268110590,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642230595
    },
    {
        "content": "<p>It means congratulations.</p>",
        "id": 268110648,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1642230633
    },
    {
        "content": "<p>Huh. Ok. Thank you!</p>",
        "id": 268110678,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642230681
    },
    {
        "content": "<p>\"Impressive\". It does a victory dance</p>",
        "id": 268114845,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1642236385
    },
    {
        "content": "<p>Is this a correct translation?</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"cm\">{-</span>\n<span class=\"cm\">First order mathematical logic using locally nameless variables.</span>\n\n<span class=\"cm\">Modified from \"Functional Pearl: I am not a Number—I am a Free Variable\"</span>\n<span class=\"cm\">by Conor McBride and James McKinna.</span>\n<span class=\"cm\">https://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf</span>\n<span class=\"cm\">-}</span>\n\n<span class=\"kr\">import</span> <span class=\"nn\">Data.List</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Func \"c\" [] : A constant named \"c\"</span>\n<span class=\"cm\">Func \"f\" [v] : A function named \"f\" of one variable v</span>\n<span class=\"cm\">-}</span>\n<span class=\"kr\">data</span> <span class=\"kt\">Term</span> <span class=\"ow\">=</span> <span class=\"kt\">F</span> <span class=\"kt\">String</span> <span class=\"c1\">-- A free variable</span>\n          <span class=\"o\">|</span> <span class=\"kt\">B</span> <span class=\"kt\">Int</span> <span class=\"c1\">-- A De Bruijn indexed bound variable</span>\n          <span class=\"o\">|</span> <span class=\"kt\">Func</span> <span class=\"kt\">String</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span>\n            <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Assumed not to have any bound variables out of scope.</span>\n\n<span class=\"cm\">Pred \"P\" [] : A propositional variable named \"P\"</span>\n<span class=\"cm\">Pred \"Eq\" [s, t] : s = t</span>\n<span class=\"cm\">-}</span>\n<span class=\"kr\">data</span> <span class=\"kt\">Formula</span> <span class=\"ow\">=</span> <span class=\"kt\">Pred</span> <span class=\"kt\">String</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Not</span> <span class=\"kt\">Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Imp</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Forall</span> <span class=\"kt\">Scope</span>\n               <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">May have bound variables indexed one greater than the number of binders</span>\n<span class=\"cm\">above it.</span>\n<span class=\"cm\">-}</span>\n<span class=\"kr\">newtype</span> <span class=\"kt\">Scope</span> <span class=\"ow\">=</span> <span class=\"kt\">Scope</span> <span class=\"kt\">Formula</span>\n                <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"kr\">newtype</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"kt\">Formula</span>\n                  <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">abstract v p = The result of changing each free variable named v in the formula</span>\n<span class=\"cm\">p to a bound variable indexed one greater than the number of binders above it.</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">abstract</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Scope</span>\n<span class=\"nf\">abstract</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"ow\">=</span> <span class=\"kt\">Scope</span> <span class=\"p\">(</span><span class=\"n\">nameTo</span> <span class=\"mi\">0</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"kr\">where</span>\n  <span class=\"n\">nameTo</span> <span class=\"ow\">::</span> <span class=\"kt\">Int</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span>\n  <span class=\"n\">nameTo</span> <span class=\"n\">outer</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"n\">name</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Pred</span> <span class=\"n\">name</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">map</span> <span class=\"p\">(</span><span class=\"n\">nameTo'</span> <span class=\"n\">outer</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"kr\">where</span>\n    <span class=\"n\">nameTo'</span> <span class=\"ow\">::</span> <span class=\"kt\">Int</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span>\n    <span class=\"n\">nameTo'</span> <span class=\"n\">outer</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">F</span> <span class=\"n\">v'</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">v'</span> <span class=\"kr\">then</span> <span class=\"kt\">B</span> <span class=\"n\">outer</span> <span class=\"kr\">else</span> <span class=\"kt\">F</span> <span class=\"n\">v'</span>\n    <span class=\"n\">nameTo'</span> <span class=\"kr\">_</span> <span class=\"kr\">_</span> <span class=\"p\">(</span><span class=\"kt\">B</span> <span class=\"n\">index</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">B</span> <span class=\"n\">index</span>\n    <span class=\"n\">nameTo'</span> <span class=\"n\">outer</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"n\">name</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Func</span> <span class=\"n\">name</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">map</span> <span class=\"p\">(</span><span class=\"n\">nameTo'</span> <span class=\"n\">outer</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span><span class=\"p\">)</span>\n  <span class=\"n\">nameTo</span> <span class=\"n\">outer</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Not</span> <span class=\"p\">(</span><span class=\"n\">nameTo</span> <span class=\"n\">outer</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n  <span class=\"n\">nameTo</span> <span class=\"n\">outer</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"n\">nameTo</span> <span class=\"n\">outer</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">nameTo</span> <span class=\"n\">outer</span> <span class=\"n\">v</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n  <span class=\"n\">nameTo</span> <span class=\"n\">outer</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"p\">(</span><span class=\"kt\">Scope</span> <span class=\"n\">p</span><span class=\"p\">))</span> <span class=\"ow\">=</span> <span class=\"kt\">Forall</span> <span class=\"p\">(</span><span class=\"kt\">Scope</span> <span class=\"p\">(</span><span class=\"n\">nameTo</span> <span class=\"p\">(</span><span class=\"n\">outer</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">instantiate t (Scope p) = The result of replacing each bound variable in the</span>\n<span class=\"cm\">formula p that has an index one greater than the number of binders above it</span>\n<span class=\"cm\">by the term t.</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">instantiate</span> <span class=\"ow\">::</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Scope</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span>\n<span class=\"nf\">instantiate</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"kt\">Scope</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">replace</span> <span class=\"mi\">0</span> <span class=\"n\">t</span> <span class=\"n\">p</span> <span class=\"kr\">where</span>\n  <span class=\"n\">replace</span> <span class=\"ow\">::</span> <span class=\"kt\">Int</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span>\n  <span class=\"n\">replace</span> <span class=\"n\">outer</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"n\">name</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Pred</span> <span class=\"n\">name</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">map</span> <span class=\"p\">(</span><span class=\"n\">replace'</span> <span class=\"n\">outer</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"kr\">where</span>\n    <span class=\"n\">replace'</span> <span class=\"ow\">::</span> <span class=\"kt\">Int</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span>\n    <span class=\"n\">replace'</span> <span class=\"kr\">_</span> <span class=\"kr\">_</span> <span class=\"p\">(</span><span class=\"kt\">F</span> <span class=\"n\">name</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">F</span> <span class=\"n\">name</span>\n    <span class=\"n\">replace'</span> <span class=\"n\">outer</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"kt\">B</span> <span class=\"n\">index</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">outer</span> <span class=\"o\">==</span> <span class=\"n\">index</span> <span class=\"kr\">then</span> <span class=\"n\">t</span> <span class=\"kr\">else</span> <span class=\"kt\">B</span> <span class=\"n\">index</span>\n    <span class=\"n\">replace'</span> <span class=\"n\">outer</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"n\">name</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Func</span> <span class=\"n\">name</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">map</span> <span class=\"p\">(</span><span class=\"n\">replace'</span> <span class=\"n\">outer</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"n\">terms</span><span class=\"p\">)</span>\n  <span class=\"n\">replace</span> <span class=\"n\">outer</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Not</span> <span class=\"p\">(</span><span class=\"n\">replace</span> <span class=\"n\">outer</span> <span class=\"n\">t</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n  <span class=\"n\">replace</span> <span class=\"n\">outer</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"n\">replace</span> <span class=\"n\">outer</span> <span class=\"n\">t</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">replace</span> <span class=\"n\">outer</span> <span class=\"n\">t</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n  <span class=\"n\">replace</span> <span class=\"n\">outer</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"p\">(</span><span class=\"kt\">Scope</span> <span class=\"n\">p</span><span class=\"p\">))</span> <span class=\"ow\">=</span> <span class=\"kt\">Forall</span> <span class=\"p\">(</span><span class=\"kt\">Scope</span> <span class=\"p\">(</span><span class=\"n\">replace</span> <span class=\"p\">(</span><span class=\"n\">outer</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">t</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n</code></pre></div>",
        "id": 268155721,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642293583
    },
    {
        "content": "<p>FYI <code>nameTo</code> does not need the <code>v</code> argument and <code>nameTo'</code> does not need <code>outer</code> or <code>v</code> because they are already in scope</p>",
        "id": 268158261,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642297856
    },
    {
        "content": "<p>I see. Thank you.</p>",
        "id": 268158309,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642297939
    },
    {
        "content": "<p><code>t</code> needs to be a closed term in <code>instantiate</code> for this implementation to be correct; I guess that's a precondition but it should be spelled out in the comment</p>",
        "id": 268158380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642298119
    },
    {
        "content": "<p>Closed in the sense of no bound variables with indexes greater than the number of binders they are under?</p>",
        "id": 268158447,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642298255
    },
    {
        "content": "<p><code>pred_1</code> should take two <code>Scope</code>s, or else the quantifiers are useless</p>",
        "id": 268158515,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642298342
    },
    {
        "content": "<p><code>pred_2</code> should also take a <code>Scope</code></p>",
        "id": 268158524,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642298376
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"139442\">@Patrick Thomas</span> Closed in the sense of no bound variables at all</p>",
        "id": 268158680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642298517
    },
    {
        "content": "<p>i.e. what you said for binders = 0</p>",
        "id": 268158726,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642298538
    },
    {
        "content": "<p>Should I make a check in the code for that each time a term is taken as an argument?</p>",
        "id": 268158808,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642298651
    },
    {
        "content": "<p>No bound variables with indexes greater than 0, or just no bound variables altogether?</p>",
        "id": 268158870,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642298743
    },
    {
        "content": "<p>Well, in LN this is an invariant, so you would only need it as a debug assertion</p>",
        "id": 268158890,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642298761
    },
    {
        "content": "<p>A term shouldn't have any bound variables right? Since there are no binders in a term?</p>",
        "id": 268159006,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642298888
    },
    {
        "content": "<p>That is the invariant?</p>",
        "id": 268159023,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642298921
    },
    {
        "content": "<p>in LN there is only one interesting notion of closed: under <code>k</code> binders, no <code>B n</code> appears for <code>n &gt;= k</code> (closed term, <code>Term</code>, <code>Formula</code>) or for <code>n &gt;= k + 1</code> (term/formula with one free variable, <code>Scope</code>). General open terms (no restriction on the <code>B</code>'s) only appear in the definition of <code>abstract</code> and <code>instantiate</code>.</p>",
        "id": 268159037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642298950
    },
    {
        "content": "<p>For a <code>Term</code> to be closed that means it has no <code>B</code> variables at all though since there are no binders in the term grammar</p>",
        "id": 268159103,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642299046
    },
    {
        "content": "<p>Every top level function you have there which has a <code>Term</code> in its type signature requires a closed term</p>",
        "id": 268159123,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642299109
    },
    {
        "content": "<p>similarly for every <code>Formula</code> and <code>Theorem</code></p>",
        "id": 268159167,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642299135
    },
    {
        "content": "<p>Thank you.</p>",
        "id": 268159250,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642299326
    },
    {
        "content": "<p>Does <code>pred_3</code> also need to take a scope?</p>",
        "id": 268159253,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642299335
    },
    {
        "content": "<p>No, that one specifically should not</p>",
        "id": 268159259,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642299355
    },
    {
        "content": "<p>that's the not free condition we talked about</p>",
        "id": 268159300,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642299368
    },
    {
        "content": "<p>I see.</p>",
        "id": 268159323,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642299429
    },
    {
        "content": "<p>Is there a way to avoid putting the check for each term, formula, theorem and scope at each pattern match? Maybe a way to associate it with the data type?</p>",
        "id": 268161293,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642302575
    },
    {
        "content": "<p>If you make <code>checkBounds'</code> a global function, you can define <code>checkTerm</code> as <code>checkBounds' 0</code>. Yes these are the invariants</p>",
        "id": 268170318,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642317920
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"cm\">{-</span>\n<span class=\"cm\">Hilbert style first order mathematical logic with equality using locally nameless variables.</span>\n\n<span class=\"cm\">Modified from \"Functional Pearl: I am not a Number—I am a Free Variable\"</span>\n<span class=\"cm\">by Conor McBride and James McKinna.</span>\n<span class=\"cm\">https://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf</span>\n<span class=\"cm\">-}</span>\n\n<span class=\"kr\">import</span> <span class=\"nn\">Data.List</span>\n<span class=\"kr\">import</span> <span class=\"nn\">Control.Exception</span>\n\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Func \"c\" [] : A constant named \"c\"</span>\n<span class=\"cm\">Func \"f\" [v] : A function named \"f\" of one variable v</span>\n<span class=\"cm\">-}</span>\n<span class=\"kr\">data</span> <span class=\"kt\">Term</span> <span class=\"ow\">=</span> <span class=\"kt\">F</span> <span class=\"kt\">String</span> <span class=\"c1\">-- A named free variable</span>\n          <span class=\"o\">|</span> <span class=\"kt\">B</span> <span class=\"kt\">Int</span> <span class=\"c1\">-- A De Bruijn indexed bound variable</span>\n          <span class=\"o\">|</span> <span class=\"kt\">Func</span> <span class=\"kt\">String</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span>\n            <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Pred \"P\" [] : A propositional variable named \"P\"</span>\n<span class=\"cm\">Pred \"Eq\" [s, t] : s = t</span>\n<span class=\"cm\">-}</span>\n<span class=\"kr\">data</span> <span class=\"kt\">Formula</span> <span class=\"ow\">=</span> <span class=\"kt\">Pred</span> <span class=\"kt\">String</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Not</span> <span class=\"kt\">Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Imp</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Forall</span> <span class=\"kt\">Scope</span>\n               <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"kr\">newtype</span> <span class=\"kt\">Scope</span> <span class=\"ow\">=</span> <span class=\"kt\">Scope</span> <span class=\"kt\">Formula</span>\n                <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"kr\">newtype</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"kt\">Formula</span>\n                  <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">abstract v p = The result of changing each free variable named v in the formula</span>\n<span class=\"cm\">p to a bound variable that has an index equal to the number of binders above it.</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">abstract</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Scope</span>\n<span class=\"nf\">abstract</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"ow\">=</span> <span class=\"kt\">Scope</span> <span class=\"p\">(</span><span class=\"n\">nameTo</span> <span class=\"mi\">0</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"kr\">where</span>\n  <span class=\"n\">nameTo</span> <span class=\"ow\">::</span> <span class=\"kt\">Int</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span>\n  <span class=\"n\">nameTo</span> <span class=\"n\">outer</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"n\">name</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Pred</span> <span class=\"n\">name</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">map</span> <span class=\"p\">(</span><span class=\"n\">nameTo'</span> <span class=\"n\">outer</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"kr\">where</span>\n    <span class=\"n\">nameTo'</span> <span class=\"ow\">::</span> <span class=\"kt\">Int</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span>\n    <span class=\"n\">nameTo'</span> <span class=\"n\">outer</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">F</span> <span class=\"n\">v'</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">v'</span> <span class=\"kr\">then</span> <span class=\"kt\">B</span> <span class=\"n\">outer</span> <span class=\"kr\">else</span> <span class=\"kt\">F</span> <span class=\"n\">v'</span>\n    <span class=\"n\">nameTo'</span> <span class=\"kr\">_</span> <span class=\"kr\">_</span> <span class=\"p\">(</span><span class=\"kt\">B</span> <span class=\"n\">index</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">B</span> <span class=\"n\">index</span>\n    <span class=\"n\">nameTo'</span> <span class=\"n\">outer</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"n\">name</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Func</span> <span class=\"n\">name</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">map</span> <span class=\"p\">(</span><span class=\"n\">nameTo'</span> <span class=\"n\">outer</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span><span class=\"p\">)</span>\n  <span class=\"n\">nameTo</span> <span class=\"n\">outer</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Not</span> <span class=\"p\">(</span><span class=\"n\">nameTo</span> <span class=\"n\">outer</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n  <span class=\"n\">nameTo</span> <span class=\"n\">outer</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"n\">nameTo</span> <span class=\"n\">outer</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">nameTo</span> <span class=\"n\">outer</span> <span class=\"n\">v</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n  <span class=\"n\">nameTo</span> <span class=\"n\">outer</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"p\">(</span><span class=\"kt\">Scope</span> <span class=\"n\">p</span><span class=\"p\">))</span> <span class=\"ow\">=</span> <span class=\"kt\">Forall</span> <span class=\"p\">(</span><span class=\"kt\">Scope</span> <span class=\"p\">(</span><span class=\"n\">nameTo</span> <span class=\"p\">(</span><span class=\"n\">outer</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">instantiate t (Scope p) = The result of replacing each bound variable that has</span>\n<span class=\"cm\">an index equal to the number of binders above it in the formula p by the term t.</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">instantiate</span> <span class=\"ow\">::</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Scope</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span>\n<span class=\"nf\">instantiate</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"kt\">Scope</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">replace</span> <span class=\"mi\">0</span> <span class=\"n\">t</span> <span class=\"n\">p</span> <span class=\"kr\">where</span>\n  <span class=\"n\">replace</span> <span class=\"ow\">::</span> <span class=\"kt\">Int</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span>\n  <span class=\"n\">replace</span> <span class=\"n\">outer</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"n\">name</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Pred</span> <span class=\"n\">name</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">map</span> <span class=\"p\">(</span><span class=\"n\">replace'</span> <span class=\"n\">outer</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"kr\">where</span>\n    <span class=\"n\">replace'</span> <span class=\"ow\">::</span> <span class=\"kt\">Int</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span>\n    <span class=\"n\">replace'</span> <span class=\"kr\">_</span> <span class=\"kr\">_</span> <span class=\"p\">(</span><span class=\"kt\">F</span> <span class=\"n\">name</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">F</span> <span class=\"n\">name</span>\n    <span class=\"n\">replace'</span> <span class=\"n\">outer</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"kt\">B</span> <span class=\"n\">index</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">outer</span> <span class=\"o\">==</span> <span class=\"n\">index</span> <span class=\"kr\">then</span> <span class=\"n\">t</span> <span class=\"kr\">else</span> <span class=\"kt\">B</span> <span class=\"n\">index</span>\n    <span class=\"n\">replace'</span> <span class=\"n\">outer</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"n\">name</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Func</span> <span class=\"n\">name</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">map</span> <span class=\"p\">(</span><span class=\"n\">replace'</span> <span class=\"n\">outer</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"n\">terms</span><span class=\"p\">)</span>\n  <span class=\"n\">replace</span> <span class=\"n\">outer</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Not</span> <span class=\"p\">(</span><span class=\"n\">replace</span> <span class=\"n\">outer</span> <span class=\"n\">t</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n  <span class=\"n\">replace</span> <span class=\"n\">outer</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"n\">replace</span> <span class=\"n\">outer</span> <span class=\"n\">t</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">replace</span> <span class=\"n\">outer</span> <span class=\"n\">t</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n  <span class=\"n\">replace</span> <span class=\"n\">outer</span> <span class=\"n\">t</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"p\">(</span><span class=\"kt\">Scope</span> <span class=\"n\">p</span><span class=\"p\">))</span> <span class=\"ow\">=</span> <span class=\"kt\">Forall</span> <span class=\"p\">(</span><span class=\"kt\">Scope</span> <span class=\"p\">(</span><span class=\"n\">replace</span> <span class=\"p\">(</span><span class=\"n\">outer</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">t</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">checkTermBounds outer t = The index of each bound variable in term t is</span>\n<span class=\"cm\">less than outer.</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">checkTermBounds</span> <span class=\"ow\">::</span> <span class=\"kt\">Int</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">checkTermBounds</span> <span class=\"kr\">_</span> <span class=\"p\">(</span><span class=\"kt\">F</span> <span class=\"kr\">_</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">True</span>\n<span class=\"nf\">checkTermBounds</span> <span class=\"n\">outer</span> <span class=\"p\">(</span><span class=\"kt\">B</span> <span class=\"n\">index</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">index</span> <span class=\"o\">&lt;</span> <span class=\"n\">outer</span>\n<span class=\"nf\">checkTermBounds</span> <span class=\"n\">outer</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"kr\">_</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">all</span> <span class=\"p\">(</span><span class=\"n\">checkTermBounds</span> <span class=\"n\">outer</span><span class=\"p\">)</span> <span class=\"n\">terms</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">checkFormulaBounds outer p = The index of each bound variable in formula p is</span>\n<span class=\"cm\">less than the number of binders above it plus outer.</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">checkFormulaBounds</span> <span class=\"ow\">::</span> <span class=\"kt\">Int</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">checkFormulaBounds</span> <span class=\"n\">outer</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"kr\">_</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">all</span> <span class=\"p\">(</span><span class=\"n\">checkTermBounds</span> <span class=\"n\">outer</span><span class=\"p\">)</span> <span class=\"n\">terms</span>\n<span class=\"nf\">checkFormulaBounds</span> <span class=\"n\">outer</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">checkFormulaBounds</span> <span class=\"n\">outer</span> <span class=\"n\">p</span>\n<span class=\"nf\">checkFormulaBounds</span> <span class=\"n\">outer</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">checkFormulaBounds</span> <span class=\"n\">outer</span> <span class=\"n\">p</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">checkFormulaBounds</span> <span class=\"n\">outer</span> <span class=\"n\">q</span>\n<span class=\"nf\">checkFormulaBounds</span> <span class=\"n\">outer</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"p\">(</span><span class=\"kt\">Scope</span> <span class=\"n\">p</span><span class=\"p\">))</span> <span class=\"ow\">=</span> <span class=\"n\">checkFormulaBounds</span> <span class=\"p\">(</span><span class=\"n\">outer</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">p</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">checkTerm t = There is no bound variable in t.</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">checkTerm</span> <span class=\"ow\">::</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">checkTerm</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"n\">checkTermBounds</span> <span class=\"mi\">0</span> <span class=\"n\">t</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">checkFormula p = The index of each bound variable in the formula p is</span>\n<span class=\"cm\">less than the number of binders above it.</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">checkFormula</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">checkFormula</span> <span class=\"n\">p</span> <span class=\"ow\">=</span> <span class=\"n\">checkFormulaBounds</span> <span class=\"mi\">0</span> <span class=\"n\">p</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">checkScope (Scope p) = The index of each bound variable in the formula p is</span>\n<span class=\"cm\">less than the number of binders above it plus one.</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">checkScope</span> <span class=\"ow\">::</span> <span class=\"kt\">Scope</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">checkScope</span> <span class=\"p\">(</span><span class=\"kt\">Scope</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">checkFormulaBounds</span> <span class=\"mi\">1</span> <span class=\"n\">p</span>\n\n\n<span class=\"c1\">-- Propositional calculus</span>\n\n<span class=\"c1\">-- |- (p -&gt; (q -&gt; p))</span>\n<span class=\"nf\">prop_1</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">prop_1</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span>\n  <span class=\"n\">assert</span> <span class=\"p\">(</span><span class=\"n\">all</span> <span class=\"n\">checkFormula</span> <span class=\"p\">[</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">q</span><span class=\"p\">])</span> <span class=\"o\">$</span>\n  <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"n\">q</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- ((p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r)))</span>\n<span class=\"nf\">prop_2</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">prop_2</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"ow\">=</span>\n  <span class=\"n\">assert</span> <span class=\"p\">(</span><span class=\"n\">all</span> <span class=\"n\">checkFormula</span> <span class=\"p\">[</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">q</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">])</span> <span class=\"o\">$</span>\n  <span class=\"kt\">Theorem</span> <span class=\"p\">((</span><span class=\"n\">p</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"n\">q</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"n\">r</span><span class=\"p\">))</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">((</span><span class=\"n\">p</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"n\">r</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">-- |- ((~p -&gt; ~q) -&gt; (q -&gt; p))</span>\n<span class=\"nf\">prop_3</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">prop_3</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span>\n  <span class=\"n\">assert</span> <span class=\"p\">(</span><span class=\"n\">all</span> <span class=\"n\">checkFormula</span> <span class=\"p\">[</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">q</span><span class=\"p\">])</span> <span class=\"o\">$</span>\n  <span class=\"kt\">Theorem</span> <span class=\"p\">(((</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"n\">q</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- p &amp; |- (p -&gt; q) =&gt; |- q</span>\n<span class=\"nf\">mp</span> <span class=\"ow\">::</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">mp</span> <span class=\"p\">(</span><span class=\"kt\">Theorem</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"n\">p'</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"ow\">=</span>\n  <span class=\"n\">assert</span> <span class=\"p\">(</span><span class=\"n\">all</span> <span class=\"n\">checkFormula</span> <span class=\"p\">[</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">p'</span><span class=\"p\">,</span> <span class=\"n\">q</span><span class=\"p\">])</span> <span class=\"o\">$</span>\n  <span class=\"kr\">if</span> <span class=\"n\">p</span> <span class=\"o\">==</span> <span class=\"n\">p'</span> <span class=\"kr\">then</span> <span class=\"kt\">Theorem</span> <span class=\"n\">q</span> <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"mp\"</span>\n<span class=\"nf\">mp</span> <span class=\"kr\">_</span> <span class=\"kr\">_</span> <span class=\"ow\">=</span> <span class=\"ne\">error</span> <span class=\"s\">\"mp\"</span>\n\n\n<span class=\"c1\">-- Predicate calculus</span>\n\n<span class=\"c1\">-- |- p =&gt; |- forall v. p</span>\n<span class=\"nf\">gen</span> <span class=\"ow\">::</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">gen</span> <span class=\"p\">(</span><span class=\"kt\">Theorem</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">v</span> <span class=\"ow\">=</span>\n  <span class=\"n\">assert</span> <span class=\"p\">(</span><span class=\"n\">checkFormula</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"o\">$</span>\n  <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"p\">(</span><span class=\"n\">abstract</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- ((forall v. (p -&gt; q)) -&gt; (forall v. p) -&gt; (forall v. q))</span>\n<span class=\"nf\">pred_1</span> <span class=\"ow\">::</span> <span class=\"kt\">Scope</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Scope</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">pred_1</span> <span class=\"p\">(</span><span class=\"kt\">Scope</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Scope</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span>\n  <span class=\"n\">assert</span> <span class=\"p\">(</span><span class=\"n\">all</span> <span class=\"n\">checkScope</span> <span class=\"p\">[(</span><span class=\"kt\">Scope</span> <span class=\"n\">p</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"kt\">Scope</span> <span class=\"n\">q</span><span class=\"p\">)])</span> <span class=\"o\">$</span>\n  <span class=\"kt\">Theorem</span> <span class=\"p\">((</span><span class=\"kt\">Forall</span> <span class=\"p\">(</span><span class=\"kt\">Scope</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"n\">q</span><span class=\"p\">)))</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">((</span><span class=\"kt\">Forall</span> <span class=\"p\">(</span><span class=\"kt\">Scope</span> <span class=\"n\">p</span><span class=\"p\">))</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"p\">(</span><span class=\"kt\">Scope</span> <span class=\"n\">q</span><span class=\"p\">))))</span>\n\n<span class=\"c1\">-- |- (forall v. p -&gt; p [t/v]) provided p admits t for v</span>\n<span class=\"nf\">pred_2</span> <span class=\"ow\">::</span> <span class=\"kt\">Scope</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">pred_2</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"ow\">=</span>\n  <span class=\"n\">assert</span> <span class=\"p\">(</span><span class=\"n\">checkScope</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"o\">$</span>\n  <span class=\"n\">assert</span> <span class=\"p\">(</span><span class=\"n\">checkTerm</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"o\">$</span>\n  <span class=\"kt\">Theorem</span> <span class=\"p\">((</span><span class=\"kt\">Forall</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"n\">instantiate</span> <span class=\"n\">t</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- (p -&gt; forall v. p) provided v is not free in p</span>\n<span class=\"nf\">pred_3</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">pred_3</span> <span class=\"n\">p</span> <span class=\"ow\">=</span>\n  <span class=\"n\">assert</span> <span class=\"p\">(</span><span class=\"n\">checkFormula</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"o\">$</span>\n  <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"p\">(</span><span class=\"kt\">Scope</span> <span class=\"n\">p</span><span class=\"p\">)))</span>\n\n\n<span class=\"c1\">-- Equality</span>\n\n<span class=\"c1\">-- |- t = t</span>\n<span class=\"nf\">eq_1</span> <span class=\"ow\">::</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">eq_1</span> <span class=\"n\">t</span> <span class=\"ow\">=</span>\n  <span class=\"n\">assert</span> <span class=\"p\">(</span><span class=\"n\">checkTerm</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"o\">$</span>\n  <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"s\">\"Eq\"</span> <span class=\"p\">[</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">])</span>\n\n<span class=\"c1\">-- |- s1 = t1 ==&gt; ... ==&gt; sn = tn ==&gt; f(s1,..,sn) = f(t1,..,tn)</span>\n<span class=\"nf\">eq_2</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">eq_2</span> <span class=\"n\">f</span> <span class=\"n\">ss</span> <span class=\"n\">ts</span> <span class=\"ow\">=</span>\n  <span class=\"n\">assert</span> <span class=\"p\">(</span><span class=\"n\">all</span> <span class=\"n\">checkTerm</span> <span class=\"n\">ss</span><span class=\"p\">)</span> <span class=\"o\">$</span>\n  <span class=\"n\">assert</span> <span class=\"p\">(</span><span class=\"n\">all</span> <span class=\"n\">checkTerm</span> <span class=\"n\">ts</span><span class=\"p\">)</span> <span class=\"o\">$</span>\n  <span class=\"kr\">if</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">length</span> <span class=\"n\">ss</span> <span class=\"o\">==</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">length</span> <span class=\"n\">ts</span><span class=\"p\">)</span> <span class=\"kr\">then</span>\n  <span class=\"c1\">-- eqs = [s1 = t1, ..., sn = tn]</span>\n  <span class=\"kr\">let</span> <span class=\"n\">eqs</span> <span class=\"ow\">=</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">zipWith</span> <span class=\"p\">(</span><span class=\"nf\">\\</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"s\">\"Eq\"</span> <span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">]))</span> <span class=\"n\">ss</span> <span class=\"n\">ts</span> <span class=\"kr\">in</span>\n  <span class=\"c1\">-- z = f(s1,..,sn) = f(t1,..,tn)</span>\n  <span class=\"kr\">let</span> <span class=\"n\">z</span> <span class=\"ow\">=</span> <span class=\"kt\">Pred</span> <span class=\"s\">\"Eq\"</span> <span class=\"p\">[(</span><span class=\"kt\">Func</span> <span class=\"n\">f</span> <span class=\"n\">ss</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"n\">f</span> <span class=\"n\">ts</span><span class=\"p\">)]</span> <span class=\"kr\">in</span>\n  <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">foldr</span> <span class=\"kt\">Imp</span> <span class=\"n\">z</span> <span class=\"n\">eqs</span><span class=\"p\">)</span>\n  <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"eq_2\"</span>\n\n<span class=\"c1\">-- |- s1 = t1 ==&gt; ... ==&gt; sn = tn ==&gt; P(s1,..,sn) ==&gt; P(t1,..,tn)</span>\n<span class=\"nf\">eq_3</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">eq_3</span> <span class=\"n\">p</span> <span class=\"n\">ss</span> <span class=\"n\">ts</span> <span class=\"ow\">=</span>\n  <span class=\"n\">assert</span> <span class=\"p\">(</span><span class=\"n\">all</span> <span class=\"n\">checkTerm</span> <span class=\"n\">ss</span><span class=\"p\">)</span> <span class=\"o\">$</span>\n  <span class=\"n\">assert</span> <span class=\"p\">(</span><span class=\"n\">all</span> <span class=\"n\">checkTerm</span> <span class=\"n\">ts</span><span class=\"p\">)</span> <span class=\"o\">$</span>\n  <span class=\"kr\">if</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">length</span> <span class=\"n\">ss</span> <span class=\"o\">==</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">length</span> <span class=\"n\">ts</span><span class=\"p\">)</span> <span class=\"kr\">then</span>\n  <span class=\"c1\">-- eqs = [s1 = t1, ..., sn = tn]</span>\n  <span class=\"kr\">let</span> <span class=\"n\">eqs</span> <span class=\"ow\">=</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">zipWith</span> <span class=\"p\">(</span><span class=\"nf\">\\</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"s\">\"Eq\"</span> <span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">]))</span> <span class=\"n\">ss</span> <span class=\"n\">ts</span> <span class=\"kr\">in</span>\n  <span class=\"c1\">-- z = P(s1,..,sn) ==&gt; P(t1,..,tn)</span>\n  <span class=\"kr\">let</span> <span class=\"n\">z</span> <span class=\"ow\">=</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"n\">p</span> <span class=\"n\">ss</span><span class=\"p\">)</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"n\">p</span> <span class=\"n\">ts</span><span class=\"p\">)</span> <span class=\"kr\">in</span>\n  <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">foldr</span> <span class=\"kt\">Imp</span> <span class=\"n\">z</span> <span class=\"n\">eqs</span><span class=\"p\">)</span>\n  <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"eq_3\"</span>\n</code></pre></div>",
        "id": 268171142,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642319397
    },
    {
        "content": "<p>Am I on the right track here? This is an attempt at implementing a proof checker for natural deduction, but I am not sure I have the predicate and equality rules right. For example, in the exists introduction, are we substituting a variable in for a term?</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"c1\">--import Data.List</span>\n\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Func \"c\" [] : A constant named \"c\"</span>\n<span class=\"cm\">Func \"f\" [v] : A function named \"f\" of one variable v</span>\n<span class=\"cm\">-}</span>\n<span class=\"kr\">data</span> <span class=\"kt\">Term</span> <span class=\"ow\">=</span> <span class=\"kt\">Var</span> <span class=\"kt\">String</span>\n          <span class=\"o\">|</span> <span class=\"kt\">Func</span> <span class=\"kt\">String</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span>\n            <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Pred \"P\" [] : A propositional variable named \"P\"</span>\n<span class=\"cm\">Pred \"Eq\" [s, t] : s = t</span>\n<span class=\"cm\">-}</span>\n<span class=\"kr\">data</span> <span class=\"kt\">Formula</span> <span class=\"ow\">=</span> <span class=\"kt\">Bottom</span> <span class=\"c1\">-- False</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Top</span> <span class=\"c1\">-- True</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Pred</span> <span class=\"kt\">String</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Not</span> <span class=\"kt\">Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">And</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Or</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Imp</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Iff</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Forall</span> <span class=\"kt\">String</span> <span class=\"kt\">Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Exists</span> <span class=\"kt\">String</span> <span class=\"kt\">Formula</span>\n               <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"kr\">data</span> <span class=\"kt\">Proof</span> <span class=\"ow\">=</span> <span class=\"kt\">Assumption</span>\n           <span class=\"o\">|</span> <span class=\"kt\">ImpIntro</span> <span class=\"kt\">Proof</span>\n           <span class=\"o\">|</span> <span class=\"kt\">ImpElim</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Proof</span> <span class=\"kt\">Proof</span>\n           <span class=\"o\">|</span> <span class=\"kt\">AndIntro</span> <span class=\"kt\">Proof</span> <span class=\"kt\">Proof</span>\n           <span class=\"o\">|</span> <span class=\"kt\">AndElimLeft</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Proof</span>\n           <span class=\"o\">|</span> <span class=\"kt\">AndElimRight</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Proof</span>\n           <span class=\"o\">|</span> <span class=\"kt\">NotIntro</span> <span class=\"kt\">Proof</span>\n           <span class=\"o\">|</span> <span class=\"kt\">NotElim</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Proof</span> <span class=\"kt\">Proof</span>\n           <span class=\"o\">|</span> <span class=\"kt\">OrIntroLeft</span> <span class=\"kt\">Proof</span>\n           <span class=\"o\">|</span> <span class=\"kt\">OrIntroRight</span> <span class=\"kt\">Proof</span>\n           <span class=\"o\">|</span> <span class=\"kt\">OrElim</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Proof</span> <span class=\"kt\">Proof</span> <span class=\"kt\">Proof</span>\n           <span class=\"o\">|</span> <span class=\"kt\">BottomElim</span> <span class=\"kt\">Proof</span>\n           <span class=\"o\">|</span> <span class=\"kt\">TopIntro</span>\n           <span class=\"o\">|</span> <span class=\"kt\">IffIntro</span> <span class=\"kt\">Proof</span> <span class=\"kt\">Proof</span>\n           <span class=\"o\">|</span> <span class=\"kt\">IffElimLeft</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Proof</span> <span class=\"kt\">Proof</span>\n           <span class=\"o\">|</span> <span class=\"kt\">IffElimRight</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Proof</span> <span class=\"kt\">Proof</span>\n           <span class=\"o\">|</span> <span class=\"kt\">Contradiction</span> <span class=\"kt\">Proof</span>\n           <span class=\"o\">|</span> <span class=\"kt\">ForallIntro</span> <span class=\"kt\">Proof</span>\n           <span class=\"o\">|</span> <span class=\"kt\">ForallElim</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Term</span> <span class=\"kt\">String</span> <span class=\"kt\">Proof</span>\n           <span class=\"o\">|</span> <span class=\"kt\">ExistsIntro</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Term</span> <span class=\"kt\">Proof</span>\n           <span class=\"o\">|</span> <span class=\"kt\">ExistsElim</span> <span class=\"kt\">Formula</span> <span class=\"kt\">String</span> <span class=\"kt\">String</span> <span class=\"kt\">Proof</span> <span class=\"kt\">Proof</span>\n           <span class=\"o\">|</span> <span class=\"kt\">Reflexivity</span>\n           <span class=\"o\">|</span> <span class=\"kt\">Substitution</span> <span class=\"kt\">Term</span> <span class=\"kt\">Term</span> <span class=\"kt\">Proof</span>\n             <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"kr\">type</span> <span class=\"kt\">Context</span> <span class=\"ow\">=</span> <span class=\"p\">[</span><span class=\"kt\">Formula</span><span class=\"p\">]</span>\n\n\n<span class=\"nf\">occursIn</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">occursIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"n\">name</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">name</span>\n<span class=\"nf\">occursIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"kr\">_</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">any</span> <span class=\"p\">(</span><span class=\"n\">occursIn</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span>\n\n\n<span class=\"c1\">-- freeIn v p = there exists an occurrence of v in p that is free.</span>\n<span class=\"nf\">freeIn</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">freeIn</span> <span class=\"kr\">_</span> <span class=\"kt\">Bottom</span> <span class=\"ow\">=</span> <span class=\"kt\">False</span>\n<span class=\"nf\">freeIn</span> <span class=\"kr\">_</span> <span class=\"kt\">Top</span> <span class=\"ow\">=</span> <span class=\"kt\">False</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"kr\">_</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">any</span> <span class=\"p\">(</span><span class=\"n\">occursIn</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">And</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"o\">||</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">q</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Or</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"o\">||</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">q</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"o\">||</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">q</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Iff</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"o\">||</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">q</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">v</span> <span class=\"o\">/=</span> <span class=\"n\">x</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Exists</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">v</span> <span class=\"o\">/=</span> <span class=\"n\">x</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span>\n\n\n<span class=\"c1\">-- Placeholders</span>\n<span class=\"nf\">sub</span> <span class=\"n\">p</span> <span class=\"kr\">_</span> <span class=\"kr\">_</span> <span class=\"ow\">=</span> <span class=\"n\">p</span>\n<span class=\"nf\">admits</span> <span class=\"kr\">_</span> <span class=\"kr\">_</span> <span class=\"kr\">_</span> <span class=\"ow\">=</span> <span class=\"kt\">True</span>\n\n\n<span class=\"c1\">-- isProofOf a (b, c) = a is a proof of b |- c</span>\n<span class=\"nf\">isProofOf</span> <span class=\"ow\">::</span> <span class=\"kt\">Proof</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Context</span><span class=\"p\">,</span> <span class=\"kt\">Formula</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Assumption:</span>\n<span class=\"cm\">(gamma |- p) if p is in gamma</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">isProofOf</span> <span class=\"kt\">Assumption</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">elem</span> <span class=\"n\">p</span> <span class=\"n\">gamma</span>\n\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Implication introduction:</span>\n<span class=\"cm\">(gamma, p |- q) =&gt; (gamma |- p -&gt; q)</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">isProofOf</span> <span class=\"p\">(</span><span class=\"kt\">ImpIntro</span> <span class=\"n\">sub_proof</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"ow\">=</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof</span> <span class=\"p\">((</span><span class=\"n\">p</span> <span class=\"kt\">:</span> <span class=\"n\">gamma</span><span class=\"p\">),</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Implication elimination:</span>\n<span class=\"cm\">(gamma |- p -&gt; q) &amp;&amp; (gamma |- p) =&gt; (gamma |- q)</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">isProofOf</span> <span class=\"p\">(</span><span class=\"kt\">ImpElim</span> <span class=\"n\">p</span> <span class=\"n\">sub_proof_1</span> <span class=\"n\">sub_proof_2</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof_1</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"o\">&amp;&amp;</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof_2</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">And introduction:</span>\n<span class=\"cm\">(gamma |- p) &amp;&amp; (gamma |- q) =&gt; (gamma |- p /\\ q)</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">isProofOf</span> <span class=\"p\">(</span><span class=\"kt\">AndIntro</span> <span class=\"n\">sub_proof_1</span> <span class=\"n\">sub_proof_2</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">And</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"ow\">=</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof_1</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"o\">&amp;&amp;</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof_2</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">And elimination left:</span>\n<span class=\"cm\">(gamma |- p /\\ q) =&gt; (gamma |- p)</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">isProofOf</span> <span class=\"p\">(</span><span class=\"kt\">AndElimLeft</span> <span class=\"n\">q</span> <span class=\"n\">sub_proof</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">And</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">))</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">And elimination right:</span>\n<span class=\"cm\">(gamma |- p /\\ q) =&gt; (gamma |- q)</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">isProofOf</span> <span class=\"p\">(</span><span class=\"kt\">AndElimRight</span> <span class=\"n\">p</span> <span class=\"n\">sub_proof</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">And</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">))</span>\n\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Not introduction:</span>\n<span class=\"cm\">(gamma, p |- False) =&gt; (gamma |- ~p)</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">isProofOf</span> <span class=\"p\">(</span><span class=\"kt\">NotIntro</span> <span class=\"n\">sub_proof</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">))</span> <span class=\"ow\">=</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof</span> <span class=\"p\">((</span><span class=\"n\">p</span> <span class=\"kt\">:</span> <span class=\"n\">gamma</span><span class=\"p\">),</span> <span class=\"kt\">Bottom</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Not elimination:</span>\n<span class=\"cm\">(gamma |- ~p) &amp;&amp; (gamma |- p) =&gt; (gamma |- False)</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">isProofOf</span> <span class=\"p\">(</span><span class=\"kt\">NotElim</span> <span class=\"n\">p</span> <span class=\"n\">sub_proof_1</span> <span class=\"n\">sub_proof_2</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"kt\">Bottom</span><span class=\"p\">)</span> <span class=\"ow\">=</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof_1</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">))</span> <span class=\"o\">&amp;&amp;</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof_2</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Or introduction left:</span>\n<span class=\"cm\">(gamma |- p) =&gt; (gamma |- p \\/ q)</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">isProofOf</span> <span class=\"p\">(</span><span class=\"kt\">OrIntroLeft</span> <span class=\"n\">sub_proof</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Or</span> <span class=\"n\">p</span> <span class=\"kr\">_</span><span class=\"p\">))</span> <span class=\"ow\">=</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Or introduction right:</span>\n<span class=\"cm\">(gamma |- q) =&gt; (gamma |- p \\/ q)</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">isProofOf</span> <span class=\"p\">(</span><span class=\"kt\">OrIntroRight</span> <span class=\"n\">sub_proof</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Or</span> <span class=\"kr\">_</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"ow\">=</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Or elimination:</span>\n<span class=\"cm\">(gamma |- p \\/ q) &amp;&amp;</span>\n<span class=\"cm\">(gamma, p |- r) &amp;&amp;</span>\n<span class=\"cm\">(gamma, q |- r) =&gt;</span>\n<span class=\"cm\">(gamma |- r)</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">isProofOf</span> <span class=\"p\">(</span><span class=\"kt\">OrElim</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">sub_proof_1</span> <span class=\"n\">sub_proof_2</span> <span class=\"n\">sub_proof_3</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"ow\">=</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof_1</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Or</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"o\">&amp;&amp;</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof_2</span> <span class=\"p\">((</span><span class=\"n\">p</span> <span class=\"kt\">:</span> <span class=\"n\">gamma</span><span class=\"p\">),</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">&amp;&amp;</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof_3</span> <span class=\"p\">((</span><span class=\"n\">q</span> <span class=\"kt\">:</span> <span class=\"n\">gamma</span><span class=\"p\">),</span> <span class=\"n\">r</span><span class=\"p\">)</span>\n\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Bottom elimination:</span>\n<span class=\"cm\">(gamma |- False) =&gt; (gamma |- p)</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">isProofOf</span> <span class=\"p\">(</span><span class=\"kt\">BottomElim</span> <span class=\"n\">sub_proof</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"kr\">_</span><span class=\"p\">)</span> <span class=\"ow\">=</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"kt\">Bottom</span><span class=\"p\">)</span>\n\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Top introduction:</span>\n<span class=\"cm\">(gamma |- True)</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">isProofOf</span> <span class=\"kt\">TopIntro</span> <span class=\"p\">(</span><span class=\"kr\">_</span><span class=\"p\">,</span> <span class=\"kt\">Top</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">True</span>\n\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Iff introduction:</span>\n<span class=\"cm\">(gamma, p |- q) &amp;&amp; (gamma, q |- p) =&gt; (gamma |- p &lt;=&gt; q)</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">isProofOf</span> <span class=\"p\">(</span><span class=\"kt\">IffIntro</span> <span class=\"n\">sub_proof_1</span> <span class=\"n\">sub_proof_2</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Iff</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"ow\">=</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof_1</span> <span class=\"p\">((</span><span class=\"n\">p</span> <span class=\"kt\">:</span> <span class=\"n\">gamma</span><span class=\"p\">),</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"o\">&amp;&amp;</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof_2</span> <span class=\"p\">((</span><span class=\"n\">q</span> <span class=\"kt\">:</span> <span class=\"n\">gamma</span><span class=\"p\">),</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Iff elimination left:</span>\n<span class=\"cm\">(gamma |- p &lt;-&gt; q) &amp;&amp; (gamma |- p) =&gt; (gamma |- q)</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">isProofOf</span> <span class=\"p\">(</span><span class=\"kt\">IffElimLeft</span> <span class=\"n\">p</span> <span class=\"n\">sub_proof_1</span> <span class=\"n\">sub_proof_2</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof_1</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Iff</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"o\">&amp;&amp;</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof_2</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Iff elimination right:</span>\n<span class=\"cm\">(gamma |- p &lt;-&gt; q) &amp;&amp; (gamma |- q) =&gt; (gamma |- p)</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">isProofOf</span> <span class=\"p\">(</span><span class=\"kt\">IffElimRight</span> <span class=\"n\">q</span> <span class=\"n\">sub_proof_1</span> <span class=\"n\">sub_proof_2</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof_1</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Iff</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"o\">&amp;&amp;</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof_2</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Contradiction:</span>\n<span class=\"cm\">(gamma, ~p |- False) =&gt; (gamma |- p)</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">isProofOf</span> <span class=\"p\">(</span><span class=\"kt\">Contradiction</span> <span class=\"n\">sub_proof</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof</span> <span class=\"p\">(((</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"kt\">:</span> <span class=\"n\">gamma</span><span class=\"p\">),</span> <span class=\"kt\">Bottom</span><span class=\"p\">)</span>\n\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Forall introduction:</span>\n<span class=\"cm\">(gamma |- p) &amp;&amp;</span>\n<span class=\"cm\">(x not free in gamma) =&gt;</span>\n<span class=\"cm\">(gamma |- forall x. p)</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">isProofOf</span> <span class=\"p\">(</span><span class=\"kt\">ForallIntro</span> <span class=\"n\">sub_proof</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">))</span> <span class=\"ow\">=</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"o\">&amp;&amp;</span>\n  <span class=\"n\">not</span> <span class=\"p\">(</span><span class=\"n\">any</span> <span class=\"p\">(</span><span class=\"n\">freeIn</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"n\">gamma</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Forall elimination:</span>\n<span class=\"cm\">(gamma |- forall x. p) &amp;&amp;</span>\n<span class=\"cm\">(p admits t for x) =&gt;</span>\n<span class=\"cm\">(gamma |- p[t/x])</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">isProofOf</span> <span class=\"p\">(</span><span class=\"kt\">ForallElim</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">x</span> <span class=\"n\">sub_proof</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"n\">p'</span><span class=\"p\">)</span> <span class=\"ow\">=</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">))</span> <span class=\"o\">&amp;&amp;</span>\n  <span class=\"n\">admits</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">x</span> <span class=\"o\">&amp;&amp;</span>\n  <span class=\"n\">p'</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"n\">sub</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">x</span><span class=\"p\">)</span>\n\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Exists introduction:</span>\n<span class=\"cm\">(gamma |- p) &amp;&amp;</span>\n<span class=\"cm\">(p admits x for t) =&gt;</span>\n<span class=\"cm\">(gamma |- exists x. p [x/t])</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">isProofOf</span> <span class=\"p\">(</span><span class=\"kt\">ExistsIntro</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">sub_proof</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Exists</span> <span class=\"n\">x</span> <span class=\"n\">p'</span><span class=\"p\">))</span> <span class=\"ow\">=</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"o\">&amp;&amp;</span>\n  <span class=\"n\">admits</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"n\">t</span> <span class=\"o\">&amp;&amp;</span>\n  <span class=\"n\">p'</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"n\">sub</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"n\">t</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Exists elimination:</span>\n<span class=\"cm\">(gamma |- exists x. p) &amp;&amp;</span>\n<span class=\"cm\">(gamma, p [y/x] |- q) &amp;&amp;</span>\n<span class=\"cm\">(y not free in q) &amp;&amp;</span>\n<span class=\"cm\">(y not free in gamma) =&gt;</span>\n<span class=\"cm\">(gamma |- q)</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">isProofOf</span> <span class=\"p\">(</span><span class=\"kt\">ExistsElim</span> <span class=\"n\">p</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"n\">sub_proof_1</span> <span class=\"n\">sub_proof_2</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof_1</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Exists</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"p\">))</span> <span class=\"o\">&amp;&amp;</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof_2</span> <span class=\"p\">(((</span><span class=\"n\">sub</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"kt\">:</span> <span class=\"n\">gamma</span><span class=\"p\">),</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"o\">&amp;&amp;</span>\n  <span class=\"n\">not</span> <span class=\"p\">(</span><span class=\"n\">freeIn</span> <span class=\"n\">y</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"o\">&amp;&amp;</span>\n  <span class=\"n\">not</span> <span class=\"p\">(</span><span class=\"n\">any</span> <span class=\"p\">(</span><span class=\"n\">freeIn</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"n\">gamma</span><span class=\"p\">)</span>\n\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Reflexivity:</span>\n<span class=\"cm\">(gamma |- t = t)</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">isProofOf</span> <span class=\"kt\">Reflexivity</span> <span class=\"p\">(</span><span class=\"kr\">_</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"s\">\"Eq\"</span> <span class=\"p\">[</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">t'</span><span class=\"p\">]))</span> <span class=\"ow\">=</span> <span class=\"n\">t</span> <span class=\"o\">==</span> <span class=\"n\">t'</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Substitution:</span>\n<span class=\"cm\">(gamma |- s = t) =&gt; (gamma |- p = p [t/s])</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">isProofOf</span> <span class=\"p\">(</span><span class=\"kt\">Substitution</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">sub_proof</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"s\">\"Eq\"</span> <span class=\"p\">[</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">p'</span><span class=\"p\">]))</span> <span class=\"ow\">=</span>\n  <span class=\"n\">isProofOf</span> <span class=\"n\">sub_proof</span> <span class=\"p\">(</span><span class=\"n\">gamma</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"s\">\"Eq\"</span> <span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">]))</span> <span class=\"o\">&amp;&amp;</span>\n  <span class=\"n\">p'</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"n\">sub</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">s</span><span class=\"p\">)</span>\n\n<span class=\"nf\">isProofOf</span> <span class=\"kr\">_</span> <span class=\"p\">(</span><span class=\"kr\">_</span><span class=\"p\">,</span> <span class=\"kr\">_</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">False</span>\n</code></pre></div>",
        "id": 268175284,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642325919
    },
    {
        "content": "<p>Your rule for <code>ForallIntro</code> is problematic because you don't have a weakening rule: you won't be able to prove e.g. <code>x = x |- forall x. True</code>. One way to fix it is instead of checking <code>not (any (freeIn x) gamma)</code> you filter out everything from <code>gamma</code> which has a free <code>x</code> in the subproof.</p>",
        "id": 268179806,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642333406
    },
    {
        "content": "<p>Your rule for <code>ExistsIntro</code> is backwards. You still want \"p admits t for x\" but the substitution is in the hypothesis, not the conclusion:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Exists</span> <span class=\"n\">introduction</span><span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">gamma</span> <span class=\"bp\">|-</span> <span class=\"n\">p</span> <span class=\"o\">[</span><span class=\"n\">t</span><span class=\"bp\">/</span><span class=\"n\">x</span><span class=\"o\">])</span> <span class=\"bp\">&amp;&amp;</span>\n<span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">admits</span> <span class=\"n\">t</span> <span class=\"n\">for</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n<span class=\"o\">(</span><span class=\"n\">gamma</span> <span class=\"bp\">|-</span> <span class=\"n\">exists</span> <span class=\"n\">x.</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 268179881,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642333517
    },
    {
        "content": "<p>Alternatively you can just add a weakening rule <code>Weakening gamma' subproof</code> that checks that <code>gamma'</code> is a subset of the input context <code>gamma</code></p>",
        "id": 268179922,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642333605
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268179806\">said</a>:</p>\n<blockquote>\n<p>Your rule for <code>ForallIntro</code> is problematic because you don't have a weakening rule: you won't be able to prove e.g. <code>x = x |- forall x. True</code>. One way to fix it is instead of checking <code>not (any (freeIn x) gamma)</code> you filter out everything from <code>gamma</code> which has a free <code>x</code> in the subproof.</p>\n</blockquote>\n<p>Hmm. I was attempting to interpret the statement in Logic and Proof (<a href=\"https://leanprover.github.io/logic_and_proof/first_order_logic.html#the-universal-quantifier\">https://leanprover.github.io/logic_and_proof/first_order_logic.html#the-universal-quantifier</a>) <code>A(x) =&gt; Forall x. A(x) provided x is not free in any uncancelled hypothesis</code>. Did I interpret it wrong, or did I miss something in the text?</p>",
        "id": 268193213,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642349599
    },
    {
        "content": "<p>I guess I was not sure how \"not free in any uncancelled hypothesis\" should translate. I'm not sure what you mean by \"filter out everything from gamma which has a free x in the subproof.\".</p>",
        "id": 268194377,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642351181
    },
    {
        "content": "<p>That is, how do you code a check for a variable being free in a subproof?</p>",
        "id": 268194627,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642351533
    },
    {
        "content": "<p>Is it the same as checking \"if x is a free variable in p, then x is not free in any formula in gamma\"?</p>",
        "id": 268195193,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642352244
    },
    {
        "content": "<p>I guess you write a function pattern matching on the <code>Proof</code> type?</p>",
        "id": 268209895,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642371117
    },
    {
        "content": "<p>I'm confused though, doesn't the gamma hold all of the uncancelled hypothesis?  So why is it not, according to \"Logic and Proof\", just a check that x is not free in gamma?</p>",
        "id": 268211328,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642373253
    },
    {
        "content": "<p>Is there a missing axiom in \"Logic and Proof\"?</p>",
        "id": 268211365,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642373283
    },
    {
        "content": "<p>Usually logic books treat <code>gamma</code> as a set, but you used a list. That's the difference.</p>",
        "id": 268226969,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642394380
    },
    {
        "content": "<p>Some books treat it as a list, and additionally includes what's called <strong>structural</strong> rules. Removing some of those gives you substructural logcis like affine, relevant, linear, noncommutive etc.</p>",
        "id": 268227032,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642394430
    },
    {
        "content": "<p>So I don't need a weakening rule if I use a set instead of a list?</p>",
        "id": 268227174,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642394586
    },
    {
        "content": "<p>If so, I'm not sure I see why that solves the example Mario posted?</p>",
        "id": 268227260,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642394697
    },
    {
        "content": "<p>You do need an additional weakening rule, because the <code>not free in gamma</code> requirements do not respect weakening.</p>",
        "id": 268227329,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642394769
    },
    {
        "content": "<p>All the other rules respect weakening, so using only those rules, if <code>gamma |- p</code> is provable, then starting the proof all over again with <code>gamma ++ delta</code> instead still gives you a proof.</p>",
        "id": 268227366,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642394835
    },
    {
        "content": "<p>The alternative as Mario points out, is, eg</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">gamma</span> <span class=\"bp\">|-</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n<span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">gamma</span> <span class=\"bp\">++</span> <span class=\"n\">delta</span> <span class=\"bp\">|-</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 268227529,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642395026
    },
    {
        "content": "<p>So regardless if gamma is a set or a list, I need a weakening rule, correct? I guess I can see why it might be needed, but I'm curious why I haven't seen it listed in what I have been able to find for predicate calculus in natural deduction.</p>",
        "id": 268227544,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642395046
    },
    {
        "content": "<p>Would you happen to have a reference that includes it?</p>",
        "id": 268227608,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642395123
    },
    {
        "content": "<p>In pure propositional calculus you don't need it, as I argued above. In the \"tree form\" of natural deduction it is also not needed, because weakening is automatic.</p>",
        "id": 268227628,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642395136
    },
    {
        "content": "<p>What is the tree form?</p>",
        "id": 268227644,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642395169
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"n\">p</span>     <span class=\"n\">q</span>\n<span class=\"c1\">-------</span>\n  <span class=\"n\">p</span> <span class=\"bp\">&amp;</span> <span class=\"n\">q</span>\n</code></pre></div>\n<p>Note that this proves <code>p, q |- p &amp; q</code>, but the <code>|-</code> doesn't appear.</p>",
        "id": 268227818,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642395393
    },
    {
        "content": "<p>Oh, I thought they were just implicit when I saw that.</p>",
        "id": 268227836,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642395437
    },
    {
        "content": "<p>So you don't have assumptions?</p>",
        "id": 268227911,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642395487
    },
    {
        "content": "<p>You do, the assumptions are exactly the leaves of the derivation tree, <code>p</code> and <code>q</code> in this case.</p>",
        "id": 268227934,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642395523
    },
    {
        "content": "<p>Those aren't proofs of p and q?</p>",
        "id": 268227971,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642395586
    },
    {
        "content": "<p>No.</p>\n<p>To formulate this properly, you need the rule for conjunction to be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">gamma</span> <span class=\"bp\">|-</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">&amp;&amp;</span>\n<span class=\"o\">(</span><span class=\"n\">delta</span> <span class=\"bp\">|-</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n<span class=\"o\">(</span><span class=\"n\">gamma</span> <span class=\"bp\">++</span> <span class=\"n\">delta</span> <span class=\"bp\">|-</span> <span class=\"n\">p</span> <span class=\"n\">and</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Because the leaves of the tree sitting on <code>p</code> and <code>q</code>, respectively, are combined.</p>",
        "id": 268228146,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642395690
    },
    {
        "content": "<p>But you also need to use a set, because, well, leaves don't have an order.</p>",
        "id": 268228212,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642395728
    },
    {
        "content": "<p>How would the proof for the example Mario gave work in that instance?</p>",
        "id": 268228364,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642395952
    },
    {
        "content": "<p>Somehow combine <code>x = x |- ?</code> and <code>|- forall x, true</code>?</p>",
        "id": 268228430,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642396025
    },
    {
        "content": "<p>I wonder if this is a better way to formulate it. I could use functions that take a proof of p and a proof of q and return a proof of p /\\ q and not have to compare the gammas.</p>",
        "id": 268228547,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642396167
    },
    {
        "content": "<p>Just combine them.</p>",
        "id": 268228557,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642396186
    },
    {
        "content": "<p>Forward instead of backwards reasoning I guess.</p>",
        "id": 268228626,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642396259
    },
    {
        "content": "<p>Is this Sequent natural deduction?</p>",
        "id": 268229138,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642396876
    },
    {
        "content": "<p>What would the set of rules need to be to match the logic in lean?</p>",
        "id": 268229970,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642397951
    },
    {
        "content": "<p>What I would like to have or create is a proof assistant for first order logic and axiomatic set theory, that has source code freely and publicly available (Mizar's doesn't seem to be?) that is easy to read and understand (probably preferably Haskell or similar), is close to standard texts or explains the reason for each deviation and why it is valid, and allows proofs to be constructed in a style such as</p>\n<ol>\n<li>statement, justification from axiom ax_1 using substitutions p, q.</li>\n<li>statement, justification from theorem th_1 using substitutions r, s and line 1.</li>\n<li>statement, justification from rule_1 using substitutions t, u and line 2.<br>\nI think meta math may be the closest to this?, but the last time I tried (admittedly some time ago) I couldn't figure out the gui assistant, and I couldn't find the api that I assumed it used to create my own. I also wish the axioms for the logic were closer to the standard texts, although I think I may understand why they are not. It would be cool if the standard texts could be derived from them and vice versa. I'm not sure if I can write proofs in it in the form shown above? I might not mind working on it to achieve this, if that is possible.<br>\nThe reason for the Haskell code is in part to help understand the logic rules more clearly, and in part an attempt at a start to create the above.</li>\n</ol>",
        "id": 268234352,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642403010
    },
    {
        "content": "<p>MM0 has a vscode extension. Maybe that solves your gui issues?</p>",
        "id": 268234427,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1642403063
    },
    {
        "content": "<p>Maybe. I'll take a look.</p>",
        "id": 268234459,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642403111
    },
    {
        "content": "<p>Thank you.</p>",
        "id": 268234483,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642403139
    },
    {
        "content": "<p>My initial impression is that it may be more complicated than I had hoped, maybe in part because it starts at a lower level? Nice tutorial video.</p>",
        "id": 268235977,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642404683
    },
    {
        "content": "<p>An aside: If you do that in Haskell and use the mechanisms of Haskell to create definitions, then during typechecking the definitions definitely will blow up exponentially. So you need something to prevent it from happening...</p>",
        "id": 268238894,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642407223
    },
    {
        "content": "<p>Like, if you implement a definition hierarchy as described in Metamath or Lean, it will get expanded all the way down when your checker tries to see if two terms are equal.</p>",
        "id": 268238996,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642407276
    },
    {
        "content": "<p>So you need something in the axioms of the logic to handle definitions?</p>",
        "id": 268293833,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642438375
    },
    {
        "content": "<p>How is it addressed in Lean and MetaMath?</p>",
        "id": 268295575,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642439332
    },
    {
        "content": "<p>Lean has the reducible/semireducible/opaque distinction, and other well-established stuff in type theory. Metamath does not have \"definitions\". Every new definition is actually little axioms, with additional checks which are detailed on the website.</p>",
        "id": 268296598,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642440050
    },
    {
        "content": "<p>It looks like in mm0 definitions are part of the formal grammar.</p>",
        "id": 268297941,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642440941
    },
    {
        "content": "<p>Is there a resource that explains more in depth the theory of definitions in mm0?</p>",
        "id": 268301192,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642443071
    },
    {
        "content": "<p>Aside from issues of efficiency, just to ensure my understanding, is this a correct implementation of first order logic with equality? Especially the <code>admitsVar</code> and <code>admitsTerm</code> functions? Thank you.</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"cm\">{-</span>\n<span class=\"cm\">Hilbert style first order mathematical logic with equality using named variables.</span>\n\n<span class=\"cm\">Modified from \"Handbook of Practical Logic and Automated Reasoning\" by John Harrison.</span>\n<span class=\"cm\">https://www.cl.cam.ac.uk/~jrh13/atp/index.html</span>\n<span class=\"cm\">-}</span>\n\n<span class=\"kr\">import</span> <span class=\"nn\">Data.List</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Func \"c\" [] : A constant named \"c\"</span>\n<span class=\"cm\">Func \"f\" [v] : A function named \"f\" of one variable v</span>\n<span class=\"cm\">-}</span>\n<span class=\"kr\">data</span> <span class=\"kt\">Term</span> <span class=\"ow\">=</span> <span class=\"kt\">Var</span> <span class=\"kt\">String</span>\n          <span class=\"o\">|</span> <span class=\"kt\">Func</span> <span class=\"kt\">String</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span>\n            <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Pred \"P\" [] : A propositional variable named \"P\"</span>\n<span class=\"cm\">Pred \"Eq\" [s, t] : s = t</span>\n<span class=\"cm\">-}</span>\n<span class=\"kr\">data</span> <span class=\"kt\">Formula</span> <span class=\"ow\">=</span> <span class=\"kt\">Pred</span> <span class=\"kt\">String</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Not</span> <span class=\"kt\">Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Imp</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Forall</span> <span class=\"kt\">String</span> <span class=\"kt\">Formula</span>\n               <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"kr\">newtype</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"kt\">Formula</span>\n                  <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">From \"First Order Mathematical Logic\" by Angelo Margaris:</span>\n\n<span class=\"cm\">An occurrence of a variable $v$ in a formula $P$ is bound if and only if</span>\n<span class=\"cm\">it occurs in a subformula of $P$ of the form $\\forall v Q$. An occurrence</span>\n<span class=\"cm\">of $v$ in $P$ is free if and only if it is not a bound occurrence. The</span>\n<span class=\"cm\">variable $v$ is free or bound in $P$ according as it has a free or bound</span>\n<span class=\"cm\">occurrence in $P$.</span>\n\n<span class=\"cm\">If $P$ is a formula, $v$ is a variable, and $t$ is a term, then $P(t/v)$ is</span>\n<span class=\"cm\">the result of replacing each free occurrence of $v$ in $P$ by an occurrence</span>\n<span class=\"cm\">of $t$.</span>\n\n<span class=\"cm\">If $v$ and $u$ are variables and $P$ is a formula, then $P$ admits $u$ for $v$</span>\n<span class=\"cm\">if and only if there is no free occurrence of $v$ in $P$ that becomes a</span>\n<span class=\"cm\">bound occurrence of $u$ in $P(u/v)$. If $t$ is a term, then $P$ admits $t$ for</span>\n<span class=\"cm\">$v$ if and only if $P$ admits for $v$ every variable in $t$.</span>\n<span class=\"cm\">-}</span>\n\n<span class=\"c1\">-- occursIn v t = there exists an occurrence of v in t.</span>\n<span class=\"nf\">occursIn</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">occursIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"n\">v'</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">v'</span>\n<span class=\"nf\">occursIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"kr\">_</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">any</span> <span class=\"p\">(</span><span class=\"n\">occursIn</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span>\n\n<span class=\"c1\">-- freeIn v p = there exists an occurrence of v in p that is free.</span>\n<span class=\"nf\">freeIn</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"kr\">_</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">any</span> <span class=\"p\">(</span><span class=\"n\">occursIn</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"o\">||</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">q</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v'</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">v</span> <span class=\"o\">/=</span> <span class=\"n\">v'</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">subIn p t v = p(t/v) = the result of replacing each free occurrence of</span>\n<span class=\"cm\">v in p by an occurrence of t.</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">subIn</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span>\n<span class=\"nf\">subIn</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"n\">name</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"kt\">Pred</span> <span class=\"n\">name</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">map</span> <span class=\"p\">(</span><span class=\"nf\">\\</span><span class=\"n\">t'</span> <span class=\"ow\">-&gt;</span> <span class=\"n\">subInTerm</span> <span class=\"n\">t'</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"kr\">where</span>\n  <span class=\"cm\">{-</span>\n<span class=\"cm\">  subInTerm t' t v = t'(t/v) = the result of replacing each occurrence of</span>\n<span class=\"cm\">  v in t' by an occurrence of t.</span>\n<span class=\"cm\">  -}</span>\n  <span class=\"n\">subInTerm</span> <span class=\"ow\">::</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span>\n  <span class=\"n\">subInTerm</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"n\">v'</span><span class=\"p\">)</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">v'</span> <span class=\"kr\">then</span> <span class=\"n\">t</span> <span class=\"kr\">else</span> <span class=\"kt\">Var</span> <span class=\"n\">v'</span>\n  <span class=\"n\">subInTerm</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"n\">name</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"kt\">Func</span> <span class=\"n\">name</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">map</span> <span class=\"p\">(</span><span class=\"nf\">\\</span><span class=\"n\">t'</span> <span class=\"ow\">-&gt;</span> <span class=\"n\">subInTerm</span> <span class=\"n\">t'</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span><span class=\"p\">)</span>\n<span class=\"nf\">subIn</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"kt\">Not</span> <span class=\"p\">(</span><span class=\"n\">subIn</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n<span class=\"nf\">subIn</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"n\">subIn</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">subIn</span> <span class=\"n\">q</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n<span class=\"nf\">subIn</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v'</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">v'</span> <span class=\"kr\">then</span> <span class=\"kt\">Forall</span> <span class=\"n\">v'</span> <span class=\"n\">p</span> <span class=\"kr\">else</span> <span class=\"kt\">Forall</span> <span class=\"n\">v'</span> <span class=\"p\">(</span><span class=\"n\">subIn</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">admitsVar p u v = p admits u for v = there is no free occurrence of</span>\n<span class=\"cm\">v in p that becomes a bound occurrence of u in p(u/v).</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">admitsVar</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">admitsVar</span> <span class=\"n\">p</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"n\">go</span> <span class=\"n\">p</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"kt\">[]</span> <span class=\"kr\">where</span>\n  <span class=\"n\">go</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">String</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n  <span class=\"n\">go</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"kr\">_</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">binders</span> <span class=\"ow\">=</span> <span class=\"n\">not</span> <span class=\"p\">(</span><span class=\"n\">any</span> <span class=\"p\">(</span><span class=\"n\">occursIn</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span><span class=\"p\">)</span>\n                               <span class=\"o\">||</span> <span class=\"n\">elem</span> <span class=\"n\">v</span> <span class=\"n\">binders</span>\n                               <span class=\"o\">||</span> <span class=\"n\">notElem</span> <span class=\"n\">u</span> <span class=\"n\">binders</span>\n  <span class=\"n\">go</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">binders</span> <span class=\"ow\">=</span> <span class=\"n\">go</span> <span class=\"n\">p</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">binders</span>\n  <span class=\"n\">go</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">binders</span> <span class=\"ow\">=</span> <span class=\"n\">go</span> <span class=\"n\">p</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">binders</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">go</span> <span class=\"n\">q</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">binders</span>\n  <span class=\"n\">go</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v'</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">binders</span> <span class=\"ow\">=</span> <span class=\"n\">go</span> <span class=\"n\">p</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"n\">v'</span> <span class=\"kt\">:</span> <span class=\"n\">binders</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">admitsTerm p t v = p admits for v every variable in t.</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">admitsTerm</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">admitsTerm</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"n\">u</span><span class=\"p\">)</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"n\">admitsVar</span> <span class=\"n\">p</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"nf\">admitsTerm</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"kr\">_</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"n\">all</span> <span class=\"p\">(</span><span class=\"nf\">\\</span><span class=\"n\">t</span> <span class=\"ow\">-&gt;</span> <span class=\"n\">admitsTerm</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span>\n\n\n<span class=\"c1\">-- Propositional calculus</span>\n\n<span class=\"c1\">-- |- (p -&gt; (q -&gt; p))</span>\n<span class=\"nf\">prop_1</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">prop_1</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"n\">q</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- ((p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r)))</span>\n<span class=\"nf\">prop_2</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">prop_2</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">((</span><span class=\"n\">p</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"n\">q</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"n\">r</span><span class=\"p\">))</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">((</span><span class=\"n\">p</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"n\">r</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">-- |- ((~p -&gt; ~q) -&gt; (q -&gt; p))</span>\n<span class=\"nf\">prop_3</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">prop_3</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(((</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"n\">q</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- p &amp; |- (p -&gt; q) =&gt; |- q</span>\n<span class=\"nf\">mp</span> <span class=\"ow\">::</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">mp</span> <span class=\"p\">(</span><span class=\"kt\">Theorem</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"n\">p'</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">p</span> <span class=\"o\">==</span> <span class=\"n\">p'</span> <span class=\"kr\">then</span> <span class=\"kt\">Theorem</span> <span class=\"n\">q</span> <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"mp\"</span>\n<span class=\"nf\">mp</span> <span class=\"kr\">_</span> <span class=\"kr\">_</span> <span class=\"ow\">=</span> <span class=\"ne\">error</span> <span class=\"s\">\"mp\"</span>\n\n\n<span class=\"c1\">-- Predicate calculus</span>\n\n<span class=\"c1\">-- |- p =&gt; |- forall v. p</span>\n<span class=\"nf\">gen</span> <span class=\"ow\">::</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">gen</span> <span class=\"p\">(</span><span class=\"kt\">Theorem</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n\n<span class=\"c1\">-- |- ((forall v. (p -&gt; q)) -&gt; (forall v. p) -&gt; (forall v. q))</span>\n<span class=\"nf\">pred_1</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">pred_1</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">((</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">((</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"n\">q</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">-- |- (forall v. p -&gt; p [t/v]) provided p admits t for v</span>\n<span class=\"nf\">pred_2</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">pred_2</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">admitsTerm</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"kr\">then</span> <span class=\"kt\">Theorem</span> <span class=\"p\">((</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"n\">subIn</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">))</span> <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"pred_2\"</span>\n\n<span class=\"c1\">-- |- (p -&gt; forall v. p) provided v is not free in p</span>\n<span class=\"nf\">pred_3</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">pred_3</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">not</span> <span class=\"p\">(</span><span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"kr\">then</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">))</span> <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"pred_3\"</span>\n\n\n<span class=\"c1\">-- Equality</span>\n\n<span class=\"c1\">-- |- t = t</span>\n<span class=\"nf\">eq_1</span> <span class=\"ow\">::</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">eq_1</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"s\">\"Eq\"</span> <span class=\"p\">[</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">])</span>\n\n<span class=\"c1\">-- |- s1 = t1 ==&gt; ... ==&gt; sn = tn ==&gt; f(s1,..,sn) = f(t1,..,tn)</span>\n<span class=\"nf\">eq_2</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">eq_2</span> <span class=\"n\">f</span> <span class=\"n\">ss</span> <span class=\"n\">ts</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">length</span> <span class=\"n\">ss</span> <span class=\"o\">==</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">length</span> <span class=\"n\">ts</span> <span class=\"kr\">then</span>\n               <span class=\"c1\">-- eqs = [s1 = t1, ..., sn = tn]</span>\n               <span class=\"kr\">let</span> <span class=\"n\">eqs</span> <span class=\"ow\">=</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">zipWith</span> <span class=\"p\">(</span><span class=\"nf\">\\</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"s\">\"Eq\"</span> <span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">]))</span> <span class=\"n\">ss</span> <span class=\"n\">ts</span> <span class=\"kr\">in</span>\n               <span class=\"c1\">-- z = f(s1,..,sn) = f(t1,..,tn)</span>\n               <span class=\"kr\">let</span> <span class=\"n\">z</span> <span class=\"ow\">=</span> <span class=\"kt\">Pred</span> <span class=\"s\">\"Eq\"</span> <span class=\"p\">[(</span><span class=\"kt\">Func</span> <span class=\"n\">f</span> <span class=\"n\">ss</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"n\">f</span> <span class=\"n\">ts</span><span class=\"p\">)]</span> <span class=\"kr\">in</span>\n               <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">foldr</span> <span class=\"kt\">Imp</span> <span class=\"n\">z</span> <span class=\"n\">eqs</span><span class=\"p\">)</span>\n               <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"eq_2\"</span>\n\n<span class=\"c1\">-- |- s1 = t1 ==&gt; ... ==&gt; sn = tn ==&gt; P(s1,..,sn) ==&gt; P(t1,..,tn)</span>\n<span class=\"nf\">eq_3</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">eq_3</span> <span class=\"n\">p</span> <span class=\"n\">ss</span> <span class=\"n\">ts</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">length</span> <span class=\"n\">ss</span> <span class=\"o\">==</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">length</span> <span class=\"n\">ts</span> <span class=\"kr\">then</span>\n               <span class=\"c1\">-- eqs = [s1 = t1, ..., sn = tn]</span>\n               <span class=\"kr\">let</span> <span class=\"n\">eqs</span> <span class=\"ow\">=</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">zipWith</span> <span class=\"p\">(</span><span class=\"nf\">\\</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"s\">\"Eq\"</span> <span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">]))</span> <span class=\"n\">ss</span> <span class=\"n\">ts</span> <span class=\"kr\">in</span>\n               <span class=\"c1\">-- z = P(s1,..,sn) ==&gt; P(t1,..,tn)</span>\n               <span class=\"kr\">let</span> <span class=\"n\">z</span> <span class=\"ow\">=</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"n\">p</span> <span class=\"n\">ss</span><span class=\"p\">)</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"n\">p</span> <span class=\"n\">ts</span><span class=\"p\">)</span> <span class=\"kr\">in</span>\n               <span class=\"kt\">Theorem</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">foldr</span> <span class=\"kt\">Imp</span> <span class=\"n\">z</span> <span class=\"n\">eqs</span><span class=\"p\">)</span>\n               <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"eq_3\"</span>\n</code></pre></div>",
        "id": 268309235,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642448700
    },
    {
        "content": "<p>The theory of definitions in MM0 is described in the <a href=\"https://arxiv.org/abs/1910.10703\">Metamath Zero paper</a> (Fig. 3, p.11). It's basically a pared-down version of lean's defeq judgment: there is a proof rule that lets you replace an expression with one obtained by unfolding some definition inside the expression.</p>",
        "id": 268327823,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642464919
    },
    {
        "content": "<p>Thank you. I saw that, but I had trouble following the notation, and I'm not familiar with multi sorted FOL.</p>",
        "id": 268328656,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642465796
    },
    {
        "content": "<p>That is, I don't know if it being multi sorted is part of the notation.</p>",
        "id": 268328720,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642465843
    },
    {
        "content": "<p>I guess I should add some context :)</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"cm\">{-</span>\n<span class=\"cm\">Hilbert style first order mathematical logic with equality using named variables.</span>\n\n<span class=\"cm\">Modified from \"Handbook of Practical Logic and Automated Reasoning\" by John Harrison.</span>\n<span class=\"cm\">https://www.cl.cam.ac.uk/~jrh13/atp/index.html</span>\n<span class=\"cm\">-}</span>\n\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Func \"c\" [] : A constant named \"c\"</span>\n<span class=\"cm\">Func \"f\" [v] : A function named \"f\" of one variable v</span>\n<span class=\"cm\">-}</span>\n<span class=\"kr\">data</span> <span class=\"kt\">Term</span> <span class=\"ow\">=</span> <span class=\"kt\">Var</span> <span class=\"kt\">String</span>\n          <span class=\"o\">|</span> <span class=\"kt\">Func</span> <span class=\"kt\">String</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span>\n            <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Pred \"P\" [] : A propositional variable named \"P\"</span>\n<span class=\"cm\">Pred \"Eq\" [s, t] : s = t</span>\n<span class=\"cm\">-}</span>\n<span class=\"kr\">data</span> <span class=\"kt\">Formula</span> <span class=\"ow\">=</span> <span class=\"kt\">Pred</span> <span class=\"kt\">String</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Not</span> <span class=\"kt\">Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Imp</span> <span class=\"kt\">Formula</span> <span class=\"kt\">Formula</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Forall</span> <span class=\"kt\">String</span> <span class=\"kt\">Formula</span>\n               <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"kr\">type</span> <span class=\"kt\">Context</span> <span class=\"ow\">=</span> <span class=\"p\">[</span><span class=\"kt\">Formula</span><span class=\"p\">]</span>\n\n<span class=\"kr\">data</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"kt\">Context</span> <span class=\"kt\">Formula</span>\n               <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span> <span class=\"kt\">Eq</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">From \"First Order Mathematical Logic\" by Angelo Margaris:</span>\n\n<span class=\"cm\">An occurrence of a variable $v$ in a formula $P$ is bound if and only if</span>\n<span class=\"cm\">it occurs in a subformula of $P$ of the form $\\forall v Q$. An occurrence</span>\n<span class=\"cm\">of $v$ in $P$ is free if and only if it is not a bound occurrence. The</span>\n<span class=\"cm\">variable $v$ is free or bound in $P$ according as it has a free or bound</span>\n<span class=\"cm\">occurrence in $P$.</span>\n\n<span class=\"cm\">If $P$ is a formula, $v$ is a variable, and $t$ is a term, then $P(t/v)$ is</span>\n<span class=\"cm\">the result of replacing each free occurrence of $v$ in $P$ by an occurrence</span>\n<span class=\"cm\">of $t$.</span>\n\n<span class=\"cm\">If $v$ and $u$ are variables and $P$ is a formula, then $P$ admits $u$ for $v$</span>\n<span class=\"cm\">if and only if there is no free occurrence of $v$ in $P$ that becomes a</span>\n<span class=\"cm\">bound occurrence of $u$ in $P(u/v)$. If $t$ is a term, then $P$ admits $t$ for</span>\n<span class=\"cm\">$v$ if and only if $P$ admits for $v$ every variable in $t$.</span>\n<span class=\"cm\">-}</span>\n\n<span class=\"c1\">-- occursIn v t = there exists an occurrence of v in t.</span>\n<span class=\"nf\">occursIn</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">occursIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"n\">v'</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">v'</span>\n<span class=\"nf\">occursIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"kr\">_</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">any</span> <span class=\"p\">(</span><span class=\"n\">occursIn</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span>\n\n<span class=\"c1\">-- freeIn v p = there exists an occurrence of v in p that is free.</span>\n<span class=\"nf\">freeIn</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"kr\">_</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">any</span> <span class=\"p\">(</span><span class=\"n\">occursIn</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"o\">||</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">q</span>\n<span class=\"nf\">freeIn</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v'</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"n\">v</span> <span class=\"o\">/=</span> <span class=\"n\">v'</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">subIn p t v = p(t/v) = the result of replacing each free occurrence of</span>\n<span class=\"cm\">v in p by an occurrence of t.</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">subIn</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span>\n<span class=\"nf\">subIn</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"n\">name</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"kt\">Pred</span> <span class=\"n\">name</span> <span class=\"p\">(</span><span class=\"n\">map</span> <span class=\"p\">(</span><span class=\"nf\">\\</span><span class=\"n\">t'</span> <span class=\"ow\">-&gt;</span> <span class=\"n\">subInTerm</span> <span class=\"n\">t'</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"kr\">where</span>\n  <span class=\"cm\">{-</span>\n<span class=\"cm\">  subInTerm t' t v = t'(t/v) = the result of replacing each occurrence of</span>\n<span class=\"cm\">  v in t' by an occurrence of t.</span>\n<span class=\"cm\">  -}</span>\n  <span class=\"n\">subInTerm</span> <span class=\"ow\">::</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span>\n  <span class=\"n\">subInTerm</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"n\">v'</span><span class=\"p\">)</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">v'</span> <span class=\"kr\">then</span> <span class=\"n\">t</span> <span class=\"kr\">else</span> <span class=\"kt\">Var</span> <span class=\"n\">v'</span>\n  <span class=\"n\">subInTerm</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"n\">name</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"kt\">Func</span> <span class=\"n\">name</span> <span class=\"p\">(</span><span class=\"n\">map</span> <span class=\"p\">(</span><span class=\"nf\">\\</span><span class=\"n\">t'</span> <span class=\"ow\">-&gt;</span> <span class=\"n\">subInTerm</span> <span class=\"n\">t'</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span><span class=\"p\">)</span>\n<span class=\"nf\">subIn</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"kt\">Not</span> <span class=\"p\">(</span><span class=\"n\">subIn</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n<span class=\"nf\">subIn</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"kt\">Imp</span> <span class=\"p\">(</span><span class=\"n\">subIn</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">subIn</span> <span class=\"n\">q</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n<span class=\"nf\">subIn</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v'</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">v'</span> <span class=\"kr\">then</span> <span class=\"kt\">Forall</span> <span class=\"n\">v'</span> <span class=\"n\">p</span> <span class=\"kr\">else</span> <span class=\"kt\">Forall</span> <span class=\"n\">v'</span> <span class=\"p\">(</span><span class=\"n\">subIn</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">admitsVar p u v = p admits u for v = there is no free occurrence of</span>\n<span class=\"cm\">v in p that becomes a bound occurrence of u in p(u/v).</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">admitsVar</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">admitsVar</span> <span class=\"n\">p</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"n\">go</span> <span class=\"n\">p</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"kt\">[]</span> <span class=\"kr\">where</span>\n  <span class=\"n\">go</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">String</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n  <span class=\"n\">go</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"kr\">_</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">binders</span> <span class=\"ow\">=</span> <span class=\"n\">not</span> <span class=\"p\">(</span><span class=\"n\">any</span> <span class=\"p\">(</span><span class=\"n\">occursIn</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span><span class=\"p\">)</span>\n                               <span class=\"o\">||</span> <span class=\"n\">elem</span> <span class=\"n\">v</span> <span class=\"n\">binders</span>\n                               <span class=\"o\">||</span> <span class=\"n\">notElem</span> <span class=\"n\">u</span> <span class=\"n\">binders</span>\n  <span class=\"n\">go</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">binders</span> <span class=\"ow\">=</span> <span class=\"n\">go</span> <span class=\"n\">p</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">binders</span>\n  <span class=\"n\">go</span> <span class=\"p\">(</span><span class=\"kt\">Imp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">binders</span> <span class=\"ow\">=</span> <span class=\"n\">go</span> <span class=\"n\">p</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">binders</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">go</span> <span class=\"n\">q</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">binders</span>\n  <span class=\"n\">go</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v'</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">binders</span> <span class=\"ow\">=</span> <span class=\"n\">go</span> <span class=\"n\">p</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"n\">v'</span> <span class=\"kt\">:</span> <span class=\"n\">binders</span><span class=\"p\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">admitsTerm p t v = p admits for v every variable in t.</span>\n<span class=\"cm\">-}</span>\n<span class=\"nf\">admitsTerm</span> <span class=\"ow\">::</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">admitsTerm</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"n\">u</span><span class=\"p\">)</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"n\">admitsVar</span> <span class=\"n\">p</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"nf\">admitsTerm</span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"kr\">_</span> <span class=\"n\">terms</span><span class=\"p\">)</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"n\">all</span> <span class=\"p\">(</span><span class=\"nf\">\\</span><span class=\"n\">t</span> <span class=\"ow\">-&gt;</span> <span class=\"n\">admitsTerm</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">terms</span>\n\n\n<span class=\"c1\">-- Assumption</span>\n\n<span class=\"nf\">assume</span> <span class=\"ow\">::</span> <span class=\"kt\">Context</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">assume</span> <span class=\"n\">gamma</span> <span class=\"n\">p</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">elem</span> <span class=\"n\">p</span> <span class=\"n\">gamma</span> <span class=\"kr\">then</span> <span class=\"kt\">Theorem</span> <span class=\"n\">gamma</span> <span class=\"n\">p</span> <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"assume\"</span>\n\n\n<span class=\"c1\">-- Propositional calculus</span>\n\n<span class=\"c1\">-- |- (p -&gt; (q -&gt; p))</span>\n<span class=\"nf\">prop_1</span> <span class=\"ow\">::</span> <span class=\"kt\">Context</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">prop_1</span> <span class=\"n\">gamma</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"n\">gamma</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"n\">q</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- ((p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r)))</span>\n<span class=\"nf\">prop_2</span> <span class=\"ow\">::</span> <span class=\"kt\">Context</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">prop_2</span> <span class=\"n\">gamma</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"n\">gamma</span> <span class=\"p\">((</span><span class=\"n\">p</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"n\">q</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"n\">r</span><span class=\"p\">))</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">((</span><span class=\"n\">p</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"n\">q</span><span class=\"p\">)</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"n\">r</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">-- |- ((~p -&gt; ~q) -&gt; (q -&gt; p))</span>\n<span class=\"nf\">prop_3</span> <span class=\"ow\">::</span> <span class=\"kt\">Context</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">prop_3</span> <span class=\"n\">gamma</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"n\">gamma</span> <span class=\"p\">(((</span><span class=\"kt\">Not</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"kt\">Not</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"n\">q</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n\n<span class=\"c1\">-- |- p &amp; |- (p -&gt; q) =&gt; |- q</span>\n<span class=\"nf\">mp</span> <span class=\"ow\">::</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">mp</span> <span class=\"p\">(</span><span class=\"kt\">Theorem</span> <span class=\"n\">gamma</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">Theorem</span> <span class=\"n\">gamma'</span> <span class=\"p\">(</span><span class=\"n\">p'</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"n\">q</span><span class=\"p\">))</span>\n       <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">gamma</span> <span class=\"o\">==</span> <span class=\"n\">gamma'</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">p</span> <span class=\"o\">==</span> <span class=\"n\">p'</span> <span class=\"kr\">then</span> <span class=\"kt\">Theorem</span> <span class=\"n\">gamma</span> <span class=\"n\">q</span> <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"mp\"</span>\n<span class=\"nf\">mp</span> <span class=\"kr\">_</span> <span class=\"kr\">_</span> <span class=\"ow\">=</span> <span class=\"ne\">error</span> <span class=\"s\">\"mp\"</span>\n\n\n<span class=\"c1\">-- Predicate calculus</span>\n\n<span class=\"c1\">-- |- p =&gt; |- forall v. p</span>\n<span class=\"nf\">gen</span> <span class=\"ow\">::</span> <span class=\"kt\">Theorem</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">gen</span> <span class=\"p\">(</span><span class=\"kt\">Theorem</span> <span class=\"n\">gamma</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">v</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"n\">gamma</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n\n<span class=\"c1\">-- |- ((forall v. (p -&gt; q)) -&gt; (forall v. p) -&gt; (forall v. q))</span>\n<span class=\"nf\">pred_1</span> <span class=\"ow\">::</span> <span class=\"kt\">Context</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">pred_1</span> <span class=\"n\">gamma</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"n\">gamma</span> <span class=\"p\">((</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"n\">q</span><span class=\"p\">))</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">((</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"n\">q</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">-- |- (forall v. p -&gt; p [t/v]) provided p admits t for v</span>\n<span class=\"nf\">pred_2</span> <span class=\"ow\">::</span> <span class=\"kt\">Context</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">pred_2</span> <span class=\"n\">gamma</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">admitsTerm</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"kr\">then</span> <span class=\"kt\">Theorem</span> <span class=\"n\">gamma</span> <span class=\"p\">((</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"n\">subIn</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"p\">))</span> <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"pred_2\"</span>\n\n<span class=\"c1\">-- |- (p -&gt; forall v. p) provided v is not free in p</span>\n<span class=\"nf\">pred_3</span> <span class=\"ow\">::</span> <span class=\"kt\">Context</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Formula</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">pred_3</span> <span class=\"n\">gamma</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">not</span> <span class=\"p\">(</span><span class=\"n\">freeIn</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"kr\">then</span> <span class=\"kt\">Theorem</span> <span class=\"n\">gamma</span> <span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"kt\">Forall</span> <span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"p\">))</span> <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"pred_3\"</span>\n\n\n<span class=\"c1\">-- Equality</span>\n\n<span class=\"c1\">-- |- t = t</span>\n<span class=\"nf\">eq_1</span> <span class=\"ow\">::</span> <span class=\"kt\">Context</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">eq_1</span> <span class=\"n\">gamma</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"kt\">Theorem</span> <span class=\"n\">gamma</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"s\">\"Eq\"</span> <span class=\"p\">[</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">])</span>\n\n<span class=\"c1\">-- |- s1 = t1 ==&gt; ... ==&gt; sn = tn ==&gt; f(s1,..,sn) = f(t1,..,tn)</span>\n<span class=\"nf\">eq_2</span> <span class=\"ow\">::</span> <span class=\"kt\">Context</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">eq_2</span> <span class=\"n\">gamma</span> <span class=\"n\">f</span> <span class=\"n\">ss</span> <span class=\"n\">ts</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">length</span> <span class=\"n\">ss</span> <span class=\"o\">==</span> <span class=\"n\">length</span> <span class=\"n\">ts</span> <span class=\"kr\">then</span>\n                     <span class=\"c1\">-- eqs = [s1 = t1, ..., sn = tn]</span>\n                     <span class=\"kr\">let</span> <span class=\"n\">eqs</span> <span class=\"ow\">=</span> <span class=\"n\">zipWith</span> <span class=\"p\">(</span><span class=\"nf\">\\</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"s\">\"Eq\"</span> <span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">]))</span> <span class=\"n\">ss</span> <span class=\"n\">ts</span> <span class=\"kr\">in</span>\n                     <span class=\"c1\">-- z = f(s1,..,sn) = f(t1,..,tn)</span>\n                     <span class=\"kr\">let</span> <span class=\"n\">z</span> <span class=\"ow\">=</span> <span class=\"kt\">Pred</span> <span class=\"s\">\"Eq\"</span> <span class=\"p\">[(</span><span class=\"kt\">Func</span> <span class=\"n\">f</span> <span class=\"n\">ss</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"kt\">Func</span> <span class=\"n\">f</span> <span class=\"n\">ts</span><span class=\"p\">)]</span> <span class=\"kr\">in</span>\n                     <span class=\"kt\">Theorem</span> <span class=\"n\">gamma</span> <span class=\"p\">(</span><span class=\"n\">foldr</span> <span class=\"kt\">Imp</span> <span class=\"n\">z</span> <span class=\"n\">eqs</span><span class=\"p\">)</span>\n                     <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"eq_2\"</span>\n\n<span class=\"c1\">-- |- s1 = t1 ==&gt; ... ==&gt; sn = tn ==&gt; P(s1,..,sn) ==&gt; P(t1,..,tn)</span>\n<span class=\"nf\">eq_3</span> <span class=\"ow\">::</span> <span class=\"kt\">Context</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">String</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Theorem</span>\n<span class=\"nf\">eq_3</span> <span class=\"n\">gamma</span> <span class=\"n\">p</span> <span class=\"n\">ss</span> <span class=\"n\">ts</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">length</span> <span class=\"n\">ss</span> <span class=\"o\">==</span> <span class=\"n\">length</span> <span class=\"n\">ts</span> <span class=\"kr\">then</span>\n                     <span class=\"c1\">-- eqs = [s1 = t1, ..., sn = tn]</span>\n                     <span class=\"kr\">let</span> <span class=\"n\">eqs</span> <span class=\"ow\">=</span> <span class=\"n\">zipWith</span> <span class=\"p\">(</span><span class=\"nf\">\\</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"ow\">-&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"s\">\"Eq\"</span> <span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">]))</span> <span class=\"n\">ss</span> <span class=\"n\">ts</span> <span class=\"kr\">in</span>\n                     <span class=\"c1\">-- z = P(s1,..,sn) ==&gt; P(t1,..,tn)</span>\n                     <span class=\"kr\">let</span> <span class=\"n\">z</span> <span class=\"ow\">=</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"n\">p</span> <span class=\"n\">ss</span><span class=\"p\">)</span> <span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span> <span class=\"p\">(</span><span class=\"kt\">Pred</span> <span class=\"n\">p</span> <span class=\"n\">ts</span><span class=\"p\">)</span> <span class=\"kr\">in</span>\n                     <span class=\"kt\">Theorem</span> <span class=\"n\">gamma</span> <span class=\"p\">(</span><span class=\"n\">foldr</span> <span class=\"kt\">Imp</span> <span class=\"n\">z</span> <span class=\"n\">eqs</span><span class=\"p\">)</span>\n                     <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"eq_3\"</span>\n</code></pre></div>",
        "id": 268331019,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642468218
    },
    {
        "content": "<p>Do formulas in the context need to be closed, that is have no free variables? Or do the predicate rules have to add a check that a variable is not free in the context?</p>",
        "id": 268331278,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642468472
    },
    {
        "content": "<p>For example, I could have:<br>\nx = 5 |- x = 5 from assume<br>\nx = 5 | forall x. x = 5 from gen<br>\nwhich I don't thing makes sense.</p>",
        "id": 268332594,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642469738
    },
    {
        "content": "<p>Sorry, I got pulled away. Here's a variation on that definition schema that may fit better with your formulation:</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"kr\">data</span> <span class=\"kt\">FuncDef</span> <span class=\"ow\">=</span> <span class=\"kt\">FuncDef</span> <span class=\"p\">{</span>\n  <span class=\"n\">name</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span><span class=\"p\">,</span>\n  <span class=\"n\">arity</span> <span class=\"ow\">::</span> <span class=\"kt\">Integer</span><span class=\"p\">,</span>\n  <span class=\"n\">defn</span> <span class=\"ow\">::</span> <span class=\"kt\">Maybe</span> <span class=\"p\">([</span><span class=\"kt\">String</span><span class=\"p\">],</span> <span class=\"kt\">Term</span><span class=\"p\">)</span> <span class=\"p\">}</span>\n\n<span class=\"kr\">data</span> <span class=\"kt\">PredDef</span> <span class=\"ow\">=</span> <span class=\"kt\">PredDef</span> <span class=\"p\">{</span>\n  <span class=\"n\">name</span> <span class=\"ow\">::</span> <span class=\"kt\">String</span><span class=\"p\">,</span>\n  <span class=\"n\">arity</span> <span class=\"ow\">::</span> <span class=\"kt\">Integer</span><span class=\"p\">,</span>\n  <span class=\"n\">defn</span> <span class=\"ow\">::</span> <span class=\"kt\">Maybe</span> <span class=\"p\">([</span><span class=\"kt\">String</span><span class=\"p\">],</span> <span class=\"kt\">Formula</span><span class=\"p\">)</span> <span class=\"p\">}</span>\n</code></pre></div>\n<ul>\n<li>A global context is a <code>(Map String FuncDef, Map String PredDef)</code> tracking definitions of functions and predicates.</li>\n<li>For a <code>Term</code> or <code>Formula</code> to be well formed, it must only use functions/predicates in the context and the arity must match.</li>\n<li>You can extend the context with a function if:<ul>\n<li>The function has not already been defined</li>\n<li>The arity is nonnegative</li>\n<li>The definition is either<ul>\n<li>not provided (it is an axiomatic term constructor), or</li>\n<li>the <code>[String]</code> is a list of length <code>arity</code>, and the <code>Term</code> contains no free variables not in the list</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>(similarly for predicates)</li>\n</ul>",
        "id": 268333033,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642470177
    },
    {
        "content": "<p>For your last question, you normally wouldn't have a context in the hilbert-style axiomatization you are using. If you want to have one anyway, I would say that the formulas in the context should all be closed, and/or they are treated as universally quantified over everything. In such a situation, <code>x = 5 |- forall x. x = 5</code> is a reasonable derivation</p>",
        "id": 268333268,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642470424
    },
    {
        "content": "<p>You certainly don't have to apologize, I really appreciate any of your time.<br>\nThat is what I had initially assumed, and then I was reminded of the deduction theorem, which while a meta theorem, seems to talk about a Hilbert system with a context?</p>",
        "id": 268333522,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642470648
    },
    {
        "content": "<p>So then there is a rule to somehow allow a definition from this global context to be unfolded in a term or formula?</p>",
        "id": 268334377,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642471341
    },
    {
        "content": "<p>What do <code>[String]</code> and <code>Term</code> and <code>Formula</code> represent, get used for, in the <code>Maybe</code>s?</p>",
        "id": 268334632,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642471675
    },
    {
        "content": "<p>The list of variables occurring in the <code>Term</code> and in the <code>Formula</code>?</p>",
        "id": 268335503,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642472535
    },
    {
        "content": "<p>So <code>name</code> is the name of the function/predicate, <code>arity</code> is the number of variables in the function/predicate, <code>[String]</code> in <code>def</code> is the list of variables in the function/predicate, and <code>Term</code>/<code>Formula</code> in <code>def</code> is the actual <code>Function</code> or <code>Formula</code> we are giving a name to? What is the difference in the <code>name</code> in <code>FuncDef</code> and <code>PredDef</code>  and the <code>String</code> in the global context?</p>",
        "id": 268335774,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642472837
    },
    {
        "content": "<blockquote>\n<p>What is the difference in the name in FuncDef and PredDef and the String in the global context?</p>\n</blockquote>\n<p>They are the same. You can probably do without <code>name</code> if you like, but it is nice to have it stored explicitly sometimes</p>",
        "id": 268338126,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642475452
    },
    {
        "content": "<p>For example, we could define <code>ne</code> as <code>PredDef \"ne\" 2 (Just ([\"x\", \"y\"], Not (Pred \"eq\" [Var \"x\", Var \"y\"])))</code></p>",
        "id": 268338226,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642475608
    },
    {
        "content": "<p>I see. Why is it a <code>Maybe</code>?</p>",
        "id": 268338302,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642475708
    },
    {
        "content": "<p>We would define <code>eq</code> as <code>PredDef \"Eq\" 2 Nothing</code></p>",
        "id": 268338312,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642475729
    },
    {
        "content": "<p>You have to actually check that terms are well formed now, because you don't want definitions to reference themselves or future definitions</p>",
        "id": 268338384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642475798
    },
    {
        "content": "<p>so even axiomatic term constructors like <code>Eq</code> need to have declarations</p>",
        "id": 268338394,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642475818
    },
    {
        "content": "<p>I see. So what happens to the definitions of <code>Term</code> and <code>Formula</code>? Do they change?</p>",
        "id": 268338506,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642475976
    },
    {
        "content": "<p>I'm guessing not?</p>",
        "id": 268338582,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642476060
    },
    {
        "content": "<p>How do these get used, and how does it avoid this:<br>\n\"<br>\nAn aside: If you do that in Haskell and use the mechanisms of Haskell to create definitions, then during typechecking the definitions definitely will blow up exponentially. So you need something to prevent it from happening...<br>\n\"</p>",
        "id": 268338764,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642476284
    },
    {
        "content": "<p>The blowup problem is avoided because if you have a definition of something complicated like <code>Pred \"IsPerfectoidSpace\" [X]</code> then it is represented as just that, not the thing it unfolds to</p>",
        "id": 268338909,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642476476
    },
    {
        "content": "<p>things are only unfolded when you need it, via a new primitive unfolding rule</p>",
        "id": 268338962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642476509
    },
    {
        "content": "<p>Oh. I see. If you don't mind, what would that rule look like in my formulation?</p>",
        "id": 268338998,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642476578
    },
    {
        "content": "<p>The unfolding rule says <code>P(t1, ... tn) = p[t1/x1, ..., tn/xn]</code> assuming the <code>ti</code> are free for <code>xi</code> in <code>p</code> and <code>P(x1, ..., xn) := p</code></p>",
        "id": 268339078,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642476625
    },
    {
        "content": "<p>although if you have substitution rules you can probably get away with just the equality <code>P(x1, ..., xn) = p</code></p>",
        "id": 268339098,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642476666
    },
    {
        "content": "<p>The <code>:=</code> means the string <code>p</code> maps to the predicate/function <code>P</code> in the global context?</p>",
        "id": 268339295,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642476928
    },
    {
        "content": "<p>Do <code>Formula</code> and <code>Term</code> get extended somehow?</p>",
        "id": 268339586,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642477248
    },
    {
        "content": "<p>The other way around; <code>P(x1, ..., xn) := p</code> means <code>lookup (snd globalCtx) P = PredDef P n (Just ([x1, ..., xn], p))</code></p>",
        "id": 268339685,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642477354
    },
    {
        "content": "<p><code>Formula</code> and <code>Term</code> are not extended, because we are reusing the <code>Func</code> and <code>Pred</code> constructors already in the grammar to represent definitions</p>",
        "id": 268339703,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642477399
    },
    {
        "content": "<p>I'm sorry, would you mind giving an example of how <code>ne</code> is used inside a formula?</p>",
        "id": 268339894,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642477575
    },
    {
        "content": "<p>That is, how would you construct a <code>Formula</code> that uses <code>ne</code>?</p>",
        "id": 268339928,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642477616
    },
    {
        "content": "<p><code>Pred \"ne\" [Var \"u\", Var \"v\"]</code>?</p>",
        "id": 268340034,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642477700
    },
    {
        "content": "<p>Then to unfold it you look up \"ne\" in the map of predicates, check that its arity is equal to <code>length [Var \"u\", Var \"v\"]</code>, check that <code>x</code> admits <code>u</code> and <code>y</code> admits <code>v</code> in <code>Not (Pred \"Eq\" [Var \"x\", Var \"y\"])</code>, then produce <code>Theorem (Pred \"Eq\" [Pred \"ne\" [Var \"u\", Var \"v\"]], Not (Pred \"Eq\" [Var \"u\", Var \"v\"])])</code>?</p>",
        "id": 268340612,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642478306
    },
    {
        "content": "<p>Yes, that's how you construct it. To unfold it, you would use a rule <code>unfold : String -&gt; [Term] -&gt; Theorem</code> such that <code>unfold \"ne\" [Var \"u\", Var \"v\"] = Theorem (Iff (Pred \"ne\" [Var \"u\", Var \"v\"]) (Not (Pred \"Eq\" [Var \"u\", Var \"v\"])))</code></p>",
        "id": 268341099,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642478720
    },
    {
        "content": "<p>With the conditions on the matching arity and admits?</p>",
        "id": 268341234,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642478835
    },
    {
        "content": "<p>The arity conditions exist on everything - to construct a <code>Term</code> in the first place you have to have the right arity</p>",
        "id": 268341331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642478933
    },
    {
        "content": "<p>one way to do this is to add a \"smart constructor\" for <code>Pred</code></p>",
        "id": 268341349,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642478960
    },
    {
        "content": "<p>not sure what you mean by admits</p>",
        "id": 268341358,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642478989
    },
    {
        "content": "<p>I think <code>free for</code> in your terminology.</p>",
        "id": 268341413,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642479025
    },
    {
        "content": "<p>ah yes, you need that for the version that does a substitution</p>",
        "id": 268341432,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642479057
    },
    {
        "content": "<p>the simpler version can just have the type <code>unfold : String -&gt; Theorem</code> and just uses the list of variables intrinsic to the predicate definition</p>",
        "id": 268341447,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642479102
    },
    {
        "content": "<p>So in the simpler version you would just have <code>Theorem (Iff (Pred \"ne\" [Var \"x\", Var \"y\"]) (Not (Pred \"Eq\" [Var \"x\", Var \"y\"])))</code>? How would that then get used to replace the <code>Pred \"ne\" [Var \"u\", Var \"v\"]</code></p>",
        "id": 268341818,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642479614
    },
    {
        "content": "<p>Use the equality axioms?</p>",
        "id": 268341847,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642479664
    },
    {
        "content": "<p>Then could you just as easily replace <code>Term</code> and <code>Formula</code> by <code>Theorem</code> in the global definition context?</p>",
        "id": 268341921,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642479777
    },
    {
        "content": "<p>I guess, how does this differ from just adding definitions as axioms?</p>",
        "id": 268341993,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642479875
    },
    {
        "content": "<p>I guess then because they would always be expanded, and then you would get the exponential blowup.</p>",
        "id": 268342073,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642479971
    },
    {
        "content": "<p>But I guess you could still replace <code>Term</code> and <code>Formula</code> in the mapped to definition by the resulting <code>Theorem</code>?</p>",
        "id": 268342091,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642480051
    },
    {
        "content": "<p>Or does having it done by the rule somehow ensure that the logic remains consistent?</p>",
        "id": 268342188,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642480161
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268341921\">said</a>:</p>\n<blockquote>\n<p>Then could you just as easily replace <code>Term</code> and <code>Formula</code> by <code>Theorem</code> in the global definition context?</p>\n</blockquote>\n<p>Sure, you could store it as a <code>Theorem</code> if you want.<br>\n<span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268341993\">said</a>:</p>\n<blockquote>\n<p>I guess, how does this differ from just adding definitions as axioms?</p>\n</blockquote>\n<p>Because it's not just any axiom, it has a particular form, namely an equality between the new definition (fully applied to distinct variables) and some expression with no additional free variables. This is checked in the <code>addTermDef : Context -&gt; String -&gt; [String] -&gt; Term -&gt; Context</code> function</p>",
        "id": 268343188,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642481406
    },
    {
        "content": "<p>I think I might see. I'll try to add it to my current code sometime in the next week or so and play around with it. Sorry to barrage you with questions, I'm not sure where else to ask. Thank you for your patience!</p>",
        "id": 268343611,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642481933
    },
    {
        "content": "<p>thank you for starting this thread too, I've had this question for quite a long time and this thread has been very insightful</p>",
        "id": 268346124,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1642484825
    },
    {
        "content": "<p>I added support for definitions using the algorithm from Mario. How does this look? Did I follow the algorithm correctly? <a href=\"/user_uploads/3121/Q89tPxr4vYHjLF7DBCUpHFUh/Hilbert_NV_Def.hs\">Hilbert_NV_Def.hs</a></p>",
        "id": 268940638,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642832420
    },
    {
        "content": "<p>Is that the right way to unfold the definition of a predicate?</p>",
        "id": 268942292,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642834838
    },
    {
        "content": "<p>If I moved this to locally nameless variables would it be a practical kernel for a proof assistant?</p>",
        "id": 268968202,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642872547
    },
    {
        "content": "<p>One danger of this approach for an LCF style kernel (i.e. everything in this module is made private except for the API and the user is allowed to call any API functions and should not be able to prove false) is that <code>Term</code> and <code>Theorem</code> have to be valid in a given <code>Context</code> but nothing enforces this. That means that I can prove <code>foo &lt;-&gt; True</code> in a context defining <code>foo = True</code>, and <code>foo &lt;-&gt; False</code> in a different context with <code>foo = False</code>, and then use <code>mp</code> and friends on both <code>Theorem</code>s (since <code>mp</code> doesn't take a <code>Context</code>) to prove <code>True &lt;-&gt; False</code> and hence <code>False</code></p>",
        "id": 268972570,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642878406
    },
    {
        "content": "<p>Isabelle handles this by having a global context manager that can be queried to see whether two contexts (which are now IDs into the context manager state) are compatible (i.e. one is obtained by extension from another), and each <code>Term</code> and <code>Theorem</code> is tupled with the context in which it was constructed; any primitive rule which takes more than one <code>Term</code>/<code>Formula</code>/<code>Theorem</code> takes the union of the contexts involved and they must all be compatible.</p>\n<p>Metamath handles this by making the context itself global state. <code>Term</code> and <code>Theorem</code> don't carry any context information but should be valid in the current context. There is no context branching in this model, but it makes validity checking a lot easier.</p>",
        "id": 268972897,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642878879
    },
    {
        "content": "<p>In Haskell you could probably also use some kind of phantom type/GADT/singleton encoding (really what you want is a phantom dependent type)</p>",
        "id": 268973069,
        "sender_full_name": "Reid Barton",
        "timestamp": 1642879166
    },
    {
        "content": "<p>I'm not sure what a phantom dependent type is.</p>",
        "id": 268973225,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642879404
    },
    {
        "content": "<p>You can look it up on the Haskell wiki, the concept is quite simple.</p>",
        "id": 268973247,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642879438
    },
    {
        "content": "<p>Would the metamath approach here be to make <code>Theorem</code> a <code>(Context, Formula)</code> pair and have <code>mp</code> check that the contexts are the same?</p>",
        "id": 268973308,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642879501
    },
    {
        "content": "<p>Are you saying we would make the type of <code>Theorem</code> be dependent on <code>Context</code>?</p>",
        "id": 268973694,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642880143
    },
    {
        "content": "<p>There are currently no dependent types in Haskell, right?</p>",
        "id": 268973767,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642880260
    },
    {
        "content": "<p>What do you mean by a <code>Term</code> being valid in a given <code>Context</code>? I can see <code>Theorem</code> but I'm not sure I understand <code>Term</code>.</p>",
        "id": 268973912,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642880452
    },
    {
        "content": "<blockquote>\n<p>Are you saying we would make the type of <code>Theorem</code> be dependent on <code>Context</code>?</p>\n</blockquote>\n<p>No.</p>\n<blockquote>\n<p>There are currently no dependent types in Haskell, right?</p>\n</blockquote>\n<p>No.</p>",
        "id": 268974150,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642880775
    },
    {
        "content": "<p>Uh, probably should be \"it depends (no pun intended) on how dependent you want it to be\"</p>",
        "id": 268974167,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642880839
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268973308\">said</a>:</p>\n<blockquote>\n<p>Would the metamath approach here be to make <code>Theorem</code> a <code>(Context, Formula)</code> pair and have <code>mp</code> check that the contexts are the same?</p>\n</blockquote>\n<p>Is this right?</p>",
        "id": 268975234,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642882068
    },
    {
        "content": "<p>As I did here, but without the assumption rule? <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268331019\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268331019</a></p>",
        "id": 268975324,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642882196
    },
    {
        "content": "<p>I guess the basic question is, what is the simplest way to fix this?</p>",
        "id": 268979750,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642887120
    },
    {
        "content": "<p>Does metamath zero use checks on free for and substitution for definitions?</p>",
        "id": 268982623,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642891015
    },
    {
        "content": "<p>Updated code, but not sure how to fix definitions, and if the substitution can be removed with definitions.<br>\n<a href=\"/user_uploads/3121/utnEIuEliZzO8xgRUiHyTm9n/Frege.hs\">Frege.hs</a></p>",
        "id": 268990172,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642902061
    },
    {
        "content": "<p>Is the addition of definitions to this what is known as an extended Frege system?</p>",
        "id": 268991872,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642904664
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268973308\">said</a>:</p>\n<blockquote>\n<p>Would the metamath approach here be to make <code>Theorem</code> a <code>(Context, Formula)</code> pair and have <code>mp</code> check that the contexts are the same?</p>\n</blockquote>\n<p>No, in the metamath approach the <code>Theorem</code> is not tupled with a context but instead the context is available in a global data structure, and only grows monotonically (so <code>Theorem</code>s can be created in past versions of the context but not \"alternate history\" versions). In Haskell the global state part is problematic, but something like <code>ST</code> should be sufficient to localize all the types to a given session, within which the context is stored in a <code>STRef</code></p>",
        "id": 268993062,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642906714
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268982623\">said</a>:</p>\n<blockquote>\n<p>Does metamath zero use checks on free for and substitution for definitions?</p>\n</blockquote>\n<p>Not sure exactly what you mean. There are constraints on what you can unfold, for example you don't want a bound variable in the definition to capture a free variable in one of the parameters.</p>",
        "id": 268993337,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642907116
    },
    {
        "content": "<p>I mean, I thought the axiom system of metamath was chosen in part to avoid the complexities of substitution, but it seems like they are reintroduced in adding definitions, for example, as you said, in the unfolding.</p>",
        "id": 268993686,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642907672
    },
    {
        "content": "<p>I think what I meant in the previous comment was, could you simulate the global data structure by passing it in and out of each axiom scheme function.</p>",
        "id": 268993753,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642907790
    },
    {
        "content": "<p>As an aside, is what I am trying to do here a waste of time :( I mean, if it could have been done, it would have?</p>",
        "id": 268993827,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642907922
    },
    {
        "content": "<p>Or there are good reasons not to that I am unaware of yet?</p>",
        "id": 268993839,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642907950
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 268998560,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642915453
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 268999589,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642917240
    },
    {
        "content": "<blockquote>\n<p>As an aside, is what I am trying to do here a waste of time :( I mean, if it could have been done, it would have?</p>\n</blockquote>\n<p>The exact combination of things you're doing probably hasn't. But each part of it has, so it's a great try-out-what-happens project, and uncovers some pitfalls / benefits along this path, I think.</p>",
        "id": 269007500,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642929532
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 269007513,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642929568
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268993686\">said</a>:</p>\n<blockquote>\n<p>I mean, I thought the axiom system of metamath was chosen in part to avoid the complexities of substitution, but it seems like they are reintroduced in adding definitions, for example, as you said, in the unfolding.</p>\n</blockquote>\n<p>Metamath has substitution as a built in primitive: it's basically <em>the</em> rule that everything is built from. Where it differs from other systems is that metamath substitution is always direct but sometimes disallowed, whereas substitution in e.g. HOL is always allowed but sometimes requires bound variable renaming.</p>\n<p>It is true, however, that adding definitions to metamath entails some additional knowledge about what it means to be a bound variable that is not present in traditional metamath. This is a fact I discovered when designing MM0. Metamath is able to sidestep the problem because it does not attempt to check conservativity of definitions - every definition is an axiom and you have to be careful not to accidentally introduce a free variable. The first version of these rules came about in the definition checker that is now part of <a href=\"http://set.mm\">set.mm</a> CI, but when we turned it on we did actually discover a few typo'd definitions that could be used to prove a contradiction, so I've come to believe that it's an important part of the verifier even though it is not officially part of the metamath spec.</p>",
        "id": 269023200,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642951183
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268993753\">said</a>:</p>\n<blockquote>\n<p>I think what I meant in the previous comment was, could you simulate the global data structure by passing it in and out of each axiom scheme function.</p>\n</blockquote>\n<p>Yes, if you used a state monad you can simulate global state, but a public state monad is not good enough, because you can still snapshot an earlier state and roll back, meaning that you can capture some theorems made in an alternate timeline and use them to mess things up in a different one. <code>ST</code> avoids this problem because it actually uses mutable state, not just a simulation - there is no way to snapshot an old version of the state and roll back - and also types are guarded by the type variable denoting the arena for the state, which can be used to \"brand\" all the types like <code>Term</code> and <code>Formula</code> so that you can't start two separate sessions and share theorems created in one session with the other.</p>",
        "id": 269023503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642951487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268993827\">said</a>:</p>\n<blockquote>\n<p>As an aside, is what I am trying to do here a waste of time :( I mean, if it could have been done, it would have?</p>\n</blockquote>\n<p>It's certainly not a waste of time if you are learning. If you want to actually turn this into a product there are a bunch of other things to attend to, but you should know what your goals are and who your audience is. For example, I've been talking about protecting against API violations in the LCF style, but you should consider what your \"threat model\" is. Metamath is not designed as an LCF style system, which is to say that if you are working in the same codebase as the verifier then you can arbitrarily muck things up. Same thing for lean - you can \"easily\" bypass the kernel with some C++ code. These systems instead ensure security by parsing their own language, which is more limited / sandboxed in the things you can do.</p>\n<p>But if you wanted to parse your own language, then clearly there is a bunch of missing stuff, like a parser and a grammar for that language, how you want to specify proofs, definitions, and so on. In the end, the \"kernel\" for such a prover might not be as well isolated as yours, because that can sometimes come with a performance penalty. Naturally if the kernel gets too big then people will start to question why it should be trustworthy, so you have to attend to that too. You have to somehow write the code such that it is easy to convince others that it is correct, and there are a variety of strategies for doing this.</p>\n<p>Ultimately, the kernel is one of the smaller parts of making a useful verification system. It's probably the most logically interesting part, but there is a whole lot more beyond it.</p>",
        "id": 269024118,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642952256
    },
    {
        "content": "<p>Thank you! I think I've got some studying to do on <code>ST</code>.</p>",
        "id": 269028195,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642957833
    },
    {
        "content": "<p>I'm having trouble finding examples of this use case. I found examples where everything is done inside of <code>runST</code>, but not where <code>runST</code> calls other functions that take and return a <code>STRef</code> (if I am right and that is what I need to do?). Is the general idea that the type of <code>Term</code>, <code>Formula</code>, and <code>Theorem</code>become dependent on a \"thread id\", and the axiom,rule functions take the \"thread id\" as a parameter and require that the <code>Term</code>, <code>Formula</code> and <code>Theorem</code>s passed to them have that same \"thread id\"?</p>",
        "id": 269035865,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642967559
    },
    {
        "content": "<p>And the <code>STRef</code> presumably created in the <code>runST</code> function somehow becomes contained to the \"thread id\" associated with that call of <code>runST</code>?</p>",
        "id": 269036140,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642967782
    },
    {
        "content": "<p>If that is the general idea, how do you add the \"thread id\" (the variable <code>s</code>) to the datatypes and functions to do this? Is it with the <code>forall</code> somehow?</p>",
        "id": 269036680,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642968438
    },
    {
        "content": "<p>Yes, that's right</p>",
        "id": 269036910,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642968736
    },
    {
        "content": "<p>I think you can just declare <code>Term</code> as having a type parameter <code>s</code></p>",
        "id": 269036912,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642968750
    },
    {
        "content": "<p>even though it doesn't really use it in any interesting way</p>",
        "id": 269036921,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642968780
    },
    {
        "content": "<p>There is one call to <code>runST</code> around the entire scope of the program. This represents one \"proving session\", within which you can add but not remove definitions. The only way to remove definitions is to exit the <code>runST</code> scope and start anew. You can also have two (unrelated) sessions going on in parallel, and the thread id <code>s</code> is being used to keep the two sessions separate</p>",
        "id": 269037019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642968915
    },
    {
        "content": "<p>You don't take and return an <code>STRef</code>, there is only one <code>STRef s (Context s)</code> in use which is passed to any functions that need to read or modify the context</p>",
        "id": 269037080,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642969001
    },
    {
        "content": "<p>IIRC the syntax for type variables in <code>data</code> is just <code>data Term s = Var String | Func String [Term s]</code>, you don't need <code>forall</code></p>",
        "id": 269037172,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642969138
    },
    {
        "content": "<p>I think I see. How do the functions, for example the ones that don't need to read or modify the context (all but the add definition and unfold definition functions) get associated with <code>s</code> and check that the terms, formulas, theorems passed to them match the same <code>s</code>? Is <code>s</code> passed to them from <code>runST</code>?</p>",
        "id": 269037337,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642969377
    },
    {
        "content": "<p>That happens automatically from the type signature</p>",
        "id": 269037349,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642969415
    },
    {
        "content": "<p>For example <code>mp</code> will have the type <code>mp :: Theorem s -&gt; Theorem s -&gt; Theorem s</code> which means that you can't use different <code>s</code> for the two inputs</p>",
        "id": 269037398,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642969444
    },
    {
        "content": "<p>note that we're talking about <em>different type variables</em> here, not different inhabitants of one type <code>s</code></p>",
        "id": 269037415,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642969472
    },
    {
        "content": "<p><code>s</code> itself is only a marker type, it has no content</p>",
        "id": 269037421,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642969488
    },
    {
        "content": "<p>but if you have two theorems from two sessions they will have types <code>Theorem s</code> and <code>Theorem  t</code> respectively where <code>s</code> and <code>t</code> are distinct type variables, so <code>mp</code> will not typecheck</p>",
        "id": 269037459,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642969550
    },
    {
        "content": "<p>So, for example, how do you create an instance of <code>Term s</code> or <code>Formula s</code> in <code>runST</code>?</p>",
        "id": 269037617,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642969740
    },
    {
        "content": "<p>You don't need an <code>s</code> to pass to the data constructor of <code>Term s</code> or <code>Formula s</code>?</p>",
        "id": 269037753,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642969925
    },
    {
        "content": "<p>Or do you just leave the <code>s</code> out of the constructor definitions, expect for those that take a <code>Formula</code> or <code>Term</code>?</p>",
        "id": 269037790,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642970027
    },
    {
        "content": "<p>Sorry, I guess I should have seen that in your example.</p>",
        "id": 269037863,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642970137
    },
    {
        "content": "<p>Thank you!!</p>",
        "id": 269037910,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642970170
    },
    {
        "content": "<p>The constructors <code>Var</code> and <code>Func</code> of <code>Term s</code> are private; using them you can construct whatever you like but the external API needs to use <code>mkFunc</code> instead, which will check that you only use functions in the context</p>",
        "id": 269038325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642970792
    },
    {
        "content": "<p>I'm a little uncertain how to implement the <code>mkFunc</code>. Here I want to read from a passed <code>STRef</code> but return a <code>Term s</code>. I can read from the <code>STRef</code> in a do block, but how do I then return a <code>Term s</code>? As a minimal example that expresses the same concept of what I think I need to do (maybe not?):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Control.Monad.ST</span>\n<span class=\"kn\">import</span> <span class=\"n\">Data.STRef</span>\n\n\n<span class=\"n\">data</span> <span class=\"n\">Term</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">Var</span> <span class=\"n\">String</span>\n            <span class=\"bp\">|</span> <span class=\"n\">Func</span> <span class=\"n\">String</span> <span class=\"o\">[</span><span class=\"n\">Term</span> <span class=\"n\">s</span><span class=\"o\">]</span>\n              <span class=\"n\">deriving</span> <span class=\"o\">(</span><span class=\"n\">Show</span><span class=\"o\">,</span> <span class=\"n\">Eq</span><span class=\"o\">)</span>\n\n\n<span class=\"n\">type</span> <span class=\"n\">Context</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">Int</span>\n\n<span class=\"n\">f</span> <span class=\"o\">::</span> <span class=\"n\">STRef</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">Context</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Term</span> <span class=\"n\">s</span>\n<span class=\"n\">f</span> <span class=\"n\">ref</span> <span class=\"bp\">=</span> <span class=\"k\">do</span>\n  <span class=\"n\">x</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">readSTRef</span> <span class=\"n\">ref</span>\n  <span class=\"c1\">-- how to return Var \"P\"?</span>\n</code></pre></div>",
        "id": 269044825,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642979406
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"nf\">f</span> <span class=\"ow\">::</span> <span class=\"kt\">STRef</span> <span class=\"n\">s</span> <span class=\"p\">(</span><span class=\"kt\">Context</span> <span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">ST</span> <span class=\"n\">s</span> <span class=\"p\">(</span><span class=\"kt\">Term</span> <span class=\"n\">s</span><span class=\"p\">)</span>\n</code></pre></div>",
        "id": 269045013,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642979675
    },
    {
        "content": "<p>Alternatively, <code>f</code> can have the type <code>Context s -&gt; Term s</code> and push the responsibility to read the context to the caller</p>",
        "id": 269045075,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642979767
    },
    {
        "content": "<p>Ahh. Thank you!</p>",
        "id": 269045078,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642979782
    },
    {
        "content": "<p>It's okay to let the user have access to objects of type <code>Context s</code>, because they can at worst hold on to old contexts (which are ancestors of the current one, so are still valid to use to construct terms). The only place where you have to be careful is the context extension function must use the latest context, not an old one, so it has to have a type like <code>STRef s (Context s) -&gt; FuncDef -&gt; ST s ()</code></p>",
        "id": 269045182,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642979957
    },
    {
        "content": "<p>in fact, you could also make a monad <code>ThmM s a = ReaderT (STRef s (Context s)) (ST s) a</code> and make the constructor private, so the user doesn't have to handle the <code>STRef</code> directly</p>",
        "id": 269045261,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642980088
    },
    {
        "content": "<p>Hmm. I'm going to have to do some more reading. Thank you!</p>",
        "id": 269045419,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642980269
    },
    {
        "content": "<p>Hello, recently I was also trying to make a \"toy\" theorem prover based on FOL + ZFC, also using Haskell (and maybe C++ in the future)... Just found this thread really helpful! I have a question though: are there some recommended ways to implement \"in/definite descriptions\"? I'm deciding between making them into inference rules (i.e. add defining axioms to context if conditions are met) and introducing some kind of \"iota &amp; epsilon operators\" instead...</p>",
        "id": 269048474,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1642984539
    },
    {
        "content": "<p>(In case anyone is interested: I used locally nameless, contexts and natural deduction from the very beginning (which makes <a href=\"https://github.com/bridgekat/apimu/blob/main/lcfstyle/FOLPlus.hs\">my verifier code</a> (also <a href=\"https://github.com/bridgekat/apimu/blob/main/lcfstyle/FOLPlusTest.hs\">this part</a>) much longer and probably slower than Patrick's, but also seems to have avoided some problems you were discussing here), and I'm now (coincidentally) trying to implement definitions. I tried to think about the design in the previous months, and came up with some (still premature) ideas including \"local definitions\" that \"interact with scope changes\" like in <a href=\"https://github.com/bridgekat/apimu/blob/main/notes/design.md#natural-deduction-rules\">this informal proof.</a> The point is, in principle they can be lifted to the outermost scope, and the rules described <a href=\"https://en.m.wikipedia.org/wiki/Extension_by_definitions\">here</a> will become applicable (although still need to be modified to include the case of \"partial\" functions/predicates, i.e. definitions inside <code>assume</code> sections)...)</p>",
        "id": 269048522,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1642984563
    },
    {
        "content": "<p>Does <code>def f</code> open a new scope? As in you can later close the scope and any theorems about <code>f</code> become generalized <code>forall f</code> instead of being about a specific definition</p>",
        "id": 269049577,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642986017
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 269050587,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1642987312
    },
    {
        "content": "<p>No, as I wanted to make the definition of <code>f</code> generalizable (it can escape from <code>any</code> scopes); <code>forall f</code> (I use <code>forallfunc f/n</code> to indicate the type of <code>f</code>) is introduced using <code>anyfunc f/n</code> instead</p>",
        "id": 269050688,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1642987443
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269045182\">said</a>:</p>\n<blockquote>\n<p>It's okay to let the user have access to objects of type <code>Context s</code>, because they can at worst hold on to old contexts (which are ancestors of the current one, so are still valid to use to construct terms). The only place where you have to be careful is the context extension function must use the latest context, not an old one, so it has to have a type like <code>STRef s (Context s) -&gt; FuncDef -&gt; ST s ()</code></p>\n</blockquote>\n<p>Should <code>FuncDef</code> take an <code>s</code>? As in <code>STRef s (Context s) -&gt; FuncDef s -&gt; ST s ()</code>?</p>",
        "id": 269051892,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642989017
    },
    {
        "content": "<p>Since it has a <code>Term s</code> in the definition?</p>",
        "id": 269051910,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642989061
    },
    {
        "content": "<p>yes</p>",
        "id": 269051914,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642989064
    },
    {
        "content": "<p>Ok. Thank you.</p>",
        "id": 269051922,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642989084
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"450398\">@Zhanrong Qiao</span> Regarding your question about indefinite description, wouldn't an iota/epsilon operator take you out of the FOL fragment? I see you have some 1.5 order variables going on so I might be wrong about this</p>",
        "id": 269052173,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642989447
    },
    {
        "content": "<p>I think it would not be so bad to have a skolem operation in your language: something like <code>any x { idef f :: p(x, f) }</code> will introduce <code>f(x)</code> such that <code>p(x, f(x))</code>. That doesn't leave the first order world, and it doesn't have the drawbacks of long lived existential assumptions you get with a simple axiom of the form <code>forall x. exists y. p(x,y) -&gt; exists f. forall x. p(x, f(x))</code> (not to mention the second order issue here as well)</p>",
        "id": 269052526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642989832
    },
    {
        "content": "<p>I can't pull a <code>Theorem s</code> out of <code>runST</code> right? If I want to do something with it, like show it, do I need to do that in <code>runST</code>?</p>",
        "id": 269055748,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642993954
    },
    {
        "content": "<p>yes</p>",
        "id": 269056045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642994334
    },
    {
        "content": "<p>I see. So the whole proof assistant basically runs inside of <code>runST.</code> Is that going to be an issue, do you think?</p>",
        "id": 269056170,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642994492
    },
    {
        "content": "<p>It's probably kind of annoying in ghci, but it shouldn't be a problem for regular haskell programming</p>",
        "id": 269056228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642994559
    },
    {
        "content": "<p>Ok. Thank you!</p>",
        "id": 269056252,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642994588
    },
    {
        "content": "<p>I can't do <code>IO</code> from inside <code>ST</code> though right? Do I have a function internal to <code>runST</code> that converts <code>Theorem s</code> to a <code>String</code> and somehow return the result of that out of <code>runST</code>?</p>",
        "id": 269056955,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642995607
    },
    {
        "content": "<p>Yay!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">ex_1</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">runST</span> <span class=\"bp\">$</span> <span class=\"k\">do</span>\n  <span class=\"n\">ref</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">newSTRef</span> <span class=\"o\">(</span><span class=\"n\">Data.Map.empty</span><span class=\"o\">,</span> <span class=\"n\">Data.Map.empty</span><span class=\"o\">)</span>\n  <span class=\"n\">addPredDefST</span> <span class=\"n\">ref</span> <span class=\"o\">(</span><span class=\"n\">PredDef</span> <span class=\"n\">p</span> <span class=\"mi\">0</span> <span class=\"n\">Nothing</span><span class=\"o\">)</span>\n  <span class=\"n\">c</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">readSTRef</span> <span class=\"n\">ref</span>\n  <span class=\"k\">let</span> <span class=\"n\">p'</span> <span class=\"bp\">=</span> <span class=\"n\">mkPred</span> <span class=\"n\">c</span> <span class=\"n\">p</span> <span class=\"o\">[]</span>\n  <span class=\"k\">let</span> <span class=\"n\">s1</span> <span class=\"bp\">=</span> <span class=\"n\">prop_2</span> <span class=\"n\">p'</span> <span class=\"o\">(</span><span class=\"n\">p'</span> <span class=\"bp\">`</span><span class=\"n\">Imp</span><span class=\"bp\">`</span> <span class=\"n\">p'</span><span class=\"o\">)</span> <span class=\"n\">p'</span>\n  <span class=\"k\">let</span> <span class=\"n\">s2</span> <span class=\"bp\">=</span> <span class=\"n\">prop_1</span> <span class=\"n\">p'</span> <span class=\"o\">(</span><span class=\"n\">p'</span> <span class=\"bp\">`</span><span class=\"n\">Imp</span><span class=\"bp\">`</span> <span class=\"n\">p'</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">s3</span> <span class=\"bp\">=</span> <span class=\"n\">mp</span> <span class=\"n\">s2</span> <span class=\"n\">s1</span>\n  <span class=\"k\">let</span> <span class=\"n\">s4</span> <span class=\"bp\">=</span> <span class=\"n\">prop_1</span> <span class=\"n\">p'</span> <span class=\"n\">p'</span>\n  <span class=\"k\">let</span> <span class=\"n\">concl</span> <span class=\"bp\">=</span> <span class=\"n\">mp</span> <span class=\"n\">s4</span> <span class=\"n\">s3</span>\n  <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">concl</span><span class=\"o\">)</span>\n\n<span class=\"n\">main</span> <span class=\"o\">::</span> <span class=\"n\">IO</span> <span class=\"o\">()</span>\n<span class=\"n\">main</span> <span class=\"bp\">=</span> <span class=\"n\">putStrLn</span> <span class=\"o\">(</span><span class=\"n\">ex_1</span> <span class=\"s2\">\"P\"</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 269057196,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642996003
    },
    {
        "content": "<p><code>Theorem (Imp (Pred \"P\" []) (Pred \"P\" []))</code></p>",
        "id": 269057203,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642996041
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/DF0Sq3yTKwlIYl0icvstO7wP/Frege_ST.hs\">Frege_ST.hs</a></p>",
        "id": 269057268,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642996115
    },
    {
        "content": "<p>Very cool! (If I did it right) :)</p>",
        "id": 269057282,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642996185
    },
    {
        "content": "<p>Thank you!!</p>",
        "id": 269057473,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642996443
    },
    {
        "content": "<p>So, um, I'm almost afraid to ask :), but is that right? Am I forgetting anything obvious that would make it unsound or incomplete or be an issue later?</p>",
        "id": 269058270,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1642997472
    },
    {
        "content": "<p>You should put it in a module and expose only the things that are supposed to be public, and ensure that the API is usable enough to prove theorems but not so permissive as to prove false</p>",
        "id": 269061574,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643001963
    },
    {
        "content": "<p>That is, right now it is trivially unsound if we think of <code>ex_1</code> as the user code because you can just write <code>Theorem Bottom</code></p>",
        "id": 269061609,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643002026
    },
    {
        "content": "<p>That was going to be my next step, that is putting it into a module and hiding what should be internal. I'm not sure how to go about the latter, that is ensure that the API is usable enough to prove theorems but not so permissive as to prove false, without trying to formally prove it, which is probably beyond what I am up for at this point, and may be impossible due to Godel?</p>",
        "id": 269062197,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643002825
    },
    {
        "content": "<p>It's certainly very difficult to check that a kernel can't prove false with anything approaching absolute certainty. Even real world theorem provers have to deal with that every once in a while</p>",
        "id": 269062320,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643003018
    },
    {
        "content": "<p>I'm soon going to run out of obvious flaws to poke at, so there's that</p>",
        "id": 269062363,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643003050
    },
    {
        "content": "<p>:)</p>",
        "id": 269062372,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643003094
    },
    {
        "content": "<p>Godel's theorem only comes up if you want to prove the soundness of your kernel using the kernel itself (or something axiomatically weaker than it). You could model this kernel in lean without too much trouble</p>",
        "id": 269062404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643003139
    },
    {
        "content": "<p>Soon? Does that mean you have more in mind :)<br>\nHow hard would the proofs be once it was in lean? I can't imagine the <code>ST</code>  monad would be easy?</p>",
        "id": 269062486,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643003233
    },
    {
        "content": "<p>true, you would have to model haskell in order to get all that right, and once you did you would probably notice that the theorem is false because of e.g. <code>unsafeCoerce</code></p>",
        "id": 269062559,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643003311
    },
    {
        "content": "<p>So it is unsound?</p>",
        "id": 269062648,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643003424
    },
    {
        "content": "<p>All was for naught?</p>",
        "id": 269062663,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643003449
    },
    {
        "content": "<p>It's why I'm generally dubious of the LCF style - every real world programming language is unsound for stupid reasons</p>",
        "id": 269062671,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643003462
    },
    {
        "content": "<p>But if you want to prove it sound anyway you can just blithely ignore these issues and assume sensible use of the API</p>",
        "id": 269062692,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643003513
    },
    {
        "content": "<p>I'm not sure what the alternative to LCF is? Isn't Lean and Coq LCF?</p>",
        "id": 269062754,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643003567
    },
    {
        "content": "<p>No, I mean LCF style in the sense of the HOL / ML-based systems: you have an abstract data type <code>Theorem</code> which may not even carry a proof object, and you use a privacy barrier to ensure that bad <code>Theorem</code> objects are not constructible</p>",
        "id": 269062829,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643003650
    },
    {
        "content": "<p>the \"small trusted kernel\" becomes everything behind the privacy barrier</p>",
        "id": 269062836,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643003667
    },
    {
        "content": "<p>Lean and Coq are not LCF style in this sense</p>",
        "id": 269062849,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643003681
    },
    {
        "content": "<p>Lean and Coq explicitly stores the proof objects, so you get things like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>m</mi><mi>p</mi><mi>S</mi><mo stretchy=\"false\">(</mo><mi>K</mi><mi>S</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(mp S (K S))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">pS</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">))</span></span></span></span></p>",
        "id": 269062855,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1643003703
    },
    {
        "content": "<p>I'm sorry, I'm not sure what that means.</p>",
        "id": 269062924,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643003789
    },
    {
        "content": "<p>That is, stores the proof objects.</p>",
        "id": 269062941,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643003824
    },
    {
        "content": "<p>the LCF style implies that the user will be writing code in the implementation language, hence you have a fundamental tension: it should be a real world language so that the implementation works, but real world languages don't have airtight privacy guarantees because that's not what they were intended for</p>",
        "id": 269062956,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643003873
    },
    {
        "content": "<p>In Lean, the proof of <code>A -&gt; B -&gt; A /\\ B</code> can be printed out (try it!) to something like <code>λ x y, &lt;x, y&gt;</code> (sorry, unicode only partly works on my device).</p>",
        "id": 269063035,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1643003973
    },
    {
        "content": "<p>But in your program (which is approximately LCF-style), you can't print \"the proof\". Such a thing doesn't even exist. You only have a <code>Theorem</code> which contains only the information of the theorem statement.</p>",
        "id": 269063153,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1643004033
    },
    {
        "content": "<p>Is the difference that in my program the proof is that a <code>Theorem</code> can be constructed, and in Lean the proof is that a given theorem passes a verifier test?</p>",
        "id": 269063304,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643004241
    },
    {
        "content": "<p>it's a lot easier to control the grammar of your verifier language than it is to control what can be constructed, especially if you allow the user to be actively malicious and use the implementation language</p>",
        "id": 269063470,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643004414
    },
    {
        "content": "<p>Is it possible to do that for what I was attempting? That is a hilbert system for FOL with equality and ZFC in Haskell?</p>",
        "id": 269063777,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643004788
    },
    {
        "content": "<p>I'm not sure what it would look like. Would it take a proof as a series of user given justifications for each step, and check that those justifications all hold?</p>",
        "id": 269063957,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643005000
    },
    {
        "content": "<p>For example, <code>P -&gt; (P -&gt; P)</code> holds from an instantiation of <code>prop_1</code> with <code>p</code> and <code>p</code>.</p>",
        "id": 269064051,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643005109
    },
    {
        "content": "<p>And the verifier instantiates <code>prop_1</code> with <code>p</code> and <code>p</code> and checks that it matches?</p>",
        "id": 269064068,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643005149
    },
    {
        "content": "<p>Or something along the lines of what I was doing for natural deduction earlier?</p>",
        "id": 269065039,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643006343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269063957\">said</a>:</p>\n<blockquote>\n<p>I'm not sure what it would look like. Would it take a proof as a series of user given justifications for each step, and check that those justifications all hold?</p>\n</blockquote>\n<p>Yes, I think what Mario was saying is that you could make a data structure that stores proof steps, then your program could just take a data structure in some format and check if it's a valid proof, which does not rely on the type safety of the implementation language (also, proofs can then be constructed using another program written in arbitrary programming language for example). This is optional</p>",
        "id": 269087541,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643021533
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269052173\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"450398\">Zhanrong Qiao</span> Regarding your question about indefinite description, wouldn't an iota/epsilon operator take you out of the FOL fragment? I see you have some 1.5 order variables going on so I might be wrong about this</p>\n</blockquote>\n<p>I thought epsilon operators and Skolem functions are the \"same thing\" (and the difference is just which one is more convenient)... In principle I could replace every occurrence of an epsilon operator by a definition of a Skolem function...?</p>",
        "id": 269088008,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643021747
    },
    {
        "content": "<p>But yes I think the <code>def</code>/<code>idef</code> approach makes it easier to interface with first-order automated proving methods (they don't need to create definitions; no replacing are needed)</p>",
        "id": 269090690,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643023085
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"450398\">@Zhanrong Qiao</span> The difference in this case is that the <code>idef</code> is essentially a monomorphized epsilon operator: you stamp out a new definition every time the rule is invoked, rather than having a single higher order thing called \"epsilon\" to which you provide a lambda to get a choice function for a particular predicate</p>",
        "id": 269099675,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643028428
    },
    {
        "content": "<p>Yes, I guess this is similar to thinking the invocations of the Axiom of Separation as instantiations of an axiom schema instead of applications of a second-order axiom... The syntactic rules are similar or the same but there can be different interpretations</p>",
        "id": 269108296,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643032475
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"450398\">Zhanrong Qiao</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269087541\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269063957\">said</a>:</p>\n<blockquote>\n<p>I'm not sure what it would look like. Would it take a proof as a series of user given justifications for each step, and check that those justifications all hold?</p>\n</blockquote>\n<p>Yes, I think what Mario was saying is that you could make a data structure that stores proof steps, then your program could just take a data structure in some format and check if it's a valid proof, which does not rely on the type safety of the implementation language (also, proofs can then be constructed using another program written in arbitrary programming language for example). This is optional</p>\n</blockquote>\n<p>Like this as a simple example?</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"cm\">{-</span>\n<span class=\"cm\">Func \"c\" [] : A constant named \"c\"</span>\n<span class=\"cm\">Func \"f\" [v] : A function named \"f\" of one variable v</span>\n<span class=\"cm\">-}</span><span class=\"w\"></span>\n<span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">Term</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Var</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"></span>\n<span class=\"w\">          </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Func</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kr\">deriving</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Eq</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Pred \"P\" [] : A propositional variable named \"P\"</span>\n<span class=\"cm\">Pred \"Eq\" [s, t] : s = t</span>\n<span class=\"cm\">-}</span><span class=\"w\"></span>\n<span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Bottom</span><span class=\"w\"> </span><span class=\"c1\">-- False</span><span class=\"w\"></span>\n<span class=\"w\">             </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Top</span><span class=\"w\"> </span><span class=\"c1\">-- True</span><span class=\"w\"></span>\n<span class=\"w\">             </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Pred</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">             </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Not</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"w\">             </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">And</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"w\">             </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Or</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"w\">             </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Imp</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"w\">             </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Iff</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"w\">             </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Forall</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"w\">             </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Exists</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"w\">               </span><span class=\"kr\">deriving</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Eq</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n\n<span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">Justification</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">MP</span><span class=\"w\"> </span><span class=\"kt\">Step</span><span class=\"w\"> </span><span class=\"kt\">Step</span><span class=\"w\"></span>\n<span class=\"w\">                   </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Prop_1</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"w\">                   </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Prop_2</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"w\">                   </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Prop_3</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"w\">                     </span><span class=\"kr\">deriving</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Eq</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n<span class=\"kr\">type</span><span class=\"w\"> </span><span class=\"kt\">Assertion</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"kr\">type</span><span class=\"w\"> </span><span class=\"kt\">Step</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Assertion</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Justification</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n\n<span class=\"nf\">checkStep</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">Step</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Bool</span><span class=\"w\"></span>\n\n<span class=\"c1\">-- Propositional calculus</span><span class=\"w\"></span>\n\n<span class=\"c1\">-- |- p &amp; |- (p -&gt; q) =&gt; |- q</span><span class=\"w\"></span>\n<span class=\"nf\">checkStep</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">assertion</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">MP</span><span class=\"w\"> </span><span class=\"n\">step_1</span><span class=\"o\">@</span><span class=\"p\">(</span><span class=\"n\">minor</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">step_2</span><span class=\"o\">@</span><span class=\"p\">(</span><span class=\"n\">major</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"p\">)))</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">case</span><span class=\"w\"> </span><span class=\"n\">major</span><span class=\"w\"> </span><span class=\"kr\">of</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"kt\">Imp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">minor</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"></span>\n<span class=\"w\">                 </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">assertion</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"></span>\n<span class=\"w\">                 </span><span class=\"n\">checkStep</span><span class=\"w\"> </span><span class=\"n\">step_1</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"></span>\n<span class=\"w\">                 </span><span class=\"n\">checkStep</span><span class=\"w\"> </span><span class=\"n\">step_2</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"ne\">error</span><span class=\"w\"> </span><span class=\"s\">\"mp\"</span><span class=\"w\"></span>\n\n<span class=\"c1\">-- |- (p -&gt; (q -&gt; p))</span><span class=\"w\"></span>\n<span class=\"nf\">checkStep</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">assertion</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Prop_1</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">assertion</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">))</span><span class=\"w\"></span>\n\n<span class=\"c1\">-- |- ((p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r)))</span><span class=\"w\"></span>\n<span class=\"nf\">checkStep</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">assertion</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Prop_2</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">assertion</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"p\">)))</span><span class=\"w\"></span>\n\n<span class=\"c1\">-- |- (((p -&gt; false) -&gt; false) -&gt; p)</span><span class=\"w\"></span>\n<span class=\"nf\">checkStep</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">assertion</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Prop_3</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">assertion</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"p\">(((</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"kt\">Bottom</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"kt\">Bottom</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n\n<span class=\"c1\">-- Example</span><span class=\"w\"></span>\n\n<span class=\"c1\">-- |- p -&gt; p</span><span class=\"w\"></span>\n\n<span class=\"nf\">ex_1</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)),</span><span class=\"w\"> </span><span class=\"kt\">Prop_2</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kr\">in</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"kt\">Prop_1</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"kr\">in</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"n\">s3</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"kt\">MP</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kr\">in</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"n\">s4</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"kt\">Prop_1</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kr\">in</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"n\">s5</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">MP</span><span class=\"w\"> </span><span class=\"n\">s4</span><span class=\"w\"> </span><span class=\"n\">s3</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kr\">in</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">checkStep</span><span class=\"w\"> </span><span class=\"n\">s5</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 269216628,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643094274
    },
    {
        "content": "<p>That's right.</p>",
        "id": 269216988,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1643094689
    },
    {
        "content": "<p>Then I could also thread a separately verified  immutable definition context through <code>checkStep</code> and add <code>UnfoldFunc</code> and <code>UnfoldPred</code> cases to the <code>checkStep</code> function?</p>",
        "id": 269218660,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643096144
    },
    {
        "content": "<p>That is, immutable with regards to <code>checkStep</code>.</p>",
        "id": 269218735,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643096187
    },
    {
        "content": "<p>As in, no case in <code>checkStep</code> changes the definition context passed to it.</p>",
        "id": 269218758,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643096230
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269218660\">said</a>:</p>\n<blockquote>\n<p>Then I could also thread a separately verified  immutable definition context through <code>checkStep</code> and add <code>UnfoldFunc</code> and <code>UnfoldPred</code> cases to the <code>checkStep</code> function?</p>\n</blockquote>\n<p>Yes, you probably need to consider \"assert <code>x</code> under definition context <code>d</code>\" as a whole in <code>checkStep</code>... Then you probably need a \"weakening\" rule (adding definitions to context does not change the validity of the assertion, as long as the names used by the assertion don't get redefined etc)...</p>",
        "id": 269253402,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643115913
    },
    {
        "content": "<p>Or you could disallow naming clashes when forming definition contexts, in this way you don't need to check for redefinitions in the weakening rule (I think I got weakening wrong in my implementations, I did not check for naming clash; will fix them later)</p>",
        "id": 269254085,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643116226
    },
    {
        "content": "<p>But if you have a global context that 1. only allows adding more definitions but not removing definitions 2. disallows naming clash, then you no longer need to pass contexts into <code>checkStep</code> and weakening will be automatic</p>",
        "id": 269254381,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643116374
    },
    {
        "content": "<p>Should I allow definitions to abstract over functions/predicates (like the <code>subset</code> function I imagined here)? This seems to be not even a part of <a href=\"https://en.wikipedia.org/wiki/Second-order_logic#Syntax_and_fragments\">second-order logic</a>...</p>",
        "id": 269263894,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643120849
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/WWiDNuO03SaDOzCg8eMvfxct/Untitled.png\">Untitled.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/WWiDNuO03SaDOzCg8eMvfxct/Untitled.png\" title=\"Untitled.png\"><img src=\"/user_uploads/3121/WWiDNuO03SaDOzCg8eMvfxct/Untitled.png\"></a></div>",
        "id": 269263904,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643120858
    },
    {
        "content": "<p>I tried and it feels like the verifier code will become much messier with this (probably I have to start from some type theory...)</p>",
        "id": 269265466,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643121530
    },
    {
        "content": "<p>Oh but I did not imagine any instances where we need more than one abstraction over (definable) functions/predicates in a formula. Probably I could still keep it simple...</p>",
        "id": 269337672,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643151320
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 269352774,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643161819
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 269358445,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643168270
    },
    {
        "content": "<p>Does this work for adding definitions?<br>\n<a href=\"/user_uploads/3121/rjefRFiy-C-m3J-5MeSP8L_i/Test.hs\">Test.hs</a></p>",
        "id": 269358939,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643168732
    },
    {
        "content": "<p>I don't need to check that each function and predicate used in the proof is in the definition context do I? They just can't be unfolded if they are not?</p>",
        "id": 269359719,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643169488
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"450398\">Zhanrong Qiao</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269254381\">said</a>:</p>\n<blockquote>\n<p>But if you have a global context that 1. only allows adding more definitions but not removing definitions 2. disallows naming clash, then you no longer need to pass contexts into <code>checkStep</code> and weakening will be automatic</p>\n</blockquote>\n<p>It seems that it would be easiest to not add definitions in the lines of the proof, and just require that they be given at the start. Then there is a single check that they are valid, and the context is only sent through the <code>checkProofInContext</code> function so that they can be unfolded as needed. Example code above.</p>",
        "id": 269361190,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643170825
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 269361934,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643171202
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 269362115,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643171312
    },
    {
        "content": "<p>Should I allow a proof step for alpha conversion? Or change to locally nameless? I suppose I should do one or the other or proofs will become unwieldy?</p>",
        "id": 269362553,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643171701
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269359719\">said</a>:</p>\n<blockquote>\n<p>For this non LCF version, I don't need to check that each function and predicate used in the proof is in the definition context do I? They just can't be unfolded if they are not?</p>\n</blockquote>\n<p>This is not okay in definitions, at least. Because you can do <code>def foo := bar</code> (where <code>bar</code> is an undeclared nullary constant symbol) and then <code>def bar := not foo</code> (a regular definition) and suddenly you can unfold both <code>foo</code> and <code>bar</code> and get a contradiction</p>",
        "id": 269363241,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643172542
    },
    {
        "content": "<p>It seems generally dubious to me to allow undefined references anywhere in a proof, but I think that under certain settings you can argue that if you use an undefined term constructor somewhere then it is effectively an opaque constant, and assuming it doesn't show up in the theorem statement you can generalize it and replace it with something more innocuous like the constant true function. (It does imply that your sorts are all nonempty, but in FOL this is usually the case anyway.)</p>",
        "id": 269363514,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643172827
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"450398\">Zhanrong Qiao</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269263894\">said</a>:</p>\n<blockquote>\n<p>Should I allow definitions to abstract over functions/predicates (like the <code>subset</code> function I imagined here)? This seems to be not even a part of <a href=\"https://en.wikipedia.org/wiki/Second-order_logic#Syntax_and_fragments\">second-order logic</a>...</p>\n</blockquote>\n<p>You might take some inspiration from metamath here. Metamath allows for the definition of functions that take second order variables, but no higher. If <code>Set</code> is the base sort (the collection of ZFC sets, for example), then first order variables (set variables) have type <code>Set</code> and second order variables (class and wff variables) have type <code>Set -&gt; ... -&gt; Class</code> or <code>Set -&gt; ... -&gt; Prop</code> (where we think of <code>Class</code> as <code>Class := Set -&gt; Prop</code>). It is then possible to make definitions that accept any number of class and wff variables and produce a class or wff, for example the class abstraction operator <code>(Set -&gt; Prop) -&gt; Class</code>. However, there are no variables in this \"third order\" level, only concrete term constructors. <code>subset : Class -&gt; Class -&gt; Prop</code> would be in this category.</p>",
        "id": 269364148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643173330
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 269364766,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643173987
    },
    {
        "content": "<p>Does this fix the issue with the undefined references? <a href=\"/user_uploads/3121/Zu1_2In88zKJWxtE4p-pEjE4/Test.hs\">Test.hs</a></p>",
        "id": 269523830,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643256826
    },
    {
        "content": "<p>It does, but now you have the issue that you have to recheck subformulas many times. The usual way to fix this is to add some explicit DAG-like structure to your proof terms, so that if a subproof or subformula appears in two places it only has to be validated once. This can be done by adding a <code>let</code>-like construct: a way to extend the local context with a record \"<code>Ref 0</code> means <code>P /\\ Q</code>\", and then you can use <code>Ref 0</code> to refer to this saved expression, and you know it is valid because it was checked when it was first entered into the context. The same thing applies to proofs, this is basically <code>have</code> statements. It is useful for both terms/formulas and proofs: for proofs, because proofs can be long and you don't want to duplicate them (and if there are duplicated subproofs in a duplicated proof it can blow up exponentially), and for terms/formulas because they have very high duplication within a proof, because all the core rules require some kind of subterm similarity (for example, <code>P</code> will necessarily be constructed at least twice, in both sides of a <code>MP</code> application proving <code>P, (P -&gt; Q) |- Q</code>).</p>",
        "id": 269530905,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643264927
    },
    {
        "content": "<p>Thank you. Does this mean for instance that instead of passing <code>Term</code>s, <code>Formula</code>s and <code>Proof</code>s to cases of <code>checkProofInContext</code>, you would pass <code>Either Term Ref</code>, <code>Either Formula Ref</code> and <code>Either Proof Ref</code> and also a local context mapping <code>Ref</code> to <code>Term</code>s, <code>Formula</code>s and <code>Proof</code>s? And you would change <code>Proof</code> to be one of <code>Assertion Justification</code>, <code>Let Ref (Either Term Formula)</code> or <code>Have Ref Proof</code>?</p>",
        "id": 269582118,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643294699
    },
    {
        "content": "<p>Actually, no, I'm not sure I have that right. At least not the part about changing the definition of <code>Proof</code>.</p>",
        "id": 269597839,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643300807
    },
    {
        "content": "<p>Maybe I should create a <code>Step</code> type that is either a <code>(Assertion, Justification)</code>, a <code>Let</code> or a <code>Have</code>? And replace the <code>checkProofInContext</code> function with a <code>CheckSteps</code> function that takes the definition context, reference context and a list of <code>Step</code>s?</p>",
        "id": 269600128,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643301746
    },
    {
        "content": "<p>I'm not sure. Suggestions welcomed :)</p>",
        "id": 269600993,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643302108
    },
    {
        "content": "<p>You want <code>Let</code> and <code>Have</code> to be part of the <code>Justification</code> grammar itself, and similarly you want <code>Ref</code> to appear inside a <code>Formula</code>. This complicates formula equality testing though; one way would be to ensure as part of wellformedness checking that formulas in the context never contain <code>Ref</code> and formulas in the <code>Justification</code> have all the <code>Ref</code>s substituted out before going in the context or being equality tested</p>",
        "id": 269602434,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643302677
    },
    {
        "content": "<p>basically the <code>Formula</code> expressions inside <code>Justification</code> are more like mini-programs for constructing a formula with guaranteed internal sharing</p>",
        "id": 269602638,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643302746
    },
    {
        "content": "<p>When you say context, are you referring to the definition context?</p>",
        "id": 269603445,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643303022
    },
    {
        "content": "<p>Also, what do you mean by guaranteed internal sharing?</p>",
        "id": 269603796,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643303157
    },
    {
        "content": "<p>Without de Brujin indexing, you recurse to check formulas without modifying it, so if you have a \"certificate\" that some formula is well-formed, then you also have \"certificates\" that all its subformulas are well-formed (though if you move into binders, there will be more free variables), so you could reuse the \"certificates\" (i.e. skip checking formulas that are subformulas of already-checked ones) i guess</p>",
        "id": 269614635,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643307244
    },
    {
        "content": "<p>To implement this we could store checked formulas in the context for reference</p>",
        "id": 269616084,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643307874
    },
    {
        "content": "<p>But if formulas in the context refer to each other, that could make equality testing slow, so Mario suggests to unfold their <code>Ref</code>s before putting formulas into the context?</p>",
        "id": 269616322,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643307970
    },
    {
        "content": "<p>(I'm not going to push for this level of optimization in checking for now... Will we encounter really long formulas in practice?)</p>",
        "id": 269617289,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643308391
    },
    {
        "content": "<p>I'm not sure if this is what he meant or not.</p>",
        "id": 269619321,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643309288
    },
    {
        "content": "<p>I'm not sure that he is saying that the issue is related to not using de Bruijn indexes.</p>",
        "id": 269648876,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643322024
    },
    {
        "content": "<p>No, de bruijn indices don't really affect this one way or another</p>",
        "id": 269651141,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643323187
    },
    {
        "content": "<p>When I say context I mean the local context associating <code>Ref -&gt; CheckedFormula</code></p>",
        "id": 269651231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643323222
    },
    {
        "content": "<p>What differentiates local and global contexts? The definition context is passed trough each instance of the proof checking function, so I guess that makes it global? What would be an example of a local context?</p>",
        "id": 269651572,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643323401
    },
    {
        "content": "<p>by internal sharing, I mean that something like <code>(x + x) + (x + x)</code> will be represented as a DAG with 3 nodes <code>x4 ⇉ x2 ⇉ x</code></p>",
        "id": 269651592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643323413
    },
    {
        "content": "<p>The map from refs to formulas can have whatever scope you like, but it generally makes most sense for it to be local to a given proof</p>",
        "id": 269651778,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643323498
    },
    {
        "content": "<p>if you make it too global then the ref numbers and the context gets big</p>",
        "id": 269651812,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643323515
    },
    {
        "content": "<p>since it basically becomes a log of all expressions ever constructed</p>",
        "id": 269651850,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643323542
    },
    {
        "content": "<p>Wait, so every formula gets added to the map from references to formulas, not just those specified by <code>let</code>?</p>",
        "id": 269651981,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643323598
    },
    {
        "content": "<p>no, just the <code>let</code> ones, but you can have them stick around / not be scoped if you like</p>",
        "id": 269652045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643323631
    },
    {
        "content": "<p>for example you could require that every proof starts with a list of all <code>let</code> formulas and then the actual justification</p>",
        "id": 269652126,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643323674
    },
    {
        "content": "<p>that way you don't have to worry about scope checking, things just monotonically add to the context and then you throw the whole thing away at the end of the proof</p>",
        "id": 269652248,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643323722
    },
    {
        "content": "<p>What would be the drawback to doing that?</p>",
        "id": 269652476,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643323849
    },
    {
        "content": "<p>I'm not sure what would delineate the start and end of a local context?</p>",
        "id": 269652547,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643323893
    },
    {
        "content": "<p>How would that differ from what I added for definitions?</p>",
        "id": 269652657,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643323951
    },
    {
        "content": "<p>no major drawback, I suppose the numbers could get large if it's a big monolithic proof but it probably won't be your biggest issue anyway</p>",
        "id": 269652664,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643323958
    },
    {
        "content": "<p>Does that mean you see a much bigger issue here?</p>",
        "id": 269652773,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643324016
    },
    {
        "content": "<p>It's kind of like definitions, but transparent to the other rules. If <code>r0 := p /\\ p</code> and <code>r1 := p</code>  then you want <code>r0</code> and <code>r1 /\\ p</code> to be considered syntactically equal for the purposes of rules like <code>MP</code></p>",
        "id": 269652894,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643324070
    },
    {
        "content": "<p>Note that equality testing is still slow with this scheme, because in haskell you can't observe the pointer sharing so even if you have <code>x4 ⇉ x2 ⇉ x</code> and <code>y4 ⇉ y2 ⇉ x</code> checking that <code>x4 = y4</code> requires checking <code>x2 = y2</code> twice</p>",
        "id": 269652998,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643324118
    },
    {
        "content": "<p>This is only a major issue if you have large terms, however. As Zhanrong said, long formulas are a niche issue</p>",
        "id": 269653133,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643324174
    },
    {
        "content": "<p>It's more important to support this for proofs, since duplication there is much more common</p>",
        "id": 269653179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643324203
    },
    {
        "content": "<p>In DTT you can get very large terms or terms with high duplication, however</p>",
        "id": 269653224,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643324230
    },
    {
        "content": "<p>DTT?</p>",
        "id": 269653373,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643324304
    },
    {
        "content": "<p>dependent type theory, i.e. lean or coq style</p>",
        "id": 269653401,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643324328
    },
    {
        "content": "<p>as opposed to FOL or HOL</p>",
        "id": 269653430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643324346
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269653179\">said</a>:</p>\n<blockquote>\n<p>It's more important to support this for proofs, since duplication there is much more common</p>\n</blockquote>\n<p>You mean <code>have</code> statements?</p>",
        "id": 269654071,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643324653
    },
    {
        "content": "<p>Sorry, I'm not certain what a local context would look like. What would start and end it?</p>",
        "id": 269654502,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643324856
    },
    {
        "content": "<p>Can you do the same thing with <code>have</code> statements and put them all at the beginning, like using earlier proofs?</p>",
        "id": 269654683,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643324937
    },
    {
        "content": "<p>It doesn't seem like what I currently have doesn't have any support for using prior proofs?</p>",
        "id": 269654770,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643324979
    },
    {
        "content": "<p>A local context for holding terms, formulas, and proofs might look like this:</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">ProofContext</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">ProofContext</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">terms</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">Seq</span><span class=\"w\"> </span><span class=\"kt\">Term</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">fmlas</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">Seq</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">proofs</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">Seq</span><span class=\"w\"> </span><span class=\"kt\">Assertion</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">Term</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"o\">...</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Ref</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"w\"></span>\n\n<span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"o\">...</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Ref</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"w\"></span>\n\n<span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">Justification</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"o\">...</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Ref</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">LetTerm</span><span class=\"w\"> </span><span class=\"kt\">Term</span><span class=\"w\"> </span><span class=\"kt\">Justification</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">LetFormula</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"kt\">Justification</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">LetProof</span><span class=\"w\"> </span><span class=\"kt\">Proof</span><span class=\"w\"> </span><span class=\"kt\">Justification</span><span class=\"w\"></span>\n\n<span class=\"nf\">checkProof</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">Context</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">ProofContext</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Proof</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Bool</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 269659010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643327202
    },
    {
        "content": "<p>Thank you. What makes <code>ProofContext</code> local?</p>",
        "id": 269660099,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643327792
    },
    {
        "content": "<p>Does local mean initialized to be empty at the start of each <code>checkProof</code>?</p>",
        "id": 269660376,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643327954
    },
    {
        "content": "<p>Is there a formal definition of what a proof is in Hilbert FOL? For instance something that reads like \"a proof is a sequence of steps each of which can refer to a previous step and must be of the form .....\"</p>",
        "id": 269666835,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643331917
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269660376\">said</a>:</p>\n<blockquote>\n<p>Does local mean initialized to be empty at the start of each <code>checkProof</code>?</p>\n</blockquote>\n<p>Yes</p>",
        "id": 269679452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643338043
    },
    {
        "content": "<p>compared to <code>Context</code> which contains all the definitions, and is generally monotonic across a whole proof development</p>",
        "id": 269679509,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643338087
    },
    {
        "content": "<p><code>checkProof</code> is not the entirety of a whole proof development?</p>",
        "id": 269681923,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643340595
    },
    {
        "content": "<p>I don't know why I didn't think of this before, but there is probably a formal description of this proof system (Hilbert FOL with equality and definitions) that I could be referencing and translating from?</p>",
        "id": 269682031,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643340704
    },
    {
        "content": "<p>For example, something that reads like \"A proof is a sequence of steps such that ...\"</p>",
        "id": 269682323,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643341015
    },
    {
        "content": "<p>If anyone has a pointer to one, that would be great. Thank you.</p>",
        "id": 269685105,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643343986
    },
    {
        "content": "<p>Logic books usually don't do that because that's too \"software-engineerish\". So you should probably look in proof assistant descriptions. I haven't really read about Mizar or HOL Light before, but I suppose you can find relevant design there.</p>\n<p>Probably nobody has ever done this exact thing, so there won't be complete references, and you have to gather information from different sources.</p>",
        "id": 269697689,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1643355981
    },
    {
        "content": "<p>One example that gets pretty close to covering the whole gamut of practical theory development is the <a href=\"http://www.gilith.com/opentheory/article.html\">OpenTheory spec</a></p>",
        "id": 269726785,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643372312
    },
    {
        "content": "<p>Thank you. I'm kind of surprised that no one has done this before, and I wonder if they had good reason and I am missing something. I was kind of expecting to find something in searches related to proof theory, but the closest I have come is the extended Frege system.</p>",
        "id": 269754716,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643384268
    },
    {
        "content": "<p>\"It does, but now you have the issue that you have to recheck subformulas many times. The usual way to fix this is to add some explicit DAG-like structure to your proof terms, so that if a subproof or subformula appears in two places it only has to be validated once.\"<br>\nFor example, when you say the usual way, what does that mean? What references or examples do you draw from?</p>",
        "id": 269760278,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643386530
    },
    {
        "content": "<p>Like, for example we have <code>let</code> binders in all major proof assistants...?</p>",
        "id": 269779744,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643394178
    },
    {
        "content": "<p>I guess I meant more along the lines of how they are implemented.</p>",
        "id": 269780094,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643394328
    },
    {
        "content": "<p>You mean, how are the representation and checking of <code>let</code> implemented?</p>",
        "id": 269783223,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643395520
    },
    {
        "content": "<p>Yes, I think so.</p>",
        "id": 269783289,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643395562
    },
    {
        "content": "<p>If I understood correctly, I guess in your example just extend <code>Formula</code> with a constructor <code>Ref Int</code>, and <code>Justification</code> with a constructor <code>Let [Formula] Justification</code> (the list can be seen as a mapping from <code>Int</code> to <code>Formula</code>, and probably using <code>Map Int Formula</code> is faster in Haskell? And the <code>Justification</code> argument is the scope of the Let) with the convention that there are no nested <code>Let</code>s.</p>",
        "id": 269784563,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643396115
    },
    {
        "content": "<p>I guess that more commonly, a local context is kept when checking proofs, and upon encountering a <code>Let String Formula Proof</code>, check the <code>Formula</code>, temporarily push the entry <code>(String, Formula)</code> onto the top of the local context and check the <code>Proof</code> in the extended context (in this way there can be nested <code>Let</code>s)</p>",
        "id": 269784921,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643396264
    },
    {
        "content": "<p>And when encountering <code>Ref Int</code> (or <code>Ref String</code> or <code>Ref</code> + whatever index type) just read the corresponding entry from the local context</p>",
        "id": 269785515,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643396467
    },
    {
        "content": "<p>So a global context is common to all proofs? I guess I'm having trouble understanding what would constitute separate proofs, because in order to use one proof in another you have to check the \"external\" proof when you encounter a reference to it in another proof?</p>",
        "id": 269786219,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643396732
    },
    {
        "content": "<p>That is, I don't see a way in the current system to have separate <code>Theorem</code> statements like in Lean.</p>",
        "id": 269786384,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643396783
    },
    {
        "content": "<p>All of which fall under a global context.</p>",
        "id": 269786503,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643396831
    },
    {
        "content": "<p>Lean seems to have a two-level hierarchy (just my feeling, I'm not sure if I'm correct, I have less experience in theorem proving than you...), in the \"outer level\" you use <code>axiom</code>, <code>def</code>, <code>theorem</code> etc. to introduce things, and the \"inner level\" is only relevant when checking individual terms, where you use <code>let</code>, <code>λ</code> etc. to introduce things (and these things will be removed once you go out of their scope)?</p>",
        "id": 269787120,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643397041
    },
    {
        "content": "<p>That is how it appears to me as well. I don't have that much experience either. I'm wondering if that is what Mario means by a global and local context in my implementation.</p>",
        "id": 269787450,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643397197
    },
    {
        "content": "<p>I don't think you made such a distinction in your implementation (I also did not, and I'm not even sure whether we need two levels of contexts...)</p>",
        "id": 269788829,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643397843
    },
    {
        "content": "<p>No, I don't think I did. I'm wondering if I should have.</p>",
        "id": 269788965,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643397913
    },
    {
        "content": "<p>(Probably this is for the sake of checking speed? After removing definitions from the context, you will need to check if the conclusion of a proof is still a well-formed formula, and if there are only two layers (here I mean a global one and one for the scope of a <code>Let</code>, with no nested <code>Let</code>s) this check will not be too often)</p>",
        "id": 269789775,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643398312
    },
    {
        "content": "<p>But we still have nested <code>let</code>s and <code>λ</code>s in Lean anyway (Lean's \"inner level\" context is more like a stack with multiple layers. Sorry if my wording is confusing...)</p>",
        "id": 269789915,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643398376
    },
    {
        "content": "<p>I'm also wondering if a Hilbert system was the right approach.</p>",
        "id": 269791711,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643399207
    },
    {
        "content": "<p>I (personally) think to make proofs appear natural, it's better to provide rules that allow making and discharging hypotheses directly (and anyway you can transform such proofs into Hilbert-style using the deduction theorem afterwards)... <a href=\"http://us.metamath.org/mpeuni/mmnatded.html\">Metamath also supports this!</a></p>",
        "id": 269793420,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643399914
    },
    {
        "content": "<p>Hmm. I wonder if <code>let</code> and <code>have</code> are something usually reserved for natural deduction.</p>",
        "id": 269797192,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643401395
    },
    {
        "content": "<p>Same with local and global contexts.</p>",
        "id": 269797343,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643401456
    },
    {
        "content": "<p>Or at least originate from it.</p>",
        "id": 269797389,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643401480
    },
    {
        "content": "<p>In some sense yes? Natural deduction is indeed related to <code>λ</code> (through the Curry-Howard correspondence) which also binds some variable...</p>",
        "id": 269797968,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643401785
    },
    {
        "content": "<p><code>let</code> and <code>have</code> are related to the \"cut rule\" in sequent calculus in this way</p>",
        "id": 269798094,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643401843
    },
    {
        "content": "<p>Interesting. I am familiar with the Curry-Howard correspondence, but not sequent calculus.</p>",
        "id": 269798358,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643401981
    },
    {
        "content": "<p>Sequent calculus feels like \"what we are actually thinking when writing down natural deduction proofs\", and it works both forwards (from premises) and backwards (from goals); natural deduction is like working forwards only</p>",
        "id": 269798770,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643402169
    },
    {
        "content": "<p>Hmm. What do <code>have</code> and <code>let</code> correspond to in natural deduction?</p>",
        "id": 269798955,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643402269
    },
    {
        "content": "<p>The cut rule corresponds to \"proving some lemma and then use it to prove the goal\" in ND</p>",
        "id": 269799106,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643402338
    },
    {
        "content": "<p>I see. Are there also local and global definitions?</p>",
        "id": 269799272,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643402407
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 269799274,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643402408
    },
    {
        "content": "<p>I don't think so, they are often considered separately as an extension to FOL? (But in dependent type theory with C-H they are similar to <code>let</code>...)</p>",
        "id": 269799331,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1643402441
    },
    {
        "content": "<p>I see. Thank you!</p>",
        "id": 269799415,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643402489
    },
    {
        "content": "<p>Is there a good reference for formalized natural deduction extended with definitions?</p>",
        "id": 269821328,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643414717
    },
    {
        "content": "<p>What is the form of natural deduction that Lean corresponds to in the Curry-Howard correspondence? Is there a formalization for it?</p>",
        "id": 269826105,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643418135
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/268179806\">said</a>:</p>\n<blockquote>\n<p>Your rule for <code>ForallIntro</code> is problematic because you don't have a weakening rule: you won't be able to prove e.g. <code>x = x |- forall x. True</code>. One way to fix it is instead of checking <code>not (any (freeIn x) gamma)</code> you filter out everything from <code>gamma</code> which has a free <code>x</code> in the subproof.</p>\n</blockquote>\n<p>Do you mean like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Forall</span> <span class=\"n\">introduction</span><span class=\"o\">:</span>\n<span class=\"n\">Let</span> <span class=\"n\">gamma</span> <span class=\"bp\">-</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"n\">be</span> <span class=\"n\">the</span> <span class=\"n\">set</span> <span class=\"n\">of</span> <span class=\"n\">all</span> <span class=\"n\">the</span> <span class=\"n\">formulas</span> <span class=\"k\">in</span> <span class=\"n\">gamma</span> <span class=\"n\">for</span> <span class=\"n\">which</span> <span class=\"n\">x</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"n\">occur</span> <span class=\"n\">free.</span> <span class=\"n\">Then</span>\n<span class=\"o\">(</span><span class=\"n\">gamma</span> <span class=\"bp\">-</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span><span class=\"bp\">|-</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n<span class=\"o\">(</span><span class=\"n\">gamma</span> <span class=\"bp\">|-</span> <span class=\"k\">forall</span> <span class=\"n\">x.</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 269831255,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643423293
    },
    {
        "content": "<p>Does the same problem occur in my implementation of exists elimination?</p>",
        "id": 269831858,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643424011
    },
    {
        "content": "<p>Is it natural deduction that Lean corresponds to in the C-H correspondence? If so, what are the exact rules of inference for it? What do <code>let</code> and <code>have</code> correspond to in it?</p>",
        "id": 269843136,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643436915
    },
    {
        "content": "<p>Are <code>have</code> statements needed because my checker processes a proof as a tree, and in a tree you have to repeat the entirety of subproofs if you use them more than once? For example, would <code>have</code> statements no longer be needed if instead my checker processed the proof as a sequence of labelled steps, and the inference rules just used the labels to refer to previously checked steps?</p>",
        "id": 269849090,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643444733
    },
    {
        "content": "<p>This could probably be made cleaner and faster, but for a thrown together example, does this eliminate the need for <code>have</code> statements?</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"kr\">import</span><span class=\"w\"> </span><span class=\"nn\">Data.Map</span><span class=\"w\"></span>\n<span class=\"kr\">import</span><span class=\"w\"> </span><span class=\"nn\">Data.Set</span><span class=\"w\"></span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Func \"c\" [] : A constant named \"c\"</span>\n<span class=\"cm\">Func \"f\" [v] : A function named \"f\" of one variable v</span>\n<span class=\"cm\">-}</span><span class=\"w\"></span>\n<span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">Term</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Var</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"></span>\n<span class=\"w\">          </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Func</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kr\">deriving</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Eq</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Pred \"P\" [] : A propositional variable named \"P\"</span>\n<span class=\"cm\">Pred \"Eq\" [s, t] : s = t</span>\n<span class=\"cm\">-}</span><span class=\"w\"></span>\n<span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Bottom</span><span class=\"w\"> </span><span class=\"c1\">-- False</span><span class=\"w\"></span>\n<span class=\"w\">             </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Top</span><span class=\"w\"> </span><span class=\"c1\">-- True</span><span class=\"w\"></span>\n<span class=\"w\">             </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Pred</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">Term</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">             </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Not</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"w\">             </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">And</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"w\">             </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Or</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"w\">             </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Imp</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"w\">             </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Iff</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"w\">             </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Forall</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"w\">             </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Exists</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"w\">               </span><span class=\"kr\">deriving</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Eq</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n<span class=\"kr\">type</span><span class=\"w\"> </span><span class=\"kt\">Assertion</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n\n<span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">Justification</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">MP</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"w\"></span>\n<span class=\"w\">                   </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Prop_1</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"w\">                   </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Prop_2</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"w\">                   </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Prop_3</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"w\">                     </span><span class=\"kr\">deriving</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Eq</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n<span class=\"kr\">type</span><span class=\"w\"> </span><span class=\"kt\">Step</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Assertion</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Justification</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n<span class=\"nf\">checkStep</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">Step</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Step</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Bool</span><span class=\"w\"></span>\n\n<span class=\"c1\">-- Propositional calculus</span><span class=\"w\"></span>\n\n<span class=\"c1\">-- |- p &amp; |- (p -&gt; q) =&gt; |- q</span><span class=\"w\"></span>\n<span class=\"nf\">checkStep</span><span class=\"w\"> </span><span class=\"n\">checked</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">q</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">MP</span><span class=\"w\"> </span><span class=\"n\">index_1</span><span class=\"w\"> </span><span class=\"n\">index_2</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"n\">pq</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">checked</span><span class=\"w\"> </span><span class=\"o\">!!</span><span class=\"w\"> </span><span class=\"n\">index_1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kr\">in</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">checked</span><span class=\"w\"> </span><span class=\"o\">!!</span><span class=\"w\"> </span><span class=\"n\">index_2</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kr\">in</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">case</span><span class=\"w\"> </span><span class=\"n\">pq</span><span class=\"w\"> </span><span class=\"kr\">of</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"kt\">Imp</span><span class=\"w\"> </span><span class=\"n\">p'</span><span class=\"w\"> </span><span class=\"n\">q'</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">p'</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">q'</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"ne\">error</span><span class=\"w\"> </span><span class=\"s\">\"mp\"</span><span class=\"w\"></span>\n\n<span class=\"c1\">-- |- (p -&gt; (q -&gt; p))</span><span class=\"w\"></span>\n<span class=\"nf\">checkStep</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">assertion</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Prop_1</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">assertion</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">))</span><span class=\"w\"></span>\n\n<span class=\"c1\">-- |- ((p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r)))</span><span class=\"w\"></span>\n<span class=\"nf\">checkStep</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">assertion</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Prop_2</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">assertion</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"p\">)))</span><span class=\"w\"></span>\n\n<span class=\"c1\">-- |- (((p -&gt; false) -&gt; false) -&gt; p)</span><span class=\"w\"></span>\n<span class=\"nf\">checkStep</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">assertion</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Prop_3</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">assertion</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"p\">(((</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"kt\">Bottom</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"kt\">Bottom</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n\n<span class=\"nf\">checkAll</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">Step</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Bool</span><span class=\"w\"></span>\n<span class=\"nf\">checkAll</span><span class=\"w\"> </span><span class=\"n\">steps</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">steps</span><span class=\"w\"> </span><span class=\"kt\">[]</span><span class=\"w\"> </span><span class=\"kr\">where</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">Step</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">Step</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Bool</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"kt\">[]</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">True</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"kt\">:</span><span class=\"n\">xs</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">previous</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">checkStep</span><span class=\"w\"> </span><span class=\"n\">previous</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">previous</span><span class=\"w\"> </span><span class=\"o\">++</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">]))</span><span class=\"w\"></span>\n\n\n<span class=\"c1\">-- Example</span><span class=\"w\"></span>\n\n<span class=\"c1\">-- |- p -&gt; p</span><span class=\"w\"></span>\n\n<span class=\"nf\">ex_1</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Pred</span><span class=\"w\"> </span><span class=\"s\">\"P\"</span><span class=\"w\"> </span><span class=\"kt\">[]</span><span class=\"w\"> </span><span class=\"kr\">in</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"n\">s0</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)),</span><span class=\"w\"> </span><span class=\"kt\">Prop_2</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kr\">in</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"kt\">Prop_1</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"kr\">in</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"kt\">MP</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kr\">in</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"n\">s3</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"kt\">Prop_1</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kr\">in</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"n\">s4</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Imp</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">MP</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kr\">in</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">checkAll</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">s0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">s3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">s4</span><span class=\"p\">]</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 269852470,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643449036
    },
    {
        "content": "<p>Looks good.</p>\n<p>But here's one thing where type theory is superior to usual FOL: In type theory, <code>let</code> and <code>have</code> are essentially the same thing except for syntactic differences. In FOL they have to be different: <code>let</code> for terms and <code>have</code> for proofs.</p>",
        "id": 269858977,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1643456856
    },
    {
        "content": "<p>Great! Thank you!<br>\nI think MetaMath has the user prove that each term and formula is valid? I'm not sure how their use in the proof is then checked.</p>",
        "id": 269875167,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643475198
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269849090\">said</a>:</p>\n<blockquote>\n<p>Are <code>have</code> statements needed because my checker processes a proof as a tree, and in a tree you have to repeat the entirety of subproofs if you use them more than once? For example, would <code>have</code> statements no longer be needed if instead my checker processed the proof as a sequence of labelled steps, and the inference rules just used the labels to refer to previously checked steps?</p>\n</blockquote>\n<p>Yes, that's correct. The same thing applies to terms, and here you gain the additional advantage that if every term is only constructed once then equality checking becomes O(1)</p>",
        "id": 269878785,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643479217
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269760278\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269530905\">said</a>:</p>\n<blockquote>\n<p>It does, but now you have the issue that you have to recheck subformulas many times. The usual way to fix this is to add some explicit DAG-like structure to your proof terms, so that if a subproof or subformula appears in two places it only has to be validated once.</p>\n</blockquote>\n<p>When you say the usual way, what do you mean? What references or examples do you draw from?</p>\n</blockquote>\n<p>Besides my experience with poking around in different proof assistants, almost everything I've talked about in this thread has been incorporated as part of <a href=\"https://github.com/digama0/mm0\">MM0</a>, including the term deduplication trick I just mentioned. When you put it all together it has a really dramatic effect on performance</p>",
        "id": 269878934,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643479361
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269786219\">said</a>:</p>\n<blockquote>\n<p>So a global context is common to all proofs? I guess I'm having trouble understanding what would constitute separate proofs, because in order to use one proof in another you have to check the \"external\" proof when you encounter a reference to it in another proof?</p>\n</blockquote>\n<p>The global context should include also a list of checked proofs, which can then be referenced as part of new proofs. Both metamath and lean work like that.</p>",
        "id": 269879052,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643479487
    },
    {
        "content": "<p>I know a few proof assistants that lack this \"two level hierarchy\", but they seem to be in the minority. In many of the HOLs, including HOL light, there is no explicit two-level thing; instead every theorem stands on its own and you \"name\" a theorem by assigning it to an OCaml variable. I think this was later found to be a bad idea, because it means you can't just enumerate over the theorems that exist like lean's <code>environment.fold</code>, nor can you get their user-provided names, which is problematic for, say, a proof exporter.</p>\n<p>Lean does not have any context management keywords at the \"global\" level, unlike Zhanrong's language. I think these are avoided because they require you to keep the list of statements in a stack, which makes lookups more expensive, and if popping an assumption changes the type of statements then it can be expensive. I think Isabelle and Coq both have a module system, which amounts to hypotheses at the global level that can be discharged later, but I believe the scope checking entails walking all the theorems in the scope and I have heard rumors of long running <code>Qed.</code> statements, which is a baffling experience for users since it is weird that closing a scope should be expensive.  Lean 3 has <code>parameter</code> which tries to simulate this behavior, but it isn't really type changing the theorems, it only makes them appear to have a different type inside the scope.</p>",
        "id": 269879679,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643480230
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269875167\">said</a>:</p>\n<blockquote>\n<p>Great! Thank you!<br>\nI think MetaMath has the user prove that each term and formula is valid? I'm not sure how their use in the proof is then checked.</p>\n</blockquote>\n<p>Every theorem comes with assumptions about each variable appearing in the theorem. So for example modus ponens which looks like <code>|- P  &amp; |- (P -&gt; Q)  =&gt;  |- Q</code> actually has four assumptions: <code>wff P</code>, <code>wff Q</code>, <code>|- P</code>and <code>|- (P -&gt; Q)</code>. So when you apply this theorem you make substitutions in for <code>P</code> and <code>Q</code>, say <code>T.</code> and <code>x = x</code>, and then you would have subproofs for <code>wff T.</code>, <code>wff x = x</code>, <code>|- T.</code> and <code>|- (T -&gt; x = x)</code>. The <code>wff T.</code> proof is showing that <code>T.</code> is a well formed formula.</p>",
        "id": 269880084,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643480726
    },
    {
        "content": "<p>Thank you!<br>\nDo you mean that you have additional steps, where each is an assertion that a term or formula is well formed with a justification potentially referring to previous steps for why that assertion holds, and when for example you need to pass a proof of p and q being well formed to mp, then you just pass the step label that asserts that p is well formed and the step label that asserts that q is well formed? So mp just takes four step labels? Do you interleave these steps with the steps for the axioms and inference rules, and add the justifications for being well formed to the list of justifications for the axioms and inference rules, or do you keep them separate and check all of the assertions of being well formed first?</p>",
        "id": 269882914,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643483895
    },
    {
        "content": "<p>Why incidentally is it that mp requires proofs of p and q being well formed, and not p and p -&gt; q?</p>",
        "id": 269883215,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643484245
    },
    {
        "content": "<p>The well formedness steps are interleaved with the rest in the overall proof, but for each individual theorem all the well-formedness assumptions (called \"floating hypotheses\" or <code>$f</code> in metamath) precede the regular assumptions (\"essential hypotheses\" or <code>$e</code> in metamath) to that theorem.</p>",
        "id": 269884064,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643485290
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269883215\">said</a>:</p>\n<blockquote>\n<p>Why incidentally is it that mp requires proofs of p and q being well formed, and not p and p -&gt; q?</p>\n</blockquote>\n<p>The <code>$f</code> hypotheses to a theorem are calculated automatically, by collecting all the variables that appear in the <code>$e</code> hypotheses and the theorem statement. This is somewhat analogous to what would happen in lean if you had <code>variables p q r s t : Prop</code> at the top of the file and then state <code>theorem mp (min : p) (maj : p -&gt; q) : q := ...</code>, you will get four actual pis in the theorem statement, <code>(p q : Prop) (min : p) (maj : p -&gt; q)</code>. You don't need an assumption that <code>p -&gt; q</code> is well formed because the theorem itself has the context to see that if <code>p</code> and <code>q</code> are well formed then so is  <code>p -&gt; q</code>, so even after substituting <code>p</code> and <code>q</code> we know it is well formed</p>",
        "id": 269884230,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643485512
    },
    {
        "content": "<p>Note that in metamath proof assertions and well formedness assertions are on the same footing - <code>wff p</code> and <code>|- p</code> are just two different statements that can be proved</p>",
        "id": 269884332,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643485675
    },
    {
        "content": "<p>I think I see. So<code>mp</code> in my implementation would still take four step labels, one for the assertion of <code>wff p</code>, one for <code>wff q</code>, one for<code> |- p</code> and one for <code>|- p -&gt; q</code>? And the code for <code>mp</code> looks at the assertions at those step labels and checks that everything matches up?</p>",
        "id": 269884650,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643485984
    },
    {
        "content": "<p>What makes a formula (or term?) well formed? That each occurring predicate and function is in the definitions table, and that each subformula (and subterm?) is well formed?</p>",
        "id": 269885078,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643486313
    },
    {
        "content": "<p>Do you have justifications like <code>AndWff Int Int</code>, where the first <code>Int</code> is the label of a step that asserts that the left subformula of the <code>/\\</code> is well formed and the second is the label of a step that asserts that the right subformula is well formed?</p>",
        "id": 269885482,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643486647
    },
    {
        "content": "<p>Yes. Each term constructor is introduced by an axiom that looks like <code>wff (p -&gt; q)</code>, which like other theorems inherits the assumptions <code>wff p</code> and <code>wff q</code></p>",
        "id": 269885966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643487180
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269885078\">said</a>:</p>\n<blockquote>\n<p>What makes a formula (or term?) well formed? That each occurring predicate and function is in the definitions table, and that each subformula (and subterm?) is well formed?</p>\n</blockquote>\n<p>In metamath, saying that a formula is well formed is the same as asserting the provability of <code>wff fmla</code>, in a context where you have wff hypotheses for every variable and have access to the syntax axioms like <code>wff p &amp; wff q =&gt; wff (p -&gt; q)</code></p>",
        "id": 269886096,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643487338
    },
    {
        "content": "<p>the distinction between formulas and terms is done here by having multiple constants that can appear in the first position: <code>wff p</code> vs <code>class A</code></p>",
        "id": 269886179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643487430
    },
    {
        "content": "<p>each metamath database defines its set of valid sorts, it's not a closed list known to the verifier</p>",
        "id": 269886200,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643487469
    },
    {
        "content": "<p>same thing for the syntax axioms</p>",
        "id": 269886205,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643487478
    },
    {
        "content": "<p>As a result, the <code>Justification</code> grammar in metamath looks closer to this:</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">Justification</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">ApplyThm</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">Justification</span><span class=\"p\">]</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 269886352,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643487603
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269886179\">said</a>:</p>\n<blockquote>\n<p>the distinction between formulas and terms is done here by having multiple constants that can appear in the first position: <code>wff p</code> vs <code>class A</code></p>\n</blockquote>\n<p>When you say term and formula here are you referring to what corresponds to <code>Term</code> and <code>Formula</code> in my implementation?</p>",
        "id": 269886434,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643487697
    },
    {
        "content": "<p>yes</p>",
        "id": 269886453,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643487720
    },
    {
        "content": "<p>those aren't metamath concepts per se</p>",
        "id": 269886497,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643487732
    },
    {
        "content": "<p>but if you are doing FOL-ish things you will probably have something similar to terms and formulas, and in <a href=\"http://set.mm\">set.mm</a> that's <code>wff</code> and <code>class</code></p>",
        "id": 269886538,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643487781
    },
    {
        "content": "<p>Oh, class as in class variable?</p>",
        "id": 269886561,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643487808
    },
    {
        "content": "<p><code>class</code> is actually more like second order terms, but it is used for both</p>",
        "id": 269886573,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643487820
    },
    {
        "content": "<p>yes, it means ZFC class expression</p>",
        "id": 269886581,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643487831
    },
    {
        "content": "<p>there is also <code>setvar</code> but this is only for set variables, as the name implies, not expressions</p>",
        "id": 269886636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643487863
    },
    {
        "content": "<p>Hmm. Thank you. I will try and see if I can extend what I have with what I think I understand.</p>",
        "id": 269886855,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643488091
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269884230\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269883215\">said</a>:</p>\n<blockquote>\n<p>Why incidentally is it that mp requires proofs of p and q being well formed, and not p and p -&gt; q?</p>\n</blockquote>\n<p>The <code>$f</code> hypotheses to a theorem are calculated automatically, by collecting all the variables that appear in the <code>$e</code> hypotheses and the theorem statement. This is somewhat analogous to what would happen in lean if you had <code>variables p q r s t : Prop</code> at the top of the file and then state <code>theorem mp (min : p) (maj : p -&gt; q) : q := ...</code>, you will get four actual pis in the theorem statement, <code>(p q : Prop) (min : p) (maj : p -&gt; q)</code>. You don't need an assumption that <code>p -&gt; q</code> is well formed because the theorem itself has the context to see that if <code>p</code> and <code>q</code> are well formed then so is  <code>p -&gt; q</code>, so even after substituting <code>p</code> and <code>q</code> we know it is well formed</p>\n</blockquote>\n<p>For the formulas passed to the axiom schemes, are you just checking that each formula passed is well formed? For example, passing <code>p -&gt; q</code> and <code>q -&gt; r</code> to the parameters <code>p</code> and <code>q</code> of <code>prop_1</code>, do they provide proofs that <code>p -&gt; q</code> and <code>q -&gt; r</code> are well formed, or that <code>p</code>, <code>q</code> and <code>r</code> are well formed? In the latter case, you would need to accept a variable number of proofs for wff and try to match them up?</p>",
        "id": 269893994,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643496785
    },
    {
        "content": "<p>the latter. There is one wff proof per variable appearing in the formula</p>",
        "id": 269894068,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643496847
    },
    {
        "content": "<p>and they come in the same order as the variable declaration</p>",
        "id": 269894085,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643496881
    },
    {
        "content": "<p>So if the passed parameters were <code>a -&gt; (c -&gt; d)</code> and <code>c -&gt; b</code> they would pass wff proofs in the order for <code>a, c, d, b</code>?</p>",
        "id": 269894162,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643496967
    },
    {
        "content": "<p>no, they would be in the order <code>a,b,c,d</code></p>",
        "id": 269894172,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643496981
    },
    {
        "content": "<p>because that's the order they were defined at the top of the file</p>",
        "id": 269894182,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643496995
    },
    {
        "content": "<p>pretty sure. It's mostly handled behind the scenes by the authoring tool, the user doesn't generally have to see it</p>",
        "id": 269894196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643497045
    },
    {
        "content": "<p>Hmm, that seems like it complicates my implementation, or I'm not sure how to handle it well.</p>",
        "id": 269894265,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643497139
    },
    {
        "content": "<p>Do I lose anything by requiring wff proofs for what is passed exactly instead?</p>",
        "id": 269894339,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643497205
    },
    {
        "content": "<p>Suppose you want to prove <code>a -&gt; b</code> and <code>b -&gt; c</code> implies <code>a -&gt; c</code>. You need to know more than that <code>a -&gt; b</code> and <code>b -&gt; c</code> are well formed, you need <code>a</code> and <code>b</code> to be well formed to apply lemmas that recombine these variables in different ways</p>",
        "id": 269894503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643497380
    },
    {
        "content": "<p>The automatic variable construction in metamath is a front end thing. Behind the scenes it probably makes more sense to assume the list of variables is provided in some order and you just check that all the hypotheses use variables in that list</p>",
        "id": 269894593,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643497491
    },
    {
        "content": "<p>When you say a variable in a hypothesis, are talking about subformulas or actually variables of the form <code>Var x</code>? What level do you break each formula down to that the user has to provide wff proofs for?</p>",
        "id": 269894700,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643497640
    },
    {
        "content": "<p>Are we taking definitions into account here also, in that predicates and functions have to be defined in order to be considered well formed?</p>",
        "id": 269894807,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643497778
    },
    {
        "content": "<p>I mean variables</p>",
        "id": 269894817,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643497802
    },
    {
        "content": "<p>you don't have to unfold definitions, it is syntactically obvious what the variables in an expression are</p>",
        "id": 269894867,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643497825
    },
    {
        "content": "<p>isn't a variable well formed by definition? Why do we need to check that it is well formed?</p>",
        "id": 269894891,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643497883
    },
    {
        "content": "<p>For an expression to be well formed you have to be able to prove it is well formed. That proof uses syntax axioms, and you get one of those for every definition</p>",
        "id": 269894895,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643497896
    },
    {
        "content": "<p>In this setting variables are not well formed by definition, well formedness means that the variable is among the list of variables permitted to appear in the statement</p>",
        "id": 269894962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643497966
    },
    {
        "content": "<p>in the metamath approach this is true by construction, but if you are given a list of variables separately then you have to check it</p>",
        "id": 269894977,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643497988
    },
    {
        "content": "<p>Oh, but metamath is at a lower level then what I am doing right. In my implementation you can only construct wff, provided that the predicates and functions are defined?</p>",
        "id": 269894994,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643498014
    },
    {
        "content": "<p>or if the variables are numbered then you are checking that the numbers are less than the length of the list</p>",
        "id": 269894995,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643498018
    },
    {
        "content": "<p>Because they are constrained by the constructors of <code>Term</code> and <code>Formula</code>?</p>",
        "id": 269895048,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643498066
    },
    {
        "content": "<p>Well, your prover still isn't dealing with applying one theorem in another context (with substitution for the variables)</p>",
        "id": 269895059,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643498089
    },
    {
        "content": "<p>the situation to avoid is that the substitution does not cover one of the variables appearing in the statement of the theorem</p>",
        "id": 269895084,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643498123
    },
    {
        "content": "<p>You mean accidental bindings?</p>",
        "id": 269895098,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643498160
    },
    {
        "content": "<p>The only context I have is the global context of definitions and proofs previously checked right?</p>",
        "id": 269895168,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643498237
    },
    {
        "content": "<p>like if you have <code>syl: (a -&gt; b) =&gt; (b -&gt; c) =&gt; (a -&gt; c)</code> and you say \"apply <code>syl</code> with <code>a := 2 + 2</code>\" and don't say anything about <code>b</code></p>",
        "id": 269895172,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643498249
    },
    {
        "content": "<p>the metamath approach is to first gather up the variables in <code>syl</code> in order to get <code>a,b,c</code>, and then when you apply it you have to give 3 things <code>x,y,z</code> and then given two more things <code>x -&gt; y</code> and <code>y -&gt; z</code> you get <code>x -&gt; z</code>. If the gathering of variables wasn't done correctly and, say, omitted <code>c</code>, then the downstream use would not substitute for it and you would get a scope error where <code>c</code> appears in the present theorem without any hypothesis about it</p>",
        "id": 269895264,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643498393
    },
    {
        "content": "<p>or you would just get a crash when you look up <code>c</code> in some map</p>",
        "id": 269895317,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643498458
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269895168\">said</a>:</p>\n<blockquote>\n<p>The only context I have is the global context of definitions and proofs previously checked right?</p>\n</blockquote>\n<p>I mean another local context, i.e. you are proving an unrelated theorem from the one to be applied</p>",
        "id": 269895379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643498533
    },
    {
        "content": "<p>So we are talking about when I have more than one proof, and proofs take hypothesis?</p>",
        "id": 269895550,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643498722
    },
    {
        "content": "<p>I guess I'm confused, because I don't declare a list of variables at the beginning?</p>",
        "id": 269895616,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643498799
    },
    {
        "content": "<p>I mean, in this Hilbert system there are no hypothesis right?</p>",
        "id": 269895643,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643498858
    },
    {
        "content": "<p>So this would be an issue only if I allowed for them, say moved to natural deduction?</p>",
        "id": 269895713,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643498938
    },
    {
        "content": "<p>Sure, you can have them all exist a priori (as long as you only have one type, which is already not quite true since you have formulas and terms), but then you have to decide what to do about substitution in a theorem</p>",
        "id": 269895890,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643499210
    },
    {
        "content": "<p>like, I want to be able to prove <code>syl</code> once (using the axioms) and use it later without having to replay the axioms</p>",
        "id": 269895945,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643499256
    },
    {
        "content": "<p>I'm sorry, I'm not sure I am following. If I want to prove something, I need to declare what variables are allowed to appear in the proof?</p>",
        "id": 269896149,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643499558
    },
    {
        "content": "<p>in metamath, yes</p>",
        "id": 269896203,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643499617
    },
    {
        "content": "<p>in lean, yes as well</p>",
        "id": 269896206,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643499629
    },
    {
        "content": "<p>Sorry, why is that again?</p>",
        "id": 269896211,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643499645
    },
    {
        "content": "<p>you can't just use random variables that haven't been declared, because variables come with type information and a random letter has unknown type</p>",
        "id": 269896223,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643499670
    },
    {
        "content": "<p>In HOL you can kind of get away with this by having a constructor of the form <code>Var String Type</code></p>",
        "id": 269896276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643499734
    },
    {
        "content": "<p>but it's still dicey because you can have variables <code>a: A</code> and <code>a: B</code> and they should be treated as different (even after substituting <code>B := A</code>!)</p>",
        "id": 269896300,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643499786
    },
    {
        "content": "<p>I didn't think FOL had types? I thought there was just one big domain of discourse?</p>",
        "id": 269896308,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643499822
    },
    {
        "content": "<p>What about wff vs term?</p>",
        "id": 269896355,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643499865
    },
    {
        "content": "<p>Oh. So like the p and q in the prop_1 scheme are variables of type formula and the t in the eq_refl scheme is a variable of type term?</p>",
        "id": 269896449,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643500004
    },
    {
        "content": "<p>right</p>",
        "id": 269896454,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643500016
    },
    {
        "content": "<p>If you don't do this, you won't be able to substitute in <code>syl</code>, which is a pretty big hit for a hilbert system</p>",
        "id": 269896464,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643500038
    },
    {
        "content": "<p>that is, without the ability to prove propositional theorems you can't build up a toolbox of useful theorems like <code>and.left</code></p>",
        "id": 269896474,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643500072
    },
    {
        "content": "<p>In natural deduction it is not quite as bad because the axioms are a little closer to practice, but there are still plenty of useful propositional lemmas that aren't god given like <code>and_assoc</code></p>",
        "id": 269896536,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643500138
    },
    {
        "content": "<p>Would you call these something like proof schemes?</p>",
        "id": 269896542,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643500151
    },
    {
        "content": "<p>yes</p>",
        "id": 269896545,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643500163
    },
    {
        "content": "<p>in metamath everything is a scheme, it's a logic of schemes being deduced from other schemes</p>",
        "id": 269896553,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643500192
    },
    {
        "content": "<p>which is why variable distinctness is a primitive notion</p>",
        "id": 269896597,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643500213
    },
    {
        "content": "<p>That is, you are proving proof schemes, and when the user goes to use it they need to know what kind of variables to substitute in for which parameters?</p>",
        "id": 269896608,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643500238
    },
    {
        "content": "<p>Like in the proof of p -&gt; p I would declare p to be a formula variable.</p>",
        "id": 269896628,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643500286
    },
    {
        "content": "<p>exactly</p>",
        "id": 269896630,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643500291
    },
    {
        "content": "<p>So when the user passes an expression in for p, you have to break it done into all of the variables and then make sure that they recombine to form a formula?</p>",
        "id": 269896730,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643500434
    },
    {
        "content": "<p>Because p has been declared to be a formula variable in the proof?</p>",
        "id": 269896805,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643500525
    },
    {
        "content": "<p>well, they have to pass a formula for p</p>",
        "id": 269896806,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643500527
    },
    {
        "content": "<p>so previously they had to have constructed that formula, with all the attendant checks</p>",
        "id": 269896816,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643500551
    },
    {
        "content": "<p>that is, you have a formula <code>foo</code> which has already been validated and you put it in as <code>p := foo</code> in <code>id : p -&gt; p</code>, which is done by traversing the expression <code>p -&gt; p</code> and replacing occurrences of <code>p</code> with <code>foo</code></p>",
        "id": 269896891,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643500631
    },
    {
        "content": "<p>and that replacement doesn't have to validate anything, because <code>p -&gt; p</code> is a valid formula and <code>foo</code> is a valid formula so <code>foo -&gt; foo</code> is also valid</p>",
        "id": 269896907,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643500666
    },
    {
        "content": "<p>So you would have a justification like, declared as term variable and a justification like declared as formula variable?</p>",
        "id": 269896997,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643500794
    },
    {
        "content": "<p>But you also have a third type of variable, the one occurring as <code>Var String</code> in term, which I guess is an object variable?</p>",
        "id": 269897163,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643500908
    },
    {
        "content": "<p>And the term and formula ones are meta variables? or schema variables?</p>",
        "id": 269897225,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643500964
    },
    {
        "content": "<p>I think you can unify term variables and term metavariables in that scheme</p>",
        "id": 269897259,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643501035
    },
    {
        "content": "<p>I'm sorry, I'm still not quite clear what I am checking if a formula is passed to an axiom scheme. I know it is a formula because they had to check it before hand right? In the check for that step of the proof, do I still need to gather all the variables that occur in the passed formulas and check that they are declared? Declared where? Wasn't that already done when it was checked that it was a formula?</p>",
        "id": 269898023,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643502121
    },
    {
        "content": "<p>For reference, I am taking about what I need to check for example in the <code>checkStep _ (assertion, Prop_1 p q)</code> case of this code:<br>\n<a href=\"/user_uploads/3121/XGL0C-xqJv8LziFuEjWxxxl8/Hilbert_Linear.hs\">Hilbert_Linear.hs</a></p>",
        "id": 269898153,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643502276
    },
    {
        "content": "<p>We are saying that the user has already checked that what is passed in for <code>p</code> and <code>q</code> are formulas right? But we also need to break these apart to determine that all of the variables occurring in the formulas that were passed are declared somewhere? Isn't that done when they verified they were formulas?</p>",
        "id": 269898261,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643502435
    },
    {
        "content": "<p>Or is this not for the axiom schemes in my implementation, but for the proof schemes?</p>",
        "id": 269898595,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643502864
    },
    {
        "content": "<p>Because in the axiom schemes for my implementation what needs to be passed in is already explicit.</p>",
        "id": 269898625,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643502937
    },
    {
        "content": "<p>So should I rename my data definition for <code>Term</code> to <code>TermScheme</code> and add a constructor that takes the name of a term scheme variable, and change the definition of <code>Formula</code> to <code>FormulaScheme</code> and add a constructor that takes the name of a formula scheme variable? So each axiom scheme takes formula schemes and term schemes and returns proof schemes?</p>",
        "id": 269899922,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643504475
    },
    {
        "content": "<p>Or would I even have data definitions for any kind of term, term scheme, formula or formula scheme?</p>",
        "id": 269900020,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643504603
    },
    {
        "content": "<p>Like, how far off was I here:<br>\n<a href=\"/user_uploads/3121/n43o4mVTbpysIksQ-W-PVeF9/Hilbert_Linear_2.hs\">Hilbert_Linear_2.hs</a></p>",
        "id": 269900774,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643505513
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269898153\">said</a>:</p>\n<blockquote>\n<p>For reference, I am taking about what I need to check for example in the <code>checkStep _ (assertion, Prop_1 p q)</code> case of this code:<br>\n<a href=\"/user_uploads/3121/XGL0C-xqJv8LziFuEjWxxxl8/Hilbert_Linear.hs\">Hilbert_Linear.hs</a></p>\n</blockquote>\n<p>In addition to what you already have, you need to check that <code>p</code> and <code>q</code> are valid formulas, or else you should have <code>Int</code>s passed in and refer to some already checked formulas in the local context</p>",
        "id": 269900796,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643505553
    },
    {
        "content": "<p>Like in the code I just added?</p>",
        "id": 269900816,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643505600
    },
    {
        "content": "<p>I would modify that code to remove the <code>Formula</code> from <code>FormulaStep</code>, and instead have the type of checked steps be different from the input</p>",
        "id": 269900966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643505773
    },
    {
        "content": "<p>Sorry, why is that? And why only for FormulaStep?</p>",
        "id": 269901144,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643505984
    },
    {
        "content": "<p>Or do you mean have only one kind of step?</p>",
        "id": 269901165,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643506022
    },
    {
        "content": "<p>Instead of ProofStep, FormulaStep and TermStep just have Step?</p>",
        "id": 269901251,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643506118
    },
    {
        "content": "<p>yes, that</p>",
        "id": 269901262,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643506136
    },
    {
        "content": "<p>1 sec, example coming up</p>",
        "id": 269901268,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643506143
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">Term</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Var</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">deriving</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Eq</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Imp</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">deriving</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Eq</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">Proof</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Proof</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n\n<span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">Step</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">IsVar</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">IsImp</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">MP</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">deriving</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Eq</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n<span class=\"kr\">type</span><span class=\"w\"> </span><span class=\"kt\">LocalContext</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">([</span><span class=\"kt\">Term</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">Formula</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">Proof</span><span class=\"p\">])</span><span class=\"w\"></span>\n\n<span class=\"nf\">pushTerm</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">LocalContext</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Term</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">LocalContext</span><span class=\"w\"></span>\n<span class=\"nf\">pushTerm</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ts</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fs</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ts</span><span class=\"w\"> </span><span class=\"o\">++</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">t</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">fs</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"nf\">getTerm</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">LocalContext</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Term</span><span class=\"w\"></span>\n<span class=\"nf\">getTerm</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ts</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"w\"> </span><span class=\"o\">!!</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"></span>\n\n<span class=\"nf\">pushFormula</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">LocalContext</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">LocalContext</span><span class=\"w\"></span>\n<span class=\"nf\">pushFormula</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ts</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fs</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ts</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fs</span><span class=\"w\"> </span><span class=\"o\">++</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">f</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"nf\">getFormula</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">LocalContext</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"nf\">getFormula</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kr\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fs</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">fs</span><span class=\"w\"> </span><span class=\"o\">!!</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"></span>\n\n<span class=\"nf\">pushProof</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">LocalContext</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Proof</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">LocalContext</span><span class=\"w\"></span>\n<span class=\"nf\">pushProof</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ts</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fs</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ts</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fs</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">++</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">p</span><span class=\"p\">])</span><span class=\"w\"></span>\n<span class=\"nf\">getProof</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">LocalContext</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Proof</span><span class=\"w\"></span>\n<span class=\"nf\">getProof</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kr\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fs</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">fs</span><span class=\"w\"> </span><span class=\"o\">!!</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"></span>\n\n<span class=\"nf\">checkStep</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">LocalContext</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Step</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">LocalContext</span><span class=\"w\"></span>\n<span class=\"nf\">checkStep</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">IsVar</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">pushTerm</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Var</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"nf\">checkStep</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">IsImp</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">pushFormula</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Imp</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">getFormula</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">getFormula</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"nf\">checkStep</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">MP</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"kt\">Proof</span><span class=\"w\"> </span><span class=\"n\">p'</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">getProof</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"kr\">in</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"kt\">Proof</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Imp</span><span class=\"w\"> </span><span class=\"n\">p''</span><span class=\"w\"> </span><span class=\"n\">q'</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">getProof</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"kr\">in</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">p'</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">p''</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">q'</span><span class=\"w\"> </span><span class=\"kr\">then</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">pushProof</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Proof</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">else</span><span class=\"w\"> </span><span class=\"ne\">error</span><span class=\"w\"> </span><span class=\"s\">\"MP\"</span><span class=\"w\"></span>\n\n<span class=\"nf\">checkSteps</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">Step</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Proof</span><span class=\"w\"></span>\n<span class=\"nf\">checkSteps</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">[]</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">[]</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">[]</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kr\">where</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kr\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kt\">[]</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">last</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"kt\">:</span><span class=\"n\">ss</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">checkStep</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 269901727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643506733
    },
    {
        "content": "<p>Very cool! Thank you!<br>\nWould I also need steps for adding term scheme variables, and formula scheme variables?</p>",
        "id": 269902373,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643507477
    },
    {
        "content": "<p>And an example use (imagine that <code>Prop_1</code> and <code>Prop_2</code> are defined similarly):</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"nf\">ex_1</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">checkSteps</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">IsPred</span><span class=\"w\"> </span><span class=\"s\">\"P\"</span><span class=\"w\"> </span><span class=\"kt\">[]</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">-- f0 = p</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">IsImp</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">-- f1 = p -&gt; p</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">IsImp</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">-- f2 = (p -&gt; p) -&gt; p</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">IsImp</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">-- f3 = p -&gt; ((p -&gt; p) -&gt; p)</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">IsImp</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">-- f4 = p -&gt; (p -&gt; p)</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">IsImp</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">-- f5 = (p -&gt; (p -&gt; p)) -&gt; (p -&gt; p)</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">IsImp</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">-- f6 = (p -&gt; ((p -&gt; p) -&gt; p)) -&gt; ((p -&gt; (p -&gt; p)) -&gt; (p -&gt; p))</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">Prop_2</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">-- p0 = |- (p -&gt; ((p -&gt; p) -&gt; p)) -&gt; ((p -&gt; (p -&gt; p)) -&gt; (p -&gt; p))</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">Prop_1</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">-- p1 = |- p -&gt; ((p -&gt; p) -&gt; p)</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">MP</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">-- p2 = |- (p -&gt; (p -&gt; p)) -&gt; (p -&gt; p)</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">Prop_1</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">-- p3 = |- p -&gt; (p -&gt; p)</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">MP</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">-- p4 = |- p -&gt; p</span><span class=\"w\"></span>\n<span class=\"p\">]</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Probably you want to assert that this is a proof of <code>p -&gt; p</code> at the end</p>",
        "id": 269902374,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643507477
    },
    {
        "content": "<p>You already have term and formula variables via the <code>Pred</code> and <code>Var</code> constructors</p>",
        "id": 269902448,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643507552
    },
    {
        "content": "<p>you just need a mechanism to substitute into them</p>",
        "id": 269902454,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643507568
    },
    {
        "content": "<p>I see. That mechanism being two more <code>Step</code> constructors?</p>",
        "id": 269902540,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643507682
    },
    {
        "content": "<p>Something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">Term</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Var</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">deriving</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Eq</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Imp</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">deriving</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Eq</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">Proof</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Proof</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n\n<span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">Step</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">IsVar</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">IsImp</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">ApplyThm</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">M</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">M</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"p\">([</span><span class=\"kt\">String</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">Int</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">deriving</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Show</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Eq</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n<span class=\"kr\">type</span><span class=\"w\"> </span><span class=\"kt\">LocalContext</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">([</span><span class=\"kt\">Term</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">Formula</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">Proof</span><span class=\"p\">])</span><span class=\"w\"></span>\n<span class=\"kr\">type</span><span class=\"w\"> </span><span class=\"kt\">GlobalContext</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">M</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"p\">([</span><span class=\"kt\">Proof</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"kt\">Proof</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n<span class=\"nf\">substTerm</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">M</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Term</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Term</span><span class=\"w\"></span>\n<span class=\"nf\">substTerm</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"kr\">where</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Var</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"w\"> </span><span class=\"kt\">M</span><span class=\"o\">.!</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"></span>\n\n<span class=\"nf\">substFormula</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">LocalContext</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">M</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">M</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"p\">([</span><span class=\"kt\">String</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n<span class=\"nf\">substFormula</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"w\"> </span><span class=\"n\">fs</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"kr\">where</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Imp</span><span class=\"w\"> </span><span class=\"n\">f1</span><span class=\"w\"> </span><span class=\"n\">f2</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Imp</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">f1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">f2</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Pred</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">vs</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">fs</span><span class=\"w\"> </span><span class=\"kt\">M</span><span class=\"o\">.!</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"kr\">in</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"n\">args'</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"kr\">in</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"n\">args'</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"n\">vs</span><span class=\"w\"> </span><span class=\"kr\">then</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">substFormula</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">M</span><span class=\"o\">.</span><span class=\"n\">fromList</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">zip</span><span class=\"w\"> </span><span class=\"n\">vs</span><span class=\"w\"> </span><span class=\"n\">args'</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"kt\">[]</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">getFormula</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kr\">else</span><span class=\"w\"> </span><span class=\"ne\">error</span><span class=\"w\"> </span><span class=\"s\">\"subst\"</span><span class=\"w\"></span>\n\n<span class=\"nf\">substProof</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">LocalContext</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">M</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">M</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"p\">([</span><span class=\"kt\">String</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Proof</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Proof</span><span class=\"w\"></span>\n<span class=\"nf\">substProof</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"w\"> </span><span class=\"n\">fs</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Proof</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Proof</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">substFormula</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"w\"> </span><span class=\"n\">fs</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n<span class=\"nf\">checkStep</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">GlobalContext</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">LocalContext</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Step</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">LocalContext</span><span class=\"w\"></span>\n<span class=\"nf\">checkStep</span><span class=\"w\"> </span><span class=\"n\">gctx</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">ApplyThm</span><span class=\"w\"> </span><span class=\"n\">th</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"w\"> </span><span class=\"n\">fs</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">hs</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">concl</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">gctx</span><span class=\"w\"> </span><span class=\"kt\">M</span><span class=\"o\">.!</span><span class=\"w\"> </span><span class=\"n\">th</span><span class=\"w\"> </span><span class=\"kr\">in</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"n\">hs'</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">substProof</span><span class=\"w\"> </span><span class=\"n\">lctx</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"w\"> </span><span class=\"n\">fs</span><span class=\"w\"> </span><span class=\"o\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"kr\">in</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"n\">concl'</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">substProof</span><span class=\"w\"> </span><span class=\"n\">lctx</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"w\"> </span><span class=\"n\">fs</span><span class=\"w\"> </span><span class=\"n\">concl</span><span class=\"w\"> </span><span class=\"kr\">in</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"n\">hs'</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nf\">\\</span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"kt\">Proof</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"o\">!!</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"kr\">in</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">zip</span><span class=\"w\"> </span><span class=\"n\">hs'</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">then</span><span class=\"w\"> </span><span class=\"n\">pushProof</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"n\">concl'</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">else</span><span class=\"w\"> </span><span class=\"ne\">error</span><span class=\"w\"> </span><span class=\"s\">\"ApplyThm\"</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 269903509,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643508844
    },
    {
        "content": "<p>Notice that you can eliminate <code>Prop_1</code> and <code>MP</code> constructors from <code>Step</code> with this, by pre-seeding the <code>GlobalContext</code> with</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"nf\">initialContext</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">M</span><span class=\"o\">.</span><span class=\"n\">fromList</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">(</span><span class=\"s\">\"MP\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Proof</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">Pred</span><span class=\"w\"> </span><span class=\"s\">\"P\"</span><span class=\"w\"> </span><span class=\"kt\">[]</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Imp</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Pred</span><span class=\"w\"> </span><span class=\"s\">\"P\"</span><span class=\"w\"> </span><span class=\"kt\">[]</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Pred</span><span class=\"w\"> </span><span class=\"s\">\"Q\"</span><span class=\"w\"> </span><span class=\"kt\">[]</span><span class=\"p\">)],</span><span class=\"w\"> </span><span class=\"kt\">Pred</span><span class=\"w\"> </span><span class=\"s\">\"Q\"</span><span class=\"w\"> </span><span class=\"kt\">[]</span><span class=\"p\">)),</span><span class=\"w\"></span>\n<span class=\"w\"> </span><span class=\"o\">...</span><span class=\"w\"></span>\n<span class=\"p\">]</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 269903636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643509038
    },
    {
        "content": "<p>Sorry, what do the constructor arguments to <code>ApplyThm</code> represent? The name of a theorem, and ?</p>",
        "id": 269904201,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643509797
    },
    {
        "content": "<p>The name of the theorem, the substitutions for term variables, the substitutions for predicate variables, and the list of hypotheses</p>",
        "id": 269904622,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643510367
    },
    {
        "content": "<p>Since you aren't tracking what variables appear in a theorem or ordering them when they go into the global context, these have to be given as maps from string. For predicate variables, the substitution is basically a lambda, since we might want to substitute for a predicate variable which has nonzero arity, and we need a secondary <code>substFormula</code> call to substitute into the lambda</p>",
        "id": 269904785,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643510537
    },
    {
        "content": "<p>In the substitutions for predicate variables <code>M.Map String ([String], Int)</code> the first string is the name of a predicate being substituted into, and sorry, what are the list of strings and int? The names of the variables in the predicate to substitute in for? The arity?</p>",
        "id": 269905202,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643511059
    },
    {
        "content": "<p>I'm guessing we need to check for accidental variable binding in all of these substitutions if this gets extended to predicate calculus?</p>",
        "id": 269905666,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643511606
    },
    {
        "content": "<p>I'm wondering if there is a missing call to <code>substTerm</code> or if it is implicit somewhere?</p>",
        "id": 269905806,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643511837
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269905202\">said</a>:</p>\n<blockquote>\n<p>In the substitutions for predicate variables <code>M.Map String ([String], Int)</code> the first string is the name of a predicate being substituted into, and sorry, what are the list of strings and int? The names of the variables in the predicate to substitute in for? The arity?</p>\n</blockquote>\n<p>The list of strings are the lambda binders, and the int is a previously constructed formula from the local context. For example we might set <code>P := \\x y z -&gt; x + y = z</code></p>",
        "id": 269906025,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643512091
    },
    {
        "content": "<p>and then we would turn an occurrence like <code>P(1, 2, 3)</code> into <code>1 + 2 = 3</code></p>",
        "id": 269906051,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643512161
    },
    {
        "content": "<p><code>substTerm</code> doesn't appear in the constructors I've shown, but it would appear in the <code>Pred</code> case, for example</p>",
        "id": 269906127,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643512230
    },
    {
        "content": "<p>er... I guess I did that one</p>",
        "id": 269906143,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643512260
    },
    {
        "content": "<p>yeah this probably doesn't typecheck, we should be using <code>let args' = substTerm ts &lt;$&gt; args</code> instead of <code>let args' = go &lt;$&gt; args</code></p>",
        "id": 269906166,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643512320
    },
    {
        "content": "<p>I'll have to think more about what substituting for a predicate name means. I can see when the arity is zero, that it is just replacing it by a formula, like in the axiom schemes, but I'm not sure what it means when the arity is greater than zero.<br>\nI have a prior engagement to attend to, but thank you so much. This is really cool!</p>",
        "id": 269906542,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643512817
    },
    {
        "content": "<p>So if you have a predicate such as such as <code>Pred \"P\" []</code> in the proof scheme that you are substituting into,  then you can replace it with any formula with no free variables right? What can you do when you have something like  <code>Pred \"P\" [Func \"f\" [Var \"x\"], Var \"y\"]</code>? Replace it with any formula that has the same number of free variables?</p>",
        "id": 269910626,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643518778
    },
    {
        "content": "<p>Or no, maybe just replace each free variable with any term?</p>",
        "id": 269910870,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643518941
    },
    {
        "content": "<p>No, you can replace it with formulas with free variables, the variables just have to not get captured so there is some \"free for t in x\" side condition</p>",
        "id": 269912987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643521879
    },
    {
        "content": "<p>I haven't thought about the details but if you draw examples of the bad case it shouldn't be too hard to figure out</p>",
        "id": 269913010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643521921
    },
    {
        "content": "<p>You could replace <code>x = y</code> with <code>x &lt; y</code>?</p>",
        "id": 269913077,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643522024
    },
    {
        "content": "<p>Oh, or where you talking about the first sentence.</p>",
        "id": 269913143,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643522088
    },
    {
        "content": "<p>For example, replacing <code>forall x, P(x, y)</code> with <code>P(z, w) := x &lt; z</code> is bad because <code>x</code> will get captured</p>",
        "id": 269913271,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643522283
    },
    {
        "content": "<p>So you can replace any predicate of arity 0 with any formula, given the side conditions on name capture? What can you do for arity &gt; 0?</p>",
        "id": 269913301,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643522379
    },
    {
        "content": "<p>that example is a predicate of arity 2</p>",
        "id": 269913306,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643522392
    },
    {
        "content": "<p>Metamath has the ability to manually rename binders because they are subject to substitution. If you are treating them as binders, then you probably want to just alpha-rename the binder automatically instead of restricting the substitution</p>",
        "id": 269913452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643522505
    },
    {
        "content": "<p>so that example would result in <code>forall x', x &lt; x'</code></p>",
        "id": 269913510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643522572
    },
    {
        "content": "<p>I'm sorry, I got a little lost. I guess I am just trying to understand what can be substituted in for a predicate of arity 0 (a propositional variable) and what can be substituted in for a predicate of arity &gt; 0.</p>",
        "id": 269913734,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643522962
    },
    {
        "content": "<p>For the arity 0 special case, you can substitute any formula expression whose free variables are not bound in the context where the variable appears. So in <code>P -&gt; forall x. P</code>, you can substitute any expression for <code>P</code> not containing a free <code>x</code></p>",
        "id": 269913796,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643523041
    },
    {
        "content": "<p>or in the alpha-renaming version, you can substitute any expression for <code>P</code>, but if <code>P</code> contains a free <code>x</code> then the <code>x</code> binder will be renamed to <code>x'</code> or something else not free in <code>P</code></p>",
        "id": 269913822,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643523091
    },
    {
        "content": "<p>In the second sentence are you still talking about the special case of arity = 0? Because then P wouldn't have a free x right?</p>",
        "id": 269913956,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643523271
    },
    {
        "content": "<p>I am</p>",
        "id": 269913967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643523301
    },
    {
        "content": "<p>In the second version we lift the restriction on <code>P</code>, so you can put anything in for it</p>",
        "id": 269913977,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643523319
    },
    {
        "content": "<p>instead of restricting the substitution, we sometimes rename the binder to avoid clashes</p>",
        "id": 269913986,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643523347
    },
    {
        "content": "<p>in the first version we just reject if we would otherwise have to rename a binder</p>",
        "id": 269914007,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643523365
    },
    {
        "content": "<p>I don't understand how P can have arity = 0 and have a free x. Wouldn't it have at least an arity of 1?</p>",
        "id": 269914013,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643523384
    },
    {
        "content": "<p>for example <code>P := 0 &lt; x</code></p>",
        "id": 269914020,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643523395
    },
    {
        "content": "<p>The arity of <code>P</code> is determined by its use in the original theorem, here <code>P -&gt; forall x. P</code></p>",
        "id": 269914036,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643523429
    },
    {
        "content": "<p>we're allowed to use an expression with free variables</p>",
        "id": 269914044,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643523447
    },
    {
        "content": "<p>we might want to derive <code>0 &lt; x -&gt; forall x'. 0 &lt; x</code> here</p>",
        "id": 269914049,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643523473
    },
    {
        "content": "<p>We would use a nonzero arity when the theorem in question uses the predicate at multiple values, for example <code>forall x. P(x) -&gt; P(t)</code></p>",
        "id": 269914107,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643523536
    },
    {
        "content": "<p>In this case, <code>P(y) := 0 &lt; x</code> would require renaming the binder (and results in <code>forall x'. 0 &lt; x -&gt; 0 &lt; x</code>), but <code>P(x) := 0 &lt; x</code> is okay and does not rename the binder, resulting in <code>forall x. 0 &lt; x -&gt; 0 &lt; t</code>. This is how you get deliberately captured variables</p>",
        "id": 269914182,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643523640
    },
    {
        "content": "<p>Wait, so what does P(x) mean? Is it the same as Pred \"P\" [Var \"x\"]?</p>",
        "id": 269914392,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643523912
    },
    {
        "content": "<p>It seems not? The \"x\" in P(x) is some kind of binder?</p>",
        "id": 269914523,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643524097
    },
    {
        "content": "<p>In formulas, <code>P(t)</code> refers to <code>Pred \"P\" [t]</code> (where <code>t</code> is any term). When I write <code>P(x) := e</code>, I mean that the substitution map contains <code>\"P\" -&gt; ([\"x\"], e)</code></p>",
        "id": 269914554,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643524171
    },
    {
        "content": "<p>well, technically <code>\"P\" -&gt; ([\"x\"], i)</code> where <code>getFormula ctx i = e</code></p>",
        "id": 269914637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643524286
    },
    {
        "content": "<p><code>\"P\" -&gt; ([\"x\"], e)</code> means we are replacing the variable <code>x</code> by <code>e</code> in <code>P</code>?</p>",
        "id": 269914784,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643524506
    },
    {
        "content": "<p>Sorry, maybe it is easier to talk about outside of the code, which I am still trying to understand.</p>",
        "id": 269914815,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643524562
    },
    {
        "content": "<p>It means we are replacing <code>P(x)</code> by <code>e</code>, and more generally <code>P(t)</code> by <code>e[t/x]</code></p>",
        "id": 269914862,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643524614
    },
    {
        "content": "<p>perhaps you should study the code and come back with more pointed questions. (I don't guarantee the code is correct - I wrote it without actually compiling it so there are probably several errors)</p>",
        "id": 269914958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643524761
    },
    {
        "content": "<p>Ok, sorry. I'll see if I can put together what I think it would look like for just the propositional calculus, and then see what needs to change to extend it to the predicate calculus, if that makes sense?</p>",
        "id": 269915027,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643524846
    },
    {
        "content": "<p>Thank you.</p>",
        "id": 269915085,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643524926
    },
    {
        "content": "<p>Probably not tonight though. Have a good evening, or day depending on your time zone.</p>",
        "id": 269915114,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643525034
    },
    {
        "content": "<p>Does this look correct for the propositional calculus case? Do the comments reflect a correct understanding? Thank you.<br>\n<a href=\"/user_uploads/3121/aojQ7h71kfhMZm_ZuH5y40IT/Hilbert_Prop.hs\">Hilbert_Prop.hs</a></p>",
        "id": 269979126,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643603770
    },
    {
        "content": "<p>Sorry, the comment for <code>GlobalContext</code> should be changed to</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"cm\">{-</span>\n<span class=\"cm\">Monotonic.</span>\n<span class=\"cm\">A mapping of names to previously checked derivations.</span>\n<span class=\"cm\">name -&gt; (ps, p) :</span>\n<span class=\"cm\">name : The name of a previously checked derivation.</span>\n<span class=\"cm\">ps : The list of proof schemes in the previously checked derivation.</span>\n<span class=\"cm\">p : The last proof scheme in the previously checked derivation.</span>\n<span class=\"cm\">-}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><a href=\"/user_uploads/3121/CHlN-psLnsx8fqV4LkSH0knY/Hilbert_Prop.hs\">Hilbert_Prop.hs</a></p>",
        "id": 269979230,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643603934
    },
    {
        "content": "<p>It looks good. The guard <code>(Data.Map.keysSet m) == (allVar p)</code> is overly strict, it suffices to use <code>(allVar p) `subset` (Data.Map.keysSet m)</code>. Also it's possible to combine the guard and the substitution into one operation that replaces each free occurrence of a variable in <code>p</code> with the corresponding element of <code>m</code> (which will fail if it's not in the map)</p>",
        "id": 269980076,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643604872
    },
    {
        "content": "<p>So you don't have to replace every free variable in the formula scheme? I was wondering about that.</p>",
        "id": 269980183,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643605038
    },
    {
        "content": "<p>Or I guess I read that backwards. You do have to?</p>",
        "id": 269980245,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643605100
    },
    {
        "content": "<p>Did you mean <code>(Data.Map.keysSet m) `subset` (allVar p)</code>?</p>",
        "id": 269980276,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643605193
    },
    {
        "content": "<p>Nevermind, I think I see. You can have a mapping that has keys that do not appear in the formula but not vice versa. You do have to replace every free variable in the formula. I think?</p>",
        "id": 269980722,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643605680
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 269981181,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643606165
    },
    {
        "content": "<p>Like this?<br>\n<a href=\"/user_uploads/3121/rBwFaaLyk1CGpI2JdagkQ-ty/Hilbert_Prop.hs\">Hilbert_Prop.hs</a></p>",
        "id": 269983035,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643608305
    },
    {
        "content": "<p>Out of curiosity, what is the advantage to storing the intermediate proof schemes in the global context at the end of a derivation instead of just the last proof scheme in the derivation?</p>",
        "id": 270140166,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643681362
    },
    {
        "content": "<p>I don't think I ever suggested that?</p>",
        "id": 270140676,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643681800
    },
    {
        "content": "<p>There are some advantages of being able to build multiple proof schemes out of one \"derivation pool\" / local context, but they are quite niche</p>",
        "id": 270140747,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643681882
    },
    {
        "content": "<p>I think it was in your example code maybe? <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269903509\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269903509</a></p>",
        "id": 270140965,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643682031
    },
    {
        "content": "<p>that example doesn't have the <code>checkSteps</code> function. The one <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269901727\">earlier</a> does and it uses <code>last ps</code></p>",
        "id": 270141102,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643682133
    },
    {
        "content": "<p>I see. I must have mixed together the code. Thank you.</p>",
        "id": 270141214,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643682242
    },
    {
        "content": "<p>If I move the last code example that I posted from propositional logic to predicate logic, do I understand correctly that applying a theorem will  then require replacing each free term variable with a syntactically correct term scheme, taking into account potential free variable capture, in addition to the replacement of propositional variables (predicate variables of arity 0) that is already done in the current propositional case?</p>",
        "id": 270142115,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643682971
    },
    {
        "content": "<p>yes</p>",
        "id": 270169793,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643704890
    },
    {
        "content": "<p>Thank you.</p>",
        "id": 270325848,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643770387
    },
    {
        "content": "<p>Is it correct that metamath and mm0 use named variables? If so, how is free variable capture handled? Is there a step that allows the user to explicitly alpha convert a formula scheme?</p>",
        "id": 270326024,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643770533
    },
    {
        "content": "<p>Yes, they use named variables. You can use theorems to prove alpha conversion, there is no built in support for it</p>",
        "id": 270326546,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643770936
    },
    {
        "content": "<p>I did not realize that was possible. What do you need to prove it, just FOL?</p>",
        "id": 270326720,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643771112
    },
    {
        "content": "<p>It uses lemmas like <a href=\"http://us.metamath.org/mpeuni/cbvalv.html\">http://us.metamath.org/mpeuni/cbvalv.html</a></p>",
        "id": 270327482,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643771762
    },
    {
        "content": "<p>which follow from the FOL axiomatization</p>",
        "id": 270327531,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643771780
    },
    {
        "content": "<p>Interesting. Is that due specifically to the axiomatization used by metamath that avoids substitution, or is that true generally?</p>",
        "id": 270327966,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643772227
    },
    {
        "content": "<p>I guess I just expected that would have to be proved at the meta level.</p>",
        "id": 270328054,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643772280
    },
    {
        "content": "<p>I don't think it's something special about the axiomatization: I mean it's a true theorem of FOL so as long as the axiomatization is something complete for FOL then that theorem should be provable</p>",
        "id": 270328150,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643772368
    },
    {
        "content": "<p>The interesting observation is that it suffices to use theorems like that in lieu of built in alpha renaming</p>",
        "id": 270328180,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643772418
    },
    {
        "content": "<p>That is cool.</p>",
        "id": 270328201,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643772454
    },
    {
        "content": "<p>Same thing for the \"not-free\" predicate, which in metamath is a regular predicate defined as <code>NF(x, ph) := (∃ x, ph) → (∀ x, ph)</code></p>",
        "id": 270328218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643772478
    },
    {
        "content": "<p>you can use <code>NF(x, ph)</code> as a substitute for actual not-free constraints in lemmas that require it</p>",
        "id": 270328289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643772528
    },
    {
        "content": "<p>This is not the usual not-free predicate defined in the metalogic, because for example <code>NF(x, x = x)</code> holds, but it is \"just as good\" from the point of view of provable theorems</p>",
        "id": 270328325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643772585
    },
    {
        "content": "<p>and there are lemmas that prove <code>NF(x, ∀ x, ph)</code> and <code>NF(y, ph) -&gt; NF(y, ∀ x, ph)</code> and so on, so whenever a variable is not-free in an expression for an interesting reason (not just because it is not present in the expression), you can prove an <code>NF</code> lemma and then use a pred calc theorem that has an <code>NF</code> assumption</p>",
        "id": 270328503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643772761
    },
    {
        "content": "<p>Cool.</p>",
        "id": 270328668,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643772953
    },
    {
        "content": "<p>So there are predicate calculus theorems that have the meta logic NF as a condition? How does that work without being able to do this? Wouldn't they have to jump to the level of meta theorems?</p>",
        "id": 270328938,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643773163
    },
    {
        "content": "<p>Or are they in fact considered as meta theorems, and this allows you to move them down.</p>",
        "id": 270329063,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643773281
    },
    {
        "content": "<p>No, there are predicate calculus theorems that have the object logic NF as a condition</p>",
        "id": 270329233,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643773435
    },
    {
        "content": "<p>that is, the <code>NF(x, ph)</code> function I just mentioned</p>",
        "id": 270329278,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643773450
    },
    {
        "content": "<p>for example <code>NF(x, ph) -&gt; ph -&gt; ∀ x, ph</code> is pretty easy to prove</p>",
        "id": 270329306,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643773487
    },
    {
        "content": "<p>or <code>NF(x, ph), ph -&gt; ps |- ph -&gt; ∀ x, ps</code></p>",
        "id": 270329379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643773524
    },
    {
        "content": "<p>But there are also predicate calculus theorems that have the meta logic NF as a condition?</p>",
        "id": 270329610,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643773701
    },
    {
        "content": "<p>no, at least not in metamath. Theorems that would normally have an NF condition in FOL come in two flavors in metamath: either they have a disjointness requirement (not-present rather than not-free), or they have a <code>NF</code> condition. Not-present is stricter than not-free but is handled by metamath natively so it is easy to use, while <code>NF</code> is weaker than not-free and requires a subproof</p>",
        "id": 270329952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643774043
    },
    {
        "content": "<p>I guess I meant in textbooks.</p>",
        "id": 270329998,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643774116
    },
    {
        "content": "<p>I thought maybe that is what you meant by \"you can use NF(x, ph) as a substitute for actual not-free constraints in lemmas that require it\".</p>",
        "id": 270330081,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643774185
    },
    {
        "content": "<p>That there are lemmas in textbooks that use the meta logic (actual) version of it.</p>",
        "id": 270330094,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643774208
    },
    {
        "content": "<p>Right. You take the textbook lemma, using the metalevel not-free constraint, and replace all instances of it with <code>NF(x, ph)</code></p>",
        "id": 270330193,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643774296
    },
    {
        "content": "<p>and that gives you a theorem that can be stated and proved in metamath</p>",
        "id": 270330203,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643774309
    },
    {
        "content": "<p>Do the textbooks identify these as meta lemmas when they state them?</p>",
        "id": 270330379,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643774384
    },
    {
        "content": "<p>In the textbooks these are all theorem schemes, since they usually have wff metavariables in them</p>",
        "id": 270330492,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643774422
    },
    {
        "content": "<p>What is proved in metamath are theorem schemes too aren't they?</p>",
        "id": 270330714,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643774572
    },
    {
        "content": "<p>Yes, but the scheme language is more restricted, to just substitution and distinctness</p>",
        "id": 270330860,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643774666
    },
    {
        "content": "<p>anything beyond that has to be implemented inside the target language itself</p>",
        "id": 270330897,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643774714
    },
    {
        "content": "<p>So meta, but not as meta? :)</p>",
        "id": 270331015,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643774824
    },
    {
        "content": "<p>the scheme language in FOL is not rigidly defined, in principle you can do whatever you like by recursion on formulas, but generally includes at least not-free, proper substitution, alpha equality, and possibly the 3-ary not-free operation \"y is free for x in t\"</p>",
        "id": 270331131,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643774908
    },
    {
        "content": "<p>For a more interesting example of an operation defined by recursion on formulas consider the <a href=\"https://en.wikipedia.org/wiki/Double-negation_translation#First-order_logic\">double negation translation</a></p>",
        "id": 270331250,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643775007
    },
    {
        "content": "<p>And everything that holds true at the object level using the usual axiom schemes holds true using metamath's restricted axiom schemes and vice versa?</p>",
        "id": 270331751,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643775581
    },
    {
        "content": "<p>yes</p>",
        "id": 270331844,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643775675
    },
    {
        "content": "<p>That's pretty cool. I would be interested in the proof, although I'm not sure I would be able to understand it.</p>",
        "id": 270331934,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643775756
    },
    {
        "content": "<p>That's different than saying that the axiom schemes from one can be derived from the other and vice versa right?</p>",
        "id": 270332082,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643775877
    },
    {
        "content": "<p>Because they are different at the meta level, so that wouldn't make sense.</p>",
        "id": 270332209,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643775992
    },
    {
        "content": "<p>The axiom schemes of metamath should be true interpreted as FOL schemes, this is just soundness restated. The reverse doesn't work because unrestricted FOL schemes can't necessarily be expressed in metamath</p>",
        "id": 270332355,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643776130
    },
    {
        "content": "<p>I see. Is that reverse direction at the same meta level and same idea as the deduction theorem showing that Hilbert and ND are equivalent?</p>",
        "id": 270332469,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643776251
    },
    {
        "content": "<p>Some FOL schemes are mapped to metamath metatheorems, which is to say that each instance of the scheme corresponds to a metamath theorem</p>",
        "id": 270332499,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643776293
    },
    {
        "content": "<p>the deduction theorem is one of these</p>",
        "id": 270332564,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643776331
    },
    {
        "content": "<p>This gets confusing.</p>",
        "id": 270333043,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643776787
    },
    {
        "content": "<p>So FOL schemes and metamath meta theorems are at the same level? How do you keep this all straight :)</p>",
        "id": 270333567,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643777269
    },
    {
        "content": "<p>Is everything eventually embedded into a single higher level metalogic?</p>",
        "id": 270333686,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643777363
    },
    {
        "content": "<p>That is, there is a single metalogic that can describe both FOL schemes and metamath metatheorems?</p>",
        "id": 270333864,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643777518
    },
    {
        "content": "<p>I think you shouldn't 'align' the levels of metamath and textbook FOL, that just gets confusing.</p>",
        "id": 270334796,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1643778172
    },
    {
        "content": "<p>They don't align? Don't they have to at some level in order to show that they are equivalent at the object level?</p>",
        "id": 270334964,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643778338
    },
    {
        "content": "<p>Or at least doesn't there have to be a single meta logic that can describe them both?</p>",
        "id": 270335027,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643778368
    },
    {
        "content": "<p>Metamath, like any formal system, has built in limits on what it can do natively. By contrast, mathematicians always dislike such restrictions and will \"go meta\" whenever they feel the need to. So the best you can hope for is to carve out a well defined subset of what mathematicians/logicians are doing and call it a formal system</p>",
        "id": 270335236,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643778543
    },
    {
        "content": "<p>You can think of metamath like a traditional logic textbook written by someone who wanted to demonstrate that you can do FOL without defining not-free</p>",
        "id": 270335539,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643778729
    },
    {
        "content": "<p>I guess that makes sense. They would still want to show that they are doing the same FOL though right?</p>",
        "id": 270335856,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643779031
    },
    {
        "content": "<p>Hence the proofs that they are equivalent at the object level.</p>",
        "id": 270335874,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643779070
    },
    {
        "content": "<p>well, most logic textbooks aren't too concerned with showing that they are equivalent to some other logic textbook. More important is that all the obviously true things can be derived</p>",
        "id": 270335960,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643779131
    },
    {
        "content": "<p>I suppose that is true. I guess it would be easier if the axioms were more intuitive or obvious, which could also probably be said for the Hilbert axioms.</p>",
        "id": 270336118,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643779275
    },
    {
        "content": "<p>I guess if you can show that they are complete and the definition of complete makes sense.</p>",
        "id": 270336257,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643779399
    },
    {
        "content": "<p>Kind of an aside, but there is something that has always bothered me regarding meta logic. If I use a meta logic to prove that a logic is consistent (can not prove false and hence anything), how do I know that the meta logic I used is consistent? What if it is not, and I only proved that the logic is consistent because I can prove anything with the meta logic? Then don't I need a meta meta logic to prove that the meta logic is consistent and so on?</p>",
        "id": 270336986,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643780060
    },
    {
        "content": "<p>sure that's true</p>",
        "id": 270337006,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643780097
    },
    {
        "content": "<p>you can't really avoid that</p>",
        "id": 270337015,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643780104
    },
    {
        "content": "<p>Any system of axioms comes with baseline assumptions. Without axioms you can't prove anything</p>",
        "id": 270337114,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643780196
    },
    {
        "content": "<p>the best you can do is make sure the axioms are \"obviously correct\"</p>",
        "id": 270337143,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643780231
    },
    {
        "content": "<p>or you can try not to engage with the question and use an off-the-shelf axiom system</p>",
        "id": 270337223,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643780300
    },
    {
        "content": "<p>I see. Do the meta logics become increasingly simpler and more \"obviously correct\" the \"higher\" you go?</p>",
        "id": 270337250,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643780330
    },
    {
        "content": "<p>they need not, it's up to you</p>",
        "id": 270337283,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643780374
    },
    {
        "content": "<p>From what I have seen of the first level it appears to be about the same as the logic it is describing.</p>",
        "id": 270337289,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643780383
    },
    {
        "content": "<p>but it is usually possible to have a PA-ish metalogic supporting an arbitrarily complicated object logic</p>",
        "id": 270337299,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643780401
    },
    {
        "content": "<p>What does \"PA-ish\" mean?</p>",
        "id": 270337368,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643780437
    },
    {
        "content": "<p>either peano arithmetic or a variation/subsystem of it</p>",
        "id": 270337386,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643780454
    },
    {
        "content": "<p>like EFA (exponential function arithmetic) or PRA (primitive recursive arithmetic)</p>",
        "id": 270337414,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643780483
    },
    {
        "content": "<p>if you try to make the system too weak it won't be able to support Godel's theorems</p>",
        "id": 270337469,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643780522
    },
    {
        "content": "<p>The incompleteness theorems?</p>",
        "id": 270337684,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643780717
    },
    {
        "content": "<p>yes</p>",
        "id": 270337701,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643780754
    },
    {
        "content": "<p>You can run the argument with <a href=\"https://en.wikipedia.org/wiki/Robinson_arithmetic\">Robinson's Q</a>, but since that system doesn't have induction, you need to do meta-induction to reason about it which means you have to step up another level</p>",
        "id": 270337789,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643780849
    },
    {
        "content": "<p>The argument that it is \"obviously correct\"?</p>",
        "id": 270338057,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643781115
    },
    {
        "content": "<p>it's pretty hard to argue that PA is not obviously correct</p>",
        "id": 270338135,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643781175
    },
    {
        "content": "<p>you have to have a strange idea of what numbers are to be able to contemplate the inconsistency of PA</p>",
        "id": 270338180,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643781212
    },
    {
        "content": "<p>I'm not sure what you meant about run the argument with Robinson's Q. Which argument?</p>",
        "id": 270338278,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643781281
    },
    {
        "content": "<p>And why do you want to be able to support Godel's theorems?</p>",
        "id": 270338331,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643781333
    },
    {
        "content": "<p>the argument for Godel's incompleteness theorem, which involves constructing a provability assertion inside the weak metalogic</p>",
        "id": 270338881,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643781612
    },
    {
        "content": "<p>The systems that can prove Godel's theorems are \"essentially undecidable\", which is a good thing. Below that, you mostly have theories that are decidable, meaning that they can't model any interesting mathematics</p>",
        "id": 270338994,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643781708
    },
    {
        "content": "<p>That is, a decidable theory can't be a metalogic for an undecidable theory because any question in the object logic can be reformulated as a question in the metalogic</p>",
        "id": 270339069,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643781761
    },
    {
        "content": "<p>and since ultimately we want to do mathematics in interesting and undecidable domains, this forms a bare minimum requirement on the metalogic</p>",
        "id": 270339093,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643781798
    },
    {
        "content": "<p>Although I should give an honorable mention to <a href=\"https://en.wikipedia.org/wiki/Self-verifying_theories\">self-verifying theories</a>, which live somewhere below Q (usually by not validating the totality of multiplication) and satisfying <code>T |- Con(T)</code></p>",
        "id": 270339284,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643781971
    },
    {
        "content": "<p>That makes sense.</p>",
        "id": 270339562,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643782241
    },
    {
        "content": "<p>Although proving their own consistency sounds like a circular argument?</p>",
        "id": 270339567,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643782251
    },
    {
        "content": "<p>It's not circular, since consistency of <code>T</code> is not a precondition of the proof</p>",
        "id": 270339612,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643782319
    },
    {
        "content": "<p>in fact if <code>T</code> was inconsistent then <code>T |- Con(T)</code> would hold trivially</p>",
        "id": 270339666,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643782340
    },
    {
        "content": "<p>Of course the interesting thing about self-verifying theories is that they are <em>in fact</em> consistent in addition to being able to prove they are consistent inside themselves</p>",
        "id": 270339683,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643782376
    },
    {
        "content": "<p>What does \"in fact consistent\" mean?</p>",
        "id": 270339775,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643782475
    },
    {
        "content": "<p>in the case of Willard's axiom systems this is usually ensured by having the theory be a subsystem of PA</p>",
        "id": 270339807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643782518
    },
    {
        "content": "<p>Why does that mean \"in fact\"?</p>",
        "id": 270339877,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643782573
    },
    {
        "content": "<p>What I mean is, it's consistent from an \"external viewpoint\", not merely in <code>T</code>'s opinion</p>",
        "id": 270339900,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643782608
    },
    {
        "content": "<p>since, as mentioned, if <code>T</code> was inconsistent it would prove its own consistency</p>",
        "id": 270339919,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643782639
    },
    {
        "content": "<p>this is the \"uninteresting case\" of self-verification</p>",
        "id": 270339926,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643782653
    },
    {
        "content": "<p>Of course you can question the consistency of any theory, including PA, but you have to throw out the vast majority of mathematics in the world to take that position. I can prove <code>Con(PA)</code> in lean with <code>no axioms</code></p>",
        "id": 270340143,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643782841
    },
    {
        "content": "<p>You mean just from type theory?</p>",
        "id": 270340398,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643783072
    },
    {
        "content": "<p>So are you basically using a sort of induction with the proof within T that T is consistent? That is, let each level of the meta logic just be T?</p>",
        "id": 270340626,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643783287
    },
    {
        "content": "<p>And since we know we can always prove the consistency of T from T...</p>",
        "id": 270340662,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643783364
    },
    {
        "content": "<p>Lean proves Con(PA), but PA never proves Con(PA)</p>",
        "id": 270340665,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1643783368
    },
    {
        "content": "<p>That's Goedel's incompleteness theorem.</p>",
        "id": 270340674,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1643783390
    },
    {
        "content": "<p>Of course, unless PA is inconsistent, in which case PA proves anything by ex falso.</p>",
        "id": 270340740,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1643783444
    },
    {
        "content": "<p>It seems kind of oddly concrete that the level is arithmetic that the incompleteness theorem takes affect.</p>",
        "id": 270341077,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643783784
    },
    {
        "content": "<p>That's the level where undecidability starts to pop up, for example in diophantine equations</p>",
        "id": 270341100,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643783832
    },
    {
        "content": "<p>I guess I would have expected it to be more abstract, like some subset of the set theory axioms.</p>",
        "id": 270341171,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643783887
    },
    {
        "content": "<p>I don't think it has to be arithmetical, but historically that's where it's easiest to state these types of theories</p>",
        "id": 270341177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643783894
    },
    {
        "content": "<p>I see.</p>",
        "id": 270341189,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643783913
    },
    {
        "content": "<p>The set theory axioms generally blow past this level pretty quickly</p>",
        "id": 270341192,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643783914
    },
    {
        "content": "<p>once you have something that acts like a successor function like <code>{x}</code> you can usually already do all this stuff</p>",
        "id": 270341211,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643783944
    },
    {
        "content": "<p>One thing though: I don't immediately see how Lean proves Con(PA) without excluded middle, is there any reference?</p>",
        "id": 270341241,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1643783985
    },
    {
        "content": "<p>I was actually writing that up right now</p>",
        "id": 270341293,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643784007
    },
    {
        "content": "<p>it's not too hard to see that it should be possible: <code>nat</code> has decidable equality</p>",
        "id": 270341321,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643784035
    },
    {
        "content": "<p>plus <code>Con(PA)</code> is a negative statement so intuitionism doesn't get in the way much</p>",
        "id": 270341347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643784065
    },
    {
        "content": "<p>Yeah I guess so, but it would be cool to see the complete proof done ;)</p>",
        "id": 270341351,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1643784069
    },
    {
        "content": "<p>Along the same lines, is there a written, maybe formal, proof that the axioms of metamath are equivalent at the object level to say the axioms of ND?</p>",
        "id": 270341561,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643784274
    },
    {
        "content": "<p>Not sure if I would understand it, but might be interesting to try to.</p>",
        "id": 270341661,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643784368
    },
    {
        "content": "<p>I think there's Meredith's work, which is mildly relevant(?)</p>",
        "id": 270341663,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1643784371
    },
    {
        "content": "<p>Something like <a href=\"http://us.metamath.org/mpeuni/natded.html\">http://us.metamath.org/mpeuni/natded.html</a>?</p>",
        "id": 270341678,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643784394
    },
    {
        "content": "<p>So I guess that shows that everything proven in ND can be proven from metamath. And the other way is shown because every axiom of metamath is a theorem of the Hilbert system, and the Hilbert system has been shown through the deduction theorem to be equivalent at the object level to ND?</p>",
        "id": 270342457,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643785204
    },
    {
        "content": "<p>I found a way to cheat enough to make an easy proof of <code>Con(PA)</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">proof</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">prefix</span> <span class=\"bp\">`⊢`</span><span class=\"o\">:</span><span class=\"mi\">30</span> <span class=\"o\">:=</span> <span class=\"n\">proof</span>\n<span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"bp\">⊢</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"bp\">⊢</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"bp\">⊢</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">z</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ_inj</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"n\">nat.succ</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">nat.succ</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ_ne_zero</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"n\">nat.succ</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">induction</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">x.succ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">add_zero</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">add_succ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b.succ</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n<span class=\"bp\">|</span> <span class=\"n\">mul_zero</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">mul_succ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b.succ</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span>\n<span class=\"kd\">prefix</span> <span class=\"bp\">`⊢`</span><span class=\"o\">:</span><span class=\"mi\">30</span> <span class=\"o\">:=</span> <span class=\"n\">proof</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">proof.sound</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">case</span> <span class=\"n\">refl</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span> <span class=\"n\">ih</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">ih.symm</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">trans</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span> <span class=\"n\">ih₁</span> <span class=\"n\">ih₂</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">ih₁.trans</span> <span class=\"n\">ih₂</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">succ_inj</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">congr_arg</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">nat.succ.inj</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">succ_ne_zero</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">nat.succ_ne_zero</span> <span class=\"n\">_</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">induction</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">P0</span> <span class=\"n\">Ps</span> <span class=\"n\">n</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">nat.rec_on</span> <span class=\"n\">n</span> <span class=\"n\">P0</span> <span class=\"n\">Ps</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">add_zero</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">add_succ</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">mul_zero</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">mul_succ</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">con_pa</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"bp\">⊢</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">absurd</span> <span class=\"n\">h.sound</span> <span class=\"n\">dec_trivial</span>\n<span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">con_pa</span> <span class=\"c1\">-- no axioms</span>\n</code></pre></div>",
        "id": 270343077,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643785784
    },
    {
        "content": "<p>That looks very much like how the Church's simple theory of types deals with propositions: There's no Curry-Howard correspondence, and  there is a separate relation <code>|-</code> for proposition derivability, with separate axioms.</p>",
        "id": 270343438,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1643786160
    },
    {
        "content": "<p>But that's currently incomplete as I see it. You don't even have modus ponens, right?</p>",
        "id": 270343514,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1643786231
    },
    {
        "content": "<p>it's a bit annoying that the wikipedia article barely acknowledges this</p>",
        "id": 270343639,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643786357
    },
    {
        "content": "<p>Thank you for the help! I'm going to sleep now :)</p>",
        "id": 270344467,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643787122
    },
    {
        "content": "<p>Okay, here's a slightly less cheating version, which embeds classical logic via the <code>wff</code> type, even though we aren't assuming any classical axioms on <code>Prop</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">wff</span>\n<span class=\"bp\">|</span> <span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">wff</span>\n<span class=\"bp\">|</span> <span class=\"n\">not</span> <span class=\"o\">:</span> <span class=\"n\">wff</span> <span class=\"bp\">→</span> <span class=\"n\">wff</span>\n<span class=\"bp\">|</span> <span class=\"n\">imp</span> <span class=\"o\">:</span> <span class=\"n\">wff</span> <span class=\"bp\">→</span> <span class=\"n\">wff</span> <span class=\"bp\">→</span> <span class=\"n\">wff</span>\n<span class=\"bp\">|</span> <span class=\"n\">all</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">wff</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">wff</span>\n<span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">≃</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">60</span> <span class=\"o\">:=</span> <span class=\"n\">wff.eq</span>\n<span class=\"kd\">infixr</span> <span class=\"bp\">`</span> <span class=\"bp\">⇒</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"o\">:=</span> <span class=\"n\">wff.imp</span>\n<span class=\"kd\">prefix</span> <span class=\"bp\">`~`</span><span class=\"o\">:</span><span class=\"mi\">59</span> <span class=\"o\">:=</span> <span class=\"n\">wff.not</span>\n<span class=\"kd\">def</span> <span class=\"n\">wff.and</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">wff</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">~</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">⇒</span> <span class=\"bp\">~</span><span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">55</span> <span class=\"o\">:=</span> <span class=\"n\">wff.and</span>\n<span class=\"kd\">def</span> <span class=\"n\">wff.or</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">wff</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">~</span><span class=\"n\">x</span> <span class=\"bp\">⇒</span> <span class=\"n\">y</span>\n<span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">||</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">54</span> <span class=\"o\">:=</span> <span class=\"n\">wff.or</span>\n<span class=\"kd\">def</span> <span class=\"n\">wff.iff</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">wff</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">⇒</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">⇒</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">⇔</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">53</span> <span class=\"o\">:=</span> <span class=\"n\">wff.iff</span>\n<span class=\"kd\">notation</span> <span class=\"bp\">`𝔸`</span> <span class=\"n\">binders</span> <span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span> <span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">scoped</span> <span class=\"o\">:=</span> <span class=\"n\">wff.all</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">proof</span> <span class=\"o\">:</span> <span class=\"n\">wff</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">prefix</span> <span class=\"bp\">`⊢</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">30</span> <span class=\"o\">:=</span> <span class=\"n\">proof</span>\n<span class=\"bp\">|</span> <span class=\"n\">ax_1</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">wff</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"n\">p</span> <span class=\"bp\">⇒</span> <span class=\"n\">q</span> <span class=\"bp\">⇒</span> <span class=\"n\">p</span>\n<span class=\"bp\">|</span> <span class=\"n\">ax_2</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">wff</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">⇒</span> <span class=\"n\">q</span> <span class=\"bp\">⇒</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">⇒</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">⇒</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">⇒</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">⇒</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">ax_3</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">wff</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"n\">p</span> <span class=\"bp\">⇒</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">⇒</span> <span class=\"n\">q</span> <span class=\"bp\">⇒</span> <span class=\"n\">p</span>\n<span class=\"bp\">|</span> <span class=\"n\">mp</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">wff</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"n\">p</span> <span class=\"bp\">⇒</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"bp\">⊢</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"bp\">⊢</span> <span class=\"n\">q</span>\n<span class=\"bp\">|</span> <span class=\"n\">gen</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">wff</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">⊢</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">⊢</span> <span class=\"bp\">𝔸</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"n\">ax_4</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">wff</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"bp\">𝔸</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">⇒</span> <span class=\"n\">p</span> <span class=\"n\">t</span>\n<span class=\"bp\">|</span> <span class=\"n\">ax_5</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">wff</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"bp\">𝔸</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"bp\">⇒</span> <span class=\"n\">q</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">⇒</span> <span class=\"o\">(</span><span class=\"bp\">𝔸</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">⇒</span> <span class=\"o\">(</span><span class=\"bp\">𝔸</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">q</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">ax_6</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">wff</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"n\">p</span> <span class=\"bp\">⇒</span> <span class=\"o\">(</span><span class=\"bp\">𝔸</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"n\">x</span> <span class=\"bp\">≃</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"n\">x</span> <span class=\"bp\">≃</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"bp\">⊢</span> <span class=\"n\">y</span> <span class=\"bp\">≃</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"n\">x</span> <span class=\"bp\">≃</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"bp\">⊢</span> <span class=\"n\">y</span> <span class=\"bp\">≃</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"bp\">⊢</span> <span class=\"n\">x</span> <span class=\"bp\">≃</span> <span class=\"n\">z</span>\n<span class=\"bp\">|</span> <span class=\"n\">subst</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">wff</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"n\">x</span> <span class=\"bp\">≃</span> <span class=\"n\">y</span> <span class=\"bp\">⇒</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"bp\">⇒</span> <span class=\"n\">p</span> <span class=\"n\">y</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ_inj</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"n\">x</span> <span class=\"bp\">≃</span> <span class=\"n\">y</span> <span class=\"bp\">⇔</span> <span class=\"n\">x.succ</span> <span class=\"bp\">≃</span> <span class=\"n\">y.succ</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ_ne_zero</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"bp\">~</span><span class=\"o\">(</span><span class=\"n\">x.succ</span> <span class=\"bp\">≃</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">induction</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">wff</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"mi\">0</span> <span class=\"bp\">⇒</span> <span class=\"o\">(</span><span class=\"bp\">𝔸</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"bp\">⇒</span> <span class=\"n\">P</span> <span class=\"n\">x.succ</span><span class=\"o\">)</span> <span class=\"bp\">⇒</span> <span class=\"bp\">𝔸</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">add_zero</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">≃</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">add_succ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b.succ</span> <span class=\"bp\">≃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n<span class=\"bp\">|</span> <span class=\"n\">mul_zero</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"mi\">0</span> <span class=\"bp\">≃</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">mul_succ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b.succ</span> <span class=\"bp\">≃</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span>\n<span class=\"kd\">prefix</span> <span class=\"bp\">`⊢</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">30</span> <span class=\"o\">:=</span> <span class=\"n\">proof</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">wff.val</span> <span class=\"o\">:</span> <span class=\"n\">wff</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">≃</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">~</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">¬</span> <span class=\"n\">x.val</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">⇒</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x.val</span> <span class=\"bp\">→</span> <span class=\"n\">y.val</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">wff.all</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">wff.dne</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">wff</span><span class=\"o\">,</span> <span class=\"bp\">¬¬</span><span class=\"n\">x.val</span> <span class=\"bp\">→</span> <span class=\"n\">x.val</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">≃</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">decidable.of_not_not</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">h</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">~</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">not_of_not_not_not</span> <span class=\"n\">h</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">⇒</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">y.dne</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">hy</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"n\">hx</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">wff.all</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">dne</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hx</span> <span class=\"bp\">$</span> <span class=\"n\">ha</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">proof.sound</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">⊢</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p.val</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">case</span> <span class=\"n\">ax_1</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">ax_2</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">ax_3</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p.dne</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">h</span> <span class=\"n\">b</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">mp</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span> <span class=\"n\">ih₁</span> <span class=\"n\">ih₂</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">ih₁</span> <span class=\"n\">ih₂</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">gen</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">h</span> <span class=\"n\">ih</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">ih</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">ax_4</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">ax_5</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">ax_6</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">refl</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span> <span class=\"n\">ih</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">ih.symm</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">trans</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span> <span class=\"n\">ih₁</span> <span class=\"n\">ih₂</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">ih₁.trans</span> <span class=\"n\">ih₂</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">subst</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">p</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">x</span><span class=\"bp\">=</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"bp\">▸</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">succ_inj</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">nat.succ.inj</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">succ_ne_zero</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">nat.succ_ne_zero</span> <span class=\"n\">_</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">induction</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">P0</span> <span class=\"n\">Ps</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">nat.rec_on</span> <span class=\"n\">n</span> <span class=\"n\">P0</span> <span class=\"n\">Ps</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">add_zero</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">add_succ</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">mul_zero</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">mul_succ</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">con_pa</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"bp\">⊢</span> <span class=\"mi\">0</span> <span class=\"bp\">≃</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">absurd</span> <span class=\"n\">h.sound</span> <span class=\"o\">(</span><span class=\"n\">dec_trivial</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">con_pa</span> <span class=\"c1\">-- no axioms</span>\n</code></pre></div>",
        "id": 270348518,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643790228
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/270142115\">said</a>:</p>\n<blockquote>\n<p>If I move the last code example that I posted from propositional logic to predicate logic, do I understand correctly that applying a theorem will  then require replacing each free term variable with a syntactically correct term scheme, taking into account potential free variable capture, in addition to the replacement of propositional variables (predicate variables of arity 0) that is already done in the current propositional case?</p>\n</blockquote>\n<p>If you substitute a formula in for a propositional variable, do you at the same time have to substitute in for each of the propositional variables and each of the free term variables in that formula? And so on recursively?</p>",
        "id": 270504934,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643868352
    },
    {
        "content": "<p>No. The variables in the formula will be variables in the current context</p>",
        "id": 270505113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643868550
    },
    {
        "content": "<p>Ok. Thank you.</p>",
        "id": 270505197,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643868614
    },
    {
        "content": "<p>there is some \"second order subtitution\" going on in the code for substituting into a second order variable, for example if we want to substitute <code>P(x, y) := a &lt; b + x</code> into a theorem scheme like <code>all z, ex w, P(z + 1, w)</code> we have to substitute <code>z + 1, w</code> for <code>x, y</code> to get <code>a &lt; b + (z + 1)</code> and then replace <code>P(z + 1, w)</code> with this <code>a &lt; b + (z + 1)</code> formula in the original expression <code>all z, ex w, P(z + 1, w)</code> to get <code>all z, ex w, a &lt; b + (z + 1)</code>, but that's as far as it goes. (You would need third order substitution if the variables <code>z</code> and <code>w</code> could themselves be higher order objects appearing as <code>z(u)</code> in the expression.)</p>",
        "id": 270505463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643868888
    },
    {
        "content": "<p>If you only have 0-ary formula and term variables then you only need one level of substitution</p>",
        "id": 270505508,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643868944
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/270505508\">said</a>:</p>\n<blockquote>\n<p>If you only have 0-ary formula and term variables then you only need one level of substitution</p>\n</blockquote>\n<p>I'm not sure if I do or not. I mean I have predicate variables which can have arbitrary arity. But are you maybe referring to higher order logics, that is beyond first order logic, where for example you can generalize over propositions?</p>",
        "id": 270505869,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643869300
    },
    {
        "content": "<p>The question is whether you can substitute for those predicate variables of nonzero arity</p>",
        "id": 270505927,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643869342
    },
    {
        "content": "<p>I assume you can, in which case you have the second order substitution process I mentioned</p>",
        "id": 270505943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643869368
    },
    {
        "content": "<p>This is second order logic \"lite\"</p>",
        "id": 270506019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643869397
    },
    {
        "content": "<p>since you don't have arbitrary quantification over those predicate variables</p>",
        "id": 270506073,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643869432
    },
    {
        "content": "<p>I don't think I can. I mean you can substitute for the terms in them, but I don't have it that you can replace them entirely, which are different things right?</p>",
        "id": 270506169,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643869503
    },
    {
        "content": "<p>I'm trying to stick to just FOL for now.</p>",
        "id": 270506208,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643869559
    },
    {
        "content": "<p>Right I mean if you have a lemma like <code>(all x, P(x) -&gt; Q(x)) -&gt; (all x, P(x)) -&gt; (all x, Q(x))</code> and you say \"I want to use this lemma with <code>P(x) := 2 &lt; x</code> and <code>Q(x) := 0 &lt; x</code>\"</p>",
        "id": 270506274,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643869596
    },
    {
        "content": "<p>Without such a mechanism it's not very useful to prove FOL schemes</p>",
        "id": 270506309,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643869668
    },
    {
        "content": "<p>Basically the predicate variables aren't variables at all, they are constants</p>",
        "id": 270506369,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643869706
    },
    {
        "content": "<p>Maybe it will be easier if I post what I have of the code so far.</p>",
        "id": 270506520,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643869917
    },
    {
        "content": "<p>Let me clean it up a bit.</p>",
        "id": 270506589,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643869964
    },
    {
        "content": "<p>What I'm saying is that if you can't substitute for predicate variables then they aren't variables</p>",
        "id": 270506606,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643869998
    },
    {
        "content": "<p>that's what it means to be a variable</p>",
        "id": 270506615,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643870010
    },
    {
        "content": "<p>Predicate constants are useful too, for example <code>\\in</code> and <code>&lt;</code> are predicate constants</p>",
        "id": 270506681,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643870055
    },
    {
        "content": "<p>you wouldn't expect to be able to substitute them with expressions</p>",
        "id": 270506694,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643870074
    },
    {
        "content": "<p>There are probably errors, but I think this gives the general idea:</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"cm\">{-</span>\n<span class=\"cm\">allVar t = The set of the names of all of the variables that occur in</span>\n<span class=\"cm\">the term t.</span>\n<span class=\"cm\">-}</span><span class=\"w\"></span>\n<span class=\"nf\">allVar</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">Term</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Set</span><span class=\"o\">.</span><span class=\"kt\">Set</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"></span>\n<span class=\"nf\">allVar</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Var</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Set</span><span class=\"o\">.</span><span class=\"n\">singleton</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"></span>\n<span class=\"nf\">allVar</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Func</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Set</span><span class=\"o\">.</span><span class=\"n\">unions</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Prelude</span><span class=\"o\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">allVar</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">allFreeVar p = The set of the names of all of the variables that occur</span>\n<span class=\"cm\">free in the formula p.</span>\n<span class=\"cm\">-}</span><span class=\"w\"></span>\n<span class=\"nf\">allFreeVar</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Set</span><span class=\"o\">.</span><span class=\"kt\">Set</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"></span>\n<span class=\"nf\">allFreeVar</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Pred</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Set</span><span class=\"o\">.</span><span class=\"n\">unions</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Prelude</span><span class=\"o\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">allVar</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"nf\">allFreeVar</span><span class=\"w\"> </span><span class=\"kt\">Bottom</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Set</span><span class=\"o\">.</span><span class=\"n\">empty</span><span class=\"w\"></span>\n<span class=\"nf\">allFreeVar</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Imp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Set</span><span class=\"o\">.</span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">allFreeVar</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">allFreeVar</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"nf\">allFreeVar</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Forall</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Set</span><span class=\"o\">.</span><span class=\"n\">delete</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">allFreeVar</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n\n<span class=\"cm\">{-</span>\n\n<span class=\"cm\">-}</span><span class=\"w\"></span>\n<span class=\"nf\">subEachInForm</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"></span>\n<span class=\"w\">                 </span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"kt\">Term</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"></span>\n<span class=\"w\">                 </span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"></span>\n<span class=\"w\">                 </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n\n<span class=\"nf\">subEachInForm</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">t_map</span><span class=\"w\"> </span><span class=\"n\">f_map</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Set</span><span class=\"o\">.</span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">t_map</span><span class=\"w\"> </span><span class=\"n\">f_map</span><span class=\"w\"> </span><span class=\"kr\">where</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Set</span><span class=\"o\">.</span><span class=\"kt\">Set</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"kt\">Term</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"kt\">Formula</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kt\">Formula</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">binders</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Pred</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"kt\">[]</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"n\">f_map</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"n\">f'</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">f_map</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"kr\">in</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Set</span><span class=\"o\">.</span><span class=\"n\">disjoint</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">allFreeVar</span><span class=\"w\"> </span><span class=\"n\">f'</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">binders</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kr\">then</span><span class=\"w\"> </span><span class=\"n\">f'</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kr\">else</span><span class=\"w\"> </span><span class=\"ne\">error</span><span class=\"w\"> </span><span class=\"s\">\"free variable capture\"</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">binders</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Pred</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">t_map</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kt\">Pred</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nf\">\\</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">subEachInTerm</span><span class=\"w\"> </span><span class=\"n\">binders</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">t_map</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kr\">where</span><span class=\"w\"></span>\n<span class=\"w\">          </span><span class=\"n\">subEachInTerm</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Set</span><span class=\"o\">.</span><span class=\"kt\">Set</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"></span>\n<span class=\"w\">                           </span><span class=\"kt\">Term</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"></span>\n<span class=\"w\">                           </span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"kt\">Term</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"></span>\n<span class=\"w\">                           </span><span class=\"kt\">Term</span><span class=\"w\"></span>\n\n<span class=\"w\">          </span><span class=\"n\">subEachInTerm</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">binders</span><span class=\"w\"> </span><span class=\"kt\">Var</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">t_map</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"p\">`</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Set</span><span class=\"o\">.</span><span class=\"n\">member</span><span class=\"p\">`</span><span class=\"w\"> </span><span class=\"n\">binders</span><span class=\"w\"> </span><span class=\"kr\">then</span><span class=\"w\"> </span><span class=\"kt\">Var</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"kr\">else</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">t_map</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"kr\">in</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Set</span><span class=\"o\">.</span><span class=\"n\">disjoint</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">allVar</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">binders</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kr\">then</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kr\">else</span><span class=\"w\"> </span><span class=\"ne\">error</span><span class=\"w\"> </span><span class=\"s\">\"free variable capture\"</span><span class=\"w\"></span>\n\n<span class=\"w\">          </span><span class=\"n\">subEachInTerm</span><span class=\"w\"> </span><span class=\"n\">binders</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Func</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">t_map</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kt\">Func</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">List</span><span class=\"o\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nf\">\\</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">subEachInTerm</span><span class=\"w\"> </span><span class=\"n\">binders</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">t_map</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"kt\">Bottom</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Bottom</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">binders</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Imp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">t_map</span><span class=\"w\"> </span><span class=\"n\">f_map</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kt\">Imp</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">subEachInForm</span><span class=\"w\"> </span><span class=\"n\">binders</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">t_map</span><span class=\"w\"> </span><span class=\"n\">f_map</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">subEachInForm</span><span class=\"w\"> </span><span class=\"n\">binders</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">t_map</span><span class=\"w\"> </span><span class=\"n\">f_map</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">binders</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Forall</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kt\">Forall</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">subEachInForm</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Set</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">binders</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">t_map</span><span class=\"w\"> </span><span class=\"n\">f_map</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 270507252,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643870711
    },
    {
        "content": "<p>shouldn't the last case</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">binders</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Forall</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kt\">Forall</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">subEachInForm</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Set</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">binders</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">t_map</span><span class=\"w\"> </span><span class=\"n\">f_map</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n<p>be calling <code>go</code> recursively?</p>",
        "id": 270507353,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643870847
    },
    {
        "content": "<p>Yep.</p>",
        "id": 270507358,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643870867
    },
    {
        "content": "<p>also protip you don't need to pass things that are fixed in the recursion to <code>go</code></p>",
        "id": 270507407,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643870895
    },
    {
        "content": "<p>like <code>f_map</code> and <code>t_map</code></p>",
        "id": 270507415,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643870904
    },
    {
        "content": "<p>Yeah, I started out thinking I might need to recursively descend for the propositional case and would need them.</p>",
        "id": 270507440,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643870959
    },
    {
        "content": "<p>Or something like that.</p>",
        "id": 270507483,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643871018
    },
    {
        "content": "<p>This code is roughly what I expected. You aren't substituting for predicate variables, which means that you can't prove schemes over predicates and use them later</p>",
        "id": 270507506,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643871051
    },
    {
        "content": "<p>What will be the drawbacks of not being able to do that?</p>",
        "id": 270507546,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643871111
    },
    {
        "content": "<p>Are there things I can't prove, or will it just be lot harder to prove them?</p>",
        "id": 270507613,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643871146
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/270506274\">said</a>:</p>\n<blockquote>\n<p>Right I mean if you have a lemma like <code>(all x, P(x) -&gt; Q(x)) -&gt; (all x, P(x)) -&gt; (all x, Q(x))</code> and you say \"I want to use this lemma with <code>P(x) := 2 &lt; x</code> and <code>Q(x) := 0 &lt; x</code>\"</p>\n</blockquote>",
        "id": 270507619,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643871148
    },
    {
        "content": "<p>In order to do this you would need to replay the proof in the specific case <code>(all x, 2 &lt; x -&gt; 0 &lt; x) -&gt; (all x, 2 &lt; x) -&gt; (all x, 0 &lt; x)</code></p>",
        "id": 270507673,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643871213
    },
    {
        "content": "<p>Yeah, that sounds like an issue.</p>",
        "id": 270507678,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643871221
    },
    {
        "content": "<p>But I have to implement another level for every arity I want to support?</p>",
        "id": 270507757,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643871287
    },
    {
        "content": "<p>I refer you back to <code>substFormula</code> from <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269903509\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269903509</a></p>",
        "id": 270507783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643871322
    },
    {
        "content": "<p>That handles arbitrary arity</p>",
        "id": 270507797,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643871340
    },
    {
        "content": "<p>it doesn't handle third order variables but you don't have those anyway</p>",
        "id": 270507804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643871354
    },
    {
        "content": "<p>Wait, what is the difference between arity and order?</p>",
        "id": 270507857,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643871384
    },
    {
        "content": "<ul>\n<li><code>x : nat</code> : first order</li>\n<li><code>P : nat -&gt; Prop</code>: second order, arity 1</li>\n<li><code>P : nat -&gt; nat -&gt; Prop</code>: second order, arity 2</li>\n<li><code>P : (nat -&gt; Prop) -&gt; Prop</code>: third order, arity 1</li>\n</ul>",
        "id": 270507905,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643871448
    },
    {
        "content": "<p>An nth order variable takes (any number of) arguments of order n-1</p>",
        "id": 270507954,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643871484
    },
    {
        "content": "<p>Which order would a propositional variable be? <code>P : Prop</code>?</p>",
        "id": 270508135,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643871663
    },
    {
        "content": "<p>I would usually refer to them as second order variables for consistency with the predicates, but you could also consider them as first order</p>",
        "id": 270508211,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643871727
    },
    {
        "content": "<p>you can always code a proposition as a <code>nat</code>, using <code>if p then 1 else 0</code>, so it's possible to smuggle propositions when only first order / <code>nat</code> variables are allowed</p>",
        "id": 270508337,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643871888
    },
    {
        "content": "<p>but of course you can't code a <code>nat -&gt; Prop</code> as a <code>nat</code>, that's cantor's theorem</p>",
        "id": 270508358,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643871918
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/270507783\">said</a>:</p>\n<blockquote>\n<p>I refer you back to <code>substFormula</code> from <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269903509\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/269903509</a></p>\n</blockquote>\n<p>I'm sorry, I was having trouble following your code from earlier, so I thought it might make more sense to me to incrementally build my code up from prop logic and see what I needed to change.</p>",
        "id": 270508585,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643872132
    },
    {
        "content": "<p>So, what are the rules to additionally substitute for a predicate variable of arity &gt; 0? What can I substitute for what under what conditions?</p>",
        "id": 270508747,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643872308
    },
    {
        "content": "<p>From the code it seems maybe you can substitute one predicate for another if there aritys match?</p>",
        "id": 270508917,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643872454
    },
    {
        "content": "<p>that's certainly a necessary condition</p>",
        "id": 270508964,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643872525
    },
    {
        "content": "<p>Think of it from the HOL perspective. We have a term like <code>P(x, y)</code> and we want to substitute a lambda like <code>P := \\lam u v -&gt; foo</code> into it</p>",
        "id": 270509039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643872589
    },
    {
        "content": "<p>obviously the number of lambda binders has to match the number of arguments to <code>P</code></p>",
        "id": 270509046,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643872608
    },
    {
        "content": "<p>I'm guessing there are also conditions to prevent free variable capture?</p>",
        "id": 270509065,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643872648
    },
    {
        "content": "<p>Here's a fairly generic situation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">substitute</span>\n<span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">u</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">v</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span>\n<span class=\"n\">into</span>\n<span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"n\">to</span> <span class=\"n\">get</span>\n<span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span>\n</code></pre></div>\n<ul>\n<li>We start with an expression for <code>P</code> that has <code>a</code> a free variable (referring to something external) and <code>b</code> a bound variable, and the parameters <code>u</code> and <code>v</code>.</li>\n<li>In the final result, <code>a</code> should still be a free variable: therefore it must not clash with the binders it was placed under, namely <code>x</code> and <code>z</code></li>\n<li>Additionally, <code>x</code> and <code>y</code> were not previously under the <code>b</code> binder but have been moved under it in the result, thus they also must not clash</li>\n</ul>",
        "id": 270509534,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643873161
    },
    {
        "content": "<p>Basically any time we have an expression in an outer context with some free variables in it and we want to insert it somewhere under a binder, none of the free variables can clash with the binder</p>",
        "id": 270509800,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643873417
    },
    {
        "content": "<p>This happens twice in the example, we took the expression <code>λ u v, ∀ b, u &lt; a ∧ v &lt; b</code> with free variable <code>a</code> and moved it under the binders <code>∀ x z, </code> so <code>a</code> must not clash with <code>x, z</code>, and then we took the expressions <code>x, y</code> with free variables <code>x, y</code> and moved them under the binder <code>∀ b,</code> so <code>b</code> must not clash with <code>x, y</code></p>",
        "id": 270509973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643873590
    },
    {
        "content": "<p>I'm not sure if I have ever seen that kind of substitution before.</p>",
        "id": 270510058,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643873649
    },
    {
        "content": "<p>In higher order logic we would only do the first part, substituting <code>P := λ u v, ∀ b, u &lt; a ∧ v &lt; b</code> and resulting in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">u</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">v</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 270510100,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643873708
    },
    {
        "content": "<p>we might beta reduce it later, resulting in more constraints / alpha renaming</p>",
        "id": 270510122,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643873737
    },
    {
        "content": "<p>here we're trying to stick to first order so we always eliminate lambdas before they appear</p>",
        "id": 270510195,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643873793
    },
    {
        "content": "<p>Free variables and parameters are not the same? What are parameters in my implementation, if I have any?</p>",
        "id": 270510197,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643873797
    },
    {
        "content": "<p>hopefully my terminology is clear from the example</p>",
        "id": 270510209,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643873818
    },
    {
        "content": "<p><code>a</code> is a free variable, <code>u</code> is a parameter</p>",
        "id": 270510227,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643873835
    },
    {
        "content": "<p>which is to say, it is a \"bound variable\" bound by the lambda</p>",
        "id": 270510246,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643873854
    },
    {
        "content": "<p>even though we don't have any explicit lambda here</p>",
        "id": 270510255,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643873867
    },
    {
        "content": "<p>in my code earlier, the parameters are the <code>[String]</code> in the <code>M.Map String ([String], Int)</code> of the formula substitution map</p>",
        "id": 270510342,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643873945
    },
    {
        "content": "<p>Is there a dependent type here? There are both lambdas and a forall?</p>",
        "id": 270510382,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643873997
    },
    {
        "content": "<p>Lambda isn't formally a part of the syntax, but we are substituting for a predicate so there is morally a lambda involved</p>",
        "id": 270510454,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643874046
    },
    {
        "content": "<p>I've been writing these predicate substitutions as <code>P(u, v) := ∀ b, u &lt; a ∧ v &lt; b</code> or <code>P := λ u v, ∀ b, u &lt; a ∧ v &lt; b</code></p>",
        "id": 270510503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643874096
    },
    {
        "content": "<p>lambda only appears at the top level here, the syntax is a list of variable names followed by a formula</p>",
        "id": 270510551,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643874122
    },
    {
        "content": "<p>like <code>([u, v], ∀ b, u &lt; a ∧ v &lt; b)</code></p>",
        "id": 270510583,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643874147
    },
    {
        "content": "<p>I mean, is there a parameter in the definition I have of <code>Formula</code>? Is it the variable name after the <code>Forall</code>?</p>",
        "id": 270510709,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643874258
    },
    {
        "content": "<p>no, I'm using the term parameter just for the lambda-bound arguments</p>",
        "id": 270510752,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643874316
    },
    {
        "content": "<p>the variables in a forall are just bound variables</p>",
        "id": 270510761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643874329
    },
    {
        "content": "<p>so <code>b</code> is a bound variable in the running example</p>",
        "id": 270510786,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643874354
    },
    {
        "content": "<p>I guess I'm not sure what lambda bound means here. Do I have to extend the <code>Formula</code> def?</p>",
        "id": 270510895,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643874466
    },
    {
        "content": "<p>no</p>",
        "id": 270510900,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643874471
    },
    {
        "content": "<p>A predicate substitution consists of a variable to replace, <code>P</code>, a list of variables <code>[u, v]</code>, and a formula <code>∀ b, u &lt; a ∧ v &lt; b</code></p>",
        "id": 270510985,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643874532
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/270510503\">said</a>:</p>\n<blockquote>\n<p>I've been writing these predicate substitutions as <code>P(u, v) := ∀ b, u &lt; a ∧ v &lt; b</code> or <code>P := λ u v, ∀ b, u &lt; a ∧ v &lt; b</code></p>\n</blockquote>",
        "id": 270510997,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643874546
    },
    {
        "content": "<p>So you just decide which variables are going to be parameters when you decide to do a substitution?</p>",
        "id": 270511090,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643874628
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/270510342\">said</a>:</p>\n<blockquote>\n<p>in my code earlier, the parameters are the <code>[String]</code> in the <code>M.Map String ([String], Int)</code> of the formula substitution map</p>\n</blockquote>",
        "id": 270511096,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643874636
    },
    {
        "content": "<p>you get to make a new formula substitution map any time you apply a lemma</p>",
        "id": 270511144,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643874706
    },
    {
        "content": "<p>so the parameters can be different if you want</p>",
        "id": 270511197,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643874723
    },
    {
        "content": "<p>the formula will usually be different too</p>",
        "id": 270511207,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643874736
    },
    {
        "content": "<p>But it has to be a well formed formula right?</p>",
        "id": 270511269,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643874792
    },
    {
        "content": "<p>Can we go step by step for what gets replaced by what?</p>",
        "id": 270511301,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643874834
    },
    {
        "content": "<p>Suppose I have the predicate <code>Pred \"P\" [Var (x), (Func \"f\" [Var \"y\"])]</code> I guess.</p>",
        "id": 270511409,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643874924
    },
    {
        "content": "<p>Although maybe that is not a proof scheme, so it doesn't work.</p>",
        "id": 270511491,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643874982
    },
    {
        "content": "<p>Can you substitute into predicates over arbitrary terms or just predicates of individual variables. Like I think I have only seen substitutions into things like P(x,y)?</p>",
        "id": 270511643,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643875124
    },
    {
        "content": "<p>I'm sorry, maybe I need a more detailed paper or textbook or something.</p>",
        "id": 270511769,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643875214
    },
    {
        "content": "<p>This kind of substitution is new to me, I think.</p>",
        "id": 270511831,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643875250
    },
    {
        "content": "<p>Is there some kind of arbitrary predicate that we can only replace? We can't replace specific predicates like \"x &lt; y\" with something like \"x = y\" right?</p>",
        "id": 270512694,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643875916
    },
    {
        "content": "<p>I changed <code>x</code> to <code>f(x)</code> in the example to emphasize that <code>P</code> is being applied to terms not variables</p>",
        "id": 270513396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643876428
    },
    {
        "content": "<p><code>u</code> is a variable, but <code>P(f(x), y)</code> can have arbitrary terms there</p>",
        "id": 270513424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643876461
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/270512694\">said</a>:</p>\n<blockquote>\n<p>Is there some kind of arbitrary predicate that we can only replace? We can't replace specific predicates like \"x &lt; y\" with something like \"x = y\" right?</p>\n</blockquote>\n<p>Ah, yes you might need to distinguish these since you haven't been doing so thus far. There are predicate constants and predicate variables and you can only substitute for variables</p>",
        "id": 270513584,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643876559
    },
    {
        "content": "<p><code>&lt;</code> is a predicate constant</p>",
        "id": 270513605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643876576
    },
    {
        "content": "<p>definitions produce new predicate constants, and axiomatic constants like <code>=</code> are also constants</p>",
        "id": 270513657,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643876609
    },
    {
        "content": "<p>The code that you wrote <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/270507252\">before</a> for the <code>Pred name ts</code> case is appropriate for predicate constants</p>",
        "id": 270513792,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643876689
    },
    {
        "content": "<p>Hmm. Ok. How would my data types change? What is an appropriate constructor for a predicate variable?</p>",
        "id": 270514019,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643876847
    },
    {
        "content": "<p>same as constants</p>",
        "id": 270514095,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643876886
    },
    {
        "content": "<p>the only difference is that variables are substituted and constants aren't</p>",
        "id": 270514132,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643876913
    },
    {
        "content": "<p>So they can take arbitrary terms, not just <code>Var</code>?</p>",
        "id": 270514200,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643876964
    },
    {
        "content": "<p>yes</p>",
        "id": 270514211,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643876970
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/ITP.20for.20FOL.20.2B.20ZFC/near/270513424\">said</a>:</p>\n<blockquote>\n<p><code>u</code> is a variable, but <code>P(f(x), y)</code> can have arbitrary terms there</p>\n</blockquote>",
        "id": 270514230,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643876989
    },
    {
        "content": "<p>How do you distinguish them in the code? I mean, I have no real data type for axiomatic constants right?</p>",
        "id": 270514493,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643877149
    },
    {
        "content": "<p>Can we go more slowly through an example substitution using the notation from the code?</p>",
        "id": 270514712,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643877303
    },
    {
        "content": "<p>Actually, I should probably go to sleep. Thank you for your patience.</p>",
        "id": 270515076,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643877492
    },
    {
        "content": "<p>I don't really want to drag this out on a public channel</p>",
        "id": 270515087,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643877497
    },
    {
        "content": "<p>Ok.</p>",
        "id": 270515134,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643877540
    },
    {
        "content": "<p>Sorry.</p>",
        "id": 270515157,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643877562
    },
    {
        "content": "<p>Thank you for your time.</p>",
        "id": 270515204,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643877600
    },
    {
        "content": "<p>perhaps you should PM me or we can have a video discussion or something, I just don't want the hundreds of other people who read #general to deal with it if it isn't of general interest</p>",
        "id": 270515287,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643877634
    },
    {
        "content": "<p>I'm not against discussing this stuff for far longer than appropriate but I should probably moderate at some point</p>",
        "id": 270515355,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643877687
    },
    {
        "content": "<p>:) Ok. I'll see what I can find for texts, papers first.</p>",
        "id": 270515451,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1643877724
    },
    {
        "content": "<p>Apart from efficiency concerns, there's actually no need to distinguish <code>&lt;</code> as constants. They <strong>can</strong> be replaced, as long as you are also replacing them consistently in the axioms.</p>",
        "id": 270516930,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1643878592
    },
    {
        "content": "<p>So declaring <code>&lt;</code> as a constant serves only to say \"hey, this thing is present in the axioms, so you can't just replace it without touching the axioms\".</p>",
        "id": 270517018,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1643878648
    },
    {
        "content": "<p>You definitely can't replace definitions, you might have used the definition in the proof</p>",
        "id": 270517487,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643878865
    },
    {
        "content": "<p>You can't replace axiomatic constants either since they might be used in axioms (e.g. replace <code>=</code> with <code>&lt;</code> in <code>x = x</code>)</p>",
        "id": 270517615,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643878927
    },
    {
        "content": "<p>That is, I think this only works if you don't have a concept of \"global context\" which is not subject to substitution</p>",
        "id": 270517702,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643878986
    },
    {
        "content": "<p>Given this definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">interpretation</span> <span class=\"o\">(</span><span class=\"n\">domain</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">nonempty</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">domain</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">func</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">domain</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">domain</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">pred</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">domain</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>If I have an instance <code>m</code> of <code>interpretation</code> and a function <code>s : string -&gt; string</code>, is there a way to create a new instance <code>m'</code> of <code>interpretation</code> such that <code>m'.nonempty = m.nonempty</code>, <code>m'.func = m.func</code> and if <code>m.pred = 0 p terms</code> then <code>m'.pred = 0 (s p) terms</code> and is <code>m.pred</code> for <code>n != 0</code>?</p>\n<p>I am trying to prove this: <a href=\"https://github.com/pthomas505/lean3/blob/ba0e7d74687a84729d8f0bf1db9c186c89c63937/src/metalogic/pred.lean#L1648\">https://github.com/pthomas505/lean3/blob/ba0e7d74687a84729d8f0bf1db9c186c89c63937/src/metalogic/pred.lean#L1648</a></p>",
        "id": 285194183,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1654566239
    },
    {
        "content": "<p>Should this theorem hold?</p>",
        "id": 285476036,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1654739638
    },
    {
        "content": "<p>that theorem is only true in the forward direction. For example, <code>P -&gt; Q</code> is not a tautology but a substitution instance of it is <code>P -&gt; P</code> which is a tautology</p>",
        "id": 285482117,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1654746117
    },
    {
        "content": "<p>I see. So just <code>is_valid P -&gt; is_valid (sub_prop s P)</code> holds?</p>",
        "id": 285482296,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1654746281
    },
    {
        "content": "<p>Ok.</p>",
        "id": 285482335,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1654746346
    },
    {
        "content": "<p>Thank you.</p>",
        "id": 285482532,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1654746564
    },
    {
        "content": "<p>Should <code>s</code> be of type <code>string -&gt; string</code> or <code>string -&gt; formula</code>? I'm guessing the latter, based on the propositional calculus case.</p>",
        "id": 285482742,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1654746789
    },
    {
        "content": "<p>Hmm, I need to check for variable capture then.</p>",
        "id": 285486736,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1654751202
    },
    {
        "content": "<p>I was wondering if anyone could help me figure out how to show that <code>term</code> and <code>formula</code> are instances of <code>decidable_eq</code>? If I add <code>@[derive decidable_eq]</code> in front of the definition of <code>term</code> I get:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">user</span> <span class=\"n\">defined</span> <span class=\"n\">recursor</span><span class=\"o\">,</span> <span class=\"n\">motive</span> <span class=\"n\">result</span> <span class=\"n\">sort</span> <span class=\"n\">must</span> <span class=\"n\">be</span> <span class=\"kt\">Prop</span> <span class=\"n\">or</span> <span class=\"kt\">Type</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"n\">where</span> <span class=\"n\">l</span> <span class=\"n\">is</span> <span class=\"n\">a</span> <span class=\"kd\">universe</span> <span class=\"kd\">parameter</span>\n</code></pre></div>\n<p>If I add it in front of the definition of <code>formula</code> I get:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">mk_dec_eq_instance</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">generate</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">term</span><span class=\"o\">),</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"n\">term</span>\n<span class=\"bp\">|</span> <span class=\"n\">func</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">term</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">term</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">formula</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">bottom</span> <span class=\"o\">:</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">top</span> <span class=\"o\">:</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">atom</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">not</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">and</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">or</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">imp</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">iff</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">forall_</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">exists_</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n</code></pre></div>",
        "id": 285631761,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1654837637
    },
    {
        "content": "<p>I don't know if the default derive handler can really be expected to do this. It relies on the fact that <code>fin</code> is a fintype naturally.<br>\nHere is a proof anyways, would be great if it can be improved but it is the best I could do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"n\">term</span>\n<span class=\"bp\">|</span> <span class=\"n\">func</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">term</span>\n\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">pi_decide</span> <span class=\"o\">[</span><span class=\"n\">decidable</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">decidable</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"k\">then</span>\n  <span class=\"kd\">by</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"n\">hp</span><span class=\"bp\">;</span> <span class=\"n\">exact</span>\n  <span class=\"k\">if</span> <span class=\"n\">hq</span> <span class=\"o\">:</span> <span class=\"n\">q</span> <span class=\"k\">then</span> <span class=\"n\">is_true</span> <span class=\"o\">⟨</span><span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">hq</span><span class=\"o\">⟩</span>\n  <span class=\"k\">else</span> <span class=\"n\">is_false</span> <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">hq</span> <span class=\"o\">(</span><span class=\"n\">and.right</span> <span class=\"n\">h</span><span class=\"o\">))</span>\n<span class=\"k\">else</span> <span class=\"n\">is_false</span> <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">hp</span> <span class=\"o\">(</span><span class=\"n\">and.left</span> <span class=\"n\">h</span><span class=\"o\">))</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">term</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">term</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">s₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">s₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">decidable_of_decidable_of_iff</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">apply_instance</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">s₁</span> <span class=\"bp\">=</span> <span class=\"n\">s₂</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">func</span> <span class=\"n\">n</span> <span class=\"n\">s'</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">is_false</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">func</span> <span class=\"n\">n</span> <span class=\"n\">s'</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">is_false</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">func</span> <span class=\"n\">n₁</span> <span class=\"n\">s₁</span> <span class=\"n\">t₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">func</span> <span class=\"n\">n₂</span> <span class=\"n\">s₂</span> <span class=\"n\">t₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">decidable_of_decidable_of_iff</span>\n  <span class=\"o\">(</span><span class=\"kd\">begin</span>\n    <span class=\"n\">apply'</span> <span class=\"n\">pi_decide</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">apply'</span> <span class=\"n\">and.decidable</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">fin.heq_fun_iff</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">apply'</span> <span class=\"n\">fintype.decidable_forall_fintype</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">term.decidable_eq</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"bp\">$</span> <span class=\"n\">n₁</span> <span class=\"bp\">=</span> <span class=\"n\">n₂</span> <span class=\"bp\">∧</span> <span class=\"n\">s₁</span> <span class=\"bp\">=</span> <span class=\"n\">s₂</span> <span class=\"bp\">∧</span> <span class=\"n\">t₁</span> <span class=\"bp\">==</span> <span class=\"n\">t₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span>\n\n\n<span class=\"k\">#eval</span> <span class=\"n\">to_bool</span> <span class=\"bp\">$</span> <span class=\"n\">term.func</span> <span class=\"mi\">2</span> <span class=\"s2\">\"f\"</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">term.var</span> <span class=\"s2\">\"x\"</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n      <span class=\"n\">term.func</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"s2\">\"f\"</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">term.var</span> <span class=\"s2\">\"y\"</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">term</span>\n\n<span class=\"kd\">@[derive decidable_eq]</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">formula</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">bottom</span> <span class=\"o\">:</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">top</span> <span class=\"o\">:</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">atom</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">not</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">and</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">or</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">imp</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">iff</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">forall_</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">exists_</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n</code></pre></div>\n<p><span class=\"user-mention\" data-user-id=\"139442\">@Patrick Thomas</span></p>",
        "id": 286255578,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1655318440
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 286298120,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1655345150
    },
    {
        "content": "<p><a href=\"https://proofassistants.stackexchange.com/questions/1537/creating-a-proof-assistant-for-first-order-logic-in-haskell\">https://proofassistants.stackexchange.com/questions/1537/creating-a-proof-assistant-for-first-order-logic-in-haskell</a></p>",
        "id": 286630323,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1655529677
    },
    {
        "content": "<p>Is there an implementation in Lean or Haskell of the algorithm that Lean uses for the locally nameless representation?</p>",
        "id": 286659768,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1655570609
    },
    {
        "content": "<p>I would like to try to see how that translates to a representation for FOL.</p>",
        "id": 286659925,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1655570786
    },
    {
        "content": "<p>Is there a way to simplify these, for example if there exist definitions in mathlib that avoid the need to convert the fin function to a list?<br>\n<a href=\"https://github.com/pthomas505/lean3/blob/06c3f0981ed301f4c4e5c447cb648e33a17e2fcd/src/metalogic/pred.lean#L2593-L2702\">https://github.com/pthomas505/lean3/blob/06c3f0981ed301f4c4e5c447cb648e33a17e2fcd/src/metalogic/pred.lean#L2593-L2702</a></p>",
        "id": 286841987,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1655762094
    },
    {
        "content": "<p>I don't look forward to trying to prove things about them as they are :)</p>",
        "id": 286842359,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1655762449
    },
    {
        "content": "<p>I'm trying to formalize the substitution of predicates as described <a href=\"https://math.stackexchange.com/questions/1374736/is-there-a-rule-for-uniform-substitution-of-predicate-symbols-in-fol/1374989#1374989\">here</a> and then prove that this substitution preserves the validity of formulas. I'm wondering if anyone has any advice on how to go about doing this. Is there a proof somewhere, either formal or informal?</p>",
        "id": 289059673,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1657396625
    },
    {
        "content": "<p>I have been having a hard time finding references to it, and I'm not sure why.</p>",
        "id": 289059687,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1657396678
    },
    {
        "content": "<p>My code base is <a href=\"https://github.com/pthomas505/lean3/blob/d892151aa112dd27bdf2cbaf11efec89d8ddb9f0/src/metalogic/pred.lean\">here</a>.</p>",
        "id": 289059748,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1657396751
    }
]
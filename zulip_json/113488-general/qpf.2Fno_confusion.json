[
    {
        "content": "<p>sorry for the millions of qpf questions, a bit stuck on this one<br>\nThis was originally about another data type, but I figured it would be easiest to just reformulate under option</p>\n<p>I have this little proof here, (on the normal lean inductive option), which I didn't see in mathlib or core btw</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">def</span> <span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">neq_of_none_some</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">none</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"o\">(</span><span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">no_confusion</span> <span class=\"n\">h</span>\n</pre></div>\n\n\n<p>I had managed to get it working relatively unscathed with the qpf parser</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">fix</span><span class=\"bp\">.</span><span class=\"n\">parser</span><span class=\"bp\">.</span><span class=\"n\">equations</span>\n<span class=\"kn\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">opt&#39;</span>\n    <span class=\"n\">qpf</span> <span class=\"n\">opt&#39;</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:</span> <span class=\"n\">opt&#39;</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">opt&#39;</span>\n\n    <span class=\"n\">def</span> <span class=\"n\">opt&#39;</span><span class=\"bp\">.</span><span class=\"n\">neq_of_none_some</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">opt&#39;</span><span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"o\">(</span><span class=\"n\">opt&#39;</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n    <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">opt&#39;</span><span class=\"bp\">.</span><span class=\"n\">no_confusion</span> <span class=\"n\">h</span>\n<span class=\"kn\">end</span> <span class=\"n\">opt&#39;</span>\n</pre></div>\n\n\n<p>When i tried to change <del>qpf opt' (α : Type)</del>  into <em>data opt (α : Type)</em><br>\nThe no_confusion function is then derived under opt.shape.no_confusion,<br>\nbut the signature has changed to accepting an equality between opt.shapes rather.</p>\n<p>I haven't figured out how to go from the original equality into the shape one (see the sorry below).</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">namespace</span> <span class=\"n\">opt</span>\n    <span class=\"n\">data</span> <span class=\"n\">opt</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:</span> <span class=\"n\">opt</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">opt</span>\n\n    <span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"bp\">@</span><span class=\"n\">opt</span><span class=\"bp\">.</span><span class=\"n\">shape</span><span class=\"bp\">.</span><span class=\"n\">no_confusion</span>\n    <span class=\"n\">def</span> <span class=\"n\">opt</span><span class=\"bp\">.</span><span class=\"n\">neq_of_none_some</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">opt</span><span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"o\">(</span><span class=\"n\">opt</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">α</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n    <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"n\">h&#39;</span> <span class=\"o\">:</span> <span class=\"n\">opt</span><span class=\"bp\">.</span><span class=\"n\">shape</span><span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">opt</span><span class=\"bp\">.</span><span class=\"n\">shape</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">α</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n          <span class=\"k\">by</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n       <span class=\"n\">opt</span><span class=\"bp\">.</span><span class=\"n\">shape</span><span class=\"bp\">.</span><span class=\"n\">no_confusion</span> <span class=\"n\">h&#39;</span><span class=\"o\">)</span>\n<span class=\"kn\">end</span> <span class=\"n\">opt</span>\n</pre></div>",
        "id": 163593491,
        "sender_full_name": "matt rice",
        "timestamp": 1555529264
    },
    {
        "content": "<p>I don't think we generate <code>no_confusion</code> for the data types yet but it should be fairly easy to add it because I already have code that does that. I can create a branch with code if you like. I'm trying to not touch the <code>master</code> branch at the moment so that it can serve as a stable state for the reviewer of my paper.</p>",
        "id": 163594980,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1555530414
    },
    {
        "content": "<p>I can just leave it as a sorry for now, but a branch would be fine too, either way</p>",
        "id": 163595349,
        "sender_full_name": "matt rice",
        "timestamp": 1555530751
    },
    {
        "content": "<p>Ok, I'll get on it and let you know when it's usable</p>",
        "id": 163597569,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1555532585
    }
]
[
    {
        "content": "<p>when using <code>add_decl</code> to create a definition, is it possible to declare an accompanying equational lemma?</p>",
        "id": 129109127,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530746317
    },
    {
        "content": "<p>As far as I know, there is no way to define equational lemmas \"just like\" the ones generated by the equation compiler. Maybe <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> can confirm?</p>",
        "id": 129116213,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530762441
    },
    {
        "content": "<p>By \"just like\", I assume specifically that you're saying that <code>simp</code> and <code>unfold</code> won't pick up on them</p>",
        "id": 129116311,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530762613
    },
    {
        "content": "<p>Actually, I should say that's what I'm looking for.</p>",
        "id": 129116417,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530762853
    },
    {
        "content": "<p>Yes, there is a C (and maybe lean?) function <code>get_equation_lemmas</code> which returns these things, but I don't think users have access to change it</p>",
        "id": 129116428,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530762934
    },
    {
        "content": "<p>Yeah I saw it. I was pretty disappointed that it was built in</p>",
        "id": 129116708,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530763447
    },
    {
        "content": "<p>Right, equation lemmas are currently stored in an environment extension, which only exposes read-only access via <a href=\"https://github.com/leanprover/lean/blob/a4aae537fe771ee92d746d4a2be1e73c543e48b9/library/init/meta/simp_tactic.lean#L69\" target=\"_blank\" title=\"https://github.com/leanprover/lean/blob/a4aae537fe771ee92d746d4a2be1e73c543e48b9/library/init/meta/simp_tactic.lean#L69\">tactic.get_eqn_lemmas</a></p>",
        "id": 129122206,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1530774321
    },
    {
        "content": "<p>Blast! Foiled again <span class=\"emoji emoji-1f61d\" title=\"stuck out tongue closed eyes\">:stuck_out_tongue_closed_eyes:</span></p>",
        "id": 129122431,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530774752
    },
    {
        "content": "<p>By the way, why I got you here, beside fields with underscore, is there any information about structures and substructures? I'm looking at <code>group</code> and it does not seem to have any underscore fields even though it has plenty of ancestry</p>",
        "id": 129122505,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530774932
    },
    {
        "content": "<p>It should still use <code>old_structure_cmd</code></p>",
        "id": 129122615,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1530775105
    },
    {
        "content": "<p>I see. I'm a bit vague on how that works. Does it mean that parent structures are expanded fully and not a trace of the  fact that it's a parent is left?</p>",
        "id": 129123072,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530776127
    },
    {
        "content": "<p>Right. Well, the only trace is the synthesized parent coercions.</p>",
        "id": 129123183,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1530776340
    },
    {
        "content": "<p>luckily, these are completely replicable by users</p>",
        "id": 129123241,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530776448
    },
    {
        "content": "<p>One of my kids is doing the exercises in Software Foundations in Lean this week, that was definitely a parent coercion</p>",
        "id": 129123244,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530776459
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Unfortunately, this time, it's not about replicating it. I'm building proofs that structures like groups are transportable. I can unfold projections like <code>group.mul</code> but most axioms are in terms of <code>has_mul.mul</code>.</p>",
        "id": 129123664,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530777146
    },
    {
        "content": "<p>My best idea right now is hard coding references to <code>has_foo.foo</code> for multiple <code>foo</code>s.</p>",
        "id": 129123678,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530777210
    },
    {
        "content": "<p>I don't see the problem. Won't the parent instance be embedded in the <code>has_mul.mul</code> application?</p>",
        "id": 129123683,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530777231
    },
    {
        "content": "<p>Let's say that from <code>equiv a b</code> and <code>group a</code>, I'm building <code>group b</code>. With a list of all the fields of <code>group</code>, I'd call <code>dsimp [...]</code>. I'm not sure what to do if I find the <code>group b</code> instance in there.</p>",
        "id": 129123852,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530777507
    },
    {
        "content": "<p>Should I look for all projections applied to that group instance?</p>",
        "id": 129123871,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530777558
    },
    {
        "content": "<p>I'm still confused. Where would there be a <code>group b</code> instance?</p>",
        "id": 129123936,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530777634
    },
    {
        "content": "<p>In the type of a field?</p>",
        "id": 129123947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530777657
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>@[to_additive name.mk_string &quot;mk&quot; (name.mk_string &quot;add_group&quot; name.anonymous)]\nconstructor group.mk : Π {α : Type u} (mul : α → α → α)\n(mul_assoc :\n  ∀ (a b c : α),\n    @eq α (@has_mul.mul α (@has_mul.mk α mul) (@has_mul.mul α (@has_mul.mk α mul) a b) c)\n      (@has_mul.mul α (@has_mul.mk α mul) a (@has_mul.mul α (@has_mul.mk α mul) b c))) (one : α)\n(one_mul : ∀ (a : α), @eq α (@has_mul.mul α (@semigroup.to_has_mul α (@semigroup.mk α mul mul_assoc)) 1 a) a)\n(mul_one : ∀ (a : α), @eq α (@has_mul.mul α (@semigroup.to_has_mul α (@semigroup.mk α mul mul_assoc)) a 1) a)\n(inv : α → α),\n  (∀ (a : α),\n     @eq α\n       (@has_mul.mul α\n          (@semigroup.to_has_mul α (@monoid.to_semigroup α (@monoid.mk α mul mul_assoc one one_mul mul_one)))\n          (@has_inv.inv α (@has_inv.mk α inv) a)\n          a)\n       1) →\n  group α\n</pre></div>",
        "id": 129123965,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530777716
    },
    {
        "content": "<p>Here's part of the <code>transportable</code> class:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">transportable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">on_equiv</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">equiv</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">equiv</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">β</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 129124003,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530777724
    },
    {
        "content": "<p>To build <code>equiv (group a) (group b)</code> I first need the <code>to_fun</code> definition (which is the hairy part we're now talking about)</p>",
        "id": 129124036,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530777813
    },
    {
        "content": "<p>Ah! Yes, that's where the instance would be:</p>\n<div class=\"codehilite\"><pre><span></span>(@has_mul.mul α\n          (@semigroup.to_has_mul α (@monoid.to_semigroup α (@monoid.mk α mul mul_assoc one one_mul mul_one)))\n          (@has_inv.inv α (@has_inv.mk α inv) a)\n</pre></div>",
        "id": 129124085,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530777861
    },
    {
        "content": "<p>So it does not appear directly as an argument to a projection</p>",
        "id": 129124089,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530777894
    },
    {
        "content": "<p>You can unfold all those if you want</p>",
        "id": 129124090,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530777899
    },
    {
        "content": "<p>it reduces to <code>mul</code> of course</p>",
        "id": 129124101,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530777912
    },
    {
        "content": "<p>I just remembered <code>unfold_projs</code> exists. Is this what you think I should use?</p>",
        "id": 129124165,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530778002
    },
    {
        "content": "<p>shouldn't <code>dsimp</code> work?</p>",
        "id": 129124170,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530778020
    },
    {
        "content": "<p>or is the problem that you don't know what to simplify</p>",
        "id": 129124178,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530778035
    },
    {
        "content": "<p>You can use <code>whnf</code> to give it a good kick</p>",
        "id": 129124182,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530778062
    },
    {
        "content": "<blockquote>\n<p>Mario Carneiro: or is the problem that you don't know what to simplify</p>\n</blockquote>\n<p>Yes exactly. What I'm starting with is the list of all the fields of <code>group</code></p>",
        "id": 129124234,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530778138
    },
    {
        "content": "<p><code>whnf</code> still would be pretty involved. If I just apply it to the proposition, nothing will happen because it's an equality. Then I'd need to traverse the whole expression</p>",
        "id": 129124288,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530778256
    },
    {
        "content": "<p>Of course you have to traverse the expression. How else would you figure out what to transport?</p>",
        "id": 129124357,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530778362
    },
    {
        "content": "<p>cancellation rules on <code>equiv</code> are doing a lot already. I thought I could use more high level primitives. My tactic is outrageously slow already without hand crafting traversals</p>",
        "id": 129124417,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530778476
    },
    {
        "content": "<p>oh, I see, you are using heuristic simplification</p>",
        "id": 129124426,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530778504
    },
    {
        "content": "<p>Yes. Do you think it might be why it's all so slow?</p>",
        "id": 129124497,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530778614
    },
    {
        "content": "<p>hard to say without knowing exactly what you are doing, but yes, I expect that a general analysis would be both more reliable and faster (and also a lot of work to write)</p>",
        "id": 129124518,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530778665
    },
    {
        "content": "<p>If you aren't going for the full decision procedure, then it seems okay to just have an ad hoc list and let users add to it as necessary</p>",
        "id": 129124589,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530778767
    },
    {
        "content": "<p>That makes sense. I'll have to do optimization at some point anyway</p>",
        "id": 129124708,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530778958
    },
    {
        "content": "<p>Even having an approximate transportable implementation would be very helpful, I think</p>",
        "id": 129124725,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530779013
    },
    {
        "content": "<p>I'll try to wrap up a prototype quickly. The feedback will be useful to pick a direction. I think the performances will be very noticeable</p>",
        "id": 129124773,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530779100
    },
    {
        "content": "<p>Did you ever look at Johannes's <code>transport</code> tactic, with its relator based approach?</p>",
        "id": 129124780,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530779107
    },
    {
        "content": "<p>Only a while ago and never managed to understand it. I'll have another look</p>",
        "id": 129124837,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530779167
    },
    {
        "content": "<p>Btw, here's what I have, if you want to check it out:</p>\n<p><a href=\"https://github.com/cipher1024/transport/blob/master/src/transport.lean#L114\" target=\"_blank\" title=\"https://github.com/cipher1024/transport/blob/master/src/transport.lean#L114\">https://github.com/cipher1024/transport/blob/master/src/transport.lean#L114</a></p>",
        "id": 129124842,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530779180
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> do you have any clue how close this brings us to the parametricity results of Wadler that <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> has been talking about?</p>",
        "id": 129134127,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530792683
    },
    {
        "content": "<p>It is not clear to me how our \"naive transporatability\" notion compares to Wadler's parametricity when it comes to ease of use. I also don't know how they compare when it comes to ease of implementation...</p>",
        "id": 129134206,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530792787
    },
    {
        "content": "<p>Actually, I haven't followed that conversation too closely. I'll have to catch up</p>",
        "id": 129143345,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530802470
    },
    {
        "content": "<p>Can you point me to the beginning of that conversation?</p>",
        "id": 129149249,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530808926
    },
    {
        "content": "<p>How does Lean tell the difference between an automatically generated <code>.equations._eqn_1</code> and one that I prove manually?</p>",
        "id": 133328882,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536086912
    },
    {
        "content": "<p>I have gone down that road before. In Lean 3, there's no way of getting Lean to use your lemmas as definitional equations</p>",
        "id": 133328929,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1536086976
    },
    {
        "content": "<p>this is so sad</p>",
        "id": 133330070,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536087994
    },
    {
        "content": "<p>I'm hopeful it'll get better in Lean 4</p>",
        "id": 133330102,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1536088053
    }
]
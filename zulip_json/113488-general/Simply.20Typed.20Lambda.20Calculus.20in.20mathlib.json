[
    {
        "content": "<p>I noticed recently there's no formalization for simply typed lambda calculus in the mathlib. I'm a fairly inexperienced Lean user, but I do have a formalization that I did for a project <a href=\"https://github.com/xoers/stlc-lean/blob/main/src/stlc.lean\">here</a>. I would be really interested in trying to get this to a place where it could live in the mathlib. There are a bunch of auxillary lemmas, but the main \"theorem-worthy\" results I have right now are proofs of Unicity of typing, Progress, and Preservation. (There are also a couple of results I proved only because they were asked as a homework question in one of my classes - lines 300 to 565 are probably not worth putting in the mathlib) Besides concerns of style which obviously needs to be improved, I have a couple of questions:</p>\n<ol>\n<li>\n<p>Is this even a reasonable foundation for STLC in Lean? If not, why not and how can I improve it?</p>\n</li>\n<li>\n<p>Is this a thing that belongs in the mathlib?</p>\n</li>\n<li>\n<p>If the answers to the previous two questions were yes, how would I decide the \"canonical\" version of STLC to work with. What types should I include? How should substituion be defined? etc.</p>\n</li>\n</ol>\n<p>Thank you so much and I would be eager for any feedback about my code or otherwise!</p>",
        "id": 308706067,
        "sender_full_name": "zbatt",
        "timestamp": 1667960618
    },
    {
        "content": "<p>I'm not an expert on lambda calculus at all. But I think such things could definitely go in mathlib.</p>",
        "id": 308726589,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1667976639
    },
    {
        "content": "<p>Does this development need anything at all of the current theory in mathlib?</p>",
        "id": 308727015,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1667976916
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Simply.20Typed.20Lambda.20Calculus.20in.20mathlib/near/308727015\">said</a>:</p>\n<blockquote>\n<p>Does this development need anything at all of the current theory in mathlib?</p>\n</blockquote>\n<p>Sorry, what do you mean by this?</p>",
        "id": 308728993,
        "sender_full_name": "zbatt",
        "timestamp": 1667977985
    },
    {
        "content": "<p>Are you depending on parts of mathlib?</p>",
        "id": 308729378,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1667978207
    },
    {
        "content": "<p>It looks like you depend on some tactics, and maybe a few things about <code>option</code>?</p>",
        "id": 308729429,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1667978245
    },
    {
        "content": "<p>Ah ok, yes that's exactly right. I use some of the mathlib tactics such as <code>induction'</code> and <code>split_ifs</code>.  I'm realizing now that the option import was from an earlier version and I no longer need it so mathlib dependencies are limited to just tactics.</p>",
        "id": 308729526,
        "sender_full_name": "zbatt",
        "timestamp": 1667978287
    },
    {
        "content": "<p>I've heard <a href=\"https://www.research.ed.ac.uk/en/publications/type-and-scope-safe-programs-and-their-proofs\">another definition</a> from others, which translates into lean is something like the following (there are some missed things), but I'm not sure it's better.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.basic</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! # Simply typed λ-calculus -/</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">lambda_calculus</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">simply_typed</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">base_types</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">simply_typed</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">type</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">simply_typed</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">base_type</span> <span class=\"o\">{</span><span class=\"n\">T</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hT</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">∈</span> <span class=\"n\">L.base_types</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">type</span>\n<span class=\"bp\">|</span> <span class=\"n\">fun_type</span> <span class=\"o\">:</span> <span class=\"n\">type</span> <span class=\"bp\">→</span> <span class=\"n\">type</span> <span class=\"bp\">→</span> <span class=\"n\">type</span>\n<span class=\"kn\">export</span> <span class=\"n\">type</span>\n\n<span class=\"n\">localized</span> <span class=\"s2\">\"infixr (name := fun_type) ` ⥤ `:10 := lambda_calculus.simply_typed.type.fun_type\"</span>\n  <span class=\"k\">in</span> <span class=\"n\">lambda_calculus.simply_typed</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">simply_typed.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">context</span> <span class=\"o\">:=</span> <span class=\"n\">list</span> <span class=\"n\">L.type</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">L</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">context.cons</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"o\">:</span> <span class=\"n\">L.context</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">L.type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">L.context</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"o\">::</span> <span class=\"bp\">Γ</span>\n\n<span class=\"n\">localized</span> <span class=\"s2\">\"infixl (name := context.cons) ` ◂ `:75 := lambda_calculus.simply_typed.context.cons\"</span>\n  <span class=\"k\">in</span> <span class=\"n\">lambda_calculus.simply_typed</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">var</span> <span class=\"o\">:</span> <span class=\"n\">L.context</span> <span class=\"bp\">→</span> <span class=\"n\">L.type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">z</span> <span class=\"o\">{</span><span class=\"bp\">Γ</span> <span class=\"n\">α</span><span class=\"o\">}</span>   <span class=\"o\">:</span>            <span class=\"n\">var</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">◂</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">s</span> <span class=\"o\">{</span><span class=\"bp\">Γ</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">var</span> <span class=\"bp\">Γ</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">var</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">◂</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">v0</span> <span class=\"o\">{</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">simply_typed</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"bp\">Γ</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">var</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">◂</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">var.z</span> <span class=\"n\">L</span> <span class=\"bp\">Γ</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">L.context</span> <span class=\"bp\">→</span> <span class=\"n\">L.type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"o\">{</span><span class=\"bp\">Γ</span> <span class=\"n\">α</span><span class=\"o\">}</span>   <span class=\"o\">:</span> <span class=\"n\">var</span> <span class=\"bp\">Γ</span> <span class=\"n\">α</span>                     <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"bp\">Γ</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">abs</span> <span class=\"o\">{</span><span class=\"bp\">Γ</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">◂</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">β</span>              <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"bp\">Γ</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⥤</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">{</span><span class=\"bp\">Γ</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">Γ</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⥤</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"bp\">Γ</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"bp\">Γ</span> <span class=\"n\">β</span>\n\n<span class=\"n\">localized</span> <span class=\"s2\">\"prefix (name := term.var) `#`:1500 := lambda_calculus.simply_typed.term.var\"</span>\n  <span class=\"k\">in</span> <span class=\"n\">lambda_calculus.simply_typed</span>\n<span class=\"n\">localized</span> <span class=\"s2\">\"prefix (name := term.abs) `ƛ `:10 := lambda_calculus.simply_typed.term.abs\"</span>\n  <span class=\"k\">in</span> <span class=\"n\">lambda_calculus.simply_typed</span>\n<span class=\"n\">localized</span> <span class=\"s2\">\"infixl (name := term.app) ` · `:1000 := lambda_calculus.simply_typed.term.app\"</span>\n  <span class=\"k\">in</span> <span class=\"n\">lambda_calculus.simply_typed</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"bp\">Γ</span> <span class=\"o\">:</span> <span class=\"n\">L.context</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"n\">L.type</span><span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">combinator</span>\n<span class=\"kd\">def</span> <span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">Γ</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⥤</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">ƛ</span> <span class=\"bp\">#</span><span class=\"n\">v0</span>\n<span class=\"kd\">def</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">Γ</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⥤</span> <span class=\"n\">β</span> <span class=\"bp\">⥤</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">ƛ</span> <span class=\"o\">(</span><span class=\"bp\">ƛ</span> <span class=\"bp\">#</span><span class=\"n\">v0.s</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">Γ</span> <span class=\"o\">((</span><span class=\"n\">α</span> <span class=\"bp\">⥤</span> <span class=\"n\">β</span> <span class=\"bp\">⥤</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"bp\">⥤</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⥤</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">⥤</span> <span class=\"n\">α</span> <span class=\"bp\">⥤</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">ƛ</span> <span class=\"bp\">ƛ</span> <span class=\"bp\">ƛ</span> <span class=\"o\">(</span><span class=\"bp\">#</span><span class=\"n\">v0.s.s</span> <span class=\"bp\">·</span> <span class=\"bp\">#</span><span class=\"n\">v0</span><span class=\"o\">)</span> <span class=\"bp\">·</span> <span class=\"o\">(</span><span class=\"bp\">#</span><span class=\"n\">v0.s</span> <span class=\"bp\">·</span> <span class=\"bp\">#</span><span class=\"n\">v0</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span> <span class=\"n\">combinator</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">simply_typed</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">lambda_calculus</span>\n</code></pre></div>\n</div></div>",
        "id": 308741346,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1667983924
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"483794\">@zbatt</span> I should maybe walk back my statement a bit. As I said I'm not an expert on lambda calculus at all. It is my opinion that some type theoretic stuff should be welcome in mathlib. But for the particular details, I would rather defer to someone more knowledgeable.</p>",
        "id": 308750834,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1667987376
    },
    {
        "content": "<p>I think a formalization of lambda calculus / type theory suffers from a similar problem as that of graph theory: there are many different (non-equivalent) formulations, and it depends on your goals which formulation you want to use.<br>\nA difference with graph theory is that eventually quite some mathematical results will use graphs, but I think the usage of a formalization of (simply) typed lambda calculus will be quite limited. </p>\n<p>Some choices you have to make when formalizing type theory. Of course there is the question of simply typed lambda calculus vs dependent type theory, but even in simply typed lambda calculus, there are many questions:</p>\n<ul>\n<li>What are your base types?</li>\n<li>How do you encode variables (named, de Bruijn variables, locally nameless, ...)?</li>\n<li>Do lambda abstractions come with their type?</li>\n<li>Do you want to define well-typed terms in terms of raw terms, or do you want to directly define the \"well-typed terms in context Γ with type A\" directly as an inductive definition?</li>\n</ul>\n<p>My preference is to wait with including type theory/lambda calculus in mathlib, until someone does a relatively big formalization and shows that their formalization is actually usable, or maybe until multiple (groups of) people want to work on it independently...</p>\n<p>Btw, <span class=\"user-mention\" data-user-id=\"483794\">@zbatt</span>: one thing in your formalization that is not very standard is that you allow for infinite contexts.</p>",
        "id": 308765127,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1667992696
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> what about putting it in <code>achive</code> instead?</p>",
        "id": 308799236,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1668004315
    },
    {
        "content": "<p>If the code quality is good, I'm fine with that.</p>",
        "id": 308802300,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1668005152
    },
    {
        "content": "<p>Although that might send the wrong message that lambda calculus does not belong to mathlib, which is not the message I want to send...</p>",
        "id": 308802605,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1668005241
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/113488-general/topic/Simply.20Typed.20Lambda.20Calculus.20in.20mathlib/near/308765127\">said</a>:</p>\n<blockquote>\n<p>I think a formalization of lambda calculus / type theory suffers from a similar problem as that of graph theory: there are many different (non-equivalent) formulations, and it depends on your goals which formulation you want to use.<br>\nA difference with graph theory is that eventually quite some mathematical results will use graphs, but I think the usage of a formalization of (simply) typed lambda calculus will be quite limited. </p>\n<p>You have to make many choices when formalizing type theory. Of course there is the question of simply typed lambda calculus vs dependent type theory, but even in simply typed lambda calculus, there are many questions:</p>\n<ul>\n<li>What are your base types?</li>\n<li>How do you encode variables (named, de Bruijn variables, locally nameless, ...)?</li>\n<li>Do lambda abstractions come with their type?</li>\n<li>Do you want to define well-typed terms in terms of raw terms, or do you want to directly define the \"well-typed terms in context Γ with type A\" directly as an inductive definition?</li>\n</ul>\n<p>My preference is to wait with including type theory/lambda calculus in mathlib, until someone does a relatively big formalization and shows that their formalization is actually usable, or maybe until multiple (groups of) people want to work on it independently...</p>\n<p>Btw, <span class=\"user-mention silent\" data-user-id=\"483794\">zbatt</span>: one thing in your formalization that is not very standard is that you allow for infinite contexts.</p>\n</blockquote>\n<p>That makes a lot of sense. I definitely am not the person that should be making those decisions about the canonical formalization of this. I was hoping that maybe there was some standard I was unaware of which is part of the reason I posted this, but if not, those decisions should absolutely be made by someone with more experience.</p>\n<p>And thanks for the note about infinite contexts! I'll be sure to get around to updating that.</p>",
        "id": 308829629,
        "sender_full_name": "zbatt",
        "timestamp": 1668013115
    },
    {
        "content": "<p>In general I think it is a bad idea to define untyped terms first. I would always do it intrinsically, see attached.  <a href=\"/user_uploads/3121/VndJOyU8Rn0qrBCGCykA0puP/stl.lean\">stl.lean</a></p>",
        "id": 308967217,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1668079458
    },
    {
        "content": "<p>This certainly works very well in agda using dependently typed pattern matching, I don't know how well this fits into Lean.<br>\nHowever, I would argue that this is conceptually the right definition, since there is no reason to define untyped terms if you are interested in typed ones. We have also done this for dependent types, e.g. see <a href=\"https://dl.acm.org/doi/abs/10.1145/2837614.2837638\">https://dl.acm.org/doi/abs/10.1145/2837614.2837638</a></p>",
        "id": 308967947,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1668079741
    }
]
[
    {
        "content": "<p>Hello, I'm not sure if this is the correct place to post this. I am Mohammed Eyad Kurd-Misto, a PhD student at Chapman university. I am having an issue with a proof where the let construct does not seem to be working the way I would think. For two steps of the proof, I am simply substituting portions of the current statement from the let, and in one instance there is no issue but in another I am getting an error. The main relevant code is:</p>\n<p><code>lemma flat_sharp {B : Type} : Π {n : ℕ}, ∀ (ps: @datum_or_data B ff n), (♭ (♯ ps)) = ps\n| 0   datum_or_data.nil := rfl \n| (n+1) (datum_or_data.cons p ps) := \nlet ⟨as, h⟩ := ♯ ps, a := ♮⁻¹ p in  --let (⟨as, h⟩ : vector B n) := (♯ ps : vector B n), a := ♮⁻¹ p in\n  calc\n    (♭ (♯ (datum_or_data.cons p ps))) = ♭ (vector.cons (♮⁻¹  p) (♯ ps)) : rfl\n    ...                 = ♭ (vector.cons (a) (♯ ps)) : rfl   --this works\n    ...                 = ♭ (vector.cons (a) (⟨as, h⟩)) : rfl --@rfl (vector B n)  -- this does not work?\n    ...                 = datum_or_data.cons (♮ (a)) (♭ ⟨as, h⟩) : rfl\n    ...</code></p>\n<p>♭ and ♯ are operations for converting data from a vector to a 'datum_or_data' and vice versa so the goal here is simply to show they invert one another.  ♮and ♮⁻¹ are operations for converting the individual elements of the data. I'm really not sure why I can't simply substitute  ⟨as, h⟩ for  ♯ ps since they are defined to be the same in the let and I have been unable to replicate anything similar where I can't simply substitute what is defined in the let construct. Any help would be greatly appreciated!</p>\n<p>The error message given is:</p>\n<p>Lean]<br>\ntype mismatch at application<br>\n  eq.trans (eq.trans (rfl (♭♯datum_or_data.cons p ps)) (rfl (♭(♮⁻¹p) :: ♯ps))) (rfl ?m_2)<br>\nterm<br>\n  rfl ?m_2<br>\nhas type<br>\n  ?m_2 = ?m_2<br>\nbut is expected to have type<br>\n  (♭a :: ♯ps) = ♭a :: ⟨as, h⟩</p>\n<p>Code to support this lemma is: </p>\n<p><code>import data.vector</code></p>\n<p><code>variable {α : Type} \nvariable {x : α}\nvariable {xs : list α} </code></p>\n<p><code>lemma list_len_cancel  {n :ℕ} (h : list.length (x::xs) = n+1)\n: list.length xs = n := nat.succ.inj h -- injectivity of successor </code></p>\n<p><code>inductive datum_or_data {B : Type} : bool → ℕ → Type \n| sg (a : B) :  datum_or_data tt 0\n| nil : datum_or_data ff 0\n| cons {n : ℕ} (a : datum_or_data tt 0) (as : datum_or_data ff n) : datum_or_data ff (n+1)</code></p>\n<p><code>@[reducible] def datum_inv {B : Type} : @datum_or_data B tt 0 → B \n| (datum_or_data.sg x) := x</code></p>\n<p>notation <code>♮</code> x := <a href=\"http://datum_or_data.sg\" target=\"_blank\" title=\"http://datum_or_data.sg\">datum_or_data.sg</a> x<br>\nnotation <code>♮⁻¹</code> a := datum_inv a</p>\n<p><code>@[reducible] definition vector_from_data {B : Type} : Π {n :ℕ }, @datum_or_data B ff n → vector B n \n| 0 _ :=  vector.nil\n| (n+1) (datum_or_data.cons p ps)  := vector.cons (♮⁻¹ p) (vector_from_data ps)</code></p>\n<p><code>@[reducible] definition data_from_vector {B : Type} : Π {n :ℕ }, vector B n → @datum_or_data B ff n\n| 0 _ :=  datum_or_data.nil\n| (n+1) ⟨(a::as), h⟩   := datum_or_data.cons (♮ a) (data_from_vector ⟨as,list_len_cancel h⟩ )</code></p>\n<p>notation <code>♯</code> p := vector_from_data p <br>\nnotation <code>♭</code> v := data_from_vector v</p>\n<p><code>-- inverses \n@[simp] lemma natural {B : Type}: ∀ a : B, (♮⁻¹ (♮ a)) = a := assume a, rfl \n@[simp] lemma natural' {B: Type}: ∀ d : @datum_or_data B tt 0, (♮ (♮⁻¹ d)) = d   \n  | (♮ b) := rfl </code></p>\n<p><code>--prove that flat and sharp are inverses\nlemma flat_sharp {B : Type} : Π {n : ℕ}, ∀ (ps: @datum_or_data B ff n), (♭ (♯ ps)) = ps\n| 0   datum_or_data.nil := rfl \n| (n+1) (datum_or_data.cons p ps) := \nlet ⟨as, h⟩ := ♯ ps, a := ♮⁻¹ p in  --let (⟨as, h⟩ : vector B n) := (♯ ps : vector B n), a := ♮⁻¹ p in\n  calc\n    (♭ (♯ (datum_or_data.cons p ps))) = ♭ (vector.cons (♮⁻¹  p) (♯ ps)) : rfl\n    ...                 = ♭ (vector.cons (a) (♯ ps)) : rfl  --this works\n    ...                 = ♭ (vector.cons (a) (⟨as, h⟩)) : rfl --@rfl (vector B n)   -- this does not work?\n    ...                 = datum_or_data.cons (♮ (a)) (♭ ⟨as, h⟩) : rfl\n    ...                 = datum_or_data.cons p (♭ (♯ ps)) : congr_arg (λ x, datum_or_data.cons x (♭ (♯ ps))) (natural' p)\n    ...                 = datum_or_data.cons p ps : congr_arg (λ x, datum_or_data.cons p x) (flat_sharp ps)</code></p>",
        "id": 127518930,
        "sender_full_name": "Mohammed Eyad Kurd-Misto",
        "timestamp": 1528067894
    },
    {
        "content": "<p>The way you use the let is more like a match statement than a local definition. It works but it makes definitional equality a bit weird.</p>",
        "id": 127519048,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1528068155
    },
    {
        "content": "<p>You might need to use an actual match statement an include an equality lemma in the match expression. I'll just try something and get back to you.</p>",
        "id": 127519100,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1528068245
    },
    {
        "content": "<p>Btw, you might like to know that it's possible to have nice formatting of Lean code by enclosing it in backticks</p>",
        "id": 127519118,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1528068358
    },
    {
        "content": "<p>Thank you, I reformatted the initial post (though the notation portions actually contain backticks in the lean code so I left them as is).</p>",
        "id": 127519350,
        "sender_full_name": "Mohammed Eyad Kurd-Misto",
        "timestamp": 1528068826
    },
    {
        "content": "<p>If you put three ticks before the first line and three after the last, you don't need to format it line by line. Even better: if you put three ticks followed by <code>lean</code>, you get syntax highlighting</p>",
        "id": 127519412,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1528068935
    },
    {
        "content": "<p>What I think you should do is:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">flat_sharp</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">},</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">ps</span><span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">datum_or_data</span> <span class=\"n\">B</span> <span class=\"n\">ff</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"err\">♭</span> <span class=\"o\">(</span><span class=\"err\">♯</span> <span class=\"n\">ps</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">ps</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>   <span class=\"n\">datum_or_data</span><span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">datum_or_data</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">p</span> <span class=\"n\">ps</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">cases</span> <span class=\"n\">h&#39;</span> <span class=\"o\">:</span> <span class=\"err\">♯</span> <span class=\"n\">ps</span> <span class=\"k\">with</span> <span class=\"n\">as</span> <span class=\"n\">h</span> <span class=\"bp\">;</span>\n  <span class=\"k\">calc</span>\n    <span class=\"o\">(</span><span class=\"err\">♭</span> <span class=\"o\">(</span><span class=\"err\">♯</span> <span class=\"o\">(</span><span class=\"n\">datum_or_data</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">p</span> <span class=\"n\">ps</span><span class=\"o\">)))</span> <span class=\"bp\">=</span> <span class=\"err\">♭</span> <span class=\"o\">(</span><span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"err\">♮</span><span class=\"bp\">⁻¹</span>  <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"err\">♯</span> <span class=\"n\">ps</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">...</span>                 <span class=\"bp\">=</span> <span class=\"err\">♭</span> <span class=\"o\">(</span><span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"err\">♯</span> <span class=\"n\">ps</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">rfl</span>   <span class=\"c1\">--this works</span>\n    <span class=\"bp\">...</span>                 <span class=\"bp\">=</span> <span class=\"err\">♭</span> <span class=\"o\">(</span><span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">as</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">rw</span> <span class=\"n\">h&#39;</span>\n    <span class=\"bp\">...</span>                 <span class=\"bp\">=</span> <span class=\"n\">datum_or_data</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"err\">♮</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"err\">♭</span> <span class=\"bp\">⟨</span><span class=\"n\">as</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">...</span>\n</pre></div>",
        "id": 127519472,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1528069028
    },
    {
        "content": "<p>Thank you, I'll look at continuing the proof using cases/rw instead.</p>",
        "id": 127520031,
        "sender_full_name": "Mohammed Eyad Kurd-Misto",
        "timestamp": 1528070108
    }
]
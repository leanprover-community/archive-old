[
    {
        "content": "<p>While investigating the timeouts in <a href=\"https://github.com/leanprover-community/mathlib/pull/15078\">#15078</a>, <span class=\"user-mention\" data-user-id=\"311453\">@Frédéric Dupuis</span> noticed that this was due to a weird instance search. Here is a mwe showing the behavior:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.basic</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.class_instances</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">wtf</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">trivial</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>If you put the cursor on the first <code>have</code> keyword in the proof, you will see that Lean goes on a wild hunt to find a <code>has_coe_to_fun</code> instance for the subtype <code>↥A</code>. And of course fails. The instance search starts with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">class_instances</span><span class=\"o\">]</span>  <span class=\"kd\">class</span><span class=\"bp\">-</span><span class=\"kd\">instance</span> <span class=\"n\">resolution</span> <span class=\"n\">trace</span>\n<span class=\"o\">[</span><span class=\"n\">class_instances</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">x_5</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"bp\">↥</span><span class=\"n\">A</span> <span class=\"bp\">?</span><span class=\"n\">x_4</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">continuous_linear_equiv.has_coe_to_fun</span> <span class=\"bp\">?</span><span class=\"n\">x_6</span> <span class=\"bp\">?</span><span class=\"n\">x_7</span> <span class=\"bp\">?</span><span class=\"n\">x_8</span> <span class=\"bp\">?</span><span class=\"n\">x_9</span> <span class=\"bp\">?</span><span class=\"n\">x_10</span> <span class=\"bp\">?</span><span class=\"n\">x_11</span> <span class=\"bp\">?</span><span class=\"n\">x_12</span> <span class=\"bp\">?</span><span class=\"n\">x_13</span> <span class=\"bp\">?</span><span class=\"n\">x_14</span> <span class=\"bp\">?</span><span class=\"n\">x_15</span> <span class=\"bp\">?</span><span class=\"n\">x_16</span> <span class=\"bp\">?</span><span class=\"n\">x_17</span> <span class=\"bp\">?</span><span class=\"n\">x_18</span> <span class=\"bp\">?</span><span class=\"n\">x_19</span>\n  <span class=\"bp\">?</span><span class=\"n\">x_20</span>\n  <span class=\"bp\">?</span><span class=\"n\">x_21</span>\n<span class=\"n\">failed</span> <span class=\"n\">is_def_eq</span>\n<span class=\"o\">[</span><span class=\"n\">class_instances</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">x_5</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"bp\">↥</span><span class=\"n\">A</span> <span class=\"bp\">?</span><span class=\"n\">x_4</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">continuous_linear_map.to_fun</span> <span class=\"bp\">?</span><span class=\"n\">x_22</span> <span class=\"bp\">?</span><span class=\"n\">x_23</span> <span class=\"bp\">?</span><span class=\"n\">x_24</span> <span class=\"bp\">?</span><span class=\"n\">x_25</span> <span class=\"bp\">?</span><span class=\"n\">x_26</span> <span class=\"bp\">?</span><span class=\"n\">x_27</span> <span class=\"bp\">?</span><span class=\"n\">x_28</span> <span class=\"bp\">?</span><span class=\"n\">x_29</span> <span class=\"bp\">?</span><span class=\"n\">x_30</span> <span class=\"bp\">?</span><span class=\"n\">x_31</span> <span class=\"bp\">?</span><span class=\"n\">x_32</span> <span class=\"bp\">?</span><span class=\"n\">x_33</span> <span class=\"bp\">?</span><span class=\"n\">x_34</span>\n<span class=\"n\">failed</span> <span class=\"n\">is_def_eq</span>\n</code></pre></div>\n<p>There are two things I don't understand here: first, why does the system look for a <code>has_coe_to_fun</code> instance? And second, why doesn't it cache the failure? (You can look at the instance search trace on the second <code>have</code>, it is just as long as for the first one). <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> , do you have some ideas?</p>\n<p>In such a short proof, it's not a real problem, but in a longer proof it makes things really really slow!</p>",
        "id": 291439013,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1659199559
    },
    {
        "content": "<p>For type ascriptions, when there's a type mismatch the elaborator will eventually get to this line <a href=\"https://github.com/leanprover-community/lean/blob/master/src/frontends/lean/elaborator.cpp#L675\">https://github.com/leanprover-community/lean/blob/master/src/frontends/lean/elaborator.cpp#L675</a></p>\n<p>It checks the weak head normal form of the expected type to see if it's a pi type. And in this case, <code>set α</code> is a pi type, so it appears to make a go at it!</p>\n<p>At least, this is what I think is happening. One test would be to create a version of <code>set</code> that's a structure to see if it avoids this behavior.</p>",
        "id": 291439880,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659200476
    },
    {
        "content": "<p>It might seem inconsistent that the typeclass inference starts with <code>has_coe_to_fun ↥A ?x_4</code> (with a metavariable at the expected type) but <code>mk_coercion_to_fn</code> doesn't take an expected type and it uses inference to infer the resulting type. Maybe this metavariable is why the instance failure isn't cached? (I don't know how the cache works.)</p>",
        "id": 291440036,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659200654
    },
    {
        "content": "<p>Thanks for the explanations, they're very convincing. I'm not sure why it doesn't use the expected type, though (and of course <code>set</code> shouldn't be considered a <code>pi</code> type to start with...)</p>",
        "id": 291440362,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1659201093
    },
    {
        "content": "<p>A quick hack would be to tell the elaborator to not consider <code>set</code> to be a pi type when looking for coercions. I'm not sure if that's principled enough of a design...</p>",
        "id": 291440994,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659201803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113488-general/topic/has_coe_to_fun.20instance.20search/near/291440362\">said</a>:</p>\n<blockquote>\n<p>I'm not sure why it doesn't use the expected type, though</p>\n</blockquote>\n<p>I think I get why -- when you have <code>(a : X)</code> you are happy if <code>a</code> coerces to something that has a type defeq to <code>X</code>, but if you give typeclass inference <code>X</code> then it'll force it to find something that's syntactically <code>X</code>.</p>",
        "id": 291441168,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659201996
    }
]
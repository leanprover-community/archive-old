[
    {
        "content": "<p>Massive thanks to <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> for helping me. I'll buy you beers next time we are in the same physical location to within 100m.</p>",
        "id": 131947644,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533981520
    },
    {
        "content": "<p>In the constructor for <code>mvar</code> for <code>expr</code>, are the arguments pretty name, unique name, type? You said that <code>local_const</code>s type argument shouldn't be trusted because its sometimes a placeholder. Is that true for <code>mvar</code>s type arg too?</p>",
        "id": 131948511,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533983051
    },
    {
        "content": "<p>Also in <code>expr</code> what is <code>macro</code> used for?</p>",
        "id": 131948744,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533983483
    },
    {
        "content": "<p>Are they macros in the same sense as C macros?</p>",
        "id": 131948754,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533983521
    },
    {
        "content": "<p>I am not sure about the reliability of <code>mvar</code> types; they aren't found in the local context so probably that's the only place the data is stored, meaning it has to be reliable</p>",
        "id": 131948868,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533983646
    },
    {
        "content": "<p>still, <code>infer_type</code> should always work</p>",
        "id": 131948870,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533983660
    },
    {
        "content": "<p><code>expr.macro</code> is a C++ thing. Those are basically \"promises\" to build an expr by some C++ code, you can't build them in lean</p>",
        "id": 131948884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533983710
    },
    {
        "content": "<p>You can unfold a macro and force it to evaluate</p>",
        "id": 131948888,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533983734
    },
    {
        "content": "<p>They are used for <code>sorry</code>, meta recursive calls (which are not compiled to recursors like the non-meta versions), builtin projections, and they also are ephemeral structures in some specialized tactics</p>",
        "id": 131948951,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533983818
    },
    {
        "content": "<p>What are some examples of meta recursive calls?</p>",
        "id": 131949182,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533984194
    },
    {
        "content": "<p><code>meta def rec := rec</code></p>",
        "id": 131949189,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533984225
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>meta def rec : nat -&gt; nat | x := rec (x + 1)\n</pre></div>",
        "id": 131949232,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533984258
    },
    {
        "content": "<p>What is a builtin projection?</p>",
        "id": 131949263,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533984350
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>structure foo := (mynat : ℕ)\n#print foo.mynat\n\n-- @[reducible]\n-- def foo.mynat : foo → ℕ :=\n-- λ (c : foo), [foo.mynat c]\n</pre></div>\n\n\n<p>the thing in brackets is a macro</p>",
        "id": 131949560,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533984839
    },
    {
        "content": "<p>cool</p>",
        "id": 131949625,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533984938
    },
    {
        "content": "<p>I am reading <code>decalaration.lean</code>. And I came across</p>\n<blockquote>\n<p>Reducibility hints are used in the convertibility checker.<br>\nWhen trying to solve a constraint such a</p>\n<div class=\"codehilite\"><pre><span></span>       (f ...) =?= (g ...)\n</pre></div>\n\n\n<p>where f and g are definitions, the checker has to decide which one will be unfolded.<br>\n  If      f (g) is opaque,     then g (f) is unfolded if it is also not marked as opaque,<br>\n  Else if f (g) is abbrev,     then f (g) is unfolded if g (f) is also not marked as abbrev,<br>\n  Else if f and g are regular, then we unfold the one with the biggest definitional height.<br>\n  Otherwise both are unfolded.</p>\n</blockquote>\n<p>Is there a way I can get programmatic access to the \"definitional height\" of a declaration (other than expanding it and calculating it myself)?</p>",
        "id": 131949675,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533985025
    },
    {
        "content": "<p>Ah it's an argument to <code>regular</code></p>",
        "id": 131949878,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533985377
    },
    {
        "content": "<p>sorry was on the next line.</p>",
        "id": 131949886,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533985404
    },
    {
        "content": "<p>So to get the definitional height you would do</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">env</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">get_env</span>\n<span class=\"n\">defn</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">regular</span> <span class=\"n\">h</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"bp\">_</span>  <span class=\"bp\">&lt;-</span> <span class=\"n\">environment</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"n\">env</span> <span class=\"n\">my_name</span>\n<span class=\"n\">return</span> <span class=\"n\">h</span>\n</pre></div>",
        "id": 131950012,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533985640
    },
    {
        "content": "<p>Is the convertability checker the same thing as the unifier?</p>",
        "id": 131950392,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533986260
    },
    {
        "content": "<p>What's the best way of adding some arbitrary data to the environment?. Eg, I've calculated a table for a tactic and I don't want to regenerate this table for every invocation of the tactic, I just want to retrieve it from the environment somehow.</p>",
        "id": 131950628,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533986646
    },
    {
        "content": "<p>You can make a <code>def</code> containing the data</p>",
        "id": 131951039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533987449
    },
    {
        "content": "<p>makes sense.</p>",
        "id": 131951102,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533987552
    },
    {
        "content": "<p>That is so much more straightforward than the Isabelle way!</p>",
        "id": 131951113,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533987589
    },
    {
        "content": "<p>your ability to store arbitrary data in the environment is limited; for the most part it's just <code>expr</code>s</p>",
        "id": 131951119,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533987598
    },
    {
        "content": "<p>Ideally you would want to store any vm_obj in the environment, but I don't know any way to do that besides reflecting it to an expr</p>",
        "id": 131951166,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533987638
    },
    {
        "content": "<p>I'd make a def with <code>mk_local_def</code> right?</p>",
        "id": 131951168,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533987656
    },
    {
        "content": "<p>no, that's for local constants</p>",
        "id": 131951181,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533987692
    },
    {
        "content": "<p><code>add_meta_definition</code>?</p>",
        "id": 131951225,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533987727
    },
    {
        "content": "<p>oh, I didn't know that one was there, that's useful</p>",
        "id": 131951229,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533987753
    },
    {
        "content": "<p>yes</p>",
        "id": 131951230,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533987756
    },
    {
        "content": "<p>When I reflect to an <code>expr</code>, that means it actually has to build an <code>expr</code> tree which represents the data in some way right? It sounds like one would get performance issues if you wanted to save a gigantic rewrite table or similar.</p>",
        "id": 131951295,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533987870
    },
    {
        "content": "<p>The <code>simp_lemmas</code> data structure is designed for handling big rewrite tables</p>",
        "id": 131951461,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533988191
    },
    {
        "content": "<p>You can cache data in special types inside user attributes as well</p>",
        "id": 131951519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533988237
    },
    {
        "content": "<p><code>simp_lemmas</code> looks good but I can only access the data through calls to <code>simp_lemmas.rewrite</code> so I am stuck with <code>simp</code>s implementation. Not necessarily a showstopper but I can't retrieve arbitrary exprs from it.</p>",
        "id": 131952210,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533989254
    },
    {
        "content": "<p>Please could you give some examples of this?</p>\n<blockquote>\n<p>You can cache data in special types inside user attributes as well</p>\n</blockquote>",
        "id": 131952213,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533989280
    },
    {
        "content": "<p>I'm referring to the <code>cache_ty</code> and <code>param_ty</code> in <code>user_attribute</code>, but it's not really a solution - <code>param_ty</code> has to be reflectable (so it is probably just stored as an <code>expr</code>) and <code>cache_ty</code> needs to be pure-functionally created from the list of all defs with the attribute in the environment (so it can only depend on things that are ultimately <code>expr</code>s). Still that cache has some promise</p>",
        "id": 131952632,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533989823
    },
    {
        "content": "<p>I'm not positive this is actually working the way you would want, but here's the general idea:</p>\n<div class=\"codehilite\"><pre><span></span>structure mydata := (n : nat)\n\n@[user_attribute]\nmeta def mydata_attr : user_attribute (name_map mydata) unit :=\n{ name := `mydata, descr := &quot;stuff&quot;,\n  cache_cfg := ⟨λ l, l.mfoldl (λ m n, do\n    d ← get_decl n,\n    v ← eval_expr mydata d.value,\n    return (m.insert n v)) (name_map.mk _), []⟩ }\n\n@[mydata] def X : mydata := ⟨500^2⟩\n\nrun_cmd do\n  m ← mydata_attr.get_cache,\n  v ← m.find ``X,\n  trace v.n\n</pre></div>",
        "id": 131953023,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533990458
    },
    {
        "content": "<ul>\n<li>In <code>pexpr</code>, has it already disambiguated overloaded operators such as <code>+</code></li>\n</ul>",
        "id": 131954639,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533992834
    },
    {
        "content": "<ul>\n<li>is the process <code>pexpr -&gt; expr</code> called \"elaboration\"?</li>\n</ul>",
        "id": 131954645,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533992851
    },
    {
        "content": "<ul>\n<li>Filling in the implicit arguments of a <code>pexpr</code> is the same problem as finding a proof. So does it make sense to think of the process <code>pexpr -&gt; expr</code> as a kind of tactic driven by the structure of the <code>pexpr</code>?</li>\n</ul>",
        "id": 131954830,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533993151
    },
    {
        "content": "<ul>\n<li>It seems that you can't do <code>pexpr -&gt; expr</code> without recursively infering the types of the subpexprs of the <code>pexpr</code>. Is this right? In which case why not cache all of the types and then you never have to call <code>infer_type</code>? My guess would be that it would take up too much space.</li>\n</ul>",
        "id": 131954891,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533993246
    },
    {
        "content": "<ul>\n<li>Why does the <code>eval_expr α e</code> tactic need to be given the type of <code>e</code> as well?</li>\n</ul>",
        "id": 131955082,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533993577
    },
    {
        "content": "<ul>\n<li>Is the <code>target</code> tactic the same as <code>get_goals &gt;&gt;= (list.head &gt;&gt; return)</code>?</li>\n</ul>",
        "id": 131955226,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533993821
    },
    {
        "content": "<ul>\n<li>The definition of <code>intro</code> is</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span>\n<span class=\"n\">do</span> <span class=\"n\">t</span> <span class=\"err\">←</span> <span class=\"n\">target</span><span class=\"o\">,</span>\n   <span class=\"k\">if</span> <span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">is_pi</span> <span class=\"n\">t</span> <span class=\"bp\">∨</span> <span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">is_let</span> <span class=\"n\">t</span> <span class=\"k\">then</span> <span class=\"n\">intro_core</span> <span class=\"n\">n</span>\n   <span class=\"k\">else</span> <span class=\"n\">whnf_target</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">intro_core</span> <span class=\"n\">n</span>\n</pre></div>\n\n\n<p>But I can't figure out what I am doing wrong in the last two examples below:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">b</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">hello</span><span class=\"o\">,</span>\n    <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">b</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">intro_core</span> <span class=\"n\">hello</span><span class=\"o\">,</span> <span class=\"c1\">-- errors here &quot;unknown identifier &#39;hello&#39;&quot;</span>\n    <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">b</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">whnf_target</span><span class=\"o\">,</span>\n    <span class=\"n\">intro_core</span> <span class=\"n\">hello</span><span class=\"o\">,</span> <span class=\"c1\">-- errors here &quot;unknown identifier &#39;hello&#39;&quot;</span>\n    <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 131955636,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533994734
    },
    {
        "content": "<ul>\n<li>Does <code>get_unused_name n</code> just check if <code>n</code> is currently being used, and if not, sticks an <code>_1</code>/ <code>_2</code>/... on the end?</li>\n</ul>",
        "id": 131956067,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533995624
    },
    {
        "content": "<ul>\n<li>If I invoke <code>local_context</code>, will that always be a list of <code>local_const</code>s or are there ways of getting other forms of <code>expr</code> in the context?</li>\n</ul>",
        "id": 131956115,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533995692
    },
    {
        "content": "<p>I can try to save Mario some time and answer a few of these....</p>\n<blockquote>\n<ul>\n<li>In <code>pexpr</code>, has it already disambiguated overloaded operators such as <code>+</code></li>\n</ul>\n</blockquote>\n<p>No. But note that <code>+</code> isn't \"overloaded,\" exactly. <code>+</code> is notation for <code>has_add.add</code> which applies to any type with a <code>has_add</code> type class instance. A <code>pexpr</code> using <code>+</code> hasn't filled in the implicit type or the instance yet. And for notation that really is overloaded, a <code>pexpr</code> will represent the ambiguity with a macro, I think.</p>",
        "id": 131956118,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1533995703
    },
    {
        "content": "<blockquote>\n<ul>\n<li>is the process <code>pexpr -&gt; expr</code> called \"elaboration\"?</li>\n</ul>\n</blockquote>\n<p>Yes.</p>",
        "id": 131956125,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1533995712
    },
    {
        "content": "<blockquote>\n<ul>\n<li>Filling in the implicit arguments of a <code>pexpr</code> is the same problem as finding a proof. So does it make sense to think of the process <code>pexpr -&gt; expr</code> as a kind of tactic driven by the structure of the <code>pexpr</code>?</li>\n</ul>\n</blockquote>\n<p>Yeah, I guess. Notice the tactic <code>to_expr</code> does exactly this.</p>",
        "id": 131956131,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1533995746
    },
    {
        "content": "<blockquote>\n<ul>\n<li>It seems that you can't do <code>pexpr -&gt; expr</code> without recursively infering the types of the subpexprs of the <code>pexpr</code>. Is this right? In which case why not cache all of the types and then you never have to call <code>infer_type</code>? My guess would be that it would take up too much space.</li>\n</ul>\n</blockquote>\n<p>Are you asking why each <code>expr</code> object doesn't store its type? Yeah, this would take up a huge amount of space.</p>",
        "id": 131956175,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1533995800
    },
    {
        "content": "<blockquote>\n<ul>\n<li>Why does the <code>eval_expr α e</code> tactic need to be given the type of <code>e</code> as well?</li>\n</ul>\n</blockquote>\n<p>I'm not 100% clear on how <code>eval_expr</code> works, but here's my intuition, anyway. If you didn't give the expected type, you'd have to \"guess\" it by inferring the type of <code>e</code>, which would give you an <code>expr</code>, not a type. You need a way to go from this <code>expr</code> to a type, which is why you have the <code>[reflected α]</code> instance.</p>",
        "id": 131956234,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1533995910
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">b</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">intro_core</span> <span class=\"n\">hello</span><span class=\"o\">,</span> <span class=\"c1\">-- errors here &quot;unknown identifier &#39;hello&#39;&quot;</span>\n    <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 131956301,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1533996009
    },
    {
        "content": "<blockquote>\n<ul>\n<li>Is the <code>target</code> tactic the same as <code>get_goals &gt;&gt;= (list.head &gt;&gt; return)</code>?</li>\n</ul>\n</blockquote>\n<p>I think, roughly. It's the type of the first goal metavariable.</p>",
        "id": 131956302,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1533996023
    },
    {
        "content": "<blockquote>\n<ul>\n<li>The definition of <code>intro</code> is</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span>\n<span class=\"n\">do</span> <span class=\"n\">t</span> <span class=\"err\">←</span> <span class=\"n\">target</span><span class=\"o\">,</span>\n   <span class=\"k\">if</span> <span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">is_pi</span> <span class=\"n\">t</span> <span class=\"bp\">∨</span> <span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">is_let</span> <span class=\"n\">t</span> <span class=\"k\">then</span> <span class=\"n\">intro_core</span> <span class=\"n\">n</span>\n   <span class=\"k\">else</span> <span class=\"n\">whnf_target</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">intro_core</span> <span class=\"n\">n</span>\n</pre></div>\n\n\n<p>But I can't figure out what I am doing wrong in the last two examples below:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">b</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">hello</span><span class=\"o\">,</span>\n    <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">b</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">intro_core</span> <span class=\"n\">hello</span><span class=\"o\">,</span> <span class=\"c1\">-- errors here &quot;unknown identifier &#39;hello&#39;&quot;</span>\n    <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">b</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">whnf_target</span><span class=\"o\">,</span>\n    <span class=\"n\">intro_core</span> <span class=\"n\">hello</span><span class=\"o\">,</span> <span class=\"c1\">-- errors here &quot;unknown identifier &#39;hello&#39;&quot;</span>\n    <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n</blockquote>\n<p>You've noticed the difference between the tactic monad and \"interactive mode.\" When you're using tactics for proofs, in begin/end blocks, they get parsed differently than when you're writing tactics. The <code>intro</code> in begin/end is actually tactic.interactive.intro.</p>",
        "id": 131956314,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1533996097
    },
    {
        "content": "<blockquote>\n<p>I think, roughly. It's the type of the first goal metavariable.</p>\n</blockquote>\n<p>The docs for <code>target</code> confused me because they say it returns the \"main goal\" but this seems to always be the first goal.</p>",
        "id": 131956358,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1533996128
    },
    {
        "content": "<p><code>intro_core</code> isn't an interactive tactic. It expects a name, which you'd have to give in the form <code> `hello </code>.</p>",
        "id": 131956359,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1533996131
    },
    {
        "content": "<p><code>tactic.intro</code> expects the same. <code>tactic.interactive.intro</code> expects some text to follow that it will parse into a name.</p>",
        "id": 131956373,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1533996180
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">b</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">intro_core</span> <span class=\"n\">hello</span><span class=\"o\">,</span> <span class=\"c1\">-- errors here &quot;unknown identifier &#39;hello&#39;&quot;</span>\n    <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>The <code>intro</code> in a <code>begin end</code> block is <code>tactic.interactive.intro</code>not <code>tactic.intro</code>. I don't know if this helps or whether you're already way ahead of this, but it was something that confused me for a while.</p>\n<p>PS just beaten to it by Rob :-)</p>",
        "id": 131956386,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1533996206
    },
    {
        "content": "<p>the \"main goal\" is the first goal</p>",
        "id": 131956462,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533996326
    },
    {
        "content": "<blockquote>\n<ul>\n<li>If I invoke <code>local_context</code>, will that always be a list of <code>local_const</code>s or are there ways of getting other forms of <code>expr</code> in the context?</li>\n</ul>\n</blockquote>\n<p>I think it's only <code>local_const</code> exprs, yes.</p>",
        "id": 131956469,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1533996350
    },
    {
        "content": "<blockquote>\n<ul>\n<li>Does <code>get_unused_name n</code> just check if <code>n</code> is currently being used, and if not, sticks an <code>_1</code>/ <code>_2</code>/... on the end?</li>\n</ul>\n</blockquote>\n<p>This one I'm not sure, I've never really paid attention. It will give you a name that starts with <code>n</code> that won't conflict with anything.</p>",
        "id": 131956568,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1533996493
    },
    {
        "content": "<blockquote>\n<p>Why does the eval_expr α e tactic need to be given the type of e as well?</p>\n</blockquote>\n<p>This is done for typechecking purposes. You are given <code>e</code> which is an <code>expr</code>, but you want to return something of type <code>α</code>. What is <code>α</code>? You would need to have a function <code>e.type : expr -&gt; Type</code> to define \"the type of <code>e</code>\", but that doesn't work because of universe issues. So instead you just assert the type you want and lean checks it (I think, maybe it just crashes if you got it wrong)</p>",
        "id": 131956570,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533996509
    },
    {
        "content": "<p>could <code>has_one.one</code> be an example of an <code>expr</code>? Or some such thing? I'm wondering when Lean decides that <code>1</code> should be a natural if it can't think of any better ideas.</p>",
        "id": 131956630,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1533996633
    },
    {
        "content": "<p><code>has_one.one</code> has a big pi type, but <code> `(has_one.one)</code> is an expr</p>",
        "id": 131956680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533996735
    },
    {
        "content": "<p>I think it's specifically numerals that default to <code>nat</code> if there's no other information, right? This happens at elaboration time.</p>",
        "id": 131956690,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1533996784
    },
    {
        "content": "<p>What's the best way to discover if <code>expr</code> e has form <code>Exists (a : A), B a</code>? Or alternatively <code>Exists p</code>?</p>",
        "id": 131962977,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534008786
    },
    {
        "content": "<p>One simple way is to do:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">do</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Exists</span> <span class=\"err\">%%</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">pure</span> <span class=\"n\">e</span> <span class=\"bp\">|</span> <span class=\"n\">fail</span> <span class=\"s2\">&quot;e is in bad shape&quot;</span><span class=\"o\">,</span>\n       <span class=\"c1\">-- do stuff with `p`</span>\n</pre></div>",
        "id": 131963019,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1534008869
    },
    {
        "content": "<ul>\n<li>Am I right in thinking that <code>rbtree</code> doesn't come with function to remove items from it?</li>\n</ul>",
        "id": 131999207,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534083819
    },
    {
        "content": "<p>I... guess you're right</p>",
        "id": 131999315,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534084069
    },
    {
        "content": "<p>that's a bit annoying, I was hoping not to have to touch <code>rbtree</code></p>",
        "id": 131999368,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534084106
    },
    {
        "content": "<p>Could I use <code>rb_map</code>, which does have this?</p>",
        "id": 132001112,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534087541
    },
    {
        "content": "<p>If I do <code>a &lt;|&gt; b</code> for the <code>option</code> type, will the VM not evaluate <code>b</code> if <code>a</code> is <code>some _</code>?</p>",
        "id": 132002458,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534090420
    },
    {
        "content": "<p>Is anyone doing 23 trees in mathlib?</p>",
        "id": 132004998,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534094941
    },
    {
        "content": "<p>I've started coding it up</p>",
        "id": 132005004,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534094955
    },
    {
        "content": "<p>Is it maths?</p>",
        "id": 132005866,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1534096787
    },
    {
        "content": "<p>It's a datastructure</p>",
        "id": 132006154,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534097221
    },
    {
        "content": "<p>like rbtree</p>",
        "id": 132006159,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534097227
    },
    {
        "content": "<p>Is there a way to have conditionals in <code>match</code> statements? Eg something like:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">y</span><span class=\"o\">)</span>  <span class=\"n\">where</span>  <span class=\"n\">y</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">5</span> <span class=\"o\">:=</span> <span class=\"s2\">&quot;hello&quot;</span>\n<span class=\"bp\">|_</span> <span class=\"o\">:=</span> <span class=\"s2\">&quot;nope&quot;</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 132012981,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534111863
    },
    {
        "content": "<p><code>\"nope\"</code></p>",
        "id": 132013028,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1534111947
    },
    {
        "content": "<p>No conditions built into <code>match</code></p>",
        "id": 132013031,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1534111969
    },
    {
        "content": "<blockquote>\n<p>If I do a &lt;|&gt; b for the option type, will the VM not evaluate b if a is some _?</p>\n</blockquote>\n<p>It will evaluate both sides, unless <code>option.orelse</code> is inlined. If you want to avoid this, you can make an <code>option.orelse'</code> that takes a <code>thunk (option A)</code> for its second argument</p>",
        "id": 132015917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534118405
    },
    {
        "content": "<blockquote>\n<p>Is anyone doing 23 trees in mathlib? I've started coding it up</p>\n</blockquote>\n<p>I have no current plans for this, go ahead. We would be happy to take it</p>",
        "id": 132015937,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534118438
    },
    {
        "content": "<blockquote>\n<p>Is there a way to have conditionals in match statements?</p>\n</blockquote>\n<p>No, as Simon said; although in this case you can write the following:</p>\n<div class=\"codehilite\"><pre><span></span>match x with\n| (some (y+6)) := &quot;hello&quot;\n| _ := &quot;nope&quot;\nend\n</pre></div>\n\n\n<p>I would recommend just using <code>if</code> though.</p>",
        "id": 132015940,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534118457
    },
    {
        "content": "<p>What if he gets tired towards the middle of the task, and ends up with 11 trees instead of 23?</p>",
        "id": 132015956,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1534118483
    },
    {
        "content": "<p>That's a linked list. We won't be so welcoming because we have those.</p>",
        "id": 132016137,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1534118851
    },
    {
        "content": "<p>Damn it. What was the probability that roughly cutting in half the number 23 would lead to another meaningful sentence?</p>",
        "id": 132016190,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1534118955
    },
    {
        "content": "<p>Btw, why do we want 2-3 trees while we have red-back trees? What do you get from 2-3 trees that you don't get from red-black trees?</p>",
        "id": 132016191,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1534118957
    },
    {
        "content": "<p>I guess with 12 trees he will have a trie</p>",
        "id": 132016192,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534118960
    },
    {
        "content": "<p>different performance characteristics... I'm okay with implementing datastructures for their own sake because of this</p>",
        "id": 132016239,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534119043
    },
    {
        "content": "<p>but it's true that rb trees already implement the same API as it were, so if you are a programmer who needs a map type and doesn't want to bother with writing data structures you can use them instead</p>",
        "id": 132016289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534119156
    },
    {
        "content": "<p>As I understand it, a red-black tree is basically a 2-3 tree where the balancing invariant is formulated in terms of tree height instead of node degree, that's why I'm surprised it would get a different performance profile</p>",
        "id": 132016293,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1534119184
    },
    {
        "content": "<p>From <a href=\"https://www.cs.purdue.edu/homes/ayg/CS251/slides/chap13b.pdf\" target=\"_blank\" title=\"https://www.cs.purdue.edu/homes/ayg/CS251/slides/chap13b.pdf\">https://www.cs.purdue.edu/homes/ayg/CS251/slides/chap13b.pdf</a> , it seems like 2-3 trees or 2-3-4 trees are actually just simpler versions of rb trees</p>",
        "id": 132016412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534119472
    },
    {
        "content": "<p>the advantage of rb trees is normalizing the node layout, but this doesn't matter when you are writing inductives in lean</p>",
        "id": 132016455,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534119519
    },
    {
        "content": "<p>Huh, that's an interesting slide format</p>",
        "id": 132016680,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1534120064
    },
    {
        "content": "<blockquote>\n<p>Huh, that's an interesting slide format</p>\n</blockquote>\n<p>Judging by the name of the pdf, this might be a chapter from a book, and books are still traditionally in portrait format I guess.</p>",
        "id": 132037220,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1534155797
    },
    {
        "content": "<p>Those are definitely slides, but more like old-school ones for overhead projectors.</p>",
        "id": 132038925,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1534158122
    },
    {
        "content": "<p>Maybe Sebastian was referring to the Batman delirium at the end</p>",
        "id": 132038975,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1534158182
    },
    {
        "content": "<p>Yes I'm just treating making 23 trees as another exercise. I copied the implementation details from Isabelle and then added dependent types to it. I managed to prove that my trees are balanced using just dependent types (each node has a height param in its type). It was fun to see that it worked and I learned a lot. I made no considerations for performance so <code>rbtree</code> is still better and more concise. The deletion algo for 23 trees is horrifying so there is likely a mistake in there, but at least I proved that it's balanced!</p>\n<p>Here is a link to the source but I've made no attempt to make it readable yet. I haven't even tested it. <br>\n<a href=\"https://github.com/EdAyers/mathlib/blob/tree23/data/tree23.lean\" target=\"_blank\" title=\"https://github.com/EdAyers/mathlib/blob/tree23/data/tree23.lean\">https://github.com/EdAyers/mathlib/blob/tree23/data/tree23.lean</a></p>\n<p>Some thoughts from doing this,<br>\n- It can be difficult to decide which typeclasses to use. Should I use <code>linear_order</code>? <code>decidable_rel</code>? And so on.<br>\n- The coercions from <code>decidable</code> to if statements are kind of magical.<br>\n-  There is a lemma <code>lt_min_key_imp_outside</code> which I basically did by taking a random walk through the space of valid tactics until <code>no goals</code> appeared. Any tips on how this can be tightened up would be appreciated.<br>\n- Proving anything about the <code>del</code> method will be a nightmare. So if the deletion method for rb trees is simpler then I am happy to abandon these.<br>\n- The main thing I learnt is that you are much better off using non-dependent-type driven datatypes and then restricting with propositions at the end. Using dependent types just makes coding too tedious.</p>",
        "id": 132062075,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534183194
    },
    {
        "content": "<p>I also had an attempt at proving some things about <code>rbtree</code>s but it is very tedious. I think that I am not using the automation very effectively.</p>",
        "id": 132062193,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534183312
    },
    {
        "content": "<p>I'm going to use <code>native.rb_tree</code> in the future instead, but I don't regret implementing this because it taught me a lot about Lean.</p>",
        "id": 132062277,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534183411
    },
    {
        "content": "<p>My dream was that I wouldn't have to write tests for my code, because I could just prove that it is correct!</p>",
        "id": 132062574,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534183781
    },
    {
        "content": "<p>Have you put your code somewhere on github. We can look at it to see if we can make your proving more effective</p>",
        "id": 132062764,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1534183952
    },
    {
        "content": "<p>yes see link above in this thread</p>",
        "id": 132062860,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534184055
    },
    {
        "content": "<p><a href=\"https://github.com/EdAyers/mathlib/blob/tree23/data/tree23.lean\" target=\"_blank\" title=\"https://github.com/EdAyers/mathlib/blob/tree23/data/tree23.lean\">https://github.com/EdAyers/mathlib/blob/tree23/data/tree23.lean</a></p>",
        "id": 132062870,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534184069
    },
    {
        "content": "<p>I'll push the rbtree experiments in a few hours.</p>",
        "id": 132062916,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534184132
    },
    {
        "content": "<p>Why is it that <code>#check λ x, x + 1</code> is <code> ℕ → ℕ</code> and not <code>[has_add ?m] [has_one ?m] ?m -&gt; ?m</code></p>",
        "id": 132190818,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534357284
    },
    {
        "content": "<p>What is causing the elaborator to default to <code>nat</code>?</p>",
        "id": 132190837,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534357312
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 132190906,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1534357346
    },
    {
        "content": "<p>I think <code>1</code> is default to <code>nat</code></p>",
        "id": 132190908,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1534357349
    },
    {
        "content": "<p>Right but where is the defaultness set?</p>",
        "id": 132191067,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534357508
    },
    {
        "content": "<p>At some point in the elaboration process, Lean <em>sometimes</em> says \"if I can't figure out what that 1 is, I'm going to assume it's a nat\". I think the point this occurs is near the end, if at all. Maybe you can even concoct something where <code>example</code> behaves differently to <code>definition</code> using this sort of thing.</p>",
        "id": 132191292,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1534357751
    },
    {
        "content": "<p>(deleted nonsense)</p>",
        "id": 132191371,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1534357805
    },
    {
        "content": "<p>Perhaps <code>1</code> is always <code>nat</code>, and there is a type coercion from <code>nat</code> to all of the other kinds of numbers?</p>",
        "id": 132191517,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534357946
    },
    {
        "content": "<p>That's not how it works, I'm pretty sure.</p>",
        "id": 132191535,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1534357968
    },
    {
        "content": "<p>Unfortunately, as I found out earlier this week, it's very difficult to switch the number literal parser off.</p>",
        "id": 132191555,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1534357995
    },
    {
        "content": "<p><code>1</code> is <code>has_one.one</code></p>",
        "id": 132191572,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1534358023
    },
    {
        "content": "<p>The thing I can't figure out is if the <code>nat</code> default is set somewhere in <code>init</code> or whether it is baked in to the elaborator.</p>",
        "id": 132191626,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534358051
    },
    {
        "content": "<p>I think it is baked into the elaborator. I think that <code>#check</code> cannot possibly return <code>[has_add ?m] [has_one ?m] ...</code> because I don't think Lean thinks these are part of the expression.</p>",
        "id": 132191902,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1534358379
    },
    {
        "content": "<p>So eventually it gets to a point where it can't figure out where this type class inference thing is coming from and at that point it decides it's going to go for nat. You should check all this with an expert.</p>",
        "id": 132191960,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1534358409
    },
    {
        "content": "<p>The nat default is baked into the elaborator, but it is not necessary for it to operate</p>",
        "id": 132192958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534359499
    },
    {
        "content": "<p>it could just as easily return <code>?m -&gt; ?m</code>, and there would be (hidden) subgoals for those typeclasses</p>",
        "id": 132192998,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534359546
    },
    {
        "content": "<blockquote>\n<p>Perhaps 1 is always nat, and there is a type coercion from nat to all of the other kinds of numbers?</p>\n</blockquote>\n<p>Lean used to work like this, but the current version uses a polymorphic 1 function</p>",
        "id": 132193030,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534359587
    },
    {
        "content": "<p>I find the nat default distateful precisely because it's the only thing about lean definitions which is not configured within lean</p>",
        "id": 132193177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534359689
    },
    {
        "content": "<p>if kevin decided to write his own core.lean with <code>xnat</code>, lean would probably complain</p>",
        "id": 132193240,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534359723
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean/blob/master/src/frontends/lean/elaborator.cpp#L3609-L3610\" target=\"_blank\" title=\"https://github.com/leanprover/lean/blob/master/src/frontends/lean/elaborator.cpp#L3609-L3610\">https://github.com/leanprover/lean/blob/master/src/frontends/lean/elaborator.cpp#L3609-L3610</a></p>",
        "id": 132193396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534359908
    },
    {
        "content": "<p>I can see why Leo did this though, since <code>nat</code> is initial with respect to <code>has_one</code> and <code>has_add</code> so you don't really lose any generality by doing this and 90% of the time you mean <code>nat</code> anyway.</p>",
        "id": 132241830,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534428716
    },
    {
        "content": "<p>note again that lean does <em>not</em> use anything like <code>nat.cast</code> to get an arbitrary value of type <code>A</code> from a nat</p>",
        "id": 132242032,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534428893
    },
    {
        "content": "<p>If you type <code>4 : A</code>, it is translated by the parser to <code>bit0 (bit0 1)</code>, where <code>bit0</code> and <code>has_one.one</code> are polymorphic functions</p>",
        "id": 132242070,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534428941
    },
    {
        "content": "<p>this term will make absolutely no reference to <code>nat</code></p>",
        "id": 132242083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534428956
    },
    {
        "content": "<p>The reason this was done, I believe, is that without a default type being assigned as a last resort, you can never write a numeral without a type ascription somewhere, so a beginner will type <code>#eval 2 + 2</code> and get a weird error message instead of the obvious answer</p>",
        "id": 132242194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534429072
    },
    {
        "content": "<p>What is the difference between synthesizing and elaborating?</p>",
        "id": 132242196,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534429075
    },
    {
        "content": "<p>My guess is synthesizing is when the elaborator tries to guess an expr for a given type sig</p>",
        "id": 132242261,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534429118
    },
    {
        "content": "<p>I'm not sure there is a difference, they are both fairly general terms</p>",
        "id": 132242270,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534429145
    },
    {
        "content": "<p>elaboration is broadly the process of taking a parsed pre-expression, an AST, and including and inferring all missing type information to make it a valid term of the formal logic</p>",
        "id": 132242360,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534429207
    },
    {
        "content": "<p>synthesis is just what you call putting data into one of these holes</p>",
        "id": 132242385,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534429255
    },
    {
        "content": "<p>Ok. So when you make the proof to a lemma by writing out a proof term. Making that a valid <code>expr</code> is elaboration. Does the process of making a valid proof term using <code>begin ... end</code> also count as elaboration?</p>",
        "id": 132242406,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534429305
    },
    {
        "content": "<p>There are multiple methods used by the elaborator to synthesize expressions, but the major workhorses are unification and typeclass inference</p>",
        "id": 132242407,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534429310
    },
    {
        "content": "<p>I'm not sure I would call tactic evaluation a part of elaboration, but it occurs in the middle of the elaboration cycle, yes</p>",
        "id": 132242482,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534429370
    },
    {
        "content": "<p>you could view the tactic framework as a giant plugin to the elaborator</p>",
        "id": 132242512,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534429405
    },
    {
        "content": "<p>Yes that's how I'm viewing it. It's a beautiful way of doing it.</p>",
        "id": 132242526,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534429440
    },
    {
        "content": "<p>When I write <code>def asdf (myarg : mytype . mytactic) : ... := ...</code>. I can't quite figure out what the tactic is doing. Is Lean making a tactic state with the goal as <code>mytype</code> and <code>myarg</code> as a local constant?</p>",
        "id": 132242701,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534429592
    },
    {
        "content": "<p>So I use this by writing <code>asdf (myvalue)</code>. Or is the idea that the <code>mytactic</code> should be used to synthesize <code>myarg</code> if it is not provided explicitly?</p>",
        "id": 132242779,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534429672
    },
    {
        "content": "<p>Also, <code>expr</code> has the argument <code>elaborated := tt</code>. I am guessing that <code>expr tt</code> is a term that has been elaborated, and hence is valid. Whereas a <code>expr ff</code> has not been checked to be valid, eg I just made a nonsense term myself from the <code>expr</code> constructors. So <code>expr ff</code>/<code>expr tt</code> is like <code>term</code>/<code>cterm</code> in Isabelle.</p>",
        "id": 132243188,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534429988
    },
    {
        "content": "<p>But then I can make <code>expr tt</code> from the <code>expr</code> constructors too, so that can't be it.</p>",
        "id": 132243213,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534430018
    },
    {
        "content": "<p>But in that case I can't see what the difference could be between <code>expr tt</code> and <code>expr ff</code>.</p>",
        "id": 132243275,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534430051
    },
    {
        "content": "<blockquote>\n<p>Or is the idea that the mytactic should be used to synthesize myarg if it is not provided explicitly?</p>\n</blockquote>\n<p>this</p>",
        "id": 132243775,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534430460
    },
    {
        "content": "<p>it is a variant on optional parameters where the default value is synthesized by a tactic</p>",
        "id": 132243807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534430488
    },
    {
        "content": "<blockquote>\n<p>Whereas a expr ff has not been checked to be valid, eg I just made a nonsense term myself from the expr constructors. </p>\n</blockquote>\n<p>Not quite. <code>expr ff</code> is the same as <code>pexpr</code>, and it represents those pre-expressions I mentioned</p>",
        "id": 132243887,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534430540
    },
    {
        "content": "<p>So an <code>expr ff</code> can have wildcard holes in it?</p>",
        "id": 132243924,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534430588
    },
    {
        "content": "<p>They actually differ from <code>expr</code> structurally, i.e. if I write <code>x + y</code> then the <code>pexpr</code> for this is <code>has_add.add x y</code> with 2 arguments, and the <code>expr</code> is <code>has_add.add ?m1 ?m2 x y</code> or <code>has_add.add nat nat.has_add x y</code> with 4 arguments</p>",
        "id": 132243941,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534430622
    },
    {
        "content": "<p>nice</p>",
        "id": 132244028,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534430692
    },
    {
        "content": "<p>they could have been defined as separate inductive types, but they share enough of the major structure that it seemed redundant</p>",
        "id": 132244041,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534430704
    },
    {
        "content": "<p>lean 4 will have these separate, with <code>pexpr</code> becoming <code>syntax</code> which is completely different</p>",
        "id": 132244073,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534430745
    },
    {
        "content": "<p>it will be much more like an AST for lean</p>",
        "id": 132244129,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534430773
    },
    {
        "content": "<p>Ah I just found <code>@[reducible] meta def pexpr := expr ff</code> in source</p>",
        "id": 132244157,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534430806
    },
    {
        "content": "<p><code>meta constant pexpr.mk_placeholder : pexpr</code> seems to be the magic <code>constant</code> that lets you do placeholders. You can't use metavariables because you might not be in a tactic monad so you can't make fresh ones.</p>",
        "id": 132244276,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534430890
    },
    {
        "content": "<p>mk_placeholder is basically the AST corresponding to <code>_</code> as a token</p>",
        "id": 132244306,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534430917
    },
    {
        "content": "<p>Am I right in thinking that <em>the</em> placeholder is distinct from metavars, but elaborating a <code>pexpr</code> turns these into metavars?</p>",
        "id": 132244319,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534430925
    },
    {
        "content": "<p>there is only one, and it is elaborated to a new metavariable every time</p>",
        "id": 132244328,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534430932
    },
    {
        "content": "<p>Will the elaborator for Lean 4 be written in Lean rather than C++?</p>",
        "id": 132244555,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534431101
    },
    {
        "content": "<p>parser yes, elaborator maybe</p>",
        "id": 132244569,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534431119
    },
    {
        "content": "<p>That would blow my mind</p>",
        "id": 132244612,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534431124
    },
    {
        "content": "<p>I think the idea is to completely self host</p>",
        "id": 132244634,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534431140
    },
    {
        "content": "<p>I can't wait for Lean 4</p>",
        "id": 132244638,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534431143
    },
    {
        "content": "<p>but it's hard, not the least because the lean VM is currently not efficient enough to support this</p>",
        "id": 132244653,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534431174
    },
    {
        "content": "<p>so they will need to implement a real lean compiler to machine code</p>",
        "id": 132244670,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534431198
    },
    {
        "content": "<p>To do the elaborator in Lean you would need some kind of super simple bootstrap elaborator in C++ with everything explicit and build up from there.</p>",
        "id": 132244677,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534431210
    },
    {
        "content": "<p>even in core lean for much of the files you don't have the tactic framework set up yet so it's all explicit terms</p>",
        "id": 132244767,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534431266
    },
    {
        "content": "<p>I don't know exactly how the full bootstrap process would work, it might just run itself on the previous version of lean to avoid messy business</p>",
        "id": 132244804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534431316
    },
    {
        "content": "<p>Right but then you can't build Lean from scratch which would be sad, you would then need to maintain both C++ and Lean elaborators.</p>",
        "id": 132244873,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534431396
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> can tell you more about the extent of current bootstrapping plans</p>",
        "id": 132245452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1534431965
    },
    {
        "content": "<p>I'm reading through the kernel code. Let me just write down what I think is happening and then I can be corrected.<br>\n- <code>expr.cpp</code> is doing roughly the same thing as <code>expr.lean</code>, just a big inductive type with helper methods.<br>\n- <code>type_checker</code> infers the type for a given <code>expr</code> or throws if it isn't a valid expr. Saying that a given <code>expr</code> typechecks is equivalent to saying that the <code>expr</code> can be built just using the inference rules of CIC (up to being able to synthesize metavars later). <br>\n- You inject a <code>normalizer_extension</code> into the kernel to dictate how the typechecker should put terms in WHNF. If there is a bug in the injected <code>normalizer_extension</code> then the kernel will be compromised too. So quotients and inductives are normalizer_extensions.<br>\n- So the kernel is happy when it is given an environment, which is an ordered dictionary of declarations indexed by <code>name</code>, and all of the declarations' <code>expr</code>s typecheck.</p>",
        "id": 132248684,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534435144
    },
    {
        "content": "<p>In the <a href=\"https://leanprover.github.io/papers/system.pdf\" target=\"_blank\" title=\"https://leanprover.github.io/papers/system.pdf\">system description</a> for Lean it says that the typechecker can also produce unification constraints, but this feature doesn't seem to be in the<code>type_checker.h</code>, although I could not be reading thoroughly enough, where is the code that does type_checking and also spits out some unification constraints?</p>",
        "id": 132249735,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534436260
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"121918\">@Edward Ayers</span> You have to go back in time to see the unification constraints :) <a href=\"https://github.com/leanprover/lean/blob/CADE25/src/kernel/type_checker.h\" target=\"_blank\" title=\"https://github.com/leanprover/lean/blob/CADE25/src/kernel/type_checker.h\">https://github.com/leanprover/lean/blob/CADE25/src/kernel/type_checker.h</a><br>\nWe abandoned this approach in Lean 3. Now, the kernel type checker is simpler and has no support for meta-variables (unification variables). The elaborator uses a different module for inferring types and solving unification constraints.</p>",
        "id": 132250626,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1534437150
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> </p>\n<blockquote>\n<p>I don't know exactly how the full bootstrap process would work, it might just run itself on the previous version of lean to avoid messy business</p>\n</blockquote>\n<p>Yes, this is how all bootstrapping compilers work. But instead of a binary file, we want to store the previous version as extracted C++ code, which should be at least slightly more inspectable and git-friendly</p>",
        "id": 132250884,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1534437464
    },
    {
        "content": "<p>Thanks Leo. Also <code>elab_context.h</code> is confusing me. The comment talks about <code>tactic_context</code>. But I can't find any other mentions of <code>tactic_context</code>. I also can't spot the definition of <code>type_context</code>, only <code>type_context_old</code></p>",
        "id": 132250969,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534437550
    },
    {
        "content": "<p>I'm really keen to see the C++ code that is used to keep track of metavariables, local context and so on while a tactic or elaborator is being run. It seems to be <code>type_context_old</code> but I'm not sure because of the <code>old</code> suffix.</p>",
        "id": 132252758,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534439524
    },
    {
        "content": "<p><code>type_context</code> was renamed to <code>type_context_old</code> in the preparation of the changes for Lean 4.  You should really be looking at <code>type_context_old</code>, it was the <code>type_context</code> for most of Lean 3.</p>",
        "id": 132252927,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1534439683
    },
    {
        "content": "<p>In the <code>type_context.h</code> there is a large comment starting with <code>NEW DESIGN notes. (This is work in progress)</code>, is this how Lean 3 works or is it how Lean 4 works?</p>",
        "id": 132253032,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534439772
    },
    {
        "content": "<p>This is a change that was introduced late in Lean 3, and the todo is also implemented now with the <code>unfreeze_local_intstances</code> tactic.</p>",
        "id": 132253156,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1534439915
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"121918\">@Edward Ayers</span> I recommend you start using different topics for your different questions so that other people may determine at a glance if the discussion is relevant to what they're working on.</p>",
        "id": 132253773,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1534440499
    },
    {
        "content": "<p>ok will do</p>",
        "id": 132253799,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1534440528
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 132253828,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1534440557
    },
    {
        "content": "<p>I like the question barrage :-) but I do see Simon's logic. I often start new threads with more descriptive titles now and it works better for search when I come back to them later.</p>",
        "id": 132257907,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1534444840
    }
]
[
    {
        "content": "<p>Within a match/case propositions are modified so that the pattern is replaced, but is it possible to peform the same rewriting to an outer predicate to get the inner predicate?</p>\n<p>In particular the situation I have is this in this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">decidable_fin</span>\n<span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">DecidablePred</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n<span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Decidable.isFalse</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">existsI</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">Exists.elim</span> <span class=\"o\">(</span><span class=\"n\">existsI</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Fin.elim0</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">m_lt_n</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">Nat_lt_succ</span> <span class=\"n\">m</span>\n    <span class=\"bp\">@</span><span class=\"n\">Decidable.byCases</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n      <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">(</span><span class=\"n\">Fin.mk</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">m_lt_n</span><span class=\"o\">)))</span>\n      <span class=\"c\">/-</span><span class=\"cm\"> If the max element of Fin n is sufficient then we're done -/</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">p_m</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Decidable.isTrue</span> <span class=\"o\">(</span>\n        <span class=\"n\">Exists.intro</span>\n          <span class=\"o\">(</span><span class=\"n\">Fin.mk</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">Nat_lt_succ</span> <span class=\"n\">m</span><span class=\"o\">))</span>\n          <span class=\"c\">/-</span><span class=\"cm\"> -------------- HERE ---------------/</span>\n          <span class=\"o\">(</span><span class=\"gr\">sorry</span><span class=\"o\">)</span>\n      <span class=\"o\">))</span>\n      <span class=\"c\">/-</span><span class=\"cm\"> Otherwise recurse on the restriction of p : Fin m → Prop, and lift back to Fin n -/</span>\n      <span class=\"o\">(</span><span class=\"gr\">sorry</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>At the comment marked by <code>HERE</code> we have that <code>p_m : p✝ (Fin.mk m (m &lt; n))</code>, however the goal is we want <code>p (Fin.mk m (m &lt; m + 1))</code>, we have from the match that <code>h : n = m +1</code></p>\n<p>My intuition would've been to use <code>h ▸ p_m</code>, however this doesn't work which isn't surprising as <code>p</code> and <code>p✝</code> are of different types</p>",
        "id": 317784110,
        "sender_full_name": "James Browning",
        "timestamp": 1671932316
    },
    {
        "content": "<p>Is there any reason here why <code>d</code> isn't transformed within the case the same way that <code>p</code> is? Like within the case <code>p</code> becomes <code>p : Fin (m+1) → Prop</code>, why does <code>d</code> not also become <code>d : (k: Fin (m+1)) → p k</code> (where <code>p</code> is the transformed prop)?</p>",
        "id": 317952155,
        "sender_full_name": "James Browning",
        "timestamp": 1672059176
    },
    {
        "content": "<p>Can you make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ? Your code doesn't compile for me as it stands.</p>",
        "id": 318019374,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672101152
    },
    {
        "content": "<p>I figured it out in the end, I noticed when printing the theorem it shows that <code>match n</code> <em>actually</em> becomes <code>match n, p</code>, so I just added <code>match n, p, d</code> and it works within the match.</p>\n<p>It is surprising though to me that <code>p</code> is automatically added to the match, but <code>d</code> isn't <em>also</em> added to the match as it too depends transitively on <code>n</code> through <code>p</code></p>",
        "id": 318208749,
        "sender_full_name": "James Browning",
        "timestamp": 1672214648
    }
]
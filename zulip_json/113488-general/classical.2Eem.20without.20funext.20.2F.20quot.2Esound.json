[
    {
        "content": "<p>After inlining and compression, I got this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">em&#39;</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">subs</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">P</span> <span class=\"n\">Q</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">,</span><span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">,</span><span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"n\">true</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">subs</span> <span class=\"n\">true</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">subs</span> <span class=\"n\">p</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">P</span> <span class=\"n\">Q</span><span class=\"o\">,</span> <span class=\"n\">subs</span> <span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">cond</span> <span class=\"n\">b</span> <span class=\"n\">P</span> <span class=\"n\">Q</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"n\">pt</span> <span class=\"n\">pf</span> <span class=\"o\">(</span><span class=\"bp\">⟨⟨⟩⟩|⟨⟨⟩⟩</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"o\">[</span><span class=\"n\">use</span> <span class=\"n\">tt</span><span class=\"o\">,</span> <span class=\"n\">use</span> <span class=\"n\">ff</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"n\">choose</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">f</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">U</span> <span class=\"bp\">≠</span> <span class=\"n\">f</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">this</span><span class=\"bp\">.</span><span class=\"n\">imp_right</span> <span class=\"o\">(</span><span class=\"n\">mt</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">pp</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">cases</span> <span class=\"n\">eq_true_intro</span> <span class=\"n\">pp</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">up</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">U</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">f</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">U</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">up</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">vp</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">f</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">trivial</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">vp</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">axioms</span> <span class=\"n\">em&#39;</span> <span class=\"c1\">-- classical.choice, propext</span>\n</code></pre></div>",
        "id": 207358170,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597796428
    },
    {
        "content": "<p>I made two essential adaptations to the original proof explained at <a href=\"https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#the-law-of-the-excluded-middle\">https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#the-law-of-the-excluded-middle</a> : using <code>bool</code> instead of <code>Prop</code> as the type to choose from (just like the {0,1} used in the Wikipedia proof; not sure why <code>Prop</code> was chosen in Lean), and using <code>Prop × Prop</code> instead of the function type <code>bool → Prop</code> to get rid of function extensionality.</p>\n<p>Not sure if this makes sense, but it seems that <code>nonempty_pi</code> preserves computability, while <code>choice</code> doesn't.</p>\n<p>Obviously you can't prove <code>prop_decidable</code> and <code>type_decidable</code> this way; <code>choice</code> follows from <code>type_decidable</code>, which follows from <code>prop_decidable</code> without choice. It makes me wonder what advantage decidability really has over excluded middle for the purpose of doing math? You can't exhibit a function using <code>ite</code> or <code>dite</code> without decidability, but can prove such functions exist using <code>em</code> and <code>or.elim</code>. When using tactics, the difference between em and decidability only matters when the goal is a <code>Type</code> instead of a <code>Prop</code>. Most likely in those cases you are able to carry out a computable/recursive construction or the goal is a function that you can apply <code>nonempty_pi</code> show it exists. So maybe the <code>choose</code> tactic should produce a existential statement in the context when the goal is a <code>Type</code> using <code>nonempty_pi</code> rather than invoking <code>choice</code>, but when the goal is a <code>Prop</code> then it's free to exhibit an element proven to exist.</p>\n<p>I am currently thinking of proving <code>em</code> with <code>quot.sound</code> but without <code>propext</code>. The rough idea is to quotient <code>Prop</code> by the equivalence relation <code>iff</code>.</p>",
        "id": 207361958,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1597800789
    },
    {
        "content": "<p>Fun to see and digest the statement of <code>nonempty_choice</code>, and nice observation that <code>nonempty_pi</code> follows from it! (Edit: it should prove nonempty_pi, as nonempty_pi is a Prop, so for the purpose of proving it, nonempty (something) is the same as something.)</p>",
        "id": 207362758,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1597801968
    },
    {
        "content": "<blockquote>\n<p>Not sure if this makes sense, but it seems that nonempty_pi preserves computability, while choice doesn't.</p>\n</blockquote>\n<p>There have been discussions about the <code>trunc</code> version of <code>nonempty_pi</code>, which looks like it should be computable but isn't:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">trunc_pi</span><span class=\"bp\">.</span><span class=\"n\">impl</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">unchecked_cast</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">vm_override</span> <span class=\"n\">trunc_pi</span><span class=\"bp\">.</span><span class=\"n\">impl</span><span class=\"o\">]</span> <span class=\"c1\">-- this should be fine, right?</span>\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">trunc_pi</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">out</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">weird</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"n\">trunc</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">trunc_pi</span><span class=\"bp\">.</span><span class=\"n\">impl</span> <span class=\"n\">id</span>\n\n<span class=\"n\">def</span> <span class=\"n\">singl</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">}</span>\n<span class=\"kn\">instance</span> <span class=\"n\">singl</span><span class=\"bp\">.</span><span class=\"n\">subsingleton</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">subsingleton</span> <span class=\"o\">(</span><span class=\"n\">singl</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"k\">by</span> <span class=\"n\">rintro</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩;</span> <span class=\"n\">refl</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">lie</span> <span class=\"o\">:</span> <span class=\"n\">singl</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span>\n<span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">rec_on_subsingleton</span> <span class=\"o\">(</span><span class=\"n\">weird</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n<span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">to_bool_tt</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">congr</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">ff</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">tt</span><span class=\"o\">))</span><span class=\"bp\">⟩</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"n\">lie</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"c1\">-- ff</span>\n</code></pre></div>",
        "id": 207362765,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597802020
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> unfortunately my demonstration doesn't quite work with <code>vm_override</code> as I was hoping, because <code>trunc_pi</code> is still considered <code>noncomputable</code> and hence functions based on it don't get any VM implementation</p>",
        "id": 207362841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597802135
    },
    {
        "content": "<blockquote>\n<p>It makes me wonder what advantage decidability really has over excluded middle for the purpose of doing math?</p>\n</blockquote>\n<p>You are omitting the most important part: ease of use. Yes, mathematicians like to prove theorems and as long as it's a Prop you can use <code>nonempty_choice</code> instead of <code>choice</code>, but the problem is that you have to be always working with respect to some choice function, and this is really inconvenient for things like choicy definitions (of which there are many in mathlib), like \"the limit of the filter\". You could probably cobble something together using a typeclass <code>[choicy.{u}]</code> to get a choice function, but we already have problems with typeclass unification when the class is a subsingleton, and the <code>choicy</code> typeclass is as non-unique as they come (that's sort of it's shtick)</p>",
        "id": 207363150,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597802525
    },
    {
        "content": "<blockquote>\n<p>The rough idea is to quotient Prop by the equivalence relation iff.</p>\n</blockquote>\n<p>I will be interested to see if this is successful. I tried and failed to do exactly this a few years ago</p>",
        "id": 207363184,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597802590
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I think what it needs is for the <code>vm_override</code> attribute to remove the <code>noncomputable</code> mark when it is set. I didn't think of it before</p>",
        "id": 207363418,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1597802936
    },
    {
        "content": "<p>does that mean that we still write <code>noncomputable</code> but it's not actually noncomputable?</p>",
        "id": 207363429,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597802979
    },
    {
        "content": "<p>Yeah, I know that's weird. The trouble is that the definition and its attribute are not added to the environment at the same time. First you add the definition and in all regards, it is <code>noncomputable</code> and that's only invalidated when the attribute is added</p>",
        "id": 207363501,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1597803080
    },
    {
        "content": "<p>maybe <code>noncomputable</code> should be an attribute</p>",
        "id": 207363581,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597803192
    },
    {
        "content": "<p>We would face a similar problem. I think we might need <code>vm_override</code> to be a keyword like <code>using_well_founded</code></p>",
        "id": 207363814,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1597803546
    },
    {
        "content": "<p>maybe we should call it <code>computable</code> :D</p>",
        "id": 207363970,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597803812
    },
    {
        "content": "<p>Hmm, I thought <code>subtype.ext_val</code> must depend on <code>propext</code> (<code>true</code> has one constructor so any proven <code>Prop</code> has only one element), but it turns out it doesn't. Does the principle of proof irrelevance not need to be stated anywhere and is just directly applied by the kernel?<br>\n<code>theorem pf_irrel (p : Prop) (a b : p) : a = b</code></p>",
        "id": 207365646,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1597806014
    },
    {
        "content": "<p>I have only learned Lean for three weeks (not counting natural number game or min/max game) so pardon my curiosity about many foundational issues.</p>",
        "id": 207365726,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1597806147
    },
    {
        "content": "<p>yes, proof irrelevance is a no axioms axiom</p>",
        "id": 207365746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597806191
    },
    {
        "content": "<p>I think I now have a good grasp of type theory by playing with Lean and it's maybe time to learn some HoTT.</p>",
        "id": 207365813,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1597806279
    },
    {
        "content": "<p>if you have the stomach for some type theory, <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">https://github.com/digama0/lean-type-theory/releases/tag/v1.0</a> has the description of the basic rules of lean in chapter 2</p>",
        "id": 207365824,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597806286
    },
    {
        "content": "<p>Earlier today I was drawn to the problem what's the shortest proof from first principles of <code>tt≠ff</code>; it was used in the <code>em</code> proof above, but <code>trivial</code> solved it. Then I found <code>no_confusion</code> and <code>no_confusion_type</code> associated to every inductive type (just like <code>rec</code>, <code>rec_on</code> and <code>cases_on</code>), but am unable to find any documentation except brief mention in \"Theorem Proving in Lean\". Anyway, here is a relatively minimal proof of the fact:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">theorem</span> <span class=\"n\">tt_ne_ff</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"bp\">.</span><span class=\"n\">tt</span> <span class=\"bp\">≠</span> <span class=\"n\">bool</span><span class=\"bp\">.</span><span class=\"n\">ff</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">set</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">bool</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"o\">(</span><span class=\"bp\">λ_</span><span class=\"o\">,</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"n\">false</span> <span class=\"n\">true</span> <span class=\"k\">with</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">tt</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">hf</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">rwa</span> <span class=\"n\">this</span> <span class=\"n\">at</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">axioms</span> <span class=\"n\">tt_ne_ff</span> <span class=\"c1\">-- no axioms</span>\n</code></pre></div>",
        "id": 207365850,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1597806295
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> has a blog post on <code>no_confusion</code>: <a href=\"https://xenaproject.wordpress.com/2018/03/24/no-confusion-over-no_confusion/\">https://xenaproject.wordpress.com/2018/03/24/no-confusion-over-no_confusion/</a></p>",
        "id": 207365939,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1597806392
    },
    {
        "content": "<p>Thanks for pointing to that!<br>\nIndeed</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">theorem</span> <span class=\"n\">pf_irrel</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">trivial</span>\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">axioms</span> <span class=\"n\">pf_irrel</span> <span class=\"c1\">-- no axioms</span>\n</code></pre></div>\n\n\n<p>requires no axioms</p>",
        "id": 207366000,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1597806444
    },
    {
        "content": "<p>it's more even than that. Two proofs are not just the same but <em>definitionally</em> the same - you can prove the equality using <code>rfl</code>, the proof that <code>a = a</code></p>",
        "id": 207366266,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597806777
    },
    {
        "content": "<p>In fact, we exploit proof irrelevance in the proof of <code>em'</code>, in the <code>cases eq_true_intro pp, refl</code> part of my version of the proof</p>",
        "id": 207366283,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597806837
    },
    {
        "content": "<p>the <code>refl</code> is a proof that <code>f true true U = f true true V</code></p>",
        "id": 207366323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597806855
    },
    {
        "content": "<p>I observed that the drinker paradox implies excluded middle in Lean, using a variation of the Diaconescu argument. However, Coq documentation <a href=\"https://coq.inria.fr/library/Coq.Logic.ClassicalFacts.html\">https://coq.inria.fr/library/Coq.Logic.ClassicalFacts.html</a> (Section \"Weak classical axioms\") says the former is weaker. What could be the reason?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">universe</span> <span class=\"n\">u</span>\n<span class=\"c1\">-- [Bell] John L. Bell, Choice principles in intuitionistic set theory, http://publish.uwo.ca/~jbell/Choice%20Principles.pdf</span>\n\n<span class=\"n\">def</span> <span class=\"n\">sid</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">a</span>\n<span class=\"c1\">-- [Lean] noncomputable theorem strong_indefinite_description {α : Sort u} (p : α → Prop) (h : nonempty α) : {x : α // (∃ y : α, p y) → p x}</span>\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">axioms</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">strong_indefinite_description</span> <span class=\"c1\">-- all three (uses EM)</span>\n<span class=\"c1\">-- [Bell] Un = [Coq] Drinker = drinker&#39;s paradox (small form) (called Ex in Bell [Bell])</span>\n<span class=\"c1\">-- This is the Prop form, and the strong (Type) form is [Coq] D_epsilon = (weakly classical) indefinite description principle</span>\n<span class=\"c1\">-- ∃a, p a → ∀b, p b ([Bell] Ex) is also called drinker paradox (e.g. on codewars); sid implies only ∃a, p a → ∀b, ¬¬p b</span>\n\n<span class=\"n\">def</span> <span class=\"n\">sid&#39;</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">a</span>\n<span class=\"c1\">-- [Coq] IGP = independence of general premises (an unconstrained generalisation of the constructive principle of independence of premises)</span>\n<span class=\"c1\">-- implies LC : (φ→ψ∨χ)→(φ→ψ)∨(φ→χ) immediately</span>\n\n<span class=\"c1\">-- Trivially interderivable:</span>\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">sid&#39;</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">sid</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>  <span class=\"bp\">λ</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"n\">id</span>\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">sid</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">sid&#39;</span> <span class=\"n\">p</span> <span class=\"n\">r</span> <span class=\"o\">:=</span>  <span class=\"bp\">λ⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">ha</span><span class=\"bp\">⟩</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">ha</span><span class=\"err\">∘</span><span class=\"n\">h</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">em_of_sid&#39;</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">sid&#39;</span> <span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">:</span><span class=\"n\">bool</span> <span class=\"bp\">//</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">u</span><span class=\"bp\">=</span><span class=\"n\">tt</span><span class=\"o\">}</span> <span class=\"bp\">⟨⟨</span><span class=\"n\">tt</span><span class=\"o\">,</span><span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩⟩</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"err\">↑</span><span class=\"n\">u</span><span class=\"bp\">=</span><span class=\"n\">ff</span><span class=\"o\">)</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">let</span> <span class=\"bp\">⟨⟨</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">h1</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"n\">h2</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">⟨⟨</span><span class=\"n\">ff</span><span class=\"o\">,</span><span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n  <span class=\"n\">h1</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"o\">{</span><span class=\"n\">dsimp</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">triv</span><span class=\"o\">}</span> <span class=\"err\">∘</span> <span class=\"n\">h2</span><span class=\"o\">))</span>\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">axioms</span> <span class=\"n\">em_of_sid&#39;</span> <span class=\"c1\">-- no axioms, not even proof irrelevance</span>\n</code></pre></div>",
        "id": 208618153,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1598909650
    },
    {
        "content": "<p>This is part of my write-up of my investigation into proving em without propext. The attempt was unsuccessful, but I make connections between em, quotient exactness and choice principles.</p>\n<p>I also introduced the function extension principle saying that you can extend a function from a subtype to a nonempty sort can be extended to the whole type, which I don't see discussed anywhere else. I showed that it's equivalent to the drinker paradox under nonempty_pi/choice.</p>",
        "id": 208619200,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1598910347
    },
    {
        "content": "<p>This is very interesting. You should try replaying your proof in Coq to see if there are any non obvious foundational differences, but it seems like this proof would also go through in Coq, and if so it looks like it would be news</p>",
        "id": 208637681,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598926037
    },
    {
        "content": "<p>Releasing this \"formal\" write-up and wrapping up this expedition :)<br>\n<a href=\"https://gist.github.com/alreadydone/7474d5000c912194d794d06192e84f1e\">https://gist.github.com/alreadydone/7474d5000c912194d794d06192e84f1e</a><br>\nI didn't end up porting the implication <code>sid→em</code> to Coq; I found the same argument in [Bell] (relativized ε-scheme), so it's not new. According to [Bell], the version of <code>sid</code> that only quantifies over the whole universe (called <code>Ex</code> in [Bell]) is weaker than LEM, but if quantification over arbitrary set (or type, in type theory) is allowed (e.g. with the relativized ε-scheme), then it's equivalent to LEM. The Coq people might have missed this point and went on to claim that <code>sid</code> (their <code>IGP</code>) is weaker than LEM.</p>",
        "id": 211337766,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1601088063
    },
    {
        "content": "<p>Update: choice + proof irrelevance =&gt; decidable equality for any type<br>\n<a href=\"https://gist.github.com/alreadydone/7474d5000c912194d794d06192e84f1e#file-choice_and_excluded_middle-lean-L29\">https://gist.github.com/alreadydone/7474d5000c912194d794d06192e84f1e#file-choice_and_excluded_middle-lean-L29</a></p>",
        "id": 211452647,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1601270075
    },
    {
        "content": "<p>Update: I managed to prove weak excluded middle <code>∀p, ¬p ∨ ¬¬p</code> using choice, quot.sound (and PI) only:<br>\n<a href=\"https://gist.github.com/alreadydone/7474d5000c912194d794d06192e84f1e#file-choice_and_excluded_middle-lean-L52\">https://gist.github.com/alreadydone/7474d5000c912194d794d06192e84f1e#file-choice_and_excluded_middle-lean-L52</a><br>\nIn fact the argument implies <code>∀p q, (¬¬p ∧ ¬¬q) ∨ (¬p ∧ ¬q) ∨ ¬(p → q) ∨ ¬(q → p)</code> which seems to be stronger.</p>",
        "id": 211579888,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1601353795
    },
    {
        "content": "<p>You should write these things down / contribute them to mathlib / etc. Thoughts published only as gists are not going to last long in this world. :-)</p>",
        "id": 211584625,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601360542
    },
    {
        "content": "<p>These aren't just thoughts, but formalized thoughts, so should last a bit longer :) I also specified the Lean version and mathlib commits in leanpkg format so they won't bitrot unless someone deletes the commit history.<br>\nI agree that I need to add a list of contents that includes the line number of each section, state main results/highlights in an introduction section, and explain ideas of nontrivial proofs in more detail.<br>\nRegarding mathlib, would you like to see the current proof of classical.em be replaced by one that doesn't use quot.sound?</p>",
        "id": 211622344,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1601387089
    },
    {
        "content": "<p>I seem to be able to prove we have a homomorphism from the Heyting algebra on <code>Prop</code> to {0,1} respecting true,false,or,and,imp,neg (all logical connectives) mapping p to 1 iff <code>⟦ff⟧=⟦tt⟧</code> in the quotient of <code>bool</code> by <code>λ_ _,p</code>. What strongest consequence does this have? It implies the Heyting algebra is a Stone algebra (satisfies weak excluded middle), for example.</p>",
        "id": 211623013,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1601387370
    },
    {
        "content": "<p>Formalized thoughts rot even faster, because they are dependent on a big software stack. We have seen many examples now of work that was not updated being lost quickly.</p>",
        "id": 211697164,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601421603
    },
    {
        "content": "<p>Making PRs into mathlib is one good option. Another is <span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span>'s recent efforts to provide continuous integration for outside-of-mathlib projects, although I now can't find any links to it...</p>",
        "id": 211697214,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601421646
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/lean_projects.html\">https://leanprover-community.github.io/lean_projects.html</a></p>",
        "id": 211725969,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1601452298
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound/near/207363184\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>The rough idea is to quotient Prop by the equivalence relation iff.</p>\n</blockquote>\n<p>I will be interested to see if this is successful. I tried and failed to do exactly this a few years ago</p>\n</blockquote>\n<p>any success?</p>",
        "id": 289644360,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1657830018
    },
    {
        "content": "<p>I think it's probably not impossible, and the best I could get is at <a href=\"https://gist.github.com/alreadydone/7474d5000c912194d794d06192e84f1e#file-choice_and_excluded_middle-lean-L50\">this gist</a>. (PI stands for proof irrelevance)</p>",
        "id": 289644544,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1657830136
    }
]
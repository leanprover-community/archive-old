[
    {
        "content": "<p>Kenny and I will need to do some work with finite sequences to prove that affine schemes are schemes. Here is an example of the sorts of issues we are running into.</p>\n<p>We have a definition <code>generate (S : set alpha)</code> -- for generating submodules of rings, but the same sort of question would arise for generating subgroups of groups or subspaces of vector spaces. Kenny has defined <code>generate S</code> to be <code>{ x | ∀ (T : set α) [is_submodule T], S ⊆ T → x ∈ T }</code> which is fine mathematically but now we need the \"concrete\" definition of the module generated by S, that is, the x such that there exists some finite sequence <code>s1,s2,..,sn</code> of elements of S and some finite sequence <code>r1,r2,...,rn</code> of the underlying ring alpha such that <code>x=r1*s1+r2*s2+...+rn*sn</code>. I can think of lots of ways to implement this but I have no feeling as to which one is \"right\" in this situation. I definitely want to allow repeats amongst the r's, and they are ordered. Should we go with asserting the existence of two lists of size n, or a map from <code>fin n</code> to S, or a map from <code>range n</code> to S, or some other approach? I am pretty sure that any of these suggestions would work but I don't know which one is most idiomatic (is that the right word?) for Lean. We are going to want to do the sorts of things that mathematicians would do with these lists -- form the sum of <code>ri*si</code> over i, choose an element from the list with some property, concatenate two lists, prove that the sum up to n+1 is the sum up to n plus the last term, blah blah blah. Obviously we'll also want to prove that the two definitions of generate are equivalent.</p>\n<p>If the answer is \"tell us more specifically exactly what you want to do with these lists\" then I could try to do that. Could it be the case that it doesn't really matter what we choose, and all methods should work fine?</p>",
        "id": 123486171,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520591955
    },
    {
        "content": "<p>so <code>generate</code> is <code>span</code> in <code>algebra.linear_algebra</code>?</p>",
        "id": 123486400,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1520592452
    },
    {
        "content": "<p>Probably. We're using it for generating ideals of a ring here.</p>",
        "id": 123486446,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520592538
    },
    {
        "content": "<p>If you use <code>span</code> you already got a representation as <code>finsupp</code>, i.e. a map from the base ring into the module with finite support.</p>",
        "id": 123486453,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1520592545
    },
    {
        "content": "<p>One of Leo's comments on some recent PR is \"I think this is an anti-idiom.\" I am just trying to avoid being anti-idiomatic :-)</p>",
        "id": 123486454,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520592580
    },
    {
        "content": "<p>The nice thing of <code>finsupp</code> is that you can ignore the order, I usually do all the operations on it using the <code>finsupp.sum</code> operator.<br>\nI guess you do not really need a order on the elements?</p>",
        "id": 123486510,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1520592659
    },
    {
        "content": "<p>No but we need a way to biject the r_i and the s_i</p>",
        "id": 123486517,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520592675
    },
    {
        "content": "<p>so we could have a map from an unordered finite type to R and a map from the same type to S, for example</p>",
        "id": 123486523,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520592698
    },
    {
        "content": "<p>On the other hand we might well sometimes want to prove things by induction on n, the size of the sequence</p>",
        "id": 123486568,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520592752
    },
    {
        "content": "<p>I think you don't need the index type at all! You can do induction directly on finsupp itself, (or on its support).<br>\nBy avoiding this arbitrary index type you avoid a lot of data to carry around. It is common in mathematics to write down <code>x_1 ... x_n</code> and then go on to prove something by induction on <code>n</code>.  But in many cases this is unnecessary, and much easier (and maybe more idiomatic) to do it in an unordered fashion. In you case you directly take a function <code>R -&gt;_0 S</code> (the <code>_0</code> indicates that it is a finsupp function), I would assume this encodes enough information for your proofs.</p>",
        "id": 123486689,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1520593076
    },
    {
        "content": "<p>In the finsupp approach I seem to need a random index type X, so that if I have a ring R and a subset S then I can write down maps X-&gt;R and X-&gt;S with finite support. So I might not need n and fin n but surely I still need an index type, if this is what X is.</p>",
        "id": 123486962,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520593626
    },
    {
        "content": "<p>If the suggestion is that the span is the elements a in R such that there exists some type X and finsupp maps f : X -&gt; R and g : X -&gt; S such that  a = sum f x * g x, then to add two such maps together I would need that if f1 : X -&gt; R and f2 : Y -&gt; R are finsupp maps then f1+f2 : X disjoint_union Y -&gt; R is a finsupp. Presumably lemmas such as this are already there?</p>",
        "id": 123487064,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520593905
    },
    {
        "content": "<p>There is no need for an arbitrary index type. The idea is that you represent a span as <code>R -&gt;_0 S</code>, there are no further index types. An element <code>x \\in span S</code>is represented as: <code>\\exists f : R -&gt;_0 S, x = \\sum_{(r, s) \\in f} r * s</code></p>",
        "id": 123487147,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1520594088
    },
    {
        "content": "<p><code>\\sum_{(r, s) \\in f}</code> is actually written <code>f.sum (\\lam r s, ...)</code> in lean.</p>",
        "id": 123487159,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1520594123
    },
    {
        "content": "<p>So there is a special summation operator over the elements in <code>f</code>.</p>",
        "id": 123487161,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1520594139
    },
    {
        "content": "<p>Aah I see! But this looks problematic because I don't see how to add the elements corresponding to two such maps. I would need maps S -&gt;_0 R instead. Can you envisage this causing any problems?</p>",
        "id": 123487777,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520595507
    },
    {
        "content": "<p>I would also need lemmas of the form \"if s is in S and if I define f :  S -&gt;_0 R by f(t)=ite (t=s) 1 0 then f.sum ... = s\". Are these already there?</p>",
        "id": 123487831,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520595629
    },
    {
        "content": "<p>and things of the form \"if f : S -&gt;_0 R has image size n+1 then I can write it as g+h with g of image size n and h of image size 1\".</p>",
        "id": 123487842,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520595695
    },
    {
        "content": "<p>What I am hoping for is being able to avoid writing all the infrastructure myself ;-)</p>",
        "id": 123487843,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520595713
    },
    {
        "content": "<p>I'm sorry, of course it would be <code>S -&gt;_0 R</code>!</p>",
        "id": 123488231,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1520596553
    },
    {
        "content": "<p><code>f(t) = ite (t=s) 1 0</code> is available for finsupp, it's called <code>single s r</code>, which maps <code>s -&gt; r</code> and nothing else.</p>",
        "id": 123488337,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1520596713
    },
    {
        "content": "<p>We can easily proof a special case statement saying essentially: <code>f = 0 \\/ \\exists f' r s, r /= 0 /\\ s \\notin f' /\\ f = f' + single s r</code></p>",
        "id": 123488399,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1520596827
    },
    {
        "content": "<p>Thanks as ever for your comment Johannes. Although I don't really understand why finsupps are better than any of the approaches I outlined, I certainly trust your judgement and will use this approach.</p>",
        "id": 123491030,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520602457
    },
    {
        "content": "<p>What brings finsupp: it doesn't  duplicate elements, it avoids any order on your elements, and there is only one data/variables etc to handle .</p>\n<ul>\n<li>Duplication might be very annoying in induction proofs, where you walk over your elements and then be sure that they do not appear at a later point. This might require removing them from the later list, and hence requiring a strong induction principle.</li>\n<li>The order is annoying when you create a linear combination. Depending on how you create them it might be a problem. </li>\n</ul>\n<p>Does this give a better idea why finsupp is better than lists of pairs, multisets of pairs or two functions indexed by a finite type?</p>",
        "id": 123493235,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1520606722
    },
    {
        "content": "<p>Thank you for these explanations. I can see that finsupp is fundamentally different to all my proposals, because for all the ways I suggested (1) I need an extra type and (2) I have an implicit order, neither of which are necessary. I guess what I don't really understand is how important these differences are in practice. I guess the point is that if I don't need some structure when implementing an idea then I should try and implement the idea without introducing the structure.</p>",
        "id": 123496322,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520611926
    },
    {
        "content": "<p>This S -&gt;_0 R is a nice trick but it won't work for non commutative laws</p>",
        "id": 123506889,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1520627646
    },
    {
        "content": "<p>So it's bad from the point of view of developing general idioms</p>",
        "id": 123506905,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1520627695
    },
    {
        "content": "<p>Also, what about <a href=\"http://www-sop.inria.fr/marelle/bigops/main.pdf\" target=\"_blank\" title=\"http://www-sop.inria.fr/marelle/bigops/main.pdf\">www-sop.inria.fr/marelle/bigops/main.pdf</a> ? Did mathlib learn from this?</p>",
        "id": 123506920,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1520627724
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-email=\"johannes.hoelzl@gmx.de\" data-user-id=\"110294\">@Johannes Hölzl</span> how does induction work on finsupp?</p>",
        "id": 123512358,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1520635184
    },
    {
        "content": "<p>The support of a finsupp is a <code>finite</code> set, so you can use <code>finite.induction</code></p>",
        "id": 123512504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1520635392
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-email=\"di.gama@gmail.com\" data-user-id=\"110049\">@Mario Carneiro</span> so I <code>case</code> it to get <code>finite</code> before I induction it?</p>",
        "id": 123512728,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1520635732
    },
    {
        "content": "<p>but then how do I use the functions from <code>finsupp</code>?</p>",
        "id": 123512731,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1520635739
    },
    {
        "content": "<p>Maybe a better question is: what are you trying to prove? Are you sure you need to use induction? Most facts about finsupp that are proven by induction should already be lemmas</p>",
        "id": 123512800,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1520635807
    },
    {
        "content": "<p>and don't case the function, just use <code>finsupp.support</code></p>",
        "id": 123512815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1520635853
    },
    {
        "content": "<p>I guess I don't need induction then</p>",
        "id": 123512955,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1520636117
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>/-- `image f s` is the forward image of `s` under `f`. -/\ndef image (f : α → β) (s : finset α) : finset β := (s.1.map f).to_finset\n</pre></div>\n\n\n<p>is there a way for the function to know that the input is in <code>s</code>?</p>",
        "id": 123512961,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1520636144
    },
    {
        "content": "<p>you could precompose with <code>finset.attach</code></p>",
        "id": 123513140,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1520636410
    },
    {
        "content": "<p>we can also add a special induction rule for finsupp, which would be based on the induction on the support itself. However, it would give one a better view, i.e. look somehow like <code>finsupp.induction_on {P : (S -&gt;_0 R) -&gt; Prop} (f : S -&gt;_0 R) (h0 : P 0) (h1 : \\all f s r, s \\notin f -&gt; P f -&gt; P (f + single s r)) : P f</code> . Then you got a induction rule which carries on the data as expected.</p>",
        "id": 123531200,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1520678741
    },
    {
        "content": "<p>I think the idiom we want to have is: represent your data in the somehow optimal way. So if one works with commutative spaces, like modules,  finsupp carries the least necessary information. If one is working in a non commutative setting they might want to use lists, or freely generated groups, or ordered maps etc.</p>",
        "id": 123531331,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1520679014
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> indeed Coq has a nice and flexible big operator library. But it is very much based on canonical structures which is hard to copy in Lean itself. Also as Leans algebraic hierarchy will change in the future we will see how big operators might look like in the future.</p>",
        "id": 123533781,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1520685478
    },
    {
        "content": "<p>I'm confused. I was under the impression that canonical structure was Coq's name for type class inference.</p>",
        "id": 123538907,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1520698246
    },
    {
        "content": "<p>AFAIK Coq has two type class mechanisms, one is called type classes, and is similar to Lean's type class mechanism. And canonical structures, which are very different. I still don't understand canonical structures, but I think it works in a way that the unifier somehow creates a structure based on unification constraints, so from <code>?x.1 =?= A</code> and <code>?x.2 =?= B</code> it will create <code>?x =?= (A, B)</code>.</p>",
        "id": 123544288,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1520711223
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> and <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span>  I worked a little bit on finsupp: it got computable, i.e. the projection of the support of a finsupp are now rfl-lemmas. But more important: I added a induction lemma <code>finsupp.induction_on</code>.</p>",
        "id": 123544529,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1520711843
    },
    {
        "content": "<p>thanks</p>",
        "id": 123544950,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1520712843
    },
    {
        "content": "<p>Oh many thanks Johannes. I think I might understand Lean well enough to formulate precisely the statement I want from this finsupp approach. I really want to make working with finite objects easier for mathematicians. I was there when Chris told Kenny that he had formalised Lagrange's Theorem and Kenny was visibly impressed. Mathematicians use finite objects in certain ways which are natural to them but which seem to be hard to do (at least for me) in Lean.</p>",
        "id": 123546318,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520716118
    },
    {
        "content": "<p>Lagrange's theorem in mathematics (in the usual language of ZFC) says that if S is a finite set of size n, and if there's an equivalence relation on S such that all the equivalence classes have the same size d, then n is the product of d and the number m of equivalence classes.</p>",
        "id": 123546377,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520716287
    },
    {
        "content": "<p>Well, it is a related statement :-)</p>",
        "id": 123546378,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520716307
    },
    {
        "content": "<p>And this is a statement which is so obvious to a mathematician that it really doesn't need a proof, it should just be by some tactic because it is as obvious as the statement that if x y and z are real numbers then <code>x * (y + z) = x * y + x * z</code>, i.e. something which one can assume without any comment.</p>",
        "id": 123546423,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520716392
    },
    {
        "content": "<p>But in Lean I look at that statement and my first thought is that I can see about 10 ways of formalizing it and I have no idea which ones will be easy to use.</p>",
        "id": 123546424,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520716424
    },
    {
        "content": "<p>So in my mind this is an area which it would be really nice to work on.</p>",
        "id": 123546461,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520716444
    },
    {
        "content": "<p>In fact let me also state the original example from commutative ring theory which got me thinking about this whole issue. Here is an example of a statement and a proof from the Stacks Project (written in ZFC). The statement is this. Say <code>R</code> is  a ring, and we have some n&gt;=2 and some elements <code>f1,f2...,fn</code> of <code>R</code> and positive integers <code>e1,e2,...,en</code> such that (a) <code>fi^ei*r=0</code> for all <code>i</code> and (b) there exists some <code>r1,r2,...,rn</code> in <code>R</code> such that the sum of <code>ri*fi</code> equals <code>1</code>. Then <code>r=0</code>.</p>",
        "id": 123546665,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520717023
    },
    {
        "content": "<p>The proof is just by calc, and it goes:</p>",
        "id": 123546708,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520717057
    },
    {
        "content": "<p><code>1=sum ri * fi</code></p>",
        "id": 123546709,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520717069
    },
    {
        "content": "<p><code>=(sum ri * fi)^N</code> where <code>N</code> is something big that we might not even bother to state if we were sloppy, but maybe we would say \"Oh N=the sum of the ei should probably work\" if we were being careful</p>",
        "id": 123546718,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520717137
    },
    {
        "content": "<p>and then say \"so done by the multinomial theorem\".</p>",
        "id": 123546719,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520717153
    },
    {
        "content": "<p>I know I can do that in Lean but I just look at it and it looks difficult to me.</p>",
        "id": 123546760,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520717171
    },
    {
        "content": "<p>it's not something I want to be stuck on or bothered with. I just defined sheaves on a topological space in Lean without batting an eyelid and that's a gazillion times more complicated to a mathematician</p>",
        "id": 123546762,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520717201
    },
    {
        "content": "<p>I don't want finite sets and sequences to be hard.</p>",
        "id": 123546769,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520717229
    },
    {
        "content": "<p>Maybe we would let the students \"fill in the details as an exercise\"</p>",
        "id": 123546813,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520717295
    },
    {
        "content": "<p>but if I saw anyone write just something like \"(sum ri fi)^N=sum_{t_1,t_2,...,t_n nats with sum N}(multinomial (N) (t1,t2,...,tn))r1^t1 r2^t2..rn^tn f1^t1 f2^t2 .. fn^tn and each term annihiliates r because the sum of the ti is the sum of the ei so clearly ti&gt;=ei for some i\"</p>",
        "id": 123546917,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520717530
    },
    {
        "content": "<p>A mathematician wouldn't be expected to write much more than that. But why do I look at that and think that it needs some planning in Lean? I want to just be able to write that easily, i.e. formulate it in an idiomatic way in DTT and prove it with a tactic.</p>",
        "id": 123546928,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520717639
    },
    {
        "content": "<p>I know Chris has proved some version of the binomial theorem in Lean, it's on his github.</p>",
        "id": 123546979,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520717722
    },
    {
        "content": "<p>But I don't know if it is the \"right\" version, or even whether it makes sense to ask that there is a \"right\" version of the binomial or multinomial theorems.</p>",
        "id": 123547019,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520717763
    },
    {
        "content": "<p>Somehow for a mathematician there is just one multinomial theorem, which might not even have been stated in the correct generality in your undergraduate class (the theorem states what the expansion of (x1+x2+...+xn)^N is, but what are those xi? The stats lecturer needs multinomial theorem to be covered ASAP because they need it for their course, so we do it in the first term, and I want to make the assertion that the x_i are a ring, but I can't because they don't know what a ring is. So I just say that x_i are real numbers because it will keep the stats person happy.</p>",
        "id": 123547095,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520717950
    },
    {
        "content": "<p>and then if anyone ever asks later on I just say \"oh yeah of course it works for any ring, probably my proof generalizes\"</p>",
        "id": 123547102,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520717994
    },
    {
        "content": "<p>We teach maths in the wrong order :-)</p>",
        "id": 123547147,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520718028
    },
    {
        "content": "<p>They do all this stuff in applied maths in year 1 where they're brutally re-arranging all sorts of sums and products on the basis that \"one day you'll see that this was all rigorous after all, or at least most of it was, there was that bit in the Fourier Transform section that is actually a bit more complicated than you'd like\"</p>",
        "id": 123547155,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520718095
    },
    {
        "content": "<p>I'll quote some stuff from earlier in the finite sequences thread and add some more stuff.</p>",
        "id": 123571601,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520778701
    },
    {
        "content": "<p>General Mathematical Principle 1): \"If you partition a finite set up into <code>m</code> subsets of size <code>d</code> then your set has size <code>m*d</code>\". The mathematician says \"this is one of several equivalent definitions of multiplication, so done\". In Lean we might formulate it like this: if <code>S</code> is a finite type of size <code>n</code> (i.e. there are exactly <code>n</code> distinct terms of type <code>S</code>), and if there's an equivalence relation on <code>S</code> such that all the equivalence classes have the same size <code>d</code>, then <code>n</code> is the product of <code>d</code> and the number <code>m</code> of equivalence classes. Already in Lean it seems to me that one has to make a decision about how to formalise this because there are several possibilities. Should <code>S</code> be a finset, a fintype, or a set S for which <code>finite S</code> is true? What if we are given <code>S</code> as a subtype and we don't even know it's finite, and want to prove this from the fact that we can partition it up into <code>m</code> subsets of size <code>d</code>? Would I be right in thinking that there is no one \"idiomatic\" way to prove a Lean version of General Mathematical Principle 1? Or might there be one general canonical way of expressing this principle in Lean such that all instances of the principle which mathematicians want to use can be deduced from this canonical formulation?</p>",
        "id": 123571912,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520779457
    },
    {
        "content": "<p>General Mathematical Principle 2) Obvious Finite Sum facts. Sum from <code>i=a</code> to <code>i=b</code> of <code>f(i)</code> plus sum from <code>i=b+1</code> to <code>i=c</code> of <code>f(i)</code> equals sum from <code>i=a</code> to <code>i=c</code> of <code>f(i)</code>. Sum from <code>0</code> to <code>n</code> of <code>f(i)</code> equals sum from <code>0</code> to <code>n</code> of <code>f(n-i)</code>. Sum from <code>a</code> to <code>n+1</code> of <code>f(i) equals sum from </code>a<code> to </code>n<code> of </code>f(i)<code>, plus </code>f(n+1)`.</p>",
        "id": 123571965,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520779672
    },
    {
        "content": "<p>Again all of these things would be things a mathematician would write without even commenting on why these things were true. Again in Lean I see lots of ways of implementing the statements, based on whether we decide to sum over a list, or a different kind of finite object: there is <code>finset.sum</code> but summing from 0 or 1 to <code>n</code> is a very common use case in mathematics. Should I just implement these theorems myself using list.range and fold?</p>",
        "id": 123572147,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520780107
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>/-- sum_from_one_to n f sums f(i) for 1&lt;=i&lt;=n -/\ndefinition sum_from_one_to {α : Type*} [has_add α] [has_zero α] (n : ℕ) (f : ℕ → α) : α := sorry\n\ntheorem sum_from_one_to.rec {α : Type*} [has_add α] [has_zero α]\n  (n : ℕ) (f : ℕ → α) : sum_from_one_to (n+1) f = f (n+1) + sum_from_one_to n f  := sorry\n\n/-- sum_from_zeo_to n f sums f(i) for 0&lt;=i&lt;=n -/\ndefinition sum_from_zero_to {α : Type*} [has_add α] [has_zero α] (n : ℕ) (f : ℕ → α) : α := sorry\n\ntheorem sum_from_zero_to.rec {α : Type*} [has_add α] [has_zero α]\n  (n : ℕ) (f : ℕ → α) : sum_from_zero_to (n+1) f = f (n+1) + sum_from_zero_to n f  := sorry\n\n/-- sum_from_to a n f sums f(i) for a&lt;=i&lt;=n -/\ndefinition sum_from_to {α : Type*} [has_add α] [has_zero α]\n  (a : ℕ) (n : ℕ) (H : a ≤ n + 1) (f : ℕ → α) : α := sorry\n\ntheorem sum_from_to.rec {α : Type*} [has_add α] [has_zero α]\n  (a : ℕ) (n : ℕ) (f : ℕ → α) : sum_from_to a (n+1) _ f = f (n+1) + sum_from_to a n _ f  := sorry\n\ntheorem sum_from_to_rec&#39; {α : Type*} [has_add α] [has_zero α]\n  (a : ℕ) (n : ℕ) (f : ℕ → α) : sum_from_to a n _ f = f a + sum_from_to (a+1) n _ f  := sorry\n</pre></div>",
        "id": 123572150,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520780121
    },
    {
        "content": "<p>That sort of thing. Is that sufficiently close to something which is there already that I shouldn't bother? I want a mathematician-friendly interface for these things.</p>",
        "id": 123572152,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520780157
    },
    {
        "content": "<p>Oh also, summing <code>f i j</code> over <code>i</code> and then <code>j</code> should be the same as summing over <code>j</code> and then over <code>i</code>.</p>",
        "id": 123572192,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520780191
    },
    {
        "content": "<p>To prove S is finite from the partition, you could use <code>set.fintype_Union</code>. The combination of the following two lemmas, I wrote, should be enough to prove the stuff you're talking about, as I needed this stuff for Lagrange.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">quot</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">of_surjective</span> <span class=\"o\">(</span><span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">exists_rep</span> <span class=\"bp\">_</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sum_const</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">add_monoid</span><span class=\"bp\">.</span><span class=\"n\">smul</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">induction_on</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"n\">h</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n<span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sum_insert</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">card_insert_of_not_mem</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">smul_succ</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">card_quot</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">card</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">quot</span> <span class=\"n\">r</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">card</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">//</span> <span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"n\">card_sigma</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">//</span> <span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">})</span> <span class=\"bp\">▸</span>\n<span class=\"n\">card_congr</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">r</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩⟩</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">_⟩</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"bp\">⟨_⟩⟩</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p>I think the final lemma might be easier to use with <code>{a // quot.mk r a = x}</code> substituted for <code>{a // r a (quot.out x)}</code></p>",
        "id": 123572194,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1520780216
    },
    {
        "content": "<p>I suspect that I can cobble together proofs of these things. Somehow I am asking something slightly different.</p>",
        "id": 123572199,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520780244
    },
    {
        "content": "<p>I am asking how to implement these general principles in such a way that mathematicians will be able to use them in a painless way.</p>",
        "id": 123572201,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520780273
    },
    {
        "content": "<p>For example, let's say I ask some mathematicians to prove that the sum of the first <code>n</code> integers is <code>n(n+1)/2</code>. If I asked them to prove this in an exam they would prove it by induction. They would observe that it's trivial for n=0 and then do the few lines of algebra which gets from n to n+1 and then say done by induction.</p>",
        "id": 123572244,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520780332
    },
    {
        "content": "<p>But in Lean they immediately need to make a call about how to formalise the statement and I can see several possibilities. And for each possibility there is a different theorem which supplies the fact that one can prove results of this kind by induction.</p>",
        "id": 123572290,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520780405
    },
    {
        "content": "<p>I had to do stuff similar to that for power series. My method was</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">local</span> <span class=\"kn\">notation</span> <span class=\"n\">f</span> <span class=\"bp\">`</span> <span class=\"err\">∑</span> <span class=\"bp\">`</span> <span class=\"o\">:</span> <span class=\"mi\">90</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"mi\">90</span>  <span class=\"o\">:=</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">f</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">sum_range_succ</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"err\">∑</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"err\">∑</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"err\">∉</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_range</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">lt_irrefl</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">range_succ</span><span class=\"o\">,</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sum_insert</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n</pre></div>\n\n\n<p>and then you have the induction principle. This way I still get all the lemmas about <code>finset.sum</code>, like <code>finset.sum_le_sum</code>. Similar notation could be defined for sums between integers and products.<br>\nThe main downside to this notation is it requires commutativity</p>",
        "id": 123572347,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1520780532
    },
    {
        "content": "<p>Similarly, one could imagine being given a big group <code>G</code>, which is not finite, and then having a subtype <code>H</code> which is not yet known to be finite, and writing down a subgroup <code>N</code> of <code>H</code> and proving that <code>N</code> is finite and that there are only finitely many left cosets for <code>N</code> in <code>H</code>. That looks like quite a natural way to me of proving that <code>H</code> is finite. It is something I would let a student assume without comment if they wrote this in an exam.</p>",
        "id": 123572348,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520780546
    },
    {
        "content": "<p>So here you're summing from 0 to <code>n-1</code>, right?</p>",
        "id": 123572353,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520780591
    },
    {
        "content": "<p>yes, slightly annoying.</p>",
        "id": 123572354,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1520780609
    },
    {
        "content": "<p>Although this is I am sure very pythonic, I think that in practice mathematicians often sum from either <code>0</code> to <code>n</code> or from <code>1</code> to <code>n</code></p>",
        "id": 123572355,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520780612
    },
    {
        "content": "<p>So I think we need some notation for this plus a way of using it which is natural for mathematicians. Already when writing that sorried code above I noticed there was an issue with trying to figure out where the mathematician should insert the observation that <code>a&lt;=n+1</code> when summing from <code>a</code> to <code>n</code> (as otherwise this notation is not good).</p>",
        "id": 123572402,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520780713
    },
    {
        "content": "<p>Note that this is not an issue when <code>a&lt;=1</code>.</p>",
        "id": 123572404,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520780744
    },
    {
        "content": "<p>For that stuff about groups,  you could use<br>\n<code>lemma group_equiv_cosets_times_subgroup (hs : is_subgroup s) : nonempty (α ≃ (cosets s × s))</code> in group_theory in mathlib, and <code>fintype.of_equiv</code> should do it quite easily.</p>",
        "id": 123572451,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1520780828
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> did you read that Coq paper I linked to?</p>",
        "id": 123573203,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1520782677
    },
    {
        "content": "<p>No, I've been really busy all week on other things. I was just trying to catch up with everything today. What Coq paper are you talking about?</p>",
        "id": 123573244,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520782712
    },
    {
        "content": "<p>The multinomial theorem is a particularly interesting example of a \"finite sum fact\" because the assertion is that <code>(x1+x2+...+xn)^N</code> is a sum over the \"obviously finite\" set of nats <code>e1,e2,...,en</code> whose sum is <code>N</code>. Somehow a mathematician does no work at all when proving that this set is finite, it is obvious because all the <code>e_i</code> are bounded by <code>N</code>. But in Lean I would have to think about how to implement this, which is not really what I want to do. What is the \"correct\" formulation of the multinomial theorem in Lean? n is typically fixed and the induction is on <code>N</code> in the normal proof -- if you try induction on <code>n</code> then you will get embroiled in more complicated multinomial coefficient identities. But maybe this doesn't even matter. Even proving the \"obvious\" statement that if <code>e1+e2+...+en=N</code> then <code>e_i&lt;=N</code> seems like it might be some work. Is there any way of making some general theorems which mathematics students will be able to apply instinctively if they understand about nat but have no clue about fintype etc?</p>",
        "id": 123573439,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520783194
    },
    {
        "content": "<p>The one from this thread: <a href=\"http://www-sop.inria.fr/marelle/bigops/main.pdf\" target=\"_blank\" title=\"http://www-sop.inria.fr/marelle/bigops/main.pdf\">www-sop.inria.fr/marelle/bigops/main.pdf</a></p>",
        "id": 123573440,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1520783201
    },
    {
        "content": "<p>It's Coq's answer to your questions</p>",
        "id": 123573449,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1520783260
    },
    {
        "content": "<p>But Johannes says it may use some magic that Lean doesn't have (yet?). <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> what do you think about this canonical instance thing? Is it already in Lean? Will it be in Lean 4?</p>",
        "id": 123573536,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1520783407
    },
    {
        "content": "<p>i had no idea what a canonical structure was, but this paper was informative: <a href=\"https://hal.inria.fr/hal-00816703v1/document\" target=\"_blank\" title=\"https://hal.inria.fr/hal-00816703v1/document\">https://hal.inria.fr/hal-00816703v1/document</a></p>",
        "id": 123573792,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1520784046
    },
    {
        "content": "<p>from my 5-minute scanning of the paper, it seems like additional functionality for the type-class inference algorithm</p>",
        "id": 123573884,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1520784276
    },
    {
        "content": "<p>There are no plans to add canonical structures to Lean. I just read that paper as well (the conclusion at least), and it doesn't really list any advantages over type classes.</p>",
        "id": 123573886,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1520784292
    },
    {
        "content": "<p>Then why does <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> wrote this allows the big operators lib in Coq and it would be hard to do the same in Lean?</p>",
        "id": 123573938,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1520784392
    },
    {
        "content": "<p><a href=\"#narrow/stream/113488-general/subject/working.20with.20finite.20sequences/near/123533781\" title=\"#narrow/stream/113488-general/subject/working.20with.20finite.20sequences/near/123533781\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/subject/working.20with.20finite.20sequences/near/123533781</a></p>",
        "id": 123573945,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1520784469
    },
    {
        "content": "<p>The \"canonical big operators\" paper that Patrick drew my attention to seems to be very relevant to some of the issues here, but it is always talking about canonical structures.</p>",
        "id": 123573988,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520784560
    },
    {
        "content": "<p>Maybe we should ping <span class=\"user-mention\" data-user-id=\"110172\">@Assia Mahboubi</span> for more information here</p>",
        "id": 123573990,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1520784591
    },
    {
        "content": "<p>So I am reading through her \"Canonical Structures for the working Coq user\" paper. The first example (bottom of p3, top of p4) seems to be easily solvable with type classes. I think it would be more helpful for me to see a problem which Canonical Structures solved naturally but which the type class system does not solve so naturally.</p>",
        "id": 123578193,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520794401
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> I don't know if canonical structures have an advantage over Lean's type classes. I also don't think so. The difference canonical structurs &lt;-&gt; type classes just means that we can not take the Coq approach to big operators one-to-one, but we need to see what a good approach in Lean is.</p>",
        "id": 123598603,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1520841919
    },
    {
        "content": "<p>I am actively interested in this to the point that I am even trying to read the papers. I would love to hear <span class=\"user-mention\" data-user-id=\"110172\">@Assia Mahboubi</span> 's thoughts on this issue. At the end of the day one of the things I am extremely interested in currently is trying to teach undergraduate mathematicians how to write undergraduate level mathematics in Lean. And the fact that Kenny Lau (who in a 2 week period wrote a bunch of Lean code to do MSc-level mathematics which localised an arbitrary ring at a multiplicative set and proved all the key lemmas which I needed for schemes), told me that he had real trouble proving Lagrange's theorem (which is a triviality to a mathematician) in Lean, makes me really think that there needs to be some progress here. How can I help? All I can see so far is that there are about three ways of formalising the underlying combinatorial statement because there are about three ways of working with the concept which the ZFC'ist knows as \"a finite set\". I am still not at all clear as to whether the best idea is to formalise all of them, or to formalise one of them and then to encourage the end users to use that one.</p>",
        "id": 123602227,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520849551
    },
    {
        "content": "<p>Could it really be the case that in practice in Lean, a mathematician might find that the finite group they are interested in today is a fintype, the one they are interested in tomorrow is a finset, and the one they are interested in the day after tomorrow is a group law on <code>fin 60</code>? Does that mean that they are doing it wrong, or does that mean that we need to be able to seamlessly translate all of these into one \"canonical type for working with finite groups\", or does that mean that the basic infrastructure needs to be written in all cases? These are fundamental questions and I do not have a clue as to what the best approach is.</p>",
        "id": 123602320,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520849731
    },
    {
        "content": "<p>I'm actually a bit confused by your question and the purpose of your investigation. Mathlib already has a variety of mechanisms for dealing with finiteness in all its guises, and they are tested and used effectively in a variety of situations. What more do you want?</p>",
        "id": 123603424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1520851899
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I think the question is, there are loads of things dealing with finite sets, how do people know which one to use in which circumstance?</p>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Finite groups always have to be a type, since <code>group</code> takes a type as an argument, and defining operations on finsets is messy. I tend to use finite sets mostly, and then coerce into a type whenever necessary, and not use finsets unless I'm doing <code>finset.sum</code> or I have to prove something 'obvious' about fintypes. I imagine finsets are better than finite sets for computability, which I don't really care about. There are things that I still don't really understand about finite sets like why for sets <code>finite s</code> and <code>fintype s</code>are both defined, given that the library doesn't usually try to avoid using choice. I always just use fintype s.</p>",
        "id": 123603933,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1520852810
    },
    {
        "content": "<p>Not using choice isn't the only reason to be constructive. Computable functions are literally evaluable by the VM, and mathlib is in part a programming library (reminder: it was once called stdlib)</p>",
        "id": 123604007,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1520852960
    },
    {
        "content": "<p>It's also often more convenient to work with a typeclass <code>fintype</code> rather than a predicate <code>finite</code></p>",
        "id": 123604056,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1520853024
    },
    {
        "content": "<p>but they each have their uses, and after some discussion we decided to keep both</p>",
        "id": 123604059,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1520853051
    },
    {
        "content": "<p>If your theorem has a natural statement with both, then why not have two theorems?</p>",
        "id": 123604072,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1520853090
    },
    {
        "content": "<p>I get that. What I don't understand is what is the advantage of finite over noncomputable fintype, given that neither is computable?</p>",
        "id": 123604073,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1520853104
    },
    {
        "content": "<p><code>finite</code> is a Prop, so it has prop irrelevance stuff</p>",
        "id": 123604112,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1520853132
    },
    {
        "content": "<p>and it can be shoved into a <code>set</code>, etc</p>",
        "id": 123604113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1520853144
    },
    {
        "content": "<p>Most of the time using the wrong notion will simply be a type error, and that's your hint at the different uses of each</p>",
        "id": 123604123,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1520853186
    },
    {
        "content": "<p>i.e. there is no <code>finite.sum</code> but there is <code>finset.sum</code></p>",
        "id": 123604126,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1520853206
    },
    {
        "content": "<p>That makes sense. I think the answer to <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> 's question is that you just have to learn the differences between all the different forms of finite sets.</p>",
        "id": 123604180,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1520853314
    },
    {
        "content": "<p>You can't really get away with trying to only use one of them</p>",
        "id": 123604190,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1520853352
    },
    {
        "content": "<p>right, they aren't <em>alternatives</em>, they are in complementary distribution</p>",
        "id": 123604231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1520853386
    },
    {
        "content": "<p>My question is this. Let's say I am about to write some teaching material to show 1st year undergraduate mathematicians how to formally verify the proof of Lagrange's theorem that they have seen in their undergraduate mathematics lectures. My goal is to make the Lean version of this proof look like the maths version, presented in a natural if somewhat pedantic way. If a student works through this material (which does not yet exist but I hope it will exist in the very near future) then at some point they will need to assert that some group or set is finite of size n. When they do this, I will have to teach them something about how Lean handles finite objects. Is there a natural \"idiomatic\" choice of how to model this situation in Lean, or should I simply write the teaching material for, say, finsets and fintypes? What I am trying to establish is whether somehow there is one \"idiomatic\" way to prove that if X is a finite object which has been broken up into m disjoint subobjects each of which have size d, then the size of X is m*d. What I am trying to stress is that in maths (i.e. in ZFC) this is _one theorem_. In Lean is it several theorems, and I should be expected to use whatever DTT-translation of this one ZFC theorem is appropriate given the way I have formalised the situation, or is there one DTT theorem that I should prove and then I should deduce the other variants from this theorem? If someone comes up in the future with a completely different DTT way of modelling finite sets, should I be expecting to port the proof of this one ZFC theorem to this new set-up? Is that how it works?</p>",
        "id": 123610882,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520865348
    },
    {
        "content": "<p>Similarly, there is only one multinomial theorem in ZFC. It says that if n is a nat and x1,x2,..,xn are n elements of a ring (or even a semiring) and if N is a nat, then (x1+x2+...+xn)^N is a sum, over the finite set of n-tuples (e1,e2,..,en) of nats such that the sum of the ei is N, of some multinomial coefficient times x1^e1 x2^e2 ... xn^en. If I were to formalise this in Lean I am going to have to make a call about what exactly I am summing over. So I have the same question. Is there some \"canonical\" answer to this in Lean, or should I consider all the multitude of ways that this finite set can be modelled in type theory and prove the multinomial theorem in every case, or should I consider all the multitude of ways that this finite set can be modelled in type theory, choose one of them, prove the multinomial theorem for that one, and then deduce it for the others using some low-tech stuff which I can be 100 percent sure that mathematicians won't be interested in because they don't care about applying the identity function in set theory.</p>",
        "id": 123611726,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520866660
    },
    {
        "content": "<p>The reason I am actively interested in these questions now is that I am going to write a lot of teaching materials for mathematics undergraduates, showing them how to do undergraduate level mathematics in Lean, so I really have to engage with the issue that whilst I can now do this kind of mathematics myself in Lean, I do not know the \"best\" way to do it, and I do not want to teach bad ways of doing things. I hope I have made my questions sufficiently precise that someone can say something illuminating about which path to take.</p>",
        "id": 123611809,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520866791
    },
    {
        "content": "<p>The tl;dr is basically \"Formalise Lagrange's theorem in Lean, taking care to explain why you chose this way of doing it\".</p>",
        "id": 123611899,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520866858
    },
    {
        "content": "<p>and similarly for the multinomial theorem</p>",
        "id": 123611907,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1520866866
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> , I have been away from zulip for a while, and I missed this very interesting discussion. I hope it's not too late to contribute. But there seem to be several interleaved topics here. <br>\nSo I'll start with the trouble with the Lagrange trivial theorem.  From my experience, there are two issues behind the formalization of this lemma. One is finiteness, but there is also a matter of avoiding to introduce \"too many types\" in the story.<br>\nAt the end of the day, finite group theory is about studying the relative properties of subgroups, not much about the relative properties of the elements of a given group. So it should be easy to write (and not unreasonably difficult to prove) statements about groups (as opposed to statements about their elements). Therefore, it is a good idea to introduce a type for groups which can be easily combined, that is groups sharing the same law (and neutral element). And to reason about the (sub)groups of a same \"domain\". <br>\nAs far as I can see, this is not the approach taken by <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> <a href=\"https://github.com/leanprover/mathlib/blob/4ceb545f7e07431263e1131a9c9524a28de99472/group_theory/subgroup.lean#L88\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/4ceb545f7e07431263e1131a9c9524a28de99472/group_theory/subgroup.lean#L88\">here</a>.<br>\nI was not able to find the proof by Chris that you mention, so may be you know all this very well already. Sorry for the noise in that case.<br>\nIf not, and  since you wrote that: </p>\n<blockquote>\n<p>I am actively interested in this to the point that I am even trying to read the papers. </p>\n</blockquote>\n<p>then I would suggest (sorry for the self recommendation) this note: <a href=\"https://hal.inria.fr/hal-00825074/file/main.pdf\" target=\"_blank\" title=\"https://hal.inria.fr/hal-00825074/file/main.pdf\">https://hal.inria.fr/hal-00825074/file/main.pdf</a> . Skip the beginning and start p.4.  </p>\n<p>In mathcomp, the \"master\" version of  Lagrange theorem is <a href=\"https://github.com/math-comp/math-comp/blob/3d59940ff4601713e8395f6b7e5c525501183731/mathcomp/fingroup/fingroup.v#L1959\" target=\"_blank\" title=\"https://github.com/math-comp/math-comp/blob/3d59940ff4601713e8395f6b7e5c525501183731/mathcomp/fingroup/fingroup.v#L1959\">here</a>. I would suggest first looking to the statement rather than  to the proof scripts. This one says that for any 2 (finite) groups G, H, the cardinal of the intersection of G and H, multiplied by the number of G-right cosets for elements in H (this is the index), is the cardinal of G. It is  followed by a litany of variants and corollaries. The line where G and H are assumed to be sugroups of a same domain is <a href=\"https://github.com/math-comp/math-comp/blob/3d59940ff4601713e8395f6b7e5c525501183731/mathcomp/fingroup/fingroup.v#L1957\" target=\"_blank\" title=\"https://github.com/math-comp/math-comp/blob/3d59940ff4601713e8395f6b7e5c525501183731/mathcomp/fingroup/fingroup.v#L1957\">here</a>.</p>",
        "id": 123703741,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1521036850
    },
    {
        "content": "<blockquote>\n<p>Should <code>S</code> be a finset, a fintype, or a set S for which <code>finite S</code> is true? What if we are given <code>S</code> as a subtype and we don't even know it's finite, and want to prove this from the fact that we can partition it up into <code>m</code> subsets of size <code>d</code>? </p>\n</blockquote>\n<p>This one is easy: if this situation is really going to happen (proving finiteness from a presentation as a finite partition into finites), then <code>S</code> should be a non-necessarily finite set, and you would then add the <code>finite S</code> property to your conclusion.</p>",
        "id": 123704159,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1521037578
    },
    {
        "content": "<p>Aah yes of course, if you don't know it's finite yet then it had better not be a type which is provably finite :-) What I am still confused about is whether one should prove three theorems (one for finsets, one for fintypes and one for finite sets) all of which say \"if it's a disjoint union of X things of size Y, it has X*Y\" or whether one should prove one theorem for one of them and deduce the analogous theorems for the other two. The reason this is troublesome for me is that in ZFC this is one theorem and some way I am still uncomfortable about making it three theorems in DTT.</p>",
        "id": 123704233,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521037728
    },
    {
        "content": "<p>this might be a dumb question, but shouldn't it be the case that if it holds for fintypes, it holds for finite sets and finsets?</p>",
        "id": 123704819,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1521038584
    },
    {
        "content": "<p>the constructive interpretation is stronger than the classical ones</p>",
        "id": 123704826,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1521038597
    },
    {
        "content": "<p>therefore if I knew a theorem was true and had a constructive interpretation I would prove that first and derive if for the others</p>",
        "id": 123704896,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1521038676
    },
    {
        "content": "<blockquote>\n<p>There are no plans to add canonical structures to Lean. I just read that paper as well (the conclusion at least), and it doesn't really list any advantages over type classes.</p>\n</blockquote>\n<p>Canonical structures/instances were implemented in Coq 10 years before type classes, by Amokrane Saïbi, who coined the name. The authors of the Coq type classes mechanism were not aware of canonical structures (which should really be called canonical instances). As far as I can tell, the \"type class\" vocabulary has been borrowed from the Haskell programming language, where it means something related but different though. The Mathematical components library started using canonical structures well before type classes became usable in Coq.</p>\n<p>I am not sure that the exact difference between the two is very relevant to this thread. But for what it's worth the main advantage (a big one for my own usage) is that the user has full control on the instance searching strategy, for each class she declares. In Coq, instance look-up can become very subtle to control and result in seemingly non-terminating type-checking.  Lean might very well be much better behaved in that respect, I have not tried enough. But it is difficult to illustrate this kind of trouble on toy examples, as one needs a non-trival hierarchy and a few instances populating it.</p>",
        "id": 123704982,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1521038778
    },
    {
        "content": "<blockquote>\n<p>Then why does <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> wrote this allows the big operators lib in Coq and it would be hard to do the same in Lean?</p>\n</blockquote>\n<p>I do not Lean well enough to assess the feasibility of this transposition. <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> is much more knowledgeable than I am... However I do not understand his post as saying that it would be hard but as saying that it would not be a straightforward direct transposition, as the inference mechanism used is a bit different. It might not be too hard though. Also, the big operators library uses its own, independent, hierarchy of structures (flavours of monoids) . Then operations of commutative rings for examples are declared as instances of these structures so that the corresponding infrastructure material becomes available. So in principle a big operator library on this model could start as an independent development.</p>",
        "id": 123705329,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1521039292
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  it reminds me of your observation that \"wow, lean developers really make metric spaces a subclass of topological spaces\". all metric spaces are topological spaces, but not all topological spaces are metric-able . in the same way, (my poor understanding here is that) all fintypes can be considered as a finset or finite set, but the reverse isn't true</p>\n<p>I think you could define it once for fintypes and then a tactic to move a proof on fintypes to a proof on finite sets</p>",
        "id": 123705348,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1521039317
    },
    {
        "content": "<blockquote>\n<p>this might be a dumb question, but shouldn't it be the case that if it holds for fintypes, it holds for finite sets and finsets?</p>\n</blockquote>\n<p>Well it holds for all of them so of course your assertion must be true :-) I don't know what \"the constructive interpretation is stronger than the classical ones\" actually means :-( because I have been classical for so long and have no feeling at all for constructive mathematics. But are you saying that I should prove it for fintypes and deduce it for the others? Johannes' proof doesn't use any finiteness at all, he just proves that G bijects with H x (G/H) in general, which is a stronger statement but I would imagine is not constructive (in fact I pretty much know for sure that it is not, if you had a given bijection then I imagine you would be able to choose an element in each coset, which surely requires the axiom of choice).</p>",
        "id": 123705421,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521039395
    },
    {
        "content": "<p>all I mean by stronger is that for all Propositions, if it holds for fintype, it must hold for a finite set</p>",
        "id": 123705611,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1521039637
    },
    {
        "content": "<p>A mathematician wouldn't say \"all metric spaces are topological spaces\", they would say that there is a canonical construction that starts with a metric space and produces a completely different object, namely a topological space. It's easy to give examples of different metric spaces which give rise to the same topological space (e.g. take a metric space and then just double the metric, i.e. decree that every point is now twice as far from every other point as it used to be, like changing from miles to kilometres). My surprise was the fact that this construction had been embedded not as a functor from metric spaces to topological spaces, but as part of the definition of a metric space, when manifestly it is just extra junk which follows automatically from the definition of the functor and the axioms of a metric space. As a mathematician I am concerned about this, because in my normal working life I am interested in structures which are a bazillion times more complicated than topological spaces, and if we want every functor to be a forgetful functor then in Lean it sounds a priori that these objects will be terrifying. However since I have learnt about how Lean can be told to fill in structure fields automatically I am less concerned about this (although it still sounds like a very anti-computer-science thing to do: if I just defined you a metric space then why are you now going through the motions to define a topology on it when I might never be using it?)</p>",
        "id": 123705682,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521039736
    },
    {
        "content": "<p>this is because of how type-class inference works as a prolog-like search :)</p>",
        "id": 123705779,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1521039911
    },
    {
        "content": "<p>if you imagine a hierarchy of types, it starts at the top and goes down</p>",
        "id": 123705791,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1521039924
    },
    {
        "content": "<blockquote>\n<p>all I mean by stronger is that for all Propositions, if it holds for fintype, it must hold for a finite set</p>\n</blockquote>\n<p>It might not be quite as easy -- e.g. if one proves that a subtype of a product of finitely many fintypes is a fintype, then it will be true that a subset of a product of finitely many finite sets is a finite set, but one can't just prove it by saying \"every finite set is a fintype\", one has to also prove that the functor from finite sets to fintypes commutes with a bunch of structures and furthermore that constructions on one side have some mirror on the other side.</p>",
        "id": 123705799,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521039931
    },
    {
        "content": "<p>it may not be trivial, but it can be automated</p>",
        "id": 123705885,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1521040057
    },
    {
        "content": "<p>that's the whole point of the relator construction used in defining lean's integers (I think, somebody better at Lean than me  correct me if I'm wrong).</p>",
        "id": 123705932,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1521040084
    },
    {
        "content": "<p>And if my understanding is correct then if you want to do all this with the type class inference system then you are going to need to carry the fintype around as part of the structure of the finite set, and that might mean re-defining the finite set structure</p>",
        "id": 123705939,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521040091
    },
    {
        "content": "<p>My gut feeling is that you will need theorems such as \"there's a bijection between the subsets of a finite set and the subtypes of a finite type, and the bijection preserves cardinality\" -- that sort of thing. I am definitely not an expert in these matters and maybe it's all much easier than I am suggesting, but I hope I am getting my point across: currently I feel like every theorem about finite sets in ZFC seems to be translating into three theorems in DTT and I am still sort-of confused about which one I should be proving, or whether I should be proving all of them.</p>",
        "id": 123706109,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521040367
    },
    {
        "content": "<p>yes, exactly, you prove the bijection exists and a few other properties (i've never used relator) and then get a tactic out that moves proofs on fintype to finset</p>",
        "id": 123706183,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1521040475
    },
    {
        "content": "<p>then, going forward, you write one proof for fintype and automatically get the other two</p>",
        "id": 123706198,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1521040508
    },
    {
        "content": "<p>To go back to the other example, the multinomial theorem is a theorem that says (x1+x2+...+xn)^N = big finite sum of terms. In ZFC you just sum over the finite set {e1,e2,...,en} with ei all nats and their sum has to be N. If I formalise the multinomial theorem using a sum over a fintype, is it conceivable that someone in the future will want it but with a sum over a finite set instead? And if this happens, is it because they wrote bad code, or are they expected to deduce the formulation they want from the one I give them, or am I expected to prove three or four versions of the multinomial theorem? Here I could be summing over a finset, a fintype, a finite set or even a carefully-chosen finsupp type thing I suspect.</p>",
        "id": 123706211,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521040535
    },
    {
        "content": "<p>you could imagine defining a type class <code>has_sum</code> and providing instances for all of the above, that would make it easy to use, but not easy to write</p>",
        "id": 123706510,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1521040966
    },
    {
        "content": "<p>but this is really getting above my paygrade, i feel like johannes or mario would have a more informed opinion</p>",
        "id": 123706590,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1521041102
    },
    {
        "content": "<p>I should make clear my intentions here -- what I really really want to be able to do is to make things look easy for undergraduate mathematicians, who are used to the ZFC way. They only see one Lagrange theorem, and it's a theorem about finite groups, which are finite sets with some extra structure. They only see one multinomial theorem. When they sum from 1 to n (and they do, we often start at 1) they really do not care if [1...n] is a finset, fintype, list or whatever. They're just summing from 1 to n. I want to make Lean look like this to them because now I understand that this is possible -- I can tell them to type \"import xena\" on line 1 and then just do what I say to do all this sort of stuff. What I am unsure about is the best way of implementing it.</p>",
        "id": 123706648,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521041196
    },
    {
        "content": "<p>That is why I am asking all these weird questions. I want to write infrastructure which they will never see, cover it up with functions which I will point them to, and then hopefully deal with all their issues relatively easily.</p>",
        "id": 123706670,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521041252
    },
    {
        "content": "<p>And I just don't know if this is easy or unfeasible.</p>",
        "id": 123706688,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521041271
    },
    {
        "content": "<p>But I want to get on and write it.</p>",
        "id": 123706753,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521041358
    },
    {
        "content": "<p>Because it is in everyone's interests that mathematicians begin to think of these proof verification tools as normal, and easy to use.</p>",
        "id": 123706763,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521041397
    },
    {
        "content": "<p>And currently (for mathematicians) they are neither.</p>",
        "id": 123706807,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521041405
    },
    {
        "content": "<p>no need to edit that last sentence, it's true for cs as well</p>",
        "id": 123706844,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1521041462
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I'm not sure you understood my point before, but let me say it this way: <code>finset</code> and <code>finite</code> are not interchangeable in any sense. They apply to completely different things - <code>finset A</code> is the collection of finite subsets of <code>A</code>, while <code>finite s</code> is a proof that <code>s</code> is a finite set. There are some obvious relations between these two, and they are all true, but \"S is finite\" and \"the fin-powerset of A\" just aren't the same concept and they need two different names.</p>",
        "id": 123723502,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1521064462
    },
    {
        "content": "<p>On the other hand, <code>fintype</code> is almost interchangeable with <code>finite</code>, in the sense that it is discussing roughly the same concept. Again there are applicability differences: <code>fintype A</code> takes a type, while <code>finite s</code> takes a set, and moreover the definition of <code>finite s = nonempty (fintype s)</code> should give you a strong hint at which is more generally applicable.</p>",
        "id": 123723576,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1521064592
    },
    {
        "content": "<p>OK so <code>fintype &gt;&gt; finite</code> and now it's just between <code>fintype</code> and <code>finset</code>. Now the problem I envisage is that if someone puts a group structure on something of type <code>fintype</code> and then proves Lagrange's Theorem for it, can someone else now come along with  a group structure on something of type <code>finset</code> and not be able to use it?</p>",
        "id": 123725943,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521068271
    },
    {
        "content": "<p>You can't define a group structure on something of type finset.</p>",
        "id": 123725986,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1521068313
    },
    {
        "content": "<p>Oh!</p>",
        "id": 123725987,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521068319
    },
    {
        "content": "<p>Can I get to \"the underlying set\"?</p>",
        "id": 123726007,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521068389
    },
    {
        "content": "<p>{x | x in s}</p>",
        "id": 123726069,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1521068411
    },
    {
        "content": "<p>Oh meh the \"underlying set\" is an equivalence class of lists</p>",
        "id": 123726071,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521068413
    },
    {
        "content": "<p>There's a function in mathlib somewhere that does that, finset.to_set or something</p>",
        "id": 123726086,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1521068447
    },
    {
        "content": "<p>your notation seems to work fine</p>",
        "id": 123726114,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521068509
    },
    {
        "content": "<p>it makes a set</p>",
        "id": 123726157,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521068525
    },
    {
        "content": "<p><code>def T := {x // x ∈ v}</code> also works</p>",
        "id": 123726169,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521068552
    },
    {
        "content": "<p>\\u s might even work</p>",
        "id": 123726174,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1521068568
    },
    {
        "content": "<p>I stay away from \\u</p>",
        "id": 123726183,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521068583
    },
    {
        "content": "<p>why?</p>",
        "id": 123726189,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1521068599
    },
    {
        "content": "<p>A \"finite group\" is a group whose elements are enumerated by a finset. That is <code>fintype</code>. There is no other reasonable interpretation here</p>",
        "id": 123726192,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1521068607
    },
    {
        "content": "<p>I have always forgotten what it means 5 minutes after I use it</p>",
        "id": 123726193,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521068611
    },
    {
        "content": "<p>So the Lean word for \"finite set\" really is <code>fintype</code>? This is the type which I need to focus on when working with finite objects?</p>",
        "id": 123726248,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521068662
    },
    {
        "content": "<p>a particular finset is not a type, so it can't have a group structure</p>",
        "id": 123726249,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1521068663
    },
    {
        "content": "<p>Probably lots of useful stuff to put in docs. instances are on types, and function are generally on types.</p>",
        "id": 123726261,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1521068691
    },
    {
        "content": "<p>I see. A finset is just a term, which has a type but which isn't a type</p>",
        "id": 123726263,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521068693
    },
    {
        "content": "<p>If you have a finset <code>s</code>, then the type <code>{x // x \\in s}</code> is a fintype, because it is enumerated by <code>s</code></p>",
        "id": 123726283,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1521068751
    },
    {
        "content": "<p>One warning I should give is that <code>fintype</code> is in the \"constructive fragment\", which is to say that a construction of a <code>fintype</code> from other <code>fintype</code>s should be computable if possible</p>",
        "id": 123726339,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1521068860
    },
    {
        "content": "<p>Some of my misunderstanding in this thread is because I have never worked with any of these finite objects before, so was asking questions which I could imagine could be well-formulated but in retrospect might not make any sense.</p>",
        "id": 123726394,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521068930
    },
    {
        "content": "<p>So I can't put a group structure \"on a list\", as it were. You see I am befuddled by all this set theory. <em>everything is a set</em> in set theory so you can attempt to put any structure on anything, in some sense.</p>",
        "id": 123726460,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521069014
    },
    {
        "content": "<p>I think that once you work with these for a bit, you will notice the \"complementary distribution\" stuff I said: it's not actually a problem which to use in most cases, since they aren't interchangeable, so use the one that makes sense and it will probably be the right one</p>",
        "id": 123726461,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1521069018
    },
    {
        "content": "<p>Not every term is a type.</p>",
        "id": 123726462,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521069034
    },
    {
        "content": "<p><code>use the one that makes sense and it will probably be the right one</code> oh but I don't want to go back there.</p>",
        "id": 123726473,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521069068
    },
    {
        "content": "<p>That's exactly what starts getting me worried.</p>",
        "id": 123726476,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521069083
    },
    {
        "content": "<p>because it then sounds like someone else might be in some other situation where another choice is the right one for them, and then we will need two theorems that say the same thing, one for each choice. At least I can envisage that this might be the case. Does this simply not happen in practice?</p>",
        "id": 123726530,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521069135
    },
    {
        "content": "<p>My point is that there is no choice, only one of them will make sense in a given situation</p>",
        "id": 123726538,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1521069170
    },
    {
        "content": "<p>As I say, I think that to a certain extent it is my inexperience with type theory, and my attempt to push naive ideas over from set theory in an incorrect way, which have led me to this confusion. I am having to learn a new foundation for a subject which I know very well and for which I have have thought hard about foundational issues over the last few decades. Now I have to completely rewire myself. This is why I am so keen to teach students, because at the end of the day I don't think it matters what your foundation is.</p>",
        "id": 123726606,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521069317
    },
    {
        "content": "<p>but their minds haven't been polluted with ZFC yet.</p>",
        "id": 123726612,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521069339
    },
    {
        "content": "<p>I think these issues come up in set theory too, which has enough soft typing to make sense of these ideas, if not formally</p>",
        "id": 123726628,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1521069360
    },
    {
        "content": "<p>If you have a list (x1, x2, x3), it's \"elements\" are some nonsense kuratowski stuff, that's not what you meant</p>",
        "id": 123726675,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1521069392
    },
    {
        "content": "<p>No sure, it's the same with group theory, maybe a group is a 3-tuple or something, but we know what we mean by \"elements\" in any given case.</p>",
        "id": 123726805,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521069654
    },
    {
        "content": "<p>The point is that we can almost always coerce some elements out of the set, whereas in type theory it is just dawning on me that sometimes there is no \"underlying type\".</p>",
        "id": 123726820,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521069698
    },
    {
        "content": "<p>In set theory, even 4 is a set, so I could put a group law on it.</p>",
        "id": 123726864,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521069727
    },
    {
        "content": "<p>It's only just dawning on me that this doesn't even make sense in type theory.</p>",
        "id": 123726865,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521069744
    },
    {
        "content": "<p>Contrast my behaviour with Chris, who knows no set theory -- I am a professor and he is an undergraduate who has seen no set theory, and in some sense he has the advantage here because he realises what a nonsense idea it is to start putting a group structure on the number 4</p>",
        "id": 123726887,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521069807
    },
    {
        "content": "<p>whereas it's just something I've always known can be done but was junk.</p>",
        "id": 123726893,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521069823
    },
    {
        "content": "<p>But year after year after year in mathematics departments we are going to be teaching them either set theory, or no foundations at all. Any move to change this in the past would have been met with \"but set theory is _fine_! It's worked for 100 years and who cares about the junk theorems\".</p>",
        "id": 123726957,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521069930
    },
    {
        "content": "<p>I wonder if they teach type theory courses in the computer science department? Is that likely?</p>",
        "id": 123727008,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521069992
    },
    {
        "content": "<p>I know they teach Haskell in term 1 year 1</p>",
        "id": 123727016,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521070015
    },
    {
        "content": "<p>but I wonder if they take it any further.</p>",
        "id": 123727033,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521070031
    },
    {
        "content": "<p><code>https://psvg.doc.ic.ac.uk/2018/03/14/formal-methods-meets-js.html</code></p>",
        "id": 123727119,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521070173
    },
    {
        "content": "<p><a href=\"https://psvg.doc.ic.ac.uk/2018/03/14/formal-methods-meets-js.html\" target=\"_blank\" title=\"https://psvg.doc.ic.ac.uk/2018/03/14/formal-methods-meets-js.html\">https://psvg.doc.ic.ac.uk/2018/03/14/formal-methods-meets-js.html</a></p>",
        "id": 123727120,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521070176
    },
    {
        "content": "<p>happening about 50 metres from my office on Monday.</p>",
        "id": 123727121,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521070189
    },
    {
        "content": "<p>Do I care about javascript program verification?</p>",
        "id": 123727178,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521070222
    },
    {
        "content": "<p><a href=\"https://psvg.doc.ic.ac.uk/teaching/separationlogic.html\" target=\"_blank\" title=\"https://psvg.doc.ic.ac.uk/teaching/separationlogic.html\">https://psvg.doc.ic.ac.uk/teaching/separationlogic.html</a></p>",
        "id": 123727257,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521070337
    },
    {
        "content": "<p>any use for Lean?</p>",
        "id": 123727260,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521070347
    },
    {
        "content": "<p>I even know some of these people</p>",
        "id": 123727264,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521070354
    },
    {
        "content": "<p>That looks pretty useful. I started a separation logic package, in parts so that I can learn from it and in parts because it's useful</p>",
        "id": 123728543,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1521072866
    },
    {
        "content": "<blockquote>\n<p>In set theory, even 4 is a set, so I could put a group law on it.</p>\n</blockquote>\n<p>The only difference between set theory and type theory here is that in type theory these are <em>formally</em> disallowed where in set theory they are just stupid things no one would ever bother to do. (In this case, 4 actually has a reasonable set theoretic interpretation, as the ordinal 4 = {0, 1, 2, 3}, and I can see at least one natural group on this set, but usually this isn't the case, you get some modeling specific thing that is \"brittle\" in the same sense as I've discussed with brittle proofs. It breaks an abstraction barrier.)</p>",
        "id": 123736197,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1521090071
    },
    {
        "content": "<p>The point I'm trying to make is that type theory should not be a major change from the mathematician's status quo. It is only disallowing things that we were all trying to avoid in the first place (i.e. junk theorems), so unless you were abusing the abstractions you shouldn't even notice the difference. (And if you were, well there are some coercions you will need to insert, like <code>4</code> -&gt; <code>fin 4</code>.)</p>",
        "id": 123736291,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1521090302
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> and <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span>  I worked a little bit on finsupp: it got computable, i.e. the projection of the support of a finsupp are now rfl-lemmas. But more important: I added a induction lemma <code>finsupp.induction_on</code>.</p>\n</blockquote>\n<p>I just realized that this breaks my tensor product, but I suppose it will make it easier</p>",
        "id": 124550511,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522711158
    },
    {
        "content": "<p>Do you see any easy proof of this?</p>\n<div class=\"codehilite\"><pre><span></span>theorem structural_theorem (f : free_abelian_group β γ) :\n  ∃ S : finset (free_abelian_group β γ), (∀ g ∈ S, ∃ (x : β) (y : γ) (n : ℤ) (H : n ≠ 0), g = finsupp.single (x, y) n) ∧ S.sum id = f :=\n</pre></div>",
        "id": 124550578,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522711286
    },
    {
        "content": "<p>nvm, I proved it</p>",
        "id": 124551662,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522712999
    }
]
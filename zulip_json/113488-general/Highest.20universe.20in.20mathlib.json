[
    {
        "content": "<p>We all know we have infinitely many universes in Lean, and basically everything is universe-polymorphic in mathlib, but how many universes do we really need currently? That is, to which point can we squish down all universes in mathlib and still have everything typecheck? Kevin argued that <code>Type 1</code> was enough, but I suspect some constructions in category might something higher.</p>",
        "id": 265998823,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640348924
    },
    {
        "content": "<p>Certainly <code>Type 2</code> will be good enough. I think that's what's needed for LTE.</p>",
        "id": 265998859,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1640348977
    },
    {
        "content": "<p>I must say I'm surprised we don't need anything higher!</p>",
        "id": 266004157,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640354711
    },
    {
        "content": "<p>I'm not. If you're a set theorist then you think everything is a set so everything's in Type. Definitions like ordinals and the category of all sets/groups etc are called classes, and they're all in Type 1.</p>",
        "id": 266008657,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640359411
    },
    {
        "content": "<p>Classically in mathematics you only deal with sets and classes</p>",
        "id": 266008672,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640359435
    },
    {
        "content": "<p>Remember that historically mathematicians didn't even need sets! People like Gauss and Euler worked with terms and functions. Then Galois came along and said \"I think it would be helpful if we could identify the permutation group of +-sqrt(2) with the permutation group of +-sqrt(3) because I think I'm on to something\". It was only around then that we started needing to talk about some kind of holder type G for a collection of terms g. So in some sense before that we didn't even need Type. We just had concrete examples like the naturals, reals and complexes</p>",
        "id": 266008877,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640359623
    },
    {
        "content": "<p>The push to develop abstract group theory and then abstract algebra and ideas like homomorphisms of groups are historically very recent. This is when people started to want to talk about maps between abstract types -- functions had of course existed for centuries before that but again only between concrete types such as the sine and cosine function on the reals</p>",
        "id": 266008976,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640359734
    },
    {
        "content": "<p>So types became \"things\" and then set theory gave a name to the things, but Russell's paradox showed that you had to be careful so then we got things like ZFC and at that point mathematics was going on purely within Type.</p>",
        "id": 266009043,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640359803
    },
    {
        "content": "<p>Then category theory and homological algebra and Grothendieck came along and then people wanted to start talking about abstract mathematical objects such as the category of all sets, which weren't even in Type. Grothendieck fixed this by adding an extra axiom to set theory to enable more than one universe of types, or of sets as he called them, and even then you don't need infinitely many, you just need to allow yourself to do the occasional universe bump. Hence Type 1</p>",
        "id": 266009175,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640359944
    },
    {
        "content": "<p>I've been curious about this question for a while, so I decided to answer it for real instead of theorizing.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">inductive</span> <span class=\"n\">level_spec</span>\n<span class=\"bp\">|</span> <span class=\"n\">const</span> <span class=\"o\">:</span> <span class=\"n\">level</span> <span class=\"bp\">→</span> <span class=\"n\">level_spec</span>\n<span class=\"bp\">|</span> <span class=\"n\">parametric</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">name</span> <span class=\"bp\">→</span> <span class=\"n\">level</span> <span class=\"bp\">→</span> <span class=\"n\">level_spec</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">level.has_any_param</span> <span class=\"o\">:</span> <span class=\"n\">level</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">level.succ</span> <span class=\"n\">l</span><span class=\"o\">)</span>     <span class=\"o\">:=</span>  <span class=\"n\">l.has_any_param</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">level.max</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span><span class=\"o\">)</span>  <span class=\"o\">:=</span>  <span class=\"n\">l₁.has_any_param</span> <span class=\"bp\">||</span>  <span class=\"n\">l₂.has_any_param</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">level.imax</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span>  <span class=\"n\">l₁.has_any_param</span> <span class=\"bp\">||</span>  <span class=\"n\">l₂.has_any_param</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">level.param</span> <span class=\"n\">_</span><span class=\"o\">)</span>    <span class=\"o\">:=</span> <span class=\"n\">tt</span>\n<span class=\"bp\">|</span> <span class=\"n\">l</span>                  <span class=\"o\">:=</span> <span class=\"n\">ff</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">level.at_zero</span> <span class=\"o\">:</span> <span class=\"n\">level</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">level.succ</span> <span class=\"n\">l</span><span class=\"o\">)</span>     <span class=\"o\">:=</span> <span class=\"n\">l.at_zero</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">level.max</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"n\">max</span> <span class=\"n\">l₁.at_zero</span> <span class=\"n\">l₂.at_zero</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">level.imax</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">l₂.at_zero</span> <span class=\"k\">in</span> <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"n\">max</span> <span class=\"n\">l₁.at_zero</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span>                  <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">level_spec.at_zero</span> <span class=\"o\">:</span> <span class=\"n\">level_spec</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">level_spec.const</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">l.at_zero</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">level_spec.parametric</span> <span class=\"n\">_</span> <span class=\"n\">l</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"n\">l.at_zero</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">mutual</span> <span class=\"kd\">def</span> <span class=\"n\">get_expr_level</span><span class=\"o\">,</span> <span class=\"n\">get_const_spec</span> <span class=\"o\">(</span><span class=\"n\">env</span> <span class=\"o\">:</span> <span class=\"n\">environment</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ref</span> <span class=\"o\">(</span><span class=\"n\">name_map</span> <span class=\"n\">level_spec</span><span class=\"o\">))</span>\n<span class=\"k\">with</span> <span class=\"n\">get_expr_level</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">level</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">level</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"n\">v.fold</span> <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"n\">_</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"bp\">λ</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n  <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">expr.const</span> <span class=\"n\">n</span> <span class=\"n\">us</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"n\">sp</span> <span class=\"bp\">←</span> <span class=\"n\">get_const_spec</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"k\">match</span> <span class=\"n\">sp</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">level_spec.const</span> <span class=\"n\">l'</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"bp\">$</span> <span class=\"n\">l.max</span> <span class=\"n\">l'</span>\n    <span class=\"bp\">|</span> <span class=\"n\">level_spec.parametric</span> <span class=\"n\">us'</span> <span class=\"n\">l'</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"bp\">$</span> <span class=\"n\">l.max</span> <span class=\"bp\">$</span> <span class=\"n\">l'.instantiate</span> <span class=\"o\">(</span><span class=\"n\">us'.zip</span> <span class=\"n\">us</span><span class=\"o\">)</span>\n    <span class=\"kd\">end</span>\n  <span class=\"bp\">|</span> <span class=\"n\">expr.sort</span> <span class=\"n\">l'</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"bp\">$</span> <span class=\"n\">l.max</span> <span class=\"n\">l'</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"n\">l</span>\n  <span class=\"kd\">end</span>\n<span class=\"k\">with</span> <span class=\"n\">get_const_spec</span> <span class=\"o\">:</span> <span class=\"n\">name</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">level_spec</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">m</span> <span class=\"bp\">←</span> <span class=\"n\">read_ref</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n  <span class=\"k\">match</span> <span class=\"n\">m.find</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">sp</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"n\">sp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">process_decl</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">us</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">level</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">level_spec</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"n\">l.normalize</span><span class=\"o\">,</span>\n      <span class=\"k\">let</span> <span class=\"n\">sp</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">l.has_any_param</span> <span class=\"k\">then</span> <span class=\"n\">level_spec.parametric</span> <span class=\"n\">us</span> <span class=\"n\">l</span> <span class=\"k\">else</span> <span class=\"n\">level_spec.const</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n      <span class=\"n\">m</span> <span class=\"bp\">←</span> <span class=\"n\">read_ref</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n      <span class=\"n\">write_ref</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">m.insert</span> <span class=\"n\">n</span> <span class=\"n\">sp</span><span class=\"o\">),</span>\n      <span class=\"n\">pure</span> <span class=\"n\">sp</span><span class=\"o\">),</span>\n    <span class=\"n\">d</span> <span class=\"bp\">←</span> <span class=\"n\">env.get</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"k\">match</span> <span class=\"n\">d</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">declaration.defn</span> <span class=\"n\">n</span> <span class=\"n\">us</span> <span class=\"n\">t</span> <span class=\"n\">v</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n      <span class=\"n\">get_expr_level</span> <span class=\"n\">t</span> <span class=\"n\">level.zero</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">get_expr_level</span> <span class=\"n\">v</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">process_decl</span> <span class=\"n\">n</span> <span class=\"n\">us</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">declaration.thm</span> <span class=\"n\">n</span> <span class=\"n\">us</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n      <span class=\"n\">get_expr_level</span> <span class=\"n\">t</span> <span class=\"n\">level.zero</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">get_expr_level</span> <span class=\"n\">v.get</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">process_decl</span> <span class=\"n\">n</span> <span class=\"n\">us</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">declaration.cnst</span> <span class=\"n\">n</span> <span class=\"n\">us</span> <span class=\"n\">t</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">get_expr_level</span> <span class=\"n\">t</span> <span class=\"n\">level.zero</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">process_decl</span> <span class=\"n\">n</span> <span class=\"n\">us</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">declaration.ax</span> <span class=\"n\">n</span> <span class=\"n\">us</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">get_expr_level</span> <span class=\"n\">t</span> <span class=\"n\">level.zero</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">process_decl</span> <span class=\"n\">n</span> <span class=\"n\">us</span>\n    <span class=\"kd\">end</span>\n  <span class=\"kd\">end</span>\n\n<span class=\"kd\">run_cmd</span>\n  <span class=\"n\">using_new_ref</span> <span class=\"n\">mk_name_map</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"k\">do</span>\n  <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">tactic.get_env</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">env.fold</span> <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">name.anonymous</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">d</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"k\">do</span>\n    <span class=\"n\">p</span> <span class=\"bp\">←</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">d.to_name</span><span class=\"o\">,</span>\n    <span class=\"n\">sp</span> <span class=\"bp\">←</span> <span class=\"n\">get_const_spec</span> <span class=\"n\">env</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">sp.at_zero</span><span class=\"o\">,</span>\n    <span class=\"n\">pure</span> <span class=\"bp\">$</span> <span class=\"k\">if</span> <span class=\"n\">p.2</span> <span class=\"bp\">&lt;</span> <span class=\"n\">z</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">p</span><span class=\"o\">),</span>\n  <span class=\"n\">trace</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 266021888,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640376607
    },
    {
        "content": "<p>For the core library, the output is <code>(sigma.mk.inj_eq, 3)</code>, which is to say, if you were to specialize every definition to every concrete universe, then the largest subterm of the form <code>Sort u</code> that appears in the hierarchy of definitions leading to <code>sigma.mk.inj_eq.{0, 0}</code> is <code>Sort 3</code>, aka <code>Type 2</code>. <code>sigma.mk.inj_eq</code> is the only definition that gets as high as <code>3</code>.</p>\n<p>For mathlib, the output is <code>(measure_theory.L1.set_to_L1_congr_left', 4)</code>, and I'm checking now to see if there are any others at height 4. So the official answer seems to be that you need <code>Type 3</code> to compile mathlib, or alternatively, mathlib can be translated to work in ZFC with 4 inaccessible cardinals.</p>",
        "id": 266021896,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640376620
    },
    {
        "content": "<p>It looks like there are a huge number of definitions at height 4 (and <code>measure_theory.L1.set_to_L1_congr_left'</code> is a random selection). I will look for minimal ones.</p>",
        "id": 266021966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640376734
    },
    {
        "content": "<p>Just to be clear here -- if a random definition takes four types in, in universes u v w x, that doesn't artificially push the bound up to 4?</p>",
        "id": 266022673,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640377826
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.L1.set_to_L1_congr_left'\">docs#measure_theory.L1.set_to_L1_congr_left'</a></p>",
        "id": 266022682,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640377843
    },
    {
        "content": "<p>Here is the list of level 4 definitions that do not depend on any level 4 definitions (i.e. they are level 4 because they either directly use a large universe or reference a level 3 definition with a universe bump in the substitution):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">ordinal.omin._match_1</span>\n<span class=\"n\">nhds_is_measurably_generated</span>\n<span class=\"n\">finprod_mem_def</span>\n<span class=\"n\">finprod_eq_prod_of_mul_support_subset</span>\n<span class=\"n\">add_monoid_hom.map_finsum</span>\n<span class=\"n\">pSet.definable</span>\n<span class=\"n\">pSet.arity.equiv._main</span>\n<span class=\"n\">finprod_mem_univ</span>\n<span class=\"n\">algebraic_geometry.LocallyRingedSpace.coproduct._proof_4</span>\n<span class=\"n\">finprod_mem_empty</span>\n<span class=\"n\">category_theory.types_glue._proof_1</span>\n<span class=\"n\">category_theory.types_glue._proof_2</span>\n<span class=\"n\">ordinal.lift.principal_seg._proof_1</span>\n<span class=\"n\">hahn_series.summable_family.hsum._proof_1</span>\n<span class=\"n\">smooth_partition_of_unity.mk</span>\n<span class=\"n\">partition_of_unity.mk</span>\n<span class=\"n\">bump_covering.to_pou_fun</span>\n<span class=\"n\">finprod_cond_nonneg</span>\n<span class=\"n\">finsum_eq_sum_of_support_subset</span>\n<span class=\"n\">partition_of_unity.sum_eq_one'</span>\n<span class=\"n\">partition_of_unity.sum_le_one'</span>\n<span class=\"n\">smooth_partition_of_unity.sum_eq_one'</span>\n<span class=\"n\">partition_of_unity.sum_nonneg</span>\n<span class=\"n\">smooth_partition_of_unity.sum_le_one'</span>\n<span class=\"n\">finsum_mem_def</span>\n<span class=\"n\">finsum_mem_univ</span>\n<span class=\"n\">finsum_mem_congr</span>\n<span class=\"n\">algebraic_geometry.Scheme.basic_open_is_open_immersion</span>\n<span class=\"n\">uchange</span>\n<span class=\"n\">finsum_mem_induction</span>\n<span class=\"n\">algebraic_geometry.LocallyRingedSpace.has_coequalizer.image_basic_open._proof_2</span>\n<span class=\"n\">algebraic_geometry.LocallyRingedSpace.has_coequalizer.image_basic_open._proof_4</span>\n<span class=\"n\">algebraic_geometry.LocallyRingedSpace.has_coequalizer.image_basic_open._proof_8</span>\n<span class=\"n\">algebraic_geometry.LocallyRingedSpace.has_coequalizer.coequalizer_π_app_is_local_ring_hom</span>\n<span class=\"n\">finsum_mem_empty</span>\n<span class=\"n\">algebraic_geometry.LocallyRingedSpace.is_open_immersion.forget_preserves_pullback_of_left</span>\n<span class=\"n\">algebraic_geometry.LocallyRingedSpace.coproduct._proof_3</span>\n<span class=\"n\">category_theory.subcanonical_types_grothendieck_topology</span>\n<span class=\"n\">algebraic_geometry.PresheafedSpace.is_open_immersion.to_LocallyRingedSpace._proof_4</span>\n<span class=\"n\">algebraic_geometry.LocallyRingedSpace.coequalizer._proof_3</span>\n<span class=\"n\">classical.all_definable._main._proof_1</span>\n<span class=\"n\">finsum_mem_zero</span>\n<span class=\"n\">monoid_hom.map_finprod</span>\n<span class=\"n\">pSet.embed._match_1</span>\n<span class=\"n\">finprod_mem_induction</span>\n<span class=\"n\">classical.all_definable._main._proof_2</span>\n<span class=\"n\">at_bot_is_measurably_generated</span>\n<span class=\"n\">ordinal.typein_iso._match_1</span>\n<span class=\"n\">ordinal.typein_iso._proof_1</span>\n<span class=\"n\">pSet.arity.equiv._main._meta_aux</span>\n<span class=\"n\">finsum_dmem</span>\n<span class=\"n\">finprod_mem_one</span>\n<span class=\"n\">finprod_mem_congr</span>\n<span class=\"n\">category_theory.flat_iff_Lan_flat</span>\n<span class=\"n\">finprod_dmem</span>\n<span class=\"n\">at_top_is_measurably_generated</span>\n</code></pre></div>",
        "id": 266022683,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640377846
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> No, having lots of universe parameters does not bump the level, but instantiating those parameters (directly or indirectly) with a <code>u+1</code> somewhere does</p>",
        "id": 266022699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640377899
    },
    {
        "content": "<p><code>measure_theory.L1.set_to_L1_congr_left'</code> just looks to me like some random technical lemma in measure theory that has nothing to do with universes</p>",
        "id": 266022747,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640377952
    },
    {
        "content": "<p>The new list is probably more useful</p>",
        "id": 266022759,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640377978
    },
    {
        "content": "<p>How the hack can something like <code>finsum_mem_empty</code> need a nontrivial amount of universes?</p>",
        "id": 266022788,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1640378040
    },
    {
        "content": "<p>One thing that is a bit dicey about any calculation like this is that if you just chop off the universe hierarchy, then not every term has a type. Right now, the program is asserting for every definition that its type and value have to be typecheckable; perhaps it would be better to skip the type for definitions and theorems</p>",
        "id": 266022798,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640378042
    },
    {
        "content": "<p><code>finprod_mem_empty</code> needs four universes? I still don't think I understand the question :-)</p>",
        "id": 266022841,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640378071
    },
    {
        "content": "<p><code>finsum_mem_empty.{u_1, u_4}</code> has max universe <code>max (u_1+4) (u_4+2)</code></p>",
        "id": 266023002,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640378319
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/finsum_mem_empty\">docs#finsum_mem_empty</a></p>",
        "id": 266023016,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1640378357
    },
    {
        "content": "<p>lol what is going on</p>",
        "id": 266023092,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640378452
    },
    {
        "content": "<p>Wow! Thanks, Mario.</p>",
        "id": 266023111,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640378505
    },
    {
        "content": "<ul>\n<li><code>finsum_mem_empty.{u_1 u_4}</code> has max universe <code>max (u_1+4) (u_4+2)</code> because it uses <code>finsum.{u_4 u_1+1}</code></li>\n<li><code>finsum.{u_1 u_2}</code> has max universe <code>max (u_1+2) (u_2+3)</code>, still not sure where this is coming from, I will make a program to unravel it</li>\n</ul>",
        "id": 266023156,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640378565
    },
    {
        "content": "<p>lol I wrote <code>finprod_mem_empty</code></p>",
        "id": 266023323,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640378811
    },
    {
        "content": "<p>oh! Oh so the issue is <code>finsum</code>, not my lemma</p>",
        "id": 266023338,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640378840
    },
    {
        "content": "<p>You're in the highest universe, Kevin!</p>",
        "id": 266023342,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640378843
    },
    {
        "content": "<p>golly, I apparently wrote <code>finprod</code> too</p>",
        "id": 266023412,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640378920
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Highest.20universe.20in.20mathlib/near/266023156\">said</a>:</p>\n<blockquote>\n<p>still not sure where this is coming from, I will make a program to unravel it</p>\n</blockquote>\n<p>The answer is Kevin <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 266023433,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640378958
    },
    {
        "content": "<p>I'm pretty sure that other people told me what to write in that definition :-)</p>",
        "id": 266023441,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640378979
    },
    {
        "content": "<p>What is all this plift stuff?</p>",
        "id": 266023502,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640379039
    },
    {
        "content": "<p>Here's the program for outputting the level of a definition and its direct dependencies:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">level_spec.level</span> <span class=\"o\">:</span> <span class=\"n\">level_spec</span> <span class=\"bp\">→</span> <span class=\"n\">level</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">level_spec.const</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">l</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">level_spec.parametric</span> <span class=\"n\">_</span> <span class=\"n\">l</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"n\">l</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">level_spec.args</span> <span class=\"o\">:</span> <span class=\"n\">level_spec</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">name</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">level_spec.const</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">level_spec.parametric</span> <span class=\"n\">us</span> <span class=\"n\">_</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"n\">us</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.all</span> <span class=\"n\">true</span>\n<span class=\"kd\">run_cmd</span>\n  <span class=\"n\">using_new_ref</span> <span class=\"n\">mk_name_map</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"k\">do</span>\n  <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">tactic.get_env</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">finsum</span><span class=\"o\">,</span>\n  <span class=\"n\">l</span> <span class=\"bp\">←</span> <span class=\"n\">get_const_spec</span> <span class=\"n\">env</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">trace</span> <span class=\"o\">(</span><span class=\"n\">l.args</span><span class=\"o\">,</span> <span class=\"n\">l.level</span><span class=\"o\">),</span>\n  <span class=\"n\">d</span> <span class=\"bp\">←</span> <span class=\"n\">env.get</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"n\">d.value.fold</span> <span class=\"n\">mk_name_set</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"n\">_</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n    <span class=\"k\">if</span> <span class=\"n\">e.is_constant</span> <span class=\"k\">then</span> <span class=\"n\">m.insert</span> <span class=\"n\">e.const_name</span> <span class=\"k\">else</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"n\">map.fold</span> <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"o\">())</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"k\">do</span>\n    <span class=\"n\">r</span><span class=\"o\">,</span>\n    <span class=\"n\">l</span> <span class=\"bp\">←</span> <span class=\"n\">get_const_spec</span> <span class=\"n\">env</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"n\">trace</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">l.args</span><span class=\"o\">,</span> <span class=\"n\">l.level</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 266023654,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640379254
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Highest.20universe.20in.20mathlib/near/266022841\">said</a>:</p>\n<blockquote>\n<p><code>finprod_mem_empty</code> needs four universes? I still don't think I understand the question :-)</p>\n</blockquote>\n<p>I don't think I understand most of these examples either ... is it possible that many of them are just \"mistakes\"?  People mis-using universes when writing the lemma/definition?</p>",
        "id": 266023749,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1640379472
    },
    {
        "content": "<ul>\n<li><code>finsum_mem_empty.{u_1 u_4}</code> has max universe <code>max (u_1+4) (u_4+2)</code> because it uses <code>finsum.{u_4 u_1+1}</code></li>\n<li><code>finsum.{u_1 u_2}</code> has max universe <code>max (u_1+2) (u_2+3)</code>, because it uses <code>set.finite.to_finset.{u_2}</code></li>\n<li><code>set.finite.to_finset.{u}</code> has max universe <code>u+3</code>, because it uses <code>set.finite.fintype.{u}</code></li>\n<li><code>set.finite.fintype.{u}</code> has max universe <code>u+3</code>, because it uses <code>set.has_coe_to_sort.{u}</code></li>\n<li><code>set.has_coe_to_sort.{u}</code> has max universe <code>u+3</code>, because it uses <code>has_coe_to_sort.mk.{(max (u+1) 1) u+2}</code></li>\n<li><code>has_coe_to_sort.mk.{u v}</code> has max universe <code>max u (v+1)</code>, because its type uses <code>out_param.{v+1}</code></li>\n<li><code>out_param.{u}</code> has max universe <code>u</code>, because it mentions <code>Sort u</code></li>\n</ul>",
        "id": 266023832,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640379598
    },
    {
        "content": "<p>It seems that the index types alpha,beta,iota are allowed to be <code>Sort</code>s however <code>finset</code> takes a <code>Type</code>, that's what all the plift nonsense is all about.</p>",
        "id": 266023921,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640379626
    },
    {
        "content": "<p>I don't think that anything like that is going to cause spurious universe bumps</p>",
        "id": 266023943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640379661
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">set.has_coe_to_sort.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">has</span> <span class=\"n\">max</span> <span class=\"kd\">universe</span> <span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"n\">because</span> <span class=\"n\">it</span> <span class=\"n\">uses</span> <span class=\"n\">has_coe_to_sort.mk.</span><span class=\"o\">{(</span><span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>lol what is this?</p>",
        "id": 266023956,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640379674
    },
    {
        "content": "<p>whether the indexing starts at 0 or 1 for a given universe variable doesn't really matter</p>",
        "id": 266023958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640379678
    },
    {
        "content": "<p>yeah that one is a bit surprising</p>",
        "id": 266023963,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640379698
    },
    {
        "content": "<p>but you can see it clearly in the pp.all</p>",
        "id": 266023968,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640379718
    },
    {
        "content": "<p>Note that in the <code>has_coe_to_sort.mk</code> step, I'm actually looking at the <em>type</em> of the definition rather than the value (since it's a constructor). Looking at types can cause universe bumps, since <code>Type u : Type (u+1)</code> - if you insist that the type be well formed for the value to be then you will get no upper bound</p>",
        "id": 266024163,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640379972
    },
    {
        "content": "<p>Here's another way to look at the derivation:</p>\n<ul>\n<li><code>finsum_mem_empty.{0 0}</code> uses <code>finsum.{0 1}</code></li>\n<li><code>finsum.{0 1}</code> uses <code>set.finite.to_finset.{1}</code></li>\n<li><code>set.finite.to_finset.{1}</code> uses <code>set.finite.fintype.{1}</code></li>\n<li><code>set.finite.fintype.{1}</code> uses <code>set.has_coe_to_sort.{1}</code></li>\n<li><code>set.has_coe_to_sort.{1}</code> uses <code>has_coe_to_sort.mk.{2 3}</code></li>\n<li><code>has_coe_to_sort.mk.{2 3}</code> uses <code>out_param.{4}</code></li>\n<li><code>out_param.{4}</code> contains <code>Sort 4</code></li>\n</ul>\n<p>The last two examples might help to understand what's happening:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">finsum_mem_empty.</span><span class=\"o\">{</span><span class=\"mi\">0</span> <span class=\"mi\">0</span><span class=\"o\">}</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">finsum.</span><span class=\"o\">{</span><span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">set.finite.to_finset.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">set.finite.fintype.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">set.has_coe_to_sort.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">has_coe_to_sort.mk.</span><span class=\"o\">{</span><span class=\"mi\">2</span> <span class=\"mi\">3</span><span class=\"o\">}</span>\n<span class=\"c1\">-- has_coe_to_sort.mk.{2 3} : Π {a : Type 1} {S : out_param.{4} (Type 2)}, (a → S) → has_coe_to_sort.{2 3} a S</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">out_param.</span><span class=\"o\">{</span><span class=\"mi\">4</span><span class=\"o\">}</span>\n<span class=\"c1\">-- out_param.{4} : Type 3 → Type 3</span>\n</code></pre></div>\n<p><code>out_param</code> is just an identity function, but in order to apply the identity function to <code>Type 2</code> you need a <code>Type 3</code> to write the type of the argument</p>",
        "id": 266024592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640380687
    },
    {
        "content": "<p>If the uses of <code>set.has_coe_to_sort</code> were replaced by <code>subtype</code>, would this get rid of the +3 universe bump?</p>",
        "id": 266024621,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1640380786
    },
    {
        "content": "<p>here's a simplified example how you can get lots of bumping without really doing anything weird</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"n\">true</span>\n</code></pre></div>",
        "id": 266024694,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640380881
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> Yes, you have to eliminate the uses of <code>set.has_coe_to_sort</code> in dependents as well, but this version drops the level of <code>set.finite.fintype</code> from u+3 to u+1:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">set.finite'</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">subtype</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">set.finite'</span>\n\n<span class=\"kd\">lemma</span> <span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">set.finite_def'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set.finite'</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">subtype</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">h</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">h</span><span class=\"o\">⟩,</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">h</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">h</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">set.finite.fintype'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">set.finite'</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">subtype</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">classical.choice</span> <span class=\"bp\">$</span> <span class=\"n\">set.finite_def'.1</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 266025023,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640381378
    },
    {
        "content": "<p>Hmm, maybe <code>set.has_coe_to_sort</code> should be considered harmful ...</p>",
        "id": 266025137,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1640381491
    },
    {
        "content": "<p>Probably a better approach for determining the real axiomatic strength of mathlib would be to allow for higher universes that don't support inductive types at all. As long as you only use them in <code>id</code> applications like this that might be sufficient.</p>",
        "id": 266025197,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640381608
    },
    {
        "content": "<p>Looking at this some more, <code>finsum.{0 1} :  Π {M α : Type}, ...</code> which looks normal, but it references</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">set.finite.to_finset.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">s.finite</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>which seems gratuitous (why are we dealing with sets of elements in Type 1?). I suspect the reason is <code>plift : Sort u -&gt; Type u</code>. Perhaps we should try changing that to <code>plift : Sort u -&gt; Sort (max u 1)</code> and see what breaks</p>",
        "id": 266027209,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640384593
    },
    {
        "content": "<p>Oh, that won't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[irreducible]</span> <span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">finsum</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">finite</span> <span class=\"o\">(</span><span class=\"n\">support</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">plift.down</span><span class=\"o\">))</span> <span class=\"k\">then</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">h.to_finset</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i.down</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>Here <code>support (f ∘ plift.down)</code> is needed because <code>support</code> takes a <code>Type u'</code>, and if you had a variant of <code>plift</code> returning <code>Sort (max v 1)</code> then it wouldn't unify with <code>Type u'</code> because <code>u' + 1 = max v 1</code> does not have a solution for <code>u'</code> in level arithmetic</p>",
        "id": 266027340,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640384769
    },
    {
        "content": "<p>try <code>induction v</code>? ;-)</p>",
        "id": 266028993,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640386925
    },
    {
        "content": "<p>Whose idea was it to sum over Props anyway?</p>",
        "id": 266029011,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640386958
    },
    {
        "content": "<p>It was my idea</p>",
        "id": 266034940,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1640395714
    },
    {
        "content": "<p>This way you can write <code>\\sum^f n &lt; 5, n</code></p>",
        "id": 266034960,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1640395789
    },
    {
        "content": "<p>We need pfinsum :-)</p>",
        "id": 266035141,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640396045
    },
    {
        "content": "<p>Why? You won't get nice notation if you don't use the same <code>def</code> for sums over <code>n : nat</code> and <code>hn : n &lt; 5</code>.</p>",
        "id": 266036956,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1640399314
    },
    {
        "content": "<p>Do you really care about universe bump here?</p>",
        "id": 266036962,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1640399336
    },
    {
        "content": "<p>For me, I find <code>∑ᶠ n &lt; 5, n</code> more important than avoiding universe bumps.</p>",
        "id": 266041913,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1640408131
    },
    {
        "content": "<p>I have heard of people who believe in the Axiom of Choice up to some aleph-n (n = 2 or 3 I think?). I haven't heard of anyone who doesn't believe in at most 3 inaccessible cardinals. So I'm curious why we care</p>",
        "id": 266071843,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1640459899
    },
    {
        "content": "<p>Because I tell ZFC people that obviously it all works in ZFC?</p>",
        "id": 266076291,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640467538
    }
]
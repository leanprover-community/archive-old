[
    {
        "content": "<p>This problem has come up several times in this year, and I decided it's time to face it instead of to avoid it. This is the definition of an algebra over a commutative ring:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">ring</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"n\">is_ring_hom</span> <span class=\"n\">f</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">commutes</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>Mathematically there are no problems, but somehow every time I try to introduce this class, the class inferences become a mess, consistently. So, my question is: what is the best way to introduce this whole algebra thing to Lean?</p>",
        "id": 133299335,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536051110
    },
    {
        "content": "<p>Yeah! Go for it! I recognize the troubles, and I don't know the answer...</p>",
        "id": 133299411,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536051191
    },
    {
        "content": "<p>Concerning terminology... I think Bourbaki has a more general notion of algebra.</p>",
        "id": 133299424,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536051234
    },
    {
        "content": "<p>For example, a Lie algebra is an algebra.</p>",
        "id": 133299477,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536051257
    },
    {
        "content": "<p>MWE:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">polynomial</span>\n\n<span class=\"n\">class</span> <span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">ring</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"n\">is_ring_hom</span> <span class=\"n\">f</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">commutes</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">to_ℤ_algebra</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"bp\">ℤ</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">coe</span><span class=\"o\">,</span>\n  <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">commutes</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">induction_on</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_add</span><span class=\"o\">,</span> <span class=\"n\">add_mul</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">])</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_add</span><span class=\"o\">,</span> <span class=\"n\">add_mul</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">]),</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">set_option</span> <span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">class_instances</span> <span class=\"n\">true</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"bp\">ℤ</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 133299481,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536051267
    },
    {
        "content": "<p>Don't you get diamonds this way?</p>",
        "id": 133299500,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536051321
    },
    {
        "content": "<p>What do you mean?</p>",
        "id": 133299559,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536051380
    },
    {
        "content": "<p>every algebra is already a ring, and now you are turning rings into algebras, so you are getting loops, not?</p>",
        "id": 133299562,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536051406
    },
    {
        "content": "<p>Maybe diamond is not the right word, but certainly loops.</p>",
        "id": 133299565,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536051419
    },
    {
        "content": "<p>I see</p>",
        "id": 133299571,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536051428
    },
    {
        "content": "<p>but it's an important fact that every ring is a Z-algebra, no?</p>",
        "id": 133299574,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536051440
    },
    {
        "content": "<p>Just as important as the fact that every abelian group is a Z-module.</p>",
        "id": 133299633,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536051526
    },
    {
        "content": "<p>Maybe that's the place to start this discussion. For example, my correspondence theorem is written for R-modules. How does one deduce the correspondence theorem for abelian groups? For mathematicians, the answer is easy -- \"set R=Z; done\". How do we do it in Lean?</p>",
        "id": 133299759,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536051718
    },
    {
        "content": "<p>At the time, the answer to this question was \"just wait until the module refactor hits and then try again\". Did you try again after the module refactor? What is still problematic?</p>",
        "id": 151194100,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544301285
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> the original MWE I posted above still works (in the sense that it still fails)</p>",
        "id": 151194328,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544301803
    },
    {
        "content": "<p>and if you define algebra differently, you run into another typeclass problem:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">polynomial</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"n\">class</span> <span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"n\">is_ring_hom</span> <span class=\"n\">f</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">commutes</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">algebra</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">to_module</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">module</span><span class=\"bp\">.</span><span class=\"n\">of_core</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">A</span> <span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_add</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_add</span><span class=\"o\">],</span>\n  <span class=\"n\">add_smul</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">mul_smul</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"err\">•</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">smul_def</span><span class=\"o\">,</span> <span class=\"n\">smul_def</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">commutes</span><span class=\"o\">,</span> <span class=\"n\">mul_assoc</span><span class=\"o\">]</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">algebra</span>\n</pre></div>",
        "id": 151194329,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544301816
    },
    {
        "content": "<p>in any case I'm quite tired of Lean's typeclass inference</p>",
        "id": 151194330,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544301826
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Help! Is this sort of thing still a problem?</p>",
        "id": 151194336,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544301842
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> I know I'm just commenting without having tried anything out. But I have been working with over-categories a bit. And there has been some work with <code>CommRing</code>, I understand. So couldn't we define <code>algebra R</code> as <code>under R</code>?</p>",
        "id": 151194926,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544302967
    },
    {
        "content": "<p>I hope that should just work.</p>",
        "id": 151194927,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544302979
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> could you show me what the code I just posted would become?</p>",
        "id": 151195058,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544303235
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> Sorry, I was distracted for a while. You have worked on colimits in <code>CommRing</code> haven't you?</p>",
        "id": 151196687,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544306469
    },
    {
        "content": "<p>I haven't</p>",
        "id": 151196688,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544306477
    },
    {
        "content": "<p>Aah, I thought you did, together with Ramon and Kevin.</p>",
        "id": 151196692,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544306492
    },
    {
        "content": "<p>Anyway, I think <code>CommRing</code> is currently being PR'd or about to be PR'd.</p>",
        "id": 151196694,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544306508
    },
    {
        "content": "<p>oh well I didn't use the category theory language</p>",
        "id": 151196735,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544306541
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/mathlib/blob/master/category_theory/examples/rings.lean\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/master/category_theory/examples/rings.lean\">https://github.com/leanprover/mathlib/blob/master/category_theory/examples/rings.lean</a></p>",
        "id": 151196737,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544306554
    },
    {
        "content": "<p>So, there is something there.</p>",
        "id": 151196739,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544306561
    },
    {
        "content": "<p>Next, you could define under categories, as in <a href=\"https://github.com/leanprover-community/mathlib/blob/sheaf/category_theory/sheafy_preamble.lean#L180\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/sheaf/category_theory/sheafy_preamble.lean#L180\">https://github.com/leanprover-community/mathlib/blob/sheaf/category_theory/sheafy_preamble.lean#L180</a></p>",
        "id": 151196744,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544306617
    },
    {
        "content": "<p>And combining those, you would have commutative algebras over a commring.</p>",
        "id": 151196745,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544306636
    },
    {
        "content": "<p>yes, yes, yes, you could, provided that your URL doesn't contain \"leanprover-community\"</p>",
        "id": 151196787,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544306650
    },
    {
        "content": "<p>You only need that 1 line.</p>",
        "id": 151196790,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544306671
    },
    {
        "content": "<p>Comma categories are already in mathlib.</p>",
        "id": 151196792,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544306679
    },
    {
        "content": "<p>The <code>functor.of.obj</code> is currently being PR'd to replace <code>functor.of_obj</code></p>",
        "id": 151196803,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544306713
    },
    {
        "content": "<p>Is there any chance that we will be able to use <code>\\Z</code> notation as an object of <code>Ring</code>? Will we always have to type <code>Ring.int</code>? Somehow I wish that we can automatically coerce a type into an object of a category if the right type class instance is found... (maybe let's not worry if that is possible with modules, atm) It would be possible if that would at least be possible with the most basic examples, like nats, ints (modulo <code>n</code>), rats, reals, complexes.</p>",
        "id": 151212724,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544342545
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> This is what I came up with, after a little bit of hacking. <a href=\"https://github.com/leanprover-community/mathlib/blob/jmc-leftmod/category_theory/examples/left_module.lean\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/jmc-leftmod/category_theory/examples/left_module.lean\">https://github.com/leanprover-community/mathlib/blob/jmc-leftmod/category_theory/examples/left_module.lean</a><br>\nNeed to go now. Of course there is lots to be done.</p>",
        "id": 151213510,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544344113
    },
    {
        "content": "<p>well... are you sure there will be no type-class issues?</p>",
        "id": 151214428,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544346022
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> Of course I can't be sure about that. But I think that the more you bundle, the less type class issues you will have. Otoh, the more you will have to be explicit about \"coercions\", and things like that.</p>",
        "id": 151217969,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544353285
    },
    {
        "content": "<p>so are you implying that the Lean typeclass system cannot be salvaged unless we bundle everything?</p>",
        "id": 151217971,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544353314
    },
    {
        "content": "<p>I don't know. The current type class system clearly isn't the most powerful thing imaginable. But for now I wouldn't mind trying more module stuff with less type class stuff.</p>",
        "id": 151218021,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544353421
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> Shall we try to define <code>map f</code> and <code>comap f</code> between <code>R-Mod</code> and <code>S-Mod</code> if <code>f : R \\hom S</code> is a morphism of commutative rings?</p>",
        "id": 151218080,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544353554
    },
    {
        "content": "<p>sure</p>",
        "id": 151218120,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544353570
    },
    {
        "content": "<p>First complication: <code>CommRing</code> is not a full subcategory of <code>Ring</code> in the current setup. So we can't just speak of <code>R-Mod</code>.</p>",
        "id": 151218181,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544353716
    },
    {
        "content": "<p>Isn't Lean's type class system the most powerful thing you can imagine subject to the requirement that you promise that if you ever define two terms of a given typeclass then they will be defeq? The problem might be that mathematicians are expecting too much from it perhaps. One way of upgrading it is to weaken the promise from \"defeq\" to \"either defeq, or the typeclass is provably a subsingleton\".</p>",
        "id": 151220181,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544357874
    },
    {
        "content": "<p>Maybe there is an art to using priorities somehow? You could imagine that mathematicians could try to get better at this art. I've not seen this technique used before. <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> you had problems with finsets or fintypes when you ended up with...something like two \"different\" empty lists representing the empty finset, right? Could you imagine carefully switching the priority of something to either very low or very high, to ensure that type class inference issues don't occur? Johan/Kenny, could you imagine doing the same thing here?</p>",
        "id": 151220287,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544358087
    },
    {
        "content": "<p>I don't think priority switching works. In the algebra example maybe who end up with the two different instances because you used a lemma that had to use the polynomial instance, because it was proved in more generality than just the integers, and likewise for the other instance.</p>",
        "id": 151220971,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1544359673
    },
    {
        "content": "<p>will auxiliary types be the solution?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">to_module</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">A</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">to_module</span><span class=\"bp\">.</span><span class=\"n\">comm_ring</span> <span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"o\">(</span><span class=\"n\">to_module</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">dunfold</span> <span class=\"n\">to_module</span><span class=\"bp\">;</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">to_module</span><span class=\"bp\">.</span><span class=\"n\">module</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">to_module</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">module</span><span class=\"bp\">.</span><span class=\"n\">of_core</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_add</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_add</span><span class=\"o\">],</span>\n  <span class=\"n\">add_smul</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_mul</span><span class=\"o\">],</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_assoc</span><span class=\"o\">],</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">one_mul</span> <span class=\"n\">x</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 151223377,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544364672
    },
    {
        "content": "<p>But you're still going to end up needing to prove the two instances are equal right? If you use lemmas about each of the different instances</p>",
        "id": 151223424,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1544364777
    },
    {
        "content": "<p>I made it a structure</p>",
        "id": 151223593,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544365126
    },
    {
        "content": "<p>Maybe you can use <code>convert</code> cleverly at some point. Can you remove things from the type class inference machine? I can't help but think that it will somehow be possible to do all this, maybe we're not having the clearest ideas about how to do it</p>",
        "id": 151223656,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544365213
    },
    {
        "content": "<blockquote>\n<p>Maybe you can use <code>convert</code> cleverly at some point. Can you remove things from the type class inference machine? I can't help but think that it will somehow be possible to do all this, maybe we're not having the clearest ideas about how to do it</p>\n</blockquote>\n<p>convert and congr are handy in these situations</p>",
        "id": 151229632,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1544377425
    },
    {
        "content": "<p>(non-MWE incoming)</p>",
        "id": 151237409,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544391954
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/OP41IwlpQ8GAgQpW6UFtBNmB/2018-12-09-2.png\" target=\"_blank\" title=\"2018-12-09-2.png\">2018-12-09-2.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/OP41IwlpQ8GAgQpW6UFtBNmB/2018-12-09-2.png\" target=\"_blank\" title=\"2018-12-09-2.png\"><img src=\"/user_uploads/3121/OP41IwlpQ8GAgQpW6UFtBNmB/2018-12-09-2.png\"></a></div>",
        "id": 151237411,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544391959
    },
    {
        "content": "<p>\"there's a type mismatch so I use <code>convert</code> which produces a proof by <code>eq.mpr (eq.refl _)</code></p>",
        "id": 151237456,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544391983
    },
    {
        "content": "<p>so what is happening\"</p>",
        "id": 151237458,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544391992
    },
    {
        "content": "<p>R[X] is an R-algebra so it has a module structure (where the scalar multiplication is <code>C r * p</code>). However <code>R[X]</code> is a finsupp so it also gets another module structure</p>",
        "id": 151246670,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544409711
    },
    {
        "content": "<p>The two module structures are not definitionally equal</p>",
        "id": 151246708,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544409724
    },
    {
        "content": "<p>can we get rid of the latter structure?</p>",
        "id": 151246711,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544409732
    },
    {
        "content": "<p>Isn't the latter instance \"the direct sum of R-modules is an R-module\"?</p>",
        "id": 151246878,
        "sender_full_name": "Reid Barton",
        "timestamp": 1544410157
    },
    {
        "content": "<p>right</p>",
        "id": 151246932,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544410221
    },
    {
        "content": "<p>How does the second instance come up in practice? Are you manually unfolding to a finsupp?<br>\nAh, do you mean the line <code>instance : module α (polynomial α) := finsupp.to_module ℕ α</code>?</p>",
        "id": 151247189,
        "sender_full_name": "Reid Barton",
        "timestamp": 1544410788
    },
    {
        "content": "<p>(does R[X] refer to <code>data.polynomial</code>?)</p>",
        "id": 151247250,
        "sender_full_name": "Reid Barton",
        "timestamp": 1544410834
    },
    {
        "content": "<p>yes</p>",
        "id": 151247375,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544411086
    },
    {
        "content": "<p>I think I mostly caught up on this thread. Deleting that instance makes sense, though I wouldn't be too surprised if you end up with new problems...</p>",
        "id": 151247440,
        "sender_full_name": "Reid Barton",
        "timestamp": 1544411194
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> what do you think about this?</p>",
        "id": 151257075,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544429716
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>class algebra (R : out_param $ Type*) [comm_ring R] (A : Type*) extends ring A :=\n</pre></div>\n\n\n<p>this is trouble, because this will make <code>ring A</code> typeclass problems go looking for instances of <code>algebra ? A</code></p>",
        "id": 151257150,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544429857
    },
    {
        "content": "<p>right, so I am not using this now</p>",
        "id": 151257201,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544429907
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"n\">is_ring_hom</span> <span class=\"n\">to_fun</span><span class=\"o\">]</span>\n</pre></div>",
        "id": 151257205,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544429918
    },
    {
        "content": "<p>I've been using this</p>",
        "id": 151257208,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544429920
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> would there be any problem if we forgot about the module structure on R[X] induced by finsupp?</p>",
        "id": 151257288,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544430058
    },
    {
        "content": "<p>or maybe I should just prove that these two modules are isomorphic</p>",
        "id": 151257303,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544430082
    },
    {
        "content": "<p>I thought an algebra was a ring that is also a module</p>",
        "id": 151257358,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544430126
    },
    {
        "content": "<p>why not have it extend module, and assert that the function's induced smul matches the existing one</p>",
        "id": 151257370,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544430174
    },
    {
        "content": "<p>I thought we like definitional equalities</p>",
        "id": 151257442,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544430281
    },
    {
        "content": "<p>hmm, I see that can be a solution</p>",
        "id": 151257466,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544430345
    },
    {
        "content": "<blockquote>\n<p>I thought an algebra was a ring that is also a module</p>\n</blockquote>\n<p>In CS you have to think really carefully about these sorts of things. In my mind, an <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-algebra is a ring which is also an <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module, <em>and</em> an <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-algebra is the codomain of a ring homomorphism from <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> -- the two notions are completely interchangeable. In Lean things seem to be much more delicate.</p>",
        "id": 151258425,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544431751
    },
    {
        "content": "<blockquote>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">ring</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n</pre></div>\n\n\n<p>this is trouble, because this will make <code>ring A</code> typeclass problems go looking for instances of <code>algebra ? A</code></p>\n</blockquote>\n<p>Can someone explain this to me? I don't know how the type class machine works <em>at all</em> and I would really like to know what its algorithm is.</p>",
        "id": 151258478,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544431845
    },
    {
        "content": "<p>Maybe what I need is some abstract examples of classes and instances and an explanation of what typeclass inference does to solve typeclass problems, and also an example of how type class inference can get into trouble and cause one of those huge log files which ends up in a max class instance resolution error.</p>",
        "id": 151258929,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544432559
    },
    {
        "content": "<p>If this isn't going to change in Lean 4 then perhaps it's worth documenting how all this works a bit better. Currently I just regard it as magic, but as Kenny once informed me, Lean does not do magic.</p>",
        "id": 151258959,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544432607
    },
    {
        "content": "<p>well in the future a neural network will resolve typeclass issues and none of us would know the algorithm</p>",
        "id": 151259223,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544432987
    },
    {
        "content": "<p>So Lean 7 does do magic after all.</p>",
        "id": 151259284,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544433040
    },
    {
        "content": "<p>But how does Lean 7 resolve the problem that it can find two non-defeq instances of <code>topological_space X \\times Y</code> when <code>X</code> and <code>Y</code> are both metric spaces?</p>",
        "id": 151259301,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544433078
    },
    {
        "content": "<p>There is a fundamental issue unrelated to algorithms.</p>",
        "id": 151259312,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544433096
    },
    {
        "content": "<p>Can we feed useful theorems into the network and tell it to try applying them whenever it can't resolve type class issues? \"If you can't prove that <code>instance1 : foo A</code> and <code>instance2 : foo A</code> are defeq, take look at the useful theorems about terms of type <code>foo A</code> which I told you about\".</p>",
        "id": 151259376,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544433194
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> am I living in a dream world?</p>",
        "id": 151259384,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544433214
    },
    {
        "content": "<p>This happens to mathematicians in practice, in particular in cases where <code>foo A</code> is a subsingleton and not a prop, and the two terms are not defeq but are trivially equal.</p>",
        "id": 151259442,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544433270
    },
    {
        "content": "<p>We want to do hard algebra in Lean but we cannot do it in a natural way and also use the typeclass system because our structures seem to be slightly too complex for it.</p>",
        "id": 151259451,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544433315
    },
    {
        "content": "<p>Well -- maybe we can use it -- maybe we just didn't figure out how to use it yet.</p>",
        "id": 151259503,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544433365
    },
    {
        "content": "<p>Type classes only work well when all instances are unique. In other languages this property is enforced, but Lean's type class inference is too general to implement that in a sensible way.</p>",
        "id": 151259599,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1544433570
    },
    {
        "content": "<p>I haven't followed these threads closely enough to say what should be done about the examples that don't satisfy this property right now</p>",
        "id": 151259686,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1544433654
    },
    {
        "content": "<p>By \"unique\" you mean that any two instances are defeq, I guess. Could you imagine a strengthening of the system which could handle non-defeq instances which are equal because of a theorem which the type class system \"knows\" ? Or is this just somehow completely computationally unfeasible? The simplest case is when the class is a subsingleton.</p>",
        "id": 151260066,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544434198
    },
    {
        "content": "<p>The type class system doesn't even know anything about definitional equality, it just uses the same unification as any other part of Lean. I'm not sure if it would be weird to add some sense of definitional extensionality to just this one part of the system, or what that should look like.</p>",
        "id": 151260884,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1544435003
    },
    {
        "content": "<p>What about the following modification: if the type class search terminally fails (not an intermediate fail during exploration), unfold the head symbol and try again? It seems to me this would make the type wrapping solution much more usable.</p>",
        "id": 151261422,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1544435525
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> The failed inference can involve many other classes, should they also be unfolded if possible? No, if you want a def to be unfolded by type class inference, it should be reducible.</p>",
        "id": 151261745,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1544435926
    },
    {
        "content": "<p>Can one locally mark a def as reducible?</p>",
        "id": 151261760,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544435974
    },
    {
        "content": "<p>I don't want it to be reducible, I want is to be unfolded only in the situation I described</p>",
        "id": 151261761,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1544435978
    },
    {
        "content": "<p>This is strictly an extension of the current algorithm, it takes over after everything else failed, and start again on a different problem</p>",
        "id": 151261816,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1544436020
    },
    {
        "content": "<p>By \"failure\" you presumably do you not include \"max type class instance resolution reached\", which might just mean it's not trying hard enough.</p>",
        "id": 151261829,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544436063
    },
    {
        "content": "<p>Excluding maxdepth error</p>",
        "id": 151261851,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1544436112
    },
    {
        "content": "<p>My vague understanding is that Coq canonical structure instance resolution does what I wrote</p>",
        "id": 151261904,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1544436145
    },
    {
        "content": "<p>By the way, Sebastian, would it make sense to add shortcuts for the instance problems that Lean keeps solving for each proof (like <code>has_bind tactic</code> or <code>has_one ℕ</code> or <code>has_add ℕ</code>)?</p>",
        "id": 151261985,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1544436296
    },
    {
        "content": "<blockquote>\n<p>By the way, Sebastian, would it make sense to add shortcuts for the instance problems that Lean keeps solving for each proof (like <code>has_bind tactic</code> or <code>has_one ℕ</code> or <code>has_add ℕ</code>)?</p>\n</blockquote>\n<p>Shortcut instances are a valid optimization, though they can also increase run time when the subproblem fails (whereas the full problem could still succeed) because there simply are more instances to check. In theory, better caching could also help there, which is the one part of the type class system that's likely to change in Lean 4.</p>",
        "id": 151266117,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1544441610
    },
    {
        "content": "<p>how is the Lean 4 system better?</p>",
        "id": 151266186,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544441674
    },
    {
        "content": "<p>I don't know, it hasn't changed yet</p>",
        "id": 151266584,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1544442154
    }
]
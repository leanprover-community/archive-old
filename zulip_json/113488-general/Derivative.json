[
    {
        "content": "<p>How do I import the derivative operator <code>D</code>. The one from <code>import analysis.calculus.deriv</code> doesn't seem to work with \"powers\" and it seems to require the function to be evaluated at some point. I would like to have <code>D</code> as a linear operator acting on the vector space of real differentiable functions and have powers of <code>D</code> to represent its nth-order derivatives.</p>\n<p>Basically, I want to set up a space where I can do this:</p>\n<p>$D(\\alpha f + g) = \\alpha D f + Dg$</p>\n<p>And</p>\n<p>$D^2 f = D (D f)$</p>\n<p>Notice that I am not evaluating any of these functions at some $x \\in \\mathbb{R}$.</p>\n<p>Is there a package that already does this in Lean3?</p>",
        "id": 322383891,
        "sender_full_name": "Icaro Costa",
        "timestamp": 1674164121
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/iterated_deriv\">docs#iterated_deriv</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/iterated_deriv_eq_iterate\">docs#iterated_deriv_eq_iterate</a></p>",
        "id": 322396201,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1674168983
    },
    {
        "content": "<p>I am trying to define <code>D</code> on top of <code>deriv</code> now. This is an attempt to prove the product rule for <code>D</code> based on <code>deriv</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">D</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">deriv</span> <span class=\"n\">f</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">variable</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">product_rule</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)(</span><span class=\"n\">hIsDiff</span> <span class=\"o\">:</span> <span class=\"n\">differentiable</span> <span class=\"n\">ℝ</span> <span class=\"n\">h</span><span class=\"o\">)(</span><span class=\"n\">gIsDiff</span> <span class=\"o\">:</span> <span class=\"n\">differentiable</span> <span class=\"n\">ℝ</span> <span class=\"n\">g</span><span class=\"o\">):</span>\n  <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">•</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"bp\">•</span> <span class=\"n\">D</span> <span class=\"n\">g</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">D</span> <span class=\"n\">h</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">D</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">deriv_smul</span> <span class=\"o\">(</span><span class=\"n\">hIsDiff</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">gIsDiff</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The error I receive is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">apply</span> <span class=\"n\">tactic</span><span class=\"o\">,</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">unify</span>\n  <span class=\"n\">deriv</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">•</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">•</span> <span class=\"n\">deriv</span> <span class=\"n\">g</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">deriv</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">x</span>\n<span class=\"k\">with</span>\n  <span class=\"n\">deriv</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">h</span> <span class=\"n\">y</span> <span class=\"bp\">•</span> <span class=\"n\">g</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"bp\">•</span> <span class=\"n\">deriv</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">deriv</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"bp\">•</span> <span class=\"n\">g</span> <span class=\"n\">x</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">h</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span>\n<span class=\"n\">hIsDiff</span> <span class=\"o\">:</span> <span class=\"n\">differentiable</span> <span class=\"n\">ℝ</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">gIsDiff</span> <span class=\"o\">:</span> <span class=\"n\">differentiable</span> <span class=\"n\">ℝ</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n<span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">deriv</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">•</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">•</span> <span class=\"n\">deriv</span> <span class=\"n\">g</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">deriv</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>Isn't the lambda expression exactly what I have on the left side? What is the right way to implement this?</p>",
        "id": 322610504,
        "sender_full_name": "Icaro Costa",
        "timestamp": 1674246998
    },
    {
        "content": "<p>Why are you defining <code>D</code> when it's definitionally equal to <code>deriv</code>? Or did I miss something? </p>\n<p>You haven't posted a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> so I'm not in a position to diagnose your error. Is <code>h x • g x</code> definitionally equal to <code>(h • g) x</code> and similar for the right hand side? If not then that's your problem. If it is then try using <code>refine</code> (and adding in the appropriate holes) instead of <code>apply</code>, <code>apply</code> is occasionally flaky because of the <code>apply</code> bug.</p>",
        "id": 322611582,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674247367
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Derivative/near/322611582\">said</a>:</p>\n<blockquote>\n<p>Why are you defining <code>D</code> when it's definitionally equal to <code>deriv</code>? Or did I miss something? </p>\n<p>You haven't posted a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> so I'm not in a position to diagnose your error. Is <code>h x • g x</code> definitionally equal to <code>(h • g) x</code> and similar for the right hand side? If not then that's your problem. If it is then try using <code>refine</code> (and adding in the appropriate holes) instead of <code>apply</code>, <code>apply</code> is occasionally flaky because of the <code>apply</code> bug.</p>\n</blockquote>\n<p>The reason I am defining this D is both for convenience and for me to learn the syntax and how to work out the proofs.</p>\n<p>I suppose this should serve as an mwe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.list.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.interval</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.vector</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.calculus.deriv</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.group.defs</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n\n<span class=\"c1\">-- Definition of the derivative operator and its properties</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">D</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">deriv</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">variable</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">product_rule</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)(</span><span class=\"n\">hIsDiff</span> <span class=\"o\">:</span> <span class=\"n\">differentiable</span> <span class=\"n\">ℝ</span> <span class=\"n\">h</span><span class=\"o\">)(</span><span class=\"n\">gIsDiff</span> <span class=\"o\">:</span> <span class=\"n\">differentiable</span> <span class=\"n\">ℝ</span> <span class=\"n\">g</span><span class=\"o\">):</span>\n  <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">•</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"bp\">•</span> <span class=\"n\">D</span> <span class=\"n\">g</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">D</span> <span class=\"n\">h</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">D</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">deriv_smul</span> <span class=\"o\">(</span><span class=\"n\">hIsDiff</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">gIsDiff</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Answering your other question, yes. <code>h x • g x</code> should be equal to <code>(h • g) x</code>, but I don't think Lean got that.</p>",
        "id": 322615022,
        "sender_full_name": "Icaro Costa",
        "timestamp": 1674248565
    },
    {
        "content": "<p>The right hand sides are not definitionally equal though:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">product_rule</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)(</span><span class=\"n\">hIsDiff</span> <span class=\"o\">:</span> <span class=\"n\">differentiable</span> <span class=\"n\">ℝ</span> <span class=\"n\">h</span><span class=\"o\">)(</span><span class=\"n\">gIsDiff</span> <span class=\"o\">:</span> <span class=\"n\">differentiable</span> <span class=\"n\">ℝ</span> <span class=\"n\">g</span><span class=\"o\">):</span>\n  <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">•</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"bp\">•</span> <span class=\"n\">D</span> <span class=\"n\">g</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">D</span> <span class=\"n\">h</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">D</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"n\">deriv_smul</span> <span class=\"o\">(</span><span class=\"n\">hIsDiff</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">gIsDiff</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n  <span class=\"c1\">-- ⊢ (h • deriv g + g • deriv h) x = h x • deriv g x + deriv h x • g x</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>You need to commute g and deriv h; that's the reason it won't unify. Lean did get that the left hand sides were definitionally equal (that's why we don't see the left hand side as a goal produced by <code>convert</code>)</p>",
        "id": 322617116,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674249312
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- I changed the statement of the lemma to be more mathlib-like</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">product_rule</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)(</span><span class=\"n\">hIsDiff</span> <span class=\"o\">:</span> <span class=\"n\">differentiable</span> <span class=\"n\">ℝ</span> <span class=\"n\">h</span><span class=\"o\">)(</span><span class=\"n\">gIsDiff</span> <span class=\"o\">:</span> <span class=\"n\">differentiable</span> <span class=\"n\">ℝ</span> <span class=\"n\">g</span><span class=\"o\">):</span>\n  <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">•</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"bp\">•</span> <span class=\"n\">D</span> <span class=\"n\">g</span> <span class=\"bp\">+</span> <span class=\"n\">D</span> <span class=\"n\">h</span> <span class=\"bp\">•</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">D</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">deriv_smul</span> <span class=\"o\">(</span><span class=\"n\">hIsDiff</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">gIsDiff</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"c1\">-- `exact` is better than `apply`, which only</span>\n  <span class=\"c1\">-- works due to a coincidence basically</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 322617533,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674249469
    },
    {
        "content": "<p>tl;dr: </p>\n<blockquote>\n<p>Isn't the lambda expression exactly what I have on the left side?</p>\n</blockquote>\n<p>No ;-) (but I only spotted this once I had working code in front of me, that's the joys of a mwe)</p>",
        "id": 322617675,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674249509
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Derivative/near/322617533\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- I changed the statement of the lemma to be more mathlib-like</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">product_rule</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)(</span><span class=\"n\">hIsDiff</span> <span class=\"o\">:</span> <span class=\"n\">differentiable</span> <span class=\"n\">ℝ</span> <span class=\"n\">h</span><span class=\"o\">)(</span><span class=\"n\">gIsDiff</span> <span class=\"o\">:</span> <span class=\"n\">differentiable</span> <span class=\"n\">ℝ</span> <span class=\"n\">g</span><span class=\"o\">):</span>\n  <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">•</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"bp\">•</span> <span class=\"n\">D</span> <span class=\"n\">g</span> <span class=\"bp\">+</span> <span class=\"n\">D</span> <span class=\"n\">h</span> <span class=\"bp\">•</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">D</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">deriv_smul</span> <span class=\"o\">(</span><span class=\"n\">hIsDiff</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">gIsDiff</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"c1\">-- `exact` is better than `apply`, which only</span>\n  <span class=\"c1\">-- works due to a coincidence basically</span>\n<span class=\"kd\">end</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I haven't seen this keyword <code>convert</code> yet, but it seems to do exactly what I was trying to accomplish. What I noticed is that if swap <code>D h • g</code> by <code>g • D h </code> in the lemma proposition, the proof doesn't work anymore. Is this because I would also have to prove that <code>•</code> commutes in this context?</p>\n<p>Does the keyword <code>convert</code> \"applies\" the lambda function onto <code>x</code> before trying to replace it?</p>\n<p>Thank you for your help btw</p>",
        "id": 322619263,
        "sender_full_name": "Icaro Costa",
        "timestamp": 1674250085
    },
    {
        "content": "<p><code>apply</code> is just doing <code>exact</code> and <code>exact</code> doesn't work because it's not exactly right. <code>convert h</code> is just <code>exact h</code> except it gives the user back the parts of the goal which weren't exactly <code>h</code></p>",
        "id": 322624616,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674252279
    }
]
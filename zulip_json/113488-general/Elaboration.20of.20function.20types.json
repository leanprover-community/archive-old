[
    {
        "content": "<p>Is this behaviour of the elaborator expected/necessary or could it be improved so that the last two cases are also inferrable?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">):</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"c1\">-- good</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"bp\">_</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span><span class=\"o\">))</span> <span class=\"c1\">-- good</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"c1\">-- failed, sort expected ?m_1[a]</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"bp\">_</span> <span class=\"bp\">→</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"c1\">-- failed, sort expected ?m_1[a]</span>\n</pre></div>",
        "id": 168395778,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1560861377
    },
    {
        "content": "<p>arguably this shouldn't happen with the arrow, which is supposed to be nondependent, but the parser turns the later two into <code>\\forall _x:nat, _</code> which produces a metavariable <code>_x : nat |- ?m_1</code> and then the typing forces it to unify <code>?m_1[n] =?= nat</code>, and it doesn't like these sorts of unification problems so it delays, hoping that <code>?m_1</code> will be solved directly.</p>",
        "id": 168396129,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560861650
    }
]
[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">list</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">thing</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">bind</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">thing</span> <span class=\"n\">i</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">thing_zero</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">thing</span> <span class=\"mi\">0</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n\n<p>Here's my example - the proof <code>refl</code> is accepted (as is <code>by exact rfl</code>) in tactic mode, but the overall definition gives me an error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"kd\">definition</span> <span class=\"bp\">'</span><span class=\"n\">list.thing_zero'</span><span class=\"o\">,</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">thing</span> <span class=\"mi\">0</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">thing</span> <span class=\"mi\">0</span> <span class=\"n\">l</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">thing</span> <span class=\"mi\">0</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"mi\">0</span><span class=\"o\">]</span>\n</code></pre></div>\n\n<p>By looking at <code>#print prefix list.thing</code>, it shows four equations, splitting the first case into two - why does this happen? Also, is it possible for a more helpful error message here: from the definition I gave, I expected those two types to be the same thing</p>",
        "id": 211370392,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1601141072
    },
    {
        "content": "<p>Oh, that is a weird definition. It looks like it's going to be an induction on <code>n</code> but it's not</p>",
        "id": 211373632,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601146058
    },
    {
        "content": "<p>if you reverse the order of arguments to make it clearer it errors where you would expect</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">thing</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">l</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">bind</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">thing</span> <span class=\"n\">xs</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">thing_zero</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">thing</span> <span class=\"n\">l</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span> <span class=\"c1\">-- error</span>\n</code></pre></div>",
        "id": 211373675,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601146086
    },
    {
        "content": "<p>I'm not sure how but you have somehow tricked the elaborator into thinking this is rfl when it's not. Looking at the generated definitions it definitely will not be a rfl proof, and the kernel knows what's up</p>",
        "id": 211373798,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601146307
    },
    {
        "content": "<p>in any case the correct proof is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">thing_zero</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">thing</span> <span class=\"mi\">0</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">l</span><span class=\"bp\">;</span> <span class=\"n\">refl</span>\n</code></pre></div>",
        "id": 211373851,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601146344
    },
    {
        "content": "<p>Yeah I figured that doing cases would work, but I guess I'm surprised at why the generated definitions are what they are - I would have thought it'd be something like: if the nat is zero then it's this, otherwise case-split on the list</p>",
        "id": 211380346,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1601150692
    }
]
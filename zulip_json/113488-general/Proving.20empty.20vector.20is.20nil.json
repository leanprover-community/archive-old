[
    {
        "content": "<p>Suppose I have a type family <code>vec</code> parametrised by its length <code>n : nat</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">vec</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">vec</span> <span class=\"o\">(</span><span class=\"n\">n.succ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Now, I want to show that any <code>vec 0</code> has to be <code>nil</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">vec_zero_is_nil</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">vec.nil</span>\n</code></pre></div>\n<p>I can't work out how to prove this, though. The obvious way seems to be to <code>destruct v</code>. The <code>cons</code> case gives an easy contradiction, but in the <code>nil</code> case, I get a hypothesis <code>v == vec.nil</code>. What does this <code>==</code> mean, and how can I deduce that <code>v = vec.nil</code>?</p>",
        "id": 243992940,
        "sender_full_name": "Jordan Mitchell Barrett",
        "timestamp": 1624679550
    },
    {
        "content": "<p>The usual way to spell coq's <code>destruct</code> in lean is <code>cases</code> and it seems to do the right thing here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">vec_zero_is_nil</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">vec.nil</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 243994804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624683072
    },
    {
        "content": "<p>Somewhat amusingly, this is one of those cases where Lean already knows it can only be <code>vec.nil</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">vec</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">vec</span> <span class=\"o\">(</span><span class=\"n\">n.succ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">vec_zero_is_nil</span> <span class=\"o\">:</span> <span class=\"bp\">Î </span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">vec.nil</span>\n<span class=\"bp\">|</span> <span class=\"n\">vec.nil</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>This is relying on the equation compiler doing case analysis and building the proof for you.  In this case, I think it deduces that <code>0 = n.succ</code> has no solutions since <code>nat.succ</code> is injective.</p>",
        "id": 244025288,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1624728508
    },
    {
        "content": "<p>The <code>==</code> is heterogeneous equality.  It appears when you have terms of equal types, and it's usually something you want to avoid since it's rather weak.  However, in this case both the terms involved have the same type (not merely equal) so <code>eq_of_heq</code> will do.  (For the second case, I'm forgetting what I'm supposed to do, so I used the low-level <code>nat.no_confusion</code>.  The <code>exfalso</code> is not necessary here.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">vec_zero_is_nil</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">vec.nil</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">destruct</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">he</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">eq_of_heq</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">n</span> <span class=\"n\">w</span> <span class=\"n\">a</span> <span class=\"n\">hz</span><span class=\"o\">,</span>\n    <span class=\"n\">exfalso</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">nat.no_confusion</span> <span class=\"n\">hz</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 244025290,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1624728513
    }
]
[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> <a href=\"#narrow/stream/113488-general/subject/cases/near/126323093\" title=\"#narrow/stream/113488-general/subject/cases/near/126323093\">wrote</a>:</p>\n<blockquote>\n<p>With nested and mutual inductives moving into the kernel, there shouldn't be any need for an abstraction layer. Well, it's still not clear how nested inductives would be represented.</p>\n</blockquote>\n<p>Would this paper help?</p>\n<p><a href=\"https://arxiv.org/abs/1806.05230\" target=\"_blank\" title=\"https://arxiv.org/abs/1806.05230\">Dependently Typed Folds for Nested Data Types</a>:</p>\n<blockquote>\n<p>We present an approach to develop folds for nested data types using dependent types. We call such folds dependently typed folds, they have the following properties. (1) Dependently typed folds are defined by well-founded recursion and they can be defined in a total dependently typed language. (2) Dependently typed folds do not depend on maps, map functions and many terminating functions can be defined using dependently typed folds. (3) The induction principles for nested data types follow from the definitions of dependently typed folds and the programs defined by dependently typed folds can be formally verified. (4) Dependently typed folds exist for any nested data types and they can be specialized to the traditional higher-order folds. Using various of examples, we show how to program and reason about dependently typed folds. We also show how to obtain dependently typed folds in general and how to specialize them to the corresponding higher-order folds.</p>\n</blockquote>",
        "id": 129137513,
        "sender_full_name": "Sean Leather",
        "timestamp": 1530797074
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110045\">@Sean Leather</span> This seems to be about a different kind of nested types. Note that <code>Bush</code> cannot even be defined in Lean 3 because of universe constraints.</p>",
        "id": 129145511,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1530804783
    },
    {
        "content": "<p>What are the nested inductives that you're referring to?</p>",
        "id": 129145627,
        "sender_full_name": "Sean Leather",
        "timestamp": 1530804932
    },
    {
        "content": "<p>And conversely, the type <code>Term</code> from the first case study is just a regular inductive type according to Lean. I didn't compare the induction principles, though.</p>",
        "id": 129145672,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1530804964
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110045\">@Sean Leather</span>  Any inductive type that is passed to another inductive type in its own definition, as in <a href=\"https://github.com/leanprover/lean/wiki/Inductive-datatypes#encoding-datatypes-that-contain-recursive-occurrences-nested-in-existing-datatypes\" target=\"_blank\" title=\"https://github.com/leanprover/lean/wiki/Inductive-datatypes#encoding-datatypes-that-contain-recursive-occurrences-nested-in-existing-datatypes\">https://github.com/leanprover/lean/wiki/Inductive-datatypes#encoding-datatypes-that-contain-recursive-occurrences-nested-in-existing-datatypes</a></p>",
        "id": 129145876,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1530805212
    },
    {
        "content": "<p>Ok, right. That's the \"simple\" version of nested data types.</p>",
        "id": 129146139,
        "sender_full_name": "Sean Leather",
        "timestamp": 1530805500
    },
    {
        "content": "<blockquote>\n<p>Note that Bush cannot even be defined in Lean 3 because of universe constraints.</p>\n</blockquote>\n<p>Actually this is an instance of non-uniform parameters, which I have figured out how to simulate in lean without any kernel extensions</p>",
        "id": 129175542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530839762
    },
    {
        "content": "<blockquote>\n<p>Actually this is an instance of non-uniform parameters, which I have figured out how to simulate in lean without any kernel extensions</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Please do share. Can you define a <code>Bush</code> type from constants?</p>",
        "id": 129183673,
        "sender_full_name": "Sean Leather",
        "timestamp": 1530856158
    },
    {
        "content": "<p>what do you mean from constants?</p>",
        "id": 129183675,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530856182
    },
    {
        "content": "<p>I mean the sort of constants generated by the equation compiler.</p>",
        "id": 129183799,
        "sender_full_name": "Sean Leather",
        "timestamp": 1530856433
    },
    {
        "content": "<p>Err, maybe I'm using the wrong terminology. What do you call the process of taking an <code>inductive</code> to its constants?</p>",
        "id": 129183844,
        "sender_full_name": "Sean Leather",
        "timestamp": 1530856483
    },
    {
        "content": "<p>the constructors?</p>",
        "id": 129184389,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530857487
    },
    {
        "content": "<p>To be precise, I can define a type <code>Bush</code> together with constructors of the stated types, the natural recursion principle, and a computation rule (as a provable equality, not definitional) while circumventing any universe inconsistencies</p>",
        "id": 129184456,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530857578
    },
    {
        "content": "<blockquote>\n<p>To be precise, I can define a type <code>Bush</code> together with constructors of the stated types, the natural recursion principle, and a computation rule (as a provable equality, not definitional) while circumventing any universe inconsistencies</p>\n</blockquote>\n<p>Yes, that's what I'd like to see.</p>",
        "id": 129184572,
        "sender_full_name": "Sean Leather",
        "timestamp": 1530857771
    },
    {
        "content": "<p>I think I will just give a rough sketch:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">bushn</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">bushn</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">bushn</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">bushn</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">bushn</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">bushn</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">bush</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">bushn</span> <span class=\"n\">α</span> <span class=\"mi\">1</span>\n\n<span class=\"n\">def</span> <span class=\"n\">bushn</span><span class=\"bp\">.</span><span class=\"n\">equiv</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">bushn</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"err\">≃</span> <span class=\"o\">(</span><span class=\"n\">bush</span><span class=\"err\">^</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"n\">def</span> <span class=\"n\">bush</span><span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bush</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">bushn</span><span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"n\">α</span>\n<span class=\"n\">def</span> <span class=\"n\">bush</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">bush</span> <span class=\"o\">(</span><span class=\"n\">bush</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">bush</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">bushn</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">bushn</span><span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">bushn</span><span class=\"bp\">.</span><span class=\"n\">equiv</span> <span class=\"n\">α</span> <span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"n\">bush</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">},</span> <span class=\"n\">bush</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Sort</span> <span class=\"n\">l</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">C0</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">bush</span><span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">C1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">α</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">bush</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">α</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">C</span> <span class=\"n\">α</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"n\">def</span> <span class=\"n\">bush</span><span class=\"bp\">.</span><span class=\"n\">rec_nil</span> <span class=\"o\">{</span><span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">C0</span> <span class=\"n\">C1</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">bush</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"bp\">@</span><span class=\"n\">C</span> <span class=\"n\">C0</span> <span class=\"n\">C1</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">bush</span><span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">C0</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"n\">def</span> <span class=\"n\">bush</span><span class=\"bp\">.</span><span class=\"n\">rec_cons</span> <span class=\"o\">{</span><span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">C0</span> <span class=\"n\">C1</span> <span class=\"n\">α</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">bush</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"bp\">@</span><span class=\"n\">C</span> <span class=\"n\">C0</span> <span class=\"n\">C1</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">bush</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"n\">C1</span> <span class=\"n\">α</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">bush</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"bp\">@</span><span class=\"n\">C</span> <span class=\"n\">C0</span> <span class=\"n\">C1</span> <span class=\"o\">(</span><span class=\"n\">bush</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 129189453,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530866135
    },
    {
        "content": "<p>At a glance, that looks similar to what's in the article I linked.</p>",
        "id": 129190374,
        "sender_full_name": "Sean Leather",
        "timestamp": 1530867610
    },
    {
        "content": "<p>Is it? I thought they assume that <code>bush</code> makes sense as an inductive without further justification, since Agda accepts it</p>",
        "id": 129190460,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530867777
    },
    {
        "content": "<p>Copy-paste:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kr\">data</span> BushN <span class=\"ow\">:</span> Nat <span class=\"ow\">-&gt;</span> <span class=\"kt\">Set</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Set</span> <span class=\"kr\">where</span>\n  <span class=\"nf\">Base</span> <span class=\"ow\">:</span> <span class=\"o\">{</span>a <span class=\"ow\">:</span> <span class=\"kt\">Set</span><span class=\"o\">}</span> <span class=\"ow\">-&gt;</span> a <span class=\"ow\">-&gt;</span> BushN Z a\n  <span class=\"nf\">NilBN</span> <span class=\"ow\">:</span> <span class=\"o\">{</span>a <span class=\"ow\">:</span> <span class=\"kt\">Set</span><span class=\"o\">}</span> <span class=\"ow\">-&gt;</span> <span class=\"o\">{</span>n <span class=\"ow\">:</span> Nat<span class=\"o\">}</span> <span class=\"ow\">-&gt;</span> BushN <span class=\"o\">(</span>S n<span class=\"o\">)</span> a\n  <span class=\"nf\">ConsBN</span> <span class=\"ow\">:</span> <span class=\"o\">{</span>a <span class=\"ow\">:</span> <span class=\"kt\">Set</span><span class=\"o\">}</span> <span class=\"ow\">-&gt;</span> <span class=\"o\">{</span>n <span class=\"ow\">:</span> Nat<span class=\"o\">}</span> <span class=\"ow\">-&gt;</span> BushN n a <span class=\"ow\">-&gt;</span> BushN <span class=\"o\">(</span>S <span class=\"o\">(</span>S n<span class=\"o\">))</span> a <span class=\"ow\">-&gt;</span> BushN <span class=\"o\">(</span>S n<span class=\"o\">)</span> a\n</pre></div>",
        "id": 129190525,
        "sender_full_name": "Sean Leather",
        "timestamp": 1530867846
    },
    {
        "content": "<p>Oh, I missed that</p>",
        "id": 129190559,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530867951
    }
]
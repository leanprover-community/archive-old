[
    {
        "content": "<p>I was reading through <a href=\"#narrow/stream/113488-general/topic/Incomplete.20pattern.20match\">this thread</a> and was trying to think of ways to stop proofs that <code>1 - 2 = 3 - 6</code> (or something similar, I could see a variety of reasons that nat subtraction specifically shouldn't be changed). This idea probably sounded better in my head than it does on paper, but I was wondering if we could define a <code>junk_value</code> function that prevents proofs of equality, like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"n\">junk_value</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"kd\">def</span> <span class=\"n\">minus</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">m</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">m</span> <span class=\"k\">else</span> <span class=\"n\">junk_value</span> <span class=\"n\">n</span> <span class=\"n\">m</span>\n</code></pre></div>\n<p>That way, <code>1 - 2</code> reduces to <code>junk_value 1 2</code> and <code>3 - 5</code> reduces to <code>junk_value 3 5</code>, which are computationally equal, but as far as I know there's no way to prove this (except maybe <code>native_decide</code>, which I don't know how it works).</p>\n<p>A more generic <code>junk_value</code> function that works for all types could be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"n\">opaque</span> <span class=\"n\">junk_value</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">Inhabited.default</span>\n</code></pre></div>\n<p>where <code>β</code> would likely be a tuple containing the type of all arguments.</p>",
        "id": 319438942,
        "sender_full_name": "Niels Voss",
        "timestamp": 1672854380
    },
    {
        "content": "<p>One caveat is that for subtraction, it essentially has to be defined twice, once where <code>1 - 2</code> returns <code>0</code> and once where it returns <code>junk_value 1 2</code>. If you try defining it in one go, like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">sub</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">junk_value</span> <span class=\"mi\">0</span> <span class=\"n\">m</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sub</span> <span class=\"n\">n</span> <span class=\"n\">m</span>\n</code></pre></div>\n<p>Then <code>1 - 5</code> and <code>2 - 6</code> both reduce to <code>junk_value 0 4</code> and can be proven equal.</p>",
        "id": 319441494,
        "sender_full_name": "Niels Voss",
        "timestamp": 1672855198
    },
    {
        "content": "<p>Is that a problem?</p>",
        "id": 319441866,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672855318
    },
    {
        "content": "<p>Because <code>(1:ℤ) - (5:ℤ) = (2:ℤ) - (6:ℤ)</code>.</p>",
        "id": 319441955,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672855340
    },
    {
        "content": "<p>I think it's reasonable to occasionaly have <code>junk_value a b = junk_value c d</code> if <code>a + d = c + b</code>.</p>",
        "id": 319442119,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672855403
    },
    {
        "content": "<p>But anyway, it turns out that for applications in can be very helpful to have well-chosen junk-values.</p>",
        "id": 319442176,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672855429
    },
    {
        "content": "<p>It can occasionally be a footgun, which is probably what you are trying to avoid. But it also saves you from checking a tonne of annoying side conditions.</p>",
        "id": 319442310,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672855464
    },
    {
        "content": "<p>For natural number subtraction, I do agree that opaque junk values are not the way to go because having <code>1 - 2 = 0</code> is actually sometimes a useful property. I was thinking that <code>junk_value</code> would be more helpful in situations where there's not really a good junk value to choose.</p>",
        "id": 319442831,
        "sender_full_name": "Niels Voss",
        "timestamp": 1672855656
    },
    {
        "content": "<p>Why would it be helpful in such situations?</p>",
        "id": 319442883,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672855681
    },
    {
        "content": "<p>If there's not really a good junk value to choose, then the risk for footguns is also quite small, I think.</p>",
        "id": 319443042,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672855722
    },
    {
        "content": "<p>In which case it doesn't matter which junk value you choose.</p>",
        "id": 319443075,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672855735
    },
    {
        "content": "<p>Do you have a concrete example in mind?</p>",
        "id": 319443144,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672855761
    },
    {
        "content": "<p>No, I don't really have a concrete example. I guess it would help in some obscure definitions where it isn't made clear that junk values exist. I remember seeing some definition of an inverse in a ring or monoid (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring.inverse\">docs#ring.inverse</a>) where it would return the inverse if it existed and zero if it didn't, but the function was just called <code>something.inverse</code> I think. That's not really a good example either because you can just read the doc strings, but someone looking at a lemma might see something like <code>inverse 3 = inverse 4</code> and be confused</p>",
        "id": 319443918,
        "sender_full_name": "Niels Voss",
        "timestamp": 1672856034
    },
    {
        "content": "<p>But generally, I agree that the risk is quite small</p>",
        "id": 319444062,
        "sender_full_name": "Niels Voss",
        "timestamp": 1672856070
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring.inverse\">docs#ring.inverse</a></p>",
        "id": 319444081,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1672856074
    },
    {
        "content": "<blockquote>\n<p>A more generic <code>junk_value</code> function that works for all types could be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"n\">opaque</span> <span class=\"n\">junk_value</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">Inhabited.default</span>\n</code></pre></div>\n<p>where <code>β</code> would likely be a tuple containing the type of all arguments.</p>\n</blockquote>\n<p>A <em>generic</em> junk value function is just as problematic as using 0, if you want to avoid \"junk\" theorems.  Because now you can prove e.g. <code>x / 0 = x % 0</code> by reflexivity.  You need to use a different opaque function for every occurrence to get truly unspecified values.</p>",
        "id": 319449267,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1672857762
    },
    {
        "content": "<p>And even then they're merely unspecified, you can still prove all kinds of theorems about them.  Like <code>(a / b)^2 + 1 &gt; 0</code>.</p>",
        "id": 319449932,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1672857996
    },
    {
        "content": "<p>I didn't consider the <code>x / 0 = x % 0</code> case that you mentioned. I guess a tactic could be used to generate the junk functions, or have <code>junk_value</code> take in a string containing the function name.<br>\nI don't really think there's a way to solve the second problem. At the very least, there's no way to take advantage of the specific undefined value and any theorems you prove about them essentially have to hold for every nat. It is still a bit unmathematical, but less alarming than something like <code>∀ n : ℕ, ∃ k, n / k = k</code>.</p>",
        "id": 319451841,
        "sender_full_name": "Niels Voss",
        "timestamp": 1672858567
    },
    {
        "content": "<p>On the other hand, there are useful theorems for nat.sub that you can't prove if the value is arbitrary instead of 0, like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_ordered_sub\">docs#has_ordered_sub</a>.</p>",
        "id": 319461233,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1672861864
    },
    {
        "content": "<p>Idea: mathlib should compile successfully independently of the choice of junk value for any partial function in mathlib. Why not have some kind of marker on all definitions of partial functions? Then periodically somebody goes through all these markers and changes their junk values to other junk values to test if the rest of mathlib is truly independent of these choices.</p>",
        "id": 319527101,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1672903413
    },
    {
        "content": "<p>I remember thinking about this a few years ago and then deciding that any change that made things more complicated was hard to justify in practice.</p>",
        "id": 319527558,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672903614
    },
    {
        "content": "<p>this is not true: we sometimes rely on junk values so that some simple theorems are true with less assumptions than in traditional maths. I don't have a good example at hand, though.</p>",
        "id": 319527659,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1672903670
    },
    {
        "content": "<p>Is this something desirable if traditional mathematicians are the intended users?</p>",
        "id": 319527794,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1672903728
    },
    {
        "content": "<p>This is definitely desirable since it leaves less assumptions to check for the user of theorems, and therefore makes the library smoother to use.</p>",
        "id": 319527998,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1672903820
    },
    {
        "content": "<p>it is very practiable and if it does not change the interesting mathematics, then I think nobody will object to that.</p>",
        "id": 319528018,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1672903831
    },
    {
        "content": "<p>A good example is the change of variables formula <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.integral_target_eq_integral_abs_det_fderiv_smul\">docs#measure_theory.integral_target_eq_integral_abs_det_fderiv_smul</a>, where you don't need to check that the function is integrable because otherwise the same junk value <code>0</code> is used on both sides of the formula which is therefore still true.</p>",
        "id": 319528149,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1672903914
    },
    {
        "content": "<p>The canonical example is (a+b)/c=a/c+b/c</p>",
        "id": 319529970,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672904857
    },
    {
        "content": "<p>Kevin has a nice blog post about this on Xena, btw. (If I was at a desk I'd look it up)</p>",
        "id": 319576075,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1672922138
    },
    {
        "content": "<p><a href=\"https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/\">https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/</a></p>",
        "id": 319577480,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672922570
    },
    {
        "content": "<p>I somewhat agree with Sebastian Reichelt's comment on your post, Kevin, that the proof assistant should make the experience of using partial functions more convenient, independently of the question of the practical use of junk values. For example (maybe I'm totally misunderstanding how proof assistants work), when writing <code>real.sqrt x</code>, the proof assistant should let you keep on proving things without interruption, while silently introducing another goal <code>x ≥ 0</code> to be completed later. If such goals are showing up repeatedly throughout the proof, then a list of local \"facts\" may be declared and proven at the beginning of your proof / block, which the compiler can automatically use to discharge such goals.</p>",
        "id": 319691686,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1672961041
    },
    {
        "content": "<p>that would be nice, but I think it is mostly wishful thinking to think that those goals would be silently created and/or discharged without interrupting the \"flow\"</p>",
        "id": 319692325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672961329
    },
    {
        "content": "<p>A whole series of real functions happen to have junk values defined to be equal to the real part of the (principal value of the) corresponding complex function at that argument; that applies to <code>sqrt</code>, <code>log</code>, <code>arcsin</code>, <code>arccos</code>, <code>arctan</code>, <code>rpow</code> at least (though only <code>rpow</code> has that as the definition, and we don't have the complex inverse trigonometric functions defined at all). It seems those junk values often work well together to reduce the number of times hypotheses are needed that arguments are in range.</p>",
        "id": 319703228,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1672967671
    },
    {
        "content": "<p>Doesn't typing <code>suffices h : 0 &lt;= x</code> basically just keep the <code>0 &lt;= x</code> goal out of the way and force you to prove it at the end instead of immediately? I know no one uses it that way but I don't really think that Winston Yin's suggestion is infeasible with our current tactics. Discharging these goals is probably the hard part. It could perhaps be some new syntax, like two underscores or something, that you use instead of a proof to defer the proof until the end.</p>",
        "id": 319703229,
        "sender_full_name": "Niels Voss",
        "timestamp": 1672967672
    },
    {
        "content": "<blockquote>\n<p>A whole series of real functions happen to have junk values defined to be equal to the real part of the ...</p>\n</blockquote>\n<p>Then I am happy to stop calling them junk and call them unconventional instead. Seems to me they're no different than \"0! = 1\" or \"heaviside(0) = 1/2\" in spirit. From the standpoint of popularising formalisation towards mathematicians, this (philosophical) point about partial functions would have to be made clear from the beginning, probably somewhere on the path of de-conversion from set theory. Then I'll just accept that \"any practical implementation of type theory really doesn't like partial functions\".</p>",
        "id": 319720686,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1672982992
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"521331\">@Niels Voss</span> You would still be typing more lines of proof than you have to do now. Which I would rather not.</p>",
        "id": 319720869,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672983155
    },
    {
        "content": "<p>I guess I agree with that. Also, having read all the replies to this thread, I agree now that having <code>1 - 2</code> be <code>0</code> is probably the best that we can do in practice, though I agree with Winston Yin that this should be documented somewhere.</p>",
        "id": 319721099,
        "sender_full_name": "Niels Voss",
        "timestamp": 1672983358
    },
    {
        "content": "<p>My point is that it should not only be documented on <code>nat.sub</code>, but in any introduction to computer formalisation of maths. For me that was TPiL, but it was not clear to me then how much Lean doesn't like partial functions and subtypes.</p>",
        "id": 319721350,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1672983544
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/319720869\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> You would still be typing more lines of proof than you have to do now. Which I would rather not.</p>\n</blockquote>\n<p>I think this is actually false</p>",
        "id": 319734891,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672992706
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> Would you bundle the side conditions? Otherwise I don't see how you would save on lines.</p>",
        "id": 319735015,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672992767
    },
    {
        "content": "<p>Unless you have some really smart automation going on.</p>",
        "id": 319735034,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672992779
    },
    {
        "content": "<p>You basically always need to know whatever facts guarantee that what you wrote down was \"well-defined\" (else, why not just write 37 instead?) and if you make those proofs arguments to the partial functions, then they are available for later automation</p>",
        "id": 319735259,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672992896
    },
    {
        "content": "<p>But that can also be done with our current strategy, right?</p>",
        "id": 319735675,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672993121
    },
    {
        "content": "<p>You add <code>have aux1 : side condition</code> to your context, and voila, it is available to automation.</p>",
        "id": 319735702,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672993139
    },
    {
        "content": "<p>only sufficiently local automation</p>",
        "id": 319735737,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672993162
    },
    {
        "content": "<p>Anyways, I'm fairly convinced that the mathlib wisdom on this is just wrong but I don't think it will change.</p>",
        "id": 319735766,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672993178
    },
    {
        "content": "<p>Are there examples of libraries (preferably with a DTT foundation) that take a different route?</p>",
        "id": 319735863,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672993234
    },
    {
        "content": "<p>Also, if you want to pass the side condition to the partial function (which isn't what Niels was suggesting in the post I replied to) then how would you combine that with readable notation?</p>",
        "id": 319735940,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1672993275
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/319449932\">said</a>:</p>\n<blockquote>\n<p>And even then they're merely unspecified, you can still prove all kinds of theorems about them.  Like <code>(a / b)^2 + 1 &gt; 0</code>.</p>\n</blockquote>\n<p>That only applies to type theory. In set theory, a function is a set of ordered pairs. If called with an argument outside of the domain, the result can be any set (choice-based set parametrized with the function and the argument), which is not necessarily in the codomain. So, you couldn't prove <code>(a / b)^2 + 1 &gt; 0</code> if <code>a</code> or <code>b</code> cannot be proved to be real numbers for example.</p>",
        "id": 319737388,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1672994059
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/319735259\">said</a>:</p>\n<blockquote>\n<p>You basically always need to know whatever facts guarantee that what you wrote down was \"well-defined\" (else, why not just write 37 instead?) and if you make those proofs arguments to the partial functions, then they are available for later automation</p>\n</blockquote>\n<p>Making more functions take proofs as arguments will lead to <code>rw</code> throwing <code>motive not type correct</code> all the time.</p>",
        "id": 319737617,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1672994200
    },
    {
        "content": "<p>I think the idea for having an \"unknown\" junk value (or an implicit junk value as a corollary of using <code>classical.epsilon</code>) rather than an explicit default value is to prevent us from proving nonsense theorems (such as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.div_zero\">docs#nat.div_zero</a>), simply because they are counter-intuitive to most mathematicians, and generally a bad advertisement for Lean. Instead, the right path would be to invent a better way of dealing with those special conditions.</p>",
        "id": 319738456,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1672994606
    },
    {
        "content": "<blockquote>\n<p>That only applies to type theory.</p>\n</blockquote>\n<p>Obviously we're only talking about Lean('s foundations) here.  There are other foundations where partiality is even \"better\" handled, and you can't even prove <code>a / b = a / b</code> (which is a junk theorem provable in set theory).</p>",
        "id": 319837755,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1673029908
    },
    {
        "content": "<p>Do you have an example of such foundations? I'm interested to learn more about them.</p>",
        "id": 319883493,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1673049359
    },
    {
        "content": "<p>BTW, I think <code>a / b = a / b</code> would be the expected result no matter what <code>a</code> and <code>b</code> are. Most mathematicians would agree that <code>1 / 0 = 1 / 0</code>, even though <code>1 / 0</code> may not be a real number, but it is definitely \"something\", and any object is equal to itself. (Unless equality itself is a partial relation?)</p>",
        "id": 319883578,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1673049404
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/319692325\">said</a>:</p>\n<blockquote>\n<p>that would be nice, but I think it is mostly wishful thinking to think that those goals would be silently created and/or discharged without interrupting the \"flow\"</p>\n</blockquote>\n<p>This reminds me of what I see WolframAlpha doing sometimes. For example, <a href=\"https://www.wolframalpha.com/input?i=a+x+%5E+2+%2B+b+x+%2B+c+%3D+0+solve+for+x\">https://www.wolframalpha.com/input?i=a+x+%5E+2+%2B+b+x+%2B+c+%3D+0+solve+for+x</a>. The answer depends on whether or not a and b are 0, and I didn’t specify. But I still get an answer — in fact, I get a few answers, along with the additional hypotheses needed to get to each one.</p>",
        "id": 319885540,
        "sender_full_name": "Tyler Josephson ⚛️",
        "timestamp": 1673050826
    },
    {
        "content": "<p>We have this thing called partial equivalence relations, and it is very useful in proving type theoretic theorems. Also, some constructive foundations use this (a type equipped with a PER) when you don't have good quotients and subtypes.</p>",
        "id": 319905330,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1673067779
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/divp\">docs#divp</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_deriv_at\">docs#has_deriv_at</a>, and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nnreal.sqrt\">docs#nnreal.sqrt</a> for people who want to avoid junk values.</p>",
        "id": 319919992,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1673080094
    },
    {
        "content": "<p>After some research I have come to the conclusion: <strong>Every proof assistant that uses classical logic and formalizes real numbers have <code>x/0=0</code></strong>.</p>",
        "id": 321896751,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1673979878
    },
    {
        "content": "<p>I am very happy to be proved wrong but I just haven't come across any. For constructive people, this is not an option because you can't decide whether a real number is zero, so they have to find another way.</p>",
        "id": 321896909,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1673979934
    },
    {
        "content": "<p>Also, this is not restricted to type theory. Mizar does that too.</p>",
        "id": 321897075,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1673979982
    },
    {
        "content": "<p>Metamath defines <code>x/0</code> to be the empty set instead of 0, but that also counts as a junk value.</p>",
        "id": 321897361,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1673980080
    },
    {
        "content": "<p>I would count <em>any</em> value for <code>x/0</code> as a junk value...</p>",
        "id": 321897529,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1673980130
    },
    {
        "content": "<p>No, if division returns <code>Option Real</code> and <code>x/0 = None</code> then probably not</p>",
        "id": 321897656,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1673980173
    },
    {
        "content": "<p>Or if it is outright undefined, like if you have a proof obligation before you use division.</p>",
        "id": 321897812,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1673980206
    },
    {
        "content": "<p>Can you add a real number to the empty set in Metamath? I think they use complex numbers?</p>",
        "id": 321897876,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1673980219
    },
    {
        "content": "<p>In that case, before starting on formalizing math, I would have considered <em>all</em> values as junk values!  <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 321897893,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1673980223
    },
    {
        "content": "<p>Yes you can add anything. Nonsense addtions return the empty set.</p>",
        "id": 321898068,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1673980270
    },
    {
        "content": "<p>Yeah so maybe the lesson is that junk values occur much more often in set theory than in type theory.</p>",
        "id": 321898236,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1673980315
    },
    {
        "content": "<p><a href=\"https://arxiv.org/abs/0901.0823\">There's a paper</a> defining \"meadows,\" which are rings with a total inverse-like function. Fields extend to meadows if you have x/0 = 0.</p>\n<p>There's also something called a <a href=\"https://en.wikipedia.org/wiki/Von_Neumann_regular_ring\">von Neumann regular ring</a> -- I guess <a href=\"#narrow/stream/113488-general/topic/XenaProject.20blog.20posts/near/203041825\">I brought these up before</a> in this context. In a von Neumann regular ring, for every <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> there exists a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>=</mo><mi>x</mi><mi>y</mi><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x=xyx</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mathnormal\">x</span></span></span></span>, a sort of weak inverse. If you say you want an involutive function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>R</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">f:R\\to R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> that chooses a weak inverse for each element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, then it must be the case that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">f(0)=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>.</p>",
        "id": 321901232,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673981275
    },
    {
        "content": "<p>I think that from an algebraic point of view, there are plenty of good reasons for <code>x/0 = 0</code>. But topologically it is of course garbáge.</p>",
        "id": 321901540,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1673981383
    },
    {
        "content": "<blockquote>\n<p>Metamath defines <code>x/0</code> to be the empty set instead of 0, but that also counts as a junk value.<br>\nNonsense addtions return the empty set.</p>\n</blockquote>\n<p>In the classical set theory (also applies to mizar) it would be much better if they defined addition and division of real numbers using Hilbert's epsilon, so that the result of <code>x / 0</code> can be any set that could possibly exist, not necessarily a real number. Then create an appropriate API for using division and all lemmas that use division <code>a / b</code> would have an assumption <code>b ≠ 0</code>. From the implementational point of view, this additional assumption can be proved automatically from the local context in most cases (just like Lean's type class resolution).</p>",
        "id": 321912748,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1673984778
    },
    {
        "content": "<p>Unfortunately, metamath lacks automation and mizar is no longer actively developed (and more importantly not open source). I'm wondering what could be the reason there are no good set-theoretic theorem provers out there.</p>",
        "id": 321913271,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1673984994
    },
    {
        "content": "<p>Metamath must have something going for it, if Mario can prove the prime number theorem in it.</p>",
        "id": 321920221,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1673987411
    },
    {
        "content": "<p>That thing is probably Mario...</p>",
        "id": 321922002,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1673988040
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/319735259\">said</a>:</p>\n<blockquote>\n<p>You basically always need to know whatever facts guarantee that what you wrote down was \"well-defined\" (else, why not just write 37 instead?) and if you make those proofs arguments to the partial functions, then they are available for later automation</p>\n</blockquote>\n<p>A good example of where this approach is useful is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.cons\">docs#finset.cons</a> / <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.disj_union\">docs#finset.disj_union</a> vs <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.has_insert\">docs#finset.has_insert</a> / <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.has_union\">docs#finset.has_union</a>. When working with sums, the first pair has an obvious lemma with no side conditions.</p>",
        "id": 321962644,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674008192
    },
    {
        "content": "<p>One downside of this approach is that you often need two versions of every lemma, one with the free hypothesis variables on the RHS, and one with them on the LHS; <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.singleton_disj_union\">docs#finset.singleton_disj_union</a> doesn't automatically populate the side condition when rewriting backwards.</p>",
        "id": 321962796,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674008328
    },
    {
        "content": "<p>For division we have <code>/ₚ</code>. It requires the denominator to be a unit.</p>",
        "id": 321962997,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1674008508
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"404479\">Trebor Huang</span> <a href=\"#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/321896751\">said</a>:</p>\n<blockquote>\n<p>After some research I have come to the conclusion: <strong>Every proof assistant that uses classical logic and formalizes real numbers have <code>x/0=0</code></strong>.</p>\n</blockquote>\n<p>Metamath does not define the division function at zero. The function properly has the domain <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi><mo>×</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">C</mi><mo>∖</mo><mo stretchy=\"false\">{</mo><mn>0</mn><mo stretchy=\"false\">}</mo><mo stretchy=\"false\">)</mo><mo>→</mo><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}\\times(\\mathbb{C}\\setminus\\{0\\})\\to \\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7722em;vertical-align:-0.0833em;\"></span><span class=\"mord mathbb\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathbb\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∖</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mclose\">})</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>. It is true that if you evaluate <code>( x / 0 )</code> you get the empty set but that's because this is what happens when you use the \"function value\" operator on a ZFC function out of domain, not because division was defined that way.</p>",
        "id": 321982709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674024448
    },
    {
        "content": "<p>Even more interestingly, there is a new metamath database <a href=\"https://us.metamath.org/ileuni/mmil.html\">iset.mm</a> (for intuitionistic set theory) which has gotten a lot of recent work done on it thanks to Jim Kingdon, and while it tries to follow <a href=\"https://us.metamath.org/mpeuni/mmset.html\">set.mm</a> where possible you just flat out cannot prove that the \"function value\" operation makes any sense without an assumption that the input is in the function's domain. It gets as far as the real numbers, and division again has the same definition (well, I think you need the denominator to be apart from zero but w/e), but you definitely don't have <code>x/0 = 0</code> there. (Although, you did head this off by qualifying \"classical logic\" so I suppose that doesn't count against your claim.)</p>",
        "id": 321983467,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674024991
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456794\">Patrick Johnson</span> <a href=\"#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/321913271\">said</a>:</p>\n<blockquote>\n<p>Unfortunately, metamath lacks automation and mizar is no longer actively developed (and more importantly not open source). I'm wondering what could be the reason there are no good set-theoretic theorem provers out there.</p>\n</blockquote>\n<p>Just in case it wasn't obvious, this is basically asking \"why aren't there more theorem provers with 30+ person-years of effort put into them\". That doesn't come cheap, and as a result you will see a variety of development-specific peculiarities in the ones that exist. Mizar is quite honestly the best contender in that space, it has had many years of effort put into it, but it started out in a completely different era and it has a lot of baggage from that time period. I will also of course shill my <a href=\"https://github.com/digama0/mm0\">MM0</a> system as a sort of hybrid of metamath with automation, although (like metamath) it is not explicitly set theory based so much as FOL based.</p>",
        "id": 321985530,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674025945
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/321985530\">said</a>:</p>\n<blockquote>\n<p>Just in case it wasn't obvious, this is basically asking \"why aren't there more theorem provers with 30+ person-years of effort put into them\". </p>\n</blockquote>\n<p>I'm not talking about math library, I'm talking about design choices of the verifier. Foundations, implementation decisions, term/tactic mode proofs, and similar concepts. Once conceptually designed, a single person can implemented it in a very short period of time and start building a math library.</p>",
        "id": 321988909,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1674027473
    },
    {
        "content": "<p>Last year I started designing and implementing a purely set-theoretic theorem prover. Two of my friends are working with me and we plan to finish the verifier near the end of this year. Then we will build a simple math library and prove basic things from number theory. I'm pretty sure this won't take 30+ person-years of effort.</p>",
        "id": 321989845,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1674027877
    },
    {
        "content": "<p>sure, but will it be \"good\"? That's a really load-bearing word. It takes years of effort for a theorem prover to become \"good\"</p>",
        "id": 321992415,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674029030
    },
    {
        "content": "<p>There are plenty of theorem provers out there with every possible design decision if you don't put that word in</p>",
        "id": 321992506,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674029059
    },
    {
        "content": "<p>Set theory based provers probably have different aesthetics, so what counts as junk value would be different. Judging from a type theoretic perspective returning the empty set definitely counts as junk values, but you could argue otherwise from the set theoretic view.</p>",
        "id": 321993037,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1674029297
    },
    {
        "content": "<p>In any FOL system, function symbols are fundamentally required to denote something. It's no different from a type theory system in which there is only one or only a few types</p>",
        "id": 321993429,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674029490
    },
    {
        "content": "<p>the best you can do is control what theorems are provable about that something</p>",
        "id": 321993447,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674029507
    },
    {
        "content": "<p>Personally, I'm in the camp of embracing \"junk values\" and making them as useful as possible though, so I'm not really motivated to come up with even more tightly isolated junk values, because it never works and only causes pain in my experience</p>",
        "id": 321993720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674029607
    },
    {
        "content": "<p>So if I were making a theorem prover I would set <a href=\"https://github.com/digama0/mm0/blob/45e06c7f95293e974bebd66350c9c45ca304a9a3/examples/peano.mm0#L275\"><code>x / 0 = 0</code></a> like lean does</p>",
        "id": 321993956,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674029708
    },
    {
        "content": "<p>In first order logic + set theory, the empty set looks very much like a global canonical junk, so I'm fine with that. Type theory doesn't give you that (at least not in Lean, I think some type theories not using the CH isomorphism introduce a global undefined value for every type).</p>",
        "id": 321994017,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1674029729
    },
    {
        "content": "<p><code>Inhabited</code> basically gives you canonical junk</p>",
        "id": 321994041,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674029745
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/321993956\">said</a>:</p>\n<blockquote>\n<p>So if I were making a theorem prover I would set <a href=\"https://github.com/digama0/mm0/blob/45e06c7f95293e974bebd66350c9c45ca304a9a3/examples/peano.mm0#L275\"><code>x / 0 = 0</code></a> like lean does</p>\n</blockquote>\n<p>It highly depends on what the goal of a theorem prover is supposed to be. MM0 has an objective task it's trying to accomplish, so it makes sense to have <code>x / 0 = 0</code> as a theorem if it helps reach the final task. However, if we want to write a general-purpose theorem prover to formalize actual mathematics, I see the undefinedness of <code>x / 0</code> as a challenge for the theorem prover inventors, rather than a nuisance we want to avoid at all costs. Mathematicians can handle that on paper without any trouble, so a good theorem prover should have the ability to smoothly translate mathematician's intuition to a formal proof, not to artificially force mathematicians to change their intuition because of the implementational limitations.</p>",
        "id": 322119027,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1674065263
    },
    {
        "content": "<p>This is most likely an irreconcilable difference of opinion, but my angle as a logician and formalist is to find the optimal way to communicate mathematics to a computer, not just to do paper mathematics in the computer and faithfully represent all the designed-for-humans tricks used in paper presentations of mathematics. The latter is a goal for some people, and systems based on controlled natural language very clearly show it, but I am looking at the longer term, where we eventually realize we don't need to follow those old habits anymore. It is akin to the evolution of programming languages: many of the old programming languages were <em>very</em> CNL inspired, but modern programming languages have diverged somewhat from that into simpler grammars with a greater emphasis on symbols instead of words, making the most of a restricted lexicon to make things easy for both the human and the computer.</p>\n<p>As it relates to undefinedness specifically, I find that the best way to render the mathematical practice of having \"unmentionables\" is to use garbage values and then just... not talk about them. Or use them to reduce hypotheses in theorems because more hypotheses = more work.</p>",
        "id": 322125938,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674067337
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456794\">Patrick Johnson</span> <a href=\"#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/322119027\">said</a>:</p>\n<blockquote>\n<p>A good theorem prover should have the ability to smoothly translate mathematician's intuition to a formal proof, not to artificially force mathematicians to change their intuition because of the implementational limitations.</p>\n</blockquote>\n<p>Note that this might be alternatively phrased as</p>\n<blockquote>\n<p>A good theorem prover should never produce new mathematical viewpoints or ideas, and it should have the ability to transfer mathematician's old ideas as faithfully as possible.</p>\n</blockquote>",
        "id": 322136542,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1674070476
    },
    {
        "content": "<p>I don't think I agree with this rephrasing. But in any case, I think that while there are cases where garbage values really are garbage, in many instances I think that appropriately chosen junk values can actually become \"not junk\". For instance, I consider the theorem</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group_with_zero</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹⁻¹</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>a <em>feature</em>, not a bug or a misrepresentation of the mathematical content. Sure, it conflicts with the way mathematical content is currently presented, but I have pretty much decided that I prefer it this way and I would hope eventually the mathematical community could accept the more useful (i.e., ones that make a bunch of theorems have weaker hypotheses) \"junk values\".</p>\n<p>Oh, and if you don't want garbage values, there's always <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pfun\">docs#pfun</a>.</p>",
        "id": 322138664,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1674071226
    },
    {
        "content": "<p>I would say that mathematicians do <em>not</em> handle division by zero on paper without any trouble -- they simply <em>don't divide by zero</em>.</p>",
        "id": 322143672,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674072867
    },
    {
        "content": "<p>Physicists, on the other hand…</p>",
        "id": 322156397,
        "sender_full_name": "Arien Malec",
        "timestamp": 1674077280
    },
    {
        "content": "<blockquote>\n<p>I would say that mathematicians do not handle division by zero on paper without any trouble -- they simply don't divide by zero.</p>\n</blockquote>\n<p>By \"Mathematicians can handle <strong>that</strong> on paper\" I mean handling of the additional assumptions of the form <code>x ≠ 0</code></p>",
        "id": 322160762,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1674078798
    },
    {
        "content": "<p>That is, they don't need to interrupt the proof to show that the division in some particular expression is well-defined. It is either obvious from the context, or in case it's not, they give a small comment explaining why the denominator can't be zero there.</p>",
        "id": 322161141,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1674078953
    },
    {
        "content": "<p>If one day mathematicians realize they want division by zero to be 0 and change the standard convention, we should accept that. My point is not whether that definition would be useful in practice or not, but that a good theorem prover should let the user easily work with truly undefined results if the user wants them in definitions for whatever reason.</p>",
        "id": 322162051,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1674079269
    },
    {
        "content": "<p>Yes, mathematicians are good at knowing that xy is obviously nonzero if x and y are nonzero, or that sqrt(x^2+1) is obviously non-zero etc (here x and y are reals). But this sounds like a hard problem for automation.</p>",
        "id": 322162567,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674079460
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456794\">Patrick Johnson</span> <a href=\"#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/322162051\">said</a>:</p>\n<blockquote>\n<p>If one day mathematicians realize they want division by zero to be 0 and change the standard convention, we should accept that. My point is not whether that definition would be useful in practice or not, but that a good theorem prover should let the user easily work with truly undefined results if the user wants them in definitions for whatever reason.</p>\n</blockquote>\n<p>These people are welcome to make their division with <code>pfun</code> but I'm happy to stick with what's easiest. I don't particularly believe in building scaffolding so that people can fall off from higher up</p>",
        "id": 322163512,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1674079831
    },
    {
        "content": "<p>You can also use this as an argument against type systems.</p>",
        "id": 322164196,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674080125
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/322162567\">said</a>:</p>\n<blockquote>\n<p>that xy is obviously nonzero if x and y are nonzero, or that sqrt(x^2+1) is obviously non-zero etc </p>\n</blockquote>\n<p>And it's not just this but also: the cardinality of a nonempty (and also finite, obviously) set is obviously non-zero, and the set is also nonempty for some obvious reason...</p>",
        "id": 322165674,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674080795
    },
    {
        "content": "<p>If a mathematician wants to talk about division (as a partial function) in Lean, they can use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/divp\">docs#divp</a> with <code>units.mk0</code> here and there.</p>",
        "id": 322184344,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1674090955
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"404479\">Trebor Huang</span> <a href=\"#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/322136542\">said</a>:<br>\nNote that this might be alternatively phrased as</p>\n<blockquote>\n<p>A good theorem prover should never produce new mathematical viewpoints or ideas, and it should have the ability to transfer mathematician's old ideas as faithfully as possible.</p>\n</blockquote>\n<p>I don't really know if I agree with this rephrasing, because it is possible that at some point in the future, the problem of partial functions will be solved <em>by</em> an innovation in mathematics. I read somewhere that to formalize the many different types of limits in Lean we had to use filters, which in my opinion is an example of something difficult to formalize being formalized by coming up with new mathematics. You can call me overly optimistic, but in other words it's possible that at some point in the future we will encounter a way to express partial functions in a natural way consistent with pen-and-paper mathematics but friendly to formalization (kind of like how the Curry-Howard isomorphism is very unique and different from what mathematicians are used to but ultimately is consistent with mathematicians' basic rules). My point is not that this is particularly likely to happen, but rather that looking for ways to formalize difficult-to-formalize ideas in a natural way can actually be somewhat insightful, and not just clinging onto obsolete ideas from pen-and-paper mathematics.</p>\n<p>However, as far as Lean is concerned, I think <code>n / 0 = 0</code> is the best choice simply because it makes a lot of things easier to work with by reducing the number of hypotheses, and isn't as different from pen-and-paper mathematics as I had originally thought (and, as other people have mentioned, junk values can have a lot of desirable properties). The only place where I am a bit wary of this would be when programming, since I would normally expect division by zero to crash the program (which can potentially avoid many worse things such as data corruption or security vulnerabilities). Hopefully with the ability to do logical verification this won't be that big of a problem.</p>",
        "id": 322198065,
        "sender_full_name": "Niels Voss",
        "timestamp": 1674102461
    },
    {
        "content": "<p>What is the essential difference between introducing filters (for basic analysis) and introducing <code>x/0=0</code>? One is more aesthetically grounded than the other? Apart from that these two are both forcing something mathematicians don't conventionally use, because they make formalization easier.</p>",
        "id": 322198785,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1674103223
    },
    {
        "content": "<p>Also, in Lean we have that <code>lst[n]!</code> crashes the program, but is definitionally equal to some junk value. Do we do that for division? (Not for real number, for the more computable stuff)</p>",
        "id": 322198860,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1674103304
    },
    {
        "content": "<p>I can't really argue much about the filters because I actually don't know much about them, I just happened to briefly read about them somewhere. Division could be designed to crash when dividing by zero, but I think that actually might prevent you from being able to prove that your program doesn't crash. Right now, you pretty much know that if you don't use either panic or an operation ending with a <code>!</code> then your program probably won't crash. Maybe a separate <code>/!</code> operator that crashes could be introduced.<br>\nNow that I think about it more, I actually don't know a good way to resolve the programming aspect of division by zero, aside from using <code>divp</code>, which as was discussed earlier, would be more difficult to use.</p>",
        "id": 322199273,
        "sender_full_name": "Niels Voss",
        "timestamp": 1674103732
    },
    {
        "content": "<p>Now that I think about it, something like <code>divp</code> (or a <code>divp?</code> that returns an <code>option</code>) might not actually be that bad of an idea while programming, because it helps prevent certain types of errors when implementing algorithms. <code>n / 0 = 0</code> is still probably better for doing mathematics, though.</p>",
        "id": 322199658,
        "sender_full_name": "Niels Voss",
        "timestamp": 1674104110
    }
]
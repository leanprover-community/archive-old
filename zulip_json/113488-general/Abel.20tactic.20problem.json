[
    {
        "content": "<p>I tried the following:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">L1</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">*</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">ring</span><span class=\"bp\">.</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">L2</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">*</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">abel</span>\n</pre></div>\n\n\n<p><code>L1</code> works but <code>L2</code> gives <code>abel failed to simplify</code>.  Is this a bug or am I misunderstanding something?</p>",
        "id": 155242485,
        "sender_full_name": "Neil Strickland",
        "timestamp": 1547633935
    },
    {
        "content": "<p>Glancing over the code for abel, it appears it only works with addition.</p>",
        "id": 155242603,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1547634058
    },
    {
        "content": "<p>OK, you seem to be right.  It would be good if the tactic docstring mentioned that.  Do you understand the story about the <code>to_additive</code> attribute?  It would be  nice if we could automagically make <code>abel</code> work with both additive and multiplicative monoids, but I have no idea how to go about that.</p>",
        "id": 155243065,
        "sender_full_name": "Neil Strickland",
        "timestamp": 1547634525
    },
    {
        "content": "<p>The story is that typeclasses were invented to be a cool way to deal with notation in Haskell, Lean has taken them to extremes, and now we discover that what looked like a cool definition of a group turns out to be bound to a notation for the group law. No reasonable solution to this has yet been found, or at least, to my knowledge, has been coded in Lean. The <code>to_additive</code> thing is just a hack which attempts to switch <code>has_mul.mul</code> to <code>has_add.add</code>, with limited success (the definition of \"success\" would be \"nobody has to ever worry about this issue ever again and it all happens automatically whenever we want it to\", which is apparently an unattainable dream). A structure equipped with a <code>has_mul.mul</code> instance is canonically isomorphic to a structure equipped with a <code>has_add.add</code> instance, however as you surely know by now, the CS guys cannot seem to write a tactic which seamlessly moves from one to the other -- or at least they have not done this yet. So currently we are stuck with <code>group</code> and <code>add_group</code>, and all the resulting noise. One of the problems is, I think, that mathematicians tend to hide behind this \"canonically isomorphic\" phrase without ever really saying what they mean by it, and another problem, I think, is that apparently dealing with this issue in full generality is very hard in dependent type theory for some reason. I mentioned this to several people last week and they all replied \"switch to HOTT!\" which is an extremely unhelpful response in my opinion. I would rather be told more about why DTT struggles here.</p>\n<p>Could there be a <code>has_binary_operation</code> typeclass, not attached to any notation by default, which could somehow be used as a partial fix for all this? Then I think we're back to isomorphic structures and Lean's inability to easily pass theorems and definitions between them.</p>",
        "id": 155245482,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547637110
    }
]
[
    {
        "content": "<p>I've been finding bundled morphisms very irritating to write lemmas about. Consider:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- the actual lemma</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">zero_hom.map_single_apply</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">zero_hom</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">finsupp.single</span> <span class=\"n\">j</span> <span class=\"n\">v</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">finsupp.single</span> <span class=\"n\">j</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finsupp.single_apply</span><span class=\"o\">,</span> <span class=\"n\">finsupp.single_apply</span><span class=\"o\">,</span> <span class=\"n\">apply_ite</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.map_zero</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- the tedious copy paste operation</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">add_monoid_hom.map_single_apply</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→+</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">finsupp.single</span> <span class=\"n\">j</span> <span class=\"n\">v</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">finsupp.single</span> <span class=\"n\">j</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"n\">f.to_zero_hom.map_single_apply</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">ring_hom.map_single_apply</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→+*</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">finsupp.single</span> <span class=\"n\">j</span> <span class=\"n\">v</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">finsupp.single</span> <span class=\"n\">j</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"n\">f.to_add_monoid_hom.map_single_apply</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">alg_hom.map_single_apply</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">finsupp.single</span> <span class=\"n\">j</span> <span class=\"n\">v</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">finsupp.single</span> <span class=\"n\">j</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"n\">f.to_ring_hom.map_single_apply</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n</code></pre></div>\n\n<p>While I only have to write an interesting proof once, I'm then forced to manually copy across  the lemma to every single derived <code>hom</code> structure if I want it to be useful - something that wouldn't be necessary if type class inference were involved.</p>",
        "id": 213184033,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1602607523
    },
    {
        "content": "<p>Earlier we migrated from the typeclass approach because Lean can't effectively use <code>is_add_monoid_hom.map_add</code> as a <code>simp</code> lemma.</p>",
        "id": 213195920,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1602613113
    },
    {
        "content": "<p>Clearly, we need more automation here but I don't know how to implement it (read: my <code>meta</code> programming skills are not good enough for the job).</p>",
        "id": 213196081,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1602613196
    },
    {
        "content": "<p>I think there was a suggestion at one point that if <code>structure B extends A</code> and <code>f : B</code> and there is <code>A.foo</code> but no <code>B.foo</code> then <code>f.foo</code> means <code>f.to_A.foo</code>.</p>",
        "id": 213197044,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602613642
    },
    {
        "content": "<p>I don't know if this is something planned for Lean 4 though.</p>",
        "id": 213197068,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602613658
    },
    {
        "content": "<p>also, I guess there might be minor details which this doesn't address, e.g. the lemma <code>add_monoid_hom.map_single_apply</code> above is stated in terms of <code>add_monoid_hom</code>'s coercion to function but its definition would be stated in terms of <code>zero_hom</code>'s coercion to function</p>",
        "id": 213197823,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602613975
    },
    {
        "content": "<p>We also need to automatically make <code>(f : ring_hom).to_monoid_hom.map_mul</code> it a <code>simp</code> lemma. I think, it should be easier to have a command \"import the following lemmas using this projection\".</p>",
        "id": 213199168,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1602614526
    },
    {
        "content": "<p>Or \"import all lemmas about <code>f.to_monoid_hom</code> marked with an attribute\"</p>",
        "id": 213199240,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1602614567
    },
    {
        "content": "<p>The command should be clever enough to replace <code>[monoid M]</code> with <code>[ring R]</code> and <code>[comm_monoid M]</code> with <code>[comm_ring R]</code>.</p>",
        "id": 213199327,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1602614613
    },
    {
        "content": "<p>Relatedly I'd like to be able to write <code>rw monoid_hom.map_mul</code> and have it match <code>ring_hom</code> too</p>",
        "id": 213226690,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1602629129
    },
    {
        "content": "<p>That's funny, I never rewrite stuff like that -- I always rewrite stuff like <code>f.map_mul</code> (so basically it's guaranteed to use the right one)</p>",
        "id": 213227010,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1602629399
    },
    {
        "content": "<p>I suppose my actual case was where I just wanted to do all of them in a <code>simp_rw</code></p>",
        "id": 213227143,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1602629519
    },
    {
        "content": "<p>I think it's also useful when you have some structure extending, say, a <code>monoid_hom</code>.</p>",
        "id": 213227210,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1602629543
    },
    {
        "content": "<p>It's annoying to write <code>f.to_monoid_hom.map_mul</code> or whatever</p>",
        "id": 213227238,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1602629565
    },
    {
        "content": "<p>Right, but that has the same solution as the original problem</p>",
        "id": 213227315,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1602629627
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/213227010\">said</a>:</p>\n<blockquote>\n<p>That's funny, I never rewrite stuff like that -- I always rewrite stuff like <code>f.map_mul</code> (so basically it's guaranteed to use the right one)</p>\n</blockquote>\n<p>Trouble with this is sometimes <code>f</code> is really long</p>",
        "id": 213228891,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1602630684
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/213195920\">said</a>:</p>\n<blockquote>\n<p>Earlier we migrated from the typeclass approach because Lean can't effectively use <code>is_add_monoid_hom.map_add</code> as a <code>simp</code> lemma.</p>\n</blockquote>\n<p>Can you elaborate a bit on why that's true? Why can lean use things like <code>inv_inv</code> as simp lemmas, which also depend on typeclass resolution?<br>\nIs the issue <code>has_coe_to_fun</code>?</p>",
        "id": 214313541,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603460013
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_add_monoid_hom.map_add\">docs#is_add_monoid_hom.map_add</a> has no <code>coe_fn</code> in it. OTOH,  <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_monoid_hom.map_add\">docs#add_monoid_hom.map_add</a> has <code>@coe_fn (add_monoid_hom)</code>, and <code>simp</code> can match on it.</p>",
        "id": 214328851,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1603467407
    },
    {
        "content": "<p>Similarly, <code>simp</code> can match <code>has_inv.inv</code> in <code>inv_inv</code>,  then start searching for the instance.</p>",
        "id": 214328894,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1603467427
    },
    {
        "content": "<p>But simp can't match <code>[is_add_monoid_hom f]</code> in <code>is_add_monoid_hom.map_add</code>?</p>",
        "id": 214329641,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603467834
    },
    {
        "content": "<p>It looks at <code>my_fun (a + b)</code>. It doesn't know that <code>my_fun</code> is a homomorphism at this moment.</p>",
        "id": 214330369,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1603468203
    },
    {
        "content": "<p>My thinking was that it would match against the lemma statement of <code>is_add_monoid_hom.map_add</code> as its statement matches <code>f (a + b)</code>, then find the predicate <code>[is_add_monoid_hom f]</code> as the second step. Is that not how simp matching works?</p>",
        "id": 214330677,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603468372
    },
    {
        "content": "<p><code>simp</code> works well if it can match on the head symbol.</p>",
        "id": 214335362,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1603470759
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> encountered <a href=\"https://github.com/leanprover-community/mathlib/pull/4874#discussion_r516126899\">an instance where the unbundled type classes make sense</a>. Consider:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">matrix.is_zero_hom_map_zero</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_zero_hom</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">n</span> <span class=\"n\">n</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n<p>Since the head symbol is <code>matrix.map</code>, this is a useful <code>simp</code> lemma, correct? The current <code>is_foo_hom</code> typeclasses do not have instances <code>(f : foo_hom) : is_foo_hom f</code>, unfortunately, so we cannot use the unbundled predicate yet. The alternative would be to copy the declaration for each <code>foo_hom</code>, which doesn't sound very scalable. </p>\n<p>So here is my modest proposal for uniting the unbundled and bundled dichotomy:</p>\n<ul>\n<li>create an <code>is_foo_hom</code> typeclass for each <code>foo_hom</code> that doesn't have one yet</li>\n<li>add <code>instance (f : foo_hom) : is_foo_hom f</code> and nothing more, except:</li>\n<li>whenever <code>bar_hom</code> extends <code>foo_hom</code>, <code>is_bar_hom</code> should extend <code>is_foo_hom</code></li>\n<li>instead of defining <code>@[simp] lemma foo_hom.map_qux (f : foo_hom) : coe_fn f qux = quux</code>, define <code>@[simp] lemma is_foo_hom.map_qux {foo_hom_like : Type*} (f : foo_hom_like) [is_foo_hom f] : coe_fn f qux = quux</code>.</li>\n</ul>\n<p>Thoughts?</p>",
        "id": 215428568,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604395454
    },
    {
        "content": "<p>I don't understand your last bullet point - the lemma involves the derived structure <code>bar_hom</code>, which surely results in the same duplication we're trying to avoid?</p>",
        "id": 215428981,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604395724
    },
    {
        "content": "<p>Ah, the trick is the <code>{bar_hom : Type*}</code> parameter: for any type whose inhabitants are <code>foo_hom</code>s, we have the lemma. I see how the name is confusing, let me rephrase it...</p>",
        "id": 215429079,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604395799
    },
    {
        "content": "<p>\"if bar_hom extends foo_hom\" - is this solved by just having <code>is_bar_hom</code> extend <code>is_foo_hom</code>?</p>",
        "id": 215429171,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604395837
    },
    {
        "content": "<p>You're right <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span></p>",
        "id": 215429255,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604395904
    },
    {
        "content": "<p>So would the rule become \"inputs should use typeclass homs, outputs bundled homs\", or is it more subtle?</p>",
        "id": 215429438,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604396011
    },
    {
        "content": "<p>That sounds like a good rule of thumb, maybe qualified with \"an input <code>f</code> should be an unbundled hom if it does not appear as a head symbol\"? Or just arrange things so that they don't appear in that position?</p>",
        "id": 215429655,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604396143
    },
    {
        "content": "<p>Perhaps <code>lift</code>-like operations need to stay bundled to ensure coherence? I don't know.</p>",
        "id": 215429747,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604396196
    },
    {
        "content": "<p>Wouldn't it be nicer to have some kind of tactic framework if we have bundled definitions that all satisfy the same kind of properties, to generate all the basic lemmas for the structure? For instance, there are many equiv-like structures. If we could tag them with <code>@equiv</code>, it could generate things like <code>apply_symm_apply</code> and the likes (currently, I see 9 instances of Lemma/Theorem <code>apply_symm_apply</code> in mathlib, for 9 different <code>equiv</code>-like structures). I have the impression that your problem belongs to the same kind of question: a framework to generate a basic skeleton that comes again and again.</p>",
        "id": 215430371,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1604396538
    },
    {
        "content": "<p>(I should say that I am not over-enthusiastic over the idea to rely again on non-bundled stuff, because for me the move to bundled stuff made things really better. But if you find a nice way to solve your problem using them, and if this could scale to equivs and the likes, maybe it just means that your way of using them is just more clever than what we did before!)</p>",
        "id": 215430673,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1604396740
    },
    {
        "content": "<p>\"as a head symbol\" means \"not <code>coe_fun f arg</code>? Is <code>f</code> even the head symbol there anyway?</p>",
        "id": 215430773,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604396797
    },
    {
        "content": "<p>If generating lemmas with tactics works well (and I don't have to write it), I'm also for it. Although it feels like we're working against Lean to get what we want, instead of using typeclasses for what they were intended.</p>",
        "id": 215430834,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604396852
    },
    {
        "content": "<p>Does the whole head symbol problem go away if we're using <code>[is_hom f_type]</code> instead of <code>[is_hom f]</code>?</p>",
        "id": 215430931,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604396903
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/215430773\">said</a>:</p>\n<blockquote>\n<p>\"as a head symbol\" means \"not <code>coe_fun f arg</code>? Is <code>f</code> even the head symbol there anyway?</p>\n</blockquote>\n<p>In that case, <code>coe_fun</code> is the head symbol. The reason for the qualification is that many tactics categorize lemmas based on the head symbol. So when <code>simp</code> traverses the subexpressions, it can do a quick equality-of-symbols check to see if this subexpression is relevant, rather than doing a big unification with each possible <code>simp</code> lemma. Similarly for <code>library_search</code>, etc.</p>",
        "id": 215431382,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604397141
    },
    {
        "content": "<p>So <code>[is_zero_hom f] : f 0 = 0</code> is problematic, but <code>[is_zero_hom (coe_fn f)] : coe_fn f 0 = 0</code> would work.</p>",
        "id": 215431448,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604397189
    },
    {
        "content": "<p>I have a meeting in a couple of minutes, in 90 minutes or so I can try writing a concrete example to see if this idea holds any water.</p>",
        "id": 215431591,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604397270
    },
    {
        "content": "<p>If f is not a function, then surely automatic coercion means it is never a head symbol, and the coercion is?</p>",
        "id": 215431846,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604397457
    },
    {
        "content": "<p>Right, but <code>is_zero_hom</code> would take <code>f : α → β</code> as an argument (it needs to since you can't easily get the domain/codomain from a general <code>has_coe_to_fn</code> instance). But then you'd be tempted to \"generalize\" <code>is_zero_hom.map_zero</code> to adding <code>f : α → β</code> as an argument to your lemma instead of <code>f : is_foo_hom_like</code>.</p>",
        "id": 215432066,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604397591
    },
    {
        "content": "<p>Bah, <code>has_coe_to_fun</code> as a typeclass argument doesn't work well at all:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_zero_hom</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map_zero'</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">is_zero_hom.map_zero</span> <span class=\"o\">{</span><span class=\"n\">zero_hom_like</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_coe_to_fun</span> <span class=\"n\">zero_hom_like</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">zero_hom_like</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_zero_hom</span> <span class=\"o\">(</span><span class=\"n\">coe_fn</span> <span class=\"n\">f</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"c1\">-- error: expected `? -&gt; ?`, got `has_coe_to_fun.F f`</span>\n  <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"n\">is_zero_hom.map_zero'</span>\n</code></pre></div>",
        "id": 215440129,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604402493
    },
    {
        "content": "<p>Can you make <code>is_zero_hom</code> extend <code>has_coe_to_fun</code> somehow?</p>",
        "id": 215440740,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604402840
    },
    {
        "content": "<p>Or use <code>(f : M → N)</code> instead of <code>coe_fn f</code>?</p>",
        "id": 215440762,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604402860
    },
    {
        "content": "<p>I'm trying something like the first option now:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">is_hom</span> <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">is_hom.to_coe_fn</span> <span class=\"o\">[</span><span class=\"n\">is_hom</span> <span class=\"n\">hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">,</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">is_hom.coe</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_zero_hom</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_hom</span> <span class=\"n\">hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map_zero</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 215440873,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604402918
    },
    {
        "content": "<p>But I suspect that <code>M</code> and <code>N</code> should be <code>out_param</code>s for <code>is_zero_hom</code></p>",
        "id": 215440896,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604402939
    },
    {
        "content": "<p>This seems to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.group.hom</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n\n<span class=\"cm\">/-- Homomorphism that preserves zero -/</span>\n<span class=\"cm\">structure zero_hom (M : Type*) (N : Type*) [has_zero M] [has_zero N] :=</span>\n<span class=\"cm\">(to_fun : M → N)</span>\n<span class=\"cm\">(map_zero' : to_fun 0 = 0)</span>\n\n<span class=\"cm\">/-- Homomorphism that preserves addition -/</span>\n<span class=\"cm\">structure add_hom (M : Type*) (N : Type*) [has_add M] [has_add N] :=</span>\n<span class=\"cm\">(to_fun : M → N)</span>\n<span class=\"cm\">(map_add' : ∀ x y, to_fun (x + y) = to_fun x + to_fun y)</span>\n\n<span class=\"cm\">/-- Bundled add_monoid homomorphisms; use this for bundled add_group homomorphisms too. -/</span>\n<span class=\"cm\">structure add_monoid_hom (M : Type*) (N : Type*) [add_monoid M] [add_monoid N]</span>\n<span class=\"cm\">extends zero_hom M N, add_hom M N</span>\n\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_hom_type</span> <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">is_hom_type.to_coe_fn</span> <span class=\"o\">[</span><span class=\"n\">is_hom_type</span> <span class=\"n\">hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">,</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">is_hom_type.coe</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_zero_hom</span> <span class=\"o\">{</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_hom_type</span> <span class=\"n\">hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map_zero</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">is_zero_hom.map_zero</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">zero_hom.is_hom_type</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_hom_type</span> <span class=\"o\">(</span><span class=\"n\">zero_hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">zero_hom.is_zero_hom</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">zero_hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_zero_hom</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">f.map_zero'</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_add_hom</span> <span class=\"o\">{</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_hom_type</span> <span class=\"n\">hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map_add</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">add_hom.is_hom</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_hom_type</span> <span class=\"o\">(</span><span class=\"n\">add_hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">add_hom.is_add_hom</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">add_hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_add_hom</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">f.map_add'</span><span class=\"o\">⟩</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">is_add_hom.map_add</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_add_monoid_hom</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_hom_type</span> <span class=\"n\">hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom</span><span class=\"o\">)</span>\n<span class=\"kd\">extends</span> <span class=\"n\">is_zero_hom</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">is_add_hom</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">add_monoid_hom.is_hom</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_hom_type</span> <span class=\"o\">(</span><span class=\"n\">add_monoid_hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">add_monoid_hom.is_add_monoid_hom</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→+</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_add_monoid_hom</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map_zero</span> <span class=\"o\">:=</span> <span class=\"n\">f.map_zero'</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add</span> <span class=\"o\">:=</span> <span class=\"n\">f.map_add'</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">test</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">add_zero</span> <span class=\"n\">add_hom.map_add</span> <span class=\"n\">add_monoid_hom.map_add</span> <span class=\"n\">add_monoid_hom.map_zero</span> <span class=\"n\">zero_hom.map_zero</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→+</span> <span class=\"n\">N</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→+</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">g.comp</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">squeeze_simp</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">test</span>\n</code></pre></div>",
        "id": 215441595,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604403413
    },
    {
        "content": "<p>Having <code>is_zero_hom</code> extend <code>is_hom</code> didn't work?</p>",
        "id": 215442874,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604404207
    },
    {
        "content": "<p>The names are a bit confusing, but <code>is_hom</code> is a predicate on the type <code>hom</code>, while <code>is_zero_hom</code> is a predicate on an element <code>f : hom</code>. So extending is not what we want. I will rename <code>is_hom -&gt; is_hom_type</code>.</p>",
        "id": 215442994,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604404301
    },
    {
        "content": "<blockquote>\n<p>while is_zero_hom is a predicate on an element f : hom.</p>\n</blockquote>\n<p>Why is this better than having it be a predicate on <code>hom</code> itself?</p>",
        "id": 215443387,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604404516
    },
    {
        "content": "<p>That is,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">is_zero_hom</span> <span class=\"o\">{</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_hom_type</span> <span class=\"n\">hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map_zero</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 215443524,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604404602
    },
    {
        "content": "<p>I get an error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">is_hom</span> <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">is_hom.to_coe_fn</span> <span class=\"o\">[</span><span class=\"n\">is_hom</span> <span class=\"n\">hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">,</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">is_hom.coe</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_zero_hom</span> <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">is_hom</span> <span class=\"n\">hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map_zero</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_add_hom</span> <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">is_hom</span> <span class=\"n\">hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map_add</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_add_monoid_hom</span> <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n<span class=\"kd\">extends</span> <span class=\"n\">is_zero_hom</span> <span class=\"n\">hom</span><span class=\"o\">,</span> <span class=\"n\">is_add_hom</span> <span class=\"n\">hom</span> <span class=\"c1\">-- don't know how to synthesize placeholder `(out_param Type*)`</span>\n</code></pre></div>",
        "id": 215443992,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604404881
    },
    {
        "content": "<p>Let's try making <code>M</code> and <code>N</code> explicit then...</p>",
        "id": 215444033,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604404916
    },
    {
        "content": "<p>Yup, that also works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.group.hom</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n\n<span class=\"cm\">/-- Homomorphism that preserves zero -/</span>\n<span class=\"cm\">structure zero_hom (M : Type*) (N : Type*) [has_zero M] [has_zero N] :=</span>\n<span class=\"cm\">(to_fun : M → N)</span>\n<span class=\"cm\">(map_zero' : to_fun 0 = 0)</span>\n\n<span class=\"cm\">/-- Homomorphism that preserves addition -/</span>\n<span class=\"cm\">structure add_hom (M : Type*) (N : Type*) [has_add M] [has_add N] :=</span>\n<span class=\"cm\">(to_fun : M → N)</span>\n<span class=\"cm\">(map_add' : ∀ x y, to_fun (x + y) = to_fun x + to_fun y)</span>\n\n<span class=\"cm\">/-- Bundled add_monoid homomorphisms; use this for bundled add_group homomorphisms too. -/</span>\n<span class=\"cm\">structure add_monoid_hom (M : Type*) (N : Type*) [add_monoid M] [add_monoid N]</span>\n<span class=\"cm\">extends zero_hom M N, add_hom M N</span>\n\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">old_structure_cmd</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_hom</span> <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">is_hom.to_coe_fn</span> <span class=\"o\">[</span><span class=\"n\">is_hom</span> <span class=\"n\">hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">,</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">is_hom.coe</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_zero_hom</span> <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">is_hom</span> <span class=\"n\">hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map_zero</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">is_zero_hom.map_zero</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">zero_hom.is_zero_hom</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_zero_hom</span> <span class=\"o\">(</span><span class=\"n\">zero_hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.to_fun</span><span class=\"o\">,</span>\n  <span class=\"n\">map_zero</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.map_zero'</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_add_hom</span> <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">is_hom</span> <span class=\"n\">hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map_add</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">add_hom.is_add_hom</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_add_hom</span> <span class=\"o\">(</span><span class=\"n\">add_hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.to_fun</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.map_add'</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">is_add_hom.map_add</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_add_monoid_hom</span> <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n<span class=\"kd\">extends</span> <span class=\"n\">is_zero_hom</span> <span class=\"n\">hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">is_add_hom</span> <span class=\"n\">hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">add_monoid_hom.is_add_monoid_hom</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_add_monoid_hom</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">→+</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.to_fun</span><span class=\"o\">,</span>\n  <span class=\"n\">map_zero</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.map_zero'</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.map_add'</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">test</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">add_zero</span> <span class=\"n\">add_hom.map_add</span> <span class=\"n\">add_monoid_hom.map_add</span> <span class=\"n\">add_monoid_hom.map_zero</span> <span class=\"n\">zero_hom.map_zero</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→+</span> <span class=\"n\">N</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→+</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">g.comp</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">squeeze_simp</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">test</span>\n</code></pre></div>",
        "id": 215444243,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604405042
    },
    {
        "content": "<p>Is <code>add_monoid_hom.is_hom </code> needed there?</p>",
        "id": 215444331,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604405085
    },
    {
        "content": "<p>We can delete it, indeed.</p>",
        "id": 215444371,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604405105
    },
    {
        "content": "<p>And I suppose</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">hom1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hom2</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">is_add_monoid_hom</span> <span class=\"n\">hom1</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">is_add_monoid_hom</span> <span class=\"n\">hom2</span> <span class=\"n\">N</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">hom2</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">squeeze_simp</span>\n</code></pre></div>\n<p>is how you'd write your example with the new typeclasses, so that it works \"by magic\" on ring_homs too</p>",
        "id": 215444695,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604405297
    },
    {
        "content": "<p>Indeed, something like that. I wanted to make sure that <code>comp</code> worked well which is why I included it. Since that was an important motivation to bundle homs (if I understand the history correctly).</p>",
        "id": 215445187,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604405624
    },
    {
        "content": "<p>Unfortunately that's rather hard to read snice the \"type\" of f and g is no longer inline</p>",
        "id": 215445297,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604405677
    },
    {
        "content": "<p>Maybe <code>is_hom</code> should include <code>id</code>, <code>comp</code> and <code>ext</code>, to look more like <code>category_theory.bundled_hom</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">bundled_hom</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Iα</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Iβ</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">hom</span> <span class=\"n\">Iα</span> <span class=\"n\">Iβ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">hom</span> <span class=\"n\">I</span> <span class=\"n\">I</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">comp</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Iα</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Iβ</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Iγ</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">γ</span><span class=\"o\">),</span>\n  <span class=\"n\">hom</span> <span class=\"n\">Iβ</span> <span class=\"n\">Iγ</span> <span class=\"bp\">→</span> <span class=\"n\">hom</span> <span class=\"n\">Iα</span> <span class=\"n\">Iβ</span> <span class=\"bp\">→</span> <span class=\"n\">hom</span> <span class=\"n\">Iα</span> <span class=\"n\">Iγ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">hom_ext</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Iα</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Iβ</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">Iα</span> <span class=\"n\">Iβ</span><span class=\"o\">)</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">id_to_fun</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">to_fun</span> <span class=\"n\">I</span> <span class=\"n\">I</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">_root_.id</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">comp_to_fun</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Iα</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Iβ</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Iγ</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">Iα</span> <span class=\"n\">Iβ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">Iβ</span> <span class=\"n\">Iγ</span><span class=\"o\">),</span>\n  <span class=\"n\">to_fun</span> <span class=\"n\">Iα</span> <span class=\"n\">Iγ</span> <span class=\"o\">(</span><span class=\"n\">comp</span> <span class=\"n\">Iα</span> <span class=\"n\">Iβ</span> <span class=\"n\">Iγ</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">Iβ</span> <span class=\"n\">Iγ</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">Iα</span> <span class=\"n\">Iβ</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 215445347,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604405707
    },
    {
        "content": "<p>(Luckily we wouldn't have <code>c : Type u → Type u</code> forcing everything into the same universe!)</p>",
        "id": 215445457,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604405766
    },
    {
        "content": "<p>I just had a go at using something like <code>class is_hom (hom : Type u₂ → Type u₃ → Type u₁)</code>, but I don't think it works out</p>",
        "id": 215445508,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604405820
    },
    {
        "content": "<p>You can't instantiate that kind of <code>is_hom</code> for <code>zero_hom</code>, since not all <code>Type u</code>s have a zero :(</p>",
        "id": 215445630,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604405890
    },
    {
        "content": "<p>Exactly</p>",
        "id": 215445639,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604405900
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.bundled_hom\">docs#category_theory.bundled_hom</a> since I'm lazy</p>",
        "id": 215445719,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604405980
    },
    {
        "content": "<p>I see the <code>c α</code> arguments end up holding the type-classes</p>",
        "id": 215445848,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604406079
    },
    {
        "content": "<p>I don't see how you can get <code>comp</code> in a structure in any sensible way - how do I write <code>comp</code> for <code>(A → B) → (B → C) → (A → C)</code> if all three types live in different universes? I'd need a universe quantifier in a field, which isn't allowed</p>",
        "id": 215446097,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604406268
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/215445457\">said</a>:</p>\n<blockquote>\n<p>(Luckily we wouldn't have <code>c : Type u → Type u</code> forcing everything into the same universe!)</p>\n</blockquote>\n<p>That is, I don't see how you plan to lift the restriction you mention in this comment</p>",
        "id": 215446268,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604406380
    },
    {
        "content": "<p>You are correct, we cannot add a good definition for <code>id</code> or <code>comp</code>. <code>ext</code> works though:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">is_hom</span> <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">ext</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">coe</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 215446467,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604406514
    },
    {
        "content": "<p>I guess we can have <code>has_comp (homMN homNO : Type*) (homMO : out_param Type*)</code> and <code>has_id</code> typeclasses with the coherence conditions in there, but that would be an inference disaster. :(</p>",
        "id": 215446642,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604406609
    },
    {
        "content": "<p>Related: <a href=\"#narrow/stream/113488-general/topic/universes/near/214217753\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214217753</a></p>",
        "id": 215448584,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604407851
    },
    {
        "content": "<p>The main problem with \"use <code>coe_fn</code> as the head symbol\" trick is that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_coe_to_fun\">docs#has_coe_to_fun</a> does not allow us to require \"type <code>hom_type</code> has coercion to <code>M → N</code>\".</p>",
        "id": 215450836,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1604409199
    },
    {
        "content": "<p>This happens because <code>F</code> is a part of the output, not an <code>out_param</code></p>",
        "id": 215450947,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1604409246
    },
    {
        "content": "<p>Is this something that lean4 could change the mechanics of, or would the <code>out_param</code> choice be worse in other ways?</p>",
        "id": 215451572,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604409627
    },
    {
        "content": "<p>The <code>is_hom</code> class is supposed to fix that issue by putting the requirement in there. The only drawback is that the <code>has_coe_to_fun</code> instance must derive from <code>is_hom</code> for <code>simp</code> to work correctly?</p>",
        "id": 215455570,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604411694
    },
    {
        "content": "<p>Or would there be another issue I'm missing?</p>",
        "id": 215455602,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604411713
    },
    {
        "content": "<p>In algebra also, the move to bundled homs has been very nice. I would like to challenge the idea that having about 10 <code>map_zero</code> lemmas \"doesn't scale\". I think it's scaling really nicely. It is linear in the number of interesting collections of bundled morphisms, and this collection is not going to grow too much bigger in the near future -- the algebraic hierarchy is not going to massively expand randomly because someone discovers a fundamental new class of objects like groups, rings etc. I'm not saying I'm against the idea of bringing back <code>is_ring_hom</code> but remember that the reason we removed it is that it doesn't work very well; Lean 3 didn't like it.</p>",
        "id": 215457773,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604412684
    },
    {
        "content": "<blockquote>\n<p>I think it's scaling really nicely. It is linear in the number of interesting collections of bundled morphisms</p>\n</blockquote>\n<p>The problem is that it's bilinear (<code>O(N*M)</code>) not just <code>O(N)</code>; it's also linear in the number of interesting things you can apply morphisms to - sums over finsets, sums over finsupp, mapping over a matrix, ... The github comment linked to in <a href=\"#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/215428568\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/215428568</a> gives an example of this.</p>",
        "id": 215457969,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604412775
    },
    {
        "content": "<p>I'm definitely not planning on replacing <code>ring_hom</code> with unbundled structures. If you like your bundled homs, you can keep them :)</p>",
        "id": 215459410,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604413463
    },
    {
        "content": "<p>Another way we can phrase <code>is_ring_hom x</code> without referring to unbundled stuff is \"this type has a coherent definition of <code>coe : x -&gt; ring_hom</code>\".</p>",
        "id": 215459477,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1604413504
    },
    {
        "content": "<p>I am similarly opposed to using lots of unbundled hom classes. However, you can achieve the original goal without too much work: have an <code>is_zero_hom f</code> class, and instances <code>(f : A -&gt;*+ B) : is_zero_hom f</code> and so on. There is no quadratic growth of lemmas that way</p>",
        "id": 215459976,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604413714
    },
    {
        "content": "<p>I think that's what <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span>'s example above does?</p>",
        "id": 215460110,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604413783
    },
    {
        "content": "<p>I see anne suggesting a lot more than that</p>",
        "id": 215460148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604413801
    },
    {
        "content": "<p>Do you object to the contents of this message? <a href=\"#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/215444243\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/215444243</a></p>",
        "id": 215460259,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604413851
    },
    {
        "content": "<p>yes, I don't think this should be a generic <code>is_hom</code></p>",
        "id": 215460316,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604413885
    },
    {
        "content": "<p>this will make the typeclass problem a lot harder</p>",
        "id": 215460363,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604413909
    },
    {
        "content": "<p><code>is_hom</code> is only there as a trick to make <code>has_coe_to_fun</code> happy, it's not intended as API I think</p>",
        "id": 215460440,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604413930
    },
    {
        "content": "<p>it still interposes on the coe typeclass problem that we use everywhere</p>",
        "id": 215460503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604413961
    },
    {
        "content": "<p>I'm not sure what you mean by that - is your claim that the existance of <code>is_hom</code> will break typeclass resolution somewhere else? Slow it down? Or something else?</p>",
        "id": 215460616,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604414019
    },
    {
        "content": "<p>it will slow it down</p>",
        "id": 215460637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604414035
    },
    {
        "content": "<p>Is the issue that all <code>has_coe_to_fun</code> lookup will try looking for <code>is_hom</code> instances?</p>",
        "id": 215460725,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604414071
    },
    {
        "content": "<p>yes, as well as back chaining through <code>is_zero_hom</code>, <code>is_add_hom</code> and all the rest</p>",
        "id": 215460815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604414112
    },
    {
        "content": "<p>But typeclass resolution already does this for things like <code>has_add</code>, right? Why are we concerned about reusing the same mechanism?</p>",
        "id": 215460929,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604414162
    },
    {
        "content": "<p>At risk of constructing a straw man, this sounds a bit like \"I don't like the idea of <code>monoid A</code> because it will slow down type-class inference for <code>has_mul A</code> (by back-chaining through cancel_monoid, ring, ...)\"</p>",
        "id": 215461043,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604414215
    },
    {
        "content": "<p>This is an actual problem though, monoid -&gt; has_mul is not exempt</p>",
        "id": 215461123,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604414261
    },
    {
        "content": "<p>What I don't want is to open a whole new world of stuff for typeclass inference to explore</p>",
        "id": 215461234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604414292
    },
    {
        "content": "<p>so \"foundational\" typeclass instances like the <code>is_hom -&gt; has_coe_to_fun</code> one here that have no content on their own can singlehandedly double the size of the search</p>",
        "id": 215461389,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604414372
    },
    {
        "content": "<p>it would be nice if we had a performance monitor for typeclass searches, so we can quantify performance regressions</p>",
        "id": 215461690,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604414493
    },
    {
        "content": "<p>I'm pretty sure it's responsible for half of mathlib's compile time (the other half being VM evaluation)</p>",
        "id": 215461815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604414542
    },
    {
        "content": "<p>My suggestion is the same as the first two points of Anne's first post, without the \"except\"</p>",
        "id": 215461965,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604414622
    },
    {
        "content": "<p>with that approach you won't be searching for an <code>is_zero_hom</code> class unless you actually apply <code>matrix.is_zero_hom_map_zero</code></p>",
        "id": 215462105,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604414672
    },
    {
        "content": "<p>so it's not going to make things worse for an unrelated file</p>",
        "id": 215462170,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604414703
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/215461965\">said</a>:</p>\n<blockquote>\n<p>My suggestion is the same as the first two points of Anne's first post, without the \"except\"</p>\n</blockquote>\n<p>How would you define <code>is_add_hom</code> then?</p>",
        "id": 215462637,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604414930
    },
    {
        "content": "<p>only if it comes up for something else</p>",
        "id": 215462731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604414980
    },
    {
        "content": "<p>and there would not be an instance <code>[is_add_hom f] : is_zero_hom f</code></p>",
        "id": 215462833,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604415010
    },
    {
        "content": "<p>this keeps the typeclass problem very local</p>",
        "id": 215462863,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604415026
    },
    {
        "content": "<p>So now I need a <code>is_zero_hom</code> instance for <code>add_monoid_hom</code>, <code>ring_hom</code>, <code>algebra_hom</code>, <code>linear_map</code>?</p>",
        "id": 215462937,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604415060
    },
    {
        "content": "<p>yes</p>",
        "id": 215462952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604415064
    },
    {
        "content": "<p>So the work is now quadratic in the depth of the hom heirarchy</p>",
        "id": 215463013,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604415091
    },
    {
        "content": "<p>yes, it's quadratic in 5</p>",
        "id": 215463026,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604415098
    },
    {
        "content": "<p>Which I suppose is slightly better than the bilinear case we have now</p>",
        "id": 215463060,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604415112
    },
    {
        "content": "<p>however, individual typeclass problems are only linear in 5</p>",
        "id": 215463080,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604415122
    },
    {
        "content": "<p>honestly, if I could have direct instances A -&gt; B for every pair of classes A and B in the hierarchy that would be far better than the current exponential situation</p>",
        "id": 215463304,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604415216
    },
    {
        "content": "<p>Why is the current situation exponential anyway?</p>",
        "id": 215463337,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604415233
    },
    {
        "content": "<p>unfortunately the way lean 3 typeclass inference works adding those shortcut instances only raises the base of the exponential</p>",
        "id": 215463419,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604415255
    },
    {
        "content": "<p>If my heirarchy were a single branch of a tree, then surely a \"get typeclass from parent\" approach is also linear</p>",
        "id": 215463429,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604415261
    },
    {
        "content": "<p>it's not a tree, it's a dag, and lean basically searches all paths in it</p>",
        "id": 215463469,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604415285
    },
    {
        "content": "<p>so shortcut instances are incredibly bad for the algorithm</p>",
        "id": 215463501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604415303
    },
    {
        "content": "<p>Is this comparison accurate to find <code>has_coe_to_fun add_monoid_hom</code></p>\n<p>Before:</p>\n<ul>\n<li>Loop over <code>has_coe_to_fun</code> until we find a match:<ul>\n<li><code>zero_hom.has_coe_to_fun</code></li>\n<li><code>add_hom.has_coe_to_fun</code></li>\n<li><code>mul_hom.has_coe_to_fun</code></li>\n<li><code>add_monoid_hom.has_coe_to_fun</code></li>\n</ul>\n</li>\n</ul>\n<p>With the post I link to above:</p>\n<ul>\n<li>Loop over <code>has_coe_to_fun</code> until we find a match:<ul>\n<li><code>is_hom.has_coe_to_fun</code>, loop over <code>is_hom</code> until we find a match<ul>\n<li><code>is_mul_hom.is_hom</code>, loop over <code>is_mul_hom</code> until we find a match<ul>\n<li><code>is_monoid_hom.is_mul_hom</code><br>\n     * <code>monoid_hom.is_monoid_hom</code></li>\n</ul>\n</li>\n<li><code>is_zero_hom.is_hom</code>, loop over <code>is_zero_hom</code> until we find a match<ul>\n<li><code>is_add_monoid_hom.is_zero_hom</code><br>\n     * <code>add_monoid_hom.is_add_monoid_hom</code></li>\n</ul>\n</li>\n<li><code>is_add_hom.is_hom</code>, loop over <code>is_add_hom</code> until we find a match<ul>\n<li><code>is_add_monoid_hom.is_add_hom</code><br>\n     * <code>add_monoid_hom.is_add_monoid_hom</code>(I assume inference then checks for consistency?)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>",
        "id": 215463565,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604415335
    },
    {
        "content": "<p>Ignoring diamonds, it looks to me like the overhead is linear in the depth of the tree, which doesn't seem too bad</p>",
        "id": 215463747,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604415403
    },
    {
        "content": "<p>is <code>is_hom</code> just replacing all <code>has_coe_to_fun</code> instances then?</p>",
        "id": 215463852,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604415463
    },
    {
        "content": "<p>Yes, for the bundled morphisms. Things like <code>finsupp</code> and <code>dfinsupp</code> will keep using <code>has_coe_to_fun</code> directly of course</p>",
        "id": 215463943,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604415489
    },
    {
        "content": "<p>you have <code>is_add_monoid_hom.is_zero_hom</code>, does that mean there is also <code>is_add_monoid_hom</code>?</p>",
        "id": 215464104,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604415579
    },
    {
        "content": "<p>so <code>add_monoid_hom.is_add_monoid_hom</code> is getting tested twice</p>",
        "id": 215464214,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604415612
    },
    {
        "content": "<p>Yes, because there is a diamond</p>",
        "id": 215464273,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604415637
    },
    {
        "content": "<p>and everything under that diamond will be doubled</p>",
        "id": 215464308,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604415661
    },
    {
        "content": "<p>Indeed</p>",
        "id": 215464319,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604415665
    },
    {
        "content": "<p>it sounds like there is still a lurking exponential in this plan then</p>",
        "id": 215464346,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604415682
    },
    {
        "content": "<p>Does lean keep looking for a match in other branches even after it finds one?</p>",
        "id": 215464367,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604415693
    },
    {
        "content": "<p>no, but a success can come anywhere in the tree, and unsuccessful searches have to run the gamut</p>",
        "id": 215464417,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604415721
    },
    {
        "content": "<p>unsuccessful searches include unsuspecting files that have nothing to do with homs</p>",
        "id": 215464496,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604415745
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/215461815\">said</a>:</p>\n<blockquote>\n<p>I'm pretty sure [typeclass searches are] responsible for half of mathlib's compile time (the other half being VM evaluation)</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib/pull/4832#discussion_r515558103\">interesting you should say that...</a></p>",
        "id": 215464522,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604415756
    },
    {
        "content": "<p>Is the search breadth-first or depth-first?</p>",
        "id": 215464621,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604415797
    },
    {
        "content": "<p>depth first</p>",
        "id": 215464643,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604415811
    },
    {
        "content": "<p>it really is objectively not a very good algorithm</p>",
        "id": 215464701,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604415841
    },
    {
        "content": "<p>Is it objectively hard to improve it for <code>lean-3.24.0</code>?</p>",
        "id": 215464798,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1604415874
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"230999\">Daniel Selsam</span> has a paper on the new typeclass algorithm in lean 4</p>",
        "id": 215464818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604415887
    },
    {
        "content": "<p>Can we backport it?</p>",
        "id": 215464852,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1604415903
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/215464798\">said</a>:</p>\n<blockquote>\n<p>Is it objectively hard to improve it for <code>lean-3.24.0</code>?</p>\n</blockquote>\n<p>It's possible</p>",
        "id": 215464902,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604415923
    },
    {
        "content": "<p>If lean 4 fixes things, would it be better to use the design with less human overhead, and hope that the performance issue goes away eventually?</p>",
        "id": 215464933,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604415936
    },
    {
        "content": "<p>it would require some work and people will probably consider it wasted in light of lean 4</p>",
        "id": 215464963,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604415948
    },
    {
        "content": "<p>it's difficult to ignore exponential factors even \"temporarily\"</p>",
        "id": 215465107,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604416010
    },
    {
        "content": "<p>I have no idea how hard it is to do something like that... If it is 1 week of work, it might be worth it. We could consider it part of the port to Lean 4...</p>",
        "id": 215465129,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1604416019
    },
    {
        "content": "<p>How easy is it to check whether the effect is actually exponential?</p>",
        "id": 215465235,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604416071
    },
    {
        "content": "<p>also we still don't even have a release date for lean 4 and many things are still up in the air so I'm not a fan of arguments for an uncertain future</p>",
        "id": 215465243,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604416073
    },
    {
        "content": "<p>There are simple typeclass problems you can set up that have literal exponential search length</p>",
        "id": 215465304,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604416093
    },
    {
        "content": "<p>For sure - my question is how we prove that the change suggested above is one of them</p>",
        "id": 215465342,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604416114
    },
    {
        "content": "<p>For a fixed size of course it's not exponential, it's just slightly bigger</p>",
        "id": 215465455,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604416165
    },
    {
        "content": "<p>but it scales worse and mathlib has real scaling issues in this area</p>",
        "id": 215465514,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604416192
    },
    {
        "content": "<p>The danger of exponential searches is significantly reduced since we have caching now.</p>",
        "id": 215465645,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1604416232
    },
    {
        "content": "<p>Both Lean 3's and Lean 4's type class algorithms are Turing-complete, I don't think either of them provide good performance guarantees.</p>",
        "id": 215465723,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1604416271
    },
    {
        "content": "<p>As it turns out there are lots of diamonds in the heirarchy of morphisms: <a href=\"/user_uploads/3121/IEnLI5rauyMvvl0_a3susEFO/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/IEnLI5rauyMvvl0_a3susEFO/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/IEnLI5rauyMvvl0_a3susEFO/image.png\"></a></div>",
        "id": 215467815,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604417170
    },
    {
        "content": "<p>/me is not surprised <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 215467853,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1604417188
    },
    {
        "content": "<p>Where gray arrows are the ones that aren't actual <code>extends</code> clauses</p>",
        "id": 215467885,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604417204
    },
    {
        "content": "<p><span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span> The graph suggests that we are missing arrows from <code>alg_hom</code> to <code>add_equiv</code> and from <code>ring_hom</code> to <code>equiv</code>.</p>",
        "id": 215468103,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1604417295
    },
    {
        "content": "<p>Perhaps clearer with the equivs separated:</p>\n<p><a href=\"/user_uploads/3121/7Z3Syav1HfQ5w_dCmVKwUDTf/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/7Z3Syav1HfQ5w_dCmVKwUDTf/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/7Z3Syav1HfQ5w_dCmVKwUDTf/image.png\"></a></div>",
        "id": 215468465,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604417457
    },
    {
        "content": "<p>Yes, the reason this is a problem is because there are <em>in fact</em> many diamonds in most typeclass problems, it's not a theoretical concern</p>",
        "id": 215468567,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604417508
    },
    {
        "content": "<p>Note also that N is 8 not 5 for <code>zero_hom</code></p>",
        "id": 215468808,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604417597
    },
    {
        "content": "<p>12 counting diamonds</p>",
        "id": 215469233,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604417776
    },
    {
        "content": "<p>For type class resolution, shouldn't only the number of edges matter?</p>",
        "id": 215469425,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604417863
    },
    {
        "content": "<p>Ah, which is 13</p>",
        "id": 215469530,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604417896
    },
    {
        "content": "<p>I'm counting nodes</p>",
        "id": 215469541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604417900
    },
    {
        "content": "<p>Shouldn't caching prevent a node being visited twice?</p>",
        "id": 215469576,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604417924
    },
    {
        "content": "<p>possibly; there are situations where it won't because of undetermined metavariables I think</p>",
        "id": 215469648,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604417963
    },
    {
        "content": "<p>not to mention if you have a sequence of typeclasses like <code>foo n -&gt; foo (n + 1)</code></p>",
        "id": 215469712,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604417992
    },
    {
        "content": "<p>I forgot about gabriel's (heroic!) work to add caching, which solves many of the problems in this area, but because of the free form nature of typeclasses it's hard to get good guarantees</p>",
        "id": 215469908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604418076
    },
    {
        "content": "<p>Are the discrimination trees in Lean 4 going to solve this issue? If we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_group_hom</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>should this just work in Lean 4? Because if I understand it correctly, <code>simp</code> will not just look at the head symbol, but also at <code>*</code>, a bit further down the tree.</p>",
        "id": 228745545,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614852410
    },
    {
        "content": "<p>Even if it did, presumably we'll still be stuck with function composition?</p>",
        "id": 228745772,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614852506
    },
    {
        "content": "<p>(<a href=\"https://leanprover-community.github.io/mathlib_docs/notes.html#no%20instance%20on%20morphisms\">https://leanprover-community.github.io/mathlib_docs/notes.html#no%20instance%20on%20morphisms</a>)</p>",
        "id": 228745932,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614852596
    },
    {
        "content": "<p>I had a bit of time last week to test this idea for real, but didn't get around to writing out a report. Because the topic came up in a <a href=\"#narrow/stream/270676-lean4/topic/Notation.20in.20structures\">lean4 thread</a>, here's my observations:</p>",
        "id": 230332072,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1615809254
    },
    {
        "content": "<ul>\n<li>Overall, using the <a href=\"https://github.com/leanprover-community/mathlib/compare/hom-classes#diff-918830029f29ce7761f69f9336d49d7397a07b37cfe8b2aaa174326749e54c71R72\">hom typeclasses</a> works quite well with tactics, you can just write <code>simp [map_mul f]</code> without worrying whether <code>f</code> is a <code>mul_hom</code>, <code>monoid_hom</code>, <code>monoid_with_zero_hom</code>, <code>ring_hom</code>, ...</li>\n<li>The <code>to_fun</code> class caused a few weird timeouts in <code>simp</code>, until I disabled the simp lemma <a href=\"#narrow/stream/113488-general/topic/Why.20is.20.60coe_fn_coe_base.60.20a.20.60simp.60.20lemma.3F\"><code>coe_fn_coe_base</code></a></li>\n<li><code>has_coe_to_fun</code> causes the expected type to be elaborated a bit too late, so you have to <a href=\"https://github.com/leanprover-community/mathlib/compare/hom-classes#diff-e355ee55b3ed90b500def3834cca1cee3c92474a5b00d9e365cb26410fccb13c\">insert type hints</a> when there is reduction going on in the type. I expect this will be better in Lean 4 because it can delay subgoals (is this correct?)</li>\n<li>I wanted to time whether <code>simp</code> gets faster because it doesn't go through all <code>foo_hom.map_bar</code> lemmas for every <code>coe_fn</code>, but didn't have the time yet</li>\n<li>There is still a bit of boilerplate because you have to define the <code>foo_hom</code> structure and the <code>foo_hom_class</code> with the appropriate instances, but this is only linear in the number of <code>foo</code>s and should be automatable.</li>\n</ul>",
        "id": 230333223,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1615809869
    },
    {
        "content": "<p>This pattern of having <code>structure foo</code> and <code>class foo_class</code> feels like it's essentially building the virtual \"method\" dispatch of C++, where <code>foo_class</code> is sort of like the vtable.</p>",
        "id": 230333654,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615810128
    },
    {
        "content": "<p>I would say it's more like the <code>class Foo</code> + <code>interface IFoo</code> pattern in Java, but yes, basically that :)</p>",
        "id": 230333782,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1615810192
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> Thanks a lot for looking into this!</p>",
        "id": 230335312,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615810997
    },
    {
        "content": "<p>I revived my experiment and opened <a href=\"https://github.com/leanprover-community/mathlib/issues/9888\">#9888</a>. It still needs some cleaning up, but the basic idea seems to work well.</p>",
        "id": 258736093,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1634919984
    },
    {
        "content": "<p>This is very interesting to see -- I hadn't realized morphisms have the same sort of design considerations as graphs! In an <a href=\"https://github.com/leanprover-community/mathlib/blob/simple_graphs/src/combinatorics/simple_graph.lean\">old branch</a> for simple graphs I came up with the same design.  I didn't think I could justify the complexity quite yet (nor did I think about it as the class+interface pattern), so we went with the more straightforward definition first, though I do plan to revisit this once we have more types of combinatorial objects.</p>\n<p>These are the definitions in that branch:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">simple_graphs</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">V</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">symmetric</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">irreflexive</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">from_rel</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">rel</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">rel</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">irr</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">rel</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graphs</span> <span class=\"o\">(</span><span class=\"n\">from_rel</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">from_rel.rel</span><span class=\"o\">,</span>\n  <span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"n\">from_rel.sym</span><span class=\"o\">,</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"n\">from_rel.irr</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>To talk about a particular generic graph you could do <code>{α : Type u} [simple_graphs α] (G : α)</code>.  (I think I like the <code>simple_graph_class</code> and <code>simple_graph</code> naming convention better.)  One downside is it seems this design pattern loses out on a lot of dot notation...</p>",
        "id": 258738465,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1634921068
    },
    {
        "content": "<p>Do you think that we need <code>[*_hom_class]</code>? Why not just <code>[map_zero_class]</code> <code>[map_add_class]</code> etc?</p>",
        "id": 258738839,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1634921219
    },
    {
        "content": "<p>An attribute can create a <code>fun_like</code> instance and <code>[map*_class]</code> instances.</p>",
        "id": 258739579,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1634921536
    },
    {
        "content": "<p>The drawback of only having <code>map_{one,mul,zero,add}_class</code>es is that terms can grow exponentially big. This is also one of the reasons <code>monoid</code> bundles everything into one class instead of something like <code>[has_one] [has_mul] [mul_assoc] [mul_one]</code>.</p>",
        "id": 258740169,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1634921774
    },
    {
        "content": "<p><a href=\"https://www.ralfj.de/blog/2019/05/15/typeclasses-exponential-blowup.html\">https://www.ralfj.de/blog/2019/05/15/typeclasses-exponential-blowup.html</a></p>",
        "id": 258740363,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1634921866
    },
    {
        "content": "<p>In this example <code>group</code> takes <code>monoid</code> as a parameter.</p>",
        "id": 258741528,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1634922316
    },
    {
        "content": "<p>Does the same happen with <code>[map_*_class]</code>? Why?</p>",
        "id": 258743008,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1634922946
    },
    {
        "content": "<p>OTOH, with <code>*_hom_class</code>, in order to apply <code>map_add</code>, Lean has to go up in the TC hierarchy to an appropriate class, then insert <code>*_hom_class.to_*_hom_class.....map_add</code> in the proof term instead of something like <code>linear_map.map_add_class</code>.</p>",
        "id": 258743397,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1634923100
    },
    {
        "content": "<p>I agree, I think we might be able to get away with separate classes for each <code>map</code> method after all</p>",
        "id": 258764300,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1634932118
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/9888\">#9888</a> builds (see commit <a href=\"https://github.com/leanprover-community/mathlib/commit/4c51e75fe10fd6e74fb3ceb4aa0f5c5ecbbe3412\"><code>4c51e75fe10fd6e74fb3ceb4aa0f5c5ecbbe3412</code></a>), so I went ahead and cleaned up the commits; hopefully that didn't break anything.</p>",
        "id": 261149164,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1636645348
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/258743008\">said</a>:</p>\n<blockquote>\n<p>Does the same happen with <code>[map_*_class]</code>? Why?</p>\n</blockquote>\n<p>Good question! Perhaps not, since there won't be a class depending on the fields of all previous classes, in the way <code>comm_group</code> depends on everything in <code>group</code>. I'll see if I can make a good comparison.</p>",
        "id": 261149653,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1636645621
    },
    {
        "content": "<p>Still, by completely separating into <code>map_*_class</code>es, we turn this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">hom_eval₂</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring_hom_class</span> <span class=\"n\">G</span> <span class=\"n\">S</span> <span class=\"n\">T</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">p.eval₂</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">p.eval₂</span> <span class=\"o\">(</span><span class=\"n\">g.comp</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>into this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">hom_eval₂</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">map_add_class</span> <span class=\"n\">G</span> <span class=\"n\">S</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">map_zero_class</span> <span class=\"n\">G</span> <span class=\"n\">S</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">map_mul_class</span> <span class=\"n\">G</span> <span class=\"n\">S</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">map_one_class</span> <span class=\"n\">G</span> <span class=\"n\">S</span> <span class=\"n\">T</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">p.eval₂</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">p.eval₂</span> <span class=\"o\">(</span><span class=\"n\">g.comp</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>which I wouldn't like to do...</p>",
        "id": 261150317,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1636645965
    },
    {
        "content": "<p>Updated <a href=\"https://github.com/leanprover-community/mathlib/issues/9888\">#9888</a> to resolve a merge conflict.</p>",
        "id": 262610804,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1637771373
    },
    {
        "content": "<p>I also tried to use unbundled classes see <a href=\"https://github.com/leanprover-community/mathlib/commit/7799c4922f53e0993b70df8a140a8c175c0f5bc3\">commit <code>7799c4922f</code></a>, but I'm getting some errors I don't understand:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">monoid_with_zero_hom.comp</span> <span class=\"o\">[</span><span class=\"n\">mul_zero_one_class</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_zero_one_class</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_zero_one_class</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">hnp</span> <span class=\"o\">:</span> <span class=\"n\">monoid_with_zero_hom</span> <span class=\"n\">N</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hmn</span> <span class=\"o\">:</span> <span class=\"n\">monoid_with_zero_hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">monoid_with_zero_hom</span> <span class=\"n\">M</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">hnp</span> <span class=\"bp\">∘</span> <span class=\"n\">hmn</span><span class=\"o\">,</span> <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">function.comp_app</span><span class=\"o\">,</span> <span class=\"n\">map_mul</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">▶ 621:25-621:26: error:</span>\n<span class=\"cm\">invalid rewrite tactic, failed to synthesize type class instance for</span>\n<span class=\"cm\">  mul_hom_class (monoid_with_zero_hom M N) M N</span>\n<span class=\"cm\">state:</span>\n<span class=\"cm\">M : Type u_1,</span>\n<span class=\"cm\">N : Type u_2,</span>\n<span class=\"cm\">P : Type u_3,</span>\n<span class=\"cm\">_inst_1 : mul_zero_one_class M,</span>\n<span class=\"cm\">_inst_2 : mul_zero_one_class N,</span>\n<span class=\"cm\">_inst_3 : mul_zero_one_class P,</span>\n<span class=\"cm\">hnp : monoid_with_zero_hom N P,</span>\n<span class=\"cm\">hmn : monoid_with_zero_hom M N,</span>\n<span class=\"cm\">x y : M</span>\n<span class=\"cm\">⊢ ⇑hnp (⇑hmn (x * y)) = (⇑hnp ∘ ⇑hmn) x * (⇑hnp ∘ ⇑hmn) y</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 262611021,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1637771466
    },
    {
        "content": "<p>What does <code>set_option pp.implicit true</code> show as the message? And what does <code>#check @the_instance_you_expect_it_to_find</code> give?</p>",
        "id": 262611279,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637771585
    },
    {
        "content": "<p><code>#print monoid_with_zero_hom.mul_hom_class</code> is an instance, as expected, and it can be found when explicitly calling <code>apply_instance</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Composition of `monoid_with_zero_hom`s as a `monoid_with_zero_hom`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">monoid_with_zero_hom.comp</span> <span class=\"o\">[</span><span class=\"n\">mul_zero_one_class</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_zero_one_class</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_zero_one_class</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">hnp</span> <span class=\"o\">:</span> <span class=\"n\">monoid_with_zero_hom</span> <span class=\"n\">N</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hmn</span> <span class=\"o\">:</span> <span class=\"n\">monoid_with_zero_hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">monoid_with_zero_hom</span> <span class=\"n\">M</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">hnp</span> <span class=\"bp\">∘</span> <span class=\"n\">hmn</span><span class=\"o\">,</span> <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">function.comp_app</span><span class=\"o\">,</span> <span class=\"bp\">@@</span><span class=\"n\">map_mul</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"n\">_</span><span class=\"o\">)],</span>\n    <span class=\"n\">swap</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">apply_instance</span> <span class=\"o\">},</span>\n    <span class=\"n\">simp</span>\n  <span class=\"kd\">end</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 262611470,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1637771664
    },
    {
        "content": "<p><code>pp.implicit</code> gives a totally normal instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">rewrite</span> <span class=\"n\">tactic</span><span class=\"o\">,</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n  <span class=\"bp\">@</span><span class=\"n\">mul_hom_class</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">monoid_with_zero_hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">_inst_1</span> <span class=\"n\">_inst_2</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">N</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mul_one_class.to_has_mul</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mul_zero_one_class.to_mul_one_class</span> <span class=\"n\">M</span> <span class=\"n\">_inst_1</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mul_zero_class.to_has_mul</span> <span class=\"n\">N</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mul_zero_one_class.to_mul_zero_class</span> <span class=\"n\">N</span> <span class=\"n\">_inst_2</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">monoid_with_zero_hom.fun_like</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">_inst_1</span> <span class=\"n\">_inst_2</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 262611581,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1637771717
    },
    {
        "content": "<p>Also:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">mul_hom_class</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">monoid_with_zero_hom</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">_inst_1</span> <span class=\"n\">_inst_2</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">N</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mul_one_class.to_has_mul</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mul_zero_one_class.to_mul_one_class</span> <span class=\"n\">M</span> <span class=\"n\">_inst_1</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mul_zero_class.to_has_mul</span> <span class=\"n\">N</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mul_zero_one_class.to_mul_zero_class</span> <span class=\"n\">N</span> <span class=\"n\">_inst_2</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">monoid_with_zero_hom.fun_like</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">_inst_1</span> <span class=\"n\">_inst_2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"c1\">-- works</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">function.comp_app</span><span class=\"o\">,</span> <span class=\"n\">map_mul</span><span class=\"o\">],</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 262611733,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1637771777
    },
    {
        "content": "<p>Although replacing <code>have</code> with <code>haveI</code> will make it work amazingly enough!</p>",
        "id": 262611824,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1637771817
    },
    {
        "content": "<p>In any case, as long as we don't have any way to abbreviate <code>[fun_like F A B] [mul_hom_class F A B] [one_hom_class F A B] [add_hom_class F A B] [zero_hom_class F A B]</code> into something as concise as <code>[ring_hom_class F A B]</code>, I don't think unbundling is the way to go.</p>",
        "id": 262612650,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1637772164
    },
    {
        "content": "<p>(I'd be okay with unbundling the <code>extends has_coe_to_fun</code> or <code>extends fun_like</code> parts into a parameter - that would separate data from proofs.)</p>",
        "id": 262612786,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1637772237
    },
    {
        "content": "<p>In a related note, I have been running into issues where <code>ideal.quotient</code>, <code>submodule.quotient</code> and <code>subgroup.quotient</code> don't behave identically although they have equivalent definitions. What if we made a <code>subgroup_class</code> extending <code>set_like</code> and defined <code>quotient</code> in terms of that...</p>",
        "id": 262613922,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1637772717
    },
    {
        "content": "<p>Here's where we're at now:</p>\n<p><a href=\"/user_uploads/3121/Cz9XGib5V_Tp4jzUWSJaHzuj/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/Cz9XGib5V_Tp4jzUWSJaHzuj/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/Cz9XGib5V_Tp4jzUWSJaHzuj/image.png\"></a></div>",
        "id": 289620897,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1657818732
    },
    {
        "content": "<p>can you upload a higher quality verison of that?</p>",
        "id": 289620974,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1657818773
    },
    {
        "content": "<p>It's in the center of <a href=\"https://gist.githubusercontent.com/eric-wieser/479c49a306430d9d8a896f105ef32178/raw/32f67356bac21dda2c9a80a99d6cef602b643d96/out-small.svg\">https://gist.githubusercontent.com/eric-wieser/479c49a306430d9d8a896f105ef32178/raw/32f67356bac21dda2c9a80a99d6cef602b643d96/out-small.svg</a></p>",
        "id": 289621071,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1657818818
    },
    {
        "content": "<p>weird that some of them don't extend <code>fun_like</code>...</p>",
        "id": 289621213,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1657818879
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/order_hom_class\">docs#order_hom_class</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/continuous_map_class\">docs#continuous_map_class</a></p>",
        "id": 289621244,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1657818895
    },
    {
        "content": "<p>That's a data parsing error because <code>order_hom_class</code> is an abbreviation</p>",
        "id": 289621256,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1657818902
    },
    {
        "content": "<p>continuous_map_class does too, but it seems in a new-style way?</p>",
        "id": 289621352,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1657818949
    },
    {
        "content": "<p>That one's a mystery to me</p>",
        "id": 289621565,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1657819032
    },
    {
        "content": "<p>Feel free to try and adjust <a href=\"https://gist.github.com/eric-wieser/479c49a306430d9d8a896f105ef32178\">the script</a></p>",
        "id": 289621600,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1657819049
    },
    {
        "content": "<p>What about the arrows that terminate into space here?<br>\n<a href=\"/user_uploads/3121/1ul2Y0SJmjwH6nybdeX1VPAX/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/1ul2Y0SJmjwH6nybdeX1VPAX/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/1ul2Y0SJmjwH6nybdeX1VPAX/image.png\"></a></div>",
        "id": 289621799,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1657819145
    },
    {
        "content": "<p>Click on them</p>",
        "id": 289621987,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1657819222
    },
    {
        "content": "<p>I see, so the TC \"values\" are the arrow ends, the boxes are the defs of the class</p>",
        "id": 289622053,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1657819267
    }
]
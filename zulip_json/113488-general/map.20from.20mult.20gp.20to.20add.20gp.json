[
    {
        "content": "<p>OK so it's finally happened. Kummer theory relates the additive group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>H</mi><mn>1</mn></msup><mo stretchy=\"false\">(</mo><mi>K</mi><mo separator=\"true\">,</mo><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mi>n</mi><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H^1(K,\\Z/n\\Z)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathbb\">Z</span><span class=\"mclose\">)</span></span></span></span> to the the multiplicative group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>K</mi><mo>×</mo></msup><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><msup><mi>K</mi><mo>×</mo></msup><msup><mo stretchy=\"false\">)</mo><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">K^\\times/(K^\\times)^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> is a number field containing all the $$n$$th roots of unity, Selmer group calculations give you maps <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo stretchy=\"false\">(</mo><mi>K</mi><mo stretchy=\"false\">)</mo><mo>→</mo><msup><mi>K</mi><mo>×</mo></msup><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><msup><mi>K</mi><mo>×</mo></msup><msup><mo stretchy=\"false\">)</mo><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">E(K)\\to K^\\times/(K^\\times)^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> in the proof of the Mordell-Weil theorem with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo stretchy=\"false\">(</mo><mi>K</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">E(K)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">)</span></span></span></span> an additive group, and I think that for my gang of PhD students at Imperial working on cool things they are going to need some kind of solution to the issue that right now mathlib has two ugly ways to define a group homomorphism from an additive group to a multiplicative group (<code>G -&gt;* multiplicative A</code> and <code>additive G -&gt;+ A</code>) and no non-ugly way. I've been putting this discussion off for years (e.g. with perfectoids we used multiplicative valuations, Maria has been using <code>multiplicative \\Z</code> here there and everywhere) but I don't think can go on forever. The idea of splitting up the concept of an additive and multiplicative monoid is brilliant because it makes things like rings fit very nicely into the typeclass system, but I think that for the sake of my students' sanity we're going to have to figure out a way of doing this.</p>\n<p>Two options spring to mind:</p>\n<p>1) make a new typeclass <code>mul_to_add_monoid_hom G A</code> and then either duplicate a ton of stuff or write a tactic which does it for us<br>\n2) Continue to run away from the problem and write horrible-looking code with <code>multiplicative (zmod n)</code> everywhere.</p>\n<p>Neither looks fun but this is now a real problem. I think the option \"define the group law on an elliptic curve to be multiplication\" has to be ruled out because we'd be a laughing stock. Same comment goes for group law on a cohomology group, and definition of an abelian category. Maybe morally what's going on is that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>H</mi><mi>n</mi></msup><mo stretchy=\"false\">(</mo><mi>G</mi><mi>a</mi><mi>l</mi><mo stretchy=\"false\">(</mo><mi>L</mi><mi mathvariant=\"normal\">/</mi><mi>K</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><msup><mi>L</mi><mo>×</mo></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H^n(Gal(L/K),L^\\times)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">L</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> should somehow have multiplication as the group law (because that's the group law on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>L</mi><mo>×</mo></msup></mrow><annotation encoding=\"application/x-tex\">L^\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span></span></span></span>) but history won't let us do that.</p>",
        "id": 271703529,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644691486
    },
    {
        "content": "<p>Do we care about being the laughing stock?</p>",
        "id": 271703631,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644691676
    },
    {
        "content": "<p>Yes</p>",
        "id": 271703646,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644691682
    },
    {
        "content": "<p>because then it's harder to learn. We need to stick to usual mathematical notation.</p>",
        "id": 271703685,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644691718
    },
    {
        "content": "<p>I guess one thing that could be done is to simply define the map as a function, and then carry around the axiom <code>f (a * b) = f a + f b</code> and rewrite as necessary. But I'm sure this will get old. We will want to talk about the short exact sequence <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>→</mo><msub><mi>μ</mi><mi>n</mi></msub><mo stretchy=\"false\">(</mo><mi>K</mi><mo stretchy=\"false\">)</mo><mo>→</mo><msup><mi>K</mi><mo>×</mo></msup><mo>→</mo><msup><mi>K</mi><mo>×</mo></msup><mo>→</mo><msup><mi>H</mi><mn>1</mn></msup><mo stretchy=\"false\">(</mo><mi>G</mi><mo separator=\"true\">,</mo><msub><mi>μ</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo><mo>→</mo><msup><mi>H</mi><mn>1</mn></msup><mo stretchy=\"false\">(</mo><mi>G</mi><mo separator=\"true\">,</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">[</mo><mi>n</mi><mo stretchy=\"false\">]</mo><mo>→</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">1\\to\\mu_n(K)\\to K^\\times\\to K^\\times\\to H^1(G,\\mu_n)\\to H^1(G,K^\\times)[n] \\to 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> for example, and the group law magically changes between multiplication and addition in the middle. Hmm, for this one we surely have to go with <code>additive</code>.</p>",
        "id": 271703774,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644691883
    },
    {
        "content": "<p>This came up in the Galois thing, too. We wanted to filter the automorphisms of a cyclo extension through the roots of unity group, and we'd have to mess around with this</p>",
        "id": 271704277,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1644692484
    },
    {
        "content": "<p>Right now <span class=\"user-mention\" data-user-id=\"464700\">@David Ang</span> is just putting <code>multiplicative</code> everywhere.</p>",
        "id": 271704723,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644692940
    },
    {
        "content": "<p>Are you sure <code>multiplicative</code> is the approach you want to take, as opposed to <code>additive</code>? These <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>K</mi><mo>×</mo></msup></mrow><annotation encoding=\"application/x-tex\">K^\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span></span></span></span> are global sections on an \\'etale sheaf of abelian groups, and we usually write those additively...</p>",
        "id": 271710519,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644701237
    },
    {
        "content": "<p>(Of course, this is the global sections of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">G</mi><mi>m</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{G}_m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> (THE multiplicative group!), so maybe an exception is in order.)</p>",
        "id": 271710760,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644701642
    },
    {
        "content": "<p>In Lean4, is it possible to create a class called, say, <code>CommGroup</code> where instances can also include notations for the operation and the unit?</p>",
        "id": 271711648,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644703074
    },
    {
        "content": "<p>Don't forget notation for the inverse and the division and the nat-power and the int-power and the ...</p>",
        "id": 271712417,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644704104
    },
    {
        "content": "<p>Sure. Let's just think about monoids for now.</p>",
        "id": 271712474,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644704165
    },
    {
        "content": "<p>Does that mean you expect lemma statements to not visually match where you'll use them?</p>",
        "id": 271712509,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644704268
    },
    {
        "content": "<p>Maybe. Is that so awful? I would prefer to have one lemma called <code>op_assoc</code> or something that can be applied to both addition in Z and multiplication in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>μ</mi><mn>37</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\mu_{37}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">37</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></p>",
        "id": 271712691,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644704507
    },
    {
        "content": "<p>Can do we something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">hidden</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_unit</span> <span class=\"o\">(</span><span class=\"n\">tag</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">unit</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_op</span> <span class=\"o\">(</span><span class=\"n\">tag</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">has_unit.to_has_one</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_unit</span> <span class=\"bp\">`</span><span class=\"n\">additive</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_one</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">has_unit.unit</span> <span class=\"bp\">`</span><span class=\"n\">additive</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">has_op.to_has_mul</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_op</span> <span class=\"bp\">`</span><span class=\"n\">additive</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_mul</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">has_op.op</span> <span class=\"bp\">`</span><span class=\"n\">additive</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">monoid</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_op</span> <span class=\"n\">n</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">has_unit</span> <span class=\"n\">n</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">unit_op</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">op</span> <span class=\"n\">unit</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">op_unit</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">op</span> <span class=\"n\">x</span> <span class=\"n\">unit</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">op_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">op</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">))</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">monoid</span> <span class=\"o\">(</span><span class=\"n\">unit_op</span> <span class=\"n\">op_unit</span> <span class=\"n\">op_assoc</span><span class=\"o\">)</span>\n\n<span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">mul_monoid</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">monoid</span> <span class=\"o\">(</span><span class=\"n\">name.mk_string</span> <span class=\"s2\">\"multiplicative\"</span> <span class=\"n\">name.anonymous</span><span class=\"o\">)</span>\n<span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">add_monoid</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">monoid</span> <span class=\"o\">(</span><span class=\"n\">name.mk_string</span> <span class=\"s2\">\"additive\"</span> <span class=\"n\">name.anonymous</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">dunfold</span> <span class=\"n\">has_mul.mul</span> <span class=\"n\">has_one.one</span><span class=\"o\">,</span>  <span class=\"c1\">-- TODO</span>\n  <span class=\"n\">rw</span> <span class=\"n\">op_unit</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">hidden</span>\n</code></pre></div>",
        "id": 271712773,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644704589
    },
    {
        "content": "<p>That is, store a name for the notation as an argument in the typeclass</p>",
        "id": 271712784,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644704612
    },
    {
        "content": "<p>Dumb stuff, but are you not getting a name conflict with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/unit\">docs#unit</a>?</p>",
        "id": 271712887,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644704737
    },
    {
        "content": "<p>But this still would mean that additive monoids and multiplicative monoids are different classes because the name parameter would be different</p>",
        "id": 271712893,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644704753
    },
    {
        "content": "<p>How does that matter? You can be \"name-polymorphic\".</p>",
        "id": 271712953,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644704802
    },
    {
        "content": "<p>Yeah okay</p>",
        "id": 271712982,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644704876
    },
    {
        "content": "<p>We'd need some special support in <code>rw</code> to avoid the line marked <code>TODO</code></p>",
        "id": 271713025,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644704892
    },
    {
        "content": "<p>Or we'd need to entirely remove <code>has_zero</code> and <code>has_one</code>, and have them just be notation for <code>has_unit _</code></p>",
        "id": 271713034,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644704916
    },
    {
        "content": "<p>This sounds like a very bad intersection with the <code>OfNat</code> conundrum.</p>",
        "id": 271713114,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644705028
    },
    {
        "content": "<p>What I would really like is to be able to pass the <em>notation</em> itself as a parameter</p>",
        "id": 271713115,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644705031
    },
    {
        "content": "<p>I.e. to be able to write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">b</span>\n</code></pre></div>",
        "id": 271713196,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644705131
    },
    {
        "content": "<p>Yeah, but that scales really badly to <code>[group (*) 1 (has_inv.inv) (/) (^) (^) R]</code> and <code>ring</code> is even worse</p>",
        "id": 271713208,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644705171
    },
    {
        "content": "<p>I would vouch against that. Soon, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/boolean_algebra\">docs#boolean_algebra</a> will have around 10 notations.</p>",
        "id": 271713218,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644705185
    },
    {
        "content": "<p>You can have default values for parameters btw</p>",
        "id": 271713231,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644705205
    },
    {
        "content": "<p>Writing <code>add_group</code> as a shorthand for <code>group (+) 0 has_neg.neg</code> sounds like a better idea already.</p>",
        "id": 271713285,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644705265
    },
    {
        "content": "<p>Yeah, but then you have to write <code>[has_add G] [has_zero G] [has_neg G] [add_group G]</code></p>",
        "id": 271713315,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644705323
    },
    {
        "content": "<p>Why?</p>",
        "id": 271713325,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644705342
    },
    {
        "content": "<p>Because <code>(+)</code> doesn't exist until you have the <code>has_add</code> instance lying around</p>",
        "id": 271713380,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644705370
    },
    {
        "content": "<p>because the notation typeclasses are typeclasses... <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 271713383,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644705378
    },
    {
        "content": "<p>In Lean4 you could presumably have a macro that expands <code>add_group M</code> to <code>group (+) ...</code></p>",
        "id": 271713392,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644705394
    },
    {
        "content": "<p>It would need to expand it to include the <code>[has_add G]</code> too</p>",
        "id": 271713406,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644705417
    },
    {
        "content": "<p>Again, that's not the problem. The problem is that <code>(+)</code> doesn't refer to anything.</p>",
        "id": 271713408,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644705421
    },
    {
        "content": "<p>Using <code> `additive </code> instead of <code>(+)</code> circumvents the problem because it generates the notation typeclasses from the names rather than depending on the notation typeclasses</p>",
        "id": 271713425,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644705464
    },
    {
        "content": "<p>Okay, this is all hypothetical anyway. I don't know if it's possible to pass in notation as a variable in Lean4.</p>",
        "id": 271713474,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644705489
    },
    {
        "content": "<p>One obvious problem with the \"name-polymorphism\" option of my proposal is that you need some way to pick a convenient notation inside the name-polymorphic lemma</p>",
        "id": 271713487,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644705508
    },
    {
        "content": "<p>Also, you definitely don't want to call all your lemmas <code>op_op_eq_op</code></p>",
        "id": 271713503,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644705544
    },
    {
        "content": "<p>Sure, you'd keep around <code>to_additive</code> and have it generate <code>mul</code> and <code>add</code> from the <code>op</code> versions</p>",
        "id": 271713522,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644705584
    },
    {
        "content": "<p>I don't know how this idea would play with the notation classes. Here is the simplest example of what I would like to be possible</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_binary_op</span> <span class=\"s2\">\"*\"</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>And not to rely on <code>has_mul</code> whatsoever.</p>",
        "id": 271713774,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644705952
    },
    {
        "content": "<p>(yes I know <code>has_ mul</code> is called <code>Mul</code> in Lean4 but you get the idea...)</p>",
        "id": 271713828,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644706012
    },
    {
        "content": "<p>Right, that's sort of similar to the approach I was trying to hit. As I mention in <a href=\"#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/271713487\">my message above</a> though, that's only half the problem - how do you write statements about monoids in general if you haven't chosen a notation for them?</p>",
        "id": 271714604,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644707170
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Your name tagging idea made me think about a metaprogramming approach. What if <code>to_additive</code> were revamped to generate multiplicative and additive lemmas for each generic monoid lemma?</p>\n<p>In files about generic monoids, you could have <code>local infix ` * ` := monoid.op</code> so you can work with notation. Since names are being modified by the <code>to_additive</code> machinery, we don't have to worry about how <code>ring</code> would have conflicting <code>op_assoc</code> axioms for its additive and multiplicative structures.</p>\n<p>We could then also generate lemmas about <code>-&gt;*</code>, <code>-&gt;+</code>, <code>*-&gt;+</code>, and <code>+-&gt;*</code> homomorphisms if the <code>to_additive</code> machinery could consider all four possible mul/add structures for the two arguments. (Presumably directed by some arguments to <code>to_additive</code> so this doesn't get too out of hand.)</p>",
        "id": 271714830,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644707546
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> make it polymorphic in the notation variable</p>",
        "id": 271714846,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644707618
    },
    {
        "content": "<p>The thing is that \"files about generic monoids\" are actually \"all files that currently use <code>@[to_additive]</code>\", so I think doing that globally in each of those files might not work out so well</p>",
        "id": 271714894,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644707649
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/271714846\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> make it polymorphic in the notation variable</p>\n</blockquote>\n<p>Yes, indeed - but then you can't use <code>*</code> in your lemma statement any more, which is what I was trying to point out.</p>",
        "id": 271714901,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644707674
    },
    {
        "content": "<p>With this approach, the whole <code>to_additive</code> game wouldn't even exist!</p>",
        "id": 271714903,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644707687
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/271714903\">said</a>:</p>\n<blockquote>\n<p>With this approach, the whole <code>to_additive</code> game wouldn't even exist!</p>\n</blockquote>\n<p>It does if we want <code>mul</code> or <code>add</code> in our lemma names as Kyle I think is suggesting.</p>",
        "id": 271714921,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644707711
    },
    {
        "content": "<p>At any rate, my point is that \"everywhere that currently uses <code>@[to_additive]</code> would end up being a notation-polymorphic lemma\", and so we'd need to enable local notation for each one of those lemma</p>",
        "id": 271714934,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644707755
    },
    {
        "content": "<p>And we do want <code>mul</code> and <code>add</code> versions because rewriting gets hard when the function is a variable...</p>",
        "id": 271714935,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644707758
    },
    {
        "content": "<p>If rewriting gets hard, then it will be hard in all the polymorphic cases where <code>add</code> and <code>mul</code> can't save us</p>",
        "id": 271714981,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644707790
    },
    {
        "content": "<p>I guess one solution is to have automation that takes a lemma written with <code>*</code> and that would make a lemma with arbitrary notation</p>",
        "id": 271714997,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644707831
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> That's basically what I was proposing, though the other way.</p>",
        "id": 271715006,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644707851
    },
    {
        "content": "<p>Yeah I see now!</p>",
        "id": 271715018,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644707882
    },
    {
        "content": "<p>A reason I was thinking the generic <code>monoid</code> seems useful is that then it puts <code>mul</code> and <code>add</code> on equal footing when you're configuring code generation.</p>",
        "id": 271715060,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644707909
    },
    {
        "content": "<p>And then you could also extend it with more notation typeclasses and generate more lemmas.</p>",
        "id": 271715077,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644707969
    },
    {
        "content": "<p>But there comes my question again. What names will you use? You're forbidding yourself both convention so as to avoid conflicts.</p>",
        "id": 271715084,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644707991
    },
    {
        "content": "<p>(It reminds me of how in some older languages with generics, like Ada, you have to declare that you're instantiating the generic variables. In this case, <code>monoid</code> gets instantiated as <code>add_monoid</code> and <code>mul_monoid</code>, perhaps.)</p>",
        "id": 271715142,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644708038
    },
    {
        "content": "<p>Why do the names matter?</p>",
        "id": 271715148,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644708044
    },
    {
        "content": "<p>Just write <code>assoc</code> instead of <code>add_assoc</code></p>",
        "id": 271715162,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644708075
    },
    {
        "content": "<p>because, against all odds, I'm not a computer <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 271715164,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644708078
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> For generic monoids, <code>op</code>-based seems fine. But then if there's <code>to_additive</code>-like metaprogramming, that all gets turned into <code>mul</code> and <code>add</code> versions.</p>",
        "id": 271715169,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644708090
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/271715162\">said</a>:</p>\n<blockquote>\n<p>Just write <code>assoc</code> instead of <code>add_assoc</code></p>\n</blockquote>\n<p>This doesn't scale too well for things like <code>mul_mul_mul_comm</code>, which after stripping away the operation name becomes the same as <code>mul_comm</code>.</p>",
        "id": 271715183,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644708118
    },
    {
        "content": "<p>Okay, and what about <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sub_eq_add_neg\">docs#sub_eq_add_neg</a>? Your heuristic breaks as soon as two operations are involved.</p>",
        "id": 271715225,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644708126
    },
    {
        "content": "<p>Maybe we just use <code>mul</code>-based naming <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 271715251,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644708176
    },
    {
        "content": "<p>so <code>mul</code>, <code>div</code>, <code>inv</code> for generic monoids.</p>",
        "id": 271715260,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644708194
    },
    {
        "content": "<p>Then you will get name conflicts with the multiplicative lemmas.</p>",
        "id": 271715264,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644708200
    },
    {
        "content": "<p>And have <code>generic_monoid.mul_mul_mul_comm</code> vs <code>mul_mul_mul_comm</code> for the generic  vs specialized versions?</p>",
        "id": 271715265,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644708204
    },
    {
        "content": "<p>I wonder if we could have something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">mul_left_comm</span>\n  <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">tag</span> <span class=\"o\">:</span> <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">multiplicative</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">generic_comm_monoid</span> <span class=\"n\">tag</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>where the default value of <code>tag</code> is used to inform the notation in the local scope of the lemma</p>",
        "id": 271715362,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644708331
    },
    {
        "content": "<p>In particular it would be nice to be able to use this in things like <a href=\"https://tqft.net/mathlib/group_theory/eckmann_hilton\">file#group_theory/eckmann_hilton</a> to have two simultaneous monoid structures on a type with locally distinct notations for each</p>",
        "id": 271715452,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644708481
    },
    {
        "content": "<p>I should say that I'm more than happy to wait for Lean 4 if that helps. We can keep ploughing on with the <code>multiplicative</code> hack until then, nothing is blocked, it's just getting a bit nasty</p>",
        "id": 271715726,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644708924
    },
    {
        "content": "<p>Stupid question, but why can't you just have one generic operation and just use different locales for different notation. Don't we basically use locales to unlock different notations anyway?</p>",
        "id": 271723404,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644721104
    },
    {
        "content": "<p>Oh nevermind, you couldn't use both locales at the same time.</p>",
        "id": 271724058,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644722172
    },
    {
        "content": "<p>Exactly, the problem is that we want <code>ring</code>s.</p>",
        "id": 271724215,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644722519
    },
    {
        "content": "<p>Since this is still on the drawing board (and you can always want more!), would it be possible to also include the opposite operation?  I find <code>\\op</code> somewhat clunkier and being able to simply pass <code>(swap (*))</code> to a statement could be easier.</p>",
        "id": 271741832,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1644752180
    },
    {
        "content": "<p>This would preempt also a <code>to_right</code> tactic from being written... <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 271741846,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1644752239
    },
    {
        "content": "<p>I've never seen a case where <code>to_right</code> would help; do you have one in mind?</p>",
        "id": 271742112,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644752647
    },
    {
        "content": "<p>A lot of the lemmas about monotonicity of multiplication on the left get reproven for multiplication on the right.  The proofs are always the \"same\" and <em>should</em> also follow by the <code>left</code> lemma applied to the <code>\\opp</code> monoid, but are simply repeated.  I'm not at a computer now, but lemmas in algebra.order.monoid_lemmas should give plenty of examples!</p>",
        "id": 271742544,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1644753396
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/271713315\">said</a>:</p>\n<blockquote>\n<p>Yeah, but then you have to write <code>[has_add G] [has_zero G] [has_neg G] [add_group G]</code></p>\n</blockquote>\n<p>I still think this is the way forwards, fwiw. We need macros that expand stuff like <code>[is_cyclotomic_extension {n} K L]</code>, because even without this happening we get crazy long variable lines that aren't how mathematicians work</p>",
        "id": 271745375,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1644757759
    },
    {
        "content": "<p>Have we got anything like the proposed [[]] notation in Lean4?</p>",
        "id": 271745382,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1644757784
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/271745375\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/271713315\">said</a>:</p>\n<blockquote>\n<p>Yeah, but then you have to write <code>[has_add G] [has_zero G] [has_neg G] [add_group G]</code></p>\n</blockquote>\n<p>I still think this is the way forwards, fwiw. </p>\n</blockquote>\n<p>No, it is important to keep things bundled (not always, but still a lot) because of performance problems otherwise. See for instance <a href=\"https://arxiv.org/abs/2202.01629\">https://arxiv.org/abs/2202.01629</a>, Section 10.</p>",
        "id": 271747893,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1644761386
    },
    {
        "content": "<p>Won't it be a constant slowdown at most? With only the amount of relevant [has_notation]  typeclasess</p>",
        "id": 271749080,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1644763125
    },
    {
        "content": "<p>Regardless, this is really interesting, we should definitely have a thread for all the ITP preprints!</p>",
        "id": 271749088,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1644763149
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/271749080\">said</a>:</p>\n<blockquote>\n<p>Won't it be a constant slowdown at most? With only the amount of relevant [has_notation]  typeclasess</p>\n</blockquote>\n<p>Term size is exponential in the length of an \"unbundled inheritance\" chain, so quadratic for this proposal: let's say we want an instance of <code>add_group (ℤ × ℤ × ... × ℤ)</code>, with <code>n</code> copies of <code>ℤ</code>. Then we get a term like <code>prod.add_group ℤ^n int.add_group (prod.has_add ℤ^n int.has_add (prod.has_add ℤ^(n-1) int.has_add _) (prod.has_zero ℤ^n int.has_zero (prod.has_zero ℤ^(n-1) int.has_zero _) (prod.has_add ℤ^(n-1) int.has_add _) (prod.has_neg ℤ^n int.has_neg (prod.has_neg ℤ^(n-1) int.has_neg _) (prod.add_group ℤ^(n-1) _ _ _ _)</code>. For each <code>prod.add_group ℤ^i</code> we get some constant term size and 3 different <code>prod.has_$op ℤ^i</code> and one <code>prod.add_group ℤ^(i-1)</code>. For each <code>prod.has_$op ℤ^i</code> we get some constant term size and <code>i</code> different <code>prod.has_$op ℤ^j</code>.</p>",
        "id": 271752379,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1644768003
    },
    {
        "content": "<p>How often do we have large chains of <code>prod</code> as opposed to using <code>pi.add_group</code>?</p>",
        "id": 271752619,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1644768083
    },
    {
        "content": "<p><code>prod</code> is an easy example since the recursive behaviour is easy to explain, but the same goes for heterogeneous definitions of the form <code>set (finsupp (multiplicative (fin n → ℤ)^op))</code></p>",
        "id": 271752689,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1644768176
    },
    {
        "content": "<p>I'd expect that for these examples, quadratic depth is not too bad and increasing the term size here moves some complexity away from <em>unfolded</em> term size, which is relevant in certain parts of the type checker I understand from diagnosing a class of timeouts where big terms appear in the type. So I'm not opposed to unbundling notation/data from axioms/proofs.</p>",
        "id": 271752917,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1644768484
    },
    {
        "content": "<p>One option that we should consider is bundling all the data into one structure and all the proofs into another. So you'd have a <code>add_group_data ℤ</code> instance containing <code>+</code>, <code>-</code>, <code>0</code>, and a <code>add_group_laws ℤ</code> instance containing <code>add_assoc</code>, <code>add_zero</code>, <code>add_neg</code>. That makes refactors like adding a <code>nsmul</code> field to monoids a bit less painful: in the unbundled data case, you'd need to add an <code>has_smul ℕ M</code> everywhere you write <code>monoid M</code>.</p>",
        "id": 271753177,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1644768953
    },
    {
        "content": "<p>I like this <code>add_group_data</code> approach; I think the [[]]s will be essential for that though</p>",
        "id": 271753406,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1644769236
    },
    {
        "content": "<p>I also like this very much.  It also aligns with how I would think of a ring: a set/type with a bunch of operations, satisfying some conditions.  I imagine that working flexibly with <code>(+), (*)</code>, their <code>swap</code>s, adding opposites/inverses as needed will become easier!</p>",
        "id": 271764618,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1644785188
    },
    {
        "content": "<p>Unfortunately this discussion is not really about how we'd like to manipulate things. It's really about performance of the type class mechanism. I certainly don't understand this technology well enough to write any meaningful comment here.</p>",
        "id": 271764954,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1644785670
    },
    {
        "content": "<p>I also don't have a good answer here but this has reminded me that I was messing around with alternatives to <code>to_additive</code> a few months ago. I've just pasted a very old script I had lying around into <a href=\"https://gist.github.com/ocfnash/3e8a8cfb377f67e9b7fdea908d996f59\">this gist</a>.</p>",
        "id": 271954906,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1644921567
    },
    {
        "content": "<p>I think it's basically the same idea as what Eric pasted above, namely we parameterise our operations so the key definition is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_op</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_unit</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">unit</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and then a group is defined as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">ω₁</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">mul_group_notation</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">group</span> <span class=\"kd\">extends</span> <span class=\"n\">has_op</span> <span class=\"n\">α</span> <span class=\"n\">ω₁</span><span class=\"o\">,</span> <span class=\"n\">has_unit</span> <span class=\"n\">α</span> <span class=\"n\">ω₁</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mul_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">mul_unit</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"bp\">Ι</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">unit_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">Ι</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">inv_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">Ι</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">inv_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"bp\">Ι</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It sort-of works. I haven't tried to see if it could really scale up but I'd love if something like this could.</p>",
        "id": 271955106,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1644921666
    },
    {
        "content": "<p>But it does at least give very basic <code>to_additive</code>-type <a href=\"https://gist.github.com/ocfnash/3e8a8cfb377f67e9b7fdea908d996f59#file-parametric_operations-lean-L81\">magic</a> without actually duplicating any lemmas as well as allowing multiple operations and notation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">distrib</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">left_distrib</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">right_distrib</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 271955303,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1644921758
    },
    {
        "content": "<p>I also have another mathematical example where this comes up that I just learned last week. Apparently algebraists studying nilpotent groups <code>G</code> like to regard the lower central series as a filtration and then take the associated graded group <code>LG</code>. However <code>LG</code> is Abelian and furthermore  carries a natural Lie bracket (coming from the commutator of two group elements) making it a Lie ring so we really want to land in the additive world. I have no plans to formalise this, and I think it wouldn't be too hard to pass from multiplicative to additive classes, but it is another example (albeit exotic) I think.</p>",
        "id": 271956046,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1644922171
    },
    {
        "content": "<p>That example is not exotic at all. It's related to Malcev completions which are quite important (take Deligne's paper on P1 minus three points, for example).</p>",
        "id": 271970216,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644930161
    },
    {
        "content": "<p>Interesting, thanks!</p>",
        "id": 271974907,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1644932670
    },
    {
        "content": "<p>BTW, if you interpret it properly, Kevin's example of Kummer theory can be seen as a special case of this. Namely, if you look at the isomorphism induced by the Kummer map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>K</mi><mo>×</mo></msup><mi mathvariant=\"normal\">/</mi><mi>n</mi><mo>≅</mo><msup><mi>H</mi><mn>1</mn></msup><mo stretchy=\"false\">(</mo><mi>K</mi><mo separator=\"true\">,</mo><msub><mi>μ</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">K^\\times/n \\cong H^1(K,\\mu_n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, assume for simplicity that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>μ</mi><mi>n</mi></msub><mo>⊂</mo><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">\\mu_n \\subset K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊂</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> then taking Pontryagin duals you obtain an isomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>G</mi><mi>K</mi><mrow><mi>a</mi><mi>b</mi></mrow></msubsup><mo>⊗</mo><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mi>n</mi><mo>≅</mo><mo stretchy=\"false\">(</mo><msup><mi>K</mi><mo>×</mo></msup><mi mathvariant=\"normal\">/</mi><mi>n</mi><msup><mo stretchy=\"false\">)</mo><mo>∨</mo></msup></mrow><annotation encoding=\"application/x-tex\">G_K^{ab} \\otimes \\mathbb{Z}/n \\cong (K^\\times/n)^\\vee</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1244em;vertical-align:-0.2753em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-2.4247em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">K</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">ab</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2753em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∨</span></span></span></span></span></span></span></span></span></span></span>. The cup-product in Galois cohomology is then related to the 2-step nilpotent part of this Lie algebra (well, the one arising from the mod-n central descending series) obtained from the absolute Galois group of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>, which (using some strong theorems, like the Merkurjev-Suslin theorem) can be related to the arithmetic of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>.</p>",
        "id": 271975991,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644933142
    },
    {
        "content": "<p>I guess one doesn't really need Galois cohomology for this... the same holds for group cohomology of any group. For example, group homology is a thing, and you can ask what  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><mi>G</mi><mo separator=\"true\">,</mo><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H_1(G,\\mathbb{Z})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>H</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>G</mi><mo separator=\"true\">,</mo><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H_2(G,\\mathbb{Z})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mclose\">)</span></span></span></span> looks like.</p>",
        "id": 271976467,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644933374
    },
    {
        "content": "<p>In knot theory, the Alexander module of a knot <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><mover accent=\"true\"><mi>X</mi><mo stretchy=\"true\">‾</mo></mover><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H_1(\\overline{X})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1333em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8833em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span><span style=\"top:-3.8033em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> as a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H_1(X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span>-module, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>=</mo><msup><mi>S</mi><mn>3</mn></msup><mo>∖</mo><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">X=S^3\\setminus K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∖</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> and where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>X</mi><mo stretchy=\"true\">‾</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\overline{X}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8833em;\"></span><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8833em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span><span style=\"top:-3.8033em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span></span></span></span> is the universal abelian cover of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>. In group theory land, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><mover accent=\"true\"><mi>X</mi><mo stretchy=\"true\">‾</mo></mover><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H_1(\\overline{X})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1333em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8833em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span><span style=\"top:-3.8033em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> (as an additive group) is isomorphic (as a multiplicative group) to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></msup><mi mathvariant=\"normal\">/</mi><msup><mi>G</mi><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow></msup></mrow><annotation encoding=\"application/x-tex\">G^{(1)}/G^{(2)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.138em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">2</span><span class=\"mclose mtight\">)</span></span></span></span></span></span></span></span></span></span></span></span> with the earlier action being conjugation by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi mathvariant=\"normal\">/</mi><msup><mi>G</mi><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></msup></mrow><annotation encoding=\"application/x-tex\">G/G^{(1)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.138em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span></span></span></span></span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> is the fundamental group of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>.</p>\n<p>In general, the derived series is a filtration, and each quotient <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow></msup><mi mathvariant=\"normal\">/</mi><msup><mi>G</mi><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></msup></mrow><annotation encoding=\"application/x-tex\">G^{(n)}/G^{(n+1)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.138em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">)</span></span></span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span></span></span></span></span></span></span></span> is an abelian group and a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mi mathvariant=\"normal\">/</mi><msup><mi>G</mi><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}[G/G^{(n)}]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.138em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">)</span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span>-module (by conjugation), and is known as a higher Alexander module of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>.</p>",
        "id": 272015764,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644949038
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Barry Mazur would say these are the same picture.</p>",
        "id": 272017052,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644949588
    },
    {
        "content": "<p>At the kind of mathematical level we're working at in mathlib I've found it fascinating that multiplication and addition have coexisted in different worlds and we've never needed to cross this divide at all. There's a natural pecking order for notation -- we have distribs to make * distribute over + but we never need to make + distribute over <em>. Valuations were the first example where I thought we'd have to deal with this but we formalised the theory of adic spaces in the perfectoid project and I thought it was striking that Huber used multiplicative notation for his target monoids meaning that the axiom was still v(x</em>y)=v(x)*v(y). However in this thread we're seeing examples where mathematicians really do pass from the multiplicative world to the additive world. I don't know whether this is some sort of profound thing or just a fact of life. Do we call something multiplication because it distributes over some addition? Do we call something addition because some multiplication distributes over it? Cohomology has an addition because we use cohomology rings, although the product is often denoted with a ∪.</p>",
        "id": 272089329,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1645002354
    },
    {
        "content": "<p><a href=\"#narrow/stream/116395-maths/topic/Additive.20characters/near/290429680\">Here</a> is some related discussion.<br>\nMy use case is Gauss sums, where one has to simultaneously consider a morphism <code>ψ</code> from the additive group of a (finite) ring <code>R</code> into the multiplicative monoid of another ring <code>R'</code> (\"additive character\") and another morphism <code>χ</code> from the multiplicative monoid of <code>R</code> into that of <code>R'</code> (\"multiplicative character\"), which are multiplied and summed over all elements of <code>R</code>. It looks like I will have to define this in the form <code>∑ a : R, (χ a) * (ψ (of_add a))</code>, which is clumsy and ugly...</p>",
        "id": 290499354,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1658492974
    },
    {
        "content": "<p>Maybe it's time we had this? What are the objections, other than \"we'll have to write some boilerplate\"? The advantages are that we don't have to write what Michael just pasted above.</p>",
        "id": 290500725,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1658493780
    },
    {
        "content": "<p>Since it will only ever be needed between groups or monoids (I mean, no ring version or field version or whatever), I don't think it will ever get too complex or too boilerplaty. So I think it's indeed a good idea to get it.</p>",
        "id": 290501165,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1658493984
    },
    {
        "content": "<p>I also (and again!) support of this!  We may even try to get <code>degree</code> (with the appropriate no-zero-divisors assumption) to fit in there!</p>",
        "id": 290501404,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1658494124
    },
    {
        "content": "<p>I can see us ending up with <code>zero_one_hom</code>, <code>one_zero_hom</code>, <code>add_mul_hom</code>, <code>mul_add_hom</code>, <code>monoid_add_monoid_hom</code>, <code>add_monoid_monoid_hom</code>, and another 6 versions for equivs</p>",
        "id": 290501451,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658494159
    },
    {
        "content": "<p>That's quite a lot of boilerplate</p>",
        "id": 290501465,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658494169
    },
    {
        "content": "<p>Even if we don't care about all 12 we certainly care about 4.</p>",
        "id": 290501557,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658494209
    },
    {
        "content": "<p>Is that an argument against or just an observation? I mean making LTE involved writing tens of thousands of lines of code which was quite a lot of code.</p>",
        "id": 290501581,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1658494232
    },
    {
        "content": "<p>Sort of an objection to the \"not too boilerplaty\" claim</p>",
        "id": 290501636,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658494266
    },
    {
        "content": "<p>But do we care if we make another definition and then write some boilerplate?</p>",
        "id": 290501691,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1658494302
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/290501451\">said</a>:</p>\n<blockquote>\n<p>I can see us ending up with <code>zero_one_hom</code>, <code>one_zero_hom</code>, <code>add_mul_hom</code>, <code>mul_add_hom</code>, <code>monoid_add_monoid_hom</code>, <code>add_monoid_monoid_hom</code>, and another 6 versions for equivs</p>\n</blockquote>\n<p>We probably don't need <code>zero_one</code> and <code>one_zero</code>, that's 2 down already.</p>",
        "id": 290503500,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1658495239
    },
    {
        "content": "<p>I'm not sure if we'd even need <code>add_mul_hom</code>+<code>mul_add_hom</code></p>",
        "id": 290503521,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1658495251
    },
    {
        "content": "<p>No need to add all the possible ones, only those that are genuinely useful. And I guess this should only be <code>monoid_add_monoid_hom</code> and <code>add_monoid_monoid_hom</code>. More can be added later if uses show up.</p>",
        "id": 290504069,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1658495566
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/290503521\">said</a>:</p>\n<blockquote>\n<p>I'm not sure if we'd even need <code>add_mul_hom</code>+<code>mul_add_hom</code></p>\n</blockquote>\n<p>I can see us ending up with them eventually, given the interest in non-unital rings</p>",
        "id": 290504936,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658496065
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/290504069\">said</a>:</p>\n<blockquote>\n<p>No need to add all the possible ones, only those that are genuinely useful. And I guess this should only be <code>monoid_add_monoid_hom</code> and <code>add_monoid_monoid_hom</code>. More can be added later if uses show up.</p>\n</blockquote>\n<p>Indeed; but my thought is that this is a sign of either not having a scalable design, or just needing some automation to generate boilerplate for us</p>",
        "id": 290504982,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658496101
    },
    {
        "content": "<p>And it's easier to write that automation / do the redesign if we have <code>n</code> existing versions to clean up instead of <code>n+12</code></p>",
        "id": 290505048,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658496124
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/290504936\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/290503521\">said</a>:<br>\nI can see us ending up with them eventually, given the interest in non-unital rings</p>\n</blockquote>\n<p>Precisely, it's not a ring thing, it's a group thing, and used in very specific contexts. That's why I imagine we will only need these 2 versions.</p>",
        "id": 290505739,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1658496561
    },
    {
        "content": "<p>I'd argue it's a monoid thing not a group thing, and so therefore applies to rings too. We indeed don't need special cases for rings, but for instance if we introduce a power operation on non-unital monoids/rings by <code>pnat</code>, then that operaion would be an <code>add_mul_hom</code> in the second argument.</p>",
        "id": 290506542,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658496990
    },
    {
        "content": "<p>I'm sitting in a lecture by Hendrik Lenstra at the Park City Mathematics Institute, and he just defined a map<br>\n\\Z^t --&gt; K^x, (n_i)_i |--&gt; a_1^{n_1} ... a_t^{n_t} (where $K$ is a number field), whose kernel he wants to compute...</p>",
        "id": 290770842,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1658761434
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">Z</mi><mi>t</mi></msup><mo>→</mo><msup><mi>K</mi><mi>x</mi></msup><mo separator=\"true\">,</mo><msub><mrow><mo stretchy=\"false\">(</mo><msub><mi>n</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><mi>i</mi></msub><mo>↦</mo><msubsup><mi>a</mi><mn>1</mn><msub><mi>n</mi><mn>1</mn></msub></msubsup><mo>⋯</mo><msubsup><mi>a</mi><mi>t</mi><msub><mi>n</mi><mi>t</mi></msub></msubsup></mrow><annotation encoding=\"application/x-tex\"> \\mathbb{Z}^t \\to K^x, {(n_i)}_i \\mapsto a_1^{n_1} \\cdots a_t^{n _t} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7936em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7936em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.162em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0126em;vertical-align:-0.2663em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7463em;\"><span style=\"top:-2.4337em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.1449em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3173em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2663em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7463em;\"><span style=\"top:-2.4542em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span><span style=\"top:-3.1449em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2963em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2458em;\"><span></span></span></span></span></span></span></span></span></span></p>",
        "id": 290773955,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1658762691
    },
    {
        "content": "<p>(I probably had a type in my first attempt at LaTeX.)</p>",
        "id": 290782858,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1658765874
    },
    {
        "content": "<p>Here's a bit of code playing around with notation in Lean4</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Op</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"[[ Op \"</span> <span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\" using \"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">str</span> <span class=\"s2\">\"]]\"</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">Op</span> <span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"o\">]</span>\n    <span class=\"kn\">local</span> <span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">str</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Op.op</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">[[</span> <span class=\"n\">Op</span> <span class=\"n\">α</span> <span class=\"n\">using</span> <span class=\"s2\">\" × \"</span> <span class=\"o\">]]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">[[</span> <span class=\"n\">Op</span> <span class=\"n\">β</span> <span class=\"n\">using</span> <span class=\"s2\">\" ++ \"</span> <span class=\"o\">]]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">×</span> <span class=\"n\">b</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">++</span> <span class=\"n\">b</span>\n</code></pre></div>",
        "id": 290846422,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658807280
    },
    {
        "content": "<p>The question is can we do rings like this or will typeclass inference get confused by the two <code>Op</code>s?</p>",
        "id": 290857865,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1658820771
    },
    {
        "content": "<p>I have started to write (= copy and modify) code for homomorphisms from additive to multiplicative monoids and vice versa.</p>\n<p>So far, I took <code>algebra/hom/group.lean</code> and extracted three files out of it, <code>add_mul_hom.lean</code> (definition of homomorphisms from additive to multiplicative monoids and stuff that only relies on the definition), <code>mul_add_hom.lean</code> (same for the other dierction) and <code>hom_comp.lean</code> (stuff that involves both types like composition). I also converted (most of) <code>equiv.lean</code> into a file <code>equiv_mixed.lean</code> that has stuff on isomorphisms. What still needs to be done is to produce the corresponding versions of <code>grop_instances.lean</code> and <code>units.lean</code> (everything inside <code>algebra/hom</code>). (Plus perhaps further material that lives elsewhere.)</p>\n<p>What would be a reasonable way to proceed? I could make a PR with what I have so far (labeled as WIP), so that people can comment on it, and we can also discuss questions that arise here. Does this sound reasonable, or are there other preferred ways of proceeding in similar cases?</p>",
        "id": 291928385,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1659565448
    },
    {
        "content": "<p>So, I'm going to second Eric's suggestion that this is too much boilerplate to actually undertake. That <code>pnat</code> instance he mentioned is definitely something on my todo list. I will completely agree that we need some way to talk abut group homs between additive and multiplicative groups (for instance, in my use case, the index map from the (operator algebraic) $K_1$ group to the $K_0$ group is a multiplicative to additive group hom). But <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> convinced me at LftCM that there is just too much duplication. <em>Perhaps</em> with the right <code>to_additive</code>-like automation, it could be feasible, but that still feels like the wrong solution to me.</p>",
        "id": 291932602,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1659568300
    },
    {
        "content": "<p>I think that <code>to_additive</code>-like automation would be difficult, since this would require to figure out which <code>mul</code>s etc. to turn into <code>add</code>s etc, depending on the kind of structure on the various monoids present (there can be up to four; the latter occurs when proving associativity of composition).<br>\nProbably something like <code>switch_add_mul</code> would work that takes a statement/proof involving one \"mixed\" homomorphism of type mul to add (say) and turns it into the corresponding statement for add to mul.</p>\n<p>What is the problem with duplication as long as somebody writes the code?</p>",
        "id": 291934366,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1659569715
    },
    {
        "content": "<p>The code has to be maintained after, ideally any change to the original API should be reflected in the duplicated one, which is tricky as often people making changes aren't aware of the duplicated version</p>",
        "id": 291947461,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1659571549
    },
    {
        "content": "<p>to_additive type automation may not be flawless, but I'd say it's worth exploring to reduce the manual effort. The original to_additive has edge cases too but it is still remarkably useful</p>",
        "id": 291947563,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1659571641
    },
    {
        "content": "<p>I assume the \"right\" way would be to write everything in terms of generic structures (not tied to additive or multiplicative notation) and then have automation that produces the 2^n variants of the generic statement (when n objects are involved). This should actually be quite possible via some kind of Macro expansion (which I think Lean4 is supposed to provide).</p>",
        "id": 291948028,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1659572156
    },
    {
        "content": "<p>I think it's dangerous to say \"we don't want to do it this way which works, we should do it this way which is a dream which exists only in my head\". Michael has a problem which needs to be solved and he has a solution. I know CS people are against code duplication in general but they're also against big monorepos in general and we've shown that actually a big monorepo can work fantastically. Who cares if the duplicated code gets out of sync? Category theory contains files which are literally two copies of the same code, one for limits and one for colimits. Separating additive and multiplicative groups is a fundamental design decision in mathlib, made because we want type class inference to infer monoid laws, and type class inference wants there to be one answer but rings have two laws. It's very easy to speculate how things could have been if rings had been built in another way, but they weren't, and the code duplication that Michael is suggesting is simply a consequence we are at some point going to have to face. Nobody was complaining when Scott was making PRs which were twice as long as some theoretical automation could have made them because the duplication was a practical solution to a clearly existing problem. I think the same is true here.</p>",
        "id": 291973086,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1659597261
    },
    {
        "content": "<blockquote>\n<p>and the code duplication that Michael is suggesting is simply a consequence we are at some point going to have to face</p>\n</blockquote>\n<p>The problem is, the longer we put off facing it, the more it grows and the more likely we never end up facing it, which means:</p>\n<ul>\n<li>Newcomers to mathlib always have to write tonnes of boilerplate, because while we already have hundreds of boilerplate lemmas for <code>add_monoid_hom</code>, we won't have them for <code>mul_add_hom</code></li>\n<li>We're increasing faced with refactors which are no longer possible to make because there's just too much boilerplate that needs changing.</li>\n</ul>",
        "id": 292016899,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1659624114
    },
    {
        "content": "<p>Yes I see that refactors would be problematic. But I can't imagine how automation can do this job, because how can it distinguish the source <code>*</code> from the target <code>*</code>? Is that sort of problem possible? If <code>f : G -&gt;* H</code> and the lemma is <code>f (a * b) = f a * f b</code> you want the automation to spit out <code>f (a * b) = f a + f b</code>. </p>\n<p>For me the question of a refactor, or of automation, are problems which can possibly be solved tomorrow (the first might never happen, the second is probably a nontrivial project), but making a bundled structure <code>f : G -&gt; A</code> with <code>f (g * h) = f g + f h</code> is a problem which can easily be solved today and which we need today.</p>",
        "id": 292020627,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1659625645
    },
    {
        "content": "<p>Automation could have you define the structures / write the lemmas in the generic way, then spit out the various specialized versions</p>",
        "id": 292021336,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1659625932
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/292020627\">said</a>:</p>\n<blockquote>\n<p>because how can it distinguish the source <code>*</code> from the target <code>*</code>?</p>\n</blockquote>\n<p>One is <code>@has_mul.mul G _inst_1</code>, the other is <code>@has_mul.mul H _inst_2</code></p>",
        "id": 292021495,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1659626014
    },
    {
        "content": "<p>So moving forward how about we write the code duplication today and leave the tactic-writing until Lean 4?</p>",
        "id": 292031064,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1659630076
    },
    {
        "content": "<p>But note that you need a version of the automation that can deal with more than two monoids (or similar), so it will have to be able to generate 8 or 16 versions in some cases.</p>",
        "id": 292041517,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1659633390
    },
    {
        "content": "<p>I think if Michael really wants to write an initial draft of this by hand, then that's fine; but I think before we <em>merge</em> anything like this we'll need to have a hard think about how to deal with these problems. My fear (maybe unfounded, but obviously shared by several people here) is that we will mire ourselves in tedious work and / or that the library will become disjointed because of failure to keep the multiplicative/additive and mixed parts in sync.</p>\n<p>At the very least, we need some sort of back-of-the-envelope calculation to estimate how many defs and lemmas we're talking about here. I get the feeling that it may be a few thousand. To me, this reeks of trying to do convergence without filters, which would be a nightmare; but maybe I'm wrong about mul/add.</p>",
        "id": 292050108,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1659637329
    },
    {
        "content": "<p>I think that one reason I'm so much more keen on the idea of making a <code>mul_add_hom</code> structure is that my naive model of the result is just one file which is handy in a few places but just sits there in the background not really doing much. Please don't take my huge enthusiasm for this structure as some kind of demand! It's more a \"what is there not to like about this idea?\" situation -- I really don't get what people are fussing about. Just one file, imported occasionally in the (rare!) situations where it really makes life easier, and who cares if it's out of sync; if it actually becomes a problem then OK we just make the tactic (note of course that any tactic-making now is a really bad idea as it actively makes the port to Lean 4 harder), but just one random file imported a few times to make some constructions less horrible -- how can this be problematic? My impression is that everyone else seems to be gazing years into the future and worrying about things not scaling. That's not why we want this structure! It's hard to imagine that it will ever need to be built upon too much, and people will add API if and when they need it. Note that we've got to LTE without ever needing it, so it's clear (to my surprise) that this structure only has some kind of niche usage, it's not going to take over the algebra hierarchy! I just don't get what people are worried about. Michael are you envisaging a few thousand lemmas to do what you want to do??</p>",
        "id": 292067520,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1659645815
    },
    {
        "content": "<p>Kevin, I shared your feeling until I talked to Yury at breakfast at LftCM (I thought maybe you were even sitting there, but perhaps I'm misremembering). I don't remember all the details, but essentially, you're probably going to need: map and comap, kernels and images, composition lemmas, etc. (I think he went on naming several much more far reaching things).</p>\n<p>Where did I ballpark a few thousand lemmas? Well, <code>algebra.hom.group</code> alone (where <code>monoid_hom</code> is defined) likely has 100-200 lemmas, and this doesn't even touch subgroups (kernel, image etc.). You will also need either new hom classes, or else just write the <code>map_add_mul</code>, <code>map_zero_one</code> lemmas manually. I think it's reasonable to hit a thousand lemmas doing this, and I've almost surely missed a bunch of things which will be necessary.</p>\n<p>Now, <em>despite</em> my relatively newfound skepticism, if this is implemented and it seems to work, then great! All i'm advocating for is that we design carefully; not doing so can bite us.</p>",
        "id": 292070357,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1659647364
    },
    {
        "content": "<p>Remember also, naming is hard to keep straight. Right now, (almost) every time a lemma name is changed <code>to_additive</code> takes care of renaming the additive one. For all of these, you have to manually keep the names in sync, not to mention the statements. <em>Maybe</em> because it is only about groups, the naming is relatively stable at this point, I have no idea.</p>",
        "id": 292070656,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1659647537
    },
    {
        "content": "<p>Naming is going to be a problem when there are three or more monoids involved.<br>\nE.g., there are eight ways to compose homomorphisms. Fixing the type of the seoncd one (in order of application; it is the first argument to <code>comp</code>), there are still two compositions to be defined: say, the second homomorphism <code>g</code>  is from multiplicative to additive. Then we can (pre-)compose <code>g</code> with an <code>f</code> that is either a hom. from additive to multiplcicative or a multiplicative hom.<br>\nIt would be desirable if all of this would be called <code>comp</code> in some appropriate namespace. But since there are two different <code>comp</code>s, we then cannot just simply use <code>monoid_to_add_monoid_hom.comp</code>. Perhaps <code>monoid_to_add_monoid_hom.add.comp</code> and <code>monoid_to_add_monoid_hom.mul.comp</code>?<br>\nThen we could write <code>g.add.comp f</code> or <code>g.mul.comp f</code>. (Of course, it would be more desirable to just write <code>g.comp f</code>, but I think this would require the possibility to overload names, which, as far as I know, Lean does not provide.)</p>",
        "id": 292071910,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1659648323
    },
    {
        "content": "<p>This would have to be taken care of by the <code>to_additive</code> analogues.</p>",
        "id": 292071953,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1659648354
    },
    {
        "content": "<p>It gets even worse with <code>comp_assoc</code>. This involves <em>four</em> monoids, so we need names like <code>monoid_hom.add.mul.comp_assoc</code> if we do it in a similar way.</p>",
        "id": 292072089,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1659648423
    },
    {
        "content": "<p>(It would be even better if there would be a general <code>comp_assoc</code> lemma that applies whenever stuff gets composed that can be coerced to functions and for which composition makes sense. The proofs of these sixteen lemmas are all the same.)</p>",
        "id": 292072303,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1659648527
    },
    {
        "content": "<p>But do you actually need these things in your use case? You don't even need a map which sends multiplication to addition, right? Such things seem to be much rarer.</p>",
        "id": 292073292,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1659649119
    },
    {
        "content": "<p>Recently I played with the idea of defining contravariant functors directly (no mention of <code>op</code>) and here you probably really would need all these extra things, but boy was it glorious not having to deal with all the <code>op</code>s!</p>",
        "id": 292073626,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1659649335
    },
    {
        "content": "<p>For my use case, I probably really don't need much. But I assume there will be more applications (also for mul_to_add), and so I would support the notion that it should be done \"right\", by which I would understand that you can do everything you can do with homomorphisms between monoids of the same kind also with homomorphisms between monoids of different kinds. And I agree that the best way of doing that is to beef up <code>to_additive</code> such that it produces the necessary versions for all combinations.</p>",
        "id": 292074367,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1659649887
    },
    {
        "content": "<p>Logarithms and exponentials are not that uncommon and would be fairly typical examples.</p>",
        "id": 292074468,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1659649946
    },
    {
        "content": "<p>I want to argue that logarithm <em>is</em> uncommon, because it's not defined on the negative reals, so as it stands in mathlib (where it takes junk values) it doesn't send * to +. It would work for positive reals but we don't even have a type for these in Lean, so they can't be common either. I think the exp direction is much more common.</p>",
        "id": 292074831,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1659650163
    },
    {
        "content": "<p>\"not that uncommon\" was referring to mathematics, not necessarily mathlib <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 292075090,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1659650317
    },
    {
        "content": "<p>If you'd asked me 5 years ago I would have said that maps that take + to * and * to + were all over the place and that any system which randomly separated out \"groups with group law +\" from \"groups with group law *\" was completely crazy. Now I have to admit that I was wrong.</p>",
        "id": 292075563,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1659650579
    },
    {
        "content": "<p>Yes, it does work surprisingly well.</p>",
        "id": 292075828,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1659650715
    },
    {
        "content": "<p>Has anybody been trying to consider <code>pow x</code> or <code>zpow x</code> as a monoid/group homomorphism? That would appear pretty natural (and perhaps underscores Kevin's point that add_to_mul is more common than <code>mul_to_add</code>).</p>",
        "id": 292075987,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1659650791
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Regarding both directions of maps: in the 6-term cyclic exact sequence (due to Bott periodicity) in operator algebraic K-theory corresponding to a short exact sequence <code>0 → J → A → A / J → 0</code>, which is:<br>\n<code>K₀(J) → K₀(A) → K₀(A / J) e→ K₁(J) → K₁(A) → K₁(A / J) δ→ K₀(J)</code> (wrap this around)<br>\nThen the maps I labeled <code>e</code> is an <code>add → mul</code> and <code>δ</code> is a <code>mul → add</code> because <code>K₀</code> is additive but <code>K₁</code> is multiplicative.</p>",
        "id": 292077186,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1659651514
    },
    {
        "content": "<p>Not sure if this has been mentioned already, but when one of these maps appears on the side in some complex construction, I think it is not at all a bad idea to just use <code>A -&gt; multiplicative B</code> homs instead of doing thousands of boilerplate lemmas for a new class. It is only when these show up often enough that the boilerplate associated with working with them is higher than the general API that we should consider doing all the combinatorial explosion of lemmas</p>",
        "id": 292107010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659674665
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Yes, that's what Michael has been using so far. Search for <code>add_char</code> in mathlib if you want to see details (-;</p>",
        "id": 292107736,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1659675501
    },
    {
        "content": "<p>In particular, if you have that as a backup plan then it means you don't have to go nuts on the combinatorial explosion, you can just do the particular special cases that happen to be very common</p>",
        "id": 292107794,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659675579
    },
    {
        "content": "<p>Certainly if the new notion would also unfold into a <code>A →* multiplicative B</code>.</p>",
        "id": 292108060,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1659675791
    },
    {
        "content": "<p>The solution I have come up with for my use case is the following. Define</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">field_theory.finite.galois_field</span>\n<span class=\"kn\">import</span> <span class=\"n\">number_theory.cyclotomic.primitive_roots</span>\n<span class=\"kn\">import</span> <span class=\"n\">field_theory.finite.trace</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">R'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">R'</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[derive [comm_monoid, inhabited]</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">add_char</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">multiplicative</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">→*</span> <span class=\"n\">R'</span>\n</code></pre></div>\n<p>as is currently done in <code>number_theory.legendre_symbol.add_character</code>, and then define the coercion to a function as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">multiplicative</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">add_char.has_coe_to_fun</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">add_char</span> <span class=\"n\">R</span> <span class=\"n\">R'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">ψ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">ψ.to_fun</span> <span class=\"o\">(</span><span class=\"n\">of_add</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>so that it includes the conversion from <code>R</code> to <code>multiplicative R</code>.<br>\nThen I can write, e.g., <code>ψ (a * x)</code> (for <code>ψ : add_char R R'</code> and <code>a x : R</code>) , and it is what I want it to be (i.e., <code>ψ.to_fun (of_add (a * x))</code> and not <code>ψ.to_fun (of_add a * of_add x) = ψ.to_fun (of_add (a + x))</code>).<br>\nIt is then easy to show API lemmas like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">map_zero_one</span> <span class=\"o\">(</span><span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">add_char</span> <span class=\"n\">R</span> <span class=\"n\">R'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ψ</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">map_add_mul</span> <span class=\"o\">(</span><span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">add_char</span> <span class=\"n\">R</span> <span class=\"n\">R'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ψ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">ψ</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">ψ</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">map_nsmul_pow</span> <span class=\"o\">(</span><span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">add_char</span> <span class=\"n\">R</span> <span class=\"n\">R'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ψ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">•</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">ψ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>and use them in the proofs, so that there is no need to even see an <code>of_add</code> or <code>to_add</code> anywhere (except in the proofs of these API lemmas).</p>",
        "id": 292623869,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1660066400
    },
    {
        "content": "<p>I'm going to PR this next, once <a href=\"https://github.com/leanprover-community/mathlib/pull/15888\">#15888</a> is merged (which should be soon).</p>",
        "id": 292624121,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1660066495
    },
    {
        "content": "<p>That's very nice!</p>",
        "id": 292634517,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660070076
    },
    {
        "content": "<blockquote>\n<p>Has anybody been trying to consider pow x or zpow x as a monoid/group homomorphism?</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/powers_hom\">docs#powers_hom</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/zpowers_hom\">docs#zpowers_hom</a></p>",
        "id": 292635094,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660070294
    },
    {
        "content": "<p>Oh that's a great solution!</p>",
        "id": 292635724,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660070559
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span> How generally can this be made to work? That is, does it solve all our problems? Are there limitations you have encountered?</p>",
        "id": 292636645,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660070886
    },
    {
        "content": "<p>I haven't tried to see how general this is. At least for what I wanted, it's sufficient.<br>\nI guess it would not work that well when you want to compose homomorphisms, say you have <code>M →+ N</code> and <code>N +→* P</code> (using <code>+→*</code> for a homomorphism from additive to multiplicative) and want to produce <code>M +→* P</code>.</p>",
        "id": 292638901,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1660071697
    },
    {
        "content": "<p>It is possible (to get compositions as above), but one has to use <code>to_multiplicative</code>, e.g. as in the following.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">ψ'</span> <span class=\"o\">:=</span> <span class=\"n\">ψ.char.comp</span> <span class=\"o\">(</span><span class=\"n\">algebra.trace</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom.to_multiplicative</span>\n</code></pre></div>\n<p>But maybe it is a good compromise...</p>",
        "id": 292647054,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1660074928
    },
    {
        "content": "<p>In terms of the simplicity of the solution and the integration with existing API, I think this is really quite spectacular. Nice work!</p>",
        "id": 292647864,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660075210
    },
    {
        "content": "<p>I think this is already the solution we use for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_valuation.has_coe_to_fun\">docs#add_valuation.has_coe_to_fun</a></p>",
        "id": 292664625,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660082369
    },
    {
        "content": "<p>Although your version of inserting the <code>of_add</code> is certainly nicer</p>",
        "id": 292664775,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660082434
    },
    {
        "content": "<p>This is now <a href=\"https://github.com/leanprover-community/mathlib/pull/16016\">#16016</a> (also a nice number...).</p>",
        "id": 292984333,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1660242616
    },
    {
        "content": "<p>It would be nice if someone could have a look at <a href=\"https://github.com/leanprover-community/mathlib/pull/16016\">#16016</a>. <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> ?</p>",
        "id": 293236169,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1660375509
    },
    {
        "content": "<p>\"Lint mathlib\" fails on <a href=\"https://github.com/leanprover-community/mathlib/pull/16016\">#16016</a> after the latest push with error message</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">curl</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">35</span><span class=\"o\">)</span> <span class=\"n\">OpenSSL</span> <span class=\"n\">SSL_connect</span><span class=\"o\">:</span> <span class=\"n\">Connection</span> <span class=\"n\">reset</span> <span class=\"kd\">by</span> <span class=\"n\">peer</span> <span class=\"k\">in</span> <span class=\"n\">connection</span> <span class=\"n\">to</span> <span class=\"n\">github.com</span><span class=\"o\">:</span><span class=\"mi\">443</span>\n<span class=\"n\">elan</span><span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"n\">failed</span><span class=\"o\">:</span> <span class=\"n\">curl</span> <span class=\"bp\">-</span><span class=\"n\">sSfL</span> <span class=\"bp\">-</span><span class=\"n\">o</span> <span class=\"bp\">/</span><span class=\"n\">dev</span><span class=\"bp\">/</span><span class=\"n\">null</span> <span class=\"bp\">-</span><span class=\"n\">w</span> <span class=\"bp\">%</span><span class=\"o\">{</span><span class=\"n\">url_effective</span><span class=\"o\">}</span> <span class=\"n\">https</span><span class=\"o\">:</span><span class=\"bp\">//</span><span class=\"n\">github.com</span><span class=\"bp\">/</span><span class=\"n\">leanprover</span><span class=\"bp\">/</span><span class=\"n\">elan</span><span class=\"bp\">/</span><span class=\"n\">releases</span><span class=\"bp\">/</span><span class=\"n\">latest</span>\n<span class=\"n\">curl</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">22</span><span class=\"o\">)</span> <span class=\"n\">The</span> <span class=\"n\">requested</span> <span class=\"n\">URL</span> <span class=\"n\">returned</span> <span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"mi\">404</span>\n<span class=\"n\">elan</span><span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"n\">failed</span><span class=\"o\">:</span> <span class=\"n\">curl</span> <span class=\"bp\">-</span><span class=\"n\">sSfL</span> <span class=\"n\">https</span><span class=\"o\">:</span><span class=\"bp\">//</span><span class=\"n\">github.com</span><span class=\"bp\">/</span><span class=\"n\">leanprover</span><span class=\"bp\">/</span><span class=\"n\">elan</span><span class=\"bp\">/</span><span class=\"n\">releases</span><span class=\"bp\">/</span><span class=\"n\">download</span><span class=\"bp\">/</span><span class=\"n\">latest</span><span class=\"bp\">/</span><span class=\"n\">elan</span><span class=\"bp\">-</span><span class=\"n\">x86_64</span><span class=\"bp\">-</span><span class=\"n\">unknown</span><span class=\"bp\">-</span><span class=\"n\">linux</span><span class=\"bp\">-</span><span class=\"n\">gnu.tar.gz</span> <span class=\"bp\">-</span><span class=\"n\">o</span> <span class=\"bp\">/</span><span class=\"n\">tmp</span><span class=\"bp\">/</span><span class=\"n\">tmp.97CY0BiNCz</span><span class=\"bp\">/</span><span class=\"n\">elan</span><span class=\"bp\">-</span><span class=\"n\">init.tar.gz</span>\n<span class=\"n\">Error</span><span class=\"o\">:</span> <span class=\"n\">Process</span> <span class=\"n\">completed</span> <span class=\"k\">with</span> <span class=\"n\">exit</span> <span class=\"n\">code</span> <span class=\"mi\">1</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>What can I do about this?</p>",
        "id": 293434290,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1660504577
    },
    {
        "content": "<p>I'm re-running the failed jobs for a second time now, and at least it doesn't fail after a few seconds. I'll keep my fingers crossed...</p>",
        "id": 293434925,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1660505124
    },
    {
        "content": "<p>OK, <a href=\"https://github.com/leanprover-community/mathlib/pull/16016\">#16016</a> is green again. Can it go on the merge queue now? <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> <br>\nSee also the discussion <a href=\"#narrow/stream/113488-general/topic/.60pnat.60.20vs.20.60.5Bfact.20.280.20.3C.20n.29.5D.60/near/293293368\">here</a>.</p>",
        "id": 293437856,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1660507483
    }
]
[
    {
        "content": "<p>On <a href=\"https://github.com/leanprover-community/mathlib/tree/dupuisf/gelfand_space_def\">branch#dupuisf/gelfand_space_def</a>, I found myself putting a <code>fun_like</code> instance on subtypes, like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">subtype.fun_like</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"bp\">$</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">fun_like</span> <span class=\"n\">F</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fun_like</span> <span class=\"o\">(</span><span class=\"n\">subtype</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">fun_like.coe</span> <span class=\"bp\">∘</span> <span class=\"n\">coe_subtype.coe</span><span class=\"o\">,</span>\n  <span class=\"n\">coe_injective'</span> <span class=\"o\">:=</span> <span class=\"n\">function.injective.comp</span> <span class=\"n\">fun_like.coe_injective'</span> <span class=\"n\">subtype.coe_injective</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>along with the same thing for the various hom classes I needed there, such as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">subtype.zero_hom_class</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">zero_hom_class</span> <span class=\"n\">F</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">zero_hom_class</span> <span class=\"o\">(</span><span class=\"n\">subtype</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map_zero</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">zero_hom_class.map_zero</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"n\">subtype.fun_like</span> <span class=\"n\">F</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"n\">p</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>It seems to work fine, though it did break a handful of proofs involving <code>coe_fn_coe_base'</code>. Is this a good idea, or am I doing something foolish here?</p>",
        "id": 273409065,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1645975644
    },
    {
        "content": "<p>The <code>fun_like</code> instance is probably a good idea! My criteria:</p>\n<ul>\n<li>is there a <code>has_coe_to_fun</code> instance already (yes, I think it's called something like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/coe_fn_trans\">docs#coe_fn_trans</a>) or would such an instance help produce natural notation?</li>\n<li>do we compare elements of this type for equality? (yes, since we have <code>coe_fn_coe_base'</code>)</li>\n</ul>",
        "id": 273415424,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1645983159
    },
    {
        "content": "<p>The only drawback I can imagine for the <code>zero_hom_class</code> is that we don't want to get expensive checks on the exact value of <code>p</code>, otherwise <code>simp</code> would become too slow. In this case we are completely generic in <code>p</code> so it is totally fine.</p>",
        "id": 273415493,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1645983250
    }
]
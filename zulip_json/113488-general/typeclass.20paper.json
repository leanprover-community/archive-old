[
    {
        "content": "<p>Hello Mathlib! As many of you know, <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> <span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> and I are writing a paper about our new typeclass resolution procedure for Lean4. We have a first draft and it would be great to get feedback, particularly from people who know more about Mathlib than they do about the internals of typeclass resolution. Here is a link: <a href=\"https://www.dropbox.com/s/5nxklkxvdh7xna9/typeclass.pdf?dl=0\" target=\"_blank\" title=\"https://www.dropbox.com/s/5nxklkxvdh7xna9/typeclass.pdf?dl=0\">https://www.dropbox.com/s/5nxklkxvdh7xna9/typeclass.pdf?dl=0</a> Thanks in advance.</p>\n<div class=\"message_inline_ref\"><a href=\"https://www.dropbox.com/s/5nxklkxvdh7xna9/typeclass.pdf?dl=0\" target=\"_blank\" title=\"typeclass.pdf\"><img src=\"https://www.dropbox.com/static/images/spectrum-icons/generated/content/content-pdf-large.png\"></a><div><div class=\"message_inline_image_title\">typeclass.pdf</div><desc class=\"message_inline_image_desc\"></desc></div></div>",
        "id": 185313688,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1578666307
    },
    {
        "content": "<p>Do you have a submission/feedback deadline? I'd love to take a look but might not find time until next week.</p>",
        "id": 185314530,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1578666896
    },
    {
        "content": "<p>We are submitting to IJCAR 2020, January 23rd deadline</p>",
        "id": 185314592,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1578666933
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> See <a href=\"https://www.math.sciences.univ-nantes.fr/~gouezel/\" target=\"_blank\" title=\"https://www.math.sciences.univ-nantes.fr/~gouezel/\">https://www.math.sciences.univ-nantes.fr/~gouezel/</a> for how to spell <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span>'s name outside of Zulip <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 185318515,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578669327
    },
    {
        "content": "<blockquote>\n<p>Thus even though e.g. lists and multisets may usefully coerce into each other, one direction must be chosen arbitrarily for the Coe instance and the other must be sacrificed.</p>\n</blockquote>\n<p>How do you coerce a multiset into a list? You've lost the ordering... Do you want \"multisets\" and \"finsets\"? (Note that the generic mathematical reader won't recognize \"finset\", but then, they aren't your target audience anyway.)</p>",
        "id": 185320293,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578670450
    },
    {
        "content": "<p>Also... you talk about coercions between \"bijective\" types. But for example <code>multiset</code> and <code>finset</code> are not bijective. It's just that there are natural maps in both directions, but those maps are not bijections.</p>",
        "id": 185320352,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578670503
    },
    {
        "content": "<p>Minor comment:</p>\n<blockquote>\n<p>allows reducing the scalars in a module</p>\n</blockquote>\n<p>It's <em>restricting</em> scalars, not \"reducing\"</p>",
        "id": 185320490,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578670595
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> Is this new typeclass resolution procedure implemented in Lean4 or in C++?</p>",
        "id": 185321363,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578671153
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"230999\">Daniel Selsam</span> Is this new typeclass resolution procedure implemented in Lean4 or in C++?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> in Lean4: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Init/Lean/Meta/SynthInstance.lean\" target=\"_blank\" title=\"https://github.com/leanprover/lean4/blob/master/src/Init/Lean/Meta/SynthInstance.lean\">https://github.com/leanprover/lean4/blob/master/src/Init/Lean/Meta/SynthInstance.lean</a></p>",
        "id": 185321667,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1578671348
    },
    {
        "content": "<p>Ok, cool!</p>",
        "id": 185321716,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578671393
    },
    {
        "content": "<p>Is there a way to deal with diamonds that prop-eq but not def-eq?</p>",
        "id": 185321840,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578671481
    },
    {
        "content": "<p>For example, Chris mentioned the other day that we'll get two <code>algebra ℚ ℂ</code> instances. But we know that <code>algebra ℚ K</code> is a subsingleton, so they must be prop-eq.</p>",
        "id": 185322040,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578671607
    },
    {
        "content": "<p>What do you mean by \"deal with\"? What are you afraid will happen, and what do you want to happen?</p>",
        "id": 185322170,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1578671659
    },
    {
        "content": "<p>But maybe this is not something that the typeclass resolution should deal with, but another part of the system.</p>",
        "id": 185322179,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578671664
    },
    {
        "content": "<p>I might claim that <code>algebra_map x = algebra_map x</code>, but both sides might find different instances (especially if the expressions are a bit more complicated and not syntactically equal).</p>",
        "id": 185322321,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578671757
    },
    {
        "content": "<p>And so Lean will refuse, because the <code>algebra_map</code>s come from different instances.</p>",
        "id": 185322386,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578671781
    },
    {
        "content": "<p>But since those instances are prop-eq, we are a silly rw away from moving forward.</p>",
        "id": 185322425,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578671812
    },
    {
        "content": "<p>But I realize now that this is not a problem that you hit during tc resolution, but during type checking</p>",
        "id": 185322480,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578671859
    },
    {
        "content": "<p>So I guess it's a bit off topic in this thread.</p>",
        "id": 185322562,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578671892
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> Section 5.3 ends with a parenthetical remark (that is not properly</p>",
        "id": 185322677,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578671985
    },
    {
        "content": "<p>I have been pushing frequent fixes, including the 5.3 issue. Please reload the page.</p>",
        "id": 185322808,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1578672039
    },
    {
        "content": "<p>If 5.3 still trails off for you after reloading, you may need to click some kind of \"jump to most recent version of paper\" button.</p>",
        "id": 185322908,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1578672106
    },
    {
        "content": "<blockquote>\n<p>But I realize now that this is not a problem that you hit during tc resolution, but during type checking</p>\n</blockquote>\n<p>This example is outside the scope of tc resolution, since presumably the two calls to tc are independent. There is a related issue we have discussed about TC though: whether to consider a second solution to the same (sub)goal to be a repeat (and so discard it) if it has the same type as the first solution, even if it is not definitionally equal to the first solution.</p>",
        "id": 185323900,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1578672677
    },
    {
        "content": "<p>Our current plan is to say that typeclasses are \"morally canonical\", and consider a solution (to a subgoal) to be a repeat if it has the same type as a previous solution.</p>",
        "id": 185324025,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1578672741
    },
    {
        "content": "<p>The \"morally canonical\" assumption would be violated by <code>Algebra</code>, and some downstream goals may succeed or fail depending on which specific instance to <code>Algebra</code> is found first.</p>",
        "id": 185324260,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1578672876
    },
    {
        "content": "<p>Aah, it might be that it still pops up here...</p>",
        "id": 185324441,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578672986
    },
    {
        "content": "<p>Note that in general <code>Algebra R A</code> is not a subsingleton... but if <code>R</code> is <code>\\Z</code> or <code>\\Q</code>, then it is...</p>",
        "id": 185324471,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578673019
    },
    {
        "content": "<p>Edited my comment -- the assumption is violated whether or not Algebra is a subsingleton.</p>",
        "id": 185324520,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1578673058
    },
    {
        "content": "<p>By transitivity <code>algebra R A</code> and <code>f</code> will give me another instance of <code>algebra R B</code>, and by some property field of <code>alg_hom</code> we know that <code>f</code> ensures it is prop-eq to the existing instance of <code>algebra R B</code>.<br>\nMathematicians treat these instances as def-eq all the time.</p>",
        "id": 185324863,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578673252
    },
    {
        "content": "<p>Or if <code>R</code> is any field</p>",
        "id": 185324875,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578673258
    },
    {
        "content": "<p>Suppose we have <code>algebra R A</code>, <code>algebra R B</code> and <code>f : alg_hom[R] A B</code> in the context.</p>",
        "id": 185324877,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578673261
    },
    {
        "content": "<p>Oops... messages are mangled up by German telecom</p>",
        "id": 185324902,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578673281
    },
    {
        "content": "<p>Can you come up with an example where typeclass resolution will succeed or fail depending on which of two different instances with the same type are discovered first for some subgoal?</p>",
        "id": 185325802,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1578673789
    },
    {
        "content": "<p>How about I try to come up with a toy example first to make the issue clear, and then you can try to come up with a real example that would exhibit the same problem.</p>",
        "id": 185326046,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1578673900
    },
    {
        "content": "<p>I don't think typeclass inference fails in these situations, the problem tends to be that it infers two different instances in different situations, so terms that look the same, and are in fact equal aren't definitionally equal, so <code>exact</code> doesn't work when it looks like it should.</p>",
        "id": 185328210,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1578675104
    },
    {
        "content": "<p>Very artificial example but just to give intuition:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span>\n<span class=\"n\">class</span> <span class=\"n\">Bar</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"o\">())</span>\n<span class=\"n\">class</span> <span class=\"n\">Rig</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"o\">())</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">FooToBar</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">Foo</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span>\n<span class=\"kn\">instance</span> <span class=\"n\">BarToRig</span> <span class=\"o\">[</span><span class=\"n\">Bar</span> <span class=\"n\">true</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Rig</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">FooTrue</span>  <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">}</span>\n<span class=\"kn\">instance</span> <span class=\"n\">FooFalse</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- There are two instances to Foo with different values.</span>\n<span class=\"c1\">-- Since they have the same type, the second one found is discarded.</span>\n<span class=\"c1\">-- The overall query succeeds only if the first one found happens to be `FooTrue`.</span>\n\n<span class=\"n\">def</span> <span class=\"n\">synthRig</span> <span class=\"o\">[</span><span class=\"n\">Rig</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"o\">()</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">synthRig</span>\n</pre></div>",
        "id": 185328504,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1578675248
    },
    {
        "content": "<blockquote>\n<p>I don't think typeclass inference fails in these situations, the problem tends to be that it infers two different instances in different situations, so terms that look the same, and are in fact equal aren't definitionally equal, so <code>exact</code> doesn't work when it looks like it should.</p>\n</blockquote>\n<p>I agree with <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> that the issue you are describing is probably better addressed after the fact, outside of typeclass resolution. Note that Lean3 had a subsingleton-canonicalizer which would address this problem.</p>",
        "id": 185328736,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1578675411
    },
    {
        "content": "<p>Here's an example that comes up in practice</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">constant</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"n\">class</span><span class=\"o\">]</span> <span class=\"n\">fintype</span>\n\n<span class=\"n\">def</span> <span class=\"n\">card</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">constant</span> <span class=\"n\">fintype_range</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"err\">↥</span><span class=\"n\">p</span>\n\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"n\">fintype_range</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">subset_lemma</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">card</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">card</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">card</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">card</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"n\">f</span><span class=\"o\">):=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">subset_lemma</span><span class=\"o\">],</span> <span class=\"c1\">--fails</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 185329385,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1578675877
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> Thanks. I don't think this is an issue with typeclass resolution though. Higher-level tactics can be made to hide this kind of complication, similar to the way <code>simp</code> does.</p>",
        "id": 185345362,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1578686249
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> Note that the Diamond problem has been around a while. Symbolics Common Lisp solved this using the \"Mixin\" idea (<a href=\"https://en.wikipedia.org/wiki/Mixin\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Mixin\">https://en.wikipedia.org/wiki/Mixin</a>) in its Flavors implementation. Common Lisp Object System (CLOS) has rules (<a href=\"http://www.lambdafaq.org/how-are-conflicting-method-declarations-resolved\" target=\"_blank\" title=\"http://www.lambdafaq.org/how-are-conflicting-method-declarations-resolved\">http://www.lambdafaq.org/how-are-conflicting-method-declarations-resolved</a>).</p>",
        "id": 185362526,
        "sender_full_name": "Tim Daly",
        "timestamp": 1578700267
    },
    {
        "content": "<p>Also note that CLOS checks class precedence to check for the cycle problem.</p>",
        "id": 185370110,
        "sender_full_name": "Tim Daly",
        "timestamp": 1578710549
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"223495\">@Tim Daly</span> Is there any reason to think that diamonds in those systems can be dealt with in the same way as diamonds in the algebraic hierarchy of an interactive theorem prover? Intuitively it feels to me like they might need different solutions.</p>",
        "id": 185375312,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578720213
    },
    {
        "content": "<p>Axiom struggled with similar problems. Here is an abbreviated form of Axiom's typeclasses: <a href=\"https://github.com/daly/PDFS/blob/master/endpaper.pdf\" target=\"_blank\" title=\"https://github.com/daly/PDFS/blob/master/endpaper.pdf\">https://github.com/daly/PDFS/blob/master/endpaper.pdf</a> and the full form (with typeclass abbreviated names): <a href=\"http://axiom-developer.org/axiom-website/bookvol10.2abb.html\" target=\"_blank\" title=\"http://axiom-developer.org/axiom-website/bookvol10.2abb.html\">http://axiom-developer.org/axiom-website/bookvol10.2abb.html</a></p>",
        "id": 185378278,
        "sender_full_name": "Tim Daly",
        "timestamp": 1578726382
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> If you have a function with the same name and same signature but different semantics available on two different paths there are various schemes to resolve them. Axiom knows that a function FOO on the path from typeclass X can be different from FOO on the path from typeclass Y. The compiler will complain. But you can be explicit FOO$X or FOO$Y where the $ operator explicitly says \"use this typeclass\"</p>",
        "id": 185378404,
        "sender_full_name": "Tim Daly",
        "timestamp": 1578726653
    },
    {
        "content": "<p>How is that remark relevant  to my reply to your remark about how lisp flavours solved the diamond problem?</p>",
        "id": 185378732,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578727333
    },
    {
        "content": "<p>Sorry, I thought the referenced Wikipedia article covered that question. Flavors was merged into the Common Lisp standard as the Common Lisp Object System (CLOS) </p>\n<p>\"CLOS allows multiple inheritance. When the default order in which methods are executed in multiple inheritance is not correct, the programmer may resolve the diamond inheritance problems by specifying the order of method combinations\".</p>\n<p>\"CLOS attempts to provide both reasonable default behavior and the ability to override it... by giving a specific method resolution order or stating a rule for combining methods. This is called 'method combination', which may be fully controlled. The MOP (metaobject protocol) also provides means to modify the inheritance, dynamic dispatch, class instantiation, and other internal mechanisms without affecting the stability of the system.\"</p>\n<p>Essentially the CLOS programmer can specify their own method of solving the diamond problem by writing 'method combinators'. So you can override the system-provided version in a specific case if you need to. This was derived from the Symbolics Flavors system.</p>",
        "id": 185380831,
        "sender_full_name": "Tim Daly",
        "timestamp": 1578731842
    },
    {
        "content": "<p>See <a href=\"http://www.bracha.org/oopsla90.pdf\" target=\"_blank\" title=\"http://www.bracha.org/oopsla90.pdf\">http://www.bracha.org/oopsla90.pdf</a> ... Mixin-based Inheritance</p>",
        "id": 185380934,
        "sender_full_name": "Tim Daly",
        "timestamp": 1578732013
    },
    {
        "content": "<p>Axiom's approach is \"Well, you've got two functions from different paths with the same signature. That's fine but you have to tell me which one you mean when you decide to use it.\"</p>",
        "id": 185381102,
        "sender_full_name": "Tim Daly",
        "timestamp": 1578732449
    },
    {
        "content": "<p>If Lean were implemented in Common Lisp it would be much easier to resolve certain problems. (Disclosure: I'm a lisper, in case that isn't obvious)</p>",
        "id": 185381157,
        "sender_full_name": "Tim Daly",
        "timestamp": 1578732567
    },
    {
        "content": "<p>Lean could adopt the approach of specifying not only the name of the function but, if there are duplicates, also specifying the particular typeclass (otherwise complain).</p>",
        "id": 185381219,
        "sender_full_name": "Tim Daly",
        "timestamp": 1578732695
    },
    {
        "content": "<blockquote>\n<p>If Lean were implemented in Common Lisp it would be much easier to resolve certain problems. (Disclosure: I'm a lisper, in case that isn't obvious)</p>\n</blockquote>\n<p>Too bad (for you) that most of Lean4 is implemented in Lean4...</p>",
        "id": 185381893,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578734106
    },
    {
        "content": "<p>In Lean it is always possible to explicitly provide the type class. So I think all of the things you've described are already available. The point is (mostly) that we want things to be fast.</p>",
        "id": 185381898,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578734162
    },
    {
        "content": "<p>My remark was that mathlib's diamonds are probably the same kind as those in Lisp, but considerably more complex.</p>",
        "id": 185381942,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578734214
    },
    {
        "content": "<p>Actually, that's a huge win. I'm looking forward to seeing the implementation.</p>",
        "id": 185382597,
        "sender_full_name": "Tim Daly",
        "timestamp": 1578735504
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"223495\">@Tim Daly</span> Thanks for sharing the links. We seem to be using the phrase <em>diamond problem</em> to mean slightly different things.  In Lean, in the common case, all the different paths through the diamond towers lead to the same implementation.  So, deciding among alternative implementations is not the main challenge. The problem is that towers of diamonds in the instance graph induce an exponential number of paths, and without care, certain queries will spend exponential time traversing these paths. The diamond problem for us is purely a performance problem.</p>",
        "id": 185389661,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1578748966
    },
    {
        "content": "<p>The term 'diamond problem' has a long history. You might want to be very clear up front to distinguish your problem from the other uses of the term.</p>",
        "id": 185390666,
        "sender_full_name": "Tim Daly",
        "timestamp": 1578750748
    },
    {
        "content": "<p>If your problem is only that you might encounter the same object on different paths, it might help to memoize the path information so you never traverse it more than once. I will reread the paper with your new definition. I assumed more about the problem than you wrote I guess. My apology for the mistake.</p>",
        "id": 185390808,
        "sender_full_name": "Tim Daly",
        "timestamp": 1578751064
    },
    {
        "content": "<p>Also Rust is another language using type classes or something similar.  Is any of this a concern there?</p>",
        "id": 185391293,
        "sender_full_name": "Jason Rute",
        "timestamp": 1578751882
    },
    {
        "content": "<p>In Scala, <em>implicits</em> are similar to Lean's type classes. They are used  to support ad-hoc polymorphism, coercion, and true-type classes.  They also have a similar syntax to Lean.  I know they are one fo the things which makes compiling Scala so slow, particularly because of <em>implicit macros</em>, which are the Scala analogue of instances depending on other instances.  Do you know off-hand if your method can be used to speed up implicit resolution in Scala?  (Or if Scala uses a method similar to yours already?)  I know the implicit resolution in Scala has some additional concerns such as trying to resolve implicits in closer levels of scope first.  Also, I haven't checked for sure that diamonds or loops are allowed in implicit macros.  Last, I don't know for sure that the slow down in implicit search in practice is due to an exponential search tree or if it is due to the execution time of the code in the implicit macros.  Just curious if you have any thoughts on this.</p>",
        "id": 185391928,
        "sender_full_name": "Jason Rute",
        "timestamp": 1578752842
    },
    {
        "content": "<p>(Due to the Zulip mobile app issues, my messages got reversed.)</p>",
        "id": 185391976,
        "sender_full_name": "Jason Rute",
        "timestamp": 1578752893
    },
    {
        "content": "<p>Actually, I just checked with some Scala code.  Diamonds are allowed in Scala in the sense that you can write the code.  However, implicit search will fall if it finds two ways to resolve the same implicit at the same level of scope, so if the top of the diamond is inhabited, it will complain that there are two ways to match the expected type (even if they evaluate the same).  This must mean it is checking all the paths (at least until it finds two satisfied paths).  In that case, I hope it is doing something similar to your method or it could be checking an exponential number of paths.</p>",
        "id": 185392639,
        "sender_full_name": "Jason Rute",
        "timestamp": 1578754171
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> Thanks. I have never used Scala and know very little about it. Could you please share your diamond example?</p>",
        "id": 185392767,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1578754387
    },
    {
        "content": "<p>You can paste this into a scala REPL.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">// The classes</span>\n<span class=\"k\">case</span> <span class=\"k\">class</span> <span class=\"nc\">A</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"k\">:</span> <span class=\"kt\">Int</span><span class=\"o\">)</span>  <span class=\"c1\">// this like a structure type</span>\n<span class=\"k\">case</span> <span class=\"k\">class</span> <span class=\"nc\">B</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"k\">:</span> <span class=\"kt\">Int</span><span class=\"o\">)</span>\n<span class=\"k\">case</span> <span class=\"k\">class</span> <span class=\"nc\">C</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"k\">:</span> <span class=\"kt\">Int</span><span class=\"o\">)</span>\n<span class=\"k\">case</span> <span class=\"k\">class</span> <span class=\"nc\">D</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"k\">:</span> <span class=\"kt\">Int</span><span class=\"o\">)</span>\n\n<span class=\"c1\">// the implicit macros</span>\n<span class=\"k\">implicit</span> <span class=\"k\">def</span> <span class=\"n\">dToC</span><span class=\"o\">(</span><span class=\"k\">implicit</span> <span class=\"n\">d</span><span class=\"k\">:</span> <span class=\"kt\">D</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">C</span> <span class=\"o\">=</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">.</span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"k\">implicit</span> <span class=\"k\">def</span> <span class=\"n\">dToB</span><span class=\"o\">(</span><span class=\"k\">implicit</span> <span class=\"n\">d</span><span class=\"k\">:</span> <span class=\"kt\">D</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">B</span> <span class=\"o\">=</span> <span class=\"n\">B</span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">.</span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"k\">implicit</span> <span class=\"k\">def</span> <span class=\"n\">bToA</span><span class=\"o\">(</span><span class=\"k\">implicit</span> <span class=\"n\">b</span><span class=\"k\">:</span> <span class=\"kt\">B</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">A</span> <span class=\"o\">=</span> <span class=\"n\">A</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"k\">implicit</span> <span class=\"k\">def</span> <span class=\"n\">cToA</span><span class=\"o\">(</span><span class=\"k\">implicit</span> <span class=\"n\">c</span><span class=\"k\">:</span> <span class=\"kt\">C</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">A</span> <span class=\"o\">=</span> <span class=\"n\">A</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"c1\">// case 1: only one valid path.  This block will return A(42)</span>\n<span class=\"o\">{</span>  <span class=\"c1\">// restrict scope</span>\n  <span class=\"k\">implicit</span> <span class=\"k\">val</span> <span class=\"n\">b</span><span class=\"k\">:</span> <span class=\"kt\">B</span> <span class=\"o\">=</span> <span class=\"n\">B</span><span class=\"o\">(</span><span class=\"mi\">42</span><span class=\"o\">)</span>\n <span class=\"c1\">// can use implicitly to check implicit implicit resolution &quot;def implicitly[T](implicit t : T): T = T&quot;</span>\n <span class=\"n\">implicitly</span><span class=\"o\">[</span><span class=\"kt\">A</span><span class=\"o\">]</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// case 2: two valid paths which meet together.  This will fail.</span>\n<span class=\"o\">{</span>  <span class=\"c1\">// restrict scope</span>\n  <span class=\"k\">implicit</span> <span class=\"k\">val</span> <span class=\"n\">d</span><span class=\"k\">:</span> <span class=\"kt\">D</span> <span class=\"o\">=</span> <span class=\"n\">D</span><span class=\"o\">(</span><span class=\"mi\">42</span><span class=\"o\">)</span>\n  <span class=\"n\">implicitly</span><span class=\"o\">[</span><span class=\"kt\">A</span><span class=\"o\">]</span>   <span class=\"c1\">// compiler will complain about &quot;ambiguous implicit values&quot;</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// case 3: two valid paths (one which extends the other). This will succeed and return A(43)</span>\n<span class=\"o\">{</span>  <span class=\"c1\">// restrict scope</span>\n  <span class=\"k\">implicit</span> <span class=\"k\">val</span> <span class=\"n\">b</span><span class=\"k\">:</span> <span class=\"kt\">B</span> <span class=\"o\">=</span> <span class=\"n\">B</span><span class=\"o\">(</span><span class=\"mi\">42</span><span class=\"o\">)</span>\n  <span class=\"k\">implicit</span> <span class=\"k\">val</span> <span class=\"n\">d</span><span class=\"k\">:</span> <span class=\"kt\">D</span> <span class=\"o\">=</span> <span class=\"n\">D</span><span class=\"o\">(</span><span class=\"mi\">43</span><span class=\"o\">)</span>\n  <span class=\"n\">implicitly</span><span class=\"o\">[</span><span class=\"kt\">A</span><span class=\"o\">]</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// case 3: two valid paths not extending each other. This will fail.</span>\n<span class=\"o\">{</span>  <span class=\"c1\">// restrict scope</span>\n  <span class=\"k\">implicit</span> <span class=\"k\">val</span> <span class=\"n\">b</span><span class=\"k\">:</span> <span class=\"kt\">B</span> <span class=\"o\">=</span> <span class=\"n\">B</span><span class=\"o\">(</span><span class=\"mi\">42</span><span class=\"o\">)</span>\n  <span class=\"k\">implicit</span> <span class=\"k\">val</span> <span class=\"n\">c</span><span class=\"k\">:</span> <span class=\"kt\">C</span> <span class=\"o\">=</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"mi\">43</span><span class=\"o\">)</span>\n  <span class=\"n\">implicitly</span><span class=\"o\">[</span><span class=\"kt\">A</span><span class=\"o\">]</span>   <span class=\"c1\">// compiler will complain about &quot;ambiguous implicit values&quot;</span>\n<span class=\"o\">}</span>\n</pre></div>",
        "id": 185393609,
        "sender_full_name": "Jason Rute",
        "timestamp": 1578755853
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> Thank you very much. I just confirmed that it also scales exponentially on the tower of (failing) diamonds.</p>",
        "id": 185395015,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1578758365
    },
    {
        "content": "<p>I am not sure if it merits putting in the paper though. For all I know, their instance logic may be simple enough that relatively naive caching would address this. And I doubt it is a problem in practice for them.</p>",
        "id": 185395083,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1578758450
    },
    {
        "content": "<p>Haskell is the same boat. We discuss and compare against Haskell mainly due its historical significance in pioneering typeclasses. I suspect Haskell could implement a simple caching scheme, and I highly doubt it would make sense for them to implement tabled resolution.</p>",
        "id": 185395152,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1578758580
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> Thanks for sharing the paper, it's very nice. Very excited to use the new procedure in Lean 4. I have some minor line comments on the paper I'll send you directly, but a few more general points:</p>\n<ul>\n<li>\n<p>One of the frustrating parts of Lean 3 type class resolution is error reporting. To some extent I think this is inherent in the algorithm, it can be hard to localize what goes wrong. I wonder if this gets better or worse with tabled resolution. Is this something you've thought about at all and is there anything worth saying in the paper? I'd be very interested to read a paragraph on this in section 5.5 if there is.</p>\n</li>\n<li>\n<p>Both appear in the literature, but \"type class\" seems to be more common than \"typeclass\" (except maybe surrounding Coq). Any reason to prefer the latter?</p>\n</li>\n<li>\n<p>There might not be space, but I'd be curious to see one or two more examples at the end, eg the frustrating int coe issue we had in mathlib. I don't think it fits the same pattern as the tower of diamonds. (edit - thinking harder, maybe it is essentially the same idea?)</p>\n</li>\n<li>\n<p>Mathlib is dropped in toward the beginning without introduction. One of the reasons we wrote the mathlib paper was just for this reason, so we can cite it without describing it!</p>\n</li>\n</ul>",
        "id": 185842670,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1579198437
    },
    {
        "content": "<p>Another question that Coq users keep asking whenever we mention type class resolution. Will we have <a href=\"https://en.wikipedia.org/wiki/Cut_(logic_programming)\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Cut_(logic_programming)\">cuts</a>?</p>",
        "id": 185842835,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1579198538
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> To the best of my knowledge, nobody has yet brought to our attention any issue that cuts might help address, so we haven't considered it.</p>",
        "id": 185846970,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1579200993
    },
    {
        "content": "<blockquote>\n<p>Mathlib is dropped in toward the beginning without introduction. One of the reasons we wrote the mathlib paper was just for this reason, so we can cite it without describing it!</p>\n</blockquote>\n<p>Funny, I thought we cited the Mathlib paper in both the abstract and the introduction, but we don't seem to cite it all... <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> ... must have gotten lost during refactoring. Great catch!</p>",
        "id": 185847550,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1579201333
    },
    {
        "content": "<blockquote>\n<p>One of the frustrating parts of Lean 3 type class resolution is error reporting. To some extent I think this is inherent in the algorithm, it can be hard to localize what goes wrong. I wonder if this gets better or worse with tabled resolution. Is this something you've thought about at all and is there anything worth saying in the paper? I'd be very interested to read a paragraph on this in section 5.5 if there is.</p>\n</blockquote>\n<p>This is an interesting question. Tracing and error reporting for typeclass resolution will be <em>way</em> better in Lean4, not because of the tabled typeclass resolution procedure but because of a much better system-wide tracing framework. I think tabling will help as well, but not for any deep reason -- mainly just because the traces will be that much shorter (in some cases, exponentially shorter). I don't think this is a paper-worthy insight though.</p>",
        "id": 185848459,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1579201862
    },
    {
        "content": "<p>The discrimination trees (S5.3, indexing the instances) will shrink the traces a lot too. Lean3 tries to resolve every goal with every instance whose result type has the same head symbol, and the vast majority of these attempts fail. Lean4 will only try a much smaller superset of the instances that will successfully resolve.</p>",
        "id": 185848799,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1579202097
    },
    {
        "content": "<blockquote>\n<p>the frustrating int coe issue we had in mathlib</p>\n</blockquote>\n<p>AFAICT this issue is just the \"succeeding diamond following by failing downstream goal\" variant of the diamond problem, which will be solved by tabling (and is also solved by Coq's short-circuit trick). However, even without the exponential blowup, typeclass resolution still does need to do search, so the \"most-constrained variable first\" advice you gave in Zulip awhile back is still sound.</p>",
        "id": 185850707,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1579203142
    },
    {
        "content": "<blockquote>\n<p>Both appear in the literature, but \"type class\" seems to be more common than \"typeclass\" (except maybe surrounding Coq). Any reason to prefer the latter?</p>\n</blockquote>\n<p>I prefer \"typeclass\", since typeclass is a distinct concept from the compositional meaning of \"type class\". I also always write \"datastructure\" as opposed to \"data structure\" for the same reason.</p>",
        "id": 185851275,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1579203525
    },
    {
        "content": "<blockquote>\n<p>To the best of my knowledge, nobody has yet brought to our attention any issue that cuts might help address, so we haven't considered it.</p>\n</blockquote>\n<p>I know nothing about this, I'm only repeating questions I heard <span class=\"user-mention\" data-user-id=\"110193\">@Cyril Cohen</span> and <span class=\"user-mention\" data-user-id=\"110172\">@Assia Mahboubi</span> asking.</p>",
        "id": 185858514,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1579207898
    },
    {
        "content": "<p>I see, thanks for clarifying! With the error reporting, my hope was that it might be possible to extract some kind of list of possible missing instances from the info in the table. I don't have any real proposal on how to do this; it just seems more plausible than with the old method. Maybe it's really just a matter of size. Either way, it does sound like the new approach will be way easier to work with. So thanks again.</p>",
        "id": 185858791,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1579208049
    },
    {
        "content": "<p>There could be some heuristics like reporting the \"deepest\" failing goal as the \"most likely point of failure\". This is relatively independent of the actual algorithm, could be worth an experiment at some point.</p>",
        "id": 185860924,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1579209180
    },
    {
        "content": "<blockquote>\n<p>There could be some heuristics like reporting the \"deepest\" failing goal as the \"most likely point of failure\". This is relatively independent of the actual algorithm, could be worth an experiment at some point.</p>\n</blockquote>\n<p>Depth is not as straightforward a concept in tabled resolution as it is in SLD.</p>",
        "id": 185867331,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1579212705
    },
    {
        "content": "<p>Hi, not only cuts are a good tool to control the behavior of backtracking during proof search, but they are also a good tool for debugging, in order to find in which branch the problems are actually happening, and to get a cleaner trace.</p>",
        "id": 185899823,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1579253304
    },
    {
        "content": "<blockquote>\n<p>Hi, not only cuts are a good tool to control the behavior of backtracking during proof search, but they are also a good tool for debugging, in order to find in which branch the problems are actually happening, and to get a cleaner trace.</p>\n</blockquote>\n<p>My hope is that typeclass resolution will be so fast in mathlib4 that there will be no need try to improve performance further using <code>cut</code>. As for debugging, in Lean4, the trace messages are collected in a datastructure, and users will be able to write their owns scripts for traversing and filtering the traces as they desire.</p>",
        "id": 185950466,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1579290846
    },
    {
        "content": "<p>I'm new here. Thanks for the nice paper!<br>\nI understand lean does not use canonical structures. Can anyone clarify, as they are popular in Coq (math-comp)</p>\n<p>This should probably go somewhere else, but I'd like to understand more about congruence, and more generally automation in lean.<br>\nIs the congruence paper still the best reference?</p>",
        "id": 186119148,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1579540106
    },
    {
        "content": "<p>The short explanation is that type classes perform the corresponding function</p>",
        "id": 186130428,
        "sender_full_name": "Reid Barton",
        "timestamp": 1579551521
    },
    {
        "content": "<blockquote>\n<p>I'm new here. Thanks for the nice paper!<br>\nI understand lean does not use canonical structures. Can anyone clarify, as they are popular in Coq (math-comp)</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> Welcome! Typeclasses are remarkably simple and versatile, and (at least with tabling) seem to work extremely well for zillions of diverse uses. Do you see any major advantages offered by canonical structures?</p>",
        "id": 186148438,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1579574950
    },
    {
        "content": "<blockquote>\n<p>This should probably go somewhere else, but I'd like to understand more about congruence, and more generally automation in lean.<br>\nIs the congruence paper still the best reference?</p>\n</blockquote>\n<p>We haven't started building automation for Lean4 yet. Note that the congruence closure procedure from IJCAR2016 doesn't seem to be that popular in mathlib --- the main workhorse has been the simplifier. We are not currently planning many changes to the simplifier, though our preliminary experiments suggest that we may be able to improve its performance by 10-100x. Mathlib also includes many diverse, interesting tactics written by users. You may want to ask a mathlib power-user to give you a tour.</p>",
        "id": 186149253,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1579576099
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> Can you give any clues as to where the 10x performance improvement in <code>simp</code> is likely to come from?</p>",
        "id": 186149566,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1579576668
    },
    {
        "content": "<p>Already indexing <code>simp</code> lemmas with discrimation trees should make a big difference. Right now, if you have a lemma of the same <code>@coe (list a) (multiset a) xs = ...</code>, it is simply indexed by the function name <code>coe</code>. With a discrimination tree, you can have the index distinguish between <code>@coe (list a) (multiset a) xs</code> and <code>@coe nat int n</code>. Where as the Lean 3 solution gives us hundreds of collisions for <code>coe</code>, the Lean 4 solution should narrow down the search more aggressively before trying to apply rewrite rules.</p>",
        "id": 186151247,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1579578986
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> do you know what happened to <a href=\"https://github.com/leanprover/lean/wiki/Simplifier-Features\" target=\"_blank\" title=\"https://github.com/leanprover/lean/wiki/Simplifier-Features\">https://github.com/leanprover/lean/wiki/Simplifier-Features</a>? It seemed to have many ideas to improve the simplifier. Note that most of it is covered by the golden rule of automation: compare with Isabelle.</p>",
        "id": 186163436,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1579596380
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"230999\">Daniel Selsam</span> Can you give any clues as to where the 10x performance improvement in <code>simp</code> is likely to come from?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> By far the single biggest speedup will come from better caching of the simp sets. Last I checked, building mathlib involves ~70 minutes of building simp sets but only ~25 minutes inside the actual simplifier. A second big speedup will come from using discrimination trees instead of head maps as <span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> said. A third will come from being more careful not to accidentally traverse huge terms (e.g. by eagerly reducing projections and abstracting all proof terms).</p>",
        "id": 186172293,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1579604468
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"230999\">Daniel Selsam</span> do you know what happened to <a href=\"https://github.com/leanprover/lean/wiki/Simplifier-Features\" target=\"_blank\" title=\"https://github.com/leanprover/lean/wiki/Simplifier-Features\">https://github.com/leanprover/lean/wiki/Simplifier-Features</a>? It seemed to have many ideas to improve the simplifier. Note that most of it is covered by the golden rule of automation: compare with Isabelle.</p>\n</blockquote>\n<p>I was not aware of this document. Thank you for sharing.</p>",
        "id": 186172597,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1579604713
    },
    {
        "content": "<p>Here's a problem with the fully unbundled approach. The term size can blow up, so we need a mechanism to go between bundled and unbundled structures. My understanding is that you are using the (mostly) unbundled approach in lean.<br>\nI believe this is also a main argument by the math-comp group to use canonical structures.<br>\nIt has been argued that we'd need general unification hints to get the best of both worlds (type classes and canonical structures)<br>\n<a href=\"https://coq.discourse.group/t/blog-post-exponential-blowup-when-using-unbundled-typeclasses-to-model-algebraic-hierarchies/289/2\" target=\"_blank\" title=\"https://coq.discourse.group/t/blog-post-exponential-blowup-when-using-unbundled-typeclasses-to-model-algebraic-hierarchies/289/2\">https://coq.discourse.group/t/blog-post-exponential-blowup-when-using-unbundled-typeclasses-to-model-algebraic-hierarchies/289/2</a></p>",
        "id": 186204508,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1579626672
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> Note that Lean 3 does not use the fully unbundled approach. We use a partially bundled approach (for most classes in the algebraic hierarchy only the type is an argument to the class). This doesn't have the exponential blowup problem. This was also discussed here:<br>\n<a href=\"#narrow/stream/113488-general/topic/what.20is.20a.20diamond.3F\" title=\"#narrow/stream/113488-general/topic/what.20is.20a.20diamond.3F\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what.20is.20a.20diamond.3F</a></p>\n<p>There are problems with canonical structures as well. One thing I dislike about canonical structures is the amount of boilerplate code you have to write to add a new structure to the hierarchy (for example, the number of unification hints you have to explicitly declare is quadratic in the number of structures, and forgetting one can cause hard-to-debug errors).<br>\nCombining both type classes and canonical structures in a library sounds very dangerous: it sounds a lot more manageable to stick with a single approach, than continually translating between two different approaches.</p>",
        "id": 186211320,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1579630941
    },
    {
        "content": "<blockquote>\n<p>Here's a problem with the fully unbundled approach. The term size can blow up</p>\n</blockquote>\n<p>AFAICT only the term <em>tree</em> size blows up, and I don't see any fundamental reason why all operations in the system couldn't in principle be made to scale in the dag sizes instead of the tree sizes. Note that Lean currently does scale exponentially on <a href=\"#narrow/stream/113488-general/topic/huge.20term.20trees/near/185818383\" title=\"#narrow/stream/113488-general/topic/huge.20term.20trees/near/185818383\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge.20term.20trees/near/185818383</a> , though this is a conscious decision: we don't hash-cons and we use faster, imprecise caches in many places. Some recent discussion at <a href=\"#narrow/stream/113488-general/topic/huge.20term.20trees\" title=\"#narrow/stream/113488-general/topic/huge.20term.20trees\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge.20term.20trees</a></p>",
        "id": 186219826,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1579636201
    },
    {
        "content": "<p>FYI the paper is on arXiv now: <a href=\"https://arxiv.org/abs/2001.04301\" target=\"_blank\" title=\"https://arxiv.org/abs/2001.04301\">https://arxiv.org/abs/2001.04301</a></p>",
        "id": 186334761,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1579729895
    },
    {
        "content": "<p>Are there differences with the version you posted here?</p>",
        "id": 186334851,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1579729946
    },
    {
        "content": "<p>I can see in the reference section  \"35. mathlib Community, T.: The Lean mathematical library.\"</p>",
        "id": 186334893,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1579729983
    },
    {
        "content": "<p>Thanks again everyone for the helpful feedback.</p>",
        "id": 186334895,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1579729984
    },
    {
        "content": "<blockquote>\n<p>Are there differences with the version you posted here?</p>\n</blockquote>\n<p>Almost no changes to the description of the procedure. The main improvements are highlighting mathlib as a primary motivator, and explaining the subtle but surprisingly big gap between what typeclasses mean in most systems vs. what they mean in Coq and Lean.</p>",
        "id": 186335220,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1579730169
    },
    {
        "content": "<p>According to Georges, canonical structures are the real type classes in Coq. They are key in the math-comp library.<br>\nOne advantage is that they are predictable. It's interesting that they are not used in lean.<br>\nOn the other hand, they have also been an obscure feature for a long time in Coq, before they became popular in math-comp.</p>",
        "id": 186340674,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1579734019
    },
    {
        "content": "<p>No one will drive us from the paradise that Wadler and Blott created for us.</p>",
        "id": 186341885,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1579735008
    },
    {
        "content": "<p>They do exist in Lean 3 but I think someone (Cyril Cohen?) once told me that they were used precisely once in mathlib, and so there was not much of an argument for keeping them in Lean 4...</p>",
        "id": 186341978,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1579735090
    },
    {
        "content": "<p>Semi-offtopic: it would be nice to have a document that explain current <code>mathlib</code> policies about <code>class A extends B :=</code> vs <code>class A [B] :=</code>.</p>",
        "id": 186342255,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1579735359
    },
    {
        "content": "<p>Are there planned changes to unification hints in Lean 4?</p>",
        "id": 186342258,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1579735361
    },
    {
        "content": "<p>removal?</p>",
        "id": 186342285,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1579735395
    },
    {
        "content": "<p>that's more of an \"effected change\" than a \"planned change\" though</p>",
        "id": 186342298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1579735417
    },
    {
        "content": "<p>Why?</p>",
        "id": 186342394,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1579735494
    },
    {
        "content": "<blockquote>\n<p>They do exist in Lean 3 but I think someone (Cyril Cohen?) once told me that they were used precisely once in mathlib, and so there was not much of an argument for keeping them in Lean 4...</p>\n</blockquote>",
        "id": 186342410,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1579735506
    },
    {
        "content": "<p>Lean 4 also appears to be doubling down on typeclass support with this new algorithm, while effective implementation of unification hints for comparable benefit is a big wild card</p>",
        "id": 186342449,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1579735558
    },
    {
        "content": "<p>Typeclasses and unification hints are somewhat mutually exclusive mechanisms, so we have to pick one and stick with it</p>",
        "id": 186342525,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1579735617
    },
    {
        "content": "<p>I mean, for a mathematician both <code>.. extends ..</code> and <code>... [B] ...</code> mean the same, and it's hard to guess technical consequences of choosing one over another. As far as I understand, with <code>extends</code> we have to think about diamonds, and with <code>... [B]</code> we may create really huge goals. Am I correct?</p>",
        "id": 186342563,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1579735643
    },
    {
        "content": "<p>I've written about the policy before, but the short version is: if you use the same types as the parent, inherit, otherwise add it as a parameter</p>",
        "id": 186342642,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1579735702
    },
    {
        "content": "<p>Before cementing a policy, I suggest figuring out where the term tree blowup is coming from that was discussed in <a href=\"#narrow/stream/113488-general/topic/huge.20term.20trees\" title=\"#narrow/stream/113488-general/topic/huge.20term.20trees\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge.20term.20trees</a></p>",
        "id": 186342707,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1579735786
    },
    {
        "content": "<p>The exponential blowup is in the number of mutually referring parameters in a highly parameterized definition. With this policy, this situation only arises if the typeclass relates many different types, with lots of structure between proper subsets of those types</p>",
        "id": 186342713,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1579735793
    },
    {
        "content": "<p>I've been using them, but they have so little support it's hard to use them. I've been using type classes and unification hints together since they can be made to work together in orthogonal directions pretty well.</p>",
        "id": 186342719,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1579735801
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> I'm talking about the lean 3 mathlib policy. This may change in lean 4 depending on how lean performs on different loads</p>",
        "id": 186342782,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1579735826
    },
    {
        "content": "<blockquote>\n<p>if you use the same types as the parent, inherit</p>\n</blockquote>\n<p>except if you are only addings Props and there is a big zoo of them, and an exponentially large number of possible combinations (just as in topological spaces, which might be second countable, order topology, T2, and so on). Then the Props should be mixins.</p>",
        "id": 186342786,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1579735829
    },
    {
        "content": "<p>I agree with that too. You shouldn't have the definition of one such mixin depend on another as a parameter, so there is no parameter depth problem here either</p>",
        "id": 186342902,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1579735927
    },
    {
        "content": "<p>A data typeclass should never have a prop mixin as a parameter, since there is no diamond problem here</p>",
        "id": 186342961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1579736004
    },
    {
        "content": "<p>Another possibly stupid question. Would the following approach to algebraic classes create an exponential blow-up?</p>\n<ol>\n<li>Define classes <code>has_mul</code>, <code>has_add</code> (one per an operation and a constant).</li>\n<li>Declare a policy \"only one instance of these classes per a type\".</li>\n<li>Make prop classes, one per each property (e.g., <code>class is_mul_comm</code>). These classes take <code>has_mul</code> etc as parameters.</li>\n<li>Create common classes (<code>group</code>, <code>monoid</code>, ...) by <code>extend</code>ing various combinations  of one-property classes.</li>\n</ol>",
        "id": 186343163,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1579736216
    },
    {
        "content": "<p>There was talk at some point about making <code>group</code> a Prop that took a binary function as an argument.</p>",
        "id": 186343289,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1579736316
    },
    {
        "content": "<p>As a mathematician, I like a possibility to write a lemma taking specific <code>is_*</code> as parameters if a specific combination is not declared as a <code>class</code>. Think about all those <code>ordered_comm_monoid</code> etc.</p>",
        "id": 186343335,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1579736352
    },
    {
        "content": "<p>That would not cause a blowup (the only thing that matters for that is the signatures of the classes), but it would make the hierarchy a bit larger and (IMO) a bit harder to understand, because the axioms are now separated from the useful classes. I think a policy like this is where <code>mul_zero_class</code> and <code>distrib</code> came from</p>",
        "id": 186345763,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1579738382
    },
    {
        "content": "<blockquote>\n<p>As a mathematician, I like a possibility to write a lemma taking specific <code>is_*</code> as parameters if a specific combination is not declared as a <code>class</code>. Think about all those <code>ordered_comm_monoid</code> etc.</p>\n</blockquote>\n<p>These usually can't be just combinations of classes, because there are also compatibility claims between the order and the comm_monoid part</p>",
        "id": 186345868,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1579738504
    },
    {
        "content": "<p>But there are tons of variations of it for partial and total orders, commutativity, cancellation. They're also slightly confusing, I remember something like not every <code>ordered_comm_monoid</code> is an <code>ordered_monoid</code> or something.</p>",
        "id": 186346347,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1579739048
    },
    {
        "content": "<p>Some of that is legacy from the core/mathlib split</p>",
        "id": 186346825,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1579739569
    },
    {
        "content": "<p>We still have one example when canonical structures do something we have never been able to do with type classes: math-comp's bigop. They have a big operators library which is completely generic in the operator. This requires having lemmas whose input are predicates like <code>is_associative</code> and <code>is_commutative</code>. Such things were tried with type classes, there are remnants in the core library, but it never took off. My understanding is we always need some constant head symbol, like <code>has_add.add</code> instead of a mysterious operator <code>op</code> and a type class <code>[is_associative op]</code>.</p>",
        "id": 186371396,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1579771829
    },
    {
        "content": "<p>In this bigop library they can prove one lemma covering big sums, big products, big intersection, big direct sum of modules etc where we have separate lemmas for each case (with giant holes in the API until someone needs each specific case).</p>",
        "id": 186371459,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1579771901
    },
    {
        "content": "<p>But there is a huge barrier to trying canonical structures, we would need to rewrite the whole library. At the end of summer there was almost enough incentive with all the type class resolution failure or crazy timing. But then Daniel came and promised all this will be solved in Lean 4 so we wait.</p>",
        "id": 186371562,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1579772010
    },
    {
        "content": "<blockquote>\n<p>My understanding is we always need some constant head symbol, like has_add.add instead of a mysterious operator op</p>\n</blockquote>\n<p>This is only true for the simplifier, which looks up the simp lemmas by the name of the head symbol. I don't think that's a problem to develop generic bigops.  BTW, we have a type class <code>is_associative</code> and also instances like <code>is_associative (*)</code> for semigroups, etc.</p>",
        "id": 186372534,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1579772900
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> Could you please clarify. Should <code>simp</code>-lemmas have these constant head symbols, or only the terms that we are matching?</p>",
        "id": 186372701,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1579773093
    },
    {
        "content": "<p>Because I think <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> would like a world where you state a lemma for a generic <code>op</code> and then use it in the simplifier when applying it to some <code>has_add.add</code> occurence.</p>",
        "id": 186372765,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1579773144
    },
    {
        "content": "<p>Errm, both:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">...</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span> <span class=\"c1\">-- bad since relation `r` is not a constant</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_associative</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"bp\">...</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"bp\">...</span> <span class=\"c1\">-- bad since head symbol `f` of lhs is not a constant</span>\n</pre></div>",
        "id": 186372842,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1579773234
    },
    {
        "content": "<p>Ok. so that's bad. Because it means we have to state each lemma 5 times, instead of once.</p>",
        "id": 186372973,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1579773327
    },
    {
        "content": "<p>Which is exactly the situation that Patrick is describing.</p>",
        "id": 186372984,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1579773339
    },
    {
        "content": "<p>If we replaced <code>finset.prod</code> with <code>finset.bigop (*)</code>, then <code>finset.bigop</code> would be the head symbol, no?</p>",
        "id": 186373047,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1579773381
    },
    {
        "content": "<p>Of course we could try to generalise the proofs, but it's clear that in this regard our setup with typeclasses is suboptimal.</p>",
        "id": 186373049,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1579773388
    },
    {
        "content": "<blockquote>\n<p>If we replaced <code>finset.prod</code> with <code>finset.bigop (*)</code>, then <code>finset.bigop</code> would be the head symbol, no?</p>\n</blockquote>\n<p>Aha, I guess that might work, but it would mean a step down in readability.</p>",
        "id": 186373152,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1579773483
    },
    {
        "content": "<p>If <code>finset.prod</code> is than made an <code>abbreviation</code> of <code>finset.bigop (*)</code> and simp-lemmas can see through such an abbreviation, then it might work. But I'm not sure if that actually works.</p>",
        "id": 186373218,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1579773551
    },
    {
        "content": "<p>I tried something like this in a commit on folding min and max: <a href=\"https://github.com/leanprover-community/mathlib/commit/b031290b228838d5e779908b129420331bb131c5\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/commit/b031290b228838d5e779908b129420331bb131c5\">https://github.com/leanprover-community/mathlib/commit/b031290b228838d5e779908b129420331bb131c5</a></p>",
        "id": 186373401,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1579773690
    },
    {
        "content": "<p>Sure, we can have <code>finset.bigop (*)</code> and a notation for that. But then the library would still need lemmas about the generic <code>op</code> and the simplifier wouldn't trigger</p>",
        "id": 186373503,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1579773745
    },
    {
        "content": "<p>More than half of that commit is stating specialised versions of the two general lemmas, and even the two general lemmas ought to be unified.</p>",
        "id": 186373507,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1579773753
    },
    {
        "content": "<p>See also <a href=\"https://github.com/PatrickMassot/bigop/blob/master/src/bigop.lean\" target=\"_blank\" title=\"https://github.com/PatrickMassot/bigop/blob/master/src/bigop.lean\">https://github.com/PatrickMassot/bigop/blob/master/src/bigop.lean</a> for my old attempt to port the bigop library</p>",
        "id": 186373527,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1579773781
    },
    {
        "content": "<p>Could we have attributes that state the specialised simp-lemmas after the generic <code>op</code> version?</p>",
        "id": 186373569,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1579773842
    },
    {
        "content": "<p>It sorts of work (although it faces elaboration issues). But then you need to actually use it in the middle of other proofs where you expect the simplifier to work.</p>",
        "id": 186373643,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1579773881
    },
    {
        "content": "<p>Yes, that was one idea for making the simplifier work with more unbundled typeclasses. Throw a metaprogram at it.</p>",
        "id": 186373670,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1579773906
    },
    {
        "content": "<p>The specialized lemmas would be generated eagerly</p>",
        "id": 186373692,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1579773927
    },
    {
        "content": "<p>Or craft an attribute on the generic lemmas that would generate the versions for sums, products, unions, and so on, which would be generic enough that one can add new instances to the attributes (for instance max), and then all the lemmas would become available right away for max.</p>",
        "id": 186374274,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1579774334
    },
    {
        "content": "<p>Oups, Johan just said this two messages ago!</p>",
        "id": 186374298,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1579774378
    },
    {
        "content": "<blockquote>\n<p>... the simplifier, which looks up the simp lemmas by the name of the head symbol.</p>\n</blockquote>\n<p>Lean4 will use a discrimination tree instead of a head map.</p>",
        "id": 186380199,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1579779829
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> In other words: in Lean 4 we can have typeclasses and an elegant bigop library?</p>",
        "id": 186380560,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1579780205
    },
    {
        "content": "<p>I didn't mean to imply that. To be honest, I don't remember all the desiderata and challenges involved in this issue.</p>",
        "id": 186382577,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1579781927
    },
    {
        "content": "<p>How much of the concern is automation (or the lack thereof) when proving the generic big-op lemmas themselves? For using the big-op theorems for concrete ops in downstream automation, what are the downsides of the meta-programming approach?</p>",
        "id": 186383047,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1579782316
    },
    {
        "content": "<p>There is a minor diamond issue: if you define a bigop simp lemma in one file and a new bigop in an independent file, you might not get a specialized version of this lemma for that bigop when you import both, depending on the implementation</p>",
        "id": 186383466,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1579782627
    },
    {
        "content": "<p>There could of course be an explicit command \"generate all missing combinations at this point\"</p>",
        "id": 186383554,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1579782710
    },
    {
        "content": "<p>I'm sorry I have very very little time for Lean right now (and probably for the coming two weeks). I only try to remember what happened one year ago. But I see from <a href=\"https://github.com/leanprover/lean4/commit/c9e9208ea29a34fe715310f47fa5ce786a4b3b8e\" target=\"_blank\" title=\"https://github.com/leanprover/lean4/commit/c9e9208ea29a34fe715310f47fa5ce786a4b3b8e\">https://github.com/leanprover/lean4/commit/c9e9208ea29a34fe715310f47fa5ce786a4b3b8e</a> that Leo is on it.</p>",
        "id": 186408714,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1579798188
    },
    {
        "content": "<p>Good eye. This is strictly about notations for now though.</p>",
        "id": 186410959,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1579799433
    },
    {
        "content": "<p>I noticed it was notation only, but it still suggest this bigop question is somewhere in Leo's mind.</p>",
        "id": 186430421,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1579810356
    },
    {
        "content": "<p>We all love big-ops. The main issue is that we don't want automation (e.g. the simplifier) to stupidly try applying every big-op lemma to every subterm for lack of decent indexing. It might be possible to extend our discrimination trees to index these lemmas better, but so far the macro-specialization approach seems acceptable to me.</p>",
        "id": 186431887,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1579811305
    },
    {
        "content": "<p>The Coq devs tried to convert mathematical components to type classes, but got stuck<br>\n<a href=\"https://github.com/coq/stdlib2/wiki/EqClass\" target=\"_blank\" title=\"https://github.com/coq/stdlib2/wiki/EqClass\">https://github.com/coq/stdlib2/wiki/EqClass</a><br>\nWould this be solved by the lean type class mechanism?</p>",
        "id": 186990249,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1580393830
    },
    {
        "content": "<p>Robbert Krebbers asks whether tabled type classes solve term blow up:<br>\n<a href=\"https://www.ralfj.de/blog/2019/05/15/typeclasses-exponential-blowup.html\" target=\"_blank\" title=\"https://www.ralfj.de/blog/2019/05/15/typeclasses-exponential-blowup.html\">https://www.ralfj.de/blog/2019/05/15/typeclasses-exponential-blowup.html</a><br>\nThis thread seems to suggest that it doesn't??<br>\n<a href=\"#narrow/stream/113488-general/topic/huge.20term.20trees\" title=\"#narrow/stream/113488-general/topic/huge.20term.20trees\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge.20term.20trees</a><br>\nOf course, we were aware of the issue when writing the Coq math-classes library, and proposed to bundle parts when needed.</p>",
        "id": 187757928,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1581252788
    },
    {
        "content": "<p>That post was discussed here: <br>\n<a href=\"#narrow/stream/113488-general/topic/what.20is.20a.20diamond.3F\" title=\"#narrow/stream/113488-general/topic/what.20is.20a.20diamond.3F\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what.20is.20a.20diamond.3F</a></p>\n<p>If my memory is correct, since Lean's typeclasses are partially bundled and not unbundled, the term blow up is quadratic, not exponential, even with a tree-encoding of a term (maybe it's smaller with a dag-encoding?)</p>",
        "id": 187783227,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1581299395
    },
    {
        "content": "<p>everything is linear with a dag-encoding</p>",
        "id": 187783620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581300148
    },
    {
        "content": "<p>it is exponential in the number of parameters to a definition, but in mathlib n = 1 in almost all cases (for modules and such n = 2)</p>",
        "id": 187783632,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581300212
    },
    {
        "content": "<p>You can also use the complexity theory term \"fixed-parameter tractable\" to give it a positive spin</p>",
        "id": 187783678,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581300269
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> The size of the tree-expansion of terms is orthogonal to the problems that tabling solves. BTW I would have expected Coq to be polynomial on <a href=\"#narrow/stream/113488-general/topic/huge.20term.20trees/near/185865827\" title=\"#narrow/stream/113488-general/topic/huge.20term.20trees/near/185865827\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge.20term.20trees/near/185865827</a> since it hash-conses -- do you know why Coq scales exponentially on it? Perhaps they are just forgetting a cache somewhere and are traversing a term as a tree unnecessarily.</p>",
        "id": 187827117,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1581349451
    },
    {
        "content": "<p>Enrico Tassi said: <br>\nCoq is quite hysterical: it does opportunistic sharing via evar assignment, but disregards that sharing while doing conversion/reduction...<br>\nThey are looking into fixing this.</p>",
        "id": 187830474,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1581351413
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> FYI we briefly discussed this sharing issue in the Lean4 dev meeting this morning. Tentative plan is to not try to scale in the DAG size, nor to preserve sharing everywhere, but rather to aggressively let-abstract in key places and to make sure never to zeta-reduce unnecessarily.</p>",
        "id": 187859501,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1581369755
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> Does the lean kernel know how to deal with let binders in the context now? I recall the algorithm in lean 3 (copied for my paper) is to eagerly expand let binders during typechecking, because the definition of \"context\" does not have let-binders (unlike in the tactic state, which represents let binders in the context explicitly)</p>",
        "id": 187870887,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581378623
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> [CORRECTED] Yes, it has support for <code>let</code> binders in the context now.</p>",
        "id": 187934095,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1581442590
    }
]
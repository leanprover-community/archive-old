[
    {
        "content": "<p>I think I have a problem because mathlib doesn't have  a <code>normed_division_ring</code>, but I'm not sure. I think I reduced my problem to the following:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>problem</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">division_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">problem</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"n\">r</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">is_unit_iff_ne_zero</span> <span class=\"n\">R</span> <span class=\"n\">_</span> <span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">h</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">type mismatch at application</span>\n<span class=\"cm\">  is_unit_iff_ne_zero.mpr h</span>\n<span class=\"cm\">term</span>\n<span class=\"cm\">  h</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  r ≠ 0</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  r ≠ 0</span>\n<span class=\"cm\">Additional information:</span>\n<span class=\"cm\">context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message</span>\n<span class=\"cm\">  type mismatch, term</span>\n<span class=\"cm\">    is_unit_iff_ne_zero.mpr ?m_1</span>\n<span class=\"cm\">  has type</span>\n<span class=\"cm\">    @is_unit R</span>\n<span class=\"cm\">      (@monoid_with_zero.to_monoid R</span>\n<span class=\"cm\">         (@group_with_zero.to_monoid_with_zero R (@division_ring.to_group_with_zero R _inst_1)))</span>\n<span class=\"cm\">      r</span>\n<span class=\"cm\">  but is expected to have type</span>\n<span class=\"cm\">    @is_unit R (@ring.to_monoid R (@normed_ring.to_ring R _inst_2)) r</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n</div></div>\n<p>If I understand the error message correctly, the problem is that the term I constructed is a unit in the monoid coming from the fact that <code>R</code> is a <code>division_ring</code>, but it was expecting a unit in the monoid coming form the fact that <code>R</code> is a <code>normed_ring</code>.</p>\n<ol>\n<li>Did I interpret correctly?</li>\n<li>I really do need both hypotheses as I am trying to define the Gelfand-Mazur isomorphism</li>\n<li>How do I deal with this?</li>\n</ol>",
        "id": 272372535,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645172308
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/division_ring\">docs#division_ring</a> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/normed_ring\">docs#normed_ring</a> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_field\">docs#is_field</a> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_division_ring\">docs#is_division_ring</a> (sorry, on mobile!)</p>",
        "id": 272372812,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1645172528
    },
    {
        "content": "<p>Doing <code>convert (@is_unit_iff_ne_zero _ _ r).mpr _</code> produces a goal of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">_inst_1</span><span class=\"o\">:</span> <span class=\"n\">division_ring</span> <span class=\"n\">R</span>\n<span class=\"n\">_inst_2</span><span class=\"o\">:</span> <span class=\"n\">normed_ring</span> <span class=\"n\">R</span>\n<span class=\"n\">r</span><span class=\"o\">:</span> <span class=\"n\">R</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">ring.to_monoid</span> <span class=\"n\">R</span> <span class=\"bp\">=</span> <span class=\"n\">monoid_with_zero.to_monoid</span> <span class=\"n\">R</span>\n</code></pre></div>\n<p>Maybe this means that there are issues with going from ring to monoid?  I do not really know whether this is a diamond or not...</p>",
        "id": 272372922,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1645172640
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 272373020,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1645172706
    },
    {
        "content": "<p><code>is_field</code> is an example, which is there, but if your ring is not commutative you'll need <code>is_division_ring</code> which is not, but which should be easy to add (just copy <code>is_field</code> and drop stuff)</p>",
        "id": 272373149,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1645172827
    },
    {
        "content": "<p>Aargh on mobile, accidentally just deleted post saying \"it's not a diamond, you do indeed have two ring structures, fix it with a mixin\"</p>",
        "id": 272373259,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1645172924
    },
    {
        "content": "<p>Kevin said:<br>\nSo yeah you're right -- division_ring R puts a ring structure on R and normed_ring R puts a different ring structure on it (so it's not diamond). You'll have to use what I think they call a Prop-valued mixin.</p>",
        "id": 272373305,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1645172965
    },
    {
        "content": "<p>(Kevin, I hope that you wanted to actually recover what you had said!)</p>",
        "id": 272373319,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1645172987
    },
    {
        "content": "<p>I think there's a problem with this idea, namely, <code>is_division_ring</code> can't just be Prop-valued mixin because <code>division_ring</code> needs an <code>inv</code> and <code>div</code>, whereas rings don't have this. <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 272374352,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645173672
    },
    {
        "content": "<p>(and yes, my rings are noncommutative, until they aren't via the isomorphism)</p>",
        "id": 272374516,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645173759
    },
    {
        "content": "<p>I have not looked at this much, so I might be wrong, but <code>is_field</code> also takes a ring and produces something with inverses.  Does asserting the existence of a left/right inverse (without using the \\inv notation, simply an element of the ring) not work for <code>division_ring</code> as well?</p>",
        "id": 272374564,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1645173791
    },
    {
        "content": "<p>ah, good point, let me check out <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_field.to_field\">docs#is_field.to_field</a></p>",
        "id": 272374638,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645173835
    },
    {
        "content": "<p>It's noncomputable but that's where the data is added</p>",
        "id": 272374779,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1645173908
    },
    {
        "content": "<p>If I truly cared about computability, I don't know how I could have ended up in functional analysis. <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 272374957,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645174014
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/division_ring_of_is_unit_or_eq_zero\">docs#division_ring_of_is_unit_or_eq_zero</a></p>",
        "id": 272378425,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645176260
    },
    {
        "content": "<p>So, I guess I don't understand how to actually use this. If I have a ring, and I have a Prop-valued mixin for division ring, how do I conclude some <code>group_with_zero</code> property? Because if I use <code>haveI</code> to construct my division ring, then I'm just back where I started (with 2 ring structures), but without the division ring type class instance, how do I get Lean to recognize the <code>group_with_zero</code> instance so I can use <code>is_unit_iff_ne_zero</code>?</p>",
        "id": 272379672,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645177096
    },
    {
        "content": "<p>If you use <code>letI</code>, then the two instances should be definitionally equal</p>",
        "id": 272379867,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1645177229
    },
    {
        "content": "<p>(<code>have</code> and <code>haveI</code> forget the definition of the new hypothesis, <code>let</code> and <code>letI</code> preserve it)</p>",
        "id": 272379893,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1645177260
    },
    {
        "content": "<p>ah, of course, it's data. Stupid me.</p>",
        "id": 272379901,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645177270
    },
    {
        "content": "<p>This is a highly non-mathematical issue which took me some time to get used to! This even goes back to the definition of group -- we often write the definition as \"a group is a set plus a multiplication plus some axioms\" and the axioms imply \"there exists a unique identity\" so the mathematicians say \"let's now call it <code>1</code>\" and I think that in ZFC there is no issue here but for Lean some magic has to occur to get the data from the prop, so instead of invoking magic all the time they just add 1 to the data in the definition -- and then we end up with both <code>field</code> and <code>is_field</code> etc etc. In some sense I'm surprised we don't have an <code>is_group</code> predicate on monoids -- perhaps the reason we don't is that in practice either the monoids we have are obviously not groups or obviously groups?</p>",
        "id": 272390693,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1645184006
    },
    {
        "content": "<p>Since I don't see it mentioned here, another solution here is just \"define <code>normed_division_ring</code> in the obvious way\". Chances are we don't have it yet because no one needed it</p>",
        "id": 272391220,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1645184388
    },
    {
        "content": "<p>One reason why <code>is_field</code> is useful is that it allows you express \"this ring structure is not a field\"; <code>is_empty (field α)</code> means something quite different to <code>¬is_field α</code>, and only the latter really expresses something mathematically interesting.</p>",
        "id": 272391308,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1645184446
    },
    {
        "content": "<p>not to diminish the point, but <code>is_empty (field α)</code> (or better, <code>nonempty (field α)</code>) is slightly mathematically interesting: it's a cardinality constraint which I believe is true iff <code>#α</code> is either a prime power or an infinite cardinal</p>",
        "id": 272395209,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645187203
    },
    {
        "content": "<p>I'm not sure we have that proved though (maybe we know the first part?)</p>",
        "id": 272395257,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645187234
    },
    {
        "content": "<p>come to think of it, do we have the existence of prime power fields? A computable definition would be extra cool</p>",
        "id": 272395358,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645187283
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/galois_field\">docs#galois_field</a></p>",
        "id": 272395752,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1645187553
    },
    {
        "content": "<p>seems to not be constructive</p>",
        "id": 272395793,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1645187585
    },
    {
        "content": "<p>(for the infinite case I think it's quite accessible from current mathlib: you use the fraction field of <code>mv_polynomial α ℚ</code>)</p>",
        "id": 272395802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645187590
    },
    {
        "content": "<p>i've just finished the finite case:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.finite.galois_field</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.is_prime_pow</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.equiv.transfer_instance</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`‖`</span> <span class=\"n\">x</span> <span class=\"bp\">`‖`</span> <span class=\"o\">:=</span> <span class=\"n\">fintype.card</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nat.prime.is_prime_pow</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p.prime</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_prime_pow</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_prime_pow_nat_iff</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">one_pos</span><span class=\"o\">,</span> <span class=\"n\">pow_one</span> <span class=\"n\">p</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">field</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">is_prime_pow</span> <span class=\"o\">(</span><span class=\"n\">fintype.card</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"n\">swap</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">hn</span><span class=\"o\">,</span> <span class=\"n\">hα</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">fact.mk</span> <span class=\"o\">(</span><span class=\"n\">nat.prime_iff.mpr</span> <span class=\"n\">hp</span><span class=\"o\">),</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨(</span><span class=\"n\">fintype.equiv_of_card_eq</span> <span class=\"o\">((</span><span class=\"n\">galois_field.card</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"n\">hn.ne'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">hα</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm.field</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">h</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">casesI</span> <span class=\"n\">char_p.exists</span> <span class=\"n\">α</span> <span class=\"k\">with</span> <span class=\"n\">p</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">haveI</span> <span class=\"n\">hp</span> <span class=\"o\">:=</span> <span class=\"n\">fact.mk</span> <span class=\"o\">(</span><span class=\"n\">char_p.char_is_prime</span> <span class=\"n\">α</span> <span class=\"n\">p</span><span class=\"o\">),</span>\n  <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">is_noetherian.finset_basis</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">module.card_fintype</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">zmod.card</span><span class=\"o\">,</span> <span class=\"n\">is_prime_pow_pow_iff</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hp.1.is_prime_pow</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">finite_dimensional.finrank_eq_card_basis</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">finite_dimensional.finrank_pos.ne'</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I don't see the equiv <code>α ≃ fraction_ring (mv_polynomial α ℚ)</code>; how do you make it?</p>",
        "id": 272405952,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1645193516
    },
    {
        "content": "<p>sorry, we should probably move this to another thread</p>",
        "id": 272406008,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1645193528
    },
    {
        "content": "<p>you probably need some facts about cardinal of mv_polynomial (<a href=\"https://tqft.net/mathlib/data/mv_polynomial/cardinal\">file#data/mv_polynomial/cardinal</a>) and fraction_ring (not sure we have those)</p>",
        "id": 272407669,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1645194347
    },
    {
        "content": "<p>I guess using that the localization map is surjective it shouldn't be too hard to get those?</p>",
        "id": 272407904,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1645194475
    },
    {
        "content": "<p>I guess you need facts about cardinality of finsupp too. Would be a nice Friday afternoon exercise!</p>",
        "id": 272408703,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1645194889
    },
    {
        "content": "<p>so do we want <code>is_division_ring</code> as a mix in, or do we just wanted to define a <code>normed_division_ring</code>? Tossing around the hypothesis <code>(h : ∀ b : A, is_unit b ∨ b = 0)</code> for everything related to Gelfand-Mazur is just silly. See here for the mixin version (you must be on the <code>j-loreaux/spectrum-nonempty</code> branch for the second half of this to compile):</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.spectrum</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">division_ring</span> <span class=\"c1\">-- goes in `algebra.field.basic`</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"sd\">/-- A predicate to express that a ring is a division ring.</span>\n<span class=\"sd\">This is mainly useful because such a predicate does not contain data,</span>\n<span class=\"sd\">and can therefore be easily transported along ring isomorphisms.</span>\n<span class=\"sd\">Additionaly, this is useful when trying to prove that</span>\n<span class=\"sd\">a particular ring structure extends to a division ring. -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">is_division_ring</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">exists_pair_ne</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mul_inv_cancel</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Transferring from division_ring to is_division_ring -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">division_ring.to_is_division_ring</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">division_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_division_ring</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mul_inv_cancel</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"bp\">⁻¹</span><span class=\"o\">,</span> <span class=\"n\">division_ring.mul_inv_cancel</span> <span class=\"n\">ha</span><span class=\"o\">⟩,</span>\n  <span class=\"bp\">..</span><span class=\"o\">‹</span><span class=\"n\">division_ring</span> <span class=\"n\">R</span><span class=\"o\">›</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Transferring from is_division_ring to division_ring -/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">is_division_ring.to_division_ring</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_division_ring</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">division_ring</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"n\">classical.some</span> <span class=\"o\">(</span><span class=\"n\">is_division_ring.mul_inv_cancel</span> <span class=\"n\">h</span> <span class=\"n\">ha</span><span class=\"o\">),</span>\n  <span class=\"n\">inv_zero</span> <span class=\"o\">:=</span> <span class=\"n\">dif_pos</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_inv_cancel</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n    <span class=\"kd\">begin</span>\n      <span class=\"n\">convert</span> <span class=\"n\">classical.some_spec</span> <span class=\"o\">(</span><span class=\"n\">is_division_ring.mul_inv_cancel</span> <span class=\"n\">h</span> <span class=\"n\">ha</span><span class=\"o\">),</span>\n      <span class=\"n\">exact</span> <span class=\"n\">dif_neg</span> <span class=\"n\">ha</span>\n    <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span> <span class=\"o\">‹</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">›,</span> <span class=\"bp\">..</span><span class=\"n\">h</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">division_ring</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">gelfand_mazur_isomorphism</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_algebra</span> <span class=\"n\">ℂ</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">complete_space</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nontrivial</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">borel_space</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space.second_countable_topology</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">σ</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">spectrum</span> <span class=\"n\">ℂ</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">spectrum</span>\n\n<span class=\"sd\">/-- Choose an arbitrary element of the spectrum of each element in a nontrivial complex Banach</span>\n<span class=\"sd\">algebra. -/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">spectrum.some</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n<span class=\"n\">set.nonempty.some</span> <span class=\"o\">(</span><span class=\"n\">spectrum.nonempty</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">spectrum.some_spec</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">spectrum.some</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">spectrum</span> <span class=\"n\">ℂ</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"n\">set.nonempty.some_mem</span> <span class=\"o\">(</span><span class=\"n\">spectrum.nonempty</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">spectrum.unique_mem</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_division_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">σ</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">σ</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">is_division_ring.to_division_ring</span> <span class=\"n\">A</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_iff</span><span class=\"o\">,</span> <span class=\"n\">not_iff_not.mpr</span> <span class=\"n\">is_unit_iff_ne_zero</span><span class=\"o\">,</span> <span class=\"n\">not_not</span><span class=\"o\">,</span> <span class=\"n\">sub_eq_iff_eq_add</span><span class=\"o\">,</span> <span class=\"n\">zero_add</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">no_zero_smul_divisors.algebra_map_injective</span> <span class=\"n\">ℂ</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">hy.symm</span> <span class=\"bp\">▸</span> <span class=\"n\">hx</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">spectrum.unique_of_mem</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_division_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">σ</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">σ</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">is_division_ring.to_division_ring</span> <span class=\"n\">A</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_iff</span><span class=\"o\">,</span> <span class=\"n\">not_iff_not.mpr</span> <span class=\"n\">is_unit_iff_ne_zero</span><span class=\"o\">,</span> <span class=\"n\">not_not</span><span class=\"o\">,</span> <span class=\"n\">sub_eq_iff_eq_add</span><span class=\"o\">,</span> <span class=\"n\">zero_add</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">ha</span> <span class=\"n\">hb</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">ha</span> <span class=\"bp\">▸</span> <span class=\"n\">hb</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">spectrum.exists_some_singleton</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_division_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">spectrum</span> <span class=\"n\">ℂ</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">z</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"n\">set.exists_eq_singleton_iff_nonempty_unique_mem.mpr</span>\n  <span class=\"o\">⟨</span><span class=\"n\">spectrum.nonempty</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">spectrum.unique_mem</span> <span class=\"n\">h</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span><span class=\"o\">)⟩</span>\n\n<span class=\"sd\">/-- **Gelfand-Mazur theorem**: A complex Banach division algebra is isomorphic to `ℂ`, registered</span>\n<span class=\"sd\">as an algebra equivalence. -/</span>\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">alg_equiv.complex_complete_normed_division_ring</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_division_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">ℂ</span><span class=\"o\">]</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">algebra_map</span> <span class=\"n\">ℂ</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"n\">spectrum.some</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">scalar_eq</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">spectrum.some_spec</span> <span class=\"o\">((</span><span class=\"n\">algebra_map</span> <span class=\"n\">ℂ</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">z</span><span class=\"o\">),</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">is_division_ring.to_division_ring</span> <span class=\"n\">A</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:=</span> <span class=\"n\">spectrum.some_spec</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">ℂ</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">spectrum.some</span> <span class=\"n\">a</span><span class=\"o\">)),</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:=</span> <span class=\"n\">not_not.mp</span> <span class=\"o\">((</span><span class=\"n\">not_iff_not.mpr</span> <span class=\"n\">is_unit_iff_ne_zero</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"o\">(</span><span class=\"n\">mem_iff.mp</span> <span class=\"n\">h₁</span><span class=\"o\">)),</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sub_eq_iff_eq_add</span><span class=\"o\">,</span> <span class=\"n\">zero_add</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">no_zero_smul_divisors.algebra_map_injective</span> <span class=\"n\">ℂ</span> <span class=\"n\">A</span> <span class=\"n\">h₂</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">spectrum.unique_of_mem</span> <span class=\"n\">h</span> <span class=\"n\">h₁</span> <span class=\"o\">(</span><span class=\"n\">spectrum.some_spec</span> <span class=\"n\">a</span><span class=\"o\">),</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">ℂ</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_mul</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">ℂ</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_add</span><span class=\"o\">,</span>\n  <span class=\"n\">commutes'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">gelfand_mazur_isomorphism</span>\n</code></pre></div>\n</div></div>\n<p>Should I PR the mixin or define <code>normed_division_algebra</code>, or both?</p>",
        "id": 272409282,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645195202
    },
    {
        "content": "<p>People who understand this sort of thing now start talking about quadratic growth of typeclass inference search or something; hopefully someone who understands the internals will chime in.</p>",
        "id": 272409415,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1645195275
    },
    {
        "content": "<p>The pattern here is to define <code>normed_division_ring</code>. The question of whether it should be a mixin belongs to another discussion as mathlib already has weaker and stronger typeclasses which are not mixins, namely <code>normed_ring</code> and <code>normed_field</code>.</p>",
        "id": 272413053,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645197005
    },
    {
        "content": "<p>Oh! If they're there then it's probably case closed: we seem to want a new object <code>normed_division_ring</code>. Is it still OK to use <code>old_structure_cmd</code> or should it extend one structure and then add the fields for the other?</p>",
        "id": 272415441,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1645198178
    },
    {
        "content": "<p>Oh, I think we don't care much about that. I suspect all the other ones use <code>old_structure_cmd</code> happily.</p>",
        "id": 272420404,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645200489
    },
    {
        "content": "<p>The whole normed_* hierarchy doesn't use old_structure_cmd (but it should).</p>",
        "id": 272421719,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1645201055
    },
    {
        "content": "<p>(Slightly related: I'm currently working on adding a typeclass for nat.cast&amp;int.cast and had to refactor normed_* to old_structure_cmd.  I should probably extract that to a separate PR.)</p>",
        "id": 272421837,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1645201100
    },
    {
        "content": "<p>I don't understand. Are you using old structures more? I thought the plan was to get rid of them?</p>",
        "id": 272424186,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645202322
    },
    {
        "content": "<p>The plan is to use them again, since Lean 4 now uses a mixture of old/new structures (i.e., new whenever possible, old as an automatic fallback).  Looking over normed_*, there's lots of ugly hacks that can be removed by switching to old structures.</p>",
        "id": 272425458,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1645202897
    },
    {
        "content": "<p>Oh, that's good to know, since I've been going round the library to remove old structures.</p>",
        "id": 272425580,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645202959
    },
    {
        "content": "<p>What I'm most complaining about the current situation is that new structures really could be as easy to declare as old ones, but for some reason they are not.</p>",
        "id": 272425639,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645202999
    },
    {
        "content": "<p>It seems to be that this is an implementation detail that leaked through.</p>",
        "id": 272425722,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645203021
    },
    {
        "content": "<p>What I want is to be able to declare new structures the same way as old ones, namely you put as many <code>extends</code> clauses as you want, with conflicting fields if you want.</p>",
        "id": 272425961,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645203131
    },
    {
        "content": "<p>And it would generate the structure in the new style, namely the first parent is taken as a field and every parent that wants to add a conflicting field is blown up and we instead get a separate instance/projection.</p>",
        "id": 272426244,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645203249
    },
    {
        "content": "<p>That's what's happening in Lean 4.</p>",
        "id": 272426704,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1645203443
    },
    {
        "content": "<p>That might not always do what you want, namely if <code>foo</code> has <code>a</code> and <code>b</code>, <code>bar</code> has <code>b</code> and <code>c</code>, <code>baz</code> has <code>c</code> and <code>d</code>, then</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">qux</span> <span class=\"kd\">extends</span> <span class=\"n\">foo</span><span class=\"o\">,</span> <span class=\"n\">bar</span><span class=\"o\">,</span> <span class=\"n\">baz</span>\n</code></pre></div>\n<p>would generate</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">qux</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_foo</span> <span class=\"o\">:</span> <span class=\"n\">foo</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"bp\">...</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"bp\">...</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">qux.to_bar</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">qux</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"bp\">..</span><span class=\"n\">x</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">qux.to_baz</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">qux</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">baz</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"bp\">..</span><span class=\"n\">x</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>instead of the more optimal</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">qux</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_foo</span> <span class=\"o\">:</span> <span class=\"n\">foo</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">to_baz</span> <span class=\"o\">:</span> <span class=\"n\">baz</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">qux.to_bar</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">qux</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"bp\">..</span><span class=\"n\">x</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 272426728,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645203454
    },
    {
        "content": "<p>And this gets worse with bigger structures which have more complicated conflicting fields, but arguably rearranging the clauses would solve what it can.</p>",
        "id": 272426916,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645203520
    },
    {
        "content": "<p>Is that possible, Gabriel, or am I daydreaming?</p>",
        "id": 272427033,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645203565
    },
    {
        "content": "<p>It works if you write <code>extends Foo, Baz, Bar</code>.</p>",
        "id": 272427166,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1645203605
    },
    {
        "content": "<p>Sorry, that was my point <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 272427330,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645203655
    },
    {
        "content": "<p>But it doesn't currently generate <code>qux.to_bar</code> automatically, right?</p>",
        "id": 272427389,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645203680
    },
    {
        "content": "<p>If you write <code>extends Foo, Baz, Bar</code> it does create a projection to <code>Bar</code>.  I can't vouch for the name though.</p>",
        "id": 272428221,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1645204022
    },
    {
        "content": "<p>In Lean 3 too?</p>",
        "id": 272428548,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645204161
    },
    {
        "content": "<p>No, but that's only a temporary issue.</p>",
        "id": 272429212,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1645204482
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/12132\">#12132</a>: introduces division rings. For the moment I just copied the stuff that worked (i.e., didn't use commutativity) from normed fields. Should I in another PR refactor to only use the normed_division_ring versions and rely on type class inference for the rest? Obviously that could touch a lot of files, and it's not that much code duplication right now anyway.</p>",
        "id": 272449104,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645214139
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/normed_field.norm_mul\">docs#normed_field.norm_mul</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/norm_mul\">docs#norm_mul</a></p>",
        "id": 272450985,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645214779
    },
    {
        "content": "<p>Hmm... that's weird. Why is it not just called <code>norm_mul</code>?</p>",
        "id": 272451098,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645214847
    },
    {
        "content": "<p>In any case I think you should replace the lemmas right away. This really fits with the rest of the PR.</p>",
        "id": 272451184,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645214884
    },
    {
        "content": "<p><code>norm_mul</code> for fields and division rings is an equality, not an inequality like for (semi)normed rings. That's the reason for the difference.</p>",
        "id": 272458691,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645219079
    },
    {
        "content": "<p>Probably we should call the inequality version <code>norm_mul_le</code></p>",
        "id": 272458823,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1645219142
    },
    {
        "content": "<p>If that's more work though, we could have <code>norm_mul'</code> for the division_ring / field versions</p>",
        "id": 272458881,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1645219178
    },
    {
        "content": "<p>I'm just worried about touching 30 or 40 files in one PR. The amount of work is not a huge deal, as long as it's feasible.</p>",
        "id": 272458949,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645219213
    },
    {
        "content": "<p>grepping for <code>normed_field.norm_mul</code> alone hit 13 different files. I'm willing to do it, but someone has to explain to me how to go about it without making my life miserable.</p>",
        "id": 272459387,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645219475
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/normed_division_ring/near/272458823\">said</a>:</p>\n<blockquote>\n<p>Probably we should call the inequality version <code>norm_mul_le</code></p>\n</blockquote>\n<p>Interestingly, the API for it includes the <code>le</code>, it's just the structure projection that doesn't have it.</p>",
        "id": 272459448,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645219522
    },
    {
        "content": "<p>Well nothing should be using the structure projection anyway</p>",
        "id": 272460208,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1645219906
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/norm_mul_le\">docs#norm_mul_le</a> exists then?</p>",
        "id": 272460269,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1645219924
    },
    {
        "content": "<p>Does <a href=\"https://leanprover-community.github.io/mathlib_docs/find/norm_mul\">docs#norm_mul</a> too?</p>",
        "id": 272460294,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1645219942
    },
    {
        "content": "<p>Alright, easy - rename <code>normed_field.norm_mul'</code> to <code>norm_mul</code> (by adding an API lemma to unwrap it) and you're done</p>",
        "id": 272460352,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1645219985
    },
    {
        "content": "<p>Sorry, <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>, I think we were talking past each other. Here is the situation:</p>\n<ol>\n<li><code>normed_ring</code> has a <code>norm_mul</code> structure projection (which is actually an inequality), and an API wrapper <code>norm_mul_le</code> (root namespace)</li>\n<li><code>normed_field</code> has a <code>norm_mul'</code> structure projection (which is an equality), and a <em>namespaced</em> API wrapper <code>normed_field.norm_mul</code></li>\n</ol>\n<p>I think <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> was <a href=\"#narrow/stream/113488-general/topic/normed_division_ring/near/272450985\">asking</a> why the latter is namespaced, but the former isn't. When I followed up with the (in)equality comment, I had thought the namespacing was required because the ring version was called <code>norm_mul</code>, but it isn't, that's only the name of the structure projection.</p>\n<p>My worry about deleting all these normed field lemmas (and only keeping the division ring versions) is that they're all in the <code>normed_field</code> namespace, and of course the division ring versions don't want to be in that namespace (right? I'm not crazy). So should I really delete them, and then go around into all the files that broke and add an <code>open normed_division_ring</code>? This was my concern about touching 30 or 40 files.</p>",
        "id": 272547311,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645310068
    },
    {
        "content": "<p>The projection from <code>normed_ring</code> really should be called <code>normed_ring.norm_mul_le</code>. Changing it shouldn't be too hard as it's supposedly called exactly once (to prove <code>norm_mul_le</code>). The projection from <code>normed_field</code> should be called <code>normed_field.norm_mul</code> and the API lemma should be called <code>norm_mul</code> (either by <code>export</code>ing it or declaring it separately). Almost no lemma should be in the <code>normed_field</code> namespace.</p>",
        "id": 272547554,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645310361
    },
    {
        "content": "<p>Similarly, no lemma should be in the <code>normed_division_ring</code> namespace.</p>",
        "id": 272547623,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645310419
    },
    {
        "content": "<p>That makes sense to me, but do we need someone (<span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> because git blame) to weigh in about why they were originally put into the <code>normed_field</code> namespace?</p>",
        "id": 272547732,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645310550
    },
    {
        "content": "<p><code>normed_field</code> was there long before me.</p>",
        "id": 272547824,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1645310660
    },
    {
        "content": "<p>I suspect this namespace is an historical accident.</p>",
        "id": 272547931,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645310769
    },
    {
        "content": "<p>I agree that it should be in the root namespace.</p>",
        "id": 272547938,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1645310778
    },
    {
        "content": "<p>okay, I'll change it.</p>",
        "id": 272548098,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645310990
    },
    {
        "content": "<p>I think we have a diamond problem. A normed field is both a normed division ring and a normed commutative ring.</p>",
        "id": 272549209,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645312154
    },
    {
        "content": "<p>Sorry, I didn't explain enough: both of these have instances of normed group.</p>",
        "id": 272549463,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645312461
    },
    {
        "content": "<p>But are they not defeq?</p>",
        "id": 272549470,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645312477
    },
    {
        "content": "<p>There are diamonds everywhere. The real trouble is non-defeq diamonds.</p>",
        "id": 272549494,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645312509
    },
    {
        "content": "<p>well, I think not because I was getting problems with the lemma <code>norm_norm</code> which to me looked like a diamond, but perhaps I misinterpreted the reason. Let me see if I can get the file back to that state and post the error.</p>",
        "id": 272549587,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645312618
    },
    {
        "content": "<p>Don't hesitate to post the code either here or on the branch. I'll be happy to diagnose.</p>",
        "id": 272549655,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645312684
    },
    {
        "content": "<p>nevermind, I think I'm an idiot. There was a <code>namespace normed_field</code> and a <code>section normed_field</code> and I think I deleted the wrong corresponding <code>end normed_field</code> which caused there to be a <code>[normed_field α]</code> and a <code>[nondiscrete_normed_field α]</code> at the same time, hence two norms.</p>",
        "id": 272550390,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645313671
    },
    {
        "content": "<p>Wait, no, it's back. I don't understand. Here's the current file. Line 462: <a href=\"/user_uploads/3121/fyqonD12OYDhZscUJSGXlLnq/basic.lean\">basic.lean</a></p>",
        "id": 272550655,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645314017
    },
    {
        "content": "<p>When I instantiate the metavariable from the hole with <code>x</code>, I get this error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">real.norm_of_nonneg</span> <span class=\"o\">(</span><span class=\"n\">norm_nonneg</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">norm_nonneg</span> <span class=\"n\">x</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">has_le.le</span> <span class=\"n\">real</span> <span class=\"n\">real.has_le</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">has_norm.norm</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">semi_normed_group.to_has_norm</span> <span class=\"n\">α</span> <span class=\"n\">_inst_2</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">has_le.le</span> <span class=\"n\">real</span> <span class=\"n\">real.has_le</span> <span class=\"mi\">0</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">has_norm.norm</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">normed_field.to_has_norm</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">nondiscrete_normed_field.to_normed_field</span> <span class=\"n\">α</span> <span class=\"n\">_inst_1</span><span class=\"o\">))</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 272550681,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645314079
    },
    {
        "content": "<p>oh wait, it's seeing a seminormed group from the declaration and a nondiscrete normed field from earlier</p>",
        "id": 272551037,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645314579
    },
    {
        "content": "<p>okay, I made this file happy, thanks.</p>",
        "id": 272551260,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645314881
    },
    {
        "content": "<p>Can someone diagnose why my changes in <a href=\"https://github.com/leanprover-community/mathlib/pull/12132\">#12132</a> broke the usage of <code>ac_refl</code> on line 975 of analysis/asymptotics/asymtopotics.lean? Replacing it with <code>ring</code> solves the goal. My guess is something to do with instance priority for <code>normed_division_ring</code> and it is getting stuck there and failing to recognize commutativity, but I'm not sure.</p>",
        "id": 272563961,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645329933
    },
    {
        "content": "<p>Perhaps it would be best to split this into a \"rename the normed_field stuff\" PR followed by the division_ring stuff - that would make it easier to isolate the problem</p>",
        "id": 272582983,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1645353277
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/12163\">#12163</a>: moves normed field lemmas into root namespace. We'll see how CI goes.</p>",
        "id": 272594470,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645366069
    },
    {
        "content": "<p>Success</p>",
        "id": 272599744,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645372172
    },
    {
        "content": "<p>Anyone want to try to understand why <code>ac_refl</code> fails in commit <code>94b0b05</code> on branch <code>j-loreaux/normed-division-ring</code> (file <code>analysis/asymptotics/asymptotics</code> line 975)? I just pushed another commit to workaround it, but it might be good to understand why it's not working. I don't have the knowledge to know where to start.</p>",
        "id": 272757240,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645501526
    }
]
[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120184\">@David Kurniadi Angdinata</span>, why did you not define <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cubic\">docs#cubic</a> as <code>polynomial.degree_le R 3</code> (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.degree_le\">docs#polynomial.degree_le</a>)?</p>",
        "id": 278832547,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649858504
    },
    {
        "content": "<p>I remember a PR about something similar, let me search.</p>",
        "id": 278833790,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1649859118
    },
    {
        "content": "<p>It's <a href=\"https://github.com/leanprover-community/mathlib/pull/6428\">#6428</a>, but the only explanation is \"Working directly with specific polynomials (like <code>X^n - X - 1</code>) is really painful, since whenever you try to do something simple like checking that the polynomial is monic or computing its degree, you have to prove a bunch of trivial inequalities. Bundling solves this problem\".</p>",
        "id": 278833929,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1649859190
    },
    {
        "content": "<p>right -- proving that the degree of x^2+1 is 2 is surprisingly annoying right now (as one of my UG students found out a few weeks ago)</p>",
        "id": 278834025,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649859243
    },
    {
        "content": "<p>(and it's not even true if R is the zero ring ;-) )</p>",
        "id": 278834064,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649859257
    },
    {
        "content": "<p>I find that working with <code>nat_degree_le</code> is way better.</p>",
        "id": 278885657,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1649881691
    },
    {
        "content": "<p>What Riccardo is describing sounds like a case for a strong dedicated API, but not really a case for a dedicated structure.</p>",
        "id": 278885770,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649881753
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113488-general/topic/Cubics/near/278885657\">said</a>:</p>\n<blockquote>\n<p>I find that working with <code>nat_degree_le</code> is way better.</p>\n</blockquote>\n<p>Certainly, but proving the other inequality is still painful.</p>",
        "id": 278887660,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1649882652
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/Cubics/near/278885770\">said</a>:</p>\n<blockquote>\n<p>What Riccardo is describing sounds like a case for a strong dedicated API, but not really a case for a dedicated structure.</p>\n</blockquote>\n<p>I also came to this conclusion for the trinomials project. I hope to return to it at some point, and see if I can avoid bundled trinomials.</p>",
        "id": 278887794,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1649882712
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> I just thought it was easier to work with four coefficients than with a submodule of R[X], and I was really just following the <code>quadratic_discriminant</code> file that’s already present (PS: can an admin kick my other account? I don’t have access to that one anymore and want to receive the right pings)</p>",
        "id": 278911388,
        "sender_full_name": "David Ang",
        "timestamp": 1649898364
    },
    {
        "content": "<p>When I wrote this I really only needed cubics that aren’t quadratic/linear/constant (so the four coefficients are kinda natural to start from), but I was told to include the degenerate cases as well, so now R[X] &lt;= 3 seems more natural</p>",
        "id": 278912074,
        "sender_full_name": "David Ang",
        "timestamp": 1649899019
    },
    {
        "content": "<p>Just a follow-up on the difficulty of computing explicit <code>nat_degree</code>s, I gave it a shot!  Below is my attempt: it has not been easy!  But I was indeed able to prove that the degree of <code>X^2 + 1</code> is <code>2</code> in any non-trivial semiring!  <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span> </p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Computing degrees</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.polynomial.degree.definitions</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">polynomial</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">C_X_pow_add_C_X_pow1</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">mn</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">C</span> <span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">C</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">C</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">C</span> <span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"n\">add_comm</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nat_degree_monomial_le</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">monomial</span> <span class=\"n\">n</span> <span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nat_degree</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">nat_degree_monomial</span><span class=\"o\">,</span> <span class=\"n\">split_ifs</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nat_degree_add_add</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s0</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">f.nat_degree</span> <span class=\"bp\">≤</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">mn</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">monomial</span> <span class=\"n\">m</span> <span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">monomial</span> <span class=\"n\">n</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nat_degree</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">nat_degree_add_eq_right_of_nat_degree_lt</span><span class=\"o\">,</span> <span class=\"n\">nat_degree_monomial</span><span class=\"o\">,</span> <span class=\"n\">if_neg</span> <span class=\"n\">s0</span><span class=\"o\">],</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">nat_degree_add_le</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans_lt</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">max_lt</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">hf.trans_lt</span> <span class=\"o\">(</span><span class=\"n\">mn.trans_le</span> <span class=\"o\">(</span><span class=\"n\">le_of_eq</span> <span class=\"n\">_</span><span class=\"o\">)),</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nat_degree_monomial</span><span class=\"o\">,</span> <span class=\"n\">if_neg</span> <span class=\"n\">s0</span><span class=\"o\">],</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">nat_degree_monomial_le</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans_lt</span> <span class=\"o\">(</span><span class=\"n\">mn.trans_le</span> <span class=\"o\">(</span><span class=\"n\">le_of_eq</span> <span class=\"n\">_</span><span class=\"o\">)),</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nat_degree_monomial</span><span class=\"o\">,</span> <span class=\"n\">if_neg</span> <span class=\"n\">s0</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nat_degree_add_once</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s0</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">mn</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">monomial</span> <span class=\"n\">m</span> <span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">monomial</span> <span class=\"n\">n</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nat_degree</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">nat_degree_add_eq_right_of_nat_degree_lt</span><span class=\"o\">,</span> <span class=\"n\">nat_degree_monomial</span><span class=\"o\">,</span> <span class=\"n\">if_neg</span> <span class=\"n\">s0</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nat_degree_monomial</span><span class=\"o\">,</span> <span class=\"n\">nat_degree_monomial</span><span class=\"o\">,</span> <span class=\"n\">if_neg</span> <span class=\"n\">s0</span><span class=\"o\">],</span>\n  <span class=\"n\">split_ifs</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">nat.zero_le</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans_lt</span> <span class=\"n\">mn</span><span class=\"o\">,</span>\n  <span class=\"n\">assumption</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">nontrivial</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"c1\">--  my test polynomial: C u * X + X ^ 5 + C s + C t * X ^ 2 + X ^ 8</span>\n<span class=\"c1\">-- {r s t u : R} (r0 : t ≠ 0)</span>\n<span class=\"c1\">--  Kevin's example</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">nat_degree_le</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"bp\">.</span><span class=\"n\">nat_degree</span> <span class=\"bp\">≤</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- First, make sure that all summands are `monomial`s</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">X</span> <span class=\"o\">},</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">C_1</span> <span class=\"o\">},</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">monomial_zero_left</span> <span class=\"o\">},</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">monomial_pow</span> <span class=\"o\">},</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">monomial_mul_monomial</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- and clean up various add_zeros, mul_ones,...</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">monomial_zero_left</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- We peel off each summand and produce goals where we need to show that each summand has</span>\n  <span class=\"c1\">-- degree bounded by our target</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">nat_degree_add_le</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">max_le</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- since our summands are monomials, we know that their degrees are at most their exponents</span>\n  <span class=\"n\">any_goals</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">nat_degree_monomial_le</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">_</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- therefore, `norm_num` should be able to prove the inequalities.</span>\n  <span class=\"n\">all_goals</span> <span class=\"o\">{</span> <span class=\"n\">norm_num</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- {r s t u : R} (r0 : t ≠ 0) (z0 : (1 : R) ≠ 0)</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">le_nat_degree</span> <span class=\"o\">:</span>\n  <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"bp\">.</span><span class=\"n\">nat_degree</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- First, make sure that all summands are `monomial`s</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">X</span> <span class=\"o\">},</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">C_1</span> <span class=\"o\">},</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">monomial_zero_left</span> <span class=\"o\">},</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">monomial_pow</span> <span class=\"o\">},</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">monomial_mul_monomial</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- and clean up various add_zeros, mul_ones,...</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">monomial_zero_left</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- Now that all summands are monomials, we convert them to the form `C r * X ^ n`,</span>\n  <span class=\"c1\">-- with possibly `r = 1` and `n = 0` or `n = 1`, for uniformity.</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">monomial_eq_C_mul_X</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- we also rearrange parentheses, just in case</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">add_assoc</span> <span class=\"o\">},</span>\n\n  <span class=\"c1\">-- mark each summand with a `1 * X`: later on, we will remove these markers, to go deeper into</span>\n  <span class=\"c1\">-- the various summands.  The presence of a `1 *` in a term is our cue that we have not yet</span>\n  <span class=\"c1\">-- rearranged it.</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">one_mul</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]),</span>\n\n  <span class=\"c1\">--  This block sorts the summands in ascending degree of exponent.</span>\n  <span class=\"c1\">--  The number of iterations should be adapted to each case -- this choice works for small cases.</span>\n  <span class=\"c1\">--  We visit each pair of consecutive summands and decide whether we swap them or not.</span>\n  <span class=\"c1\">--  The number of times that we visit all the summands is determined by the first `iterate`.</span>\n  <span class=\"c1\">--  The visits to the summands happens in the second `iterate`.</span>\n  <span class=\"n\">iterate</span> <span class=\"mi\">2</span>\n  <span class=\"c1\">-- The inner loop visits each consecutive pairs of summands and swaps them, if the swap makes the</span>\n  <span class=\"c1\">-- sequence of exponents decrease.</span>\n  <span class=\"o\">{</span> <span class=\"n\">iterate</span> <span class=\"mi\">3</span>\n    <span class=\"o\">{</span> <span class=\"c1\">-- We focus on the first pair.  `C_X_pow_add_C_X_pow1` will swap the two summands</span>\n      <span class=\"c1\">-- creating a proof obligation of showing that the new order is strictly monotone increasing.</span>\n      <span class=\"c1\">-- `norm_num` will try to solve side goal and if it does not succeed, then `refl` fails and</span>\n      <span class=\"c1\">-- the swap does not occur.</span>\n      <span class=\"c1\">-- If `norm_num` succeeds, we have straightened a little, otherwise, the two first terms are</span>\n      <span class=\"c1\">-- in correct order.</span>\n      <span class=\"c1\">--  In either case, after the `try`, we have not increased the number of inversions among the</span>\n      <span class=\"c1\">--  exponents of our summands and it could have decreased.</span>\n      <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">work_on_goal</span> <span class=\"mi\">1</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">C_X_pow_add_C_X_pow1</span><span class=\"o\">,</span> <span class=\"n\">rotate</span><span class=\"o\">,</span> <span class=\"n\">norm_num</span><span class=\"bp\">;</span> <span class=\"n\">refl</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n      <span class=\"c1\">-- so we shift parentheses around isolating the not-yet-visited terms (highlighted by the `1`)</span>\n      <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">add_assoc</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">_</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n      <span class=\"c1\">-- we mark as straightened the term that was just (possibly) rearranged</span>\n      <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">nth_rewrite</span> <span class=\"mi\">0</span> <span class=\"n\">one_mul</span> <span class=\"n\">X</span> <span class=\"o\">},</span>\n      <span class=\"c1\">-- and we prepare to start again with the next pair</span>\n      <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">add_assoc</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">_</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n      <span class=\"c1\">-- We are now outside of the first `iterate`.</span>\n      <span class=\"c1\">-- we clear and replace the markers</span>\n      <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">one_mul</span><span class=\"o\">]</span> <span class=\"o\">},</span> <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">one_mul</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])]</span> <span class=\"o\">},</span>\n      <span class=\"c1\">-- we rearrange parentheses</span>\n      <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">add_assoc</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n\n  <span class=\"c1\">-- Unless we made mistakes (or we looped too little), our expression has exponents sorted in</span>\n  <span class=\"c1\">-- strictly increasing order.</span>\n  <span class=\"c1\">-- We clear the leftover markers</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">one_mul</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- We re-express everything in terms of `monomial`s</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">monomial_eq_C_mul_X</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- Now we strip off each summand from the right-most one back</span>\n  <span class=\"c1\">-- remember that the further right we go, the higher the exponent.</span>\n  <span class=\"c1\">-- Lemma `nat_degree_add_add` creates proof obligations of checking that the ordering is</span>\n  <span class=\"c1\">-- correct and that the various coefficients are non-zero</span>\n  <span class=\"c1\">-- (really, we only need the highest coefficient to be non-zero, the remaining ones might well</span>\n  <span class=\"c1\">-- be zero, but I decided that this was enough!)</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">nat_degree_add_add</span> <span class=\"o\">},</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">nat_degree_add_once</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- Finally, we try to prove these proof obligations using `norm_num` or `assumptions that might</span>\n  <span class=\"c1\">-- be floating around.</span>\n  <span class=\"n\">any_goals</span> <span class=\"o\">{</span> <span class=\"n\">norm_num</span> <span class=\"o\">},</span>\n  <span class=\"n\">all_goals</span> <span class=\"o\">{</span> <span class=\"n\">assumption</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>",
        "id": 279001166,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1649959720
    },
    {
        "content": "<p>Thanks Damiano -- I think you've made my point quite well :-/</p>",
        "id": 279002847,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649960595
    },
    {
        "content": "<p>Btw, the challenge is now to find a polynomial written as a sum of terms with distinct exponents and non-zero coefficients, for which the above code does <em>not</em> compute the degree!</p>",
        "id": 279003322,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1649960827
    },
    {
        "content": "<p>I don't see the issue:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.polynomial.degree.definitions</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nontrivial</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nat_degree</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nat_degree_add_eq_left_of_nat_degree_lt</span><span class=\"o\">,</span> <span class=\"n\">nat_degree_X_pow</span><span class=\"o\">],</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 279004013,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1649961222
    },
    {
        "content": "<p>Sure, I was just giving a general procedure to compute natdegrees of explicit polynomials</p>",
        "id": 279004203,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1649961324
    },
    {
        "content": "<p>Oh, does this work for any polynomial? That's exciting!</p>",
        "id": 279004256,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1649961358
    },
    {
        "content": "<p>Well, it works on 2...</p>",
        "id": 279004797,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1649961664
    },
    {
        "content": "<p>It would be nice to make it a <code>norm_num</code> extension</p>",
        "id": 279005649,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1649962155
    },
    {
        "content": "<p>Patrick, I'm happy to try, but I'm not even entirely sure what is a <code>norm_num</code> extension.</p>\n<p>Moreover, I think that all the code above could be <em>much</em> simpler if I only knew some metaprogramming.  I would need a lot of help with that.</p>",
        "id": 279013995,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1649966347
    },
    {
        "content": "<p><code>norm_num</code> essentially works in an \"extendable\" way, I'm not really sure how. but it means that if you have some definition that you want to evaluate, you don't have to edit the core tactic, you can just do it in a separate file</p>",
        "id": 279031999,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1649977360
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, he made most of this I think</p>",
        "id": 279032013,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1649977373
    },
    {
        "content": "<p>Thanks Eric, I'll look a little at the various <code>norm_num</code> files and will ask questions.</p>",
        "id": 279051050,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1650000227
    },
    {
        "content": "<p>By the way, most of the structure above is about sorting a sum of monomials by degree, which is independent of computing degrees.  I can see if <code>abel</code> or <code>ring</code> works there.</p>",
        "id": 279051135,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1650000323
    }
]
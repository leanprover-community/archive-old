[
    {
        "content": "<p>I'm assuming I've either done something silly here that I've missed, or my lean installation is broken. Should this be expected to timeout?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">algebra</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u1</span> <span class=\"n\">u2</span> <span class=\"n\">u3</span> <span class=\"n\">u4</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u1</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u2</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"n\">class</span> <span class=\"n\">tensor_algebra_class</span>\n  <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u3</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun&#39;</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span><span class=\"err\">ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">T</span><span class=\"o\">)</span>\n<span class=\"c1\">-- (lift : Π {A : Type u4} [semiring A] [algebra R A], (M →ₗ[R] A) → (T →ₐ[R] A))</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">tensor_algebra_class</span>\n</code></pre></div>",
        "id": 205053134,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1595771506
    },
    {
        "content": "<p>I don't know what's going on, but I can tell you it times out for me too.</p>",
        "id": 205053428,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595772045
    },
    {
        "content": "<p>Also, I'm quite confident you should use the same universe level for <code>R</code>, <code>M</code>, <code>T</code>, <code>A</code>.</p>",
        "id": 205053436,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595772067
    },
    {
        "content": "<p>I suspect it has to do with the on the fly reconstruction of bits of the constructor into typeclasses in order to make things like <code>semimodule R T</code> work when you've only been given a bunch of fields. Making <code>algebra R T</code> a parameter fixes the issue</p>",
        "id": 205053539,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595772247
    },
    {
        "content": "<p>a workaround:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">tensor_algebra_mixin</span>\n  <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u3</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun&#39;</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span><span class=\"err\">ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">T</span><span class=\"o\">)</span>\n<span class=\"c1\">-- (lift : Π {A : Type u4} [semiring A] [algebra R A], (M →ₗ[R] A) → (T →ₐ[R] A))</span>\n\n<span class=\"n\">class</span> <span class=\"n\">tensor_algebra_class</span>\n  <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u3</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mixin</span> <span class=\"o\">:</span> <span class=\"n\">tensor_algebra_mixin</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">T</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 205053550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595772301
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/Deterministic.20timeout.20for.20class.20definition/near/205053436\">said</a>:</p>\n<blockquote>\n<p>Also, I'm quite confident you should use the same universe level for <code>R</code>, <code>M</code>, <code>T</code>, <code>A</code>.</p>\n</blockquote>\n<p>I'd disagree with this simply because <code>algebra</code> and <code>module</code> use different universe levels today.</p>",
        "id": 205053555,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1595772309
    },
    {
        "content": "<p>That is also a dubious, but more defensible choice</p>",
        "id": 205053561,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595772325
    },
    {
        "content": "<p>Once you try to characterize an object by a universal property that quantifies over all other objects, it will become extremely unpleasant.</p>",
        "id": 205053613,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595772396
    },
    {
        "content": "<p>As in, once I uncomment <code>lift</code>?</p>",
        "id": 205053620,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1595772425
    },
    {
        "content": "<p>In the <code>is_def_eq_detail</code> trace I see stuff like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">type_context</span><span class=\"bp\">.</span><span class=\"n\">is_def_eq_detail</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">]:</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">to_semimodule</span><span class=\"bp\">._</span><span class=\"n\">proof_5</span> <span class=\"bp\">=</span><span class=\"err\">?</span><span class=\"bp\">=</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">to_semimodule</span><span class=\"bp\">._</span><span class=\"n\">proof_5</span>\n<span class=\"o\">[</span><span class=\"n\">type_context</span><span class=\"bp\">.</span><span class=\"n\">is_def_eq_detail</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">5</span><span class=\"o\">]:</span> <span class=\"bp\">_</span><span class=\"n\">to_algebra</span> <span class=\"bp\">=</span><span class=\"err\">?</span><span class=\"bp\">=</span> <span class=\"bp\">_</span><span class=\"n\">to_algebra_1</span>\n<span class=\"o\">[</span><span class=\"n\">type_context</span><span class=\"bp\">.</span><span class=\"n\">is_def_eq_detail</span><span class=\"o\">]</span> <span class=\"n\">on</span> <span class=\"n\">failure</span><span class=\"o\">:</span> <span class=\"bp\">_</span><span class=\"n\">to_algebra</span> <span class=\"bp\">=</span><span class=\"err\">?</span><span class=\"bp\">=</span> <span class=\"bp\">_</span><span class=\"n\">to_algebra_1</span>\n<span class=\"o\">[</span><span class=\"n\">type_context</span><span class=\"bp\">.</span><span class=\"n\">is_def_eq_detail</span><span class=\"o\">]</span> <span class=\"n\">unfold</span> <span class=\"n\">left</span><span class=\"bp\">&amp;</span><span class=\"n\">right</span><span class=\"o\">:</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">to_semimodule</span><span class=\"bp\">._</span><span class=\"n\">proof_5</span>\n<span class=\"o\">[</span><span class=\"n\">type_context</span><span class=\"bp\">.</span><span class=\"n\">is_def_eq_detail</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">5</span><span class=\"o\">]:</span> <span class=\"o\">(</span><span class=\"n\">id</span>\n   <span class=\"o\">((((</span><span class=\"n\">forall_congr_eq</span> <span class=\"o\">[</span><span class=\"bp\">...</span> <span class=\"n\">many</span> <span class=\"n\">more</span> <span class=\"n\">lines</span> <span class=\"n\">omitted</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 205053627,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595772475
    },
    {
        "content": "<p>I understand <code>_to_algebra</code> is probably an instance argument of <code>algebra.to_semimodule._proof_5</code>, but still why is it doing this work to check a defeq between proofs?</p>",
        "id": 205053676,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595772534
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Deterministic.20timeout.20for.20class.20definition/near/205053550\">said</a>:</p>\n<blockquote>\n<p>a workaround:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">tensor_algebra_mixin</span>\n  <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u3</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun&#39;</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span><span class=\"err\">ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">T</span><span class=\"o\">)</span>\n<span class=\"c1\">-- (lift : Π {A : Type u4} [semiring A] [algebra R A], (M →ₗ[R] A) → (T →ₐ[R] A))</span>\n\n<span class=\"n\">class</span> <span class=\"n\">tensor_algebra_class</span>\n  <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u3</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mixin</span> <span class=\"o\">:</span> <span class=\"n\">tensor_algebra_mixin</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">T</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n</blockquote>\n<p>Note that this is bad, as <code>tensor_algebra_class</code> has a parameter <code>M</code> which is not in <code>algebra R T</code>, so you should not extend it (unless I misunderstand something).</p>",
        "id": 205053728,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1595772623
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Deterministic.20timeout.20for.20class.20definition/near/205053620\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>it will become extremely unpleasant.</p>\n</blockquote>\n<p>As in, once I uncomment <code>lift</code>?</p>\n</blockquote>\n<p>Yes. You cannot quantify over universes so what you have defined is a <code>u3</code>-algebra <code>T</code> that satisfies a universal property with respect to all <code>u4</code>-algebras.</p>",
        "id": 205053729,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595772624
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> Ah, that's true, I didn't look at the original example carefully enough</p>",
        "id": 205053740,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595772669
    },
    {
        "content": "<p>so you probably want the mixin version anyway</p>",
        "id": 205053745,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595772686
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span>, that's good advice</p>",
        "id": 205053789,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1595772723
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> in the perfectoid project we thought we wanted to make a structure which involved quantifying over types in a random universe, but the type theory experts pointed out that we could just quantify over types in the same universe as part of our definition, and then prove the more general universal property as a theorem. My understanding was that you don't really want to be introducing new universe variables in your structures that can't be inferred from the inputs, but that was way back in 2019 before the fork and maybe things are better now</p>",
        "id": 205053796,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595772748
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">tensor_algebra_class</span>\n  <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u3</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">T</span><span class=\"o\">]:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun&#39;</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span><span class=\"err\">ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">T</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>works just fine</p>",
        "id": 205053798,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1595772749
    },
    {
        "content": "<p><span aria-label=\"four leaf clover\" class=\"emoji emoji-1f340\" role=\"img\" title=\"four leaf clover\">:four_leaf_clover:</span> ?</p>",
        "id": 205053799,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1595772751
    },
    {
        "content": "<p>(as in, will the typeclass system in Lean 4 be better?)</p>",
        "id": 205053814,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1595772792
    },
    {
        "content": "<p><span aria-label=\"rainbow\" class=\"emoji emoji-1f308\" role=\"img\" title=\"rainbow\">:rainbow:</span></p>",
        "id": 205053817,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595772797
    },
    {
        "content": "<p>I predict it will be better in at least some respects.</p>",
        "id": 205053820,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595772807
    },
    {
        "content": "<p>The motivation for A and T having different universes came from <a href=\"https://github.com/leanprover-community/mathlib/issues/3531\">#3531</a>, for which I'm trying to work out if  a typeclass-style \"Assume such a construction exists\" type formalization can be used instead of assembling what to me seems like a rather uninteresting definition. That PR used different universes, so I figured I'd try the same</p>",
        "id": 205053825,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1595772835
    },
    {
        "content": "<p>(although admittedly there <code>tensor_algebra R M</code> has universe <code>max u1 u2</code> instead of my <code>T</code> which is <code>u3</code>)</p>",
        "id": 205053875,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1595772888
    },
    {
        "content": "<p><code>A</code> and <code>T</code> having different universes just doesn't work</p>",
        "id": 205053885,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595772913
    },
    {
        "content": "<p>because you cannot characterize an object by its maps into objects in another universe in general</p>",
        "id": 205053893,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595772942
    },
    {
        "content": "<p><code>A</code> and <code>T</code> having the same universe, distinct from <code>R</code> and <code>M</code> could work</p>",
        "id": 205053895,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595772958
    },
    {
        "content": "<p>Maybe I should mention that my initial construction of the tensor algebra is here:<br>\n<a href=\"https://gist.github.com/adamtopaz/84315ae5b11319013707b2d0804fb37e\">https://gist.github.com/adamtopaz/84315ae5b11319013707b2d0804fb37e</a></p>\n<p>Here I quantified over all types of some random universe when defining the relation, and got exactly the universe issues that Kevin mentioned.</p>",
        "id": 205053933,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1595772983
    },
    {
        "content": "<p>but it will just lead to strictly more headaches than simply putting everything in the same universe</p>",
        "id": 205053936,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595772984
    },
    {
        "content": "<p>I mean, they will be different headaches.</p>",
        "id": 205053942,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595773012
    },
    {
        "content": "<p>Does the PR suffer from the same issue, where <code>A</code> is <code>u3</code> and <code>T = tensor_algebra R M</code> is <code>max u1 u2</code>? Or is it exempt because the lemma using both universes does not attempt to be part of a type class?</p>",
        "id": 205053948,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1595773049
    },
    {
        "content": "<p>We are doing mathematics here. In actual mathematics all our objects will be what ZFC people call sets, so in particular they will all be in the same universe. Universe polymorphism is important sometimes, but for definitions like this I don't think it is</p>",
        "id": 205053951,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595773060
    },
    {
        "content": "<p>The PR is different because it is performing a construction</p>",
        "id": 205053992,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595773084
    },
    {
        "content": "<p>The universe level of <code>tensor_algebra R M</code> is the maximum of the universe levels of <code>R</code> and <code>M</code>, as it should be.</p>",
        "id": 205053993,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1595773086
    },
    {
        "content": "<p>But the universal property is proved for maps into algebras with arbitrary universe levels.</p>",
        "id": 205054001,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1595773105
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>, just to emphasize I'm super excited by your PR, and this is me trying to understand alternatives not criticise your approach :)</p>",
        "id": 205054005,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1595773113
    },
    {
        "content": "<p>also, someone can always come along and set <code>u1 = u2 = u</code> to get the plain case where the universes agree</p>",
        "id": 205054006,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595773119
    },
    {
        "content": "<p>however, this will probably cause Lean some difficulties</p>",
        "id": 205054009,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595773132
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Deterministic.20timeout.20for.20class.20definition/near/205053951\">said</a>:</p>\n<blockquote>\n<p>We are doing mathematics here. In actual mathematics all our objects will be what ZFC people call sets, so in particular they will all be in the same universe. Universe polymorphism is important sometimes, but for definitions like this I don't think it is</p>\n</blockquote>\n<p>If you have as a component of your structure a lift into every set, then the structure isn't a set (in ZFC)</p>",
        "id": 205054016,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595773146
    },
    {
        "content": "<p>because unification with universe levels of the form <code>max ?u_1 ?u_2</code> is hard</p>",
        "id": 205054019,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595773154
    },
    {
        "content": "<p>Right, so in the perfectoid project our universal property in the definition stuck with the same universe and we proved a theorem afterwards saying it worked with different universes too</p>",
        "id": 205054020,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595773157
    },
    {
        "content": "<p>(or at least, too hard for Lean's elaborator)</p>",
        "id": 205054025,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595773183
    },
    {
        "content": "<p>Lean will not unify <code>max ?u_1 ?u_2 = u</code> anyway, it knows that <code>max</code> is not injective</p>",
        "id": 205054068,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595773230
    },
    {
        "content": "<p>it will not unify <code>max ?u_1 ?u_2 = max u v</code></p>",
        "id": 205054072,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595773247
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Deterministic.20timeout.20for.20class.20definition/near/205054020\">said</a>:</p>\n<blockquote>\n<p>we proved a theorem afterwards saying it worked with different universes too</p>\n</blockquote>\n<p>Would you mind linking to that theorem?</p>",
        "id": 205054117,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1595773328
    },
    {
        "content": "<p>the workaround to \"having a function quantify over a universe in a component in the structure\" is \"don't\"</p>",
        "id": 205054120,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1595773341
    },
    {
        "content": "<p>This comes up sometimes in the category theory library because there are a lot of constructions whose results live in various complicated universes, and I think there are even instances which are declared for the sole purpose of enabling instance search to guess the right values of universe levels.</p>",
        "id": 205054123,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595773377
    },
    {
        "content": "<p>It's really just not worth dealing with these issues if you don't have to.</p>",
        "id": 205054139,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595773416
    },
    {
        "content": "<p>Actually, I stand corrected, lean will unify <code>max u v = max ?u ?v</code> even though it really shouldn't</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"n\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">variable</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">))</span>\n<span class=\"kn\">set_option</span> <span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">universes</span> <span class=\"n\">true</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">foo</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"c1\">-- foo.{u v} = x : Prop</span>\n</code></pre></div>",
        "id": 205054246,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595773577
    },
    {
        "content": "<p>Kevin, in the perfectoid space project, I think you only used a single universe variable at a time, right?</p>",
        "id": 205054258,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595773627
    },
    {
        "content": "<p>this <code>max</code> problem causes issues with <code>cardinal.lift</code> etc</p>",
        "id": 205054263,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1595773633
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/Deterministic.20timeout.20for.20class.20definition/near/205053895\">said</a>:</p>\n<blockquote>\n<p><code>A</code> and <code>T</code> having the same universe, distinct from <code>R</code> and <code>M</code> could work</p>\n</blockquote>\n<p>Oh I remembered the other issue, which is that with three general universe levels for <code>R</code>, <code>M</code>, <code>A = T</code>, your definition might \"work\", but be wrong!</p>",
        "id": 205054303,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595773684
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> if you start playing with universes, don't forget to <code>git pull</code> first because I just pushed two commits to your branch.</p>",
        "id": 205054319,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1595773752
    },
    {
        "content": "<p>The problem is if <code>R</code> lives in <code>u1</code>, <code>M</code> lives in <code>u2</code>, <code>T</code> lives in <code>u3</code>, and <code>u3</code> is not at least <code>max u1 u2</code>, then there might not be enough interesting <code>u3</code>-<code>R</code>-algebras with a map from <code>M</code> to map <code>T</code> into</p>",
        "id": 205054323,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595773787
    },
    {
        "content": "<p>so then you want <code>A</code> to live in <code>max u1 u2 u3</code></p>",
        "id": 205054371,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595773850
    },
    {
        "content": "<p>Because the actual tensor algebra will usually really live in universe <code>max u1 u2</code>, and so whatever the object <code>T</code> described by this universal property happens to be, it certainly can't be the correct tensor algebra (most likely, it simply doesn't exist).</p>",
        "id": 205054385,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595773888
    },
    {
        "content": "<p>Right, you can do that, but then Lean is likely to never understand how to guess <code>u3</code></p>",
        "id": 205054425,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595773928
    },
    {
        "content": "<p>it's in the type of <code>T</code> though?</p>",
        "id": 205054427,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595773942
    },
    {
        "content": "<p>Oh, <code>A</code> not <code>T</code></p>",
        "id": 205054430,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595773962
    },
    {
        "content": "<p>Ah, I think I see your complaint now -<code>u4</code> is part of the <code>tensor_algebra_class</code> type as I wrote it, not just part of the quantifier. Is that a correct interpretation?</p>",
        "id": 205054447,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1595774011
    },
    {
        "content": "<p>that could work, but then you can't even prove that two different tensor algebras <code>T</code> are isomorphic without jumping through a bunch of <code>ulift</code> hoops</p>",
        "id": 205054448,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595774012
    },
    {
        "content": "<p>yeah it won't be pleasant</p>",
        "id": 205054450,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595774030
    },
    {
        "content": "<p>and all of these issues could have been dealt with up front by <code>ulift</code> anyways</p>",
        "id": 205054451,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595774032
    },
    {
        "content": "<p>by just moving <code>R</code> and <code>M</code> into the same universe</p>",
        "id": 205054489,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595774054
    },
    {
        "content": "<p>I agree with Kenny's recommendation: avoid universe quantification in definitions</p>",
        "id": 205054491,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595774070
    },
    {
        "content": "<p>if you can get an \"internal\" definition use that instead, and prove the universal property as a lemma</p>",
        "id": 205054494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595774103
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Deterministic.20timeout.20for.20class.20definition/near/205054447\">said</a>:</p>\n<blockquote>\n<p>Ah, I think I see your complaint now -<code>u4</code> is part of the <code>tensor_algebra_class</code> type as I wrote it, not just part of the quantifier. Is that a correct interpretation?</p>\n</blockquote>\n<p>Yes, it is a parameter of the class, and it is impossible to quantify over universe variables in a forall like this.</p>",
        "id": 205054498,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595774117
    },
    {
        "content": "<blockquote>\n<p>by just moving R and M into the same universe</p>\n</blockquote>\n<p>What's the motivation for <code>semimodule</code> putting <code>R</code> and <code>M</code> into different universes?</p>",
        "id": 205054501,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1595774122
    },
    {
        "content": "<p>they are both parameters to <code>semimodule</code></p>",
        "id": 205054506,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595774138
    },
    {
        "content": "<p>the preferred default is to have all input types be in unconstrained universes and for the output type to be derived from the inputs. That way universe inference is always easy</p>",
        "id": 205054552,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595774203
    },
    {
        "content": "<p>generally if you have two \"unrelated\" types, they should probably be in different universes</p>",
        "id": 205054599,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595774286
    },
    {
        "content": "<p>but if you make a concrete definition like <code>real</code>, it should live in the lowest permissible universe</p>",
        "id": 205054609,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595774342
    },
    {
        "content": "<p>There's plenty of stuff you can do with <code>semimodule</code> before the universe headaches start, and once they do you can just specialize to the same universe and it doesn't cost too much.</p>",
        "id": 205054663,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595774417
    },
    {
        "content": "<p>And the definition is really correct for all possible pairs of universe levels</p>",
        "id": 205054669,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595774453
    },
    {
        "content": "<p>and because things like <code>real</code> being in a fixed universe <code>Type 0</code>, which penalizes the \"just use a single universe and save yourself a lot of bother\" approach, there's a range of applications where it's more convenient to allow distinct universes because it avoids <code>ulift</code></p>",
        "id": 205054723,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595774532
    },
    {
        "content": "<p>but as soon as you would have to use <code>ulift</code> <em>anyways</em> to prove things like \"two objects with the same universal property are isomorphic\" then it's no longer worth keeping it up</p>",
        "id": 205054733,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595774589
    },
    {
        "content": "<p>For another example, I think the usual definition of a projective module as \"lifts against surjections\" is wrong when the module's universe is less than the ring's universe.</p>",
        "id": 205054781,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595774694
    },
    {
        "content": "<p>And also, what Kevin said earlier. In real math, even if the objects are not just sets, we can always move them into the same universe and work there, and this is what people do. If supporting extra universe generality in the formalization doesn't cause any headaches, then great, but if it does, then it's just not worth it to create actual extra math problems for yourself.</p>",
        "id": 205054904,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595774912
    },
    {
        "content": "<p>(Unless of course you're specifically interested in those problems, similarly to proving something constructively for its own sake.)</p>",
        "id": 205054914,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595774942
    },
    {
        "content": "<p>Also it's worth noting that working with everything in the same universe is no loss of generality since you can always pick a universe large enough and then <code>ulift</code> everything. So moving to one-universe is just deferring the <code>ulift</code> to the application rather than the theory</p>",
        "id": 205054970,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595775045
    },
    {
        "content": "<p>A valuation on a ring R is a pair(Gamma,v) where Gamma is a (certain kind of) monoid and v : R -&gt; Gamma is a map with some properties. We initially let Gamma be in a different universe to R. Let M(v) be the image of v; this is a submonoid. Two valuations v1 and v2 are _equivalent_ if there's an isomorphism M(v1)=M(v2) making the diagram commute. We only cared about valuations up to equivalence.</p>",
        "id": 205055147,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595775397
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> why not define it as an \"ordered congruence\" on R?</p>",
        "id": 205055298,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1595775659
    },
    {
        "content": "<p>We wanted that the type of equivalence class of valuations on R lived in the same universe as R. This was problematic for two reasons. Firstly, we had let Gamma vary through all universes, and secondly, even if we restricted to one universe, the equivalence  classes bumped the universe level up by one. </p>\n<p>We solved both of these problems at the same time and it might be difficult to see the wood from the trees. In the perfectoid project the relevant files are <code>valuation.basic</code> and <code>valuation_spectrum</code>. The bump-universe-by-one issue is solved using a binary relation on R, and the universe issue was solved by only considering valuations taking values in monoids living in the same universe as R, and then proving that if we had a valuation R -&gt; Gamma where Gamma was in some different universe to R, then there was an equivalent valuation taking values in some Gamma' in the same universe as R. We did this by using the first isomorphism theorem: R/equiv-coming-from-v is isomorphic to im(v), and R/equiv-coming-from-v lives in the same universe as R.</p>",
        "id": 205055352,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595775726
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> this is what we did in the end, but this was not because of the universe issue we're talking about, this was for a different universe issue.</p>",
        "id": 205055354,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595775754
    },
    {
        "content": "<p>My takeaway:</p>\n<ol>\n<li>We should avoid using different universes in our (concrete) theory development without loss of generality since the chosen universe could be a sufficiently large one as pointed out by <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> .</li>\n<li>We could use different universes when PRing mathlib but we should follow rules pointed out by <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> , and if we encounter any headaches about universes we could use the specializing strategy suggested by <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> and it should be good enough for most interesting math.</li>\n<li>Using the same universe for the definitions doesn’t stop us from proving that the theorems work for different universes later as long as the math allows the constructs to be dragged into the same universe as done in perfectoid project by <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> et al.</li>\n<li>The discussions above make a great library note worth PRing.</li>\n</ol>",
        "id": 205055878,
        "sender_full_name": "Utensil Song",
        "timestamp": 1595776728
    },
    {
        "content": "<p>1 is good enough for justifying using the same universe. I was just curious about how it could be relaxed later after fixing the same universe in 3 and it’s now perfectly explained.</p>",
        "id": 205056120,
        "sender_full_name": "Utensil Song",
        "timestamp": 1595777165
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 205056621,
        "sender_full_name": "Utensil Song",
        "timestamp": 1595778119
    },
    {
        "content": "<p>Concerning this specific construction--</p>\n<p>When I  originally made the construction in the \"universal\" way, i.e. using the following relation:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">rel</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">pre</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">pre</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"k\">by</span> <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">h1</span><span class=\"bp\">;</span> <span class=\"n\">exact</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"k\">by</span> <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">h2</span><span class=\"bp\">;</span> <span class=\"n\">exact</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span><span class=\"err\">ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"n\">lift_fun</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">lift_fun</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">y</span>\n</code></pre></div>\n\n\n<p>I obtained a construction <code>tensor_algebra.{u1 u2 u3}</code> with three universe levels. The <code>u1</code> is the universe level of <code>R</code>, the <code>u2</code> is the one of <code>M</code> and the <code>u3</code> is the one of <code>A</code> appearing in the definition of <code>rel</code>. </p>\n<p>But note that <code>tensor_algebra.{u1 u2 u3} R M : Type (max u1 u2)</code>.</p>\n<p>The issue with this is that the universal property (which is true \"by construction\" in this case) could only be easily proved for <code>R</code>-algebras whose underlying type has universe level <code>u3</code>. So as Reid, Kevin, and others mentioned, one would have had to prove the existence of some isomorphism between these objects for varying <code>u3</code>, and in particular for <code>u3 = max u1 u2</code>. It seemed much easier to just change the definition of <code>rel</code> to what it is now in <a href=\"https://github.com/leanprover-community/mathlib/issues/3531\">#3531</a></p>",
        "id": 205057726,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1595780124
    },
    {
        "content": "<p>Unrelated to your point, but... is the <code>by letI := ...; exact</code> a workaround for something I haven't run into yet?</p>",
        "id": 205064233,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1595791822
    },
    {
        "content": "<p>It's a trick that <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> told me about that lets you introduce instances in term mode.</p>",
        "id": 205064307,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1595792016
    },
    {
        "content": "<p>But it's not really term mode.</p>",
        "id": 205064315,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1595792041
    },
    {
        "content": "<p>There's some information about the <code>fooI</code> tactics <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#Instance%20cache%20tactics\">here</a>.</p>",
        "id": 205064420,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1595792236
    },
    {
        "content": "<p>Does the following not work there to avoid needing <code>letI</code>?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">rel</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">pre</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">pre</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span><span class=\"err\">ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"n\">lift_fun</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">lift_fun</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">y</span>\n</code></pre></div>",
        "id": 205064960,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1595793336
    },
    {
        "content": "<p>This doesn't work.</p>",
        "id": 205065446,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1595794138
    },
    {
        "content": "<p>The following emoji has been mentioned in relation to this: <span aria-label=\"four leaf clover\" class=\"emoji emoji-1f340\" role=\"img\" title=\"four leaf clover\">:four_leaf_clover:</span></p>",
        "id": 205065459,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1595794182
    },
    {
        "content": "<p>You want <code>exactI</code>, not <code>letI</code> here</p>",
        "id": 205065462,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595794199
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">rel</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">pre</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">pre</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">],</span> <span class=\"k\">by</span> <span class=\"n\">exactI</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span><span class=\"err\">ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"n\">lift_fun</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">lift_fun</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">y</span>\n</code></pre></div>",
        "id": 205065504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595794222
    },
    {
        "content": "<p>Oh nice!</p>",
        "id": 205065513,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1595794248
    },
    {
        "content": "<p>So exactI just picks up all the instances in context?</p>",
        "id": 205065528,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1595794310
    },
    {
        "content": "<p>yep</p>",
        "id": 205065581,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595794343
    }
]
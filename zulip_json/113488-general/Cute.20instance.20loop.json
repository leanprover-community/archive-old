[
    {
        "content": "<p>I just ran into a cute instance loop. A : if <code>K</code> is a field, it is a (finite-dimensional) vector space over itself. B : if <code>K</code> is a complete normed field, then any finite dimensional vector space over <code>K</code> is complete (I have just completed the proof of this fact). Combining these two, to prove the completeness of a normed field <code>K</code>, Lean will try to use the completeness of <code>K</code>, and loop.</p>\n<p>My problem is that these two instances are natural and useful, and I would like to keep both of them. In Lean 3, if I understand correctly, I can't, and I should not register B as an instance. <span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span>, can you confirm that this will not be a problem in Lean 4? (Another problem with this instance in Lean 3, by the way, is that to prove the completeness of <code>E</code> Lean will start to look for an instance of <code>vector_space ?m1 E</code> for whatever <code>?m1</code>, and then it will try all the fields it knows about, and there are tons of them -- will this also be OK in Lean 4?)</p>",
        "id": 180118035,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573121661
    },
    {
        "content": "<p>Wait... so given a <code>normed_field K</code> that is <code>complete K</code>, you ask Lean to prove <code>complete K</code>, and it is like... yeah I know that <code>K</code> is a fin.dim vector space over this field <code>K</code>. So I can prove that <code>K</code> is complete, if this field <code>K</code> is a complete normed field. Hmmm... it's clear that <code>K</code> is a normed field, because the instance is <em>staring me right in the face</em>. Now let's see if I can prove that <code>K</code> is complete. Ooh, I know that <code>K</code> is a fin.dim vector space over... ... ...</p>",
        "id": 180118932,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1573122587
    },
    {
        "content": "<p>Can't instances in the local context have some sort of infinite priority over instances coming from the library?</p>",
        "id": 180119653,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1573123120
    },
    {
        "content": "<p>Oooh... never mind. It's more complicated.<br>\nIf you <em>don't</em> have <code>complete K</code> in your context, and you still want to infer <code>complete K</code> for some reason (maybe it is a finite field extension of something complete)... then you can still run into this loop.</p>",
        "id": 180119715,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1573123196
    },
    {
        "content": "<p>So somehow <code>complete_of_fin_dim_over_complete</code> should never be tried for vector space = base field.</p>",
        "id": 180119788,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1573123245
    },
    {
        "content": "<p>So we need <code>@[inference_hint := assert (¬¨ (E = K))]</code></p>",
        "id": 180119960,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1573123414
    },
    {
        "content": "<p>Yes, this is very funny. For instance, asking <code>complete_space ‚Ñö</code> loops forever (or rather, it hits <code>instance_max_depth</code> quickly). Of course, I will never ask Lean to prove that <code>‚Ñö</code> is complete, but this might show up in some instance search if Lean is trying the wrong path.</p>",
        "id": 180120335,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573123696
    },
    {
        "content": "<p>Could you show the types of these instances?</p>",
        "id": 180122054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573125240
    },
    {
        "content": "<p>Whichever instance involves looking for a field metavariable sounds like it shouldn't be an instance</p>",
        "id": 180122148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573125358
    },
    {
        "content": "<p>I don't think lean should always have every true relation between classes as an instance. It's not capitulation to say that some of them should be invoked explicitly</p>",
        "id": 180122224,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573125420
    },
    {
        "content": "<p>If I understand correctly, instance A is <code>vector_space K K &lt;- field K</code>, which seems fine, and B is <code>complete V &lt;- complete_normed_field K, vector_space K V</code> which does not look fine because the <code>K</code> is free</p>",
        "id": 180122358,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573125597
    },
    {
        "content": "<p>If B was <code>complete_vector_space K V</code> it wouldn't be a problem</p>",
        "id": 180122417,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573125626
    },
    {
        "content": "<p>But given that completeness is a property only of <code>V</code> (and its metric structure), you should already \"know\" that it is complete without having to do proof search to find out. That is, I would expect instances of the form <code>complete V</code> for every concrete <code>V</code> (like <code>real</code>), or it should be in the context. Perhaps we want to prove that <code>real</code> is a complete space by proving that it is a vector space over another complete field, in which case we would apply that lemma (and supply the choice of <code>K</code>), but it's not a search lean should be doing on its own</p>",
        "id": 180122747,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573125876
    },
    {
        "content": "<p>Hmmm... you've told us this fact many times by now. For some reason it catches me by surprise time and again. I wonder when I will finitely learn this principle.</p>",
        "id": 180124149,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1573127270
    },
    {
        "content": "<p>I know, this is why I did not register it as an instance. But I find this a little bit sad, as this is an important, useful and nontrivial way to prove that a space is complete. Here is the type of the theorem</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">finite_dimensional</span><span class=\"bp\">.</span><span class=\"n\">complete</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">{</span><span class=\"err\">ùïú</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">nondiscrete_normed_field</span> <span class=\"err\">ùïú</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">normed_group</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_3</span> <span class=\"o\">:</span> <span class=\"n\">normed_space</span> <span class=\"err\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_6</span> <span class=\"o\">:</span> <span class=\"n\">complete_space</span> <span class=\"err\">ùïú</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_7</span> <span class=\"o\">:</span> <span class=\"n\">finite_dimensional</span> <span class=\"err\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">],</span> <span class=\"n\">complete_space</span> <span class=\"n\">E</span>\n</pre></div>",
        "id": 180126478,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573129322
    },
    {
        "content": "<p>A way out could be to define a class <code>complete_nondiscrete_normed_field</code> extending both <code>nondiscrete_normed_field</code> and <code>complete_space</code>, and use it in the assumption. What do you think of this approach?</p>",
        "id": 180126597,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573129430
    },
    {
        "content": "<blockquote>\n<p>But I find this a little bit sad, as this is an important, useful and nontrivial way to prove that a space is complete</p>\n</blockquote>\n<p>This is the sentiment I hope to combat by saying \"it's not capitulation\". Just because it's true doesn't mean it's a good way <em>for lean to find out</em> that a space is complete</p>",
        "id": 180126953,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573129769
    },
    {
        "content": "<p>Are there any examples where this is the desired way to prove completeness of a space?</p>",
        "id": 180126973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573129797
    },
    {
        "content": "<p>I think this is a nice theorem, and the mere fact that it is entirely about typeclasses doesn't qualify it as an instance. There are plenty of other nice theorems which are not instances, it's not a second class status</p>",
        "id": 180127133,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573129935
    },
    {
        "content": "<p><code>complete_nondiscrete_normed_field</code> doesn't solve the problem, since it is only merging two assumptions on <code>K</code> without addressing the fact that <code>K</code> doesn't appear in the consequent <code>complete_space E</code></p>",
        "id": 180127248,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573130058
    },
    {
        "content": "<p>This is definitely used to prove completeness. For instance, if you want to check completeness of euclidean space, you can either make a messy computation with a clever blend of epsilons and Cauchy-Schwarz, or apply directly the theorem. More importantly, I want to write theorems with an assumption <code>[finite_dimensional R E]</code> and be able to use the completeness of <code>E</code> in the proof. Of course, I can put <code>haveI : complete_space E := ...</code> at the beginning of each such proof, but it will be tedious to say the least.</p>",
        "id": 180127377,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573130185
    },
    {
        "content": "<p><code>complete_nondiscrete_normed_field</code> solves the looping problem, but I agree it does not solve the fact that there would be a metavariable in instance search.</p>",
        "id": 180127402,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573130220
    },
    {
        "content": "<p>Is <code>R</code> the reals?</p>",
        "id": 180127421,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573130237
    },
    {
        "content": "<p>I would solve that by having a class <code>euclidean_space E</code> that implies <code>finite_dimensional R E</code> and <code>complete_space E</code></p>",
        "id": 180127456,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573130274
    },
    {
        "content": "<p>Yes, sorry for the lack of unicode. Complex numbers and p-adics are also good examples.</p>",
        "id": 180127513,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573130292
    },
    {
        "content": "<p>For those, you just prove <code>complete_space C</code> and <code>complete_space Q_[p]</code></p>",
        "id": 180127529,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573130319
    },
    {
        "content": "<p>Yes, but this looks like a useless class as it is exactly equivalent to <code>finite_dimensional R E</code>.</p>",
        "id": 180127532,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573130327
    },
    {
        "content": "<p>What I mean is that I will want to use completeness of finite-dimensional spaces over <code>C</code> and <code>Q_p</code>.</p>",
        "id": 180127554,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573130363
    },
    {
        "content": "<p>you could also take it as an assumption, of course</p>",
        "id": 180127575,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573130390
    },
    {
        "content": "<p>this would be the obviously correct way to do it if <code>complete_space</code> had data</p>",
        "id": 180127633,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573130415
    },
    {
        "content": "<p>What about <code>complete_fd K E</code>?</p>",
        "id": 180127692,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573130472
    },
    {
        "content": "<p>seems like this isn't much different from having a class <code>vector_space</code> (which is completely useless since it means the same as <code>module</code>)</p>",
        "id": 180127761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573130532
    },
    {
        "content": "<p>You mean, two typeclass assumptions <code>finite_dimensional K E</code> and <code>complete_space E</code>, while the second one is implied by the first one? This looks like a hackish workaround instead of a real solution, but I agree it would work fine. I think I would rather go for the explicit instance at the beginning of each proof.</p>",
        "id": 180127778,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573130549
    },
    {
        "content": "<p><code>complete_fd</code> is the conjunction of those classes</p>",
        "id": 180127803,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573130577
    },
    {
        "content": "<p>Yes, and therefore completely equivalent to <code>finite_dimensional K E</code>!</p>",
        "id": 180127830,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573130601
    },
    {
        "content": "<p>These have data, though, don't they?</p>",
        "id": 180127840,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573130612
    },
    {
        "content": "<p><code>complete_space E</code> has to have a metric and stuff</p>",
        "id": 180127852,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573130623
    },
    {
        "content": "<p>The difference with <code>vector_space</code> is that this class is just here to make mathematicians comfortable.</p>",
        "id": 180127858,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573130631
    },
    {
        "content": "<p>No, <code>complete_space</code> is a mixin over <code>metric_space</code>, without data.</p>",
        "id": 180127911,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573130650
    },
    {
        "content": "<p>hm, maybe fix that then</p>",
        "id": 180127925,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573130659
    },
    {
        "content": "<p>it's not mixin very well</p>",
        "id": 180127946,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573130680
    },
    {
        "content": "<p>The topological hierarchy has a spine <code>topological_space &lt;- uniform_space &lt;- metric_space</code>, and additional mixins specifying zillions of properties. It seems to work pretty well!</p>",
        "id": 180128001,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573130727
    },
    {
        "content": "<p>If you want to build stuff on top of a mixin though, it needs to be merged in</p>",
        "id": 180128046,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573130762
    },
    {
        "content": "<p>I don't get it. We have a lot of theorems with assumptions <code>[topological_space \\alpha] [t1_space \\alpha]</code> or <code>[metric_space \\alpha] [second_countable \\alpha] [complete_space \\alpha]</code>. There are so many possibilitiesof combination of the mixins that I don't see how we could merge anything.</p>",
        "id": 180128135,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573130866
    },
    {
        "content": "<p>Those are all over one type though. it's not like <code>[complete_space A -&gt; complete_space B]</code> is a class</p>",
        "id": 180128220,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573130953
    },
    {
        "content": "<p>but that's basically what <code>finite_dimensional A B</code> is doing here</p>",
        "id": 180128237,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573130980
    },
    {
        "content": "<p>What I get from this discussion is the confirmation that my theorem <code>finite_dimensional.complete</code> should not be an instance, because of the metavariable in the search, and that I should rather instantiate it explicitly when I need it. Is that reasonable?</p>",
        "id": 180128443,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573131135
    },
    {
        "content": "<p>Yes, that should work</p>",
        "id": 180128508,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573131219
    },
    {
        "content": "<p>Why are these even typeclasses? They look like hypotheses to me</p>",
        "id": 180128510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573131221
    },
    {
        "content": "<p>You mean, <code>finite_dimensional K E</code>? It is a typeclass in the current linear algebra framework. This seems reasonable as then it can be derived automatically for products, for function types over a fintype, for <code>K</code> itself, and so on.</p>",
        "id": 180128637,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573131335
    },
    {
        "content": "<p>I love that a mathematician and a computer scientist are having a chat about a completely basic theorem but the chat actually has some content. Why hasn't this question been solved 20 years ago? Is there an analogous question for this theorem in Coq and Isabelle, and if so, then do the answers just not help at all? Or did they not get as far as this theorem yet?</p>",
        "id": 180128647,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1573131343
    },
    {
        "content": "<p>When we start on local fields, which we'll have to do at some point, the first thing we'll need is that a finite dimensional field extension of the p-adic numbers is complete.</p>",
        "id": 180128726,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1573131407
    },
    {
        "content": "<p>I mean <code>topological_property A</code></p>",
        "id": 180128754,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573131439
    },
    {
        "content": "<p>They aren't being used to define anything, and they are rather more like mathematical assumptions than structures</p>",
        "id": 180128842,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573131490
    },
    {
        "content": "<p>You know, this is not really a trivial theorem. I am sure it is not in Isabelle. I don't think it is in Coq either, as they don't have a lot of topology. The proof over real numbers is in the undergraduate cursus, and easy by compactness, but the proof for complete fields is really harder, by induction on the dimension. By the way, for the proof to compile in reasonable time, I had to add</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">local</span> <span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">,</span> <span class=\"n\">priority</span> <span class=\"mi\">10000</span><span class=\"o\">]</span> <span class=\"n\">pi</span><span class=\"bp\">.</span><span class=\"n\">module</span> <span class=\"n\">normed_space</span><span class=\"bp\">.</span><span class=\"n\">to_vector_space</span>\n  <span class=\"n\">vector_space</span><span class=\"bp\">.</span><span class=\"n\">to_module</span> <span class=\"n\">submodule</span><span class=\"bp\">.</span><span class=\"n\">add_comm_group</span> <span class=\"n\">submodule</span><span class=\"bp\">.</span><span class=\"n\">module</span>\n  <span class=\"n\">linear_map</span><span class=\"bp\">.</span><span class=\"n\">finite_dimensional_range</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">complete</span> <span class=\"n\">nondiscrete_normed_field</span><span class=\"bp\">.</span><span class=\"n\">to_normed_field</span>\n</pre></div>\n\n\n<p>to help Lean a little bit!</p>",
        "id": 180128908,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573131558
    },
    {
        "content": "<p>see, I don't want lean to choke on this instance</p>",
        "id": 180128954,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573131595
    },
    {
        "content": "<p>For <code>topological_property A</code>, it is the same: these properties are typically derived automatically for products, function spaces, and so on.</p>",
        "id": 180129040,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573131622
    },
    {
        "content": "<p>If this theorem were recast as a structural rule it would be unproblematic. Something like <code>complete_space K -&gt; complete_space (K^n)</code></p>",
        "id": 180129119,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573131695
    },
    {
        "content": "<p>I guess this also has to do with the earlier move away from modules having a unique base field</p>",
        "id": 180129208,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573131756
    },
    {
        "content": "<p><code>K^n</code> comes with some metric (the sup metric), for which completeness is true and easy. The point of the theorem (and what makes it nontrivial) is that you get completeness whatever the metric.</p>",
        "id": 180129227,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573131769
    },
    {
        "content": "<p>sounds like a search to me</p>",
        "id": 180129304,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573131818
    },
    {
        "content": "<blockquote>\n<p>You know, this is not really a trivial theorem.</p>\n</blockquote>\n<p>I totally agree -- by \"basic\" I mean everyone knows it and assumes it.</p>",
        "id": 180129394,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1573131879
    },
    {
        "content": "<p>I would be very interested to read the thoughts of <span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> about how we should do this in Lean 4.</p>",
        "id": 180129396,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573131879
    },
    {
        "content": "<p>I mean, if you really want lean to do the search, I think you can do so, but you need a bunch more typeclasses to guide the search better</p>",
        "id": 180129411,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573131888
    },
    {
        "content": "<p>I don't know what the best in-principle solution is, since I don't really know what you expect it to do here</p>",
        "id": 180129540,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573131982
    },
    {
        "content": "<p>do you want every <code>complete_space</code> to search for a vector space instance, a field and all that? <code>complete_space</code>s don't even have to be algebraic</p>",
        "id": 180129577,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573132019
    },
    {
        "content": "<p>If we are just reasoning forward from the context then this seems like a good forward reasoning rule</p>",
        "id": 180129693,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573132088
    },
    {
        "content": "<p>I don't know if lean 4 supports that but I would really like to see forward reasoning in typeclass search</p>",
        "id": 180129717,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573132114
    },
    {
        "content": "<p>If Lean is quick enough to do the silly  search in all cases, realize very quickly if my space is not algebraic, and go on a better path if needed, yes, I would be very happy. If this is not possible, I can live with it and give the instance myself :)</p>",
        "id": 180129794,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573132198
    },
    {
        "content": "<p>Unfortunately I think that the lean 4 algorithm won't help here, because the failing search really is infinite</p>",
        "id": 180129894,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573132259
    },
    {
        "content": "<p>There are an infinite number of fields, and an infinite number of failing assumptions <code>finite_dimensional (real x real x ... x real) E</code></p>",
        "id": 180129990,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573132329
    },
    {
        "content": "<p>actually those aren't fields, but I can't be bothered to think of an actual field constructor</p>",
        "id": 180129993,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573132333
    },
    {
        "content": "<p><code>algebraic_closure (algebraic_closure (... algebraic_closure (C)))))</code></p>",
        "id": 180130074,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573132419
    },
    {
        "content": "<p>The algorithm that I think would actually work would be to see that <code>complete_space R</code> and <code>finite_dimensional R E</code> are in the context, and derive <code>complete_space E</code>; then search for <code>complete_space E</code> and find it in the context</p>",
        "id": 180130179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573132486
    },
    {
        "content": "<p>Yes, such a forward search would be very useful!</p>",
        "id": 180130294,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573132580
    },
    {
        "content": "<p>Forward reasoning also works really well for \"parent\" instances, like if I want <code>has_add G</code> I can start from <code>add_group G</code> and populate the context with all subinstances of it (<code>add_monoid G</code>, <code>has_add G</code>, <code>has_zero G</code>) followed by the usual backward search</p>",
        "id": 180130339,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573132625
    },
    {
        "content": "<p>rather than trawling the entire algebraic hierarchy</p>",
        "id": 180130356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1573132641
    },
    {
        "content": "<blockquote>\n<p>I would be very interested to read the thoughts of <span class=\"user-mention silent\" data-user-id=\"230999\">Daniel Selsam</span> about how we should do this in Lean 4.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> Can you please share a minimal, self-contained example that loops? For this purpose, you can just make the classes empty as in <a href=\"https://github.com/leanprover/lean4/blob/master/tests/elabissues/typeclass_triggers_typeclass.lean\" target=\"_blank\" title=\"https://github.com/leanprover/lean4/blob/master/tests/elabissues/typeclass_triggers_typeclass.lean\">https://github.com/leanprover/lean4/blob/master/tests/elabissues/typeclass_triggers_typeclass.lean</a></p>\n<p>In general, the rule in Lean 4 is as follows:</p>\n<p>- If you literally reach the same goal twice (upto alpha equivalence), Lean4 will detect and do the right thing.<br>\n- You can still cause typeclass resolution to run forever in some cases, but to do this the generated goals must be getting bigger and bigger.</p>",
        "id": 180138503,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1573137908
    },
    {
        "content": "<p>Here is the minimal example:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">Field</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"n\">class</span> <span class=\"n\">VectorSpace</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">VectorSpaceSelf</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">VectorSpace</span> <span class=\"n\">K</span> <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">constructor</span>\n\n<span class=\"n\">class</span> <span class=\"n\">CompleteSpace</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">bad</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">VectorSpace</span> <span class=\"n\">K</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CompleteSpace</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">CompleteSpace</span> <span class=\"n\">E</span> <span class=\"o\">:=</span>\n  <span class=\"k\">by</span> <span class=\"n\">constructor</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">loops</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">CompleteSpace</span> <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n</pre></div>\n\n\n<p><code>loops</code> should fail as there is no way to get completeness out of thin air, but Lean 3 will loop on it. It will try to apply the instance <code>bad</code> (as it sees <code>K</code> as a vector space over itself), and for this it will need the completeness of <code>K</code>, and therefore it loops.  From what you say, your Lean 4 algorithm should succeed on that one, which is very nice.</p>\n<p>Then, there is a second potential issue. When applying the instance <code>bad</code>, Lean knows the vector space <code>E</code> (from the type of the desired conclusion), but it does not know which field to choose, so it will try every field it has at its disposal. In this example, it can not go wild. But what happens if one adds, say,</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">AlgebraicClosure</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"n\">K</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">AlgebraicClosure</span><span class=\"bp\">.</span><span class=\"n\">Field</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Field</span> <span class=\"o\">(</span><span class=\"n\">AlgebraicClosure</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">constructor</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">loops_even_more</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">CompleteSpace</span> <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n</pre></div>\n\n\n<p>Here, I guess <code>loops_even_more</code> will also fail in Lean 4 as it will try to apply <code>bad</code> to more and more complicated fields, constructed by iterated algebraic closure. Is that indeed the case?</p>",
        "id": 180140798,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573139330
    },
    {
        "content": "<p>Thanks. The first example will fail quickly in Lean4 since it is the same goals being solved over and over again, and Lean4 will detect this and do the right thing.</p>",
        "id": 180142205,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1573140139
    },
    {
        "content": "<p>I hope that there is also a cheap heuristic that gives the loop in the second example a very low priority</p>",
        "id": 180142501,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1573140334
    },
    {
        "content": "<p>Sometimes you need to alternate some constructions several times in a row, but it isn't very common. One example is:</p>\n<ul>\n<li>Take the field Q. this field is not algebraically closed, and not complete</li>\n<li>complete for the p-adic valuation to get Q_p. this field is not algebraically closed, it is complete</li>\n<li>take the algebraic closure to get Q_p-bar. this field is algebraically closed, it is not complete</li>\n<li>take the completion, to get C_p. this field is algebraically closed and it is complete.</li>\n</ul>\n<p>However, I certainly don't expect the typeclass system to figure out such things for me. So in general, I would like the type class system to be very hesitant to apply such constructors multiple times.</p>",
        "id": 180143039,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1573140611
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 180143420,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1573140842
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 180144484,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1573141465
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 180144570,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1573141528
    },
    {
        "content": "<p>Great! I was afraid it would do the following: try to apply <code>bad ?K K</code> where <code>?K</code> is an unknown complete field over which one would like <code>K</code> to have a vector space structure. Since it doesn't know which field to use, what does Lean4 do to fill the meta-variable <code>?K</code>? Does it try all the fields it knows about, like <code>AlgebraicClosure K</code>, or is it more clever?</p>",
        "id": 180144679,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573141572
    },
    {
        "content": "<p>For instance, in Lean 3,</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">works_fine</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CompleteSpace</span> <span class=\"o\">(</span><span class=\"n\">AlgebraicClosure</span> <span class=\"n\">K</span><span class=\"o\">)]</span>\n  <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">VectorSpace</span> <span class=\"o\">(</span><span class=\"n\">AlgebraicClosure</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">CompleteSpace</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n</pre></div>\n\n\n<p>works fine, so Lean3 is clever enough to try to fill the metavariable with <code>AlgebraicClosure K</code> (probably using what it sees in the context?)</p>",
        "id": 180145204,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573141899
    },
    {
        "content": "<p>What I wrote before was wrong. Lean4 will indeed still loop in your second example. I apologize for the confusion.</p>",
        "id": 180147614,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1573143283
    },
    {
        "content": "<p>Would it be reasonable to change the behavior to the following one: if one encounters an instance in which there are Type variables which can not be inferred directly, then</p>\n<ul>\n<li>either there is something in the context which matches the instance, then use it </li>\n<li>or fail</li>\n</ul>\n<p>This would prevent the search from getting completely crazy, and still it would allow instances with Type metavariables, which can be handy in situations like the one discussed in the above thread. Are there situations where this is obviously wrong? (Or, as a middle ground, could one have an attribute on instances to say that they should follow this behavior -- all this is for Lean4, of course).</p>",
        "id": 180154276,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573147598
    },
    {
        "content": "<p>Or an attribute <code>instance_search.restricted</code> or whatever, that one could set to choose the behavior between the current one and the less recursive one?</p>",
        "id": 180155319,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573148360
    },
    {
        "content": "<p>How about just having a <code>maxGoalSize</code> flag, and refusing to consider any intermediate goals beyond that size? This works for your second example, and fails quickly even when set very high. Con: it would not work well if there were a combinatorial number of pretty-big-but-not-too-big undesired goals.</p>",
        "id": 180155853,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1573148760
    },
    {
        "content": "<p>Otherwise typeclass resolution might still run forever when it is e.g. bigger <code>Nat</code>s that are being created, as opposed to bigger types.</p>",
        "id": 180156244,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1573148998
    },
    {
        "content": "<p>Or even max recursion size. Currently, when the maximal recursion depth is reached, instance search fails with an error message. It could instead fail on the branch it is, and resume the search on the next branch. I am still afraid that this or your <code>maxGoalSize</code> could lead to a combinatorial explosion. </p>\n<p>In Lean3, we avoid completely instances with Type metavariables because of this risk of combinatorial explosion. I think only allowing them when one can solve them from the context would solve most of our use cases.</p>",
        "id": 180158025,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573150159
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> See <a href=\"https://github.com/leanprover/lean4/blob/9a7354633a18ce73039549cfb4a019fe74e7d09f/tests/elabissues/typeclass_nested_validate.lean\" target=\"_blank\" title=\"https://github.com/leanprover/lean4/blob/9a7354633a18ce73039549cfb4a019fe74e7d09f/tests/elabissues/typeclass_nested_validate.lean\">https://github.com/leanprover/lean4/blob/9a7354633a18ce73039549cfb4a019fe74e7d09f/tests/elabissues/typeclass_nested_validate.lean</a> for more analysis, suggested workaround, and tentative plan for Lean4.</p>",
        "id": 180190118,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1573171067
    },
    {
        "content": "<p>That's extremely clever!</p>",
        "id": 180207357,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1573196500
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> That's a really nice idea. And if I understand correctly, we can even try to use this already in Lean 3. That's cool.</p>",
        "id": 180213064,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1573204146
    }
]
[
    {
        "content": "<p>I'm creating instances for a bundled <code>hom</code> type:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order</span><span class=\"bp\">.</span><span class=\"n\">preorder_hom</span>\n<span class=\"kn\">import</span> <span class=\"n\">order</span><span class=\"bp\">.</span><span class=\"n\">lattice</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simps</span> <span class=\"o\">{</span><span class=\"n\">rhs_md</span> <span class=\"o\">:=</span> <span class=\"n\">semireducible</span><span class=\"o\">}]</span>\n<span class=\"kn\">instance</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span><span class=\"err\">ₘ</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">partial_order</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"n\">preorder_hom</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"err\">$</span> <span class=\"k\">by</span> <span class=\"n\">rintro</span> <span class=\"bp\">⟨⟩</span> <span class=\"bp\">⟨⟩</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">congr</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">h</span>\n\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simps</span><span class=\"o\">]</span>\n<span class=\"kn\">instance</span> <span class=\"o\">[</span><span class=\"n\">semilattice_sup</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">semilattice_sup</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span><span class=\"err\">ₘ</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">sup</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"err\">⊔</span> <span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">sup_le_sup</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">monotone</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">monotone</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">le_sup_left</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">le_sup_left</span><span class=\"o\">,</span>\n  <span class=\"n\">le_sup_right</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">le_sup_right</span><span class=\"o\">,</span>\n  <span class=\"n\">sup_le</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">h₀</span> <span class=\"n\">h₁</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">sup_le</span> <span class=\"o\">(</span><span class=\"n\">h₀</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n  <span class=\"bp\">..</span> <span class=\"o\">(</span><span class=\"bp\">_</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span><span class=\"err\">ₘ</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- generates</span>\n<span class=\"c1\">-- preorder_hom.semilattice_sup_sup_to_fun : ∀ {α : Type u_1} [_inst_1 : preorder α] {β : Type u_2}</span>\n<span class=\"c1\">-- [_inst_4 : semilattice_sup β] (f g : α →ₘ β) (a : α),</span>\n<span class=\"c1\">-- ⇑(semilattice_sup.sup f g) a = (f.to_fun ⊔ g.to_fun) a</span>\n</code></pre></div>\n\n\n<p><code>simps</code> generates the wrong equality for <code>sup</code>. I'd like it to generate <code>⇑(semilattice_sup.sup f g) a = f a ⊔ g a</code>. Is this possible and if so how?</p>",
        "id": 209114165,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1599236782
    },
    {
        "content": "<p>Update: Defining <code>sup</code> as:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">sup</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"err\">⊔</span> <span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">sup_le_sup</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">monotone</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">monotone</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n</code></pre></div>\n\n\n<p>does it but why does <code>simps</code> not know that we can distribute function application and <code>sup</code> on pi types?</p>",
        "id": 209114379,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1599236913
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> Do you think <code>simps</code> could be made to take here of <a href=\"https://github.com/leanprover-community/mathlib/pull/4125#discussion_r487682684\">https://github.com/leanprover-community/mathlib/pull/4125#discussion_r487682684</a>?</p>",
        "id": 209975004,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1600070564
    }
]
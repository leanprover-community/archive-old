[
    {
        "content": "<p>Are there some specifications for intermediate representation Lean uses? If so, where can I find them?<br>\nHow can I dump the IR of a given lean program? <br>\nThanks, <br>\nMatt</p>",
        "id": 191729686,
        "sender_full_name": "Matthew Weingarten",
        "timestamp": 1585134664
    },
    {
        "content": "<p>Do you mean something like the export format? <a href=\"https://github.com/leanprover-community/lean/blob/master/doc/export_format.md\" title=\"https://github.com/leanprover-community/lean/blob/master/doc/export_format.md\">https://github.com/leanprover-community/lean/blob/master/doc/export_format.md</a> The type theory is explained in <a href=\"https://github.com/digama0/lean-type-theory\" title=\"https://github.com/digama0/lean-type-theory\">https://github.com/digama0/lean-type-theory</a></p>",
        "id": 191732155,
        "sender_full_name": "Anton Lorenzen",
        "timestamp": 1585136220
    },
    {
        "content": "<p>Another interesting IR is the bytecode used by the VM (which is used by <code>#eval</code> and for tactics).  You can view the generated bytecode by enabling an option:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">set_option</span> <span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">compiler</span><span class=\"bp\">.</span><span class=\"n\">optimize_bytecode</span> <span class=\"n\">true</span>\n<span class=\"n\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">42</span>\n</pre></div>",
        "id": 191732336,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1585136339
    },
    {
        "content": "<p>Thanks for the responses Gabriel. I think the Bytecode IR is interpreted in the lean3 system is that correct? I am looking more in the direction of the lean4 IR, basically, the one described in the 'Counting Immutable Beans' as the lambda pure IR.</p>",
        "id": 191753517,
        "sender_full_name": "Matthew Weingarten",
        "timestamp": 1585146790
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/\" title=\"https://github.com/leanprover/lean4/\">https://github.com/leanprover/lean4/</a></p>",
        "id": 191753749,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1585146895
    },
    {
        "content": "<p>Thanks as well Anton, is this IR only used for typechecking?</p>",
        "id": 191753864,
        "sender_full_name": "Matthew Weingarten",
        "timestamp": 1585146949
    },
    {
        "content": "<p>Oh it took a while to click, I  understand now, everything is done by set_options command in the .lean file ( so set_option trace.compiler.labda_pure true) <br>\nThanks for the help!</p>",
        "id": 191755323,
        "sender_full_name": "Matthew Weingarten",
        "timestamp": 1585147491
    },
    {
        "content": "<p>Hey, what exactly is the difference between the IRs generated by these two commands? </p>\n<div class=\"codehilite\"><pre><span></span>set_option trace.compiler.ir.init true\n</pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span>set_option trace.compiler.lambda_pure true\n</pre></div>\n\n\n<p>Can I assume they are semantically equivalent? From anecdotal evidence on small programs they seem to produce the same code, but just show lambda-calculus functions in more 'traditional' style.</p>",
        "id": 192124747,
        "sender_full_name": "Matthew Weingarten",
        "timestamp": 1585404156
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 192124953,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1585404419
    },
    {
        "content": "<p>The Lean 4 compiler has 2 distinct phases, one where it treats the code as pure functional code, which <code>lambda_pure</code> seems to print results from, and one where it uses the IR and treats it as imperative code. In functional transformations, you have things like common subexpression eliminations and constant folding and I'm not sure if <code>lambda_pure</code> includes those. If it does include all of those, you could see <code>lambda_pure</code> as the output of the functional phase and <code>ir.init</code> as the input of the next phase. I recommend looking through the Lean source code for <code>lambda_pure</code> and seeing if it has done all the functional optimizations at the time where it prints it.</p>",
        "id": 192129135,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1585410772
    },
    {
        "content": "<p>No, they are exactly the same IR. The only difference is that <code>lambda_pure</code> is traced from C++ and <code>ir.init</code> from Lean. One of them could be removed.</p>",
        "id": 192129572,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1585411388
    },
    {
        "content": "<p>OK great! Thanks for the answer Sebastian, very helpful.</p>",
        "id": 192133010,
        "sender_full_name": "Matthew Weingarten",
        "timestamp": 1585416167
    },
    {
        "content": "<p>Also thank you Simon! I am fairly sure lambda pure includes those as it is written in the paper, that exactly the way I am looking at it so far (output of the functional phase)</p>",
        "id": 192133172,
        "sender_full_name": "Matthew Weingarten",
        "timestamp": 1585416408
    }
]
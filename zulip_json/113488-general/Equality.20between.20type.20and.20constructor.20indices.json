[
    {
        "content": "<p>What is the recommended way to deal with this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">T</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk₁</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk₂</span> <span class=\"o\">{</span><span class=\"n\">xs</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">xs</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">])</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]))</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">s</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"c1\">-- cases tactic failed, unsupported equality between type and constructor indices</span>\n  <span class=\"n\">assumption</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>It can be solved by replacing <code>xs ++ [x]</code> with another variable and then substituting it back.<br>\nFor example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]))</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">s</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">revert</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">generalize</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">xs</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"o\">(</span><span class=\"n\">list.append_eq_nil.mp</span> <span class=\"n\">h₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">list.reverse</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">++</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"n\">_</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">rcases</span> <span class=\"n\">h₁</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">assumption</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Is there a better way?</p>",
        "id": 270470810,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1643841801
    },
    {
        "content": "<p><code>cases</code> can automatically deal with goals that cannot apply because they are different constructors to an inductive type. To explain, let's consider the easier case of <code>nat</code>:</p>\n<ul>\n<li><code>nat.succ n</code> and <code>nat.zero</code> are different constructors, so <code>cases</code> can prove this:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat.succ</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"n\">nat.zero</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"o\">}</span>\n</code></pre></div>\n<ul>\n<li><code>n + 1</code> and <code>0</code> reduce to different constructors (after unfolding definitions this is the same problem as before - addition on natural numbers is defined by recursion on the second argument), so <code>cases</code> can also deal with this:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"o\">}</span>\n</code></pre></div>\n<ul>\n<li><code>1 + n</code> and <code>0</code> do <em>not</em> reduce to different constructors. In fact, since <code>+</code> is defined by recursion on the second argument, <code>1 + n</code> doesn't reduce at all. Of course the terms are unequal, but <code>cases</code> cannot find this for you. So this doesn't work:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>How this applies to your example is that <code>xs ++ [x]</code> is not a different constructor from <code>[]</code>, since <code>++</code> is defined by recursion on the first argument. One way to solve this, is to replace <code>xs ++ [x]</code> by <code>x :: xs</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">T</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk₁</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk₂</span> <span class=\"o\">{</span><span class=\"n\">xs</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">xs</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">s</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"c1\">-- works!</span>\n  <span class=\"n\">assumption</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I don't know if this works in your actual use case.</p>",
        "id": 270535972,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1643888755
    },
    {
        "content": "<p>I know how <code>cases</code> work, I didn't expect from <code>cases,assumption</code> to solve the goal. My question was, if you already have a type defined like <code>T</code> which uses append singleton instead of cons, and you need to prove <code>T xs</code> from <code>T (xs ++ [x])</code>, how would you do it?</p>\n<p>Is there a tactic similar to cases that fallbacks to eq whenever it fails to unify using defeq? I would like a tactic that can transform this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]))</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">s</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases'</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Into this:</p>\n<div class=\"codehilite\" data-code-language=\"txt\"><pre><span></span><code>Two goals:\n\nα: Type\ns: set α\nx: α\nxs: list α\nh: xs ++ [x] = []\n⊢ T s xs\n\nα: Type\ns: set α\nx: α\nxs ys: list α\ny: α\nh₁: T s ys\nh₂: y ∈ s\nh₃: xs ++ [x] = ys ++ [y]\n⊢ T s xs\n</code></pre></div>\n<p>And then we could easily prove it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]))</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">s</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases'</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"o\">(</span><span class=\"n\">list.append_eq_nil.mp</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"n\">h₃</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"n\">list.reverse</span> <span class=\"n\">h₃</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h₃</span><span class=\"o\">,</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">h₃</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 270558541,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1643899146
    },
    {
        "content": "<p>Try <code>import tactic.induction</code>: it will provide the <code>cases'</code> tactic that will does what you want (it does not support custom induction principles though).</p>",
        "id": 270561953,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1643900299
    }
]
[
    {
        "content": "<p>I wanted to prove the following function, but I've run into problems at the commented line<br>\nSeems like lean interprets <code>≤ </code> in <code>le_of_not_lt h₂</code> as the <code>le</code> defined in <code>linear_order</code> instead of <code>semilattice_sup_bot</code>, while <code>lattice.sup_of_le_left </code> requires <code>le</code> defined by <code>semilattice_sup_bot</code>...<br>\nHow can I fix this?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finset</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">finest</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kn\">parameters</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">semilattice_sup_bot</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_linear_order</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">mem_of_sup_id&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"err\">∅</span> <span class=\"bp\">→</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">sup</span> <span class=\"n\">id</span> <span class=\"err\">∈</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">induction_on</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">false</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">)))</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">notin</span> <span class=\"n\">ih</span> <span class=\"n\">notempty</span><span class=\"o\">,</span> <span class=\"k\">begin</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">insert_eq</span><span class=\"o\">,</span> <span class=\"n\">sup_union</span><span class=\"o\">,</span> <span class=\"n\">mem_union</span><span class=\"o\">,</span> <span class=\"n\">sup_singleton</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n        <span class=\"n\">simp</span><span class=\"o\">,</span>\n        <span class=\"n\">generalize</span> <span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">sup</span> <span class=\"n\">y</span> <span class=\"n\">id</span> <span class=\"bp\">=</span> <span class=\"n\">y&#39;</span><span class=\"o\">,</span>\n        <span class=\"k\">from</span> <span class=\"k\">if</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"err\">∅</span>\n        <span class=\"k\">then</span> <span class=\"k\">begin</span>\n            <span class=\"n\">left</span><span class=\"o\">,</span>\n            <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">sup_empty</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n            <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span><span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">sup_bot_eq</span><span class=\"o\">],</span>\n        <span class=\"kn\">end</span>\n        <span class=\"k\">else</span> <span class=\"k\">begin</span>\n            <span class=\"k\">from</span> <span class=\"k\">if</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y&#39;</span>\n            <span class=\"k\">then</span> <span class=\"k\">begin</span>\n                <span class=\"n\">right</span><span class=\"o\">,</span>\n                <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">sup_of_le_right</span> <span class=\"o\">(</span><span class=\"n\">le_of_lt</span> <span class=\"n\">h₂</span><span class=\"o\">),</span> <span class=\"err\">←</span><span class=\"n\">hy</span><span class=\"o\">],</span>\n                <span class=\"n\">apply</span> <span class=\"n\">ih</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n            <span class=\"kn\">end</span>\n            <span class=\"k\">else</span> <span class=\"k\">begin</span>\n                <span class=\"n\">left</span><span class=\"o\">,</span>\n                <span class=\"c1\">--rw [lattice.sup_of_le_left (le_of_not_lt h₂)],</span>\n            <span class=\"kn\">end</span>\n        <span class=\"kn\">end</span>\n    <span class=\"kn\">end</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">finset</span>\n</pre></div>",
        "id": 150822083,
        "sender_full_name": "AHan",
        "timestamp": 1543895720
    },
    {
        "content": "<p>You are introducing two orders which have nothing to do with each other, as both <code>semilattice_sup_bot</code> and <code>decidable_linear_order</code> contain an order. Instead, you need to start from one order only, and add some \"mixin\", i.e., some property of the order but not a new order. For instance, in <code>data/finset.lean</code>, you have</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">sup_lt</span> <span class=\"o\">[</span><span class=\"n\">is_total</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">⊥</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">sup</span> <span class=\"n\">f</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span>\n</pre></div>\n\n\n<p>Your problem can be solved in the same way.</p>",
        "id": 150828636,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1543908089
    },
    {
        "content": "<p>So I have to define another class which includes properties of <code>semilattice_sup_bot</code> and <code>decidable_linear_order</code>?</p>",
        "id": 150829193,
        "sender_full_name": "AHan",
        "timestamp": 1543909039
    },
    {
        "content": "<p>Yes, I think so. So you define a class that <code>extends (semilattice_sup_bot X) (decidable_linear_order X).</code> I think you can just put a <code>.</code> after that extends statement, and then it will merge those two classes. You don't need any extra conditions, so you don't need a <code>:= (foo : blah)</code> part.</p>",
        "id": 150829404,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543909347
    },
    {
        "content": "<p>But this is all from memory, so I might be wrong.</p>",
        "id": 150829408,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543909358
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  I've tried, but it outputs the error message :<br>\n\"invalid 'structure' header, field 'le' from 'decidable_linear_order' has already been declared\"...</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">decidable_semilattice_sup_bot</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"o\">(</span><span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">semilattice_sup_bot</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">decidable_linear_order</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">.</span>\n</pre></div>\n\n\n<p><code>function expected at  lattice.semilattice_sup_bot α term has type  Type ?</code></p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">decidable_semilattice_sup_bot</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"o\">(</span><span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">semilattice_sup_bot</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">decidable_linear_order</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">.</span>\n</pre></div>",
        "id": 150829714,
        "sender_full_name": "AHan",
        "timestamp": 1543909906
    },
    {
        "content": "<p>Hmm, then I don't know. Maybe others can help.</p>",
        "id": 150829776,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543909973
    },
    {
        "content": "<p>I checked <code>semilattice_sup_bot</code> which is extended from <code>order_bot</code> and <code>semilattice_sup</code>, and both of them are extended from <code>partial_order</code>, but it doesn't seems to conflict in this case...</p>",
        "id": 150829847,
        "sender_full_name": "AHan",
        "timestamp": 1543910106
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  Solved! Have to <code>set_option</code> lol</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">set_option</span> <span class=\"n\">old_structure_cmd</span> <span class=\"n\">true</span>\n<span class=\"n\">class</span> <span class=\"n\">decidable_semilattice_sup_bot</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">semilattice_sup_bot</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">decidable_linear_order</span> <span class=\"n\">α</span>\n</pre></div>",
        "id": 150830288,
        "sender_full_name": "AHan",
        "timestamp": 1543910752
    },
    {
        "content": "<p>This whole aspect of the type class inference system is very cumbersome. It would not surprise me if somewhere someone had made exactly the typeclass that you need to give you the structure you want, but finding it is another matter. The type class system is extremely fussy when it comes to this sort of thing. I am not sure how long the old structure command option will be around for...</p>",
        "id": 150830341,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543910807
    },
    {
        "content": "<p>Although someone will no doubt come along and suggest a fix for your use case that doesn't involve the old structure command, I don't know how to solve this sort of problem in general. I guess it would be nice to be able to define the structures you wanted and then precisely insert them into the type class system by hand.</p>",
        "id": 150830498,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543911028
    },
    {
        "content": "<p>I thought the entire type class system is going to be redone in <span class=\"emoji emoji-1f340\" title=\"four leaf clover\">:four_leaf_clover:</span>. So by then <code>old_structure_cmd</code> will be <code>ancient_structure_cmd</code> and our current structures will be <code>old_structure</code>...</p>",
        "id": 150830584,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543911191
    },
    {
        "content": "<p>Ancient ! LOL</p>",
        "id": 150830640,
        "sender_full_name": "AHan",
        "timestamp": 1543911266
    },
    {
        "content": "<p>As I tried to say, you can prove your lemma without introducing a new class, with</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finset</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">finest</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">semilattice_sup_bot</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_total</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)]</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">mem_of_sup_id&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"err\">∅</span> <span class=\"bp\">→</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">sup</span> <span class=\"n\">id</span> <span class=\"err\">∈</span> <span class=\"n\">a</span>\n<span class=\"bp\">...</span>\n</pre></div>",
        "id": 150830741,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1543911470
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span>  That's nice! Thanks a lot!</p>",
        "id": 150830975,
        "sender_full_name": "AHan",
        "timestamp": 1543911803
    },
    {
        "content": "<p>(the typeclass inference system and the structure command are really quite orthogonal topics)</p>",
        "id": 150831357,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1543912258
    },
    {
        "content": "<p>There are no semantic change planned so far for either of them. Though hopefully you'll be able to \"just\" copy and modify the structure command in Lean 4, after it's rewritten in Lean.</p>",
        "id": 150831579,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1543912640
    },
    {
        "content": "<blockquote>\n<p>orthogonal topics</p>\n</blockquote>\n<p>Well, probably they are to a dev. Maybe the dev's answer to this question is \"go and define the right mixins\". The problems with this approach are (1) it doesn't seem to scale and (2) it confuses newcomers. It also means that mathematicians constantly make fun of Lean having a theory of distribs :D</p>",
        "id": 150831588,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543912680
    },
    {
        "content": "<p>We have explicitl  promise that Johan will be able to define <code>ancient_structure</code> and <code>fancy_johan_structure</code> that will reuse parts of the grammar of the built-in command. <a href=\"http://leanprover.github.io/presentations/20181012_MSR/#/1\" target=\"_blank\" title=\"http://leanprover.github.io/presentations/20181012_MSR/#/1\">http://leanprover.github.io/presentations/20181012_MSR/#/1</a></p>",
        "id": 150831711,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543912805
    },
    {
        "content": "<p>Oh, I was too slow finding back the slides, Sebastian already mentioned it</p>",
        "id": 150831727,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543912839
    },
    {
        "content": "<p>Ultimately mathematicians will want to define five new concepts A B C D E, and then 2^5 more concepts of the form \"put together this subset of A B C D E\" and will want all the obvious compatibiities to hold and will want them all to be typeclasses. Now the two concepts are kind of mixed together. I thought we had the explicit promise that nothing was going to change? In the back of my mind I always figured that if the type class system wasn't up to some complicated collection of maths structures then the answer is simple -- just don't use it.</p>",
        "id": 150831755,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543912890
    },
    {
        "content": "<p>Oh but maybe I am beginning to understand the future better. The devs will leave us the structure command and type class system as it is, but will give us the tools to tweak it so that perhaps I can still do these 2^5 things in my own way and add exactly the fields I want to the type class inference system or whatever.</p>",
        "id": 150831836,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543913031
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span>  Sorry, I forgot to ask, what if I also wanted the decidable instance?<br>\nI can't just add <code>[decidable_rel (≤)]</code>...</p>",
        "id": 150832214,
        "sender_full_name": "AHan",
        "timestamp": 1543913603
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variable</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">basic_thing</span> <span class=\"n\">α</span> <span class=\"kn\">extends</span> <span class=\"n\">has_mul</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">basic</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- mathematically sensible object</span>\n<span class=\"kn\">structure</span> <span class=\"n\">extension1</span> <span class=\"n\">α</span> <span class=\"kn\">extends</span> <span class=\"n\">basic_thing</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">thing1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">thing2</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- mathematically sensible object</span>\n<span class=\"kn\">structure</span> <span class=\"n\">extension2</span> <span class=\"n\">α</span> <span class=\"kn\">extends</span> <span class=\"n\">basic_thing</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">thing2</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">thing3</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">axiom1</span> <span class=\"o\">:</span> <span class=\"n\">thing2</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">thing3</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- mathematically sensible object</span>\n<span class=\"kn\">structure</span> <span class=\"n\">extension3</span> <span class=\"n\">α</span> <span class=\"kn\">extends</span> <span class=\"n\">basic_thing</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">thing2</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">thing7</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">axiom2</span><span class=\"o\">:</span> <span class=\"n\">thing7</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">thing2</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- mathematically sensible object</span>\n<span class=\"kn\">structure</span> <span class=\"n\">extension23</span> <span class=\"n\">α</span> <span class=\"kn\">extends</span> <span class=\"n\">basic_thing</span> <span class=\"n\">α</span> <span class=\"o\">:=</span><span class=\"bp\">...</span>\n<span class=\"c1\">-- I want to extend extension2 and extension3</span>\n<span class=\"c1\">-- but now I have to start defining mixins</span>\n\n<span class=\"c1\">-- insert 1000 lines of code here</span>\n\n<span class=\"c1\">-- object I realise I want later on</span>\n<span class=\"kn\">structure</span> <span class=\"n\">extension123</span> <span class=\"n\">α</span> <span class=\"kn\">extends</span> <span class=\"n\">basic_thing</span> <span class=\"n\">α</span> <span class=\"o\">:=</span><span class=\"bp\">...</span>\n<span class=\"c1\">-- oh dear, I now have to go back and refactor</span>\n<span class=\"c1\">-- everything because I want to extend 1 and 2 and 3 now</span>\n<span class=\"c1\">-- so maybe I need to remix my mixins</span>\n<span class=\"c1\">-- but the mixins are artificial objects anyway, I don&#39;t</span>\n<span class=\"c1\">-- really want to make new ones :-/</span>\n</pre></div>",
        "id": 150832300,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543913745
    },
    {
        "content": "<p>You need to annotate the <code>(≤)</code> in <code>[decidable_rel (≤)]</code>: <code>[decidable_rel ((≤) : α -&gt; α -&gt; Prop)]</code></p>",
        "id": 150832348,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1543913775
    },
    {
        "content": "<p>@AHan what happens if you just add exactly the extra hypotheses you need and then insert them manually into the type class inference system?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"bp\">...</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">extra_axiom</span> <span class=\"n\">alpha</span><span class=\"o\">)</span> <span class=\"bp\">...</span> <span class=\"c1\">-- round brackets not square</span>\n<span class=\"bp\">...</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"c1\">-- manually insert</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">decidable_linear_order</span> <span class=\"n\">alpha</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"c1\">-- manually build },</span>\n<span class=\"bp\">...</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 150832432,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543913896
    },
    {
        "content": "<p>You will I guess need to import <code>tactic.interactive</code> for this, from mathlib</p>",
        "id": 150832451,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543913958
    },
    {
        "content": "<p>Aah -- Johannes has a better solution ;-)</p>",
        "id": 150832529,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543914025
    },
    {
        "content": "<p>Still doesn't work at <code>(le_of_not_lt h₂)</code> in this case...</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finset</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">finset</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">semilattice_sup_bot</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"o\">((</span><span class=\"bp\">≤</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">is_total</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)]</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">mem_of_sup_id</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"err\">∅</span> <span class=\"bp\">→</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">sup</span> <span class=\"n\">id</span> <span class=\"err\">∈</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">induction_on</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">false</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">)))</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">notin</span> <span class=\"n\">ih</span> <span class=\"n\">notempty</span><span class=\"o\">,</span> <span class=\"k\">begin</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">insert_eq</span><span class=\"o\">,</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sup_union</span><span class=\"o\">,</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_union</span><span class=\"o\">,</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sup_singleton</span><span class=\"o\">],</span>\n        <span class=\"n\">simp</span><span class=\"o\">,</span>\n        <span class=\"k\">from</span> <span class=\"k\">if</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"err\">∅</span>\n        <span class=\"k\">then</span> <span class=\"k\">begin</span>\n            <span class=\"n\">left</span><span class=\"o\">,</span>\n            <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sup_empty</span><span class=\"o\">,</span> <span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">sup_bot_eq</span><span class=\"o\">],</span>\n        <span class=\"kn\">end</span>\n        <span class=\"k\">else</span> <span class=\"k\">begin</span>\n            <span class=\"k\">from</span> <span class=\"k\">if</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">sup</span> <span class=\"n\">id</span>\n            <span class=\"k\">then</span> <span class=\"k\">begin</span>\n                <span class=\"n\">right</span><span class=\"o\">,</span>\n                <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">sup_of_le_right</span> <span class=\"o\">(</span><span class=\"n\">le_of_lt</span> <span class=\"n\">h₂</span><span class=\"o\">)],</span>\n                <span class=\"n\">apply</span> <span class=\"n\">ih</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n            <span class=\"kn\">end</span>\n            <span class=\"k\">else</span> <span class=\"k\">begin</span>\n                <span class=\"n\">left</span><span class=\"o\">,</span>\n                <span class=\"c1\">--rw [lattice.sup_of_le_left (le_of_not_lt h₂)],</span>\n            <span class=\"kn\">end</span>\n        <span class=\"kn\">end</span>\n    <span class=\"kn\">end</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">finset</span>\n</pre></div>",
        "id": 150832535,
        "sender_full_name": "AHan",
        "timestamp": 1543914032
    },
    {
        "content": "<p>@AHan can you post fully working code? I am lost with the imports, sections, parameters etc. I can try and fix it but it would be nice to just be able to cut and paste one thing</p>",
        "id": 150832627,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543914175
    },
    {
        "content": "<p>Sorry, I don't understand sections, parameters etc as well as most of the others here :-)</p>",
        "id": 150832639,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543914189
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133545\">@AHan</span></p>",
        "id": 150832652,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543914240
    },
    {
        "content": "<p><code>#check @le_of_not_lt</code> tells us that it really needs a <code>linear_order</code>.</p>",
        "id": 150832713,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1543914289
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133545\">@AHan</span> oh it's Ok, I got your code (not) working.</p>",
        "id": 150832794,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543914377
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  Sorry, I just edited the code!</p>",
        "id": 150832813,
        "sender_full_name": "AHan",
        "timestamp": 1543914436
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span>  Yeah, so seems like <code>[is_total α (≤)]</code> can't work on this case?</p>",
        "id": 150833026,
        "sender_full_name": "AHan",
        "timestamp": 1543914673
    },
    {
        "content": "<p>Not when you want to use <code>le_of_not_lt</code>...</p>",
        "id": 150833041,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1543914714
    },
    {
        "content": "<p>Or is there any better way to prove the function without needing <code>(≤)</code> to be a linear_order ...?</p>",
        "id": 150833089,
        "sender_full_name": "AHan",
        "timestamp": 1543914742
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>                <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">linear_order</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"c1\">-- fails</span>\n                <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">sup_of_le_left</span> <span class=\"o\">(</span><span class=\"n\">le_of_not_lt</span> <span class=\"n\">h₂</span><span class=\"o\">)],</span>\n</pre></div>\n\n\n<p>Your problem is that the type class inference system cannot figure out that alpha is a linear order.</p>",
        "id": 150833091,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543914751
    },
    {
        "content": "<p>Even though all the data is there.</p>",
        "id": 150833094,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543914768
    },
    {
        "content": "<p>You probably need to do some <code>refine_struct</code> stuff</p>",
        "id": 150833124,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543914827
    },
    {
        "content": "<p>This is a great example of exactly what the problem is.</p>",
        "id": 150833134,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543914841
    },
    {
        "content": "<p>Also not <code>haveI</code> but <code>letI</code> the order contains the relation</p>",
        "id": 150833174,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1543914850
    },
    {
        "content": "<p><code>letI : linear_order α := { le_total := _ },</code></p>",
        "id": 150833181,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1543914872
    },
    {
        "content": "<p>Oops, I always screw this up.</p>",
        "id": 150833183,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543914876
    },
    {
        "content": "<p>I think whenever there is data involved you should use <code>let</code> and not <code>have</code>.</p>",
        "id": 150833209,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543914909
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>invalid structure value { ... }, field &#39;le&#39; was not provided\n</pre></div>",
        "id": 150833215,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543914918
    },
    {
        "content": "<blockquote>\n<p>I think whenever there is data involved you should use <code>let</code> and not <code>have</code>.</p>\n</blockquote>\n<p>Sure -- I just always forget that there is data involved.</p>",
        "id": 150833222,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543914932
    },
    {
        "content": "<blockquote>\n<p><code>letI : linear_order α := { le_total := _ },</code></p>\n</blockquote>\n<p>I think we need to tell Lean about the partial order somehow. But I can never remember these arcane structure extension tricks.</p>",
        "id": 150833285,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543914977
    },
    {
        "content": "<p>Do we do refine_struct? extends? <code>by refine</code> somehow?</p>",
        "id": 150833293,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543914994
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>  letI : linear_order α :=\n    { le_total := is_total.total (≤), .. _inst_1 },\n</pre></div>",
        "id": 150833324,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1543915035
    },
    {
        "content": "<p><code>_inst_1</code> is the name of the semilattice sup bot instance.</p>",
        "id": 150833334,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1543915063
    },
    {
        "content": "<p>Wow! It works!<br>\nBut... I don't quite get why this work..?</p>",
        "id": 150833401,
        "sender_full_name": "AHan",
        "timestamp": 1543915129
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133545\">@AHan</span> what is happening with Johannes' magic code is that he is explicitly building the term of type <code>linear_order alpha</code> from the pieces you already have (<code>_inst_1</code> is the partial order etc) and then he is inserting it into the type class inference system with <code>letI</code>.</p>",
        "id": 150833424,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543915178
    },
    {
        "content": "<p>It is absolutely clear to anyone watching that this is a pretty hacky and horrible solution, but as far as I can see it is the only one we have that works in general.</p>",
        "id": 150833484,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543915223
    },
    {
        "content": "<p>Having to type <code>_inst_1</code> is always a bad omen</p>",
        "id": 150833492,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543915241
    },
    {
        "content": "<p>No doubt you can get around it with some sort of <code>by apply_instance</code> trickery. But ultimately this is not a situation which scales.</p>",
        "id": 150833508,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543915284
    },
    {
        "content": "<p>Ultimately one does not want <code>distrib</code>s because they are useless objects. They serve a purpose which is to give a hacky fix to a problem which deserves a better fix but which I have no ideas about.</p>",
        "id": 150833560,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543915336
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">distrib</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_add</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">left_distrib</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">right_distrib</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n</pre></div>\n\n\n<p>a.k.a. \"here are some axioms which make no sense by themselves, but which we need to beef up structure X to structure Y so we have to have an entirely new typeclass\"</p>",
        "id": 150833600,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543915409
    },
    {
        "content": "<p>you can always give your <code>semilattie...</code> instance a concrete name, but then you need to mark it a <code>include</code> or add it to your theorem statement (the anonymous instances are always added as long as the type in you type class instance is used in the theorem statement)</p>",
        "id": 150833714,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1543915529
    },
    {
        "content": "<p>this is one of my favorite uses of the french quotes for getting a term by its type</p>",
        "id": 150835207,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543917358
    },
    {
        "content": "<p>Hah, now I can golf the <code>assumption</code> tactic:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">exact</span> <span class=\"err\">‹</span><span class=\"bp\">_</span><span class=\"err\">›</span>\n<span class=\"c1\">--assumption</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 150835883,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543918098
    },
    {
        "content": "<p>Oh I got it! Thanks a lot for the explanation!!</p>",
        "id": 150836031,
        "sender_full_name": "AHan",
        "timestamp": 1543918248
    }
]
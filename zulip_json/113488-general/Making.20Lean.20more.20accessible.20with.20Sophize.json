[
    {
        "content": "<p>Hello! I would like to introduce the Lean community to a Mathematics Library that I have been working on for over a year. <br>\nSophize is a non-profit online mathematics library and academic discussion platform. We are trying to create a deeply connected network of mathematical knowledge from a variety of sources - including formal systems such as lean.</p>\n<p>As a part of this project, we are incorporating knowledge from formal systems and making them more accessible. The following short video gives an overview of our work with the Metamath language.<br>\n<a href=\"https://youtu.be/XNJ2w71Gi50\">https://youtu.be/XNJ2w71Gi50</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"XNJ2w71Gi50\" href=\"https://youtu.be/XNJ2w71Gi50\"><img src=\"https://i.ytimg.com/vi/XNJ2w71Gi50/default.jpg\"></a></div>",
        "id": 211785444,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601482898
    },
    {
        "content": "<p>We would like to incorporate the wealth of knowledge you have created into our platform and extend our services to the Lean community.  We can help make Lean more accessible to the broader mathematics community. Our broader goals for mathematics are outlined here:<br>\n<a href=\"https://www.youtube.com/watch?v=Wb1JbW9Otek&amp;list=PLdfnRS1Iea0219QBYU_jF9D8F9VPUIq1z\">https://www.youtube.com/watch?v=Wb1JbW9Otek&amp;list=PLdfnRS1Iea0219QBYU_jF9D8F9VPUIq1z</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"Wb1JbW9Otek\" href=\"https://www.youtube.com/watch?v=Wb1JbW9Otek&amp;list=PLdfnRS1Iea0219QBYU_jF9D8F9VPUIq1z\"><img src=\"https://i.ytimg.com/vi/Wb1JbW9Otek/default.jpg\"></a></div><p>I am looking for feedback from the community to help focus on what the community finds most valuable</p>",
        "id": 211786133,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601483237
    },
    {
        "content": "<p>Would you folks be generous to fill-in this short form so that we can better understand the community's views?<br>\n<a href=\"https://forms.gle/WSYc44wCadxRUyPe8\">https://forms.gle/WSYc44wCadxRUyPe8</a></p>",
        "id": 211786666,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601483481
    },
    {
        "content": "<p>Some people (e.g., me) prefer reading text to watching videos.</p>",
        "id": 211789642,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1601484850
    },
    {
        "content": "<p>Ah, I see. Thanks for letting me know.</p>",
        "id": 211789772,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601484926
    },
    {
        "content": "<p>So the basic idea - for Lean - would be to incorporate all the proofs and theorems that have been developed by the community. We provide very simple and intuutive to look up the meanings of every term/proposition in the proof.</p>",
        "id": 211790055,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601485058
    },
    {
        "content": "<p>Secondly, we organize the proofs in the form of a graph (built of individual arguments) where you can keep browsing the proof as much as you like (till you reach the axioms)</p>",
        "id": 211790223,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601485127
    },
    {
        "content": "<p>Have you already incorporated theorems from some other library of formal proofs? If yes, could you please post a link to your presentation of the library?</p>",
        "id": 211790306,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1601485165
    },
    {
        "content": "<p>Do you want to deal with the proof tree only, or with the tactic mode source?</p>",
        "id": 211790390,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1601485204
    },
    {
        "content": "<p>Thirdly, we allow you to run proof -generating code on our servers that whose output gets displayed on the fly on the website.</p>",
        "id": 211790472,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601485243
    },
    {
        "content": "<p>In either case, do you have some way of separating \"important\" dependencies from inevitable low-level ones? E.g., every <code>rw</code> or <code>simp</code> injects lots of boilerplate code in the proof tree.</p>",
        "id": 211790547,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1601485282
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/113488-general/topic/Making.20Lean.20more.20accessible.20with.20Sophize/near/211790306\">said</a>:</p>\n<blockquote>\n<p>Have you already incorporated theorems from some other library of formal proofs? If yes, could you please post a link to your presentation of the library?</p>\n</blockquote>\n<p>Yes, we have done so for the Metamath language. The video (&lt;4min) shows what we have done. The link is at <a href=\"https://sophize.org/s/metamath\">https://sophize.org/s/metamath</a></p>",
        "id": 211790671,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601485331
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/113488-general/topic/Making.20Lean.20more.20accessible.20with.20Sophize/near/211790547\">said</a>:</p>\n<blockquote>\n<p>In either case, do you have some way of separating \"important\" dependencies from inevitable low-level ones? E.g., every <code>rw</code> or <code>simp</code> injects lots of boilerplate code in the proof tree.</p>\n</blockquote>\n<p>Since we have full control over the entire process, we can do such things easily. Each language needs special support and we will handle such things</p>",
        "id": 211790854,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601485437
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/113488-general/topic/Making.20Lean.20more.20accessible.20with.20Sophize/near/211790390\">said</a>:</p>\n<blockquote>\n<p>Do you want to deal with the proof tree only, or with the tactic mode source?</p>\n</blockquote>\n<p>I was thinking about the same and it doesn't look like things are very useful without the tactic mode support. So we are thinking of focusing more on that rather than the unwrapped tree.</p>",
        "id": 211791058,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601485543
    },
    {
        "content": "<p>But it will be a lot harder to get the data you want, in that case.</p>",
        "id": 211791193,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1601485600
    },
    {
        "content": "<p>You can ask lean for the proof tree, but not for the tactic script that generated it. So you will need to parse the lean source code. That's a non-trivial thing to do.</p>",
        "id": 211791269,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1601485634
    },
    {
        "content": "<p>Or you can ask the lean server info at each symbol.</p>",
        "id": 211791336,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1601485679
    },
    {
        "content": "<p>I am assuming that there Lean already has a parser - in C/C++, am I right?</p>",
        "id": 211791373,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601485684
    },
    {
        "content": "<p>I went through the same process with metamath (although it was probably an order of magnitude simpler I suppose)</p>",
        "id": 211791454,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601485723
    },
    {
        "content": "<p>AFAIR, someone posted highlighted sources obtained by asking the lean server about each symbol.</p>",
        "id": 211791468,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1601485734
    },
    {
        "content": "<p>That would be pretty great. Would simplify a lot of things</p>",
        "id": 211791572,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601485785
    },
    {
        "content": "<p>So my main focus for this thread is to understand these sorts of things - which are the biggest pain-points/opportunities in terms of </p>\n<ul>\n<li>presentation of formal Lean proofs </li>\n<li>sharing your proofs with descriptions - with the world to explain what you have done</li>\n<li>making people understand how rigorous your work is </li>\n<li>other opportunities to make formal mathematics popular/accessible</li>\n</ul>",
        "id": 211792375,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601486137
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/113488-general/topic/Making.20Lean.20more.20accessible.20with.20Sophize/near/211791468\">said</a>:</p>\n<blockquote>\n<p>AFAIR, someone posted highlighted sources obtained by asking the lean server about each symbol.</p>\n</blockquote>\n<p>Can you give me a hint about where I could find this?</p>",
        "id": 211793170,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601486519
    },
    {
        "content": "<p>You may be interested in <a href=\"https://www.imo.universite-paris-saclay.fr/~pmassot/lean/\">https://www.imo.universite-paris-saclay.fr/~pmassot/lean/</a>, which looks a bit like one of your \"smart articles\", and is generated from source code with comments</p>\n<p><strong>Edit:</strong> this is generated with <a href=\"https://leanprover-community.github.io/format_lean/\">https://leanprover-community.github.io/format_lean/</a>, which is not actively maintained.</p>",
        "id": 211793736,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601486775
    },
    {
        "content": "<p>This is great. They must have gone through a very similar process to create this. Thanks Eric</p>",
        "id": 211793896,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601486879
    },
    {
        "content": "<p>Cool. I've stumbled upon your channel yesterday while searching about Metamath.</p>",
        "id": 211794112,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1601486966
    },
    {
        "content": "<p>Oh. Great! I guess you could be our first 'organic' viewer</p>",
        "id": 211794224,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601487013
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219649\">Abhishek Chugh</span> <a href=\"#narrow/stream/113488-general/topic/Making.20Lean.20more.20accessible.20with.20Sophize/near/211791454\">said</a>:</p>\n<blockquote>\n<p>I went through the same process with metamath (although it was probably an order of magnitude simpler I suppose)</p>\n</blockquote>\n<p>I believe <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> is going to be the best person to access how hard that is going to be. But from what I've seen it seems that the process will be more than an order of magnitude harder in Lean.</p>",
        "id": 211794455,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1601487128
    },
    {
        "content": "<p>Yep, it's basically never been done before</p>",
        "id": 211794589,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601487193
    },
    {
        "content": "<p>The only practical way to get information about parsed lean source is to hack lean directly</p>",
        "id": 211794647,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601487225
    },
    {
        "content": "<p>Hey Mario, great to see you here.</p>",
        "id": 211794671,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601487242
    },
    {
        "content": "<p>or find a way to get what you need through the lean API</p>",
        "id": 211794714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601487244
    },
    {
        "content": "<p>also hello again</p>",
        "id": 211794737,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601487256
    },
    {
        "content": "<p>I see. Can you give me a hint why the lean parser would not have the information I am looking for?</p>",
        "id": 211794844,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601487307
    },
    {
        "content": "<p>Is it different from the regular language parsers (some complex stages etc.) or is it that the parsed data is going to be very hard to make sense of?</p>",
        "id": 211795150,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601487447
    },
    {
        "content": "<p>So, what I am getting from here that displaying a tactic based proof - which hides (or reduces visibility) of some of the most repeated tactics would be the best way to present proofs. <br>\nAnd that hacking into the parser would be my best bet to get this information.</p>",
        "id": 211796596,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601488122
    },
    {
        "content": "<p>could I get some feedback on whether actually doing this would be helpful to the community. Or reading/sharing proofs is quite easy for you already?</p>",
        "id": 211796921,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601488278
    },
    {
        "content": "<p>Reading proofs is relatively easy for experienced users but it is not that easy for new users.</p>",
        "id": 211799364,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1601489491
    },
    {
        "content": "<p>I'd also argue that some (many?) proofs on mathlib were not made to be read.</p>",
        "id": 211799470,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1601489542
    },
    {
        "content": "<p>At least I find small term proofs harder to read than bigger (and slower to check) tactic mode proofs.</p>",
        "id": 211799512,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1601489573
    },
    {
        "content": "<p>Usually a short term mode proof proves something trivial.</p>",
        "id": 211799777,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1601489725
    },
    {
        "content": "<p>I see.</p>",
        "id": 211799811,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601489753
    },
    {
        "content": "<p>And you can reconstruct the proof in your mind from the list of theorems used in this line.</p>",
        "id": 211799825,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1601489762
    },
    {
        "content": "<p>(says a person who often writes proofs of \"trivial\" results as term mode one-liners)</p>",
        "id": 211799928,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1601489816
    },
    {
        "content": "<p>It really depends what you mean by \"read\". I don't think it's a good use of time for humans to try to type-check Lean proofs, but certainly it's not bad practice and not too difficult with experience to skim over a proof that Lean accepts and get a sense of whether it's an efficient / \"good\" proof.</p>",
        "id": 211799940,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1601489824
    },
    {
        "content": "<p>Okay. So most of the time is spent creating proofs. Folks don't come back often to look important proofs to admire/learn something from them?</p>",
        "id": 211800258,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601490008
    },
    {
        "content": "<p>Well, at least I do sometimes. Following a Lean proof is as convenient, if not more so something, as reading a demonstration from a textbook.</p>",
        "id": 211800312,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1601490050
    },
    {
        "content": "<p>Sometimes we refactor old proofs, e.g., to get an intermediate lemma out of it, or to slightly generalize the statement, or to make the proof more readable.</p>",
        "id": 211800499,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1601490126
    },
    {
        "content": "<p>Or if we want to change the definition.</p>",
        "id": 211800519,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1601490140
    },
    {
        "content": "<p>I agree that most term-mode one-liners are \"trivial.\" But it would be nice to have mathlib's source itself be a tool for learning.</p>",
        "id": 211800552,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1601490163
    },
    {
        "content": "<p>I believe it already kind of is, it just clearly wasn't made of it.</p>",
        "id": 211800621,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1601490200
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219649\">Abhishek Chugh</span> <a href=\"#narrow/stream/113488-general/topic/Making.20Lean.20more.20accessible.20with.20Sophize/near/211795150\">said</a>:</p>\n<blockquote>\n<p>Is it different from the regular language parsers (some complex stages etc.) or is it that the parsed data is going to be very hard to make sense of?</p>\n</blockquote>\n<p>The lean parser is very extensible (some might say too extensible), and lean 4 will be even more so. You can't parse lean code without also interpreting lean code, which requires that you also know the whole environment, have a VM implementation, and a typechecker - that is, you must be lean</p>",
        "id": 211802305,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601491031
    },
    {
        "content": "<p>Thanks for the help guys. I think I am getting a feel of things here. One last thing I would like to know:<br>\nHas anyone made automatic proof-generators for even simple input statement like \"6*9+7=61\" or \"d (3 sin x)/dx = 3 cos x\"?<br>\nSeems to me like having a formally verified proofs for things like this could be useful in critical applications (verification/security). And I suppose strongly verified easily accessible knowledge might be one of the goals of projects like Lean?</p>",
        "id": 211802308,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601491035
    },
    {
        "content": "<p>For <code>6*9+7=61</code>, yes, this is the <code>norm_num</code> tactic (which incidentally is almost the same tactic as the one I wrote for metamath)</p>",
        "id": 211802619,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601491184
    },
    {
        "content": "<p>although for something that small you can probably just use <code>rfl</code> too</p>",
        "id": 211802645,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601491198
    },
    {
        "content": "<p>This might be too much of a tangent, but one thing I would really like to see is a service that properly connects different libraries and also informal references. Like OEIS but with a much broader scope, or <a href=\"https://www.cs.ru.nl/~freek/100/\">https://www.cs.ru.nl/~freek/100/</a> extended to all definitions and theorems. I know there are some projects with this goal, but they tend to get lost trying to solve interesting research problems around translating between provers or between formal and informal math. I'm imagining something much simpler.<br>\n(Like OEIS, in the long term it might actually work better in the reverse direction: There is a central service which essentially provides unique IDs, and others - in this case theorem prover libraries - reference these IDs.)</p>",
        "id": 211802703,
        "sender_full_name": "Sebastian Reichelt",
        "timestamp": 1601491209
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Making.20Lean.20more.20accessible.20with.20Sophize/near/211802305\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"219649\">Abhishek Chugh</span> <a href=\"#narrow/stream/113488-general/topic/Making.20Lean.20more.20accessible.20with.20Sophize/near/211795150\">said</a>:</p>\n<blockquote>\n<p>Is it different from the regular language parsers (some complex stages etc.) or is it that the parsed data is going to be very hard to make sense of?</p>\n</blockquote>\n<p>The lean parser is very extensible (some might say too extensible), and lean 4 will be even more so. You can't parse lean code without also interpreting lean code, which requires that you also know the whole environment, have a VM implementation, and a typechecker - that is, you must be lean</p>\n</blockquote>\n<p>Thanks, Mario. I will start digging into the parser/API/LeanCrawler to understand this.</p>",
        "id": 211802724,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601491220
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.norm_num</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">6</span><span class=\"bp\">*</span><span class=\"mi\">9</span><span class=\"bp\">+</span><span class=\"mi\">7</span><span class=\"bp\">=</span><span class=\"mi\">61</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">6</span><span class=\"bp\">*</span><span class=\"mi\">9</span><span class=\"bp\">+</span><span class=\"mi\">7</span><span class=\"bp\">=</span><span class=\"mi\">61</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 211802810,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601491269
    },
    {
        "content": "<p>For taking derivatives, I think there is a tactic but I haven't been involved in that area. <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> might know</p>",
        "id": 211802860,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601491302
    },
    {
        "content": "<p>That's pretty convenient!</p>",
        "id": 211803058,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601491400
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198266\">@Sebastian Reichelt</span> This sounds a lot like what Michael Kohlhase's work on OMDoc and such. I think they want URIs for everything, dunno how not-vaporware it all is though</p>",
        "id": 211803226,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601491479
    },
    {
        "content": "<p><code>simp</code> is able to do a bunch of derivatives:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.special_functions.trigonometric</span>\n<span class=\"kn\">open</span> <span class=\"n\">real</span>\n<span class=\"bp\">#</span><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">exp_ne_zero</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">deriv</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">sin</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">exp</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"c1\">-- λ (x : ℝ), (cos x * exp x - sin x * exp x) / exp x ^ 2</span>\n</code></pre></div>",
        "id": 211803292,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1601491525
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198266\">Sebastian Reichelt</span> <a href=\"#narrow/stream/113488-general/topic/Making.20Lean.20more.20accessible.20with.20Sophize/near/211802703\">said</a>:</p>\n<blockquote>\n<p>This might be too much of a tangent, but one thing I would really like to see is a service that properly connects different libraries and also informal references. Like OEIS but with a much broader scope, or <a href=\"https://www.cs.ru.nl/~freek/100/\">https://www.cs.ru.nl/~freek/100/</a> extended to all definitions and theorems. I know there are some projects with this goal, but they tend to get lost trying to solve interesting research problems around translating between provers or between formal and informal math. I'm imagining something much simpler.<br>\n(Like OEIS, in the long term it might actually work better in the reverse direction: There is a central service which essentially provides unique IDs, and others - in this case theorem prover libraries - reference these IDs.)</p>\n</blockquote>\n<p>I have thought about this for some time and I came to very similar conclusions as yours. Mathematicians are quite interested in finding the underlying translation mechanisms where theories can be transformed (semi/fully) automatically. But they seem to forget that having simple relationships - even if not perfect - at first would be pretty useful. We have a system that can do exactly that - we have unique IDs for each term/propositions/proofs across various datasets/systems.</p>",
        "id": 211803772,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601491760
    },
    {
        "content": "<p>We have a lot of pretty scalable foundations setup - using technologies that power things like Instagram and stuff. But I am finding it pretty hard to convince people to realize that a well-engineered software platform for Mathematics is worth investing into <span aria-label=\"neutral\" class=\"emoji emoji-1f610\" role=\"img\" title=\"neutral\">:neutral:</span></p>",
        "id": 211804123,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601491921
    },
    {
        "content": "<p>Even though math researchers themselves have published reports saying that there is a need for it (<a href=\"https://arxiv.org/pdf/1404.1905.pdf\">https://arxiv.org/pdf/1404.1905.pdf</a>), the incentive structures in universities make it pretty hard</p>",
        "id": 211804547,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601492149
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/stream/113488-general/topic/Making.20Lean.20more.20accessible.20with.20Sophize/near/211803292\">said</a>:</p>\n<blockquote>\n<p><code>simp</code> is able to do a bunch of derivatives:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.special_functions.trigonometric</span>\n<span class=\"kn\">open</span> <span class=\"n\">real</span>\n<span class=\"bp\">#</span><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">exp_ne_zero</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">deriv</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">sin</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">exp</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"c1\">-- λ (x : ℝ), (cos x * exp x - sin x * exp x) / exp x ^ 2</span>\n</code></pre></div>\n\n</blockquote>\n<p>Lean makes this so simple. Getting this in metamath needed so many lines of code.</p>",
        "id": 211804855,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601492293
    },
    {
        "content": "<p>that's because the lean library includes tactics (proof producing programs) and annotations to help those programs work effectively, unlike metamath, which only collects a library of formal theorems and leaves automation to the user</p>",
        "id": 211805814,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601492762
    },
    {
        "content": "<p>MM1 is gonna solve that :)</p>",
        "id": 211805944,
        "sender_full_name": "Abhishek Chugh",
        "timestamp": 1601492832
    },
    {
        "content": "<p>I have done some minor work to add annotations to <a href=\"http://set.mm\">set.mm</a> to help mmj2 in some respects, but there is essentially no support for this sort of thing out of the box. MM1 is indeed trying to tackle this problem head on, with a lean inspired tactic framework on a metamath like foundation</p>",
        "id": 211806004,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601492871
    }
]
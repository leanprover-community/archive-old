[
    {
        "content": "<p>This proof was a really weird one to get working (verbatim from <a href=\"https://github.com/leanprover-community/mathlib/issues/5645\">#5645</a>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- A linearly ordered commutative monoid with a zero element. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">linear_ordered_comm_monoid_with_zero</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"kd\">extends</span> <span class=\"n\">linear_order</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">comm_monoid_with_zero</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">ordered_comm_monoid</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">zero_le_one</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lt_of_mul_lt_mul_left</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"c1\">-- type-class inference uses a meaningless `linear_order` without this!</span>\n  <span class=\"n\">set</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">linear_order</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"n\">le</span><span class=\"o\">,</span>\n    <span class=\"n\">lt</span> <span class=\"o\">:=</span> <span class=\"n\">lt</span><span class=\"o\">,</span>\n    <span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›,</span>\n    <span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›,</span>\n    <span class=\"n\">lt_iff_le_not_le</span> <span class=\"o\">:=</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›,</span>\n    <span class=\"n\">le_antisymm</span> <span class=\"o\">:=</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›,</span>\n    <span class=\"n\">le_total</span> <span class=\"o\">:=</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›,</span>\n    <span class=\"n\">decidable_le</span> <span class=\"o\">:=</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›,</span>\n    <span class=\"n\">decidable_eq</span> <span class=\"o\">:=</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›,</span>\n    <span class=\"n\">decidable_lt</span> <span class=\"o\">:=</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"o\">},</span>\n  <span class=\"n\">apply</span> <span class=\"n\">imp_of_not_imp_not</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">not_lt_of_le</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">mul_le_mul_left</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">le_of_not_lt</span> <span class=\"n\">_</span> <span class=\"n\">l</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"o\">})</span>\n</code></pre></div>\n<p>If I don't construct my own <code>l</code>, it uses the <code>a : linear_order α</code> object (is there a new \"a\" bug hiding here waiting to be found?) from the context, and then flops because it doesn't have any knowledge that <code>a</code> contains the other local hypotheses as its fields.</p>\n<p>Is there a trick I'm missing here? Would there be any value to a tactic that constructs these \"correct\" instances automatically, discarding the bad ones?</p>",
        "id": 221832405,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609972227
    },
    {
        "content": "<p>This is probably related to <a href=\"https://github.com/leanprover-community/lean/issues/282\">lean#282</a>.  I think the cleanest workaround is just to extract the default argument into a lemma.</p>",
        "id": 221921838,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1610012155
    }
]
[
    {
        "content": "<p>On a high level, the proof that in a category with enough projectives every object admits a projective resolution works as follows: We start with a map <code>f₀ : α₁ → α₂</code> and we have functions that look like the following (except that we're in category-land, but that shouldn't matter here):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">next_type</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">next_fun</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">next_type</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n<p>We now construct an infinite sequence of maps <code>... → next_type (next_fun (next_fun f₀)) → next_type (next_fun f₀) → next_type f₀ → α₁</code>, where the arrows are <code>next_fun</code> applied to <code>f₀</code> the correct number of times. I would like to have two functions <code>T : ℕ → Type u</code> and <code>f : Π (n : ℕ), T (n + 1) → T n</code>  giving the ith type and function in that sequence, respectively. To me, this sounds like mutual induction. I tried the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span> <span class=\"kd\">def</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">f</span>\n<span class=\"k\">with</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">α₁</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">next_type</span> <span class=\"n\">f₀</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">next_type</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"k\">with</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">next_fun</span> <span class=\"n\">f₀</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">next_fun</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n\n<p>but it produces multiple errors: \"ill-formed match/equations expression\" as well as \"equation type mismatch, term <code>next_fun f₀</code> has type <code>next_type f₀ → α₁ : Type ?</code> but is expected to have type <code>T (0 + 1) → T 0 : Type u</code>\". Full MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">α₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">α₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">f₀</span> <span class=\"o\">:</span> <span class=\"n\">α₁</span> <span class=\"bp\">→</span> <span class=\"n\">α₂</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">next_type</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">next_fun</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">next_type</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kd\">mutual</span> <span class=\"kd\">def</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">f</span>\n<span class=\"k\">with</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">α₁</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">next_type</span> <span class=\"n\">f₀</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">next_type</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"k\">with</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">next_fun</span> <span class=\"n\">f₀</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">next_fun</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n\n<p>I'm not sure whether I just got the syntax wrong or whether mutual induction is not the right tool for this kind of thing. <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, I recall you saying that you never need mutual induction when formalizing math. What would you use here?</p>",
        "id": 210963855,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1600843140
    },
    {
        "content": "<p>You can use a structure putting together all the things you need at step <code>n</code>, and then define inductively the full structures.</p>",
        "id": 210964235,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1600843568
    },
    {
        "content": "<p>That worked like a charm. Thanks!</p>",
        "id": 210964725,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1600844130
    },
    {
        "content": "<p>Nice! My observation was that in the perfectoid project we just used a bunch of structures and this had led me to believe that inductive types with more than one constructor were not particularly useful to me (other than the basic ones like nat and list and option). However I don't know to what extent this remains true across mathematics. How many inductive types which aren't structures appear in the foundations of manifolds in Lean, for example?</p>\n<p>Sebastien's Lean Together 2020 talk shows a very nice example where an inductive type is used to prove a theorem of Bonk and Schramm</p>",
        "id": 210965495,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600844765
    },
    {
        "content": "<p>We have a couple of things like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/topological_space.generate_open\">docs#topological_space.generate_open</a></p>",
        "id": 210965930,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1600845166
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Mutual.20def/near/210965495\">said</a>:</p>\n<blockquote>\n<p>How many inductive types which aren't structures appear in the foundations of manifolds in Lean, for example?</p>\n</blockquote>\n<p>Exactly 0, of course.</p>",
        "id": 210966087,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1600845291
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Mutual.20def/near/210965930\">said</a>:</p>\n<blockquote>\n<p>We have a couple of things like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/topological_space.generate_open\">docs#topological_space.generate_open</a></p>\n</blockquote>\n<p>I prefer the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submonoid.closure/src\">src#submonoid.closure</a> approach (e.g., because you don't have to repeat the definition of <code>submonoid</code>/<code>topological_space</code>/... once more) but of course this is a matter of taste.</p>",
        "id": 210966641,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1600845775
    },
    {
        "content": "<p>So these two approaches give the same answer but please don't assume that my observation (that inductive types which aren't structures can often be avoided in my work) means that it's always a good idea to avoid them</p>",
        "id": 210966824,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600845943
    }
]
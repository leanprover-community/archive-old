[
    {
        "content": "<p>I seem to have backed myself into a corner, and I don't understand how to escape. I would really appreciate some help, as it feels like this problem is an instance of one that will become more and more severe as we do more advanced maths.</p>",
        "id": 133771753,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536715142
    },
    {
        "content": "<p>I've been working on morphisms of presheaves.</p>",
        "id": 133771756,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536715145
    },
    {
        "content": "<p>These are \"bundled\" presheaves, so they consist of a topological space, along with a functor from the category of open sets (morphisms are subsets) to some other category.</p>",
        "id": 133771768,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536715195
    },
    {
        "content": "<p>A morphism of presheaves <code>(X, O_X) \\hom (Y, O_Y)</code> consists of a pair: a function <code>f : X \\hom Y</code>, which is just a continuous map, and</p>",
        "id": 133771812,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536715247
    },
    {
        "content": "<p>a \"comorphism\", which is a natural transformation from <code>O_Y \\to f_* O_X</code>.</p>",
        "id": 133771817,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536715276
    },
    {
        "content": "<p>The point here is that you can push forward a presheaf on X to presheaf on Y, along a continuous map (take an open set of Y, pull it back via f, then evaluate the presheaf on it).</p>",
        "id": 133771858,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536715333
    },
    {
        "content": "<p>Now, I want to define the identity presheaf morphism, and I want to define compositions of presheaf morphisms, and check they satisfy the right properties.</p>",
        "id": 133771924,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536715561
    },
    {
        "content": "<p>Yesterday I managed to do this, but both the constructions and the proofs were very ugly.</p>",
        "id": 133771965,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536715593
    },
    {
        "content": "<p>Today I've made another attempt, where the constructions are quite a bit better, and the proofs look like they should be easy but get stuck at the last hurdle, when we should just be cancelling off identity morphisms and saying we're done.</p>",
        "id": 133771976,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536715643
    },
    {
        "content": "<p>The code is at &lt;<a href=\"https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/V_pre.lean\" target=\"_blank\" title=\"https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/V_pre.lean\">https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/V_pre.lean</a>&gt;.</p>",
        "id": 133772022,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536715703
    },
    {
        "content": "<p>The particular problem I reach is the proof of <code>comp_id'</code> in constructing <code>instance : category (Presheaf.{u v} C) := ...</code>.</p>",
        "id": 133772037,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536715757
    },
    {
        "content": "<p>Just before the <code>sorry</code>, the goal is</p>\n<div class=\"codehilite\"><pre><span></span>C : Type u,\nùíû : category C,\nX Y : Presheaf C,\nf : Presheaf_hom X Y,\nX_1 : open_set ((Y.X).Œ±)\n‚ä¢ functor.map (Y.ùí™) (ùüô X_1) ‚â´\n      ‚áë(f.c) (‚áë(map_open_set (ùüô (Y.X))) X_1) ‚â´\n        functor.map (X.ùí™) (functor.map (map_open_set (f.f)) (ùüô (‚áë(map_open_set (ùüô (Y.X))) X_1))) =\n    ‚áë(f.c) X_1\n</pre></div>",
        "id": 133772085,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536715812
    },
    {
        "content": "<p>And this should be perfectly manageable. The left hand side is a composition of three morphisms, and we should begin by observing the first and third are actually identity morphisms, since they are explicitly some functor applied to some identity morphism.</p>",
        "id": 133772095,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536715872
    },
    {
        "content": "<p>In particular we should be able to rewrite <code>functor.map (Y.ùí™) (ùüô X_1) </code> into <code>ùüô (Y.ùí™ X_1) </code></p>",
        "id": 133772100,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536715914
    },
    {
        "content": "<p>However <code>simp</code> fails.</p>",
        "id": 133772102,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536715920
    },
    {
        "content": "<p>Yeah I've had this happen too. In that case the problem was some implicit argument was not <code>X_1</code> but only something defeq to it, and <code>simp</code> didn't like that.</p>",
        "id": 133772147,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536715954
    },
    {
        "content": "<p>In my case <code>dsimp, simp</code> worked, but it doesn't look like that will help you judging from the two preceding lines</p>",
        "id": 133772150,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536715966
    },
    {
        "content": "<p>Trying the rewrite by hand, with increasing desperation:</p>\n<div class=\"codehilite\"><pre><span></span>rw [category_theory.functor.map_id]\nrw [category_theory.functor.map_id Y.ùí™ X_1]\n</pre></div>",
        "id": 133772154,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536715974
    },
    {
        "content": "<p><code>rw [category_theory.functor.map_id Y.ùí™ X_1] {md:=semireducible}</code></p>",
        "id": 133772161,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536715985
    },
    {
        "content": "<p>all fail.</p>",
        "id": 133772164,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536715988
    },
    {
        "content": "<p><code>erw</code>?</p>",
        "id": 133772165,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536715997
    },
    {
        "content": "<p><code>erw</code> is just the same as <code>{md:=semireducible}</code></p>",
        "id": 133772166,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716016
    },
    {
        "content": "<p>(I'd usually use <code>erw</code> but didn't want to scare anyone. :-)</p>",
        "id": 133772167,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716027
    },
    {
        "content": "<p>Reid is exactly right that the problem is an implicit argument.</p>",
        "id": 133772210,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716064
    },
    {
        "content": "<p>Let's look at that, turning on <code>set_option pp.implict true</code> and inspecting the goal again.</p>",
        "id": 133772211,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716083
    },
    {
        "content": "<p>The whole thing is a bit long, but the bit that corresponds to <code>functor.map (Y.ùí™) (ùüô X_1)</code> is</p>\n<div class=\"codehilite\"><pre><span></span>@functor.map\n        (@open_set (@bundled.Œ± topological_space (@Presheaf.X C ùíû Y))\n           (examples.topological_space (@Presheaf.X C ùíû Y)))\n        (@open_set.open_sets (@bundled.Œ± topological_space (@Presheaf.X C ùíû Y))\n           (examples.topological_space (@Presheaf.X C ùíû Y)))\n        C\n        ùíû\n        (@Presheaf.ùí™ C ùíû Y)\n        X_1\n        (‚áë(@map_open_set (@Presheaf.X C ùíû Y) (@Presheaf.X C ùíû Y) (ùüô (@Presheaf.X C ùíû Y))) X_1)\n        (ùüô X_1)\n</pre></div>",
        "id": 133772226,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716147
    },
    {
        "content": "<p>We can see the problem at the end there: the last three arguments are meant to consist of two objects, and a hom between them.</p>",
        "id": 133772266,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716177
    },
    {
        "content": "<p>However we've got <code>X_1</code>,  <code>(‚áë(@map_open_set (@Presheaf.X C ùíû Y) (@Presheaf.X C ùíû Y) (ùüô (@Presheaf.X C ùíû Y))) X_1)</code>, and <code>(ùüô X_1)</code>.</p>",
        "id": 133772271,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716217
    },
    {
        "content": "<p>Something like <code>id ‚Åª¬π' X_1</code>, I guess?</p>",
        "id": 133772280,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536716230
    },
    {
        "content": "<p>We really want that second object to just be <code>X_1</code> again.</p>",
        "id": 133772281,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716231
    },
    {
        "content": "<p>is what that long thing is</p>",
        "id": 133772283,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536716242
    },
    {
        "content": "<p>If we <code>dsimp  [map_open_set]</code> we see:</p>",
        "id": 133772285,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716253
    },
    {
        "content": "<p><code>(@open_set.mk (@bundled.Œ± topological_space (@Presheaf.X C ùíû Y))\n           (examples.topological_space (@Presheaf.X C ùíû Y))\n           (@subtype.val\n                (@bundled.Œ± topological_space (@Presheaf.X C ùíû Y) ‚Üí\n                 @bundled.Œ± topological_space (@Presheaf.X C ùíû Y))\n                (@continuous (@bundled.Œ± topological_space (@Presheaf.X C ùíû Y))\n                   (@bundled.Œ± topological_space (@Presheaf.X C ùíû Y))\n                   (@bundled.str topological_space (@Presheaf.X C ùíû Y))\n                   (@bundled.str topological_space (@Presheaf.X C ùíû Y)))\n                (ùüô (@Presheaf.X C ùíû Y)) ‚Åª¬π'\n              @open_set.s (@bundled.Œ± topological_space (@Presheaf.X C ùíû Y))\n                (examples.topological_space (@Presheaf.X C ùíû Y))\n                X_1)\n           _)</code></p>",
        "id": 133772329,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716370
    },
    {
        "content": "<p>Which sadly is not definitely equal to <code>X_1</code>, although we can prove it is equal.</p>",
        "id": 133772338,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716401
    },
    {
        "content": "<p>oh no</p>",
        "id": 133772385,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536716409
    },
    {
        "content": "<p>In fact, we have a lemma prepared just for this!</p>",
        "id": 133772386,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716410
    },
    {
        "content": "<p>wait then</p>",
        "id": 133772390,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536716414
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>@[simp] def map_open_set_id_obj (X : Top) (U : open_set X.Œ±) : map_open_set (ùüô X) U = U :=\nbegin dsimp [map_open_set], cases U, congr, end\n</pre></div>",
        "id": 133772394,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716423
    },
    {
        "content": "<p>And <code>rw [map_open_set_id_obj]</code> says ...</p>",
        "id": 133772412,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716467
    },
    {
        "content": "<p><code>failed</code></p>",
        "id": 133772414,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716470
    },
    {
        "content": "<p>I'm confused</p>",
        "id": 133772417,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536716488
    },
    {
        "content": "<p>Doesn't this mean your goal is ill-typed?</p>",
        "id": 133772420,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536716502
    },
    {
        "content": "<p>(And <code>erw</code> is no better, nor does it seem that using <code>conv</code> to zoom in on it helps.)</p>",
        "id": 133772421,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716503
    },
    {
        "content": "<p>That's what appears to be happening, I agree.</p>",
        "id": 133772464,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716535
    },
    {
        "content": "<p>So how did Lean let me get this far?</p>",
        "id": 133772467,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716547
    },
    {
        "content": "<p>I had that happen too once, but I didn't understand how it happened, but it's almost certainly unrelated.</p>",
        "id": 133772468,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536716550
    },
    {
        "content": "<p>I do have a note a few lines earlier in my code <code>It's hard to believe this typechecks!</code></p>",
        "id": 133772479,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716589
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>structure Presheaf_hom (F G : Presheaf.{u v} C) :=\n(f : F.X ‚ü∂ G.X)\n(c : G.ùí™ ‚üπ ((map_open_set f) ‚ãô F.ùí™))\n\nnamespace Presheaf_hom\ndef id (F : Presheaf.{u v} C) : Presheaf_hom F F :=\n{ f := ùüô F.X,\n  c := begin apply nat_trans.vcomp, swap, apply whisker_on_right (map_open_set_id _).inv, apply (functor.id_comp _ _ _).inv end\n}\n\ndef comp {F G H : Presheaf.{u v} C} (Œ± : Presheaf_hom F G) (Œ≤ : Presheaf_hom G H) : Presheaf_hom F H :=\n{ f := Œ±.f ‚â´ Œ≤.f,\n  c := Œ≤.c ‚äü (whisker_on_left (map_open_set Œ≤.f) Œ±.c), -- It&#39;s hard to believe this typechecks!\n}\nend Presheaf_hom\n</pre></div>",
        "id": 133772519,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716645
    },
    {
        "content": "<p>In particular, I have to jump through some hoops to construct the natural transformation for <code>id</code>.</p>",
        "id": 133772525,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716678
    },
    {
        "content": "<p>But Lean appears to be happy with me just writing the \"obvious\" answer for <code>comp</code>.</p>",
        "id": 133772531,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716702
    },
    {
        "content": "<p>I found composition/associativity things are often easier than identity/unitality things</p>",
        "id": 133772542,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536716747
    },
    {
        "content": "<p>(... in real life as well as Lean, for me!)</p>",
        "id": 133772591,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716786
    },
    {
        "content": "<p>(identities are strange and confusing in higher dimensions!)</p>",
        "id": 133772599,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716810
    },
    {
        "content": "<p>how hard would it be to find the first place the goal becomes ill-typed?<br>\nIs the goal before the last <code>simp</code> comprehensible?</p>",
        "id": 133772671,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536716955
    },
    {
        "content": "<p>The only avenues I can work out are:<br>\n1) Go back and work out where this \"ill-typed, or at least hard-to-see-its-well-typed\" expression first appears, and then \"do something different\".<br>\n2) Work out how to \"fix\" implicit arguments.</p>",
        "id": 133772673,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536716962
    },
    {
        "content": "<p>(This is an example, by the way, of a situation it would be nice to have a good term inspector, where you can toggle on and off implicit arguments for subtrees.)</p>",
        "id": 133772717,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536717027
    },
    {
        "content": "<p>Given that the implicit argument is not even defeq to the right thing, I think 2 isn't applicable in this case.<br>\nIt looks to me like you hit a bug in Lean (which is probably not in the kernel, since it is only the goal which is ill-typed, but still very frustrating).</p>",
        "id": 133772767,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536717164
    },
    {
        "content": "<p>Oooh, I maybe found a way around it.</p>",
        "id": 133772769,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536717183
    },
    {
        "content": "<p>It's just a matter of <code>dsimp</code>ing expressions in a different order, so somehow it's not at all a principled solution.</p>",
        "id": 133772777,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536717225
    },
    {
        "content": "<p>Oh, no, the problem is there a step or two later. I was just doing something by hand that <code>simp</code> was doing anyway.</p>",
        "id": 133772821,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536717290
    },
    {
        "content": "<p>:-(</p>",
        "id": 133772822,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536717295
    },
    {
        "content": "<p>I'm kind of surprised that the result of the tactic passes typechecking, even with <code>sorry</code> there</p>",
        "id": 133772935,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536717526
    },
    {
        "content": "<p>Shall I try for a proof of false? :-)</p>",
        "id": 133772995,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536717625
    },
    {
        "content": "<p>Unfortunately I doubt you can prove false from a term which is ill-typed but only in that one of the type arguments is definitionally wrong (but propositionally correct)</p>",
        "id": 133773004,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536717680
    },
    {
        "content": "<p>Okay... this is bizarre, but <code>cases X_1</code> seems to break the impasse.</p>",
        "id": 133773005,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536717691
    },
    {
        "content": "<p>that's not surprising</p>",
        "id": 133773006,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536717699
    },
    {
        "content": "<p>Why is that?</p>",
        "id": 133773008,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536717715
    },
    {
        "content": "<p>same reason why you used <code>cases U</code> to prove <code>map_open_set_id_obj</code></p>",
        "id": 133773051,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536717736
    },
    {
        "content": "<p>basically you have an equality that looks like &lt;x.1, _&gt; = x</p>",
        "id": 133773055,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536717761
    },
    {
        "content": "<p>Okay, and there's a (horrible) proof:</p>\n<div class=\"codehilite\"><pre><span></span>  comp_id&#39; := Œª X Y f, --sorry,\n    begin\n      ext,\n      -- we check the functions first\n      dsimp [Presheaf_hom.id, Presheaf_hom.comp],\n      simp,\n      -- and now the comorphisms\n      dsimp [Presheaf_hom.id, Presheaf_hom.comp],\n      simp,\n      ext,\n      dsimp [whisker_on_right, whiskering_on_right, whisker_on_left, whiskering_on_left],\n      dsimp [map_open_set],\n      simp,\n      erw [category_theory.functor.map_id],\n      simp,\n      cases X_1,\n      simp,\n      apply congr_fun,\n      simp,\n    end,\n</pre></div>",
        "id": 133773056,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536717775
    },
    {
        "content": "<p>where x is a variable, and so they can never be definitionally equal. Buf after <code>cases x</code>, it's okay</p>",
        "id": 133773062,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536717791
    },
    {
        "content": "<p>I see.</p>",
        "id": 133773063,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536717801
    },
    {
        "content": "<p>when you do comp, both sides look like &lt;_, _&gt;</p>",
        "id": 133773064,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536717811
    },
    {
        "content": "<p>and that's why comp is easier</p>",
        "id": 133773065,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536717816
    },
    {
        "content": "<p>This still feels weird to me, but I've seen it a few times</p>",
        "id": 133773107,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536717846
    },
    {
        "content": "<p>So maybe the summary from today is:</p>\n<blockquote>\n<p>avoid <code>cases</code> when constructing stuff, because then you'll have horrible <code>X.rec</code> expressions to deal with later, but<br>\nremember to try <code>cases</code> when an implicit argument looks wrong!</p>\n</blockquote>",
        "id": 133773113,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536717884
    },
    {
        "content": "<p>Well, in general when you need to prove <code>(blah.mk _ _) = X</code>, it will require doing cases on X</p>",
        "id": 133773166,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536717993
    },
    {
        "content": "<p>I still think something very fishy is going on with your original code</p>",
        "id": 133773170,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536718019
    },
    {
        "content": "<p>Sure. The problem here was that it wasn't at all obvious to me that this was what was going on.</p>",
        "id": 133773173,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536718024
    },
    {
        "content": "<p>The file you linked references <code>category_theory.examples.topological_spaces</code> but I can't find it in the repo</p>",
        "id": 133773227,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536718172
    },
    {
        "content": "<p>That's in mathlib</p>",
        "id": 133773228,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536718183
    },
    {
        "content": "<p>:-)</p>",
        "id": 133773229,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536718186
    },
    {
        "content": "<p>I just finished building your repo locally so I can take a look</p>",
        "id": 133773271,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536718210
    },
    {
        "content": "<p>And just to confound you, Mario, lean-category-theory is currently pointing at a branch of mathlib on <code>community</code>, in which that file has been modified. :-)</p>",
        "id": 133773278,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536718230
    },
    {
        "content": "<p>Anyways the situation you were in ought to have been impossible. If <code>x : t</code> and <code>x : t'</code> then <code>t</code> and <code>t'</code> should be definitionally equal. Not just propositionally equal.</p>",
        "id": 133773287,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536718279
    },
    {
        "content": "<p>At least, as far as I understand.</p>",
        "id": 133773288,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536718289
    },
    {
        "content": "<p>yes.</p>",
        "id": 133773290,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536718293
    },
    {
        "content": "<p>oh wow, mathlib category theory has grown quite a bit since I last checked</p>",
        "id": 133773291,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536718312
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>-- Do I dare define `open_set` as a functor from Top to CAT? I don&#39;t like CAT.\n\ndef map_open_set\n  {X Y : Top} (f : X ‚ü∂ Y) : open_set Y.Œ± ‚•§ open_set X.Œ± :=\n</pre></div>\n\n\n<p>Why is it a functor to CAT? It looks like <code>open_set</code> should be a (contravariant) functor from <code>Top</code> to <code>Type</code></p>",
        "id": 133773444,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536718630
    },
    {
        "content": "<p>For each topological space X, we get the category of open sets and inclusions.</p>",
        "id": 133773453,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536718681
    },
    {
        "content": "<p>The ill-typed goal I encountered involved Lean getting confused about the difference between <code>quot</code> and <code>quotient</code>, and so I had a goal involving some types of the form <code>quot s a</code> where <code>s</code> was a setoid, which I had trouble producing</p>",
        "id": 133773493,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536718730
    },
    {
        "content": "<p>Okay, I think I'm starting to piece this together. There is an unnamed function <code>comap f U</code> (where <code>f</code> is a bundled continuous function and <code>U</code> is an <code>open_set</code>) which is the object part of <code>map_open_set</code></p>",
        "id": 133773568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536718863
    },
    {
        "content": "<p>And what is true is that <code>map_open_set (ùüô X) U = comap (ùüô X) U</code>, which is isomorphic to <code>U</code></p>",
        "id": 133773575,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536718902
    },
    {
        "content": "<p>so you have a classic two-category problem</p>",
        "id": 133773613,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536718925
    },
    {
        "content": "<p>I don't know this classic. :-)</p>",
        "id": 133773625,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536718996
    },
    {
        "content": "<p>I think Mario means 2-category?</p>",
        "id": 133773626,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536719008
    },
    {
        "content": "<p>You have to worry about coherences since it's not an equality</p>",
        "id": 133773628,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536719025
    },
    {
        "content": "<p>Oh, okay! :-)</p>",
        "id": 133773629,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536719041
    },
    {
        "content": "<p>Yes.</p>",
        "id": 133773666,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536719044
    },
    {
        "content": "<p>Like, the Top -&gt; Cat thing could be only a pseudofunctor</p>",
        "id": 133773667,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536719044
    },
    {
        "content": "<p>As Kevin learned a while ago, a propositional equality should not ever be treated as equality in a category, only isomorphism</p>",
        "id": 133773672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536719062
    },
    {
        "content": "<p>objects are either defeq or isomorphic</p>",
        "id": 133773673,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536719074
    },
    {
        "content": "<p>but where am I abusing that here?</p>",
        "id": 133773674,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536719088
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>-- These next two are desperate attempts to solve problems below.\n@[simp] def map_open_set_id_obj (X : Top) (U : open_set X.Œ±) : map_open_set (ùüô X) U = U :=\nbegin dsimp [map_open_set], cases U, congr, end\n@[simp] def map_open_set_id (X : Top) : map_open_set (ùüô X) ‚âÖ functor.id (open_set X.Œ±) :=\n</pre></div>\n\n\n<p>this is bad news</p>",
        "id": 133773684,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536719106
    },
    {
        "content": "<p>this equality should be turned into an iso, given a name, and explicitly reasoned with</p>",
        "id": 133773691,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536719140
    },
    {
        "content": "<p>It's the first one that is evil</p>",
        "id": 133773692,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536719141
    },
    {
        "content": "<p>and I don't use it</p>",
        "id": 133773694,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536719145
    },
    {
        "content": "<p>the second one is fine, isn't it?</p>",
        "id": 133773736,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536719181
    },
    {
        "content": "<p>the type looks fine, but now I am confused about the implementation</p>",
        "id": 133773743,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536719237
    },
    {
        "content": "<p>I think? I can't parse it</p>",
        "id": 133773744,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536719239
    },
    {
        "content": "<p>I just pushed an update</p>",
        "id": 133773745,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536719248
    },
    {
        "content": "<p><code>map_open_set (ùüô X)</code> is a functor, so what does <code>‚âÖ</code> mean here?</p>",
        "id": 133773746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536719260
    },
    {
        "content": "<p>that has the working proof, and doesn't have the evil <code>map_open_set_id_obj</code></p>",
        "id": 133773748,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536719275
    },
    {
        "content": "<p>iso is automatically natural isomorphism</p>",
        "id": 133773786,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536719286
    },
    {
        "content": "<p>sweet sweet typeclass magic finds the category of functors between two fixed categories</p>",
        "id": 133773791,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536719303
    },
    {
        "content": "<p>isomorphism in the functor category</p>",
        "id": 133773792,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536719305
    },
    {
        "content": "<p>and correctly interprets iso</p>",
        "id": 133773793,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536719312
    },
    {
        "content": "<p>and that doesn't have any 2-category mess in it?</p>",
        "id": 133773796,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536719330
    },
    {
        "content": "<p>no -- for a fixed pair of categories C and D</p>",
        "id": 133773799,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536719342
    },
    {
        "content": "<p>functors and natural transformations between them are a perfectly honest 1-category</p>",
        "id": 133773804,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536719360
    },
    {
        "content": "<p>(indeed, the prototypical example)</p>",
        "id": 133773806,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536719370
    },
    {
        "content": "<p>Oh man this is confusing.</p>",
        "id": 133773899,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536719548
    },
    {
        "content": "<p>so where did you get that bad application from? <code>functor.map (Y.ùí™) (ùüô X_1)</code></p>",
        "id": 133773901,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536719559
    },
    {
        "content": "<p>I noticed that both of these worked, and was confused.</p>\n<div class=\"codehilite\"><pre><span></span>  <span class=\"o\">{</span> <span class=\"n\">app</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"k\">show</span> <span class=\"n\">map_open_set</span> <span class=\"o\">(</span><span class=\"mi\">ùüô</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"n\">U</span> <span class=\"err\">‚ü∂</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"mi\">ùüô</span> <span class=\"n\">U</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">app</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"k\">show</span> <span class=\"n\">U</span> <span class=\"err\">‚ü∂</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"mi\">ùüô</span> <span class=\"n\">U</span> <span class=\"o\">},</span>\n</pre></div>",
        "id": 133773903,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536719576
    },
    {
        "content": "<p>Even though we know <code>map_open_set (ùüô X) U = U</code> is not a definitional equality</p>",
        "id": 133773910,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536719594
    },
    {
        "content": "<p>hah, it's because the hom destructs it</p>",
        "id": 133773911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536719612
    },
    {
        "content": "<p>right</p>",
        "id": 133773913,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536719624
    },
    {
        "content": "<p>Yeah, and I think this is where the \"bad\" application is coming from.</p>",
        "id": 133773916,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536719635
    },
    {
        "content": "<p>Can you explain what \"the hom destructs it\" means?</p>",
        "id": 133773956,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536719649
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_subset</span> <span class=\"o\">(</span><span class=\"n\">open_set</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">subset</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">U</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"n\">s</span> <span class=\"err\">‚äÜ</span> <span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">s</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 133773962,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536719701
    },
    {
        "content": "<p>this is what defines the partial order, and therefore the hom types</p>",
        "id": 133773970,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536719728
    },
    {
        "content": "<p>oh ...</p>",
        "id": 133773972,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536719744
    },
    {
        "content": "<p>it's not true that <code>map_open_set (ùüô X) U = U</code> definitionally, but it is true that <code>(map_open_set (ùüô X) U).s = U.s</code> because (contrary to my initial guess) <code>preimage id</code> is definitionally the identity</p>",
        "id": 133774013,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536719770
    },
    {
        "content": "<p>I see.</p>",
        "id": 133774014,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536719782
    },
    {
        "content": "<p>Oh, wait...</p>",
        "id": 133774017,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536719819
    },
    {
        "content": "<p>So maybe that weird goal was correctly typed, after all</p>",
        "id": 133774022,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536719828
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 133774023,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536719832
    },
    {
        "content": "<p>And I could have replaced my evil lemma with</p>",
        "id": 133774028,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536719876
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>@[simp] def map_open_set_id_obj (X : Top) (U : open_set X.Œ±) : (map_open_set (ùüô X) U).s = U.s := rfl\n</pre></div>",
        "id": 133774071,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536719899
    },
    {
        "content": "<p>and perhaps had it work...</p>",
        "id": 133774072,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536719904
    },
    {
        "content": "<p>Hmm,. you can indeed prove that via <code>rfl</code>, but I can't get it to help.</p>",
        "id": 133774082,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536719991
    },
    {
        "content": "<p>ah, I have to remove the dsimp [map_open_set], perhaps</p>",
        "id": 133774124,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536720015
    },
    {
        "content": "<p>Scott, I'm trying to get your repo. How do you update everything with leanpkg?</p>",
        "id": 133774125,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536720019
    },
    {
        "content": "<p><code>leanpkg build</code>?</p>",
        "id": 133774127,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536720028
    },
    {
        "content": "<p>It should notice if you don't have the right dependencies already in <code>_target</code>.</p>",
        "id": 133774129,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536720057
    },
    {
        "content": "<p>I get version mismatch error</p>",
        "id": 133774130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536720060
    },
    {
        "content": "<p>ah... Is your lean provided by elan?</p>",
        "id": 133774136,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536720080
    },
    {
        "content": "<p>This repo is set to use nightly-2018-06-21</p>",
        "id": 133774137,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536720099
    },
    {
        "content": "<p>but I think it should be safe to change that in leanpkg.toml file</p>",
        "id": 133774139,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536720109
    },
    {
        "content": "<p>What is the \"official recommendation\" these days?</p>",
        "id": 133774140,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536720121
    },
    {
        "content": "<p>I've been using 3.4.1 even though a few bugfixes have come in</p>",
        "id": 133774179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536720167
    },
    {
        "content": "<p>Since my student Keeley started forking Lean I've switched to using elan and don't notice these problems. :-)</p>",
        "id": 133774185,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536720204
    },
    {
        "content": "<p>that's good to hear. You should write a tutorial :)</p>",
        "id": 133774188,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536720228
    },
    {
        "content": "<p>for elan?</p>",
        "id": 133774233,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536720281
    },
    {
        "content": "<p>I really should borrow a windows machine, and write a tutorial for running elan on windows.</p>",
        "id": 133774234,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536720299
    },
    {
        "content": "<p>Ducking out for lunch. Thanks very much for the discussion today!</p>",
        "id": 133774365,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536720567
    },
    {
        "content": "<p>Aha, I found some 2-categoricity:</p>\n<div class=\"codehilite\"><pre><span></span>structure Presheaf_hom (F G : Presheaf.{u v} C) :=\n(f : F.X ‚ü∂ G.X)\n(c : G.ùí™ ‚üπ ((map_open_set f) ‚ãô F.ùí™))\n</pre></div>\n\n\n<p>Since <code>Presheaf_hom</code> has a component which is a functor, proving equality of homs is going to involve equality of objects</p>",
        "id": 133774471,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536720810
    },
    {
        "content": "<p>I guess that can't really be avoided, but since <code>G.ùí™</code> is a functor out of a skeletal category (a partial order category), it suffices to prove isomorphism instead of equality</p>",
        "id": 133774631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536721166
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>@[extensionality] lemma ext {F G : Presheaf.{u v} C} (Œ± Œ≤ : Presheaf_hom F G)\n  (w : Œ±.f = Œ≤.f) (h : Œ±.c == Œ≤.c)\n  : Œ± = Œ≤ :=\n</pre></div>\n\n\n<p>the <code>heq</code> here is evil. You should state some kind of composite equality here</p>",
        "id": 133774739,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536721360
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, actually that component <code>Preasheaf_hom.c</code> is a natural transformation, not a functor, so equality is non-evil.</p>",
        "id": 133775001,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536721874
    },
    {
        "content": "<p>I agree that the <code>ext</code> lemma is evil. I will replace that.</p>",
        "id": 133775042,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536721923
    },
    {
        "content": "<p>equality of natural transformations is not evil, equality of natural transformations in different categories is</p>",
        "id": 133775051,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536721933
    },
    {
        "content": "<p>Oh, so you're saying specifically the <code>heq</code> is evil.</p>",
        "id": 133775062,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536721970
    },
    {
        "content": "<p>I don't think we'll ever to to say anything about equalities of objects, however.</p>",
        "id": 133775075,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536721995
    },
    {
        "content": "<p>I think I found the culprit. <code>map_open_sets</code> is a 2-categorical thing, since it takes homs to functors. This means that congruence says that equality of homs maps to natural iso of functors</p>",
        "id": 133775136,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536722103
    },
    {
        "content": "<p>And this is the iso you should reference in the definition of <code>ext</code></p>",
        "id": 133775143,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536722119
    },
    {
        "content": "<p>I'm filling in </p>\n<div class=\"codehilite\"><pre><span></span>def map_open_set_iso {X Y : Top} (f g : X ‚ü∂ Y) (h : f = g) : map_open_set f ‚âÖ map_open_set g := {\n\n}\n</pre></div>",
        "id": 133775147,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536722135
    },
    {
        "content": "<p>right now</p>",
        "id": 133775148,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536722136
    },
    {
        "content": "<p>This is a terrifying thread to wake up to. It reminds me of when I couldn't prove anything about real numbers because there was no norm_num. But instead of a beginner struggling to prove math-trivial things because of a lack of tools, it's experts and tool-makers having problems with something that looks math-trivial</p>",
        "id": 133781152,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536734252
    },
    {
        "content": "<p>I actually stopped thinking about pushing the perfectoid repo forward towards the definition of an adic space because this funky category showed up, Patrick was doing completions (which were also needed) and I knew someone had to do integral closures (which were also needed) so I went back to those and thought I'd wait a bit to see what the category experts thought about this category V_pre which had shown up \"in the wild\". I want to argue that we don't <em>need</em> V_pre, it's just a convenient container and I thought it would be a good test case. I could instead just make a new structure modelling the objects and muddle on from there and it would no doubt be fine at least as far as the ultimate goal is concerned, which is a definition.</p>",
        "id": 133781442,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536734685
    },
    {
        "content": "<p>I think this thread is Scott having an epiphany similar to the one that prompted that blog post <a href=\"https://mathematicswithoutapologies.wordpress.com/2018/09/11/guest-post-by-kevin-buzzard/\" target=\"_blank\" title=\"https://mathematicswithoutapologies.wordpress.com/2018/09/11/guest-post-by-kevin-buzzard/\">https://mathematicswithoutapologies.wordpress.com/2018/09/11/guest-post-by-kevin-buzzard/</a></p>",
        "id": 133781575,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536734918
    },
    {
        "content": "<p>I think it boils down to \"equalities of types are evil\"</p>",
        "id": 133781606,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536734995
    },
    {
        "content": "<p>As I'm sure you realise, that comment (it was only supposed to be a comment!) was very much informed by the comments you made when I was having that big meltdown about equality a few months ago (\"Kevin, stop trolling!\").</p>",
        "id": 133784114,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536739073
    },
    {
        "content": "<p>A summer student, Ned Summers, was doing some 4th year category theory example sheet questions (using Scott's library as a dependency) and ran into these sorts of problems, and this time I was better equipped. Chris (who freely admits he knows nothing about category theory) had suggested some casts which had caused trouble for Ned, and I diagnosed the problem as exactly the same sort of thing: Ned had two objects X and Y and a proof that they were equal, and was doing exactly what a mathematican would do -- treating Hom(X,Z) as equal to Hom(Y,Z) etc etc. Equality in type theory is more delicate than that. Of course this doesn't change the fact that we are right, and your definition is rubbish -- but it's what we've got to work with ;-)</p>",
        "id": 133784227,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536739266
    },
    {
        "content": "<blockquote>\n<p>A summer student, Ned Summers</p>\n</blockquote>",
        "id": 133784234,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536739284
    },
    {
        "content": "<p>They've almost all gone now. Ned stopped on Friday. Only about three left. I am going to spend all day writing documentation and basic questions. Yesterday I said \"we want ten basic examples and ten basic questions about metaprogramming\" -- today I'm (hopefully) going to write ten basic examples and ten basic questions about set membership.</p>",
        "id": 133784295,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536739362
    },
    {
        "content": "<p>I asked a question on this chat probably last Wed or Thurs about how to generate \"the identity morphism\" between two objects which were provably equal, and Reid answered very quickly with some function called something like <code>iso_of_eq</code> which generated the data from the proof; it was because of my schemes meltdown that I had understood that this was what was missing.</p>",
        "id": 133784364,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536739476
    },
    {
        "content": "<p>I didn't suggest the use of <code>eq.rec</code>. My instinct would be that <code>eq.rec</code> for data should be avoided if at all possible</p>",
        "id": 133786353,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1536742621
    },
    {
        "content": "<p>Maybe I got the wrong impression from Ned :-)</p>",
        "id": 133788910,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536746126
    },
    {
        "content": "<p>Thanks to some help from Mario and Reid, it is well sorted out now!</p>",
        "id": 133794864,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536754597
    },
    {
        "content": "<p>While I agree that I was making mistakes (being \"evil\") when I shouldn't have been, and the code is nicer as a result of today's exorcism, the fundamental cause of being stuck was something a bit different. I really need to catch up on sleep now, so I won't explain it now. :-)</p>",
        "id": 133794955,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536754712
    },
    {
        "content": "<p>The upshot is that &lt;<a href=\"https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/presheaves.lean\" target=\"_blank\" title=\"https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/presheaves.lean\">https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/presheaves.lean</a>&gt; contains the definition of bundled presheaves (i.e. a topological space and a presheaf on it), and the right notion of morphisms between these, and indeed the category structure.</p>",
        "id": 133794972,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536754766
    },
    {
        "content": "<p>It's certainly not all of <code>V_pre</code>, but it's the categorical theoretic core.</p>",
        "id": 133794979,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536754786
    },
    {
        "content": "<p>Yeah, \"Lean does no magic\" ‚Ñ¢ but sometimes a good exorcism session is needed</p>",
        "id": 133794986,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1536754794
    },
    {
        "content": "<p>Hopefully from this point on it is just adding bells and whistles (that stalk needs to be local, these valuations need to be jiggered by the whatsit).</p>",
        "id": 133795036,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536754822
    },
    {
        "content": "<p>Happily, the category of presheaves is actually pretty easy to PR now. I only have one dependency, about whiskering, and that looks easy to clean up. So this may be in mathlib soon.</p>",
        "id": 133795050,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536754863
    },
    {
        "content": "<blockquote>\n<p>to reduce an <code>eq.rec</code> you need the major premise to become <code>refl</code> somehow</p>\n<p>that usually means finding the appropriate equality in the context and generalizing it until one side is a variable, and then <code>subst</code>, which is to say use <code>eq.rec</code> in the proof term</p>\n</blockquote>\n<p><a href=\"#narrow/stream/113488-general/subject/so.20what.20is.20eq.2Erec.3F/near/125134372\" title=\"#narrow/stream/113488-general/subject/so.20what.20is.20eq.2Erec.3F/near/125134372\">Mario Carneiro, 16/04/2018 04:39:04 (UTC)</a></p>",
        "id": 133837710,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536779568
    },
    {
        "content": "<p>underrated comment</p>",
        "id": 133837740,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536779624
    },
    {
        "content": "<p>wow I had an <code>eq.rec</code> in my goal and it took me nearly 2 hours to destruct it</p>",
        "id": 133842645,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536785106
    },
    {
        "content": "<p>sounds about right</p>",
        "id": 133845614,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536787937
    },
    {
        "content": "<p>I feel like <code>eq.rec</code> is such a disaster that we need special VS Code plugin support: a little zulip box that pops up, with a message: \"Help me, Mario!\" ready to be sent...</p>",
        "id": 133856278,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536802765
    },
    {
        "content": "<p>ok so eq.rec isn't really the problem. The problem is sometimes you can't just rewrite something with an equality <code>a = b</code> because that something depends on <code>a</code> and <code>b</code> being those expressions. And the solution is to generalize <code>a</code> in all places in which that expression occurs, and then <code>subst</code> that equality</p>",
        "id": 133866974,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536822986
    },
    {
        "content": "<p>sometimes you can't just generalize <code>a</code>, but you have to generalize a lot of things</p>",
        "id": 133866988,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536823059
    },
    {
        "content": "<p>a strategy is to generalize all proofs first (<code>set_option pp.proofs true</code>), because that will always work because of proof irrelevance</p>",
        "id": 133866989,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536823075
    },
    {
        "content": "<p>Slowly making progress here. This now compiles:</p>\n<div class=\"codehilite\"><pre><span></span>def stalks_local (F : Presheaf.{u+1 u} TopRing) : Type u :=\nŒ† x : F, local_ring (((TopRing.forget_to_CommRing).map_presheaf F).stalk_at x)\n\ndef V_pre_pre := Œ£ (F : Presheaf.{u+1 u} TopRing), stalks_local F\n\nexample : category.{u+1 u} V_pre_pre := by unfold V_pre_pre; apply_instance\n</pre></div>",
        "id": 133947991,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536927102
    }
]
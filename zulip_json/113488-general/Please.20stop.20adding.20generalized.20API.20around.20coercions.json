[
    {
        "content": "<p>I've only just noticed <a href=\"https://github.com/leanprover-community/mathlib/pull/17048\">#17048</a>, which adds a lot of generalized infrastructure around the <code>coe</code> function.  Problem is, we no longer have a <code>coe</code> function in Lean 4.  So porting this is far from straightforward.</p>",
        "id": 310898388,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1668797294
    },
    {
        "content": "<p>It is not completely clear to me what the goal of <a href=\"https://github.com/leanprover-community/mathlib/pull/17048\">#17048</a> is (or what concrete problems it solves).  So I'm not really sure what the best solution is here.</p>",
        "id": 310899277,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1668797573
    },
    {
        "content": "<p>Either way, please hold off on adding lemmas about <code>coe</code> for now!</p>",
        "id": 310899417,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1668797622
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span></p>",
        "id": 310899441,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1668797629
    },
    {
        "content": "<p>Sorry if this has been answered before. Is there somewhere an explanation of the changes to <code>coe</code> and casting in Lean4? I can’t find anything in <a href=\"https://leanprover.github.io/lean4/doc/lean3changes.html\">https://leanprover.github.io/lean4/doc/lean3changes.html</a></p>",
        "id": 310926565,
        "sender_full_name": "Winston Yin",
        "timestamp": 1668807754
    },
    {
        "content": "<p>A coercion is now syntactically equal to what it unravels to.</p>",
        "id": 310933634,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1668810509
    },
    {
        "content": "<p>So basically, no more up arrows?</p>",
        "id": 310952052,
        "sender_full_name": "Winston Yin",
        "timestamp": 1668820780
    },
    {
        "content": "<p>well no, the up arrows are still there in both input and output, they just don't represent applications of the <code>coe</code> function anymore</p>",
        "id": 310952885,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668821409
    },
    {
        "content": "<p>Are <code>has_coe</code> instances now defined with a regular function definition marked with the attribute <code>@[coe]</code>?</p>",
        "id": 310953678,
        "sender_full_name": "Winston Yin",
        "timestamp": 1668822101
    },
    {
        "content": "<p>No coercion instances are still defined with <code>instance : Coe A B where coe := myCast</code>.  You need to say <code>@[coe] def myCast := ...</code> so that you get 1) the uparrow delaborator, and 2) norm_cast support.</p>",
        "id": 310955513,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1668823849
    },
    {
        "content": "<p>The reason <code>@[coe]</code> doesn't automatically create the instance is because you need to choose between Coe/CoeTail/CoeHead/etc.</p>",
        "id": 310955537,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1668823873
    },
    {
        "content": "<p>It's not my favorite idea, but do we need to consider reverting <a href=\"https://github.com/leanprover-community/mathlib/pull/17048\">#17048</a>? <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span></p>",
        "id": 311047736,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1668878331
    },
    {
        "content": "<p>There will be plenty of problems with coe whether or not we revert this recent PR, and we're going to have to learn how to deal with them anyway, so I don't immediately see an argument for reverting it. The same argument could be made for eg Damiano's recent addition of a new tactic in lean 3; that also will be hard to port because all tactics need energy to port. The problem is not really <a href=\"https://github.com/leanprover-community/mathlib/pull/17048\">#17048</a>, the problem is that mathlib3 is still growing faster than mathlib4 so right now every day  the job of porting mathlib gets harder. Gabriel's observation is just that some days the amount by which it gets harder is larger than other days.</p>",
        "id": 311050364,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1668879686
    },
    {
        "content": "<p>Kevin, that is very far from my interpretation of Gabriel's comment (although I could be wrong!). To me, it seems that Gabriel is saying: because <code>coe</code> (the function) doesn't exist in Lean 4, there is going to be massive headache porting anything related to Anne's new coe hom classes, and in fact, there likely won't be <em>any</em> analogue of these in Lean 4. </p>\n<p>From that point of view, it seems to make sense to me that we could simplify porting by undoing this change now (especially before the revert commit would rot horribly, if it hasn't already), instead of manually untangling this every time we encounter a coe hom class situation.</p>",
        "id": 311054239,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1668882010
    },
    {
        "content": "<p>I mean, I understand that coercions in general are a lot different and will cause some overhead (I did just port <code>data.{nat, int}.cast.defs</code> so I got some familiarity with it), but direct uses of <code>coe</code> the function (as opposed to some application of a specific coercion) are much stickier.</p>",
        "id": 311054667,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1668882314
    },
    {
        "content": "<p>Kevin, I think you’re being a bit too pessimistic about the port process. I think the relative growing speeds of mathlib3 and mathlib4 will naturally reverse as it gets more and more painful to make PRs to mathlib3 because of the synchronization requirements. Basically my hope is that at some point it will require more energy to do the work twice than to just port what’s missing and do everything in Lean4.</p>",
        "id": 311054751,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1668882362
    },
    {
        "content": "<p>Of course we will never have enough people helping with the ports, but I’m not super bothered by mathlib3 still moving faster</p>",
        "id": 311055091,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1668882543
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> We know how to port tactics, it's merely laborious. And if we don't want to or manage to port them, we can always prove things manually as a plan B.</p>",
        "id": 311067062,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1668890996
    },
    {
        "content": "<p>With library design changes like this, figuring out how to make it work in Lean 4 is roughly as much work as it took Anne to figure out the Lean 3 design.  And we can't fall back to doing things manually in a couple of places because the PR in question touches dozen of type classes, changes simp lemmas etc.  (The only fall back would be to revert.)</p>",
        "id": 311067289,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1668891174
    },
    {
        "content": "<p>Ideally we wouldn't have spent effort on that PR in the first place, and instead looked into a better Lean 4 solution.</p>",
        "id": 311067435,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1668891298
    },
    {
        "content": "<p>It already took plenty of time to figure out how to do Nat.cast/numerals in Lean 4.  I'm not excited about adding roadblocks to mathlib3 right at the point where people are motivated and start to port files.  And Nat.cast is right on the critical path of almost everything.</p>",
        "id": 311067760,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1668891537
    },
    {
        "content": "<p>Maybe we should have marked data.nat.cast etc. as \"frozen\" months ago.</p>",
        "id": 311068769,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1668892264
    },
    {
        "content": "<p>I'm not sure if we need to revert the PR, but we'll certainly need to rewrite the new type classes.</p>",
        "id": 311069043,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1668892501
    },
    {
        "content": "<p>(That's why I pinged <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> to hear more about the motivation behind the PR so that we can port this right.)</p>",
        "id": 311069200,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1668892623
    },
    {
        "content": "<p>I think the underlying motivation for Anne's change was to eliminate and generalize <code>algebra_map</code> in favor of coe (unifying it with nat.cast); down the line this could get rid of <code>matrix.scalar</code> and <code>polynomial.C</code> if we wanted too. Of course, the whole idea hinges on making <code>coe</code> the simp-normal form, which doesn't work if Lean4 unfolds it back to its implementation. Maybe Anne had a better picture of how things might work in Lean 4 though.</p>",
        "id": 311070345,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1668893501
    },
    {
        "content": "<p>My hunch is that eventually in Lean4 we'll actually want to go back to the unbundled morphism design if the new simplifier permits it; and then we won't need the coe typeclasses at all, which are really just special cases of it.</p>",
        "id": 311070423,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1668893564
    },
    {
        "content": "<p>But that's not remotely explorable until the port is over</p>",
        "id": 311070433,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1668893580
    },
    {
        "content": "<p>I think we should consider reverting this one. It's a shame to discard Anne's work, but I think we all know Anne's work is great, and Anne knows we know that, and this is just a unfortunate situation arising in the porting process.</p>",
        "id": 311071637,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1668894678
    },
    {
        "content": "<p>Relatedly, I wonder if we should just adopt a \"no new tactics PRs\" for mathlib 3. (Of course bugfixes and backports would be welcome.)</p>",
        "id": 311071783,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1668894801
    },
    {
        "content": "<p>I think positivity and norm_num extensions are probably ok as porting one should be much like porting the rest, but brand new tactics probably not so much.</p>",
        "id": 311074352,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1668896821
    },
    {
        "content": "<p>New tactics are fine. We are definitely porting tactics faster than they are written, especially nontrivial ones</p>",
        "id": 311077059,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668898818
    },
    {
        "content": "<p>The <a href=\"https://github.com/leanprover-community/mathlib4/issues/430\">tactic list</a> has seen some substantial reduction, I'm hopeful we will have most of the tactics done by the end of the year</p>",
        "id": 311077256,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668898942
    },
    {
        "content": "<p>besides, I don't see any reason to say no to making lean 4 better</p>",
        "id": 311077294,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668898987
    },
    {
        "content": "<p>I think in the case of <a href=\"https://github.com/leanprover-community/mathlib/pull/17048\">#17048</a>, the Lean 4 solution is to declare coercions from bundled operators. Then there will syntactically be a <code>whatever_hom.to_fun</code> available.</p>",
        "id": 311079279,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668900712
    },
    {
        "content": "<p>And then if an instance <code>something_hom_class (whatever_hom ...) ...</code> exists, Anne's general lemmas apply.</p>",
        "id": 311079354,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668900775
    },
    {
        "content": "<p>My thought with \"no new tactics\" was more along the lines of telling people who want to write new tactics to just write them in Lean 4 to begin with...</p>",
        "id": 311080798,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1668902164
    },
    {
        "content": "<p>Yaël, I couldn't quite put that together in my head. Can you elaborate a bit, maybe with a simple example?</p>",
        "id": 311088211,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1668909335
    },
    {
        "content": "<p>First of all, feel free to revert <a href=\"https://github.com/leanprover-community/mathlib/pull/17048\">#17048</a> while we figure out how to deal with the porting situation. Nothing major should depend on this yet.</p>",
        "id": 311251165,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1669025573
    },
    {
        "content": "<p>Subclassing <code>has_lift_t</code> in this way immediately allows us to solve the concrete problem that we have a huge multitude of lemmas like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nnrat.coe_sum\">docs#nnrat.coe_sum</a> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nnreal.coe_sum\">docs#nnreal.coe_sum</a> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.coe_sum\">docs#submodule.coe_sum</a> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_submonoid.coe_finset_sum\">docs#add_submonoid.coe_finset_sum</a> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.cast_sum\">docs#nat.cast_sum</a>. These all have the same mathematical content but are redundantly stated and proved on an ad-hoc basis, so they are unavailable half of the time that you need them, so there is no <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subring.coe_sum\">docs#subring.coe_sum</a>.</p>\n<p>At the same time, we've figured out thanks to the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra\">docs#algebra</a> class that the right way to treat many inclusions of rings and fields in a uniform way is to assume the existence of a canonical homomorphism (algebra_map in this case). There are quite a few places in group theory where the same strategy should apply.</p>\n<p>Finally, there are types with such a canonical homomorphism that is defeq to both <code>coe</code> and <code>algebra_map</code> (if it exists) but spelled differently: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.C\">docs#polynomial.C</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/adjoin_root.of\">docs#adjoin_root.of</a> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subring.subtype\">docs#subring.subtype</a> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.cast_ring_hom\">docs#nat.cast_ring_hom</a>. etc. Apart from yet again more duplication and inconsistencies in all these implementations, it's terribly annoying to have <code>coe</code> in the goal and a simp lemma involving <code>polynomial.C</code> or vice versa. Arguably <code>algebra_map</code> itself also counts as a weird spelling of this canonical homomorphism.</p>\n<p>As I said, subclassing <code>has_lift_t</code> in this way immediately allows us to solve the first problem, which means <code>coe</code> is now a viable candidate to serve as the canonical map that we need for the other two points. On the other hand, those more abstract goals can also be achieved without <code>coe</code>.</p>",
        "id": 311256421,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1669027552
    },
    {
        "content": "<p>About unbundled morphisms: these will be much more useful in Lean 4 but still come with limitations. Toy example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IsZeroHom</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">map_zero</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">IsZeroHom</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">AddGroupWithOne</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsZeroHom</span> <span class=\"o\">(</span><span class=\"n\">Int.cast</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">map_zero</span> <span class=\"o\">:=</span> <span class=\"n\">Int.cast_zero</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsZeroHom</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">map_zero</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n    <span class=\"o\">[</span><span class=\"n\">IsZeroHom</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsZeroHom</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsZeroHom</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">map_zero</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Function.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">map_zero</span><span class=\"o\">]</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">IsZeroHom</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"c1\">-- succeeds</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.simp</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">AddGroupWithOne</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_zero</span><span class=\"o\">,</span> <span class=\"n\">IsZeroHom.map_zero</span><span class=\"o\">]</span> <span class=\"c1\">-- succeeds, but tries to unify `?f 0` with every subterm</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">AddGroupWithOne</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_zero</span><span class=\"o\">,</span> <span class=\"n\">IsZeroHom.map_zero</span><span class=\"o\">]</span> <span class=\"c1\">-- failed, pattern is a metavariable</span>\n</code></pre></div>\n<p>Since <code>Function.id</code> and <code>Function.comp</code> are no longer reducible, there is no more looping on trying to synthesise <code>IsZeroHom (id ∘ id ∘ id ∘ id ∘ ...)</code> and the simplifier now accepts lemmas with a metavariable as head (<code>rw</code> still doesn't though).</p>\n<p>However, we still have two objections to unbundled maps that remain unchanged from Lean 3:</p>\n<ul>\n<li>Since <code>?f 0</code> could unify potentially with any subterm of the goal, the simplifier has to scan through everything, which I expect will have the same performance impacts as it did in Lean 3. (At least it doesn't seem to find a <code>IsZeroHom</code> instance on each subterm.)</li>\n<li>The collection of morphisms is still an interesting object in its own right, so we still want to have some level of bundled maps to e.g. put a group structure on the automorphisms of a vector space.</li>\n</ul>",
        "id": 311261011,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1669029312
    },
    {
        "content": "<p>Honestly, I don't know what the right plan is at the moment: it would be easy enough to redo the classes in a way that doesn't mention <code>coe</code>. Due to various other projects I have to finish at the moment, I don't particularly feel motivated to do so, especially without some reassurance that there are no further secret breakages in Lean 4.</p>",
        "id": 311263726,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1669030342
    },
    {
        "content": "<p>I don't want to go off on a whole rant but each of my encounters with the Lean 4 port has been frustrating, despite all the advantages I know Lean 4 is supposed to bring. :(</p>",
        "id": 311266318,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1669031334
    },
    {
        "content": "<p>I totally agree that porting files is frustrating, precisely because we don't notice all the stuff which works and only have to bang our head against the wall dealing with the stuff which doesn't work :-)</p>",
        "id": 311438631,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1669054141
    },
    {
        "content": "<p>I'm sorry this is frustrating you.  I should have raised this issue earlier before you had invested so much time into it, but the PR flew completely under my radar.</p>",
        "id": 311443394,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1669055721
    },
    {
        "content": "<blockquote>\n<p>it's terribly annoying to have coe in the goal and a simp lemma involving polynomial.C or vice versa.</p>\n</blockquote>\n<p>This is exactly what moving to Lean 4 would have fixed automatically: the elaborator now produces polynomial.C so there's no annoying mismatch.</p>",
        "id": 311443626,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1669055795
    },
    {
        "content": "<p>What it doesn't solve is having to repeat <code>coe_add</code>/<code>coe_sum</code> lemmas for types where the canonical map can't always be bundled</p>",
        "id": 311449768,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1669057983
    },
    {
        "content": "<p>I would guess those are relatively rare, right? What situations do you have in mind where this map can't be bundled?</p>",
        "id": 311450502,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1669058214
    },
    {
        "content": "<p>... whenever different bundlings hold in different generalities, which is a ubiquitous situation</p>",
        "id": 311451228,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1669058506
    },
    {
        "content": "<p>The one that  comes to mind immediately is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/matrix.scalar\">docs#matrix.scalar</a>, but <code>nat.cast</code> is another good example since <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.cast_mul\">docs#nat.cast_mul</a> doesn't hold as often as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.cast_add\">docs#nat.cast_add</a>.</p>",
        "id": 311451844,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1669058749
    },
    {
        "content": "<p>But certainly we shouldn't attempt to solve this problem mid-port</p>",
        "id": 311452079,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1669058825
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/113488-general/topic/Please.20stop.20adding.20generalized.20API.20around.20coercions/near/311443626\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>it's terribly annoying to have coe in the goal and a simp lemma involving polynomial.C or vice versa.</p>\n</blockquote>\n<p>This is exactly what moving to Lean 4 would have fixed automatically: the elaborator now produces polynomial.C so there's no annoying mismatch.</p>\n</blockquote>\n<p>I mean but I think the issue is that now we need to have <code>simp</code> lemmas for all these normal forms of the coercions as opposed to just having a \"coercion\" simp lemma, which removes a hell of a lot of boilerplate</p>",
        "id": 311492515,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1669073016
    },
    {
        "content": "<p>plus I don't think humans want to see goals with stuff like <code>adjoin_root.of (nat.cast k) * r</code>, because to them that is just <code>k * r</code></p>",
        "id": 311492606,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1669073056
    },
    {
        "content": "<p>Note that <code>↑</code> still appears in the tactic state, but that doesn't address the boilerplate issue.</p>",
        "id": 311494089,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1669073909
    },
    {
        "content": "<p>Yeah, having a single <code>coe</code> function had the appeal that we could write lemmas about it.</p>",
        "id": 311494724,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1669074334
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113488-general/topic/Please.20stop.20adding.20generalized.20API.20around.20coercions/near/311494089\">said</a>:</p>\n<blockquote>\n<p>Note that <code>↑</code> still appears in the tactic state, but that doesn't address the boilerplate issue.</p>\n</blockquote>\n<p>sometimes not; I've not seen it work a single time with <code>equiv.toFun</code>, for example</p>",
        "id": 311495036,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1669074524
    },
    {
        "content": "<p>did the function get tagged as <code>@[coe]</code>?</p>",
        "id": 311495109,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669074577
    },
    {
        "content": "<p>Yaël, can we just write lemmas involving the <code>coe</code> attribute though? (I have no idea, just flailing in the dark)</p>",
        "id": 311495186,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1669074609
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Please.20stop.20adding.20generalized.20API.20around.20coercions/near/311495109\">said</a>:</p>\n<blockquote>\n<p>did the function get tagged as <code>@[coe]</code>?</p>\n</blockquote>\n<p><a href=\"/user_uploads/3121/c2l6rpIgv4dKWcCPKWUUfbsX/image.png\">image.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/c2l6rpIgv4dKWcCPKWUUfbsX/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/c2l6rpIgv4dKWcCPKWUUfbsX/image.png\"></a></div><p>I don't think so, this seems the only close-to-related thing in equiv's files. should we have a line <code>attribute [coe] Equiv.toFun</code>?</p>",
        "id": 311495299,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1669074702
    },
    {
        "content": "<p>yes</p>",
        "id": 311495369,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669074727
    },
    {
        "content": "<p>we'll have a linter for this at some point</p>",
        "id": 311495390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669074747
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113488-general/topic/Please.20stop.20adding.20generalized.20API.20around.20coercions/near/311495186\">said</a>:</p>\n<blockquote>\n<p>Yaël, can we just write lemmas involving the <code>coe</code> attribute though? (I have no idea, just flailing in the dark)</p>\n</blockquote>\n<p>It doesn't even make sense to state that some function is tagged with <code>coe</code> though, right?</p>",
        "id": 311495416,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1669074777
    },
    {
        "content": "<p>I wonder if this is what was causing the issues with <code>EmbeddingLike</code> and also <code>map_one</code></p>",
        "id": 311495421,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1669074779
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/Please.20stop.20adding.20generalized.20API.20around.20coercions/near/311495416\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113488-general/topic/Please.20stop.20adding.20generalized.20API.20around.20coercions/near/311495186\">said</a>:</p>\n<blockquote>\n<p>Yaël, can we just write lemmas involving the <code>coe</code> attribute though? (I have no idea, just flailing in the dark)</p>\n</blockquote>\n<p>It doesn't even make sense to state that some function is tagged with <code>coe</code> though, right?</p>\n</blockquote>\n<p>it does</p>",
        "id": 311495455,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669074797
    },
    {
        "content": "<p>How can I state that a function is tagged with <code>coe</code>?</p>",
        "id": 311495486,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1669074825
    },
    {
        "content": "<p>I mean, you can have a metaprogram look for the attribute</p>",
        "id": 311495549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669074845
    },
    {
        "content": "<p>I'm not sure what you are after here</p>",
        "id": 311495559,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669074853
    },
    {
        "content": "<p>why does the fact that a function is a coe have anything to do with the lemmas that are provable for it?</p>",
        "id": 311495582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669074876
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Please.20stop.20adding.20generalized.20API.20around.20coercions/near/311495369\">said</a>:</p>\n<blockquote>\n<p>yes</p>\n</blockquote>\n<p><a href=\"/user_uploads/3121/rcmhByBx397kD97imfYbrKWX/image.png\">image.png</a>  </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/rcmhByBx397kD97imfYbrKWX/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/rcmhByBx397kD97imfYbrKWX/image.png\"></a></div><p>this cannot be right</p>",
        "id": 311508319,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1669084222
    },
    {
        "content": "<p>that appears to be a bug in the coe delaborator</p>",
        "id": 311508434,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669084366
    },
    {
        "content": "<p>it's actually a somewhat challenging issue because the <code>@[coe]</code> attribute doesn't know whether <code>toFun : Equiv A B -&gt; A -&gt; B</code> is supposed to be a coe from <code>A</code> to <code>B</code> or <code>Equiv A B</code> to <code>A -&gt; B</code></p>",
        "id": 311508536,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669084465
    },
    {
        "content": "<p>cc: <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span></p>",
        "id": 311508545,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669084471
    },
    {
        "content": "<p>I think it is safe to say that we should look at the first explicit argument of the function as the source and the rest as the destination</p>",
        "id": 311508579,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669084513
    },
    {
        "content": "<p>Yeah, the attribute doesn't support function corrections yet.</p>",
        "id": 311513285,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1669089031
    },
    {
        "content": "<p>E.g. the FunLike.coe function is registered manually.</p>",
        "id": 311513313,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1669089067
    },
    {
        "content": "<p>The explicit argument heuristic sounds good to me.  This covers everything we've got. And in the worst case you can always fall back to registering it manually.</p>",
        "id": 311513380,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1669089138
    },
    {
        "content": "<p>I would personally like coercions to functions (and sorts?) to not appear in the tactic state at all. In all non-artificial situations there is only one way to treat an object as a function (or a sort), and from the context 99% of the time it is clear that you are treating an object as a function, since you're e.g. applying it to an argument. (An exception is a lemma like <code>f = g ↔ ⇑f = ⇑g</code>.)</p>",
        "id": 311608966,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1669128521
    },
    {
        "content": "<p>But if they do not appear in the tactic state, they are not inspectable, so you can't jump to where the coercion is defined, etc</p>",
        "id": 311642412,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1669130242
    },
    {
        "content": "<p>Maybe I'm wishful thinking, but for me the  ideal behavior would be that clicking on the term with the hidden coercion does show the coercion application in the pop-up (if you want to get to the non-coercion application you click the corresponding argument of the coercion to open a second pop-up).</p>",
        "id": 311645076,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1669130901
    },
    {
        "content": "<p>That can be (and already is?) a <code>pp</code> option. Of course typing <code>set_option ...</code> in every file you inspect is not a solution, so it would be nice to make <code>pp</code> options persistently configurable from the VScode extension.</p>",
        "id": 311648917,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1669131921
    },
    {
        "content": "<p>I think there is an option for removing all coercion arrows. But the normal coercion arrows (not to functions or sorts) are useful (since they often convey information not contained in the rest of the expression), and I want to keep those.</p>",
        "id": 311651365,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1669132602
    },
    {
        "content": "<p>I agree that user-configurable default pp options in the extension would be useful.</p>",
        "id": 311651509,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1669132654
    },
    {
        "content": "<p>Then we should make suboptions for each type of coercion.</p>",
        "id": 311651656,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1669132693
    },
    {
        "content": "<p>I see that the discussion moved from \"what can be used by <code>simp</code> etc\" to \"what a user sees in the tactic state\". Do I understand correctly that we can write lemmas about <code>FunLike</code> coercions because Lean only unfolds it up to <code>FunLike.coe</code>, not to <code>Equiv.toFun</code> etc? So, we're emulating Lean 3 here.</p>",
        "id": 312110373,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1669346394
    },
    {
        "content": "<p>About the original issue: can we teach Lean 4 <code>simp</code> that a lemma about <code>coe</code> applies to any function tagged with <code>@[coe]</code>?</p>",
        "id": 312110439,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1669346444
    },
    {
        "content": "<p>This would make all those general <code>coe_add</code>/<code>coe_sum</code> lemmas useful again.</p>",
        "id": 312110540,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1669346537
    },
    {
        "content": "<p>What is the best way to unfold local definitions?</p>",
        "id": 312606880,
        "sender_full_name": "Meow",
        "timestamp": 1669635116
    },
    {
        "content": "<p>I usually use simp only [] now.</p>",
        "id": 312606955,
        "sender_full_name": "Meow",
        "timestamp": 1669635127
    },
    {
        "content": "<p>Yeah, I hate this stuff.</p>",
        "id": 312633741,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1669643940
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/113488-general/topic/Please.20stop.20adding.20generalized.20API.20around.20coercions/near/312110439\">said</a>:</p>\n<blockquote>\n<p>About the original issue: can we teach Lean 4 <code>simp</code> that a lemma about <code>coe</code> applies to any function tagged with <code>@[coe]</code>?</p>\n</blockquote>\n<p>An idea I got while away from the computer, so untested: would it be possible to use unification hints for this purpose? Not sure how they work in Lean 4, let alone in combination with tactics, but it would be nice to be able to say that <code>@Nat.cast _ _ n =?= @coe _ _ _ n</code> should unify, and have <code>simp</code>/<code>rw</code>/etc. respect that</p>",
        "id": 312657986,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1669650488
    }
]
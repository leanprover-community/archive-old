[
    {
        "content": "<p>I have a little riddle, from the file <code>exterior_algebra</code>. Consider the following two definitions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.exterior_algebra</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">profiler</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo1</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">semiring</span> <span class=\"o\">(</span><span class=\"n\">exterior_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">semiring</span> <span class=\"o\">(</span><span class=\"n\">tensor_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span> <span class=\"k\">in</span>\n<span class=\"bp\">@</span><span class=\"n\">ring_quot.semiring</span> <span class=\"o\">(</span><span class=\"n\">tensor_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">exterior_algebra.rel</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo2</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"o\">(</span><span class=\"n\">exterior_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"o\">(</span><span class=\"n\">tensor_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span> <span class=\"k\">in</span>\n<span class=\"bp\">@</span><span class=\"n\">ring_quot.ring</span> <span class=\"o\">(</span><span class=\"n\">tensor_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">exterior_algebra.rel</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Here <code>foo1</code> elaborates in 18ms on my computer, and <code>foo2</code> in 18s. So a ratio of 1 to 1000...</p>",
        "id": 233614772,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617868022
    },
    {
        "content": "<p>This one was a mystery to me too</p>",
        "id": 233615083,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617868199
    },
    {
        "content": "<p>I was kinda fed up with not having a ring structure at all, and had such a hard time adding one that I lost interest in making it fast too!</p>",
        "id": 233615226,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617868259
    },
    {
        "content": "<p><del>src#exterior_algebra.ring has a few more <code>let</code>s than that, doesn't it?</del></p>",
        "id": 233615285,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617868293
    },
    {
        "content": "<p>I noticed it because it gets even slower in <a href=\"https://github.com/leanprover-community/mathlib/issues/7084\">#7084</a></p>",
        "id": 233615303,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617868300
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Slow.20definition/near/233615285\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/exterior_algebra.ring/src\">src#exterior_algebra.ring</a> has a few more <code>let</code>s than that, doesn't it?</p>\n</blockquote>\n<p>No, I copied the exact definition.</p>",
        "id": 233615336,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617868322
    },
    {
        "content": "<p>I thought that might be where this was going</p>",
        "id": 233615431,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617868353
    },
    {
        "content": "<p>Does <a href=\"https://github.com/leanprover-community/mathlib/issues/7084\">#7084</a> change <code>ring_quot</code> (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring_quot.semiring\">docs#ring_quot.semiring</a>?) to add a non-auto_param nsmul?</p>",
        "id": 233615505,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617868399
    },
    {
        "content": "<p>I just noticed that ring_quot.ring uses the automatic <code>has_sub</code> - I'll see if changing that makes things better.</p>",
        "id": 233615736,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617868561
    },
    {
        "content": "<p>It didn't initially, although it does now on my local branch (because there is also an algebra instance below, so to kill the potential diamond one needs to add the <code>nsmul</code> field). But it becomes too slow even without adding it.</p>",
        "id": 233615777,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617868568
    },
    {
        "content": "<p>I found a way to speed up things, but I don't understand what's going on. The current ring structure on a quotient is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"o\">(</span><span class=\"n\">ring_quot</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">neg</span>           <span class=\"o\">:=</span> <span class=\"n\">quot.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">a</span><span class=\"o\">)</span>\n    <span class=\"n\">rel.neg</span><span class=\"o\">,</span>\n  <span class=\"n\">add_left_neg</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">exact</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">quot.mk</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">add_left_neg</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"o\">},</span>\n  <span class=\"bp\">..</span> <span class=\"o\">(</span><span class=\"n\">ring_quot.semiring</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>With this definition, my test example <code>foo2</code> takes 18s to compile. If I change it to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"o\">(</span><span class=\"n\">ring_quot</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">add</span>           <span class=\"o\">:=</span> <span class=\"n\">quot.map₂</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"n\">rel.add_right</span> <span class=\"n\">rel.add_left</span><span class=\"o\">,</span>\n  <span class=\"n\">add_assoc</span>     <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨⟩</span> <span class=\"o\">⟨⟩</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">exact</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">quot.mk</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">add_assoc</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"o\">},</span>\n  <span class=\"n\">zero</span>          <span class=\"o\">:=</span> <span class=\"n\">quot.mk</span> <span class=\"n\">_</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_add</span>      <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">exact</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">quot.mk</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">zero_add</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"o\">},</span>\n  <span class=\"n\">add_zero</span>      <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">exact</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">quot.mk</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">add_zero</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"o\">},</span>\n  <span class=\"n\">add_comm</span>      <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨⟩</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">exact</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">quot.mk</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">add_comm</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"o\">},</span>\n  <span class=\"n\">mul</span>           <span class=\"o\">:=</span> <span class=\"n\">quot.map₂</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"n\">rel.mul_right</span> <span class=\"n\">rel.mul_left</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_assoc</span>     <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨⟩</span> <span class=\"o\">⟨⟩</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">exact</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">quot.mk</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mul_assoc</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"o\">},</span>\n  <span class=\"n\">one</span>           <span class=\"o\">:=</span> <span class=\"n\">quot.mk</span> <span class=\"n\">_</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">one_mul</span>       <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">exact</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">quot.mk</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">one_mul</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"o\">},</span>\n  <span class=\"n\">mul_one</span>       <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">exact</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">quot.mk</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mul_one</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"o\">},</span>\n  <span class=\"n\">left_distrib</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨⟩</span> <span class=\"o\">⟨⟩</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">exact</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">quot.mk</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">left_distrib</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"o\">},</span>\n  <span class=\"n\">right_distrib</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨⟩</span> <span class=\"o\">⟨⟩</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">exact</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">quot.mk</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">right_distrib</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"o\">},</span>\n  <span class=\"n\">neg</span>           <span class=\"o\">:=</span> <span class=\"n\">quot.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">rel.neg</span><span class=\"o\">,</span>\n  <span class=\"n\">add_left_neg</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">exact</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">quot.mk</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">add_left_neg</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>(So, doing everything by hand instead of referring to the semiring structure), then this goes down to 8s. </p>\n<p>If I trim it down to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"o\">(</span><span class=\"n\">ring_quot</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">add</span>           <span class=\"o\">:=</span> <span class=\"n\">quot.map₂</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"n\">rel.add_right</span> <span class=\"n\">rel.add_left</span><span class=\"o\">,</span>\n  <span class=\"n\">zero</span>          <span class=\"o\">:=</span> <span class=\"n\">quot.mk</span> <span class=\"n\">_</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">mul</span>           <span class=\"o\">:=</span> <span class=\"n\">quot.map₂</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"n\">rel.mul_right</span> <span class=\"n\">rel.mul_left</span><span class=\"o\">,</span>\n  <span class=\"n\">one</span>           <span class=\"o\">:=</span> <span class=\"n\">quot.mk</span> <span class=\"n\">_</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">neg</span>           <span class=\"o\">:=</span> <span class=\"n\">quot.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">rel.neg</span><span class=\"o\">,</span>\n  <span class=\"n\">add_left_neg</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">exact</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">quot.mk</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">add_left_neg</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"bp\">..</span> <span class=\"o\">(</span><span class=\"n\">ring_quot.semiring</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>(Keeping only the data fields, and leaving the Prop fields to the semiring structure), this goes up again to 21s.</p>\n<p>So the content of Prop-fields matters, which I don't get. And all this is to be compared to the 18ms for the semiring version. </p>\n<p>TLDR: I don't understand anything to the inner workings of structure elaboration. Any advice on how to make things right / good practice rule would be most welcome!</p>",
        "id": 233624077,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617873561
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Slow.20definition/near/233615736\">said</a>:</p>\n<blockquote>\n<p>I just noticed that ring_quot.ring uses the automatic <code>has_sub</code> - I'll see if changing that makes things better.</p>\n</blockquote>\n<p>Done in <a href=\"https://github.com/leanprover-community/mathlib/issues/7112\">#7112</a>, although I didn't end up profiling it because the behavior seemed like something we'd want anyway</p>",
        "id": 233636361,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617881017
    },
    {
        "content": "<p>I had done profiling, and it doesn't make any difference. Unfortunately, the speedup I mentioned earlier in the discussion is not enough for <a href=\"https://github.com/leanprover-community/mathlib/issues/7084\">#7084</a>, which is therefore stuck for now :-(</p>",
        "id": 233638104,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617882085
    },
    {
        "content": "<p>I'm wondering if the solution here would not be to make more things irreducible: here the exterior algebra is a quotient of the tensor algebra, which itself is already a complicated quotient, so if Lean tries to unfold anything in exterior algebras the terms are astronomically big right away, which is probably not reasonable (and essentially pointless). Thoughts, anyone?</p>",
        "id": 233658727,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617891081
    },
    {
        "content": "<p>(by \"irreducible\", I mean use structures just like in the definition of reals, not mark things irreducible after the fact).</p>",
        "id": 233658883,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617891128
    },
    {
        "content": "<p>Note that originally things were marked <code>irreducible</code> and that actually broke typeclass search</p>",
        "id": 233659658,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617891405
    },
    {
        "content": "<blockquote>\n<p>(So, doing everything by hand instead of referring to the semiring structure), then this goes down to 8s.</p>\n</blockquote>\n<p>This makes no difference for me. On my desktop it takes around 9 seconds to elaborate <code>foo2</code> below, and if I uncomment all the comments then it still takes around 9 seconds. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.exterior_algebra</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.ring_quot</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">profiler</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo1</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">semiring</span> <span class=\"o\">(</span><span class=\"n\">exterior_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">semiring</span> <span class=\"o\">(</span><span class=\"n\">tensor_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span> <span class=\"k\">in</span>\n<span class=\"bp\">@</span><span class=\"n\">ring_quot.semiring</span> <span class=\"o\">(</span><span class=\"n\">tensor_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">exterior_algebra.rel</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u₁</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">ring_quot</span>\n\n<span class=\"c1\">-- local attribute [-instance] ring_quot.ring</span>\n\n<span class=\"c1\">-- instance inst37 {R : Type u₁} [ring R] (r : R → R → Prop) : ring (ring_quot r) :=</span>\n<span class=\"c1\">-- { add           := quot.map₂ (+) rel.add_right rel.add_left,</span>\n<span class=\"c1\">--   add_assoc     := by { rintros ⟨⟩ ⟨⟩ ⟨⟩, exact congr_arg (quot.mk _) (add_assoc _ _ _), },</span>\n<span class=\"c1\">--   zero          := quot.mk _ 0,</span>\n<span class=\"c1\">--   zero_add      := by { rintros ⟨⟩, exact congr_arg (quot.mk _) (zero_add _), },</span>\n<span class=\"c1\">--   add_zero      := by { rintros ⟨⟩, exact congr_arg (quot.mk _) (add_zero _), },</span>\n<span class=\"c1\">--   add_comm      := by { rintros ⟨⟩ ⟨⟩, exact congr_arg (quot.mk _) (add_comm _ _), },</span>\n<span class=\"c1\">--   mul           := quot.map₂ (*) rel.mul_right rel.mul_left,</span>\n<span class=\"c1\">--   mul_assoc     := by { rintros ⟨⟩ ⟨⟩ ⟨⟩, exact congr_arg (quot.mk _) (mul_assoc _ _ _), },</span>\n<span class=\"c1\">--   one           := quot.mk _ 1,</span>\n<span class=\"c1\">--   one_mul       := by { rintros ⟨⟩, exact congr_arg (quot.mk _) (one_mul _), },</span>\n<span class=\"c1\">--   mul_one       := by { rintros ⟨⟩, exact congr_arg (quot.mk _) (mul_one _), },</span>\n<span class=\"c1\">--   left_distrib  := by { rintros ⟨⟩ ⟨⟩ ⟨⟩, exact congr_arg (quot.mk _) (left_distrib _ _ _), },</span>\n<span class=\"c1\">--   right_distrib := by { rintros ⟨⟩ ⟨⟩ ⟨⟩, exact congr_arg (quot.mk _) (right_distrib _ _ _), },</span>\n<span class=\"c1\">--   neg           := quot.map (λ a, -a) rel.neg,</span>\n<span class=\"c1\">--   add_left_neg  := by { rintros ⟨⟩, exact congr_arg (quot.mk _) (add_left_neg _) } }</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo2</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"o\">(</span><span class=\"n\">exterior_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"o\">(</span><span class=\"n\">tensor_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span> <span class=\"k\">in</span>\n<span class=\"bp\">@</span><span class=\"n\">ring_quot.ring</span> <span class=\"o\">(</span><span class=\"n\">tensor_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">exterior_algebra.rel</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 233669712,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617894422
    },
    {
        "content": "<p>Oh in fact if I just make ring_quot.ring not an instance then it still takes 9 seconds -- in my set-up it doesn't seem to be using <code>ring_quot.ring</code> at all (this is on a relatively recent master -- are you doing something else?)</p>",
        "id": 233670333,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617894565
    },
    {
        "content": "<p>You need to do this in the original file, before <code>tensor_product</code> is defined.</p>",
        "id": 233670351,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617894570
    },
    {
        "content": "<p>Got it!</p>",
        "id": 233670389,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617894580
    },
    {
        "content": "<p>Did you actually mean <code>tensor_product</code> and not <code>tensor_algebra</code>?</p>",
        "id": 233670854,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617894689
    },
    {
        "content": "<p>It's a universe issue.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.exterior_algebra</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">profiler</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo1</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">semiring</span> <span class=\"o\">(</span><span class=\"n\">exterior_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">semiring</span> <span class=\"o\">(</span><span class=\"n\">tensor_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span> <span class=\"k\">in</span>\n<span class=\"bp\">@</span><span class=\"n\">ring_quot.semiring</span> <span class=\"o\">(</span><span class=\"n\">tensor_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">exterior_algebra.rel</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Change {S : Type*} to {S : Type}</span>\n<span class=\"c1\">-- 455 ms</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo2</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"o\">(</span><span class=\"n\">exterior_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"o\">(</span><span class=\"n\">tensor_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span> <span class=\"k\">in</span>\n<span class=\"bp\">@</span><span class=\"n\">ring_quot.ring</span> <span class=\"o\">(</span><span class=\"n\">tensor_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">exterior_algebra.rel</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 233675279,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617895954
    },
    {
        "content": "<p>What if you put <code>{S : Type*}</code> in a separate variables declaration?</p>",
        "id": 233675443,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617896018
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.exterior_algebra</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">profiler</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo1</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">semiring</span> <span class=\"o\">(</span><span class=\"n\">exterior_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">semiring</span> <span class=\"o\">(</span><span class=\"n\">tensor_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span> <span class=\"k\">in</span>\n<span class=\"bp\">@</span><span class=\"n\">ring_quot.semiring</span> <span class=\"o\">(</span><span class=\"n\">tensor_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">exterior_algebra.rel</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- 455 ms</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo2</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"o\">(</span><span class=\"n\">exterior_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"o\">(</span><span class=\"n\">tensor_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span> <span class=\"k\">in</span>\n<span class=\"bp\">@</span><span class=\"n\">ring_quot.ring</span> <span class=\"o\">(</span><span class=\"n\">tensor_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">exterior_algebra.rel</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This is also instant. It's <code>{Type*}</code> v <code>{Type u}</code> again.</p>",
        "id": 233675514,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617896044
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.exterior_algebra</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">profiler</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo1</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">semiring</span> <span class=\"o\">(</span><span class=\"n\">exterior_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">semiring</span> <span class=\"o\">(</span><span class=\"n\">tensor_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span> <span class=\"k\">in</span>\n<span class=\"bp\">@</span><span class=\"n\">ring_quot.semiring</span> <span class=\"o\">(</span><span class=\"n\">tensor_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">exterior_algebra.rel</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- 484ms</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo2</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"o\">(</span><span class=\"n\">exterior_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"o\">(</span><span class=\"n\">tensor_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span> <span class=\"k\">in</span>\n<span class=\"bp\">@</span><span class=\"n\">ring_quot.ring</span> <span class=\"o\">(</span><span class=\"n\">tensor_algebra</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">exterior_algebra.rel</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>As Eric suggests: if you strip it out it's quick even with Type*.</p>",
        "id": 233675827,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617896143
    },
    {
        "content": "<p>This is annoying, because I constantly run into universe issues where someone wrote <code>Type u</code> and mean <code>Type something_other_than_u</code> because guessing the universe variables already in the lemma was a pain for them.</p>\n<p>In the past I've ended up stripping out universe variables entirely and replacing things with <code>Type*</code>. Only now we find that introduces subtler problems...</p>",
        "id": 233676041,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617896194
    },
    {
        "content": "<p>I have not encountered this issue much, but the first time it came for me was also in linear algebra.  Could there be something specific to the linear algebra part of the library that makes these issues more prominent?</p>",
        "id": 233676368,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617896317
    },
    {
        "content": "<p>I think this was why universes were causing problems with some previous linear algebra thread:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n<span class=\"c1\">-- this is the type of `flip`</span>\n<span class=\"k\">#check</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">φ</span>\n<span class=\"c1\">-- Type (max (u+1) (v+1) (w+1) (max u v w) v u w)</span>\n</code></pre></div>\n<p>This type can be simplified, but you can't run the simplifier on universe levels :-)</p>",
        "id": 233677352,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617896676
    },
    {
        "content": "<p>Indeed, it was <code>flip</code>!  Maybe it is the fact of having 3 interlaced Types that causes problems?</p>",
        "id": 233677615,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617896776
    },
    {
        "content": "<p>My instinct, probably not the correct one but it's what I tell students, is that whilst it's important to stay universe polymorphic, can you really imagine a situation where you have your ring in one universe and your module in another one? Put everything into one universe! And then of course people want to do modules over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span> and they realise they have to do everything in <code>Type</code>.</p>",
        "id": 233677643,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617896787
    },
    {
        "content": "<p>... which is fine as it might even be inconsistent to have more than <code>Type</code>!  <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 233677794,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617896843
    },
    {
        "content": "<p>Here is the non-diamond which I think is causing the issue:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.exterior_algebra</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">profiler</span> <span class=\"n\">true</span>\n\n<span class=\"c1\">-- 10 seconds</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">tensor_algebra.semiring</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">comm_ring.to_comm_semiring</span> <span class=\"n\">S</span> <span class=\"n\">_inst_4</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">_inst_2</span> <span class=\"n\">_inst_5</span> <span class=\"bp\">=</span>\n  <span class=\"bp\">@</span><span class=\"n\">ring.to_semiring</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">tensor_algebra</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">comm_ring.to_comm_semiring</span> <span class=\"n\">S</span> <span class=\"n\">_inst_4</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">_inst_2</span> <span class=\"n\">_inst_5</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">tensor_algebra.ring</span> <span class=\"n\">M</span> <span class=\"n\">_inst_2</span> <span class=\"n\">S</span> <span class=\"n\">_inst_4</span> <span class=\"n\">_inst_5</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- 1/2 second</span>\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">tensor_algebra.semiring</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">comm_ring.to_comm_semiring</span> <span class=\"n\">S</span> <span class=\"n\">_inst_4</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">_inst_2</span> <span class=\"n\">_inst_5</span> <span class=\"bp\">=</span>\n  <span class=\"bp\">@</span><span class=\"n\">ring.to_semiring</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">tensor_algebra</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">comm_ring.to_comm_semiring</span> <span class=\"n\">S</span> <span class=\"n\">_inst_4</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">_inst_2</span> <span class=\"n\">_inst_5</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">tensor_algebra.ring</span> <span class=\"n\">M</span> <span class=\"n\">_inst_2</span> <span class=\"n\">S</span> <span class=\"n\">_inst_4</span> <span class=\"n\">_inst_5</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>(<code>foo</code> and <code>bar</code> are the same apart from <code>{S : Type*}</code> changed to <code>{S : Type w}</code>)</p>",
        "id": 233683319,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617898908
    },
    {
        "content": "<p>What does <code>foo</code> infer for the <code>*</code>?</p>",
        "id": 233684425,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617899400
    },
    {
        "content": "<p><code>{S : Type u_2} </code></p>",
        "id": 233684730,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617899507
    },
    {
        "content": "<p>Thanks a lot for debugging this and noticing it was a universe issue! In the meantime, I have made this quotient ring construction irreducible, which I think is a good idea in any case because it hides some irrelevant complexity.</p>",
        "id": 233684815,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617899534
    },
    {
        "content": "<p>Thanks a lot for your diamond-killing! You have put in a lot of work recently with some really technical and messy issues and I am all too happy to help.</p>",
        "id": 233684946,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617899591
    },
    {
        "content": "<p>After making things irreducible, <code>foo</code> takes 2 seconds and <code>bar</code>takes 0.5s, so it's better but the universe issues are still in the way.</p>",
        "id": 233685075,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617899639
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> as far as I can see <code>foo</code> and <code>bar</code> are identical even up to universes.</p>",
        "id": 233685373,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617899756
    },
    {
        "content": "<p>For some reason Lean is spending a long time solving for <code>*</code> in <code>foo</code>, and ultimately deciding that it can be anything.</p>",
        "id": 233685634,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617899882
    },
    {
        "content": "<p>If someone had told me 5 years ago I'd be working with an analyst on universe issues, I would have been extremely skeptical.</p>",
        "id": 233686530,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617900276
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Slow.20definition/near/233686530\">said</a>:</p>\n<blockquote>\n<p>If someone had told me 5 years ago I'd be working with an analyst on universe issues, I would have been extremely skeptical.</p>\n</blockquote>\n<p>Sounds like you're in a different universe now to the one you thought you were in</p>",
        "id": 233686697,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617900344
    },
    {
        "content": "<p>I'm not really an analyst, you know, more of a dynamical systems/probability person. But still in a different universe, yes :-)</p>",
        "id": 233686732,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617900361
    },
    {
        "content": "<p>And I've already written a paper relying on the classification of irreducible unitary representations of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mi>L</mi><mo stretchy=\"false\">(</mo><mn>2</mn><mo separator=\"true\">,</mo><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">SL(2,\\R)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">L</span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"mclose\">)</span></span></span></span>, so that almost makes me an automorphic guy also :-)</p>",
        "id": 233686935,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617900437
    },
    {
        "content": "<p>They're defeq to projective 2-d reps of the Weil group of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span></span></span> I guess.</p>",
        "id": 233687082,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617900490
    },
    {
        "content": "<p>Another weirdness I encountered while fixing the slowness. In the file <code>data.mv_polynomial.equiv</code>, on Line 255, there is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">change</span> <span class=\"n\">algebra_map</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">mv_polynomial</span> <span class=\"n\">S₁</span> <span class=\"o\">(</span><span class=\"n\">mv_polynomial</span> <span class=\"n\">S₂</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"n\">r</span> <span class=\"k\">with</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">r</span><span class=\"o\">),</span>\n</code></pre></div>\n<p>which is already slow, and becomes slower after the refactor. You can replace the <code>change</code> with an equivalent</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">have</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">algebra_map</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">mv_polynomial</span> <span class=\"n\">S₁</span> <span class=\"o\">(</span><span class=\"n\">mv_polynomial</span> <span class=\"n\">S₂</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>which takes 64s on my branch. With <code>:= by refl</code>, same thing. With <code>, by refl</code>, it becomes instant (less than 200ms).</p>",
        "id": 233708350,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617907748
    },
    {
        "content": "<p>Another weird example.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">finite_field.char_poly_pow_card</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">n</span> <span class=\"n\">n</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">char_poly</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">fintype.card</span> <span class=\"n\">K</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">char_poly</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">char_p.exists</span> <span class=\"n\">K</span> <span class=\"k\">with</span> <span class=\"n\">p</span> <span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">finite_field.card</span> <span class=\"n\">K</span> <span class=\"n\">p</span> <span class=\"k\">with</span> <span class=\"o\">⟨⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">kpos</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">hk</span><span class=\"o\">⟩⟩,</span>\n    <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">fact</span> <span class=\"n\">p.prime</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">hp</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">hk</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">hk</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">frobenius_inj</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">iterate</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n    <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">iterate_frobenius</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">hk</span> <span class=\"o\">},</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">finite_field.expand_card</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">char_poly</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">alg_hom.map_det</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">is_monoid_hom.map_pow</span><span class=\"o\">],</span>\n    <span class=\"n\">apply</span> <span class=\"n\">congr_arg</span> <span class=\"n\">det</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">mat_poly_equiv.injective</span><span class=\"o\">,</span> <span class=\"n\">swap</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">apply_instance</span> <span class=\"o\">},</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">mat_poly_equiv.coe_alg_hom</span><span class=\"o\">,</span> <span class=\"n\">alg_hom.map_pow</span><span class=\"o\">,</span> <span class=\"n\">mat_poly_equiv.coe_alg_hom</span><span class=\"o\">,</span>\n          <span class=\"n\">mat_poly_equiv_char_matrix</span><span class=\"o\">,</span> <span class=\"n\">hk</span><span class=\"o\">,</span> <span class=\"n\">sub_pow_char_pow_of_commute</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">C_pow</span><span class=\"o\">],</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">mat_poly_equiv_eq_X_pow_sub_C</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">commute_X</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">congr</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">subsingleton.elim</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">subsingleton_of_empty_left</span> <span class=\"n\">hn</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>takes 30s on mathlib master. If I change the last three lines to </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">mat_poly_equiv_eq_X_pow_sub_C</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">commute_X</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">congr_arg</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">subsingleton.elim</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">subsingleton_of_empty_left</span> <span class=\"n\">hn</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n</code></pre></div>\n<p>it goes down to 2s. </p>\n<p>This PR is getting me to meet all the corners of mathlib where weird things are going on!</p>",
        "id": 233725304,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617914813
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/7084\">#7084</a> is finally building without timeouts. There is an issue with the tests for <code>transport</code>, though, since it can not transport just by itself the <code>nsmul</code> field (or it can not transport the proof that it is equal to the inductive <code>nsmul</code>). Can this be fixed in <code>transport</code>, or should we use another playground for <code>transport</code> tests (or do you think this PR was a bad idea to begin with)? <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> , you wrote <code>transport</code>, right?</p>",
        "id": 233879890,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617997358
    },
    {
        "content": "<p>Yes. Sorry, it's been a while since I worked on <code>transport</code>. Last year I had a long todo list of further improvements, but I stopped working on it for a while. I'd like to get back to it, but I think for now we should just change the tests to avoid this situation.</p>",
        "id": 233904818,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618009863
    },
    {
        "content": "<p>Hmm.. Actually, I guess this fundamentally breaks <code>transport</code>... :-) I'll see how hard a fix would be.</p>",
        "id": 233905110,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618010058
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span>, do you know if there is some way to ask <code>refine_struct</code> to make use of optional values? This would solve the problem.</p>",
        "id": 233906043,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618010798
    },
    {
        "content": "<p>Ah, it was meant to all along, but <a href=\"https://github.com/leanprover-community/mathlib/issues/2319\">#2319</a> accidentally broke it.</p>",
        "id": 233907546,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618012044
    },
    {
        "content": "<p>Okay <a href=\"https://github.com/leanprover-community/mathlib/issues/7143\">#7143</a> will fix this problem. I'd suggest just merging it into <a href=\"https://github.com/leanprover-community/mathlib/issues/7084\">#7084</a>.</p>",
        "id": 233907810,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618012232
    },
    {
        "content": "<p>Unfortunately <a href=\"https://github.com/leanprover-community/mathlib/issues/7143\">#7143</a> doesn't work at all, so I've marked it WIP, and am hoping for some help from Simon.</p>",
        "id": 233952880,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618059078
    },
    {
        "content": "<p>I think I've found a workaround, switching to better requirements for <code>nsmul</code> that should be more in line with what <code>transfer</code> can do.</p>",
        "id": 233953985,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618060122
    },
    {
        "content": "<p>I've now changed the definition of <code>add_monoid</code> in <a href=\"https://github.com/leanprover-community/mathlib/issues/7084\">#7084</a>. It is now</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">add_monoid</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">add_semigroup</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">add_zero_class</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">nsmul</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">nsmul_rec</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">nsmul_zero'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">nsmul</span> <span class=\"mi\">0</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">.</span> <span class=\"n\">try_refl_tac</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">nsmul_succ'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">nsmul</span> <span class=\"n\">n.succ</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">nsmul</span> <span class=\"n\">n</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">.</span> <span class=\"n\">try_refl_tac</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>so, just using addition and multiplication to express the properties one wants of <code>nsmul</code>. This is the kind of thing that transfer should like more, and indeed in the tests <code>transfer</code> has no difficulty transferring a <code>semiring</code> instance with this new definition. Some tests are failing, but just because the definition is not the same so there are more fields to fill. <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> , I could fix the tests myself but I am not sure what they are testing, so it is maybe better if you have a look yourself. If you trust me to fix them, tell me and I'll do it!</p>",
        "id": 234046579,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618149265
    },
    {
        "content": "<p>You mean <code>transport</code> not <code>transfer</code>, right?</p>",
        "id": 234046604,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618149294
    },
    {
        "content": "<p>I'll look now.</p>",
        "id": 234046620,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618149309
    },
    {
        "content": "<p>I fixed the tests for <code>equiv_rw</code>, but am a bit stumped by the failure of the test for <code>transport</code>. It works for semiring at the top of the file, but then not at the bottom.</p>",
        "id": 234047079,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618149710
    },
    {
        "content": "<p>I've also fixed the tests for <code>refine_struct</code>. <code>transport</code> itself really shouldn't care how many fields there are: it works that out for the structure itself.</p>",
        "id": 234047881,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618150355
    },
    {
        "content": "<p>Oh!</p>",
        "id": 234048144,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618150566
    },
    {
        "content": "<p>The problem is that the second test for <code>transport</code> is transporting between <code>nat</code> and <code>mynat</code>. When it gets to the <code>npow</code> field, it can't tell the difference between the copies of <code>nat</code> that it is meant to transport to <code>mynat</code> (because they are the carrier type of the semiring), and the copies of <code>nat</code> that are referring to powers, and just be left invariant.</p>",
        "id": 234048203,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618150636
    },
    {
        "content": "<p>It's late here, but I will try to think about a good solution to this. Not sure at this point.</p>",
        "id": 234048339,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618150745
    },
    {
        "content": "<p>Isn't it just that the test is unfortunate here? Doing the same with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span></span></span> instead of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span></span></span> should avoid this issue, right?</p>",
        "id": 234061725,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618161754
    },
    {
        "content": "<p>Yes.</p>",
        "id": 234083593,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618182572
    },
    {
        "content": "<p>I have fixed the test by using the general <code>semiring.map</code> defined at the top of the file (which is defined for a generic ring and therefore not perturbed by the coincidental fact that our ring is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span></span></span>). I hope it's ok.</p>",
        "id": 234140864,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618226423
    },
    {
        "content": "<p>There is another test failing in  <a href=\"https://github.com/leanprover-community/mathlib/issues/7084\">#7084</a>, for <code>ring_exp</code> (hopefully the last one!)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">1000000</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">1000000</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ring_exp</span>\n<span class=\"c1\">-- deep recursion was detected at 'replace' (potential solution: increase stack space in your system)</span>\n</code></pre></div>\n<p>This is probably due to the fact that I changed the definition of powers (now, <code>x ^ n.succ</code> is definitionally <code>x ^ n * x</code>, while it used to be <code>x * x^n</code>). I don't understand the internals of <code>ring_exp</code> enough to be able to fix this. <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> , do you think you could have a look or give me a hint where to look?</p>",
        "id": 234141411,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618226727
    },
    {
        "content": "<p>It's not supposed to use defeq to unfold <code>pow</code>s, instead applying the <a href=\"https://github.com/leanprover-community/mathlib/blob/nsmul_data/src/tactic/ring_exp.lean#L1091\"><code>pow_p_pf_succ</code></a> family of lemmas. Those still typecheck, right?</p>",
        "id": 234141925,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1618227034
    },
    {
        "content": "<p>Would it work to fix the previous commit, or should I wait for the new oleans to be built?</p>",
        "id": 234142121,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1618227144
    },
    {
        "content": "<p>Fixing the previous commit would be perfect.</p>",
        "id": 234142269,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618227233
    },
    {
        "content": "<p>Yes, all the lemmas still typecheck, the problem only shows up in this specific test.</p>",
        "id": 234142385,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618227279
    },
    {
        "content": "<p>Strangely enough, the test works if one replaces <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85556em;vertical-align:-0.16667em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span></span></span>, or a general <code>comm_ring</code>.</p>",
        "id": 234142483,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618227350
    },
    {
        "content": "<p>The proof term looks like it typechecks too, so it is the last <code>exact</code> that fails.</p>",
        "id": 234142774,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1618227523
    },
    {
        "content": "<p><del>I think it's a general bug that <code>ring_exp</code> happens to expose:</del></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">my_op</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"mi\">10000000000</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">my_op</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"mi\">100000000000</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- deep recursion detected at replace</span>\n</code></pre></div>",
        "id": 234143424,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1618227915
    },
    {
        "content": "<p>Nevermind, miscopied the number of 0's</p>",
        "id": 234143595,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1618228009
    },
    {
        "content": "<p>But overall yes, seems that this is an artifact of bad unfolding of the definition of <code>npow</code>. The following works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">irreducible</span><span class=\"o\">]</span> <span class=\"n\">npow_rec</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">1000000</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">1000000</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ring_exp</span> <span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 234144796,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1618228642
    },
    {
        "content": "<p>Ah, and changing elaboration order by going from <code>example</code> to <code>lemma</code> breaks the <code>my_op</code> example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">my_op</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"mi\">10000</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">fooQ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">my_op</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"mi\">10000</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- deep recursion detected at replace</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">fooN</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">my_op</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"mi\">10000</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- works</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">irreducible</span><span class=\"o\">]</span> <span class=\"n\">npow_rec</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fooQ'</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">my_op</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"mi\">10000</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 234145138,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1618228820
    },
    {
        "content": "<p>Is there an easy way to suggest to lean \"when unifying <code>@npow α inst1 x n =?= @npow α inst2 x n</code>, try unifying <code>inst1</code> with <code>inst2</code> before unfolding the whole thing\"?</p>",
        "id": 234145654,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1618229073
    },
    {
        "content": "<p>(I guess making <code>npow_rec</code> irreducible is close enough.)</p>",
        "id": 234145676,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1618229096
    },
    {
        "content": "<p>Here's my attempt at fixing this by making <code>npow_rec</code> irreducible (doesn't build yet because there are still some uses of reducible <code>npow_rec</code>): <a href=\"https://github.com/leanprover-community/mathlib/commit/7dc0d02c8610d881cd33f1605c3315518484b8fb\">https://github.com/leanprover-community/mathlib/commit/7dc0d02c8610d881cd33f1605c3315518484b8fb</a></p>\n<p>If we make <code>npow_rec</code> irreducible, we can't prove its properties anymore by <code>try_refl_tac</code> in the instances. I made a new <code>npow_zero_tac</code> and <code>npow_succ_tac</code> that try to apply the correct definitional lemmas. Unfolding <code>npow_rec</code> in <code>try_refl_tac</code> doesn't work always, since it may appear in a form like <code>div_inv_monoid.npow._default</code>.</p>",
        "id": 234150856,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1618231588
    },
    {
        "content": "<p>What I don't get is why it didn't show up before. Is it that one definition <code>x^(n+1) = x * x^n</code> is optimized by tail-recursion and the other <code>x^(n+1) = x^n * x</code> is not? If this is the case, I should definitely switch back to the original definition. I'd like to avoid putting <code>npow_rec</code> irreducible, because being able to compute small powers by <code>rfl</code> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85556em;vertical-align:-0.16667em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span></span></span></span> seems desirable.</p>",
        "id": 234163224,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618236017
    },
    {
        "content": "<p>The issue is not with the definition of <code>npow</code> itself, it's the fact that there are many <code>npow</code> fields available, so to unify <code>some_class_extending_monoid.npow</code> with <code>some_other_class_extending_monoid.npow</code> we need to unfold both sides a couple of times. But if one side has a shorter path to <code>npow_rec</code> than another, it will unfold the definition of <code>npow_rec</code>, actually calculating the outcome.</p>",
        "id": 234170097,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1618238247
    },
    {
        "content": "<p>So the better comparison is: why doesn't this happen for the <code>(+)</code> operator on <code>ℕ</code>?</p>",
        "id": 234170259,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1618238298
    },
    {
        "content": "<p>Is it just that <code>npow</code> causes the terms to grow exponentially?</p>",
        "id": 234170581,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1618238413
    },
    {
        "content": "<p>I think it's really a tail-recursion optimization. Look at the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mypow1</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">mypow1</span> <span class=\"n\">n</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">haspow1</span> <span class=\"o\">:</span> <span class=\"n\">has_pow</span> <span class=\"n\">ℚ</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">mypow1</span> <span class=\"n\">n</span> <span class=\"n\">x</span><span class=\"o\">⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">my_op1</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">mypow1</span> <span class=\"mi\">10000</span> <span class=\"n\">a</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">foo1</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">my_op1</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">has_pow.pow</span> <span class=\"n\">ℚ</span> <span class=\"n\">ℕ</span> <span class=\"n\">haspow1</span> <span class=\"n\">a</span> <span class=\"mi\">10000</span>  <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- deep recursion detected at replace</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mypow2</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">mypow2</span> <span class=\"n\">n</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">haspow2</span> <span class=\"o\">:</span> <span class=\"n\">has_pow</span> <span class=\"n\">ℚ</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">mypow2</span> <span class=\"n\">n</span> <span class=\"n\">x</span><span class=\"o\">⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">my_op2</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">mypow2</span> <span class=\"mi\">10000</span> <span class=\"n\">a</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">foo2</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">my_op2</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">has_pow.pow</span> <span class=\"n\">ℚ</span> <span class=\"n\">ℕ</span> <span class=\"n\">haspow2</span> <span class=\"n\">a</span> <span class=\"mi\">10000</span>  <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- works</span>\n</code></pre></div>\n<p>Exact same definition for both, but one with left multiplication and the other one with right multiplication. One works, the other fails.</p>",
        "id": 234170695,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618238446
    },
    {
        "content": "<p>I'll switch back to the other direction, even if it makes some things more painful.</p>",
        "id": 234170787,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618238481
    },
    {
        "content": "<p>(And I'll add a comment explaining why it has to be done this way).</p>",
        "id": 234170822,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618238498
    },
    {
        "content": "<p>Huh, but the recursive call isn't in tail position for those definitions.</p>",
        "id": 234170859,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1618238519
    },
    {
        "content": "<p>It might depend on how multiplication is defined, no?</p>",
        "id": 234171010,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618238569
    },
    {
        "content": "<p>This is always a \"proper\" tail-recursive definition, but still fails:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mypow3</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">x</span> <span class=\"n\">acc</span> <span class=\"o\">:=</span> <span class=\"n\">acc</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">acc</span> <span class=\"o\">:=</span> <span class=\"n\">mypow3</span> <span class=\"n\">n</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">acc</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">haspow3</span> <span class=\"o\">:</span> <span class=\"n\">has_pow</span> <span class=\"n\">ℚ</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">mypow3</span> <span class=\"n\">n</span> <span class=\"n\">x</span> <span class=\"mi\">1</span><span class=\"o\">⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">my_op3</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">mypow3</span> <span class=\"mi\">10000</span> <span class=\"n\">a</span> <span class=\"mi\">1</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">foo3</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">my_op3</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">has_pow.pow</span> <span class=\"n\">ℚ</span> <span class=\"n\">ℕ</span> <span class=\"n\">haspow3</span> <span class=\"n\">a</span> <span class=\"mi\">10000</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- deep recursion detected at replace</span>\n</code></pre></div>",
        "id": 234171298,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1618238667
    },
    {
        "content": "<p>Really weird...</p>",
        "id": 234172002,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618238897
    },
    {
        "content": "<p>Looking at the <code>set_option trace.type_context.is_def_eq_detail true</code>, for some reason Lean really wants to unfold only the <code>mypow3</code> on the right hand side:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>[type_context.is_def_eq_detail] [2]: a ^ 10000 =?= my_op3 a\n[type_context.is_def_eq_detail] unfold right: my_op3\n[type_context.is_def_eq_detail] [3]: a ^ 10000 =?= mypow3 10000 a 1\n[type_context.is_def_eq_detail] unfold right: mypow3\n[type_context.is_def_eq_detail] [4]: a ^ 10000 =?= mypow3 (5000.add (2500.add (1250.add (62\n5.add (624.add 0))))) a (1 * a)\n[type_context.is_def_eq_detail] unfold right: mypow3\n[type_context.is_def_eq_detail] [5]: a ^ 10000 =?= mypow3 (5000.add (2500.add (1250.add (62\n5.add (312.add (156.add (78.add (39.add (38.add 0))))))))) a (1 * a * a)\n[type_context.is_def_eq_detail] unfold right: mypow3\n[type_context.is_def_eq_detail] [6]: a ^ 10000 =?= mypow3 (5000.add (2500.add (1250.add (62\n5.add (312.add (156.add (78.add (39.add (19.add (18.add 0)))))))))) a\n  (1 * a * a * a)\n[type_context.is_def_eq_detail] unfold right: mypow3\n[type_context.is_def_eq_detail] [7]: a ^ 10000 =?= mypow3 (5000.add (2500.add (1250.add (62\n5.add (312.add (156.add (78.add (39.add (19.add (9.add (8.add 0))))))))))) a\n  (1 * a * a * a * a)\n[type_context.is_def_eq_detail] unfold right: mypow3\n[type_context.is_def_eq_detail] [8]: a ^ 10000 =?= mypow3\n  (5000.add\n     (2500.add (1250.add (625.add (312.add (156.add (78.add (39.add (19.add (9.add (4.add (\n2.add (1.add 0)))))))))))))\n  a\n  (1 * a * a * a * a * a)\n[type_context.is_def_eq_detail] unfold right: mypow3\n...\n</code></pre></div>",
        "id": 234172431,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1618239054
    },
    {
        "content": "<p>(From the Lean source: because <code>mypow3</code> can be delta-reduced, and <code>has_pow.pow</code> cannot?)</p>",
        "id": 234172704,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1618239142
    },
    {
        "content": "<p>So we actually want non-tail recursive definitions? It looks like, for <code>foo2</code>, they block the delta-reducing:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>[type_context.is_def_eq_detail] [2]: a ^ 10000 =?= my_op2 a\n[type_context.is_def_eq_detail] unfold right: my_op2\n[type_context.is_def_eq_detail] [3]: a ^ 10000 =?= mypow2 10000 a\n[type_context.is_def_eq_detail] unfold right: mypow2\n[type_context.is_def_eq_detail] [4]: a ^ 10000 =?= a * mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a\n[type_context.is_def_eq_detail] [5]: (λ (x : ℚ) (n : ℕ), mypow2 n x) a 10000 =?= distrib.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a)\n[type_context.is_def_eq_detail] after whnf_core: mypow2 10000 a =?= distrib.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a)\n[type_context.is_def_eq_detail] unfold left: mypow2\n[type_context.is_def_eq_detail] [6]: a * mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a =?= distrib.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a)\n[type_context.is_def_eq_detail] [7]: distrib.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a) =?= semiring.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a)\n[type_context.is_def_eq_detail] [8]: semiring.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a) =?= comm_semiring.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a)\n[type_context.is_def_eq_detail] [9]: comm_semiring.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a) =?= comm_ring.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a)\n[type_context.is_def_eq_detail] [10]: comm_ring.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a) =?= euclidean_domain.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a)\n[type_context.is_def_eq_detail] [11]: euclidean_domain.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a) =?= a * mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a\n[type_context.is_def_eq_detail] [12]: a * mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a =?= distrib.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a)\n[type_context.is_def_eq_detail] [13]: distrib.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a) =?= ring.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a)\n[type_context.is_def_eq_detail] [14]: ring.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a) =?= division_ring.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a)\n[type_context.is_def_eq_detail] [15]: division_ring.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a) =?= field.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a)\n[type_context.is_def_eq_detail] [16]: field.mul a (mypow2 (5000.add (2500.add (1250.add (625.add (624.add 0))))) a) =?= a.mul (mypow2 (5000.add (2500.add (1250.add (625.add (624.add : ...\n</code></pre></div>",
        "id": 234173134,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1618239298
    },
    {
        "content": "<p>Would an <code>id_delta</code> help? edit: I can't see a way</p>",
        "id": 234188922,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618244794
    },
    {
        "content": "<p>I'll just switch to the <code>mypow2</code> definition, which works fine.</p>",
        "id": 234189539,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618245036
    },
    {
        "content": "<p>This is probably worth filing as a github issue since you have a MWE, just so it doesn't get forgotten</p>",
        "id": 234189975,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618245228
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean/issues/563\">lean#563</a></p>",
        "id": 234219220,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1618256977
    }
]
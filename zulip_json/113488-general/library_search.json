[
    {
        "content": "<p>... a present coming soon:</p>\n<p>Here's a randomly chosen short mathlib proof:</p>\n<div class=\"codehilite\"><pre><span></span>lemma div_dvd_of_dvd {a b : ‚Ñï} (h : b ‚à£ a) : (a / b) ‚à£ a :=\n‚ü®b, (nat.div_mul_cancel h).symm‚ü©\n</pre></div>\n\n\n<p>Now, let's try</p>\n<div class=\"codehilite\"><pre><span></span>lemma div_dvd_of_dvd {a b : ‚Ñï} (h : b ‚à£ a) : (a / b) ‚à£ a :=\nby library_search\n</pre></div>\n\n\n<p>wait a few seconds, and observe the trace message <code>div_dvd_of_dvd h</code>, which is interesting I guess, but not that awesome.</p>\n<p>However:</p>\n<div class=\"codehilite\"><pre><span></span>lemma div_dvd_of_dvd {a b : ‚Ñï} (h : b ‚à£ a) : (a / b) ‚à£ a :=\nby library_search [-div_dvd_of_dvd]\n</pre></div>\n\n\n<p>gives <code>dvd.intro b (nat.div_mul_cancel h)</code>.</p>\n<p>There were no hints here, just scraping all the imported declarations, and doing a neither-depth-nor-breadth-first search of the tree of applications of lemmas to the goal.</p>",
        "id": 159997569,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1551788026
    },
    {
        "content": "<p>Now, this is pretty sensitive to how much you have imported! With just <code>data.nat.prime</code> imported, this example takes a second or so, but with everything-and-the-kitchen-sink imported it spirals out to 40s, which is obviously unacceptable. But I've barely started optimising / trimming the search tree, so it's possible this will still improve a lot.</p>",
        "id": 159997676,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1551788146
    },
    {
        "content": "<p>Other examples are much less sensitive to the amount imported.  For example I can find the proof of <code>example {a b c : ‚Ñï} (h‚ÇÅ : a ‚à£ c) (h‚ÇÇ : a ‚à£ b + c) : a ‚à£ b</code> in about 1s with small imports, and 2s with lots of imports.</p>",
        "id": 159997754,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1551788206
    },
    {
        "content": "<p>(That proof is <code>(nat.dvd_add_iff_left h‚ÇÅ).mpr h‚ÇÇ</code>)</p>",
        "id": 159997826,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1551788279
    },
    {
        "content": "<p>It's very promising!</p>",
        "id": 159997879,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1551788297
    },
    {
        "content": "<p>It's very exciting to see you are back to tactic writing!</p>",
        "id": 159997891,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1551788311
    },
    {
        "content": "<p>Attempting to prepare examples for my students was getting discouraging. Also they are already upset about not being able to find lemmas. :-)</p>",
        "id": 159997917,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1551788344
    },
    {
        "content": "<p>Also -- thanks to Simon and Keeley for help at key points, and Johan's constant encouragement. :-)</p>",
        "id": 159997958,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1551788380
    },
    {
        "content": "<p>But there's still some work to get this polished, it's a mess at the moment!</p>",
        "id": 159997967,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1551788393
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I'm glad you interpret my nagging and whining as encouragement (-;<br>\nI'm very excited to see this! I really hope we will have a <code>back</code> in mathlib soon.</p>",
        "id": 160015701,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551802354
    },
    {
        "content": "<p>This is also how I collaborate with Simon</p>",
        "id": 160022912,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1551807450
    },
    {
        "content": "<p>I had some people in my office today who attended Kevin's talk. They had never used Lean before, but they wanted to try it. I helped them setup the system, and they dove in. First thing they wanted to try: prove that the derivative of <code>exp</code> is <code>exp</code>. After we had the statement formalised, I told them about some basic tactics, and <code>library_search</code>. They loved it. It worked surprisingly often, which kept them addicted. Of course, when we got to the meat of the theorem, we gut stuck. But nevertheless: chapeau <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>!<br>\n(I think Kevin would say that they went in instant Isabelle-mode.)</p>",
        "id": 164559455,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1556646576
    },
    {
        "content": "<p>Proving the derivative of exp is exp is not something we can currently do, right?</p>",
        "id": 164561941,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556648224
    },
    {
        "content": "<p>We need that a power series can be differentiated term by term</p>",
        "id": 164561960,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556648239
    },
    {
        "content": "<p>we don't know that</p>",
        "id": 164561977,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556648253
    },
    {
        "content": "<p>that's just comparison test</p>",
        "id": 164561999,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1556648268
    },
    {
        "content": "<p>Why doesn't someone do it if it's easy? We have done so much algebra. We need some analysts!</p>",
        "id": 164562192,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556648358
    },
    {
        "content": "<p>we have basic exp inequalities already, right? so that's not needed</p>",
        "id": 164563054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1556648847
    },
    {
        "content": "<p>In this case you need that <code>exp x - 1 - x</code> is O(x^2)</p>",
        "id": 164563090,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1556648875
    },
    {
        "content": "<p><code>library_search</code> works extremely well most of the time (many thanks for this). However, I just got the following strange behavior</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">continuous_at</span><span class=\"bp\">.</span><span class=\"n\">preimage_mem_nhds</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">continuous_at</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"err\">‚àà</span> <span class=\"n\">nhds</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">‚Åª¬π</span><span class=\"err\">&#39;</span> <span class=\"n\">s</span> <span class=\"err\">‚àà</span> <span class=\"n\">nhds</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">library_search</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>the output of <code>library_search</code> is <code>exact mem_def.mpr (h s hs)</code>, which does not work. It should be <code>exact mem_def.mpr (h hs)</code> (or simply <code>exact h hs</code>).</p>",
        "id": 166112089,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1558380189
    },
    {
        "content": "<p>Is it because <code>s</code> should be an implicit argument?</p>",
        "id": 166112350,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1558380377
    },
    {
        "content": "<p>It's complicated to say: there is a lot of nontrivial unfolding to be done.</p>",
        "id": 166113191,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1558381020
    },
    {
        "content": "<p>You can see the function type of <code>h</code> by putting this into your proof script:</p>\n<div class=\"codehilite\"><pre><span></span>   <span class=\"n\">do</span> <span class=\"o\">{</span> <span class=\"n\">get_local</span> <span class=\"bp\">`</span><span class=\"n\">h</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">infer_type</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">whnf</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">trace</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 166113773,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1558381428
    },
    {
        "content": "<p>(don't forget to <code>open tactic</code>)</p>",
        "id": 166113782,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1558381439
    },
    {
        "content": "<p>semi-implicit argument: <code>‚àÄ ‚¶Éa : set Œ≤‚¶Ñ, a ‚àà (nhds (f x)).sets ‚Üí a ‚àà (filter.map f (nhds x)).sets</code></p>",
        "id": 166114441,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1558381878
    },
    {
        "content": "<p>How would you prove</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">no_way</span> <span class=\"o\">{</span><span class=\"err\">ùïú</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_field</span> <span class=\"err\">ùïú</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"err\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"err\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"err\">ùïú</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"err\">ùïú</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f&#39;</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">‚Üí</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"err\">ùïú</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f&#39;</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">continuous_linear_map</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"bp\">=</span> <span class=\"n\">f&#39;</span> <span class=\"o\">:=</span>\n</pre></div>\n\n\n<p><code>by simp</code> doesn't work (obvious gap in the library that I will fill right away), so I tried <code>library_search</code>. It worked, giving me the following proof...</p>",
        "id": 182051592,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1574883251
    },
    {
        "content": "<p>... <code>exact neg_inj rfl</code></p>",
        "id": 182051612,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1574883273
    },
    {
        "content": "<p>where <code>neg_inj</code> is</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">neg_inj</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">add_group</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">},</span> <span class=\"bp\">-</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">b</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n</pre></div>\n\n\n<p>Lean is way too clever for me here to see a relationship between the question I ask and the answer I get.</p>",
        "id": 182051691,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1574883357
    },
    {
        "content": "<p>Indeed, <code>- f'.comp continuous_linear_map.id = - f'</code>is <code>rfl</code>, but <code>f'.comp continuous_linear_map.id = f'</code>is not...</p>",
        "id": 182051922,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1574883496
    },
    {
        "content": "<p><code>cases f'; refl</code> or <code>ext; refl</code>?</p>",
        "id": 182052031,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1574883592
    },
    {
        "content": "<p>Yes, the natural proof I would use is <code>ext, refl</code>, and it works fine. I was just amazed by the answer of <code>library_search</code>.</p>",
        "id": 182052544,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1574883957
    },
    {
        "content": "<p>Isn't it nice that Lean is getting clever? That's what all the mathematicians want, right?</p>",
        "id": 182057496,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1574887757
    },
    {
        "content": "<p>This is one of the strange artifacts from Lean not having the definitional eta rule for structures. The eta rule for (say) products states that <code>x : prod A B</code> is definitionally equal to <code>(x.1, x.2)</code>. A rule like this makes sense. After all, the first and second projections of both <code>x</code> and <code>(x.1, x.2)</code> are already definitionally equal in Lean, so it makes sense to say that they are definitionally equal. </p>\n<p>In your case you have again two structures, where all projections are definitionally equal. This means that if you perform any transformation on both the LHS and the RHS that only take projections into account (like <code>neg</code>), you get something definitionally equal, which is why the proof that <code>library_search</code> found works.</p>\n<p>Originally the reason that Lean didn't get this rule was that the developers saw no compelling reason to add it. A while later I stated some (IMO) compelling reasons, but it never got added.</p>",
        "id": 182057748,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1574888006
    },
    {
        "content": "<p>This behavior of product never ceases to catch me by surprise.</p>",
        "id": 182057836,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1574888071
    },
    {
        "content": "<p>Even if you added this rule for structures, I guess it would not ensure that <code>id</code> and <code>lambda x, (x.1, x.2)</code> are defeq, right? (in manifolds, it would have helped me a lot if this had been true).</p>",
        "id": 182058493,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1574888689
    },
    {
        "content": "<p>I think it is the first time I understand what this eta rule for structures is. Thanks! Now I just need to understand alpha, beta, gamma, delta, and how many others do you have?</p>",
        "id": 182058910,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1574889037
    },
    {
        "content": "<p>Ooh, and then there are Y and S and K combinators, in case you get bored....</p>",
        "id": 182058933,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1574889087
    },
    {
        "content": "<p>I learnt about these alpha beta things when I was trying to get automation working in the definition of the complex numbers</p>",
        "id": 182060049,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1574890073
    },
    {
        "content": "<p>All proofs of eg associativity of multiplication are \"check on real and imaginary parts\" so it was precisely these projections in a very concrete situation</p>",
        "id": 182060126,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1574890128
    },
    {
        "content": "<p>Here is a cheat sheet:</p>\n<div class=\"codehilite\"><pre><span></span>Œ±-equivalence: Œª x, f x ‚â° Œª y, f y\nŒ≤-reduction: (Œª x, f x) a ‚â° f a\nŒ¥-reduction: id ‚â° Œª {Œ± : Sort*} (x : Œ±), x (i.e. unfold a definition)\nŒ∑-reduction: Œª x, f x ‚â° f (Œ∑-expansion is in the other direction)\nŒπ-reduction: nat.rec P‚ÇÄ P‚Çõ 0 ‚â° P‚ÇÄ and nat.rec P‚ÇÄ P‚Çõ n.succ ‚â° P‚Çõ n (nat.rec P‚ÇÄ P‚Çõ n)\nŒ∂-reduction: (let x := a in f x) ‚â° f a\nŒ≤-reduction (for records): (x, y).1 ‚â° x and (x, y).2 ‚â° y\nŒ∑-reduction (for records): (x.1, x.2) ‚â° x\n</pre></div>\n\n\n<p>all reduction rules are directed (from left to right), but if you take the congruence closure (that is, the smallest equivalence relation that respects all ways to make a term), you get the corresponding equivalence. \"Definitional equality\" is the smallest congruence closure containing all of the above relations (except Œ∑-reduction for records).</p>",
        "id": 182061967,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1574891829
    },
    {
        "content": "<p>Usually they are written a bit differently, using substitution instead of function application, but that will probably be more confusing. But just to be clear: something like <code>Œ≤</code>-reduction also applies if the term inside the lambda is not a application - so something like <code>(Œª x, x) a ‚â° a</code> is an instance of <code>Œ≤</code>-reduction</p>",
        "id": 182062071,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1574891915
    },
    {
        "content": "<p>Why do the two <code>eta</code>s and <code>beta</code>s have the same name? Isn't the second <code>beta</code> just a combination of <code>delta</code> and <code>iota</code>?</p>",
        "id": 182063842,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1574893521
    },
    {
        "content": "<p>If you view the projections as primitive, they are different</p>",
        "id": 182065296,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1574894796
    },
    {
        "content": "<p>Yes, the second <code>beta</code> is indeed a combination of <code>delta</code> and <code>iota</code> in Lean. This is because products are defined as a inductive type. If records are primitive (not special cases of inductive types) then it could be its own rule.</p>\n<p>Sometimes <code>Œπ</code>-reduction is also called \"<code>Œ≤</code>-reduction for inductive types\". To explain this terminology, we have to take a step back.<br>\nIn type theory, to each type former, there is a number of rules associated to it. I will explain these rules by using the natural numbers as an example.</p>\n<ul>\n<li>(Type) formation rules: when can I form this type? For natural numbers, we have <code>nat : Type</code></li>\n<li>(Term) introduction rules: when can I form an element of this type? For natural numbers: <code>0 : nat</code> and if <code>n : nat</code> then <code>n.succ : nat</code></li>\n<li>(Term) elimination rules: how can I eliminate out of this type? For natural numbers this is <code>nat.rec</code>.</li>\n<li>Then there are computation rules. These have two flavors<p>- What happens if I apply an elimination rule to an introduction rule? In general, this is sometimes called <code>beta</code>-reduction (since it corresponds to <code>beta</code>-reduction when talking about functions). For natural numbers, these are the <code>iota</code>-reduction rules mentioned above.<br>\n- What happens if I apply an introduction rule to an elimination rule? These are called <code>eta</code>-conversion rules. The natural numbers don't really have them (I think you can write something like an eta-rule down, but it's not that useful). For functions and products, it's the eta rule I mentioned above.</p>\n</li>\n</ul>\n<p>This is the reason that different rules have the name <code>beta</code>/<code>eta</code>-reductions: they are the corresponding reduction rules for those type formers.</p>",
        "id": 182065700,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1574895214
    },
    {
        "content": "<p>If you want more information than my summary, you can look e.g. here: <a href=\"https://ncatlab.org/nlab/show/type+theory#Syntax\" target=\"_blank\" title=\"https://ncatlab.org/nlab/show/type+theory#Syntax\">https://ncatlab.org/nlab/show/type+theory#Syntax</a></p>",
        "id": 182065761,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1574895268
    },
    {
        "content": "<p>Just for comparison, Agda has definitional eta for <em>some</em> structures. Some termination (for coinductive structures, so not very relevant) and performance (even for pairs, unsolved?) issues are documented at <a href=\"https://github.com/agda/agda/issues/2436\" target=\"_blank\" title=\"https://github.com/agda/agda/issues/2436\">https://github.com/agda/agda/issues/2436</a>.</p>",
        "id": 182105414,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1574945018
    },
    {
        "content": "<p>Coq also has opt-in definitional eta for structures.</p>",
        "id": 182117322,
        "sender_full_name": "Reid Barton",
        "timestamp": 1574954931
    },
    {
        "content": "<p>Does library_search check for every possible paranthetic nesting structure of the hypothesis? Or just superficial combinations and repetitions?</p>",
        "id": 183284849,
        "sender_full_name": "Abhimanyu Pallavi Sudhir",
        "timestamp": 1576174086
    },
    {
        "content": "<p>I don't think it does anything with associativity, if that is what you mean. The goal has to match perfectly.</p>",
        "id": 183285547,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1576174576
    },
    {
        "content": "<p>I mean, if we have hypothesis H1 H2 H3 and goal G, and we have a library theorem L such that L (H1 H2) H3 = G, will the tactic find L?</p>",
        "id": 183285788,
        "sender_full_name": "Abhimanyu Pallavi Sudhir",
        "timestamp": 1576174775
    },
    {
        "content": "<p>Yes.</p>",
        "id": 183286048,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1576174930
    },
    {
        "content": "<p>Or maybe I don't understand the question.</p>",
        "id": 183286096,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1576174959
    },
    {
        "content": "<p>I'm actually not sure if <code>library_search</code> will close that. <code>suggest</code> hopefully will do it. But as far as I know <code>library_search</code> only tries to close the immediate hypotheses of <code>L</code> with existing hypotheses in your context. There is no recursion.</p>",
        "id": 183289794,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1576177088
    },
    {
        "content": "<p><code>suggest</code> wouldn't close the goal either, but would hopefully suggest <code>refine L _ H3</code>. And after that <code>suggest</code> and <code>library_search</code> should both close the goal via <code>solve_by_elim</code></p>",
        "id": 183289883,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1576177147
    },
    {
        "content": "<p>I am always amazed by library_search. I thought it was only supposed to try to apply all lemmas in the library, filling them with things in the context. But look at what happens in the following situation:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">card</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">(</span><span class=\"n\">ordered_partition2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">let</span> <span class=\"o\">:</span> <span class=\"n\">ordered_partition2</span> <span class=\"n\">n</span> <span class=\"err\">‚âÉ</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">order_partition2_equiv</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">library_search</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>I wanted to get the name of the lemma saying that if one has an equiv between two fintypes they have the same cardinal, so I asked <code>library_search</code> in my context. Its answer is:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">Try</span> <span class=\"n\">this</span><span class=\"o\">:</span> <span class=\"n\">exact</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">length_map</span>\n  <span class=\"err\">‚áë</span><span class=\"o\">{</span><span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"err\">‚áë</span><span class=\"o\">(</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">order_partition2_equiv</span> <span class=\"n\">n</span><span class=\"o\">)),</span>\n     <span class=\"n\">inj</span> <span class=\"o\">:=</span> <span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">of_bijective</span><span class=\"bp\">._</span><span class=\"n\">proof_1</span> <span class=\"err\">‚áë</span><span class=\"o\">(</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">order_partition2_equiv</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n              <span class=\"o\">(</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">bijective</span> <span class=\"o\">(</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">order_partition2_equiv</span> <span class=\"n\">n</span><span class=\"o\">)))}</span>\n  <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">pmap</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">powerset_aux</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">fin_range</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"bp\">._</span><span class=\"n\">proof_1</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"o\">))</span>\n</pre></div>\n\n\n<p>and it works perfectly well :) (Still, I will rather go with <code>exact fintype.card_congr this</code>)</p>",
        "id": 189430252,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1583062625
    },
    {
        "content": "<p>I think it unfolded some proof in the library to get that</p>",
        "id": 189431733,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583065612
    },
    {
        "content": "<p>plagiarization!</p>",
        "id": 189431842,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1583065889
    },
    {
        "content": "<p>I don't know what <code>order_partition2</code> is so I can't completely reverse engineer it but the last bit, <code>list.pmap finset.mk ...</code> is the list that results if you ask what list enumerates <code>finset.powerset (@finset.univ (fin (n-1)))</code></p>",
        "id": 189431893,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583065982
    },
    {
        "content": "<p><code>order_partition2 n</code> is a structure, defined as</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">ordered_partition2</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">boundaries</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">zero_mem</span>   <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span> <span class=\"err\">‚àà</span> <span class=\"n\">boundaries</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">last_mem</span>   <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span><span class=\"bp\">.</span><span class=\"n\">last</span> <span class=\"n\">n</span> <span class=\"err\">‚àà</span> <span class=\"n\">boundaries</span><span class=\"o\">))</span>\n</pre></div>\n\n\n<p>I constructed an equiv between this and <code>finset (fin (n-1))</code> (the one that is used in the proof). So, I am not surprised that an enumeration of the powerset of <code>fin (n-1)</code> shows up in the proof found by <code>library_search</code>.</p>\n<p>On an unrelated note, I was surprised that I could not prove that this is a <code>fintype</code> directly. Even</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">my_struct</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">my_finset</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">my_struct</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n</pre></div>\n\n\n<p>fails...</p>",
        "id": 189432036,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1583066301
    },
    {
        "content": "<p>While</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">inst2</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n</pre></div>\n\n\n<p>works, of course.</p>",
        "id": 189432044,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1583066380
    },
    {
        "content": "<p>There is no tactic for proving arbitrary inductive types to be finite. (I think <span class=\"user-mention\" data-user-id=\"110865\">@Jeremy Avigad</span> was working on something like this...) You have to manually cobble together the constructions in <code>fintype.lean</code></p>",
        "id": 189432088,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583066445
    },
    {
        "content": "<p>Certainly <code>apply_instance</code> will not work, there is no typeclass instance to find</p>",
        "id": 189432093,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583066489
    },
    {
        "content": "<p>Conceivably it might work with a hypothetical <code>@[derive fintype]</code> on the definition of <code>order_partition2</code></p>",
        "id": 189432133,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583066536
    },
    {
        "content": "<p>But if you just use the existing constructors instead of defining a new type, typeclass inference works fine:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">{</span>\n  <span class=\"n\">boundaries</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span> <span class=\"bp\">//</span>\n  <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span> <span class=\"err\">‚àà</span> <span class=\"n\">boundaries</span> <span class=\"bp\">‚àß</span>\n  <span class=\"o\">(</span><span class=\"n\">fin</span><span class=\"bp\">.</span><span class=\"n\">last</span> <span class=\"n\">n</span> <span class=\"err\">‚àà</span> <span class=\"n\">boundaries</span><span class=\"o\">)}</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n</pre></div>",
        "id": 189432196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583066757
    },
    {
        "content": "<p>and that is also the easiest method of proof:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">ordered_partition2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">of_equiv</span> <span class=\"o\">{</span><span class=\"n\">boundaries</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span> <span class=\"bp\">//</span>\n  <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span> <span class=\"err\">‚àà</span> <span class=\"n\">boundaries</span> <span class=\"bp\">‚àß</span> <span class=\"o\">(</span><span class=\"n\">fin</span><span class=\"bp\">.</span><span class=\"n\">last</span> <span class=\"n\">n</span> <span class=\"err\">‚àà</span> <span class=\"n\">boundaries</span><span class=\"o\">)}</span>\n<span class=\"bp\">‚ü®Œª</span> <span class=\"bp\">‚ü®</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"bp\">‚ü©</span><span class=\"o\">,</span> <span class=\"bp\">‚ü®</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"bp\">‚ü©</span><span class=\"o\">,</span> <span class=\"bp\">Œª</span> <span class=\"bp\">‚ü®</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"bp\">‚ü©</span><span class=\"o\">,</span> <span class=\"bp\">‚ü®</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"bp\">‚ü©</span><span class=\"o\">,</span> <span class=\"bp\">Œª</span> <span class=\"bp\">‚ü®</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"bp\">‚ü©</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">Œª</span> <span class=\"bp\">‚ü®</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"bp\">‚ü©</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">‚ü©</span>\n</pre></div>",
        "id": 189432293,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583066955
    },
    {
        "content": "<p>Sure, I know how to do it with a subtype. But since I need the exact cardinality, I have anyway to construct the equiv with <code>fin (n-1)</code>. I was just surprised the <code>fintype</code> instance didn't work out of the box, because in general almost everything works out of the box!</p>",
        "id": 189433113,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1583068742
    },
    {
        "content": "<p>Well, my point is that as you wrote it it's impossible to have anything work out of the box unless you go into lean to change how the <code>structure</code> command works. You would have to put a <code>@[derive fintype]</code> annotation or trigger a tactic by some similar method... and someone would have to write that tactic</p>",
        "id": 189435049,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583072796
    },
    {
        "content": "<p>No, I am not working on tactics for inductive types. What Mario is thinking of is this: there is a general strategy for showing finitely branching inductive types are encodable: <a href=\"https://github.com/leanprover-community/mathlib/blob/master/archive/examples/prop_encodable.lean\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/archive/examples/prop_encodable.lean\">https://github.com/leanprover-community/mathlib/blob/master/archive/examples/prop_encodable.lean</a>. There is a lot of boilerplate involved, but that sort of thing can also be automated. (But I am not planning to do it.)</p>",
        "id": 189445654,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1583092980
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> Where do you use <code>ordered_partition2</code>?</p>",
        "id": 189458109,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1583115187
    },
    {
        "content": "<p>I am working on analytic functions (in good generality, i.e., possibly on Banach spaces). These are the functions that have locally an expansion <code>f(x + h) = \\Sigma_n f_n(h, ..., h)</code> where <code>f_n</code> is a continuous <code>n</code>-multilinear map. To show that the composition of analytic functions is analytic, you need to write the composition of two such things as a series of multilinear maps, which is kind of dirty. I use <code>ordered_partition2</code> there.</p>",
        "id": 189467369,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1583132038
    },
    {
        "content": "<p>I would like to personally thank <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> for creating this incredibly useful <code>library_search</code> tactic (and others who contributed to this tactic).</p>",
        "id": 193433100,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1586428962
    },
    {
        "content": "<p>I typed:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">exists_one_div</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÉ</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ñï</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">r</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">library_search</span>\n</pre></div>\n\n\n<p>and then I found exactly the name of the lemma <code>exists_nat_one_div_lt</code> that I couldn't find by trying <code>real.exists_</code> and other <code>real.</code> prefixes</p>",
        "id": 193433229,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1586429061
    },
    {
        "content": "<p>You're welcome. I really should get back to work on it; I think it easily could be better still.</p>",
        "id": 193433560,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1586429287
    },
    {
        "content": "<p>I am surprised that <code>library_search</code> fails on that one:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">analytic</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ennreal</span><span class=\"o\">)</span> <span class=\"bp\">‚â§</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"c1\">-- library_search!, fails</span>\n  <span class=\"n\">exact</span> <span class=\"n\">zero_le</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> , does it look normal to you?</p>",
        "id": 203705340,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1594641262
    },
    {
        "content": "<p>Nope, that sounds like a bug!</p>",
        "id": 203705355,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1594641286
    },
    {
        "content": "<p>It seems that something is broken currently with library_search. Here is another example where it doesn't work:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">analytic</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">Ioo</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"c1\">-- library_search!,  -- fails</span>\n  <span class=\"n\">exact</span> <span class=\"n\">is_open_Ioo</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>It turns out that it fails for essentially all one-liners like this in the manifold exercises for Friday. It is not a real problem, though, because we have a wonderful naming convention, and people should get used to it sooner than later :-)</p>",
        "id": 203925426,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1594799558
    },
    {
        "content": "<p>This one looks like the apply bug, and potentially the one above as well</p>",
        "id": 203943262,
        "sender_full_name": "Reid Barton",
        "timestamp": 1594812807
    },
    {
        "content": "<p>indeed</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"o\">{</span> <span class=\"n\">le</span>          <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">o‚ÇÅ</span> <span class=\"n\">o‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">a</span> <span class=\"err\">‚àà</span> <span class=\"n\">o‚ÇÇ</span><span class=\"o\">,</span> <span class=\"bp\">‚àÉ</span> <span class=\"n\">b</span> <span class=\"err\">‚àà</span> <span class=\"n\">o‚ÇÅ</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">‚â§</span> <span class=\"n\">a</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 203943342,
        "sender_full_name": "Reid Barton",
        "timestamp": 1594812855
    },
    {
        "content": "<p>Here is another bug report from Kevin's breakout room, this time regarding <code>library_search</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">metric_space</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"n\">filter</span> <span class=\"n\">topological_space</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">lftcm</span>\n<span class=\"kn\">open</span> <span class=\"n\">filter</span> <span class=\"n\">set</span>\n\n<span class=\"n\">def</span> <span class=\"n\">at_top</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"bp\">‚Ñï</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">sets</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"bp\">‚àÉ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">‚â§</span> <span class=\"n\">b</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">b</span> <span class=\"err\">‚àà</span> <span class=\"n\">s</span><span class=\"o\">},</span>\n  <span class=\"n\">univ_sets</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n    <span class=\"n\">sorry</span>\n  <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">sets_of_superset</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n    <span class=\"n\">rintros</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">‚ü®</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"bp\">‚ü©</span> <span class=\"n\">hxy</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">b</span> <span class=\"n\">hb</span><span class=\"o\">,</span>\n    <span class=\"n\">library_search</span>\n  <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">inter_sets</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n    <span class=\"n\">sorry</span>\n  <span class=\"kn\">end</span><span class=\"o\">}</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">lftcm</span>\n</code></pre></div>\n\n\n<p>Lean suggests <code>exact hxy b (ha b hb)</code> which doesn't work (removing the b makes it work).</p>",
        "id": 204187893,
        "sender_full_name": "Julian K√ºlshammer",
        "timestamp": 1594978935
    },
    {
        "content": "<p>This was just discovered in exactly the same context :) <a href=\"https://github.com/leanprover-community/mathlib/issues/3422\">#3422</a></p>",
        "id": 204187951,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1594978980
    },
    {
        "content": "<p>Is this the same bug as <a href=\"https://github.com/leanprover-community/mathlib/issues/3093\">#3093</a>?</p>",
        "id": 204188124,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1594979106
    },
    {
        "content": "<p>Oh, yes, I'm pretty sure it is!</p>",
        "id": 204188232,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1594979170
    },
    {
        "content": "<p>As far as I can see, It's because \\subseteq unfolds to <code>\\forall {{a}}, ...</code> and <code>library_search</code> inserts the variable but Lean doesn't want it</p>",
        "id": 204191805,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594982440
    },
    {
        "content": "<p>Aah yes I see now that this has been well diagnosed</p>",
        "id": 204191853,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594982510
    },
    {
        "content": "<p>Now I don't think the bug is in <code>library_search</code>. Here's an example which doesn't use <code>library_search</code> which I think does the same thing for this goal.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">interactive</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">st</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">do</span>\n  <span class=\"n\">g</span> <span class=\"err\">‚Üê</span> <span class=\"n\">get_goals</span><span class=\"o\">,</span>\n  <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">solve_by_elim</span><span class=\"o\">,</span>\n  <span class=\"n\">trace</span> <span class=\"n\">g</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">interactive</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">‚àà</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hst</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"err\">‚äÜ</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">‚àà</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">st</span> <span class=\"c1\">-- Output: [hst a ha]</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 204195107,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1594985190
    },
    {
        "content": "<p>This also has the same behaviour (and the same if <code>tauto</code> is replaced by <code>solve_by_elim</code>)</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">‚àà</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hst</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"err\">‚äÜ</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">‚àà</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">show_term</span> <span class=\"o\">{</span> <span class=\"n\">tauto</span> <span class=\"o\">}</span> <span class=\"c1\">-- exact hst a ha</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 204195244,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1594985321
    },
    {
        "content": "<p>and the same even if I provide the term to use with <code>exact</code></p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">‚àà</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hst</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"err\">‚äÜ</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">‚àà</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">show_term</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">hst</span> <span class=\"n\">ha</span> <span class=\"o\">}</span> <span class=\"c1\">-- exact hst a ha</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 204195778,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1594985806
    },
    {
        "content": "<p>in fact, this works without any mathlib imports, so it's probably an issue in core Lean</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">st</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">do</span>\n  <span class=\"n\">g</span> <span class=\"bp\">::</span> <span class=\"bp\">_</span> <span class=\"err\">‚Üê</span> <span class=\"n\">get_goals</span><span class=\"o\">,</span>\n  <span class=\"n\">e</span> <span class=\"err\">‚Üê</span> <span class=\"n\">to_expr</span> <span class=\"bp\">```</span><span class=\"o\">(</span><span class=\"n\">hst</span> <span class=\"n\">ha</span><span class=\"o\">),</span>\n  <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">exact</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n  <span class=\"n\">trace</span> <span class=\"n\">g</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">‚àà</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hst</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"err\">‚äÜ</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">‚àà</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">st</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 204195917,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1594985923
    },
    {
        "content": "<p>Yes, I think Gabriel saw this in <a href=\"https://github.com/leanprover-community/mathlib/issues/3093\">#3093</a>:</p>\n<blockquote>\n<p>This looks like a bug in the pretty-printer, which apparently prints <code>hst ha</code> incorrectly. </p>\n</blockquote>\n<p>The pretty printer affects everything you've shown and is part of the Lean system.</p>",
        "id": 204196108,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1594986106
    },
    {
        "content": "<p>So should I close the mathlib issue and make one in leanprover-community/lean instead?</p>",
        "id": 204196177,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1594986162
    },
    {
        "content": "<p>Definitely make an issue in the lean repo and link the mathlib one! But I think you can leave the mathlib one open.</p>",
        "id": 204196207,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1594986203
    },
    {
        "content": "<p>Since library_search is where this bug will appear most often.</p>",
        "id": 204196220,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1594986217
    },
    {
        "content": "<p>I think github lets you move issues between repos in the same org</p>",
        "id": 204220850,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1595000168
    },
    {
        "content": "<p>Lean learner here, how do I write my claim and do a library search in the middle of a proof? currently, I write my claim as a separate lemma and it feels too verbose.</p>",
        "id": 307835572,
        "sender_full_name": "Siyuan Yan",
        "timestamp": 1667508313
    },
    {
        "content": "<p>have : X := by library_search</p>",
        "id": 307836291,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1667508566
    },
    {
        "content": "<p>that's cool thanks!</p>",
        "id": 307837957,
        "sender_full_name": "Siyuan Yan",
        "timestamp": 1667509123
    },
    {
        "content": "<p>You can also write stuff like <code>specialize foo x (by library_search)</code> or <code>convert_to foo bar baz, library_search</code> in the middle of your proof.</p>",
        "id": 307844920,
        "sender_full_name": "Martin Dvo≈ô√°k",
        "timestamp": 1667511747
    }
]
[
    {
        "content": "<p>In the following snippet</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.subgroup.basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">k</span><span class=\"o\">},</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">neg_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"bp\">*</span><span class=\"n\">k</span><span class=\"o\">},</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">neg_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">H</span> <span class=\"bp\">≤</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">x_in</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"bp\">*</span><span class=\"n\">k</span> <span class=\"n\">at</span> <span class=\"n\">x_in</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">k</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>what is the idiomatic way to get to this proof state without manually writing the two <code>change</code>  lines? Using <code>dsimp [G, H] at *</code> brings the awful goal</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"bp\">∈</span>\n  <span class=\"o\">{</span><span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">k</span><span class=\"o\">},</span>\n   <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"n\">G._proof_1</span><span class=\"o\">,</span>\n   <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"n\">G._proof_2</span><span class=\"o\">,</span>\n   <span class=\"n\">neg_mem'</span> <span class=\"o\">:=</span> <span class=\"n\">G._proof_3</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 255854392,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633164524
    },
    {
        "content": "<p>There is a <code>add_subgroup.mem_mk</code> lemma missing.</p>",
        "id": 255854594,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1633164729
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.subgroup.basic</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">add_subgroup.mem_mk</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">g</span> <span class=\"bp\">∈</span> <span class=\"n\">add_subgroup.mk</span> <span class=\"n\">s</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"n\">h3</span> <span class=\"bp\">↔</span> <span class=\"n\">g</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">k</span><span class=\"o\">},</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">neg_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"bp\">*</span><span class=\"n\">k</span><span class=\"o\">},</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">neg_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">H</span> <span class=\"bp\">≤</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">x_in</span><span class=\"o\">,</span>\n  <span class=\"n\">squeeze_simp</span> <span class=\"o\">[</span><span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">x_in</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- Try this: simp only [H, G, add_subgroup.mem_mk, set.mem_set_of_eq] at x_in ⊢</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 255855328,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1633165515
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp, to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">subgroup.mem_mk</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h_one</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_inv</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">subgroup.mk</span> <span class=\"n\">s</span> <span class=\"n\">h_one</span> <span class=\"n\">h_mul</span> <span class=\"n\">h_inv</span>  <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"n\">iff.rfl</span>\n</code></pre></div>",
        "id": 255855334,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633165523
    },
    {
        "content": "<p>I didn't dare not writing the assumptions <span aria-label=\"flushed\" class=\"emoji emoji-1f633\" role=\"img\" title=\"flushed\">:flushed:</span></p>",
        "id": 255855351,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633165551
    },
    {
        "content": "<p>Next question is whether this should be a more general lemma involving <code>set_like</code></p>",
        "id": 255855405,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633165581
    },
    {
        "content": "<p>Hmm, that would be nice. But I don't know how to do that</p>",
        "id": 255855419,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1633165607
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span></p>",
        "id": 255855539,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633165745
    },
    {
        "content": "<p>Unless Eric has a better idea, I'll soon PR</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.subgroup.basic</span>\n\n<span class=\"kd\">@[simp, to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">subgroup.mem_mk</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h_one</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_mul</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_inv</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">subgroup.mk</span> <span class=\"n\">s</span> <span class=\"n\">h_one</span> <span class=\"n\">h_mul</span> <span class=\"n\">h_inv</span>  <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">@[simp, to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">subgroup.mk_le_mk</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h_one</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_mul</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_inv</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_one'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_mul'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_inv'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">subgroup.mk</span> <span class=\"n\">s</span> <span class=\"n\">h_one</span> <span class=\"n\">h_mul</span> <span class=\"n\">h_inv</span> <span class=\"bp\">≤</span> <span class=\"n\">subgroup.mk</span> <span class=\"n\">t</span> <span class=\"n\">h_one'</span> <span class=\"n\">h_mul'</span> <span class=\"n\">h_inv'</span>  <span class=\"bp\">↔</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">set_like.le_def</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>but I'm not sure I'll have courage to PR all variations for bundled subobjects</p>",
        "id": 255855792,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633166032
    },
    {
        "content": "<p>There's no way to generalize I can think of</p>",
        "id": 255856791,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633167097
    },
    {
        "content": "<p>Does iff.rfl prove that second one?</p>",
        "id": 255856848,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633167131
    },
    {
        "content": "<p>Actually it does. I didn't in the beginning but I think I slightly changed the statement after trying</p>",
        "id": 255856991,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633167270
    },
    {
        "content": "<p>Another option would be to have separate <code>mk_le</code> and <code>le_mk</code> lemmas, which might close more goals</p>",
        "id": 255857265,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633167545
    },
    {
        "content": "<p>But they might also make things more awkward for other cases</p>",
        "id": 255857413,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633167700
    }
]
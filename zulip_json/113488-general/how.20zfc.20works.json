[
    {
        "content": "<p>well people keep talking about zfc... and I've read the axioms but I still can't understand how it models mathematics... any resources? thanks in advance</p>",
        "id": 245169288,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625659848
    },
    {
        "content": "<p>from my perspective, ZFC is like a dystopian world where people are only allowed to talk about sets and discussions about other things are only allowed if they can be described in terms of sets... but my idea of the ZFC world is still very vague...</p>",
        "id": 245169558,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625660028
    },
    {
        "content": "<p>You could just as well say the same thing about type theory if you replace \"sets\" with \"types\"</p>",
        "id": 245170782,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625660696
    },
    {
        "content": "<p>Sets are the primitive notion in ZFC. They have no definition, they just are axiomatized to have certain properties that amount to \"there are enough sets for anything you could ever need\"</p>",
        "id": 245170835,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625660745
    },
    {
        "content": "<p>and then you just build whatever notions you need with that as the substrate. You very quickly stop thinking in terms of sets because that's not the topic of discussion, in the same way that we don't make a big deal about how mathematics is made of words</p>",
        "id": 245170992,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625660832
    },
    {
        "content": "<p>so... I have a more concrete question now. the axiom of infinity asserts that there is a set that contains every natural number in the von Neumann encoding and possibly other garbage elements... how can I extract the set of natural numbers from the axiom of infinity then? and how can I prove that induction holds?</p>",
        "id": 245176602,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625663441
    },
    {
        "content": "<p>the set of natural numbers is itself a natural number right?</p>",
        "id": 245176778,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625663525
    },
    {
        "content": "<p>and its name is omega or aleph null...</p>",
        "id": 245176854,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625663567
    },
    {
        "content": "<p>omega isn't a natural number it's an ordinal</p>",
        "id": 245176870,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1625663577
    },
    {
        "content": "<p>you can probably make up some predicate to extract the non-junk, i'd go for something like (off the top of my head, not guaranteeing correctness):</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>x</mi><mo>∈</mo><mi>X</mi><mtext> </mtext><mi mathvariant=\"normal\">∣</mi><mtext> </mtext><mi mathvariant=\"normal\">∀</mi><mi>s</mi><mo>∈</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>s</mi><mo>∈</mo><mi>X</mi><mo>∧</mo><mi mathvariant=\"normal\">∀</mi><mi>s</mi><mi>t</mi><mo>∈</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>s</mi><mo>=</mo><mi>t</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\"> \\{  x \\in X\\ |\\ \\forall s \\in x, s \\in X \\land \\forall s t \\in x, s = t \\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\"> </span><span class=\"mord\">∣</span><span class=\"mspace\"> </span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7335400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.73354em;vertical-align:-0.0391em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">}</span></span></span></span></p>",
        "id": 245177107,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1625663668
    },
    {
        "content": "<p>I don't think that works, you are defining all the singleton subsets of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> but that might not be countable if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> is some arbitrary infinite set</p>",
        "id": 245178051,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625664121
    },
    {
        "content": "<p>what other singleton subsets can there be? any non-finite ones are ruled out by regularity, no? or am I missing something</p>",
        "id": 245178207,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1625664181
    },
    {
        "content": "<p>The usual approach is to define what it means for a set to be \"inductive\", i.e. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>∈</mo><mi>X</mi><mo>∧</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo>∈</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>S</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>∈</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">0\\in X\\wedge (\\forall x\\in X, S(x)\\in X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68354em;vertical-align:-0.0391em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span> (the axiom of infinity asserts that an inductive set exists), and then you take the intersection of all inductive sets to get <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span> (which exists because it is a subset of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>)</p>",
        "id": 245178320,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625664235
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span> is in fact not composed of singleton sets</p>",
        "id": 245178384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625664254
    },
    {
        "content": "<p>I see, big oops then</p>",
        "id": 245178444,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1625664282
    },
    {
        "content": "<p>that explains why I'm so confused by the predicate</p>",
        "id": 245178456,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625664288
    },
    {
        "content": "<p><span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 245178485,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625664293
    },
    {
        "content": "<p>If I recall correctly, you also need to do this to get the power set from the power set axiom.</p>",
        "id": 245178605,
        "sender_full_name": "Jason Rute",
        "timestamp": 1625664338
    },
    {
        "content": "<p>and the union axiom. It's a common trick to simplify all the axioms to unidirectional versions in the presence of the subset axiom</p>",
        "id": 245178738,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625664382
    },
    {
        "content": "<p>does it work for Zermelo ordinals Mario? that's what I was thinking of, not the VN ones</p>",
        "id": 245178777,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1625664402
    },
    {
        "content": "<p>ahh I see what I've done, I've created a horrific mixture of both</p>",
        "id": 245178860,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1625664442
    },
    {
        "content": "<p>that's terrifying and bad</p>",
        "id": 245178867,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1625664445
    },
    {
        "content": "<p>It depends on how the axiom of infinity is stated. The usual statement contains an explicit reference to VN successor</p>",
        "id": 245178885,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625664454
    },
    {
        "content": "<p>but if you swapped it out for a zermelo successor then you could do the same thing with zermelo ordinals</p>",
        "id": 245178994,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625664488
    },
    {
        "content": "<p>wait, that's confusing. how can the axiom of infinity be stated with zermelo ordinals then?</p>",
        "id": 245179488,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625664689
    },
    {
        "content": "<p>and can that be shown to be equivalent to the VN version</p>",
        "id": 245179546,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625664712
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"270523\">Huỳnh Trần Khanh</span> <a href=\"#narrow/stream/113488-general/topic/how.20zfc.20works/near/245176602\">said</a>:</p>\n<blockquote>\n<p>and how can I prove that induction holds?</p>\n</blockquote>\n<p>Given the intersection definition of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span>, the induction theorem falls out naturally. If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mclose\">)</span></span></span></span> holds and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mi>S</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\forall x,(P(x)\\to P(S(x)))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)))</span></span></span></span>, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>x</mi><mo>∈</mo><mi>ω</mi><mi mathvariant=\"normal\">∣</mi><mi>P</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{x\\in \\omega|P(x)\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)}</span></span></span></span> is an inductive set, so therefore <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi><mo>⊆</mo><mo stretchy=\"false\">{</mo><mi>x</mi><mo>∈</mo><mi>ω</mi><mi mathvariant=\"normal\">∣</mi><mi>P</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\omega\\subseteq \\{x\\in \\omega|P(x)\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)}</span></span></span></span> and hence <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> holds for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">x\\in\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span></p>",
        "id": 245179563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625664715
    },
    {
        "content": "<p>I've been using <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">S(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> so far to talk about the successor function. VN ordinals use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>x</mi><mo>∪</mo><mo stretchy=\"false\">{</mo><mi>x</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">S(x)=x\\cup \\{x\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.55556em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">}</span></span></span></span>, and zermelo ordinals use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">{</mo><mi>x</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">S(x)=\\{x\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">}</span></span></span></span>. All the theory is the same for either one, since all you need to make the argument work is for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> to be injective and not have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> in the range</p>",
        "id": 245180058,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625664878
    },
    {
        "content": "<p>For technical reasons VN ordinals turn out to be more convenient once you start doing more advanced set theory (VN successor of a transitive set is also transitive)</p>",
        "id": 245180328,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625664973
    },
    {
        "content": "<p>alright so it seems that I can play the Natural Number Game in ZFC... how about this? <a href=\"https://github.com/leanprover-community/mathlib/tree/master/archive/miu_language\">https://github.com/leanprover-community/mathlib/tree/master/archive/miu_language</a> how can this be modeled in ZFC? like I mean the inductive predicate that tells whether or not a given string is derivable...</p>",
        "id": 245197545,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625671361
    },
    {
        "content": "<p>I don't even know how to define a list in ZFC!</p>",
        "id": 245197718,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625671423
    },
    {
        "content": "<p>You could encode <code>[a,b,c,d]</code> as <code>{{a}, {a,b}, {a,b,c}, {a,b,c,d}}</code>, or something like that.</p>",
        "id": 245198324,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1625671638
    },
    {
        "content": "<p>although it's rather defined as <code>{{a}, {a, {{b}, {b, {{c}, {c, d}}}</code> because we want to define it by induction using the pair</p>",
        "id": 245199209,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1625671969
    },
    {
        "content": "<p>As with every definition in maths, you should take it very seriously, but, in Johan's encoding -- which normally goes under the name of Kuratowski's encoding,  I remember that I had to think hard about the case in which there are repetitions among the elements of the list.  In particular, you may want to define ordered <em>pairs</em> first, and then proceed to longer lists.</p>",
        "id": 245199235,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1625671973
    },
    {
        "content": "<p>Ooh, I guess I messed up, right? With repeated elements you my encoding doesn't work.</p>",
        "id": 245200198,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1625672311
    },
    {
        "content": "<p>so. many. subtleties. how can I construct stuff in ZFC without subtly messing stuff up, when even working mathematicians on here still get things wrong</p>",
        "id": 245200367,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625672378
    },
    {
        "content": "<p>hmm I'll check back later for answers to my questions, also are there any resources to help me learn this stuff without having to ask like 998244353 questions for every single thing I want to do in ZFC</p>\n<p>like a website or something that teaches ZFC stuff</p>",
        "id": 245200715,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625672521
    },
    {
        "content": "<p>thanks in advance, as usual. I have to go to bed <span aria-label=\"in bed\" class=\"emoji emoji-1f6cc\" role=\"img\" title=\"in bed\">:in_bed:</span></p>",
        "id": 245200874,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625672585
    },
    {
        "content": "<p>You can read \"Naive Set Theory\" by Halmos</p>",
        "id": 245202039,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625673084
    },
    {
        "content": "<p>Note that the \"mess up\" is with the <em>encoding</em>, not with the concept!  No mathematician should ever make a mistake with lists with repeated entries, except possibly in their definition!</p>",
        "id": 245202084,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1625673111
    },
    {
        "content": "<p>I think it would be interesting to make a ZFC natural number game in Lean using the ZFC naturals</p>",
        "id": 245209878,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1625676664
    },
    {
        "content": "<p>Of course once you've established recursion I guess it'll just reduce to the same thing</p>",
        "id": 245209947,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1625676711
    },
    {
        "content": "<p>Why isn't there foundational pluralism in mathematics like there is in computer science? E.g. in CS/software engineering there are myriad programming languages (some of which I guess correspond to formal logics) and people typically choose the foundation (language) that is best suited to a particular problem. In mathematics there is just one de facto foundation/language, ZFC with FOL.  But I imagine that some mathematical problems are more easily stated or solved in some other foundational system.</p>",
        "id": 245231311,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1625686530
    },
    {
        "content": "<p>ZFC is more of a theoretical foundation than a practical one.  For the practical side, yes, there are a Myriad of options.</p>",
        "id": 245231946,
        "sender_full_name": "Jason Rute",
        "timestamp": 1625686821
    },
    {
        "content": "<p>I don't agree that ZFC is comparable to languages. More like x86, or binary.</p>",
        "id": 245232215,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625686938
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"270523\">Huỳnh Trần Khanh</span> <a href=\"#narrow/stream/113488-general/topic/how.20zfc.20works/near/245200367\">said</a>:</p>\n<blockquote>\n<p>so. many. subtleties. how can I construct stuff in ZFC without subtly messing stuff up, when even working mathematicians on here still get things wrong</p>\n</blockquote>\n<p>The same way you do any formally intricate definition: you prove theorems about the stuff proving the key properties you expect. If you don't do this it's no better than an untested computer program.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"270523\">Huỳnh Trần Khanh</span> <a href=\"#narrow/stream/113488-general/topic/how.20zfc.20works/near/245200715\">said</a>:</p>\n<blockquote>\n<p>hmm I'll check back later for answers to my questions, also are there any resources to help me learn this stuff without having to ask like 998244353 questions for every single thing I want to do in ZFC</p>\n<p>like a website or something that teaches ZFC stuff</p>\n</blockquote>\n<p>This is actually a very good use for the <a href=\"http://us.metamath.org/mpeuni/opth.html\">metamath website</a>, which has fully worked out and hyperlinked proofs of all these facts from the axioms of ZFC</p>",
        "id": 245232725,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625687184
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113488-general/topic/how.20zfc.20works/near/245232215\">said</a>:</p>\n<blockquote>\n<p>I don't agree that ZFC is comparable to languages. More like x86, or binary.</p>\n</blockquote>\n<p>ZFC itself, perhaps not, but ZFC + conservative extensions for definitions can certainly raise the level of discourse to traditional mathematical argumentation</p>",
        "id": 245232971,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625687307
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243102\">Brandon Brown</span> <a href=\"#narrow/stream/113488-general/topic/how.20zfc.20works/near/245231311\">said</a>:</p>\n<blockquote>\n<p>Why isn't there foundational pluralism in mathematics like there is in computer science? E.g. in CS/software engineering there are myriad programming languages (some of which I guess correspond to formal logics) and people typically choose the foundation (language) that is best suited to a particular problem. In mathematics there is just one de facto foundation/language, ZFC with FOL.  But I imagine that some mathematical problems are more easily stated or solved in some other foundational system.</p>\n</blockquote>\n<p>I think that the reason is that practically mathematicians don't care at all about foundations. Someone told us that it is ZFC, maybe with the continuum hypothesis, but we really don't care doing \"standard\" mathematics.</p>",
        "id": 245233012,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1625687335
    },
    {
        "content": "<p>I'm not sure it's an exact parallel, but I see a sort of church-turing thesis for mathematical foundations: once you get past a certain very low bar all theories become interconvertible (modulo adding axioms to match up the consistency strengths of the source and target systems). Mathematics is presented using an implicit background foundation that fails to commit to any of these equivalent systems, and if pressed people will pick one like ZFC but that doesn't mean they were thinking about it at all before you ask the question</p>",
        "id": 245233373,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625687520
    },
    {
        "content": "<p>ZFC has the advantage that it is really simple to define, which makes it appealing for metalogical analysis / \"set theory\". Type theory is more complex but comes with advantages for automation (e.g. type checking), so it is more common among computer proof assistants</p>",
        "id": 245233673,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625687657
    },
    {
        "content": "<p>Also, I think the stack is a lot larger in maths. Going with the PL analogy, Lurie wrote a \"library\" on higher topos theory. It's several thousand pages. If you want to use a language that is different from his, but you want to use higher topos theory, you first need to port that library.</p>\n<p>As pointed out above, in practice informal maths is foundation-agnostic. But when you start formalizing, this library porting becomes a serious issue.</p>",
        "id": 245235501,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1625688497
    },
    {
        "content": "<p>wait I'm extremely confused... why is the Naive Set Theory book titled so? it describes ZFC...</p>",
        "id": 245270673,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625717990
    },
    {
        "content": "<p>ZFC is not naive by any stretch of the imagination...</p>",
        "id": 245270724,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625718027
    },
    {
        "content": "<p>I haven't looked at the book in detail but it probably means that it isn't dealing at the edges of the system where you have to worry about how ZFC avoids the contradictions in unrestricted comprehension</p>",
        "id": 245270737,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625718072
    },
    {
        "content": "<p>Note that a lot of category theory is also \"naive\" in this sense - there are universe issues to be handled, but as long as you don't test the limits you can kind of pretend they don't exist</p>",
        "id": 245270742,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625718118
    },
    {
        "content": "<p>I am reminded of a certain formal system that shall not be named, which implemented naive set theory, and the solution the developers had for avoiding contradictions was to simply not write down the russell set</p>",
        "id": 245270816,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625718237
    },
    {
        "content": "<p>The title of Halmos's book is sort of a joke -- it rigorously goes through the axioms of ZFC, and the only thing that's \"naive\" is the intended audience with regards to knowledge of foundations, and also it doesn't go into detail about things like what exactly is a logical formula.  (It definitely expects mathematical maturity though.)</p>",
        "id": 245275152,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625724163
    },
    {
        "content": "<p>Halmos explains the axiom of restricted comprehension (here called the axiom of specification, which he helpfully tells you is often referred to as Aussonderungsaxiom), then shortly after proves \"there is no universe\", mentioning how in pre-axiomatic approaches the Russell paradox would arise.</p>",
        "id": 245275421,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625724541
    },
    {
        "content": "<p>Actually, he explains the title in the preface.  More accurately, \"it is naive in that the language and notation are those of ordinary informal (but formalizable) mathematics,\" and also that it works with set theory as if there were a single theory of sets.</p>",
        "id": 245276130,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625725362
    }
]
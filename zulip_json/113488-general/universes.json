[
    {
        "content": "<p>Hello,<br>\nin <em>Theorem Proving in Lean,</em> the authors provide the following examples:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">list</span> <span class=\"c1\">-- Type u_1 -&gt; Type u_1</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">prod</span> <span class=\"c1\">-- Type u_1 -&gt; Type u_2 -&gt; Type (max u_1 u_2)</span>\n</pre></div>\n\n\n<p>Why is the universe the same in the first case, and different in the second?</p>",
        "id": 193025730,
        "sender_full_name": "Phiroc",
        "timestamp": 1586171305
    },
    {
        "content": "<p>there is one input in the first case and two in the second</p>",
        "id": 193026351,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586171685
    },
    {
        "content": "<p>in general, we want the output type to be determined by the inputs, and the output type will usually be the max of the universes of all the inputs</p>",
        "id": 193026407,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586171729
    },
    {
        "content": "<p>Are there foundational problems with allowing mild(?) quantification over universe variables?</p>",
        "id": 213879221,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603175405
    },
    {
        "content": "<p>yes, it increases the axiomatic strength</p>",
        "id": 213879231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603175424
    },
    {
        "content": "<p>That's the only problem?</p>",
        "id": 213879260,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603175474
    },
    {
        "content": "<p>Sounds like a good thing to me <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 213879266,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603175483
    },
    {
        "content": "<p>I mean it doesn't really solve any problems, you just get more universes that you aren't allowed to quantify over</p>",
        "id": 213879294,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603175522
    },
    {
        "content": "<p>Well, it might solve my problems</p>",
        "id": 213879349,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603175564
    },
    {
        "content": "<p>if you add the ability to quantify over <em>all</em> universes, including the ones you are adding, then you get a second impredicative universe and then it's hello paradox</p>",
        "id": 213879357,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603175578
    },
    {
        "content": "<p>I think I only care about rings/modules/schemes that live in <code>Type n</code> for <code>n : nat</code></p>",
        "id": 213879361,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603175586
    },
    {
        "content": "<p>I think I would prefer the solution Kevin often talks about, where you have <em>less</em> universes, preferably none</p>",
        "id": 213879388,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603175631
    },
    {
        "content": "<p>And since most mathematicians still pretend they only work in <code>Type 0</code>, I think it will take some time before we get a profound mathematical construction that genuinely takes a limit construction over <code>Type n</code> (<code>n : nat</code>) to produce something that lives in <code>Type \\omega</code></p>",
        "id": 213879459,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603175681
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/universes/near/213879388\">said</a>:</p>\n<blockquote>\n<p>I think I would prefer the solution Kevin often talks about, where you have <em>less</em> universes, preferably none</p>\n</blockquote>\n<p>But then, why all this trouble of being universe polymorphic?</p>",
        "id": 213879482,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603175718
    },
    {
        "content": "<p>The thing is, once you are doing limit constructions you don't just get to Type \\omega, you get to <code>Type (aleph omega)</code> or an even higher cardinal</p>",
        "id": 213879507,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603175755
    },
    {
        "content": "<p>We have to be universe polymorphic because someone had the poor sense to put universes in the type theory</p>",
        "id": 213879556,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603175784
    },
    {
        "content": "<p>Right, but my point is that I don't see such constructions happening.</p>",
        "id": 213879557,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603175785
    },
    {
        "content": "<p>Whereas I do hope that we might be able to have etale cohomology soonish. The ingredients are slowly dripping into mathlib.</p>",
        "id": 213879573,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603175809
    },
    {
        "content": "<p>so if you want to be generic over things you can construct in lean then you have to be universe polymorphic</p>",
        "id": 213879576,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603175813
    },
    {
        "content": "<p>But without universes, you'll have a major pain when you try to define sheaf cohomology</p>",
        "id": 213879604,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603175867
    },
    {
        "content": "<p>I don't think universes actually solve that pain, they just put it somewhere else</p>",
        "id": 213879652,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603175888
    },
    {
        "content": "<p>Why?</p>",
        "id": 213879676,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603175932
    },
    {
        "content": "<p>because you can't iterate any universe bumping construction, so inevitably you still have to figure out how to do whatever you are doing without any universe bumps</p>",
        "id": 213879703,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603175971
    },
    {
        "content": "<p>Right, but my point is that I don't know of any construction in maths that (even informally) is iterating universe bumps.</p>",
        "id": 213879756,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603176003
    },
    {
        "content": "<p>and at the end of it you realize it all fit in ZFC to begin with</p>",
        "id": 213879767,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603176020
    },
    {
        "content": "<p>I've said it before: what category theorists actually want is Type in Type, not this universe nonsense</p>",
        "id": 213879799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603176064
    },
    {
        "content": "<p>and if and when you make all the reasoning consistent you find it's just plain old ZFC</p>",
        "id": 213879823,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603176098
    },
    {
        "content": "<p>universes make everything more complicated and don't solve the problem they set out to solve</p>",
        "id": 213879884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603176140
    },
    {
        "content": "<p>I totally disagree with the above 3 lines, with the caveat that math universes are not the same as type theory universes</p>",
        "id": 213921303,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603201811
    },
    {
        "content": "<p>It all fits in ZFC+U--if we're redefining ZFC to mean that then great</p>",
        "id": 213921417,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603201866
    },
    {
        "content": "<p>It's also probably the case in a given application (in algebraic geometry say) that you can remove the \"U\" axiom, in the reverse mathematics sense--but this doesn't mean the category theory itself lives in ZFC, any more than the modularity theorem lives in PA</p>",
        "id": 213922959,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603202462
    },
    {
        "content": "<p>I think most real category theory still fits in higher order ZFC, with no actual universes</p>",
        "id": 213937502,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603208399
    },
    {
        "content": "<p>and higher order ZFC fits in ZFC for most concrete arguments if you play enough logical tricks</p>",
        "id": 213937720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603208484
    },
    {
        "content": "<p>There are certainly some instances where mathematicians do stuff with universes and then force everything back into ZFC. However it is getting to the point where there are things which some mathematicians (e.g. Scholze) do which cannot be forced back into ZFC, or, at least, nobody is trying to force it back into ZFC right now. We're quite a way away from this in mathlib so whether this will matter to us in practice is unclear to me -- but perhaps Reid knows other areas of maths which are also falling out of ZFC. </p>\n<p>I am not looking forward to all this \"force everything back into ZFC\" issue when we run into etale cohomology. We want to take a limit over a universe and then there's a theorem saying that it's \"equal to\" a limit over a type. Nowadays I am quite conflicted about to how important this descent is.</p>",
        "id": 213948143,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603213090
    },
    {
        "content": "<p>Mike Shulman has a paper <a href=\"https://arxiv.org/pdf/0810.1279.pdf\">https://arxiv.org/pdf/0810.1279.pdf</a> discussing size issues in category theory and the possible ways to resolve them (including universes).</p>",
        "id": 213955400,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603216127
    },
    {
        "content": "<p>Here's a simple example where ZFC is inadequate. Suppose I already have a theory of monoidal categories and monoid objects in them and their modules. Now a friendly Haskell programmer informs me that a monad on a category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> is \"just a monoid in the category of endofunctors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>C</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[C, C]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">]</span></span></span></span>\". Great, now I can apply my existing theory to get a theory of monads and their modules (usually known as algebras).</p>",
        "id": 213955784,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603216317
    },
    {
        "content": "<p>However, if I try to apply this to a large category (like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>=</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">C = \\mathrm{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">S</span><span class=\"mord mathrm\">e</span><span class=\"mord mathrm\">t</span></span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>=</mo><msub><mrow><mi mathvariant=\"normal\">M</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow><mi>R</mi></msub></mrow><annotation encoding=\"application/x-tex\">C = \\mathrm{Mod}_R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">M</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">d</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>) this breaks down, because the \"endofunctor category\" <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>C</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[C, C]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">]</span></span></span></span> is \"too large\" to fit in ZFC even as a proper class (basically because its objects are already class-sized).</p>",
        "id": 213955949,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603216377
    },
    {
        "content": "<p>So, I'm forced to develop a parallel but separate theory of monads on large categories.</p>",
        "id": 213956013,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603216401
    },
    {
        "content": "<p>For a much fancier example, in algebraic geometry, there's no difficulty in ZFC in defining a stack of small categories on a small site. But, putting aside the issue of the size of the site, it's also very useful to consider stacks of large categories. For example, there is a stack which assigns to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mtext> </mtext><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Spec}\\,R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">S</span><span class=\"mord mathrm\">p</span><span class=\"mord mathrm\">e</span><span class=\"mord mathrm\">c</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> the category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"normal\">M</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow><mi>R</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Mod}_R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">M</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">d</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-modules. On a scheme <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, the \"global sections\" of this stack is the category of quasicoherent modules on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>.</p>",
        "id": 213956814,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603216714
    },
    {
        "content": "<p>It would not surprise me if some mathematicians thought that we were in some kind of second foundational crisis -- ZFC worked fine for 100 years but now people really want to do stuff which pushes it to the limits and possibly beyond. However there are many areas of mathematics for which ZFC is completely adequate; I was talking to Hairer about this and he seemed absolutely convinced that he didn't even need full AC, and that ZF + countable dependent choice could get him a Fields Medal in the kind of analysis he did.</p>",
        "id": 213956973,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603216794
    },
    {
        "content": "<p>I've never thought about precisely how much AC I need, but I have this uncomfortable feeling that the ZFC crisis I had in my 20s, when I carefully checked that a bunch of stuff I wanted/needed could be done in ZFC, is now going to be repeated if I ever want to dive into condensed mathematics, and this time I'm not entirely sure what the answer will be.</p>",
        "id": 213957289,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603216891
    },
    {
        "content": "<p>With my category theorist hat on, I want to make two points:</p>\n<ol>\n<li>It really is important to make some size distinctions, at least to the extent of \"small\" and \"large\" , because you can't do very much category theory without talking about Set and other large categories, and here we already find for example that Set has (co)limits indexed by small categories but not large ones. The beginning of Shulman's paper gives more examples of this kind.</li>\n<li>It's useful <em>at least for conceptual reasons</em> to talk about \"very large\" categories like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow><mo separator=\"true\">,</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[\\mathrm{Set}, \\mathrm{Set}]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathrm\">S</span><span class=\"mord mathrm\">e</span><span class=\"mord mathrm\">t</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">S</span><span class=\"mord mathrm\">e</span><span class=\"mord mathrm\">t</span></span><span class=\"mclose\">]</span></span></span></span> or the 2-category of all stacks of locally presentable categories on a scheme (or whatever). These objects are too big to exist in ZFC(at least  if we interpret <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">S</span><span class=\"mord mathrm\">e</span><span class=\"mord mathrm\">t</span></span></span></span></span> as referring to the category of <em>all</em> sets, and similarly for locally presentable categories).</li>\n</ol>",
        "id": 213959144,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603217742
    },
    {
        "content": "<p>Now,</p>\n<ul>\n<li>In the end, one might be interested in a specific theorem about monads or quasicoherent modules or whatever, and then one could ask whether or not this theorem is provable in ZFC. In my view, this is basically a question of reverse mathematics, and those who aren't interested in such questions shouldn't feel obliged to care about them.</li>\n<li>A lot of category theory can be presented in a way which is agnostic to the specific foundations, while still making the basic small/large distinction. In this case, the reader can choose whether to interpret \"small/large\" as \"set/class\" or \"element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">U</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{U}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">U</span></span></span></span></span>/non-element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">U</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{U}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">U</span></span></span></span></span>\" or in some other way.</li>\n</ul>\n<p>Personally, I find the interpretation using Grothendieck universes convenient because it allows me to make sense of all category theory using ordinary sets, and doesn't need classes or fancy logic. However, it does have the disadvantages that the interpretation is relative to a fixed inaccessible cardinal and that, for example, a group constructed to have a certain universal property <em>a priori</em> only has this universal property with respect to other groups that are small with respect to the reference cardinal, and not with respect to all groups.</p>",
        "id": 213960154,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603218254
    },
    {
        "content": "<p>Reid, since you are in this foundational mood, and I don't know anything about all this, do you have a definitive answer to the question: if I have a set S, can I define free groups over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> as groups <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> equipped with a map from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>:</mo><mi>S</mi><mo>→</mo><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">i : S \\to F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> such that, for <em>all</em> groups <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>S</mi><mo>→</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">f : S \\to G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> there is a unique morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi><mo>:</mo><mi>F</mi><mo>→</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">\\varphi : F \\to G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">φ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi><mo>∘</mo><mi>i</mi><mo>=</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">\\varphi \\circ i = f</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.63889em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">φ</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>? Or is it forbidden because there is no set of groups? If it's forbidden, what can be done?</p>",
        "id": 213960893,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603218632
    },
    {
        "content": "<p>I have the vague impression this is forbidden as a definition but somewhat allowed as a theorem about a given <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span>, but this doesn't seem to make any sense.</p>",
        "id": 213960960,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603218678
    },
    {
        "content": "<p>At least in Lean the answer seems to be that you cannot make it the definition, but you can make it a theorem.</p>",
        "id": 213961275,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603218841
    },
    {
        "content": "<p>Yes, this is my impression, but it's weird and I'd like to understand this one day (or at least have the feeling to understand a bit and get a reference I can read from times to times)</p>",
        "id": 213961388,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603218893
    },
    {
        "content": "<p>Yes that's no definition. You can only quantify over all G in some universe, so really you end up with infinitely many universal properties in some sense.</p>",
        "id": 213961559,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603218964
    },
    {
        "content": "<p>But still it can be a property, right?</p>",
        "id": 213961618,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603218991
    },
    {
        "content": "<p>Because if I define <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> using reduced words etc. then certainly it satisfies the universal property for all groups, right?</p>",
        "id": 213961676,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603219021
    },
    {
        "content": "<p>In ZFC the predicate \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>S</mi><mo>→</mo><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">f : S \\to F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> exhibits <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> as the free group on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>\" defined in this way (for <em>all</em> groups <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> and maps <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>→</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">S \\to G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> there exists ...) is totally fine. For example, it could be a hypothesis to a theorem. (Of course you need to do something else to prove that there actually exists such an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>, but I don't think that's what you were asking about.)</p>",
        "id": 213961968,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603219162
    },
    {
        "content": "<p>Then where is the problem? Is it that we want more than ZFC for other purposes and this breaks this definition?</p>",
        "id": 213962168,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603219246
    },
    {
        "content": "<p>The problem with doing category theory in ZFC?</p>",
        "id": 213962226,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603219285
    },
    {
        "content": "<p>The problem with defining stuff using universal properties</p>",
        "id": 213962275,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603219314
    },
    {
        "content": "<p>If I have several universes, I can still prove that my favorite free groups satisfies the universal property for all groups in any universe but this cannot be an assumption in a theorem, right?</p>",
        "id": 213962435,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603219384
    },
    {
        "content": "<p>... which means you can end up writing essentially the same proof over and over again for each of your favorite free groups, right?</p>",
        "id": 213962726,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603219507
    },
    {
        "content": "<p>And if I have a low-tech definition of free groups (something like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo stretchy=\"false\">(</mo><mi>S</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">i(S)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span></span></span></span> generates <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> and there is no relation between elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo stretchy=\"false\">(</mo><mi>S</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">i(S)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span></span></span></span>, which can be defined properly), I cannot state something like \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>F</mi><mo separator=\"true\">,</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(F, i)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span> is a free group on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> iff it satisfies the universal property for every group in every universe\" right?</p>",
        "id": 213962768,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603219530
    },
    {
        "content": "<p>What do you mean with \"any\"?</p>",
        "id": 213962891,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603219563
    },
    {
        "content": "<p>If it means \"all\", then you indeed cannot,<br>\nif it means \"there exists a universe\", then you can</p>",
        "id": 213962962,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603219591
    },
    {
        "content": "<p>If you're doing category theory in ZFC+U with the \"all categories implicitly relativized to a universe <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">U</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{U}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">U</span></span></span></span></span>\" convention, then it is still meaningful to talk about whether a morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>S</mi><mo>→</mo><mi>U</mi><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">f : S \\to UF</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi><mo>:</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow><mo>→</mo><mrow><mi mathvariant=\"normal\">G</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">p</mi></mrow></mrow><annotation encoding=\"application/x-tex\">U : \\mathrm{Set} \\to \\mathrm{Grp}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">S</span><span class=\"mord mathrm\">e</span><span class=\"mord mathrm\">t</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">G</span><span class=\"mord mathrm\">r</span><span class=\"mord mathrm\">p</span></span></span></span></span> the forgetful functor) has the universal property of making <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> a free group with respect to <em>all</em> groups. It just isn't the condition that falls out from the category theory, because <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">G</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">p</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Grp}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">G</span><span class=\"mord mathrm\">r</span><span class=\"mord mathrm\">p</span></span></span></span></span> now means \"all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">U</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{U}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">U</span></span></span></span></span>-small groups\" (and likewise for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">S</span><span class=\"mord mathrm\">e</span><span class=\"mord mathrm\">t</span></span></span></span></span>).</p>",
        "id": 213962986,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603219605
    },
    {
        "content": "<p>English is a really awful language, but hopefully I disambiguated.</p>",
        "id": 213963013,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603219621
    },
    {
        "content": "<p>At least not by definition--of course in this case the two conditions really are equivalent, but the easiest way to see that might be to note that you can construct the free group in a way that does not depend upon the reference universe <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">U</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{U}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">U</span></span></span></span></span>.</p>",
        "id": 213963172,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603219687
    },
    {
        "content": "<p>Johan's answer is right for Lean, but not for ZFC+U, I think.</p>",
        "id": 213963300,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603219761
    },
    {
        "content": "<p>But why is there this assymetry that I can state this as a property of a given concrete <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>F</mi><mo separator=\"true\">,</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(F, i)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span> but not as an assumption of a theorem?</p>",
        "id": 213963313,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603219769
    },
    {
        "content": "<p>You can state that, and even prove it.</p>",
        "id": 213963319,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603219772
    },
    {
        "content": "<p>In Lean, it works differently because you can only quantify over types in a specific universe, and quantifiers over universes can only occur at the outside of a top-level definition.</p>",
        "id": 213963519,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603219856
    },
    {
        "content": "<p>In ZFC I think that statements which use bounded quantification, i.e., only have quantifiers like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>X</mi><mo separator=\"true\">,</mo><mi>X</mi><mo>∈</mo><mi>S</mi><mo>→</mo><mo>…</mo></mrow><annotation encoding=\"application/x-tex\">\\forall X, X \\in S \\to \\ldots</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.12em;vertical-align:0em;\"></span><span class=\"minner\">…</span></span></span></span> is a notion which is useful, but you're not restricted to only making such statements.</p>",
        "id": 213963772,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603219963
    },
    {
        "content": "<p>(Sorry, that was a poorly-constructed sentence but I hope it makes sense.)</p>",
        "id": 213963872,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603220006
    },
    {
        "content": "<p>So what is impossible with ZFC + universes then?</p>",
        "id": 213964316,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603220215
    },
    {
        "content": "<p>The drawback of this approach isn't that anything is impossible, but rather that if you really care about (let's say) \"Universal\" properties that quantify over <em>all</em> groups, or whatever, you will have to do some extra work to know that you have one.</p>",
        "id": 213965126,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603220577
    },
    {
        "content": "<p>Whereas if you really did category theory with the category of all groups in the first place, then universal properties in category theory would be true Universal properties.</p>",
        "id": 213965200,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603220612
    },
    {
        "content": "<p>(Plus of course you might be concerned about accepting the universe axiom, which does prove additional arithmetic statements like Con(ZFC).)</p>",
        "id": 213965403,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603220700
    },
    {
        "content": "<p>What is Con(ZFC)?</p>",
        "id": 213965453,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603220726
    },
    {
        "content": "<p>consistency?</p>",
        "id": 213965474,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603220737
    },
    {
        "content": "<p>Yes, or more precisely, some encoding of it in terms of natural numbers.</p>",
        "id": 213965615,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603220788
    },
    {
        "content": "<p>Some particular, rather large polynomial in a few variables has no integer solution.</p>",
        "id": 213965779,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603220859
    },
    {
        "content": "<p>The later parts of Shulman's paper go into ways to systematically turn universe-relative universal properties into true Universal properties, and ways you might be able to talk about \"very large\" categories without increasing the consistency strength of the background theory.</p>",
        "id": 213966153,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603221004
    },
    {
        "content": "<p>Ok, thanks for all you explanations! I'll try to think about all that.</p>",
        "id": 213966463,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603221134
    },
    {
        "content": "<p>I have a question related to this issue about defining things in terms of their universal properties. I know of one example in mathlib which does (more-or-less) exactly this: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/stone_cech_setoid/src\">src#stone_cech_setoid</a><br>\nDoes this mean that mathlib only has the universal property of the Stone-Cech compactification for topological spaces which live in the same universe? Is there any way around this (without changing the definition of <code>stone_cech</code>)?</p>",
        "id": 213975002,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603225573
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> It is a curious consequence of \"internal definitions\" (for example, a free group is a certain quotient of lists) that they imply and are implied by the \"external definition\" (a free group is one that maps in an appropriate way to all groups) at every universe. This fact means that even a definition using an external definition at Type u is equivalent to the external definition at all types, so <code>stone_cech</code>'s universal property applies even to larger universes even though you can't apply it directly</p>",
        "id": 213998351,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603242699
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/universes/near/213963313\">said</a>:</p>\n<blockquote>\n<p>But why is there this assymetry that I can state this as a property of a given concrete <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>F</mi><mo separator=\"true\">,</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(F, i)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span> but not as an assumption of a theorem?</p>\n</blockquote>\n<p>The key to this ability for us to prove external properties that we didn't quantify over to start with at the foundational level is the extra universe argument in <code>T.rec</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">nat'</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">nat'</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">nat'</span> <span class=\"bp\">→</span> <span class=\"n\">nat'</span>\n<span class=\"k\">#print</span> <span class=\"n\">nat'.rec</span>\n<span class=\"c1\">-- protected eliminator nat'.rec : Π {C : nat' → Sort l},</span>\n<span class=\"c1\">--  C nat'.zero → (Π (a : nat'), C a → C a.succ) → Π (n : nat'), C n</span>\n</code></pre></div>\n\n<p>Note that <code>nat'</code> has no universe parameters but it has a recursor that quantifies over a universe parameter <code>l</code>. If recursors didn't do this, for example if <code>nat'.rec</code> only quantified over <code>C : nat' -&gt; Type</code>, then we wouldn't need the inductive axioms at all; we could use church encodings to do everything. But this universe lifting property is truly magical, as it allows you to prove that a universal property at one type implies a universal property for one specifically crafted inductive type, which then implies the universal property at a higher universe using that inductive type's recursor.</p>",
        "id": 213998837,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603243273
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> As a concrete example, is it possible to make the second example in the following code work?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.stone_cech</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">compact_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">compact_space</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">γ</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cont</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">stone_cech</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span> <span class=\"n\">stone_cech_extend</span> <span class=\"n\">cont</span> <span class=\"c1\">-- works</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cont</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">stone_cech</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">stone_cech_extend</span> <span class=\"n\">cont</span> <span class=\"c1\">-- doesn't work</span>\n</code></pre></div>\n\n<p>I understand that it's possible to prove that the stone cech compactification of a topological space in <code>Type u</code>, which is defined so that it satisfies the universal property with respect to every topological space of <code>Type u</code>, also satisfies the universal property for every topological space of <code>Type v</code>. But it seems to me that doing this is essentially equivalent to redefining the stone cech compactification, or more specifically in this case, the equivalence relation <code>stone_cech_setoid</code>, so that it doesn't quantify over types in the first place.</p>",
        "id": 214049241,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603286990
    },
    {
        "content": "<p>that's right</p>",
        "id": 214049661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603287156
    },
    {
        "content": "<p>you can't apply <code>stone_cech_extend</code> directly</p>",
        "id": 214049720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603287193
    },
    {
        "content": "<p>Okay, so life isn't as easy as I would have hoped.</p>",
        "id": 214049722,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603287194
    },
    {
        "content": "<p>but you can hide this construction inside a proof, for example, if you wanted to keep the definition \"clean\"</p>",
        "id": 214049783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603287229
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/universes/near/214049783\">said</a>:</p>\n<blockquote>\n<p>but you can hide this construction inside a proof, for example, if you wanted to keep the definition \"clean\"</p>\n</blockquote>\n<p>What do you mean by this?</p>",
        "id": 214049861,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603287251
    },
    {
        "content": "<p>you can construct an inductive type with the requisite properties in order to prove that the universal property at u implies the universal property at v</p>",
        "id": 214049974,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603287315
    },
    {
        "content": "<p>and then that is the theorem you would be applying instead of <code>stone_cech_extend</code></p>",
        "id": 214050040,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603287354
    },
    {
        "content": "<p>Oh, I'm not sure what such an inductive type would like like. You mean something similar to <code>ulift</code>?</p>",
        "id": 214050244,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603287452
    },
    {
        "content": "<p>no, it depends on the universal property</p>",
        "id": 214050317,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603287481
    },
    {
        "content": "<p>for free groups it's lists on the basic elements</p>",
        "id": 214050396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603287504
    },
    {
        "content": "<p>in a lot of categorical proofs this is where we show that the presheaf is representable</p>",
        "id": 214050436,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603287535
    },
    {
        "content": "<p>Ah okay. So this would just redefine the object altogether then.</p>",
        "id": 214050443,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603287537
    },
    {
        "content": "<p>When I wrote the <code>stone_cech</code> stuff I think I just followed some notes I found online--if there's a way to describe the required topology directly, without quantifying over <code>Type u</code>, then that's probably a better definition.</p>",
        "id": 214050483,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603287561
    },
    {
        "content": "<p>I think there is a way to do it, using the monadic properties of ultrafilters, but of course it's more complicated.</p>",
        "id": 214050537,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603287598
    },
    {
        "content": "<p>I think the internal definition of stone cech uses the set of ultrafilters</p>",
        "id": 214050742,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603287690
    },
    {
        "content": "<p>Actually, maybe it's not too bad with what's in this file:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/topology/category/Compactum.lean\">https://github.com/leanprover-community/mathlib/blob/master/src/topology/category/Compactum.lean</a></p>",
        "id": 214050760,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603287698
    },
    {
        "content": "<p>For example maybe it's enough to consider all quotients of <code>ultrafilter α</code> itself</p>",
        "id": 214050800,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603287714
    },
    {
        "content": "<p>or maybe you don't even need to allow a quotient</p>",
        "id": 214050940,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603287759
    },
    {
        "content": "<p>Isn't the stone cech compactification the largest quotient of <code>ultrafilter \\a</code> which is an algebra for the ultrafilter monad, and for which the canonical map from <code>\\a</code> is continuous?</p>",
        "id": 214051108,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603287843
    },
    {
        "content": "<p>This would be a description that says nothing about any type other than <code>\\a</code> itself.</p>",
        "id": 214051211,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603287879
    },
    {
        "content": "<p>@_<strong>Wikipedia</strong> <a href=\"https://en.wikipedia.org/wiki/Stone%E2%80%93%C4%8Cech_compactification#Construction_using_products\">said</a>:</p>\n<blockquote>\n<p>There are several ways to modify this idea to make it work; for example, one can restrict the compact Hausdorff spaces K to have underlying set P(P(X)) (the power set of the power set of X), which is sufficiently large that it has cardinality at least equal to that of every compact Hausdorff set to which X can be mapped with dense image.</p>\n</blockquote>",
        "id": 214051328,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603287935
    },
    {
        "content": "<p>The constructions in terms of maps to the unit interval (from wiki) would also work, I guess.</p>",
        "id": 214051583,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603288057
    },
    {
        "content": "<p>This reminds me that hausdorff sets have an interesting cardinality bound: they are at most the double powerset of any dense subset A because you can uniquely pick out every element of X by a filter in A</p>",
        "id": 214051590,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603288062
    },
    {
        "content": "<p>I think this proof would be easiest (I've done it in metamath before, it follows from the axioms pretty easily)</p>",
        "id": 214051728,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603288119
    },
    {
        "content": "<p>the unit interval requires partitions of unity, which I think are more complicated</p>",
        "id": 214051761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603288135
    },
    {
        "content": "<p>By the way, what was the original point of this thread? <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 214217563,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603386542
    },
    {
        "content": "<p>What was quantifying over universe levels intended to be used for?</p>",
        "id": 214217599,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603386563
    },
    {
        "content": "<p>I think specifying universal properties?</p>",
        "id": 214217723,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603386604
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/universes/near/213879221\">said</a>:</p>\n<blockquote>\n<p>Are there foundational problems with allowing mild(?) quantification over universe variables?</p>\n</blockquote>\n<p>Why can't I write a <code>bundled_hom</code> class that is universe polymorphic...</p>",
        "id": 214217753,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603386615
    },
    {
        "content": "<p>That's what my motivation was</p>",
        "id": 214217793,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603386632
    },
    {
        "content": "<p>Because I want <code>bundled_hom.funext</code> and <code>bundled_hom.congr_arg</code> and <code>bundled_hom.congr_fun</code>, etc...</p>",
        "id": 214217824,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603386654
    },
    {
        "content": "<p>what is a bundled hom in this context?</p>",
        "id": 214217853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603386674
    },
    {
        "content": "<p>Instead of having to reprove them for <code>mul_hom</code>, <code>zero_hom</code>, <code>monoid_hom</code>, <code>one_hom</code>, <code>ring_hom</code>, <code>alg_hom</code>, the list goes on...</p>",
        "id": 214217880,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603386688
    },
    {
        "content": "<p>E.g. a group homomorphism from a group of <code>Type u</code> to a group of <code>Type v</code>.</p>",
        "id": 214217882,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603386694
    },
    {
        "content": "<p><code>equiv</code> is a universe polymorphic bundled hom</p>",
        "id": 214217891,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603386700
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/universes/near/214217853\">said</a>:</p>\n<blockquote>\n<p>what is a bundled hom in this context?</p>\n</blockquote>\n<p>It is <code>bundled_hom</code> in the sense of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bundled_hom\">docs#bundled_hom</a></p>",
        "id": 214217903,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603386708
    },
    {
        "content": "<p>Snap!</p>",
        "id": 214217917,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603386721
    },
    {
        "content": "<p>It's not clear to me why this needs more universe quantification than Lean provides</p>",
        "id": 214217968,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603386734
    },
    {
        "content": "<p>I think it's because of <code>bundled</code> as in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.bundled\">docs#category_theory.bundled</a></p>",
        "id": 214218063,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603386791
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.bundled_hom\">docs#category_theory.bundled_hom</a> is a predicate on homs from Type u to Type u. It could be a predicate on homs from Type u to Type v but then you couldn't compose them</p>",
        "id": 214218218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603386847
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">⦃</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">Iα</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Iβ</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Class for bundled homs. Note that the arguments order follows that of lemmas for `monoid_hom`.</span>\n<span class=\"sd\">This way we can use `⟨@monoid_hom.to_fun, @monoid_hom.id ...⟩` in an instance. -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">bundled_hom</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Iα</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Iβ</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">hom</span> <span class=\"n\">Iα</span> <span class=\"n\">Iβ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">hom</span> <span class=\"n\">I</span> <span class=\"n\">I</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">comp</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Iα</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Iβ</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Iγ</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">γ</span><span class=\"o\">),</span>\n  <span class=\"n\">hom</span> <span class=\"n\">Iβ</span> <span class=\"n\">Iγ</span> <span class=\"bp\">→</span> <span class=\"n\">hom</span> <span class=\"n\">Iα</span> <span class=\"n\">Iβ</span> <span class=\"bp\">→</span> <span class=\"n\">hom</span> <span class=\"n\">Iα</span> <span class=\"n\">Iγ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">hom_ext</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Iα</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Iβ</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">Iα</span> <span class=\"n\">Iβ</span><span class=\"o\">)</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">id_to_fun</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">to_fun</span> <span class=\"n\">I</span> <span class=\"n\">I</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">_root_.id</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">comp_to_fun</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Iα</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Iβ</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Iγ</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">Iα</span> <span class=\"n\">Iβ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">Iβ</span> <span class=\"n\">Iγ</span><span class=\"o\">),</span>\n  <span class=\"n\">to_fun</span> <span class=\"n\">Iα</span> <span class=\"n\">Iγ</span> <span class=\"o\">(</span><span class=\"n\">comp</span> <span class=\"n\">Iα</span> <span class=\"n\">Iβ</span> <span class=\"n\">Iγ</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">Iβ</span> <span class=\"n\">Iγ</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">Iα</span> <span class=\"n\">Iβ</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 214218226,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603386849
    },
    {
        "content": "<p>You can't even define them with two universe variables</p>",
        "id": 214218267,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603386873
    },
    {
        "content": "<p>Because you need <code>id</code></p>",
        "id": 214218276,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603386878
    },
    {
        "content": "<p>Actually I think <code>c</code> could be <code>Type u -&gt; Type v</code></p>",
        "id": 214218301,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603386895
    },
    {
        "content": "<p>It would be cool to define the \"category\" of groups as having underlying object type <code>\\Sigma {u : universe} (G : Type u) (is_group : group G)</code></p>",
        "id": 214218311,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603386898
    },
    {
        "content": "<p>oh <code>bundled_hom</code> isn't a bundled hom</p>",
        "id": 214218324,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603386905
    },
    {
        "content": "<p>But nevertheless <code>ring_hom.id</code> is a thing</p>",
        "id": 214218333,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603386909
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/universes/near/214218311\">said</a>:</p>\n<blockquote>\n<p>It would be cool to define the \"category\" of groups as having underlying object type <code>\\Sigma {u : universe} (G : Type u) (is_group : group G)</code></p>\n</blockquote>\n<p>Is that an example of a \\HUGE category?</p>",
        "id": 214218389,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603386940
    },
    {
        "content": "<p>I'm trying to understand what the end goal is though</p>",
        "id": 214218407,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603386949
    },
    {
        "content": "<p>type in type</p>",
        "id": 214218418,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603386956
    },
    {
        "content": "<p>So that the universal property of the free group is actually the left adjoint to the forgetful functor for example.</p>",
        "id": 214218494,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603386976
    },
    {
        "content": "<p>But <code>bundled_hom.funext</code> and so on sounds a lot simpler than talking about universal properties</p>",
        "id": 214218553,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603386998
    },
    {
        "content": "<p>also don't forget the \"metatheorem\" approach: write a tactic to generate all instantiations of a schematic theorem</p>",
        "id": 214218754,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603387095
    },
    {
        "content": "<p>you can quite often write higher order theorems than the logic actually supports this way</p>",
        "id": 214218818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603387128
    },
    {
        "content": "<p>This was on my mind too but I wanted to understand what those theorems are first.</p>",
        "id": 214218839,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603387140
    },
    {
        "content": "<p>I think a tactic that writes the theory of <code>foo_hom</code>s would be more useful than literal category theory</p>",
        "id": 214219058,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603387238
    },
    {
        "content": "<p>and as long as everything is in meta-land the high consistency strength requirements of general category theory is no problem</p>",
        "id": 214219204,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603387302
    },
    {
        "content": "<p>Well, I think Johan's intention was also not to literally do category theory but just be able to abstract over what it means to be a \"foo hom\" when multiple universes are involved</p>",
        "id": 214219320,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603387335
    },
    {
        "content": "<p>sure, but I assume this is going to be used for something</p>",
        "id": 214219380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603387361
    },
    {
        "content": "<p>like perhaps proving theorems generic over different kinds of bundled homs</p>",
        "id": 214219437,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603387387
    },
    {
        "content": "<p>For <code>ext</code> this problem is already solved by <code>@[ext]</code>, right?</p>",
        "id": 214219448,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603387393
    },
    {
        "content": "<p>I think the interesting problem is explicating the actual set of theorems we'd like to generate for foo homs</p>",
        "id": 214219518,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603387430
    },
    {
        "content": "<p>What's an example of a theorem in mathlib which would be a special case of one of these generalized theorems?</p>",
        "id": 214219525,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603387433
    },
    {
        "content": "<p>I am still stuck at the stage where everything category theory appears to deliver is utterly trivial results about associativity pentagons that are one line proofs in the concrete case, which is why I have a poor opinion of the subject</p>",
        "id": 214219714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603387522
    },
    {
        "content": "<p>In particular, it's not clear to me that we couldn't solve whatever the problem is by just having a class like <code>class has_hom (foo : Type*) (bar : Type*)</code> without it knowing that we're always going to set e.g. <code>foo = ring.{u}</code> and <code>bar = ring.{v}</code>.</p>",
        "id": 214219742,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603387544
    },
    {
        "content": "<p>I would like to be able to write the following, for example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">is_free_group</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">incl</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lift</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"kd\">universe</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lift_comp_incl</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"kd\">universe</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">H</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">lift</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">incl</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lift_unique</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"kd\">universe</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">H</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"n\">H</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">g</span> <span class=\"bp\">∘</span> <span class=\"n\">incl</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">lift</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 214219749,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603387545
    },
    {
        "content": "<p>No, this universal property example I understand and it seems hard but it sounded like the things Johan wanted might be easy.</p>",
        "id": 214219862,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603387597
    },
    {
        "content": "<p>Oh, then I misunderstood what the goal was.</p>",
        "id": 214219888,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603387622
    },
    {
        "content": "<p>you can get reasonably close to a general theory using</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">is_free_group_lift</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">incl</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">lift</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lift_comp_incl</span> <span class=\"o\">:</span> <span class=\"n\">lift</span> <span class=\"bp\">∘</span> <span class=\"n\">incl</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lift_unique</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"n\">H</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">∘</span> <span class=\"n\">incl</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">lift</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 214220433,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603387878
    },
    {
        "content": "<p>Oh interesting.</p>",
        "id": 214220698,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603388001
    },
    {
        "content": "<p>But of course this wouldn't give a specification of the free group.</p>",
        "id": 214220901,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603388092
    },
    {
        "content": "<p>no but I'm not trying to do that, I'm trying to do everything a specification of the free group would do</p>",
        "id": 214220966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603388125
    },
    {
        "content": "<p>anyway we know how to specify free groups, you can just restrict to universe u and that works because free groups have some presentability property</p>",
        "id": 214221111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603388186
    },
    {
        "content": "<p>you can always say \"I wish my foundations were more expressive than they are, because they miss &lt;use case X&gt;\", that's godel incompleteness</p>",
        "id": 214221242,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603388255
    },
    {
        "content": "<p>Right, the fact that you can't directly state what I called the \"Universal property\" is kind of annoying, but in specific cases you can find alternative definitions (e.g., by restricting the universe to an appropriate one) and then prove an \"improved\" eliminator which removes the universe restriction.</p>",
        "id": 214221257,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603388264
    },
    {
        "content": "<p>My contention above is actually that you can use <code>is_free_group_lift</code> to work with the unreduced <code>is_free_group</code> predicate by referring to it obliquely</p>",
        "id": 214221471,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603388366
    },
    {
        "content": "<p>For example in your original <code>is_free_group</code>, if we replace <code>v</code> by <code>u</code> (since we know the free group construction doesn't increase the universe level, this should be fine), then the type of <code>is_free_group.lift</code> is something like <code>Pi (G : Type u) (S : Type u) [group G] [is_free_group G S] {H : Type u} [group H] (f : S -&gt; H) : G -&gt;* H</code>, but we can define a better projection with the type <code>Pi (G : Type u) (S : Type u) [group G] [is_free_group G S] {H : Type v} [group H] (f : S -&gt; H) : G -&gt;* H</code>.</p>",
        "id": 214221492,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603388381
    },
    {
        "content": "<p>And for the construction side, obviously it's fine to only have to pass the fields in in the special case <code>v = u</code>.</p>",
        "id": 214221595,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603388413
    },
    {
        "content": "<p>I think for every foo in <code>one</code>, <code>mul</code>, <code>monoid</code>, <code>ring</code>,  we have about 100 lines of quasi-consistent api for <code>foo_hom</code> (and <code>linear_map</code> and <code>alg_hom</code> maybe, although they depend on <code>R</code>), and then another 100 lines for <code>foo_equiv</code>.</p>",
        "id": 214221662,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603388448
    },
    {
        "content": "<p>so let's automate it</p>",
        "id": 214221713,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603388473
    },
    {
        "content": "<p>But these APIs are currently not all homogeneous, there are gaps all over the place.</p>",
        "id": 214221717,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603388475
    },
    {
        "content": "<p>Our only hope is that Yury will refactor them....</p>",
        "id": 214221739,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603388484
    },
    {
        "content": "<p>We want <code>ext</code>, <code>ext_iff</code>, <code>coe</code>, <code>coe_injective</code>, <code>funext</code>, <code>congr_arg</code>, <code>congr_fun</code>, <code>coe_mk</code>, and another 10 common lemmas</p>",
        "id": 214221890,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603388540
    },
    {
        "content": "<p>It would be nice to have a framework for writing entire theory templates that will be multiply instantiated</p>",
        "id": 214221912,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603388553
    },
    {
        "content": "<p><code>id</code>, <code>comp</code>, <code>id_comp</code>, <code>comp_id</code>, <code>comp_assoc</code>, <code>id_apply</code>, <code>comp_apply</code></p>",
        "id": 214221963,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603388572
    },
    {
        "content": "<p>those lemmas are all inputs to the category theory though, you get no help in proving them</p>",
        "id": 214222063,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603388622
    },
    {
        "content": "<p>I don't think abstracting over the category is really viable anyways when using the style of unbundled objects and arrows that specify which structure they preserve</p>",
        "id": 214222225,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603388690
    },
    {
        "content": "<p>Not all of them are input, and some of them the automation should be able to guess</p>",
        "id": 214222248,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603388701
    },
    {
        "content": "<p>I mean, I guess it might be but it's not the way the category theory library is set up at least</p>",
        "id": 214222270,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603388708
    },
    {
        "content": "<p>it's certainly viable for meta code to abstract over the category</p>",
        "id": 214222375,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603388752
    },
    {
        "content": "<p>even if it's a large/universe polymorphic category</p>",
        "id": 214222460,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603388771
    },
    {
        "content": "<p>Right, I meant trying to prove the theorems like <code>comp_assoc</code> for all the variants like <code>-&gt;*</code> simultaneously (or even making them all instances of the same type class or whatever).</p>",
        "id": 214222570,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603388819
    },
    {
        "content": "<p>it does seem like a good idea to focus on the concrete category case though, because almost all our examples are of that form</p>",
        "id": 214222589,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603388826
    },
    {
        "content": "<p>By simultaneously I mean in a single Lean definition</p>",
        "id": 214222599,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603388830
    },
    {
        "content": "<p>I feel like we're going back to all those discussions about universal algebra ;)</p>",
        "id": 214222641,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603388852
    },
    {
        "content": "<p>Yay!</p>",
        "id": 214222653,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603388857
    },
    {
        "content": "<p>didn't someone write a program that would do some of this? Subgroups and submonoids and other subthings?</p>",
        "id": 214222791,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603388905
    },
    {
        "content": "<p><a href=\"#narrow/stream/116395-maths/topic/Free.20stuff/near/209873309\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free.20stuff/near/209873309</a></p>",
        "id": 214223056,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603388998
    },
    {
        "content": "<p>Clearly a framework for doing this in a more ergonomic way would be good</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">homomorphism_comp</span> <span class=\"o\">(</span><span class=\"n\">struct_name</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">declaration</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"o\">(</span><span class=\"n\">params</span><span class=\"o\">,</span> <span class=\"n\">fields</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">get_parameters_and_data_fields</span> <span class=\"n\">struct_name</span><span class=\"o\">,</span>\n   <span class=\"k\">let</span> <span class=\"n\">base_type</span> <span class=\"o\">:=</span> <span class=\"n\">params.head</span><span class=\"o\">,</span>\n   <span class=\"k\">let</span> <span class=\"n\">struct_u</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span>  <span class=\"n\">expr.const</span> <span class=\"n\">struct_name</span> <span class=\"o\">[</span><span class=\"n\">level.param</span> <span class=\"bp\">`</span><span class=\"n\">u</span><span class=\"o\">],</span>\n   <span class=\"k\">let</span> <span class=\"n\">struct_v</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span>  <span class=\"n\">expr.const</span> <span class=\"n\">struct_name</span> <span class=\"o\">[</span><span class=\"n\">level.param</span> <span class=\"bp\">`</span><span class=\"n\">v</span><span class=\"o\">],</span>\n   <span class=\"k\">let</span> <span class=\"n\">struct_w</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span>  <span class=\"n\">expr.const</span> <span class=\"n\">struct_name</span> <span class=\"o\">[</span><span class=\"n\">level.param</span> <span class=\"bp\">`</span><span class=\"n\">w</span><span class=\"o\">],</span>\n   <span class=\"n\">α</span> <span class=\"bp\">←</span> <span class=\"n\">mk_local'</span> <span class=\"bp\">`</span><span class=\"n\">α</span> <span class=\"n\">binder_info.implicit</span> <span class=\"o\">(</span><span class=\"n\">sort</span> <span class=\"o\">(</span><span class=\"n\">level.succ</span> <span class=\"o\">(</span><span class=\"n\">level.param</span> <span class=\"bp\">`</span><span class=\"n\">u</span><span class=\"o\">))),</span>\n   <span class=\"n\">ia</span> <span class=\"bp\">←</span> <span class=\"n\">mk_local'</span> <span class=\"bp\">`</span><span class=\"n\">ia</span> <span class=\"n\">binder_info.inst_implicit</span> <span class=\"o\">(</span><span class=\"n\">struct_u</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n   <span class=\"n\">β</span> <span class=\"bp\">←</span> <span class=\"n\">mk_local'</span> <span class=\"bp\">`</span><span class=\"n\">β</span> <span class=\"n\">binder_info.implicit</span> <span class=\"o\">(</span><span class=\"n\">sort</span> <span class=\"o\">(</span><span class=\"n\">level.succ</span> <span class=\"o\">(</span><span class=\"n\">level.param</span> <span class=\"bp\">`</span><span class=\"n\">v</span><span class=\"o\">))),</span>\n   <span class=\"n\">ib</span> <span class=\"bp\">←</span> <span class=\"n\">mk_local'</span> <span class=\"bp\">`</span><span class=\"n\">ib</span> <span class=\"n\">binder_info.inst_implicit</span> <span class=\"o\">(</span><span class=\"n\">struct_v</span> <span class=\"n\">β</span><span class=\"o\">),</span>\n   <span class=\"n\">γ</span> <span class=\"bp\">←</span> <span class=\"n\">mk_local'</span> <span class=\"bp\">`</span><span class=\"n\">γ</span> <span class=\"n\">binder_info.implicit</span> <span class=\"o\">(</span><span class=\"n\">sort</span> <span class=\"o\">(</span><span class=\"n\">level.succ</span> <span class=\"o\">(</span><span class=\"n\">level.param</span> <span class=\"bp\">`</span><span class=\"n\">w</span><span class=\"o\">))),</span>\n   <span class=\"n\">ic</span> <span class=\"bp\">←</span> <span class=\"n\">mk_local'</span> <span class=\"bp\">`</span><span class=\"n\">ic</span> <span class=\"n\">binder_info.inst_implicit</span> <span class=\"o\">(</span><span class=\"n\">struct_w</span> <span class=\"n\">γ</span><span class=\"o\">),</span>\n   <span class=\"n\">f</span> <span class=\"bp\">←</span> <span class=\"n\">mk_local'</span> <span class=\"bp\">`</span><span class=\"n\">f</span> <span class=\"n\">binder_info.implicit</span> <span class=\"o\">(</span><span class=\"n\">pi</span> <span class=\"bp\">`</span><span class=\"n\">_x</span> <span class=\"n\">binder_info.default</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">),</span>\n   <span class=\"n\">g</span> <span class=\"bp\">←</span> <span class=\"n\">mk_local'</span> <span class=\"bp\">`</span><span class=\"n\">g</span> <span class=\"n\">binder_info.implicit</span> <span class=\"o\">(</span><span class=\"n\">pi</span> <span class=\"bp\">`</span><span class=\"n\">_x</span> <span class=\"n\">binder_info.default</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">),</span>\n   <span class=\"k\">let</span> <span class=\"n\">hom_name</span> <span class=\"o\">:=</span> <span class=\"n\">mk_simple_name</span> <span class=\"o\">(</span><span class=\"n\">string.append</span> <span class=\"n\">struct_name.to_string</span> <span class=\"s2\">\"_homomorphism\"</span><span class=\"o\">),</span>\n   <span class=\"k\">let</span> <span class=\"n\">hom_constr_name</span> <span class=\"o\">:=</span> <span class=\"n\">hom_name</span> <span class=\"bp\">&lt;.&gt;</span> <span class=\"s2\">\"mk\"</span><span class=\"o\">,</span>\n   <span class=\"n\">hom_f</span> <span class=\"bp\">←</span> <span class=\"n\">mk_app</span> <span class=\"n\">hom_name</span> <span class=\"o\">[</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">ia</span><span class=\"o\">,</span> <span class=\"n\">ib</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">],</span>\n   <span class=\"n\">hom_g</span> <span class=\"bp\">←</span> <span class=\"n\">mk_app</span> <span class=\"n\">hom_name</span> <span class=\"o\">[</span><span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"n\">ib</span><span class=\"o\">,</span> <span class=\"n\">ic</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">],</span>\n   <span class=\"n\">hf</span> <span class=\"bp\">←</span> <span class=\"n\">mk_local'</span> <span class=\"bp\">`</span><span class=\"n\">hf</span> <span class=\"n\">binder_info.default</span> <span class=\"n\">hom_f</span><span class=\"o\">,</span>\n   <span class=\"n\">hg</span> <span class=\"bp\">←</span> <span class=\"n\">mk_local'</span> <span class=\"bp\">`</span><span class=\"n\">hg</span> <span class=\"n\">binder_info.default</span> <span class=\"n\">hom_g</span><span class=\"o\">,</span>\n   <span class=\"n\">compos</span> <span class=\"bp\">←</span> <span class=\"n\">mk_mapp</span> <span class=\"bp\">`</span><span class=\"n\">function.comp</span> <span class=\"o\">[</span><span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">],</span>\n   <span class=\"n\">stmt</span> <span class=\"bp\">←</span> <span class=\"n\">mk_app</span> <span class=\"n\">hom_name</span> <span class=\"o\">[</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"n\">ia</span><span class=\"o\">,</span> <span class=\"n\">ic</span><span class=\"o\">,</span> <span class=\"n\">compos</span><span class=\"o\">],</span>\n   <span class=\"k\">let</span> <span class=\"n\">field_numbers</span> <span class=\"o\">:=</span> <span class=\"n\">list.range</span> <span class=\"n\">fields.length</span><span class=\"o\">,</span>\n   <span class=\"k\">let</span> <span class=\"n\">fields_enum</span> <span class=\"o\">:=</span> <span class=\"n\">list.zip</span> <span class=\"n\">fields</span> <span class=\"n\">field_numbers</span><span class=\"o\">,</span>\n   <span class=\"n\">compatibilities</span> <span class=\"bp\">←</span> <span class=\"n\">fields_enum.mmap</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">field_enum</span><span class=\"o\">,</span> <span class=\"n\">homomorphism_comp_part</span> <span class=\"n\">struct_name</span> <span class=\"n\">base_type</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">ia</span> <span class=\"n\">ib</span> <span class=\"n\">ic</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">hf</span> <span class=\"n\">hg</span>\n                    <span class=\"n\">field_enum.fst</span> <span class=\"n\">field_enum.snd</span> <span class=\"n\">fields_enum.length</span><span class=\"o\">),</span>\n   <span class=\"n\">constr</span> <span class=\"bp\">←</span> <span class=\"n\">mk_mapp</span> <span class=\"n\">hom_constr_name</span> <span class=\"o\">[</span><span class=\"n\">some</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">some</span> <span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"n\">some</span> <span class=\"n\">ia</span><span class=\"o\">,</span> <span class=\"n\">some</span> <span class=\"n\">ic</span><span class=\"o\">,</span> <span class=\"n\">some</span> <span class=\"n\">compos</span><span class=\"o\">],</span>\n   <span class=\"k\">let</span> <span class=\"n\">body</span> <span class=\"o\">:=</span> <span class=\"n\">expr.app_of_list</span> <span class=\"n\">constr</span> <span class=\"n\">compatibilities</span><span class=\"o\">,</span>\n   <span class=\"k\">let</span> <span class=\"n\">decl_body</span> <span class=\"o\">:=</span> <span class=\"n\">expr.lambdas</span> <span class=\"o\">[</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"n\">ia</span><span class=\"o\">,</span> <span class=\"n\">ib</span><span class=\"o\">,</span> <span class=\"n\">ic</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">]</span> <span class=\"n\">body</span><span class=\"o\">,</span>\n   <span class=\"k\">let</span> <span class=\"n\">decl_type</span> <span class=\"o\">:=</span> <span class=\"n\">expr.pis</span> <span class=\"o\">[</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"n\">ia</span><span class=\"o\">,</span> <span class=\"n\">ib</span><span class=\"o\">,</span> <span class=\"n\">ic</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">]</span> <span class=\"n\">stmt</span><span class=\"o\">,</span>\n   <span class=\"k\">let</span> <span class=\"n\">decl_name</span> <span class=\"o\">:=</span> <span class=\"n\">mk_simple_name</span> <span class=\"o\">(</span><span class=\"n\">string.append</span> <span class=\"n\">struct_name.to_string</span> <span class=\"s2\">\"_homomorphism_comp\"</span><span class=\"o\">),</span>\n   <span class=\"n\">return</span> <span class=\"bp\">$</span> <span class=\"n\">declaration.thm</span> <span class=\"n\">decl_name</span> <span class=\"o\">(</span><span class=\"n\">collect_univ_params</span> <span class=\"n\">decl_type</span><span class=\"o\">)</span> <span class=\"n\">decl_type</span> <span class=\"o\">(</span><span class=\"n\">task.pure</span> <span class=\"n\">decl_body</span><span class=\"o\">)</span>\n<span class=\"c1\">-- for any transitive target? eq, if, iff, ...</span>\n</code></pre></div>",
        "id": 214223461,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603389156
    },
    {
        "content": "<p>One possibility, similar to <code>to_additive</code>, would be to write a sort of \"sample definition\" and extract the template to instantiate from it, changing the names of constants and possibly applying a substitution but otherwise keeping things as is</p>",
        "id": 214223910,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603389347
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110193\">@Cyril Cohen</span> How hard is it to tie your algebra framework into Lean?</p>",
        "id": 214223921,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603389354
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/universes/near/214223910\">said</a>:</p>\n<blockquote>\n<p>One possibility, similar to <code>to_additive</code>, would be to write a sort of \"sample definition\" and extract the template to instantiate from it, changing the names of constants and possibly applying a substitution but otherwise keeping things as is</p>\n</blockquote>\n<p>I believe you'll find that such a tool already exists and is known as \"the C preprocessor\" <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 214224676,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603389657
    },
    {
        "content": "<p>I guess stuff like \"preserves the algebraic structure\" needs to iterate over a variable number of operations (e.g. <code>+</code>, <code>*</code> or both)</p>",
        "id": 214224924,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603389740
    },
    {
        "content": "<p>But the proof of <code>ext_iff</code> doesn't care about algebraic structure. And neither does <code>comp_assoc</code>, nor does <code>comp_id</code> or <code>id_apply</code>.</p>",
        "id": 214225057,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603389803
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>lemma one_hom.to_fun_eq_coe\nlemma one_hom.coe_mk\nlemma one_hom.coe_inj\nlemma one_hom.ext\nlemma one_hom.ext_iff\nlemma one_hom.id_apply\nlemma one_hom.comp_apply\nlemma one_hom.comp_assoc\nlemma one_hom.cancel_right\nlemma one_hom.cancel_left\nlemma one_hom.comp_id\nlemma one_hom.id_comp\n</code></pre></div>\n\n<p>this is what I extracted about <code>one_hom</code>s</p>\n<p>The proofs don't use any properties of <code>one_hom</code>, except that it behaves like a function.<br>\nIt's all <code>rfl</code> or <code>cases, cases, congr</code> or some generic logic lemmas.</p>",
        "id": 214226554,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603390427
    },
    {
        "content": "<p>The list is incomplete, because things like <code>funext</code> and <code>congr_arg</code> are missing.</p>",
        "id": 214226627,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603390447
    },
    {
        "content": "<p>Right, so while I think it's probably better to autogenerate these lemmas at the same time as we autogenerate the rest of the theory of <code>has_one</code>s and <code>sub_has_one</code>s and so on, I claim you don't need any fancy universe polymorphism to implement <code>one_hom.comp_assoc</code>, say, in terms of ingredients that say that \"taking the underlying function\" is injective and commutes with composition.</p>",
        "id": 214227530,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603390824
    },
    {
        "content": "<p>I'm not really sure, though.</p>",
        "id": 214227603,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603390872
    },
    {
        "content": "<p>Could those particular lemmas be written in terms of a <code>has_to_fun</code> typeclass?</p>",
        "id": 214227844,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603391002
    },
    {
        "content": "<p>Which provides <code>has_coe_to_fun</code> in term of the member</p>",
        "id": 214228005,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603391074
    },
    {
        "content": "<p>Right, I would just start with things like <code>class has_comp (a b : Type) (c : out_param Type)</code> and compatibility classes and see whether that's good enough</p>",
        "id": 214228131,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603391146
    },
    {
        "content": "<p>So I'm trying something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">),</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_faithful_coe_to_fun</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_faithful</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">coe</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">coe</span> <span class=\"n\">g</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">has_faithful_coe_to_fun</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">has_faithful_coe_to_fun</span> <span class=\"n\">hom</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">,</span><span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">coe</span> <span class=\"n\">f</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">ext</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">is_faithful</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">has_faithful_coe_to_fun</span>\n</code></pre></div>",
        "id": 214228620,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603391336
    },
    {
        "content": "<p>But I'm getting an error at <code>ext</code> saying <code>only constants and Pi types are supported: hom α β</code>.</p>",
        "id": 214228895,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603391437
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/universes/near/214224676\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/universes/near/214223910\">said</a>:</p>\n<blockquote>\n<p>One possibility, similar to <code>to_additive</code>, would be to write a sort of \"sample definition\" and extract the template to instantiate from it, changing the names of constants and possibly applying a substitution but otherwise keeping things as is</p>\n</blockquote>\n<p>I believe you'll find that such a tool already exists and is known as \"the C preprocessor\" <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>\n</blockquote>\n<p>You know, we have something that is just as flexible/hackish as the C preprocessor: <code>emit_code_here</code></p>",
        "id": 214229033,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603391507
    },
    {
        "content": "<p>that's definitely one way to make theory templates, just do string replacement in a big code block in quotes</p>",
        "id": 214229161,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603391559
    },
    {
        "content": "<p>plus, unlike the tactic approach, it actually lets you write <code>def</code>s that are just as good as the real thing</p>",
        "id": 214229308,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603391641
    },
    {
        "content": "<p>How do you use it? Can I just write the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">run_cmd</span> <span class=\"n\">emit_code_here</span> <span class=\"s2\">\"def foo := 1\"</span>\n</code></pre></div>",
        "id": 214229509,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603391740
    },
    {
        "content": "<p>Can we use this: <a href=\"#narrow/stream/113488-general/topic/Generate.20homomorphism.20types.20for.20algebraic.20structures/\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generate.20homomorphism.20types.20for.20algebraic.20structures/</a> ?</p>",
        "id": 214229852,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603391883
    },
    {
        "content": "<p>huh, I guess we need a <code>run_parser</code> command to make this easier</p>",
        "id": 214230078,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603391994
    },
    {
        "content": "<p>There must be some <code>tactic unit</code> that takes a parser and runs it no?</p>",
        "id": 214230207,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603392035
    },
    {
        "content": "<p>I have absolutely no idea what I'm doing... Can I make this work?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[user_command]</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">add_thing</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">interactive.parse</span> <span class=\"bp\">$</span> <span class=\"n\">lean.parser.tk</span> <span class=\"s2\">\"add_thing\"</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">lean.parser</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">s</span> <span class=\"bp\">←</span> <span class=\"n\">lean.parser.ident</span><span class=\"o\">,</span>\n  <span class=\"n\">lean.parser.emit_code_here</span> <span class=\"o\">(</span><span class=\"n\">to_string</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 214231973,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603392846
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.core</span>\n\n<span class=\"kd\">@[user_command]</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">add_thing</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">interactive.parse</span> <span class=\"bp\">$</span> <span class=\"n\">lean.parser.tk</span> <span class=\"s2\">\"add_thing\"</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">lean.parser</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">s</span> <span class=\"bp\">←</span> <span class=\"n\">lean.parser.ident</span><span class=\"o\">,</span>\n  <span class=\"n\">lean.parser.emit_code_here</span> <span class=\"o\">(</span><span class=\"n\">to_string</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"bp\">.</span>\n\n<span class=\"n\">add_thing</span> <span class=\"bp\">«</span><span class=\"k\">#check</span> <span class=\"mi\">5</span><span class=\"bp\">»</span>\n</code></pre></div>",
        "id": 214232401,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603393058
    },
    {
        "content": "<p>Oh, the <code>.</code> is necessary?</p>",
        "id": 214232452,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603393078
    },
    {
        "content": "<p>Well <code>add_thing</code> isn't a user command until the declaration ends, and if <code>add_thing</code> is not a user command then writing it will not end the declaration.</p>",
        "id": 214232548,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603393104
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">tactic</span> <span class=\"n\">lean.parser</span> <span class=\"n\">interactive</span> <span class=\"n\">interactive.types</span>\n<span class=\"kd\">@[user_command]</span> <span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">run_parser_cmd</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"bp\">$</span> <span class=\"n\">tk</span> <span class=\"s2\">\"run_parser\"</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">lean.parser</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">lean.parser.pexpr</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">tactic.to_expr</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n  <span class=\"n\">p</span> <span class=\"bp\">←</span> <span class=\"n\">eval_expr</span> <span class=\"o\">(</span><span class=\"n\">lean.parser</span> <span class=\"n\">unit</span><span class=\"o\">)</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n  <span class=\"n\">p.</span>\n\n<span class=\"n\">run_parser</span> <span class=\"n\">emit_code_here</span> <span class=\"s2\">\"def foo := 1\"</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">foo</span>\n</code></pre></div>",
        "id": 214232554,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603393106
    },
    {
        "content": "<p>You could also put any other command in between.</p>",
        "id": 214232637,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603393149
    },
    {
        "content": "<p>Like I said, I really had no idea what I was doing. That's the first piece of <code>meta</code> code I've even tried to write.</p>",
        "id": 214232707,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603393175
    },
    {
        "content": "<p>I don't know if it's what you intended but I'm amused at the idea of writing entire Lean definitions inside <code>«...»</code>.</p>",
        "id": 214232747,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603393191
    },
    {
        "content": "<p>oh, you are using ident quoting? That's an interesting way to get highlighting</p>",
        "id": 214232888,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603393230
    },
    {
        "content": "<p>It's not highlighting in vscode</p>",
        "id": 214232948,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603393258
    },
    {
        "content": "<p>it doesn't give the correct highlighting in emacs though, does it work well in ...</p>",
        "id": 214232963,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603393264
    },
    {
        "content": "<p>it also doesn't work with newlines apparently</p>",
        "id": 214232976,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603393272
    },
    {
        "content": "<p>ok well at least it works in Zulip! <span aria-label=\"octopus\" class=\"emoji emoji-1f419\" role=\"img\" title=\"octopus\">:octopus:</span></p>",
        "id": 214232985,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603393278
    },
    {
        "content": "<p>oh, no newlines is bad</p>",
        "id": 214233006,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603393291
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">run_parser</span> <span class=\"n\">emit_code_here</span> <span class=\"bp\">«</span>\n  <span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">»</span>\n<span class=\"c1\">-- error: illegal character in escaped identifier</span>\n</code></pre></div>",
        "id": 214233008,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603393291
    },
    {
        "content": "<p>I don't suppose there's a <code>parser</code> for an entire top-level command?</p>",
        "id": 214233286,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603393405
    },
    {
        "content": "<p>this also doesn't seem to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">run_parser</span> <span class=\"n\">emit_code_here</span> <span class=\"s2\">\"</span>\n<span class=\"s2\">  def foo := 1</span>\n<span class=\"s2\">\"</span>\n</code></pre></div>\n\n<p>something funny happens when the last <code>\"</code> is not indented</p>",
        "id": 214233289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603393406
    },
    {
        "content": "<p>there is</p>",
        "id": 214233320,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603393419
    },
    {
        "content": "<p><code>command_like</code></p>",
        "id": 214233330,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603393424
    },
    {
        "content": "<p>can you get the source string out?</p>",
        "id": 214233340,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603393430
    },
    {
        "content": "<p><code>meta constant command_like : parser unit</code></p>",
        "id": 214233441,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603393461
    },
    {
        "content": "<p>no, it executes on the spot</p>",
        "id": 214233450,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603393466
    },
    {
        "content": "<p>doesn't seem <em>entirely</em> helpful</p>",
        "id": 214233464,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603393473
    },
    {
        "content": "<p>ah, I see</p>",
        "id": 214233473,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603393477
    },
    {
        "content": "<p>it's actually the way <code>emit_code_here</code> works</p>",
        "id": 214233501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603393488
    },
    {
        "content": "<p>it's just <code>with_input command_like</code></p>",
        "id": 214233532,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603393500
    },
    {
        "content": "<p>It would be slick if instead of doing any quoting at all like <code>foo \"def ...\"</code>, you could just write <code>foo def ...</code></p>",
        "id": 214233598,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603393529
    },
    {
        "content": "<p>Anyone have any idea why the <code>faithful_has_coe_to_fun</code> a little ways above didn't work? It seems unfortunate to have to resort to code generation to define basic stuff about morphisms, where we don't have to do so for structures</p>",
        "id": 214233625,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603393545
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/universes/near/214233625\">said</a>:</p>\n<blockquote>\n<p>Anyone have any idea why the <code>faithful_has_coe_to_fun</code> a little ways above didn't work? It seems unfortunate to have to resort to code generation to define basic stuff about morphisms, where we don't have to do so for structures</p>\n</blockquote>\n<p>I think it has to do with the <code>@[ext]</code> attribute itself.</p>",
        "id": 214233726,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603393576
    },
    {
        "content": "<p>Do you mean the error about <code>ext</code>?</p>",
        "id": 214233727,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603393576
    },
    {
        "content": "<p><code>ext</code> expects the lemmas to have a certain form, kind of like <code>simp</code></p>",
        "id": 214233783,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603393604
    },
    {
        "content": "<p><code>hom</code> is a variable, not a constant</p>",
        "id": 214233870,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603393655
    },
    {
        "content": "<p>Ah, so we'd need code generation at least for populating <code>ext</code> attributes</p>",
        "id": 214234023,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603393704
    },
    {
        "content": "<p>Or we could change how <code>ext</code> works. But I think doing code generation is preferable anyways.</p>",
        "id": 214234082,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603393731
    },
    {
        "content": "<p>yeah, right now this string interpolation approach seems better than alternatives, even for the more complex use cases with a variable number of operations</p>",
        "id": 214234217,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603393803
    },
    {
        "content": "<p>in fact it might not even be horrible looking if you use <code>format!</code></p>",
        "id": 214234303,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603393841
    },
    {
        "content": "<p>which I don't find enough uses for</p>",
        "id": 214234326,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603393850
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">run_parser</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"s2\">\"bar\"</span><span class=\"o\">,</span>\n  <span class=\"n\">emit_code_here</span> <span class=\"o\">(</span><span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">\"</span>\n<span class=\"s2\">    def {foo} := 1</span>\n<span class=\"s2\">    \"</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_string</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">bar</span>\n</code></pre></div>",
        "id": 214234525,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603393944
    },
    {
        "content": "<p>Does lean have something like python's multiline strings with <code>\"\"\"</code>?</p>",
        "id": 214235369,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603394297
    },
    {
        "content": "<p>Or can I just write multiline strings with <code>\"</code>?</p>",
        "id": 214235476,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603394357
    },
    {
        "content": "<p>Cool. It's strange about the indentation of <code>\"</code>, in Mario's comment above.</p>",
        "id": 214235574,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603394397
    },
    {
        "content": "<p>Looks like it's about the final newline.<br>\nE.g. this works</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">str</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"o\">:=</span>\n<span class=\"s2\">\"</span>\n<span class=\"s2\">def foo := 1</span>\n<span class=\"s2\">def bar := 2\"</span>\n\n<span class=\"n\">run_parser</span> <span class=\"n\">emit_code_here</span> <span class=\"n\">str</span>\n</code></pre></div>",
        "id": 214235797,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603394498
    },
    {
        "content": "<p>But this doesn't (or at least it looks like <code>run_parser</code> loops forever)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">str</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"o\">:=</span>\n<span class=\"s2\">\"</span>\n<span class=\"s2\">def foo := 1</span>\n<span class=\"s2\">def bar := 2</span>\n<span class=\"s2\">\"</span>\n\n<span class=\"n\">run_parser</span> <span class=\"n\">emit_code_here</span> <span class=\"n\">str</span>\n</code></pre></div>",
        "id": 214235822,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603394513
    },
    {
        "content": "<p><code>run_parser</code> PR'd in <a href=\"https://github.com/leanprover-community/mathlib/issues/4745\">#4745</a></p>",
        "id": 214236277,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603394707
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">run_parser</span> <span class=\"n\">emit_code_here</span> <span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span> <span class=\"c1\">-- loops</span>\n</code></pre></div>",
        "id": 214236466,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603394802
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">run_parser</span> <span class=\"k\">do</span> <span class=\"n\">with_input</span> <span class=\"n\">command_like</span> <span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"o\">,</span> <span class=\"n\">pure</span> <span class=\"o\">()</span> <span class=\"c1\">-- no loop</span>\n</code></pre></div>",
        "id": 214236578,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603394865
    },
    {
        "content": "<p>I guess we could make a new function <code>emit_code_here'</code> which removes trailing newlines</p>",
        "id": 214236580,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603394865
    },
    {
        "content": "<p>Oh I see:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">emit_code_here</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"n\">lean.parser</span> <span class=\"n\">unit</span>\n<span class=\"bp\">|</span> <span class=\"n\">str</span> <span class=\"o\">:=</span> <span class=\"k\">do</span> <span class=\"n\">left</span> <span class=\"bp\">←</span> <span class=\"n\">emit_command_here</span> <span class=\"n\">str</span><span class=\"o\">,</span>\n            <span class=\"k\">if</span> <span class=\"n\">left.length</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"o\">()</span>\n            <span class=\"k\">else</span> <span class=\"n\">emit_code_here</span> <span class=\"n\">left</span>\n</code></pre></div>\n\n<p>this has no termination condition</p>",
        "id": 214236721,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603394926
    },
    {
        "content": "<p>It should check that <code>left.length &lt; str.length</code></p>",
        "id": 214236761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603394954
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/4746\">#4746</a></p>",
        "id": 214237950,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603395493
    },
    {
        "content": "<p>Already failing CI...</p>",
        "id": 214238013,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603395527
    },
    {
        "content": "<blockquote>\n<p>I don't always test my code, but when I do, I do it in production.</p>\n</blockquote>\n<p>-- Mario's shirt</p>",
        "id": 214239047,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603396049
    },
    {
        "content": "<p>Hm, I wasn't really planning on using <code>run_parser</code> to actually parse something in the source, but it is possible:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">run_parser</span> <span class=\"k\">do</span> <span class=\"c1\">-- 4</span>\n  <span class=\"n\">tk</span> <span class=\"s2\">\".\"</span><span class=\"o\">,</span>\n  <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">texpr</span><span class=\"o\">,</span>\n  <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">to_expr</span> <span class=\"n\">e</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">eval_expr</span> <span class=\"n\">ℕ</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">trace</span><span class=\"o\">)</span>\n<span class=\"bp\">.</span>\n<span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span>\n</code></pre></div>",
        "id": 214243961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603398532
    },
    {
        "content": "<p>unfortunately parsers can't parse command keywords like <code>def</code> so this isn't quite what reid was looking for</p>",
        "id": 214244121,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603398604
    },
    {
        "content": "<p>This is fun!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">monoid_stuff</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">string</span> <span class=\"bp\">×</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[(</span><span class=\"s2\">\"mul\"</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">),(</span><span class=\"s2\">\"one\"</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mk_op_str_aux</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">string</span>\n<span class=\"bp\">|</span> <span class=\"n\">nat.zero</span> <span class=\"o\">:=</span> <span class=\"n\">s</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">s</span> <span class=\"bp\">++</span> <span class=\"s2\">\" → \"</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">mk_op_str_aux</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mk_op_str</span> <span class=\"o\">(</span><span class=\"n\">nn</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"o\">:=</span> <span class=\"n\">nn</span> <span class=\"bp\">++</span> <span class=\"s2\">\" : \"</span> <span class=\"bp\">++</span> <span class=\"n\">mk_op_str_aux</span> <span class=\"n\">s</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mk_class_str_aux</span> <span class=\"o\">(</span><span class=\"n\">nn</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">string</span> <span class=\"bp\">×</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">string</span>\n<span class=\"bp\">|</span> <span class=\"n\">list.nil</span> <span class=\"o\">:=</span> <span class=\"s2\">\"\"</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">list.cons</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">( \"</span> <span class=\"bp\">++</span> <span class=\"n\">mk_op_str</span> <span class=\"n\">hd.1</span> <span class=\"n\">nn</span> <span class=\"n\">hd.2</span> <span class=\"bp\">++</span> <span class=\"s2\">\" )\"</span> <span class=\"bp\">++</span> <span class=\"n\">mk_class_str_aux</span> <span class=\"n\">tl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mk_class_str</span> <span class=\"o\">(</span><span class=\"n\">class_name</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">string</span> <span class=\"bp\">×</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">string</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">ls</span><span class=\"o\">,</span> <span class=\"s2\">\"class \"</span> <span class=\"bp\">++</span> <span class=\"n\">class_name</span> <span class=\"bp\">++</span> <span class=\"s2\">\" (α : Type*) :=\"</span> <span class=\"bp\">++</span> <span class=\"n\">mk_class_str_aux</span> <span class=\"s2\">\"α\"</span> <span class=\"n\">ls</span>\n\n<span class=\"n\">run_parser</span> <span class=\"n\">emit_code_here</span> <span class=\"o\">(</span><span class=\"n\">mk_class_str</span> <span class=\"s2\">\"raw_monoid\"</span> <span class=\"n\">monoid_stuff</span><span class=\"o\">)</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">raw_monoid</span>\n</code></pre></div>",
        "id": 214247264,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603400269
    },
    {
        "content": "<p>Ah, but I get a \"deep recursion\" error if I try to define a typeclass with a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>10000</mn></mrow><annotation encoding=\"application/x-tex\">10000</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>-ary operation.</p>",
        "id": 214248786,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603401102
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3679</mn></mrow><annotation encoding=\"application/x-tex\">3679</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mord\">6</span><span class=\"mord\">7</span><span class=\"mord\">9</span></span></span></span>-ary operations are okay though</p>",
        "id": 214248859,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603401131
    },
    {
        "content": "<p>Well, hopefully Lean 4 will let us supoport 3680-ary operations</p>",
        "id": 214248997,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603401237
    },
    {
        "content": "<p>It's a bit slow for some reason, but this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">monoid_stuff</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">string</span> <span class=\"bp\">×</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[(</span><span class=\"s2\">\"mul\"</span><span class=\"o\">,</span><span class=\"mi\">10000</span><span class=\"o\">),(</span><span class=\"s2\">\"one\"</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">arity</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span>\n<span class=\"bp\">|</span> <span class=\"n\">nat.zero</span> <span class=\"o\">:=</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">arity</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">mk_class_str_aux</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">string</span> <span class=\"bp\">×</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">string</span>\n<span class=\"bp\">|</span> <span class=\"n\">list.nil</span> <span class=\"o\">:=</span> <span class=\"s2\">\"\"</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">list.cons</span> <span class=\"o\">(</span><span class=\"n\">nn</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">tl</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">({nn} : arity {s} {to_string n})\"</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_string</span> <span class=\"bp\">++</span> <span class=\"n\">mk_class_str_aux</span> <span class=\"n\">tl</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">mk_class_str</span> <span class=\"o\">(</span><span class=\"n\">class_name</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">string</span> <span class=\"bp\">×</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">string</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">ls</span><span class=\"o\">,</span> <span class=\"s2\">\"class \"</span> <span class=\"bp\">++</span> <span class=\"n\">class_name</span> <span class=\"bp\">++</span> <span class=\"s2\">\" (α : Type*) :=\"</span> <span class=\"bp\">++</span> <span class=\"n\">mk_class_str_aux</span> <span class=\"s2\">\"α\"</span> <span class=\"n\">ls</span>\n\n<span class=\"n\">run_parser</span> <span class=\"n\">emit_code_here</span> <span class=\"o\">(</span><span class=\"n\">mk_class_str</span> <span class=\"s2\">\"raw_monoid\"</span> <span class=\"n\">monoid_stuff</span><span class=\"o\">)</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">raw_monoid</span>\n</code></pre></div>",
        "id": 214250956,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603402376
    },
    {
        "content": "<p>Oh interesting. So the the deep recursion is only a problem when you generate a large string, and not when you generate a long type expression</p>",
        "id": 214251099,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603402464
    },
    {
        "content": "<p>This <code>arity</code> type is in  mathlib somewhere...</p>",
        "id": 214251130,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603402489
    },
    {
        "content": "<p>no, the deep recursion isn't for the string, it's for the parsing of the notation <code>A -&gt; A -&gt; A -&gt; ... -&gt; A</code></p>",
        "id": 214251143,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603402500
    },
    {
        "content": "<p>Oh ok</p>",
        "id": 214251158,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603402510
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/arity\">docs#arity</a></p>",
        "id": 214251178,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603402527
    },
    {
        "content": "<p>although I think that you can also get into deep recursion trouble when constructing the strings too</p>",
        "id": 214251210,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603402557
    },
    {
        "content": "<p>or at least quadratic behavior</p>",
        "id": 214251257,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603402567
    },
    {
        "content": "<p>you should probably stick to the iterated arrows instead of arity though, since it requires unfolding at point of use</p>",
        "id": 214251338,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603402659
    },
    {
        "content": "<p>Ooh, I had another idea...</p>",
        "id": 214251436,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603402700
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">monoid_stuff</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">string</span> <span class=\"bp\">×</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[(</span><span class=\"s2\">\"mul\"</span><span class=\"o\">,</span><span class=\"mi\">10000</span><span class=\"o\">),(</span><span class=\"s2\">\"one\"</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">arity</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">pexpr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">α</span> <span class=\"bp\">←</span> <span class=\"n\">to_expr</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n  <span class=\"n\">tactic.exact</span> <span class=\"bp\">$</span> <span class=\"o\">(</span><span class=\"n\">expr.pi</span> <span class=\"bp\">`</span><span class=\"n\">_x</span> <span class=\"n\">binder_info.default</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">mk_class_str_aux</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">string</span> <span class=\"bp\">×</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">string</span>\n<span class=\"bp\">|</span> <span class=\"n\">list.nil</span> <span class=\"o\">:=</span> <span class=\"s2\">\"\"</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">list.cons</span> <span class=\"o\">(</span><span class=\"n\">nn</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">tl</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">(\"</span> <span class=\"bp\">++</span> <span class=\"n\">nn</span> <span class=\"bp\">++</span> <span class=\"s2\">\" : by arity ```(\"</span> <span class=\"bp\">++</span> <span class=\"n\">s</span> <span class=\"bp\">++</span> <span class=\"s2\">\") \"</span> <span class=\"bp\">++</span> <span class=\"n\">to_string</span> <span class=\"n\">n</span> <span class=\"bp\">++</span> <span class=\"s2\">\")\"</span> <span class=\"bp\">++</span> <span class=\"n\">mk_class_str_aux</span> <span class=\"n\">tl</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">mk_class_str</span> <span class=\"o\">(</span><span class=\"n\">class_name</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">string</span> <span class=\"bp\">×</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">string</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">ls</span><span class=\"o\">,</span> <span class=\"s2\">\"class \"</span> <span class=\"bp\">++</span> <span class=\"n\">class_name</span> <span class=\"bp\">++</span> <span class=\"s2\">\" (α : Type*) :=\"</span> <span class=\"bp\">++</span> <span class=\"n\">mk_class_str_aux</span> <span class=\"s2\">\"α\"</span> <span class=\"n\">ls</span>\n\n<span class=\"n\">run_parser</span> <span class=\"n\">emit_code_here</span> <span class=\"o\">(</span><span class=\"n\">mk_class_str</span> <span class=\"s2\">\"raw_monoid\"</span> <span class=\"n\">monoid_stuff</span><span class=\"o\">)</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">raw_monoid</span>\n</code></pre></div>",
        "id": 214252331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603403315
    },
    {
        "content": "<p>it times out, unfortunately. I think it's getting stuck somewhere in the aux defs of the structure</p>",
        "id": 214252422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603403384
    },
    {
        "content": "<p>it's a metametametaprogram</p>",
        "id": 214252685,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603403541
    },
    {
        "content": "<p>That's cool, even just to be able to write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">arity</span> <span class=\"bp\">```</span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"mi\">3</span>\n<span class=\"k\">#print</span> <span class=\"n\">fo</span>\n</code></pre></div>",
        "id": 214252773,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603403619
    },
    {
        "content": "<p>it makes the parser's job easier here, since there are no long chains in the source text</p>",
        "id": 214252877,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603403668
    },
    {
        "content": "<p>I think lean still has to go through them all when dealing with the exprs later in elaboration and typechecking</p>",
        "id": 214252928,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603403701
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">arity</span> <span class=\"bp\">```</span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"mi\">24525</span>\n</code></pre></div>\n\n<p>Lean is happy with that, but not with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>24526</mn></mrow><annotation encoding=\"application/x-tex\">24526</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mord\">5</span><span class=\"mord\">2</span><span class=\"mord\">6</span></span></span></span>.</p>",
        "id": 214253102,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603403831
    },
    {
        "content": "<p>to be fair, if you have a structure with a 24526-ary operation then perhaps you would rather generalize to <code>n</code>-ary</p>",
        "id": 214253288,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603403963
    },
    {
        "content": "<p>Ping <span class=\"user-mention\" data-user-id=\"315523\">@Colter MacDonald</span></p>",
        "id": 214260166,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603409762
    },
    {
        "content": "<p>Type theory/logic noob here. We currently cannot state universe restrictions. And I understand that this is a box of pandora. We want equality of expressions of universe levels to be decidable. However, since the theory of linearly ordered abelian groups is decidable, I was wondering whether it is possible to add <code>u &lt; v</code> constraints to the theory of universe levels and still have a system that works well in practice.<br>\nI guess this would mean that the kernel might need to run some version of <code>omega</code> during typechecking, which is maybe not very performant/practical. On the other hand, 99% of the time, we would be inside the current fragment of universe logic. So maybe it can be made to work.</p>\n<p>Being able to write <code>u &lt; v</code> or <code>u ≤ v</code> constraints would be really useful for statements in category theory.</p>",
        "id": 273327630,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1645864643
    },
    {
        "content": "<p>We basically can already write <code>u ≤ v</code> and <code>u &lt; v</code> because <code>u ≤ max u w</code> and <code>u &lt; max (u+1) w</code> so you can let <code>v = max u w</code> or <code>v = max (u+1) w</code>.</p>",
        "id": 273329880,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1645867845
    },
    {
        "content": "<p>Yes, that's a very good point. But these expressions can potentially get quite complicated, right? This is the approach that we recently started using in the category theory library. We'll have to find out how far we can push it in practice.</p>",
        "id": 273340836,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1645882267
    },
    {
        "content": "<p>Didn't we already see this failing earlier this week? Lean failed to unify <code>max u v = max v ?m_1</code></p>",
        "id": 273343769,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1645885691
    }
]
[
    {
        "content": "<p>The perfectoid project currently compiles fine, according to Travis, but if I try it in VS Code I get deterministic timeouts! I have traced the issue back to VS Code feeding <code>-T100000</code> to Lean (maximum number of memory allocations per task), but Travis not doing this. </p>\n<p>If I have code which is timing out with <code>-T100000</code> does this indicate that something is wrong with the code? Before, we had timeout issues which were fixed by making arbitrary universe changes. Maybe I'll try this now, but in general I am not sure what this means. I've seen my code give typeclass inference errors which could be fixed by changing the max depth, but this is the first time I've seen a timeout issue which could be fixed by changing the parameters.</p>",
        "id": 165472346,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557680333
    },
    {
        "content": "<p>Oh, I definitely get this when I let tactics go berserk. It's usually solved by splitting things into smaller lemmas.</p>",
        "id": 165486652,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1557703949
    },
    {
        "content": "<p>I have managed to tame the timeouts but I don't think it's a tactic issue.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">presheaf_map</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"o\">(</span><span class=\"n\">spa</span> <span class=\"n\">A</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">hUV</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">≤</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">presheaf_value</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">presheaf_value</span> <span class=\"n\">U</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">rd</span><span class=\"o\">,</span>\n<span class=\"k\">let</span> <span class=\"n\">TEMP</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"k\">in</span> <span class=\"n\">TEMP</span> <span class=\"bp\">⟨</span><span class=\"n\">rd</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">rd</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">hUV</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n<span class=\"c1\">--  f.val ⟨rd.val, set.subset.trans rd.2 hUV⟩, -- this times out with lean -T100000</span>\n<span class=\"bp\">λ</span> <span class=\"n\">rd1</span> <span class=\"n\">rd2</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"c1\">-- I do not particularly want to go into tactic mode right now</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">TEMP2</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">rational_open_data_subsets</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">hUV</span> <span class=\"n\">rd1</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">rational_open_data_subsets</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">hUV</span> <span class=\"n\">rd2</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">TEMP2</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- exact f.2 (rational_open_data... times out</span>\n  <span class=\"c1\">-- convert f.2 (rational_open_data... works</span>\n<span class=\"kn\">end</span><span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p>This should be a purely term mode proof. The first problem is that <code> f.val ⟨rd.val, set.subset.trans rd.2 hUV⟩</code> times out when applied directly; this <code>let</code> hack fixes the first timeout. The second timeout I solve in tactic mode (it's a prop) but it's the same story; a term should work, but <code>exact</code> fails and it's only <code>convert</code> or the <code>let</code> which save us. A <code>convert</code> can be used with the first timeout too, but this causes errors later in the file for some reason.</p>\n<p>I would like to debug this further. I do not know what is going on at all. If this is happening because we have written bad code then I'd like to write better code but I don't know which code is bad. If this is happening because of some other reason I'd still  like to know what is going on. I feel a bit helpless at the minute; I have no understanding why the first <code>let</code> changes anything. <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> can either of you make some educated guesses about what is happening?</p>\n<p>A completely compiled version of the perfectoid project, all the olean files, with current mathlib master, is available here:</p>\n<p><a href=\"http://wwwf.imperial.ac.uk/~buzzard/xena/perfectoid_20190513.tar\" target=\"_blank\" title=\"http://wwwf.imperial.ac.uk/~buzzard/xena/perfectoid_20190513.tar\">wwwf.imperial.ac.uk/~buzzard/xena/perfectoid_20190513.tar</a></p>\n<p>If you download this, and run <code>lean --make</code> in <code>src</code> the command returns very quickly with no output. The project is all compiled and all fine. Now open it in VS Code and in <code>src/Spa.lean</code> on line 720 there is a timeout, which can be fixed by changing -T100000 to a higher value in VS Code settings. Lean is working far too hard to compile this lemma. Changing <code>f.val ⟨rd.val, set.subset.trans rd.2 hUV⟩, </code> to <code>let TEMP := f.val in TEMP ⟨rd.val, set.subset.trans rd.2 hUV⟩,</code> fixes everything.</p>",
        "id": 165514559,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557742216
    },
    {
        "content": "<p>what is the type of <code>TEMP</code>?</p>",
        "id": 165514653,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557742339
    },
    {
        "content": "<p>and <code>f</code> and <code>⟨rd.val, set.subset.trans rd.2 hUV⟩</code></p>",
        "id": 165514669,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557742377
    },
    {
        "content": "<p>Here's a working term mode proof:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">presheaf_map</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"o\">(</span><span class=\"n\">spa</span> <span class=\"n\">A</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">hUV</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">≤</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_value</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_value</span> <span class=\"n\">U</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">rd1</span> <span class=\"n\">rd2</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">rational_open_data_subsets</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">hUV</span> <span class=\"n\">rd1</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">rational_open_data_subsets</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">hUV</span> <span class=\"n\">rd2</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n</pre></div>",
        "id": 165515200,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557742909
    },
    {
        "content": "<p>But what's going on? How is (blah : _) any different to blah?</p>",
        "id": 165515549,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557743222
    },
    {
        "content": "<p>This is my actual question. Is the point that your code is somehow better than my code in some intrinsic way -- I should never have written my code the way I wrote it? Or is the problem that I have made some ghastly types and the fact that they're difficult to manipulate is my fault and something should be changed? Or is the problem that Lean is not very good at something and you know how to work around the deficiency? What is actually happening?</p>",
        "id": 165515674,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557743355
    },
    {
        "content": "<p><code>(blah : _)</code> says \"ignore the expected type here, figure out the type of blah first and then unify with the goal\"</p>",
        "id": 165515681,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557743359
    },
    {
        "content": "<p>But doesn't <code>(blah)</code> also say that?</p>",
        "id": 165515702,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557743397
    },
    {
        "content": "<p><code>blah</code> says \"use the expected type to elaborate <code>blah</code>\"</p>",
        "id": 165515774,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557743416
    },
    {
        "content": "<p>usually this is a good thing, but occasionally it gives a bad result</p>",
        "id": 165515798,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557743436
    },
    {
        "content": "<p>Aah. So the elaboration process of a term usually takes the type of this term into account, and this is a workaround to stop it doing this?</p>",
        "id": 165515828,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557743469
    },
    {
        "content": "<p>Running Lean with -T200000 succeeds, by the way -- so everything is consistent; this is just, for some reason, a way of making Lean succeed quicker.</p>",
        "id": 165515858,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557743520
    },
    {
        "content": "<p>I think I figured out the problem (and I guess you could class it as \"lean is not very good at something\"). If I start with</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">presheaf_map</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"o\">(</span><span class=\"n\">spa</span> <span class=\"n\">A</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">hUV</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">≤</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_value</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_value</span> <span class=\"n\">U</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">rd</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"bp\">_⟩</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>I see that the goal has type <code>r_o_d_completion (rd.val)</code>, and the <code>have</code> has type <code>Π (rd : rational_open_data_subsets V), r_o_d_completion (rd.val)</code>. The obvious solution is to plug <code>rd</code> into <code>f.val</code> but this doesn't work because <code>rd : rational_open_data_subsets U</code> instead</p>",
        "id": 165515926,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557743558
    },
    {
        "content": "<p>I am deeply sorry about <code>r_o_d_completion</code> by the way. I got sick of typing <code>rational_open_data</code>. It's on my job list to change it to something more sensible.</p>",
        "id": 165515965,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557743625
    },
    {
        "content": "<p>But the problem is that when you use <code>refine f.val _</code> here lean thinks \"okay, let's make <code>r_o_d_completion (rd.val) =?= r_o_d_completion (?m.val)</code>. I know, let's try to make all the arguments to <code>r_o_d_completion</code> the same and <code>rd =?= ?m</code>. So I have to prove <code>rational_open_data_subsets U =?= rational_open_data_subsets V</code>.\" Lean then gets lost unfolding your tower of definitions, hoping that U doesn't actually appear in the definition so that <code>rational_open_data_subsets U</code> is defeq to <code>rational_open_data_subsets V</code></p>",
        "id": 165516047,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557743713
    },
    {
        "content": "<blockquote>\n<p>but this doesn't work because <code>rd : rational_open_data_subsets U</code> instead</p>\n</blockquote>\n<p>Right, that's what all the <code>set.subset.trans rd.2 hUV</code> is about.</p>",
        "id": 165516049,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557743715
    },
    {
        "content": "<p>Oh you have maybe completely debugged this. Many thanks as ever! Did you use some trace tools or was this just pure thought? I think it is worth my while thinking about what you're saying here. This is a trick I don't know yet.</p>",
        "id": 165516117,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557743772
    },
    {
        "content": "<p>This is often the place where the <code>:_</code> trick works</p>",
        "id": 165516133,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557743806
    },
    {
        "content": "<p>I usually see this when you use <code>congr_arg</code>, which is another place where the heuristic <code>f x =?= g y =&gt; f =?= g /\\ x =?= y</code> leads lean astray</p>",
        "id": 165516170,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557743858
    },
    {
        "content": "<p>I knew the maths I was formalising in the project (although as Patrick pointed out I didn't know all of the details in several places), but the timeouts were scary.  Before we finished the project I was sometimes thinking \"you know, Lean actually can't do this can it\". I've been forced to wrestle with several timeouts.</p>",
        "id": 165516342,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557744045
    },
    {
        "content": "<p>But Lean always came through in the end, although the solutions were a bit random.</p>",
        "id": 165516355,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557744058
    },
    {
        "content": "<p>On line 744 of <code>src/valuation/field.lean</code> if you change <code>Type u</code> to <code>Type*</code> then Lean times out. That was the worst one. I have no idea why.</p>",
        "id": 165516378,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557744101
    },
    {
        "content": "<p>For that one, I tried</p>",
        "id": 165516627,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557744297
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"k\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">valuation</span><span class=\"bp\">.</span><span class=\"n\">completion_extend</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- try_for 10000 {</span>\n  <span class=\"c1\">--   exact valuation.completion_extend (valuation_field.canonical_valuation v)</span>\n  <span class=\"c1\">-- }</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>and it says</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">invalid</span> <span class=\"n\">type</span> <span class=\"n\">ascription</span><span class=\"o\">,</span> <span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">valuation</span> <span class=\"o\">(</span><span class=\"n\">ring_completion</span> <span class=\"o\">(</span><span class=\"n\">valued_ring</span> <span class=\"err\">?</span><span class=\"n\">m_3</span> <span class=\"err\">?</span><span class=\"n\">m_5</span><span class=\"o\">))</span> <span class=\"err\">?</span><span class=\"n\">m_1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"err\">?</span> <span class=\"err\">?</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">valuation</span> <span class=\"o\">(</span><span class=\"n\">ring_completion</span> <span class=\"o\">(</span><span class=\"n\">valuation_field</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">value_group</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span>\n</pre></div>",
        "id": 165516646,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557744310
    },
    {
        "content": "<p>what is the relation between <code>valuation_field</code> and <code>valued_ring</code>?</p>",
        "id": 165516681,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557744341
    },
    {
        "content": "<p>I see, <code>valued_ring</code> is a wrapper. This is not being very nice to lean, it has no idea what to unwrap here. I'm guessing <code>valuation_field</code> is much more complicated, so lean's heuristics say to unfold the more complicated one and it gets lost</p>",
        "id": 165516897,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557744537
    },
    {
        "content": "<p>That wrapper caused us problems.</p>",
        "id": 165517102,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557744764
    },
    {
        "content": "<p>It's funny that changing the universe made it work though.</p>",
        "id": 165517120,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557744801
    },
    {
        "content": "<p>In fact even <code>with_zero</code> caused us problems (a wrapper for <code>option</code>) -- we used <code>with_zero</code> a lot and at some point we seriously considered redefining it by just copying some <code>option</code> code; the <code>option</code> kept leaking out.</p>",
        "id": 165517212,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557744921
    },
    {
        "content": "<p>have you tried printing the definition? It makes me weep to see</p>",
        "id": 165517221,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557744947
    },
    {
        "content": "<p>The definition of what?</p>",
        "id": 165517225,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557744957
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">valuation_on_completion</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">valuation</span>\n    <span class=\"o\">(</span><span class=\"n\">ring_completion</span>\n      <span class=\"o\">(</span><span class=\"n\">valuation</span><span class=\"bp\">.</span><span class=\"n\">valuation_field</span> <span class=\"n\">v</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">value_group</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">valuation</span><span class=\"bp\">.</span><span class=\"n\">completion_extend</span> <span class=\"o\">(</span><span class=\"n\">valuation_field</span><span class=\"bp\">.</span><span class=\"n\">canonical_valuation</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"kn\">set_option</span> <span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">all</span> <span class=\"n\">true</span>\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">valuation_on_completion</span>\n</pre></div>",
        "id": 165517276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557744981
    },
    {
        "content": "<p>oh, actually that's not so bad</p>",
        "id": 165517286,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557745012
    },
    {
        "content": "<p>this version looks much worse</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">valuation</span><span class=\"bp\">.</span><span class=\"n\">completion_extend</span> <span class=\"o\">(</span><span class=\"n\">valuation_field</span><span class=\"bp\">.</span><span class=\"n\">canonical_valuation</span> <span class=\"n\">v</span><span class=\"o\">),</span>\n  <span class=\"n\">dunfold</span> <span class=\"n\">valued_ring</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">this</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 165517300,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557745026
    },
    {
        "content": "<p>I need a deduplicating pp printer</p>",
        "id": 165517320,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557745068
    },
    {
        "content": "<p>I don't really understand what you're saying.</p>",
        "id": 165517366,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557745085
    },
    {
        "content": "<p>These printouts always make expressions look worse than they are</p>",
        "id": 165517373,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557745090
    },
    {
        "content": "<p>We just typed in normal maths</p>",
        "id": 165517377,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557745103
    },
    {
        "content": "<p>but if expressions are much much worse under the hood than they appear then that's a bad sign</p>",
        "id": 165517387,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557745116
    },
    {
        "content": "<p>and stuff like timeouts is just the symptom</p>",
        "id": 165517400,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557745140
    },
    {
        "content": "<p>the moral of the story is \"don't make lean work too hard\"</p>",
        "id": 165517421,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557745166
    },
    {
        "content": "<p>sometimes you accidentally ask lean to do something silly and then you get a timeout for no reason</p>",
        "id": 165517445,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557745202
    },
    {
        "content": "<p>We're just extending a valuation on a ring to a valuation on its completion. What's not to like?</p>",
        "id": 165517535,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557745269
    },
    {
        "content": "<p>You're saying we should be looking at our terms to see if any of them are getting suspiciously large?</p>",
        "id": 165517604,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557745345
    },
    {
        "content": "<p>But what can we do to stop this happening?</p>",
        "id": 165517614,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557745358
    },
    {
        "content": "<p>You shouldn't have unfolded our wrapper!</p>",
        "id": 165517646,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557745405
    },
    {
        "content": "<p>The reason this happened was the first error message I posted:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">invalid</span> <span class=\"n\">type</span> <span class=\"n\">ascription</span><span class=\"o\">,</span> <span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">valuation</span> <span class=\"o\">(</span><span class=\"n\">ring_completion</span> <span class=\"o\">(</span><span class=\"n\">valued_ring</span> <span class=\"err\">?</span><span class=\"n\">m_3</span> <span class=\"err\">?</span><span class=\"n\">m_5</span><span class=\"o\">))</span> <span class=\"err\">?</span><span class=\"n\">m_1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"err\">?</span> <span class=\"err\">?</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">valuation</span> <span class=\"o\">(</span><span class=\"n\">ring_completion</span> <span class=\"o\">(</span><span class=\"n\">valuation_field</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">value_group</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span>\n</pre></div>\n\n\n<p>I think the problem is not actually <code>valued_ring</code> itself but all the instances on it</p>",
        "id": 165517730,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557745487
    },
    {
        "content": "<p><code>valuation_field</code> has a bunch of instances, and <code>valued_ring</code> has different instances, and a lot of unfolding needs to happen to see they are the same</p>",
        "id": 165517761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557745521
    },
    {
        "content": "<p>Why are you applying a theorem which isn't obviously applicable?</p>",
        "id": 165517850,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557745589
    },
    {
        "content": "<p>what's the logic here? How does the stuff on <code>valuation_field</code> relate to <code>valued_ring</code>?</p>",
        "id": 165517877,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557745628
    },
    {
        "content": "<p>A valued ring is a ring together with a valuation. This valuation induces a topology, etc...</p>\n<p>A valuation field is a particular example.</p>",
        "id": 165517972,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557745725
    },
    {
        "content": "<p>maybe you need a typeclass for that</p>",
        "id": 165518015,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557745787
    },
    {
        "content": "<p>rather than a type constructor</p>",
        "id": 165518020,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557745794
    },
    {
        "content": "<p>i.e. <code>valued_ring R v</code> is a prop assertion that says that a topological ring is generated by a valuation</p>",
        "id": 165518142,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557745912
    },
    {
        "content": "<p>that way you can assert that <code>valuation_field</code> is a valued ring, even though it isn't literally constructed as \"adjoin this valuation to the ring\"</p>",
        "id": 165518216,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557745973
    },
    {
        "content": "<p>aka stricklandize it</p>",
        "id": 165518236,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557745995
    },
    {
        "content": "<p>Or we change it to <code>valued_ring.mk</code>? And we have class</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">valued_ring</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 165518241,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557746002
    },
    {
        "content": "<p>I was going to say that, and then I realized that the gamma will give you problems</p>",
        "id": 165518255,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557746034
    },
    {
        "content": "<p>Sorry, my exam just finished and I had to pick up several hundred pieces of paper</p>",
        "id": 165519572,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557747376
    },
    {
        "content": "<p>With a random ring R there are lots of valuations, so lots of topologies. But given a valuation v we wanted a topology on R so we went with a wrapper because topological_space is a class I guess.</p>",
        "id": 165519699,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557747537
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>invalid type ascription, term has type\n  valuation (ring_completion (valued_ring ?m_3 ?m_5)) ?m_1 : Type (max ? ?)\nbut is expected to have type\n  valuation (ring_completion (valuation_field v)) (value_group v) : Type ?\n</pre></div>\n\n\n<p><code>valued_ring ?m_3 ?m_5</code> is just by definition <code>?m_3</code> but this is all about topology, and I can't put a topology on <code>?m_3</code> because it depends on <code>?m_5</code></p>",
        "id": 165519806,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557747652
    },
    {
        "content": "<p>We mathematicians need to learn the right way to think about this stuff.</p>",
        "id": 165519885,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557747729
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Can you formulate a general principal here? Why is <code>valued_ring</code> a bad type wrapper, but <code>multiplicative</code> a good one?</p>",
        "id": 165519900,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557747758
    },
    {
        "content": "<blockquote>\n<p>but if expressions are much much worse under the hood than they appear then that's a bad sign</p>\n</blockquote>\n<p>Do you mean \"much worse after you've unfolded absolutely everything\" or something else?</p>",
        "id": 165519923,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557747784
    },
    {
        "content": "<p>I mean much worse explicitly, before any unfolding</p>",
        "id": 165519949,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557747809
    },
    {
        "content": "<p>or after any unfolding that needs to be done in the moment</p>",
        "id": 165519954,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557747821
    },
    {
        "content": "<p>like unfolding <code>valued_ring</code>.</p>",
        "id": 165520051,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557747901
    },
    {
        "content": "<p><code>valued_ring</code> is not a bad type wrapper, but it's not sufficient for all things. In particular, this is the same problem we've seen before with <code>localization</code>. Sometimes you want to perform the construction, and sometimes you want to say that an independently constructed type is isomorphic to the construction</p>",
        "id": 165520124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557747944
    },
    {
        "content": "<p><code>quotient</code> is another example of this</p>",
        "id": 165520182,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557747977
    },
    {
        "content": "<p>It doesn't apply if the type isn't actually <code>quotient bla</code></p>",
        "id": 165520194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557747991
    },
    {
        "content": "<blockquote>\n<p>I was going to say that, and then I realized that the gamma will give you problems</p>\n</blockquote>\n<p>Because of universe issues or because we just need to input it directly with</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">valued_ring</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">totally_ordered_group</span> <span class=\"err\">Γ</span><span class=\"o\">]</span> <span class=\"c1\">-- or whatever we called it</span>\n<span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 165520236,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748042
    },
    {
        "content": "<p>In this case you have <code>valued_ring R v</code>, the construction, and you want to apply it to <code>valuation_field v</code>, which after unfolding is <em>not</em> defined as <code>valued_ring bla bla</code></p>",
        "id": 165520237,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557748042
    },
    {
        "content": "<p>There's something a bit wrong. Those v's are perhaps not the same.</p>",
        "id": 165520310,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748093
    },
    {
        "content": "<p><code>valuation_field v</code> has got a valuation on it but it's not <code>v</code></p>",
        "id": 165520323,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748108
    },
    {
        "content": "<p>right, I'm not saying they are</p>",
        "id": 165520335,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557748116
    },
    {
        "content": "<p>Oh Ok</p>",
        "id": 165520336,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748122
    },
    {
        "content": "<p>No, you're supposed to be unfolding valued_ring here, not valuation_field</p>",
        "id": 165520344,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748142
    },
    {
        "content": "<p>I'm saying that <code>valuation_field v =?= valued_ring ?m1 ?m2</code> doesn't have a solution by unfolding <code>valuation_field</code></p>",
        "id": 165520357,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557748152
    },
    {
        "content": "<p>Right!</p>",
        "id": 165520367,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748168
    },
    {
        "content": "<p>Unfold the other one.</p>",
        "id": 165520370,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748173
    },
    {
        "content": "<p>Even if you unfold <code>valued_ring</code> here, it doesn't solve the problem of all the instances</p>",
        "id": 165520374,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557748185
    },
    {
        "content": "<p>I think that you're saying that if we're going to use a wrapper type, then we must be very careful to wrap everything up.</p>",
        "id": 165520441,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748218
    },
    {
        "content": "<p><code>valued_ring</code> has a bunch of instances on it, a uniform structure and so on - does <code>valuation_field v</code> have the same structure?</p>",
        "id": 165520449,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557748227
    },
    {
        "content": "<p>No</p>",
        "id": 165520457,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748236
    },
    {
        "content": "<p>then you shouldn't apply this theorem</p>",
        "id": 165520461,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557748251
    },
    {
        "content": "<p>Hmm...we could put those structures on it.</p>",
        "id": 165520462,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748258
    },
    {
        "content": "<p>We wrote the wrapper because for a general ring R and a general valuation v, we definitely don't want R to inherit the uniform structure from v, because often R will be fixed and v will change</p>",
        "id": 165520507,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748291
    },
    {
        "content": "<p>My guess is you want to prove <code>is_valued_ring (valuation_field v) (valuation_field.canonical_valuation v)</code></p>",
        "id": 165520517,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557748303
    },
    {
        "content": "<p><code>valuation_field v</code> is exactly the point where we've manipulated the ring so much that now we'll never put another valuation on it.</p>",
        "id": 165520572,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748332
    },
    {
        "content": "<p>None of this conversation is about mathematics, in some sense.</p>",
        "id": 165520579,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748348
    },
    {
        "content": "<p>It's proof engineering stuff</p>",
        "id": 165520585,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557748363
    },
    {
        "content": "<p>So I'm a beginner here.</p>",
        "id": 165520587,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748364
    },
    {
        "content": "<p>Yes exactly.</p>",
        "id": 165520591,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748372
    },
    {
        "content": "<p>You can have <code>valued_ring R v</code> as before, and prove <code>is_valued_ring (valued_ring R v) v</code></p>",
        "id": 165520629,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557748403
    },
    {
        "content": "<p>So we keep the wrapper?</p>",
        "id": 165520710,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748446
    },
    {
        "content": "<p>and then <code>completion_extend</code> has the type <code>valuation (ring_completion K) Γ </code> where <code>is_valued_ring K v</code></p>",
        "id": 165520712,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557748451
    },
    {
        "content": "<p>I don't know if you need the wrapper, but I imagine that sometimes you just have a ring and need to put a valuation on it</p>",
        "id": 165520737,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557748480
    },
    {
        "content": "<p>rather than asserting that a pre-existing topological ring is generated by a valuation</p>",
        "id": 165520771,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557748506
    },
    {
        "content": "<p>That's right.</p>",
        "id": 165520781,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748513
    },
    {
        "content": "<p>so you want both</p>",
        "id": 165520788,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557748520
    },
    {
        "content": "<p>In fact I think that always we just have the ring and need to put a topology on it coming from a valuation.</p>",
        "id": 165520815,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748546
    },
    {
        "content": "<p>That's why we used a wrapper -- because the valuation can vary, but topological_space is a class.</p>",
        "id": 165520876,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748565
    },
    {
        "content": "<p>I think that's what you thought originally and that's why the code looks like it does, but it turns out not to be the case</p>",
        "id": 165520886,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557748573
    },
    {
        "content": "<p>because <code>valuation_field</code> is clearly not of that form</p>",
        "id": 165520893,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557748587
    },
    {
        "content": "<p>It is of that form mathematically</p>",
        "id": 165520902,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557748603
    },
    {
        "content": "<p>But not Lean-ny</p>",
        "id": 165520907,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557748612
    },
    {
        "content": "<p>valuation_field was a field that didn't have a valuation for most of the projects, and then I realised far too late (because I never wrote a proper roadmap) that we needed a topology on it.</p>",
        "id": 165520915,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748623
    },
    {
        "content": "<p>and that's what <code>is_valued_ring</code> is for, to say \"this ring is generated by this valuation\"</p>",
        "id": 165520931,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557748638
    },
    {
        "content": "<p>You might also consider writing <code>valuation_field</code> so it has the form <code>valued_ring bla bla</code>, but that will affect other things</p>",
        "id": 165520956,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557748678
    },
    {
        "content": "<p>Then Patrick found the part of Bourbaki that did what we wanted, and worked in what a library-builder would say was the correct generality: given a valuation on a ring, the ring gets a topology, and the valuation extends to the completion of the ring.</p>",
        "id": 165521005,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748686
    },
    {
        "content": "<p>I guess an alternative would be to rename <code>valuation_field</code> to <code>valuation_field.aux</code> and then define <code>valuation_field</code> as <code>valued_ring (valuation_field_aux _) _</code></p>",
        "id": 165521020,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557748710
    },
    {
        "content": "<p>I thought about that too, but there are some nontrivial theorems here about how the topological ring structure is preserved</p>",
        "id": 165521066,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557748750
    },
    {
        "content": "<p>But I guess that Mario is saying that the predicate approach is better (because more flexible?)</p>",
        "id": 165521068,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557748752
    },
    {
        "content": "<p>I suspect that the only time we ever apply the valued_ring stuff is to <code>valuation_field v</code> (which is a field), however there were a bunch of general theorems about the topology on a ring induced by a valuation in Bourbaki and Patrick formalised those.</p>",
        "id": 165521071,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748755
    },
    {
        "content": "<p>the predicate approach means that the instances are not impacted - they are just the <code>valuation_field</code> instances</p>",
        "id": 165521090,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557748786
    },
    {
        "content": "<p>So Patrick was faced with the dilemma of having a ring R, and a valuation v on R, and he wanted to talk about the induced topology on R. So the wrapper was born.</p>",
        "id": 165521163,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748812
    },
    {
        "content": "<p>This was almost certainly the correct generality for Bourbaki. But in retrospect it was more than we needed for our application.</p>",
        "id": 165521193,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557748842
    },
    {
        "content": "<p>Thanks for all these comments. I'll digest them slowly.</p>",
        "id": 165521751,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557749371
    }
]
[
    {
        "content": "<p>In Isabelle/HOL, for each definition there is an automatically generated induction principle. For example, if we define predicate <code>even</code> recursively such that <code>even 0</code> is true, <code>even 1</code> is false and <code>even (n+2)</code> is <code>even n</code> for any natural number <code>n</code>, then we get <code>nat.two_step_induction</code> for free. Is there an equivalent in Lean?</p>\n<p>Here is a simple example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"mi\">123</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"mi\">45</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">123</span> <span class=\"bp\">∨</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">45</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>It would be nice if <code>cases h</code> could split into two goals, one with <code>n</code> replaced with <code>123</code> and the other with <code>n</code> replaced with <code>45</code>. Is there such a tactic?</p>",
        "id": 279534788,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1650457058
    },
    {
        "content": "<p>If you defined <code>P</code> as an inductive proposition then this would be the induction principle</p>",
        "id": 279534979,
        "sender_full_name": "Reid Barton",
        "timestamp": 1650457199
    },
    {
        "content": "<p>Probably you rather want</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">intro123</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">123</span>\n<span class=\"bp\">|</span> <span class=\"n\">intro45</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">45</span>\n</code></pre></div>\n<p>Then <code>cases h</code> will do what you want.</p>",
        "id": 279534981,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650457199
    },
    {
        "content": "<p>Sure, my example is bad. I am talking about re-using the recursion principle generated by the equation compiler, rather than proving it manually (like the even/odd example).</p>",
        "id": 279535748,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1650457588
    },
    {
        "content": "<p>So that we can use that principle when proving facts about the function.</p>",
        "id": 279535840,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1650457641
    },
    {
        "content": "<p>I don't understand the even/odd example because <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.two_step_induction\">docs#nat.two_step_induction</a> does not mention <code>even</code> or <code>odd</code></p>",
        "id": 279535877,
        "sender_full_name": "Reid Barton",
        "timestamp": 1650457657
    },
    {
        "content": "<p>But I guess the answer is that the equation compiler <em>doesn't</em> generate a recursion principle (for what?). It does generate equational lemmas.</p>",
        "id": 279535980,
        "sender_full_name": "Reid Barton",
        "timestamp": 1650457699
    },
    {
        "content": "<p>In Lean you can define an inductive family of propositions, in which case you get an induction principle that tells you all the ways that the proposition can be true. Or you can define a family of proposiitons by recursion on something else (like a <code>nat</code>), which tells you how to \"compute\" the proposition for a specific natural number (by doing recursion on that number). They are different tools and in general it might not be straightforward to convert from one presentation to the other in an interesting way.</p>",
        "id": 279536423,
        "sender_full_name": "Reid Barton",
        "timestamp": 1650457933
    },
    {
        "content": "<p>For example if you define <code>even</code> by recursion in Lean then it is basically the same as writing <code>def even (n : nat) : Prop := nat.rec_on n true not</code>. There are no constants or axioms being added, and you could replace a usage of <code>even</code> by this definition. I think it works quite differently in Isabelle/HOL.</p>",
        "id": 279537732,
        "sender_full_name": "Reid Barton",
        "timestamp": 1650458628
    },
    {
        "content": "<p>I am talking about this: suppose we define two functions <code>f</code> and <code>g</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)))</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"n\">ys</span> <span class=\"o\">:=</span> <span class=\"n\">ys</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"n\">ys</span> <span class=\"o\">:=</span> <span class=\"k\">have</span> <span class=\"n\">ys.length</span> <span class=\"bp\">+</span> <span class=\"n\">xs.length</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">+</span> <span class=\"n\">ys.length</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">g</span> <span class=\"n\">ys</span> <span class=\"n\">xs</span>\n<span class=\"n\">using_well_founded</span> <span class=\"o\">{</span> <span class=\"n\">dec_tac</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"gr\">sorry</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>The equation compiler uses <code>nat.rec</code> and <code>list.rec</code> to build the functions. It would be nice if we could obtain the direct induction principle for the definition, rather than making a separate definition for it. For example, functions <code>f</code> and <code>g</code> would automatically generate</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f_rec</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">f₀</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">fn</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">))))</span> <span class=\"o\">:</span>\n<span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">f₀</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">f₁</span>\n<span class=\"bp\">|</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">f₂</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)))</span> <span class=\"o\">:=</span> <span class=\"n\">fn</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">f_rec</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g_rec</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">g_nil</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"o\">[]</span> <span class=\"n\">ys</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">g_cons</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"n\">ys</span> <span class=\"n\">xs</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"n\">ys</span> <span class=\"o\">:=</span> <span class=\"n\">g_nil</span> <span class=\"n\">ys</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"n\">ys</span> <span class=\"o\">:=</span> <span class=\"k\">have</span> <span class=\"n\">ys.length</span> <span class=\"bp\">+</span> <span class=\"n\">xs.length</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">+</span> <span class=\"n\">ys.length</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">g_cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span> <span class=\"o\">(</span><span class=\"n\">g_rec</span> <span class=\"n\">ys</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n<span class=\"n\">using_well_founded</span> <span class=\"o\">{</span> <span class=\"n\">dec_tac</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"gr\">sorry</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 279538956,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1650459266
    },
    {
        "content": "<p>OK, so basically the most general function with the same recursive structure as the original one. For example you can recover <code>f</code> from <code>f_rec</code> by <code>f = f_rec 0 0 0 (\\lam n x, x)</code>.</p>",
        "id": 279539903,
        "sender_full_name": "Reid Barton",
        "timestamp": 1650459686
    },
    {
        "content": "<blockquote>\n<p>If you defined <code>P</code> as an inductive proposition then this would be the induction principle.</p>\n</blockquote>\n<p>We can't always do that. For example, this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">¬</span><span class=\"n\">P</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>but this does not:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">n.succ</span>\n</code></pre></div>",
        "id": 279542542,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1650461003
    },
    {
        "content": "<p>Right, that's why the original question was so confusing <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 279542712,
        "sender_full_name": "Reid Barton",
        "timestamp": 1650461102
    },
    {
        "content": "<p>What you want to do makes sense, for example (for some reason) you defined <code>f</code> as above, and now you want to prove <code>f n = 0</code> for all <code>n</code>. I think the usual wisdom is something like:</p>\n<ol start=\"0\">\n<li>Avoid fancy recursive structures in the first place (not that common in math anyways, maybe more common in program verification)</li>\n<li>If you want to prove something about <code>f</code> (defined using the equation compiler) then you should use the equation compiler for the proof also. (Rather than your <code>f_rec</code> which would only be palatable if applied in tactic mode.)</li>\n<li>Try to minimize the amount to which you need to do 1, e.g. by completely characterizing the behavior of <code>f</code> by a single lemma, so you don't need to reason by recursion about <code>f</code> again and again.</li>\n</ol>",
        "id": 279543532,
        "sender_full_name": "Reid Barton",
        "timestamp": 1650461571
    },
    {
        "content": "<p>(For example <code>even</code> is not actually defined by recursion in mathlib, it wouldn't occur to most mathematicians to define it that way, and I would go so far to say it would be a bad way to define it.)</p>",
        "id": 279545310,
        "sender_full_name": "Reid Barton",
        "timestamp": 1650462472
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> I remember someone asking about something like this last year, and the impression I got was that this is equivalent to having the equation compiler also define an inductive type that gives the underlying relation for the the function along with defining some lemma proving that the the relation is functional and is equivalent to the defined function. Then you can do induction on the function's recursion by doing induction on that relation.</p>\n<p>I saw in the Lean 4 changelog that it's able to do induction on a recursion now, but I haven't looked into how you do that yet.</p>",
        "id": 279562844,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1650470055
    },
    {
        "content": "<p>I think we could define such a type using a user attribute in Lean 3, where there'd be a constructor per equation lemma.</p>",
        "id": 279563049,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1650470152
    }
]
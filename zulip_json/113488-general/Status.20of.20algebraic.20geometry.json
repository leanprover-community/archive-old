[
    {
        "content": "<p>I'm a newcomer to lean, and a student studying in maths with interests towards algebraic geometry. <br>\nAs the current mathlib is quite short on algebraic geometry, I am wondering what the current status is, and if there are TODOs that i can contribute to so that i can practice lean hands-on at the same time.</p>",
        "id": 253718572,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1631873055
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384542\">@Justus Springer</span> currently has the most active plans for developing AG.</p>",
        "id": 253718834,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1631873214
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> that's basically how I started out as well :)<br>\nA significant part of my contributions so far have been to solve TODOs in algebraic geometry. Currently I'm trying to formalize the adjunction between <code>Spec</code> and the global sections functor (from locally ringed spaces). I'm following <a href=\"https://stacks.math.columbia.edu/tag/01I1\">stacks</a>.  I hope I can finish this in September, after that, I probably won't have as much time for Lean as I do now. <br>\nWhen that's done, there are some obvious follow-ups: Defining the category of affine schemes, showing it to be contravariantly equivalent to <code>CommRing</code> and showing that it has products and fibre products. Then there is some gluing construction to show that schemes have fibre products as well.<br>\nBesides that, maybe it would be time to define and play around with basic properties of schemes (integral, reduced, normal, notherian,...) and morphisms (flat, smooth, affine,...). But I don't know how accessible that is. See also <a href=\"#narrow/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL/near/235331481\">this discussion</a>.</p>",
        "id": 253727937,
        "sender_full_name": "Justus Springer",
        "timestamp": 1631878397
    },
    {
        "content": "<p>One thing I'd like to see is the definition of <code>Proj R</code> for <code>R</code> a graded ring (or, as we say here, an internally graded commutative ring). If you're more variety-y than schemey then there's always the possibility of setting up a theory of algebraic varieties too, although I'm still not really sure how it would look. Perhaps restrict to a separably closed field and define quasi-projective algebraic varieties as subspaces of projective n-space? Morphisms of quasi-projective varieties probably need to be handled via sheaves though, otherwise things get quite nasty.</p>",
        "id": 253730815,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631880010
    },
    {
        "content": "<p>A completely different idea would be to develop the concept of finite locally free group schemes over a base scheme (otherwise known as finite flat group schemes, if the base is Noetherian). This is a globalisation of group theory and there are lots of surprises, e.g. in characteristic p there is more than one group of order p, even if your base is a point. We'll need these for the proof of Fermat's Last Theorem ;-)</p>",
        "id": 253731059,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631880120
    },
    {
        "content": "<p>I could start trying to define <code>Proj R</code> by probably copying <code>Spec.lean</code> and modifying it.<br>\nAfter that, porting the definitions and the basic properties in Hartshorne II.3 also seems like an interesting<br>\ntask that I could try. Though gluing schemes seems like quite a challenge to formalise.</p>",
        "id": 253737344,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1631883401
    },
    {
        "content": "<p>Oh and may I have the write access to the mathlib repo? My username is <code>erdOne</code>.</p>",
        "id": 253737685,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1631883555
    },
    {
        "content": "<p>Hmm, <code>Proj R</code> depends on a theory of graded rings, which I wouldn't recommend to a beginner.</p>",
        "id": 253737697,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1631883560
    },
    {
        "content": "<p>Justus was talking about fibre products, which is a nice target, I think. So, for starters, we'll need to know that <code>CommRing</code> has fibred coproducts. Tensor products are defined, but I don't think this category is aware yet that is has these coproducts.</p>",
        "id": 253738051,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1631883691
    },
    {
        "content": "<p>So that might be a nice place to start.</p>",
        "id": 253738068,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1631883700
    },
    {
        "content": "<p>After that, define the subcategory of affine schemes, and deduce that it has fibre products.</p>",
        "id": 253738102,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1631883716
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/CommRing.colimits.has_colimits_CommRing\">docs#CommRing.colimits.has_colimits_CommRing</a></p>",
        "id": 253738291,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1631883789
    },
    {
        "content": "<p>ooh, of course <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 253738371,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1631883820
    },
    {
        "content": "<p>But of course it would be nice to have an explicit cocone for the fibered coproducts which is defeq to the tensor product</p>",
        "id": 253738409,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1631883839
    },
    {
        "content": "<p>In my opinion, a good place to start is in constructing a gluing construction for topological spaces, which will then be useful for a gluing constrution for schemes.</p>",
        "id": 253739096,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1631884111
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/Top\">docs#Top</a> is the category of topological spaces, which we know has colimits (so we can glue in some sense), but we probably need an explicit construction of gluing spaces along open subsets which will be useful for gluing schemes.</p>",
        "id": 253739170,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1631884155
    },
    {
        "content": "<p>Sure, I will start there then.<br>\nI am thinking of implementing the underlying set as the quotient set of the disjoint union,  and then specifying the open sets.<br>\nIs this a good idea?</p>",
        "id": 253740638,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1631884831
    },
    {
        "content": "<p>Yes, I think that's reasonable. But one should think carefully how to set this up. My inclination is to use the general formalism of descent data, and to use open immersions instead of open subsets. This is probably worth further discussion (maybe in the #maths stream)</p>",
        "id": 253741263,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1631885113
    },
    {
        "content": "<p>So again, I'm not sure if this is a good \"first project\"</p>",
        "id": 253742284,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1631885590
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/253742284\">said</a>:</p>\n<blockquote>\n<p>So again, I'm not sure if this is a good \"first project\"</p>\n</blockquote>\n<p>You're right.</p>",
        "id": 253742325,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1631885609
    },
    {
        "content": "<p>Defining the category of affine schemes is probably a lot easier to get started with.</p>",
        "id": 253742331,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1631885615
    },
    {
        "content": "<p>We have the following ingredients for this: <br>\n<a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebraic_geometry.Scheme.Spec\">docs#algebraic_geometry.Scheme.Spec</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.functor.ess_image\">docs#category_theory.functor.ess_image</a></p>",
        "id": 253743114,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1631885942
    },
    {
        "content": "<p>I will start working on the category of affine schemes then.<br>\nShould I assume the adjointness of Spec, or prove independently that Spec is  fully faithful?</p>",
        "id": 253744518,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1631886520
    },
    {
        "content": "<p>It would be best to coordinate with <span class=\"user-mention\" data-user-id=\"384542\">@Justus Springer</span>, but I imagine that for affine schemes you don't need the Gamma-Spec adjunction, right?</p>",
        "id": 253744662,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1631886581
    },
    {
        "content": "<p>Or do you mean that you want to know that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">O</mi><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mi>A</mi><mo stretchy=\"false\">)</mo><mo>≅</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal O(\\mathrm{Spec} A) \\cong A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">Spec</span></span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>?</p>",
        "id": 253744833,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1631886626
    },
    {
        "content": "<p>I think Justus proved that a while ago.</p>",
        "id": 253744858,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1631886637
    },
    {
        "content": "<p>I think that need <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Hom</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi><mo stretchy=\"false\">)</mo><mo>≃</mo><mi mathvariant=\"normal\">Hom</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Spec</mi><mo>⁡</mo><mi>B</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">Spec</mi><mo>⁡</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Hom}(A, B) \\simeq \\operatorname{Hom}(\\operatorname{Spec} B, \\operatorname{Spec} A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Hom</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Hom</span></span><span class=\"mopen\">(</span><span class=\"mop\"><span class=\"mord mathrm\">Spec</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Spec</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span> in order to say that the category of affine schemes is equivalent to <code>CommRing^op</code>.<br>\nThe equivalence is a direct consequence of the adjunction, but there may be a more elementary proof to it.</p>",
        "id": 253745356,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1631886840
    },
    {
        "content": "<p>I thought we had that Spec is fully faithful in mathlib. <span class=\"user-mention\" data-user-id=\"384542\">@Justus Springer</span>?</p>",
        "id": 253745633,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1631886948
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/253737685\">said</a>:</p>\n<blockquote>\n<p>Oh and may I have the write access to the mathlib repo? My username is <code>erdOne</code>.</p>\n</blockquote>\n<p>I've sent you an invite: <a href=\"https://github.com/leanprover-community/mathlib/invitations\">https://github.com/leanprover-community/mathlib/invitations</a></p>",
        "id": 253747443,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1631887679
    },
    {
        "content": "<p>Affine schemes can definitely be defined without the Gamma-spec adjunction. It should be pretty straightforward with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.functor.ess_image\">docs#category_theory.functor.ess_image</a>. Still, we would need some infrastructure, like defining <code>Spec.to_AffineScheme</code> and also <code>AffineScheme.Γ</code>.</p>",
        "id": 253748570,
        "sender_full_name": "Justus Springer",
        "timestamp": 1631888103
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/253745633\">said</a>:</p>\n<blockquote>\n<p>I thought we had that Spec is fully faithful in mathlib. <span class=\"user-mention silent\" data-user-id=\"384542\">Justus Springer</span>?</p>\n</blockquote>\n<p>Unfortunately not. But since this follows immediately from the adjunction, I think we should wait for that.</p>",
        "id": 253748943,
        "sender_full_name": "Justus Springer",
        "timestamp": 1631888252
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/253747443\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/253737685\">said</a>:</p>\n<blockquote>\n<p>Oh and may I have the write access to the mathlib repo? My username is <code>erdOne</code>.</p>\n</blockquote>\n<p>I've sent you an invite: <a href=\"https://github.com/leanprover-community/mathlib/invitations\">https://github.com/leanprover-community/mathlib/invitations</a></p>\n</blockquote>\n<p>Thanks!</p>",
        "id": 253749023,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1631888282
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384542\">Justus Springer</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/253748943\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/253745633\">said</a>:</p>\n<blockquote>\n<p>I thought we had that Spec is fully faithful in mathlib. <span class=\"user-mention silent\" data-user-id=\"384542\">Justus Springer</span>?</p>\n</blockquote>\n<p>Unfortunately not. But since this follows immediately from the adjunction, I think we should wait for that.</p>\n</blockquote>\n<p>Wouldn't proving that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">O</mi><mo stretchy=\"false\">(</mo><mi>S</mi><mi>p</mi><mi>e</mi><mi>c</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}(Spec(A)) = A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">Sp</span><span class=\"mord mathnormal\">ec</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> be one of the steps in proving the adjunction? Full-faithfulness would follow easily from that.</p>",
        "id": 253749187,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1631888339
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384542\">Justus Springer</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/253748943\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/253745633\">said</a>:</p>\n<blockquote>\n<p>I thought we had that Spec is fully faithful in mathlib. <span class=\"user-mention silent\" data-user-id=\"384542\">Justus Springer</span>?</p>\n</blockquote>\n<p>Unfortunately not. But since this follows immediately from the adjunction, I think we should wait for that.</p>\n</blockquote>\n<p>Sure! I will start the definitions and the infrastructures then. The equivalence to <code>CommRing</code> can wait.</p>",
        "id": 253749361,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1631888401
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/253749187\">said</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Wouldn't</span> <span class=\"n\">proving</span> <span class=\"n\">that</span> <span class=\"bp\">$$\\</span><span class=\"n\">mathcal</span><span class=\"o\">{</span><span class=\"n\">O</span><span class=\"o\">}(</span><span class=\"n\">Spec</span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">A</span><span class=\"bp\">$$</span> <span class=\"n\">be</span> <span class=\"n\">one</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">steps</span> <span class=\"k\">in</span> <span class=\"n\">proving</span> <span class=\"n\">the</span> <span class=\"n\">adjunction</span><span class=\"bp\">?</span> <span class=\"n\">Full</span><span class=\"bp\">-</span><span class=\"n\">faithfulness</span> <span class=\"n\">would</span> <span class=\"n\">follow</span> <span class=\"n\">easily</span> <span class=\"k\">from</span> <span class=\"n\">that.</span>\n</code></pre></div>\n<p>Yes. That part is more or less done, I proved the more general statement <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">O</mi><mi>X</mi></msub><mo stretchy=\"false\">(</mo><mi>D</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>≅</mo><msub><mi>A</mi><mi>f</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}_X(D(f))\\cong A_f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> a while ago (where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>=</mo><mi>S</mi><mi>p</mi><mi>e</mi><mi>c</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">X=Spec(A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Sp</span><span class=\"mord mathnormal\">ec</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span>). See <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebraic_geometry.structure_sheaf.basic_open_iso\">docs#algebraic_geometry.structure_sheaf.basic_open_iso</a>. I never got around to specializing this to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">O</mi><mi>X</mi></msub><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>≅</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}_X(X)\\cong A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> though. This seems trivial, but involves knowing that localizing a ring at units doesn't change it. This could be a nice project too <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> .</p>",
        "id": 253750174,
        "sender_full_name": "Justus Springer",
        "timestamp": 1631888705
    },
    {
        "content": "<p>The reason the adjunction is taking so long by the way is that I want to do the more general version for locally ringed spaces: I.e. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">H</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi></mrow><mo stretchy=\"false\">(</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>S</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>R</mi><mo stretchy=\"false\">)</mo><mo>≅</mo><mrow><mi mathvariant=\"normal\">H</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi></mrow><mo stretchy=\"false\">(</mo><mi>R</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{\\rm Hom}(X,Spec R)\\cong{\\rm Hom}(R,\\Gamma(X))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Hom</span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">Sp</span><span class=\"mord mathnormal\">ec</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Hom</span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">Γ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">))</span></span></span></span> for any locally ringed space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, not just (affine) schemes. For this, I need <a href=\"https://stacks.math.columbia.edu/tag/01HZ\">this lemma</a>, which requires some generalizations to the sheaves library. Also, I had to prove that the forgetful functor <code>CommRing ⥤ Type</code> preserves filtered colimits (<a href=\"https://github.com/leanprover-community/mathlib/issues/9191\">#9191</a>). So that's the state of affairs as of now. I hope the road is clear now for the Gamma-Spec adjunction.</p>",
        "id": 253751299,
        "sender_full_name": "Justus Springer",
        "timestamp": 1631889163
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span>  If you want you could play around with proving <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">H</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi></mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi><mo stretchy=\"false\">)</mo><mo>≅</mo><mrow><mi mathvariant=\"normal\">H</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi></mrow><mo stretchy=\"false\">(</mo><mi>S</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>B</mi><mo separator=\"true\">,</mo><mi>S</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{\\rm Hom}(A,B)\\cong{\\rm Hom}(Spec B, Spec A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Hom</span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Hom</span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">Sp</span><span class=\"mord mathnormal\">ec</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">Sp</span><span class=\"mord mathnormal\">ec</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span> as you suggested. Then you can use the things you've learned to help me with the general version <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 253751729,
        "sender_full_name": "Justus Springer",
        "timestamp": 1631889342
    },
    {
        "content": "<p>So there is definitely enough work to do...</p>",
        "id": 253751844,
        "sender_full_name": "Justus Springer",
        "timestamp": 1631889380
    },
    {
        "content": "<p>Just for fun:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.monoid_localization</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.localization</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_localization.away</span> <span class=\"n\">u</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map_units</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">erw</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">M</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_pow</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">is_unit.pow</span> <span class=\"n\">_</span> <span class=\"n\">hu</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">surj</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">eq_iff_exists</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨⟨</span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span><span class=\"n\">hc</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">is_unit.pow</span> <span class=\"n\">_</span> <span class=\"n\">hu</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">this.mul_left_inj</span> <span class=\"n\">at</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">localization.away</span> <span class=\"n\">u</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span> <span class=\"n\">_</span> <span class=\"n\">u</span> <span class=\"n\">hu</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">is_localization.alg_equiv</span> <span class=\"o\">(</span><span class=\"n\">submonoid.powers</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">localization.away</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">M</span>\n</code></pre></div>",
        "id": 253752823,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1631889739
    },
    {
        "content": "<p>I'm a little surprised we don't have this in mathlib somewhere...</p>",
        "id": 253753134,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1631889845
    },
    {
        "content": "<p>Also, it looks like <code>is_localization.away</code> is only defined for commutative rings while <code>localization.away</code> for any monoid. Why is that?</p>",
        "id": 253753608,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1631890012
    },
    {
        "content": "<p>I asked about this before <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Localization.20at.20units\">here</a>, but then never PR'd it. Now things have changed again since the localization map refactor.</p>",
        "id": 253754607,
        "sender_full_name": "Justus Springer",
        "timestamp": 1631890355
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/253753608\">said</a>:</p>\n<blockquote>\n<p>Also, it looks like <code>is_localization.away</code> is only defined for commutative rings while <code>localization.away</code> for any monoid. Why is that?</p>\n</blockquote>\n<p>Maybe <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> ?</p>",
        "id": 253754640,
        "sender_full_name": "Justus Springer",
        "timestamp": 1631890367
    },
    {
        "content": "<p>(<a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_localization.away\">docs#is_localization.away</a> vs <a href=\"https://leanprover-community.github.io/mathlib_docs/find/localization.away\">docs#localization.away</a> for reference)</p>",
        "id": 253756558,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1631891115
    },
    {
        "content": "<p>I think this is because in turn <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_localization\">docs#is_localization</a> requires a full algebra structure while <a href=\"https://leanprover-community.github.io/mathlib_docs/find/localization\">docs#localization</a> does not</p>",
        "id": 253756780,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1631891192
    },
    {
        "content": "<p>The monoid version of <code>is_localization.away</code> is called something like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submonoid.localization_map.away_map\">docs#submonoid.localization_map.away_map</a></p>",
        "id": 253759706,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1631892439
    },
    {
        "content": "<p>Since <code>Scheme</code>s and consequently <code>AffineScheme</code>s have hidden universe variables, I cannot simply coerce <code>X : AffineScheme</code> into <code>Scheme</code> without explicitly stating the universe levels.<br>\nIs the paradigm to tuck <code>.{u}</code>'s everywhere, or to not use coerces, or there is some other solution to this?</p>",
        "id": 253777819,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1631899797
    },
    {
        "content": "<p>I don't think providing universe levels explicitly is considered a bad thing. But I'm not sure we would even want a coercion, maybe it would suffice to have <code>AffineScheme.to_Scheme</code>?</p>",
        "id": 253785999,
        "sender_full_name": "Justus Springer",
        "timestamp": 1631903071
    },
    {
        "content": "<p>The <code>AffineScheme.to_Scheme</code> would presumably just be an alias for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.functor.ess_image_inclusion\">docs#category_theory.functor.ess_image_inclusion</a></p>",
        "id": 253786257,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1631903164
    },
    {
        "content": "<p>I've finished the 'faithful' part of the fully-faithful-ness, but the 'full' part seems to need some more definition unfolding to make it work.<br>\n<a href=\"https://github.com/leanprover-community/mathlib/blob/affine_schemes/src/algebraic_geometry/Spec_fully_faithful.lean\">The file</a>.<br>\nI'm wondering if there are any advices about the code or such before I continue.</p>",
        "id": 253921254,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1632031489
    },
    {
        "content": "<p>Thanks for working on this! I think it looks very good. I have a few comments:</p>\n<ul>\n<li>I don't think we even need the extra definition <code>to_Spec_Γ</code>. Maybe we can just use <code>structure_sheaf.to_open R ⊤</code>? As a second step, we could have the actual isomorphism <code>R ≅ (structure_sheaf R).presheaf.obj (op ⊤)</code> as an extra definition, making use of <code>as_iso</code>. This should also help with defining <code>Spec_Γ_identity</code>, making use of <code>nat_iso.of_components</code>.</li>\n<li><code>Spec_Γ_identity</code> should be a def, not a lemma (you can also see this warning yourself by typing <code>#lint</code> at the end of the file).</li>\n<li>Everything leading up to <code>R ≅ (structure_sheaf R).presheaf.obj (op ⊤)</code> should probably go into <code>structure_sheaf.lean</code> I would say. Maybe right below <code>basic_open_iso</code>? </li>\n<li>About <code>op_iso</code>: I remember I needed the same thing when playing around with something else. I have it on the old branch <a href=\"https://github.com/leanprover-community/mathlib/tree/is_iso_op\">branch#is_iso_op</a>, but never PR'd it. Should I PR it, so that that's out of the way?</li>\n</ul>\n<p>You could probably PR the isomorphism <code>R ≅ (structure_sheaf R).presheaf.obj (op ⊤)</code> very soon (as soon as the localization-at-units thing jas been done)</p>",
        "id": 253925279,
        "sender_full_name": "Justus Springer",
        "timestamp": 1632036163
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 254151995,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1632196255
    },
    {
        "content": "<p>I've finished the fully faithful ness of <code>Spec</code>. Though it is just a draft and the proof is quite ugly. <br>\n<a href=\"https://github.com/leanprover-community/mathlib/blob/affine_schemes/src/algebraic_geometry/global_section_of_spec.lean\">This file</a> contains <code>R ≅ (structure_sheaf R).presheaf.obj (op ⊤)</code> and <code>Spec ⋙ Γ ≅ 𝟭</code>.<br>\n<a href=\"https://github.com/leanprover-community/mathlib/blob/affine_schemes/src/algebraic_geometry/morphism_into_affine.lean\">This file</a> proves the fact that two morphisms into affine schemes are equal if their underlying topological map and the map at the global sections are both equal.<br>\n<a href=\"https://github.com/leanprover-community/mathlib/blob/affine_schemes/src/algebraic_geometry/Spec_fully_faithful.lean\">This file</a>  contains the fully-faithful ness of Spec.</p>\n<ul>\n<li>I've tried to remove <code>to_Spec_Γ</code>, but lean complains about <code>R</code> not equal to <code>CommRing.of ↥R</code>. I moved it out from the part that should go into <code>structure_sheaf.lean</code> though. I'm not sure what the better solution is.</li>\n<li>I need the fact that two maps of sheaves (of CommRing) coincide iff they coincide on stalks, and that elements of stalks are all germs. These are proved in <code>Top.presheaves</code> for Type-valued sheaves, but not for CommRing valued sheaves. I could just mirror the proof, but maybe there is a better way to prove that these all hold in good enough concrete categories.</li>\n<li>The <code>eq_to_hom</code> is quite annoying and the proof seems unnecessarily long because of it. Is there a better general approach to it?</li>\n<li>About <code>op_iso</code>: Yeah, please do PR it. Also it would be great if there is also <code>(inv f).op = inv f.op</code>.</li>\n<li>For the localization-at-units thing, is anyone currently working on it? Or should I finish that up.</li>\n</ul>",
        "id": 254152799,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1632197149
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/tree/affine_schemes\">branch#affine_schemes</a> for those looking for a branch name (-;</p>",
        "id": 254152868,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632197200
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> great job! Seems like you managed to do a lot in a few days.</p>",
        "id": 254152957,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632197304
    },
    {
        "content": "<p>These are all steps in the right direction. Many thanks Andrew!</p>",
        "id": 254158587,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1632203232
    },
    {
        "content": "<p>Great! Maybe we should make a new directory <code>algebraic_geometry/Spec</code>? Then we could have one file for fully faithfulness and one file for the adjunction.</p>",
        "id": 254172384,
        "sender_full_name": "Justus Springer",
        "timestamp": 1632213097
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/254152799\">said</a>:</p>\n<blockquote>\n<ul>\n<li>About <code>op_iso</code>: Yeah, please do PR it. Also it would be great if there is also <code>(inv f).op = inv f.op</code>.</li>\n</ul>\n</blockquote>\n<p>Done: <a href=\"https://github.com/leanprover-community/mathlib/issues/9319\">#9319</a>. I'm afraid we can't prove <code>(inv f).op = inv f.op</code>, as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.inv\">docs#category_theory.inv</a> is defined using choice. But we do have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.iso.op_inv\">docs#category_theory.iso.op_inv</a>.</p>",
        "id": 254172595,
        "sender_full_name": "Justus Springer",
        "timestamp": 1632213232
    },
    {
        "content": "<p>A new directory is a good idea.</p>",
        "id": 254175541,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632214927
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384542\">Justus Springer</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/254172595\">said</a>:</p>\n<blockquote>\n<p>Done: <a href=\"https://github.com/leanprover-community/mathlib/issues/9319\">#9319</a>. I'm afraid we can't prove <code>(inv f).op = inv f.op</code>, as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.inv\">docs#category_theory.inv</a> is defined using choice. But we do have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.iso.op_inv\">docs#category_theory.iso.op_inv</a>.</p>\n</blockquote>\n<p>Hmm, is there a place for non-computable lemmas about category theory to go then? <br>\nAnd also things like <code>instance [e : is_equivalence F] : is_equivalence F.op</code>.</p>",
        "id": 254187822,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1632221880
    },
    {
        "content": "<p>It can be proved, it just won't be a definitional equality.</p>",
        "id": 254188676,
        "sender_full_name": "Reid Barton",
        "timestamp": 1632222303
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/254152799\">said</a>:</p>\n<blockquote>\n<ul>\n<li>The <code>eq_to_hom</code> is quite annoying and the proof seems unnecessarily long because of it. Is there a better general approach to it?</li>\n</ul>\n</blockquote>\n<p>You're talking about this one, right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">top_map_of</span> <span class=\"o\">:</span> <span class=\"n\">Top_obj</span> <span class=\"n\">R</span> <span class=\"bp\">⟶</span> <span class=\"n\">Top_obj</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">eq_to_hom</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">≫</span> <span class=\"n\">f.val.base</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">eq_to_hom</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">to_LocallyRingedSpace</span><span class=\"o\">,</span> <span class=\"n\">LocallyRingedSpace_obj</span><span class=\"o\">,</span> <span class=\"n\">opposite.unop_op</span><span class=\"o\">]</span><span class=\"bp\">;</span>\n  <span class=\"n\">refl</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 254188859,
        "sender_full_name": "Reid Barton",
        "timestamp": 1632222412
    },
    {
        "content": "<p>Just looking at it, I'm not sure why the <code>eq_to_hom</code>s should be necessary at all since the equalities involved are definitional. What happens if you leave them out? Does Lean just take a long time?</p>",
        "id": 254189046,
        "sender_full_name": "Reid Barton",
        "timestamp": 1632222514
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/254188676\">said</a>:</p>\n<blockquote>\n<p>It can be proved, it just won't be a definitional equality.</p>\n</blockquote>\n<p>Oh of course, inverses are unique!</p>",
        "id": 254193985,
        "sender_full_name": "Justus Springer",
        "timestamp": 1632225259
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/254187822\">said</a>:</p>\n<blockquote>\n<p>And also things like <code>instance [e : is_equivalence F] : is_equivalence F.op</code>.</p>\n</blockquote>\n<p>We only have the bundled version: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.equivalence.op\">docs#category_theory.equivalence.op</a>.</p>",
        "id": 254194220,
        "sender_full_name": "Justus Springer",
        "timestamp": 1632225400
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/254152799\">said</a>:</p>\n<blockquote>\n<ul>\n<li>I need the fact that two maps of sheaves (of CommRing) coincide iff they coincide on stalks, and that elements of stalks are all germs. These are proved in <code>Top.presheaves</code> for Type-valued sheaves, but not for CommRing valued sheaves. I could just mirror the proof, but maybe there is a better way to prove that these all hold in good enough concrete categories.</li>\n</ul>\n</blockquote>\n<p>Indeed, I've just generalized this (and other stuff in <code>topology/sheaves/stalks</code>) on <a href=\"https://github.com/leanprover-community/mathlib/tree/spec_gamma_adjunction\">branch#spec_gamma_adjunction</a>. It should now be applicable to any concrete category, whose forgetful functor reflects isomorphisms, preserves limits and filtered colimits. This is exactly why I needed this whole filtered colimits stuff.</p>",
        "id": 254196637,
        "sender_full_name": "Justus Springer",
        "timestamp": 1632226496
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> I think it's promising that we are discovering the same sorts of issues here. We should probably coordinate our efforts closely :)</p>",
        "id": 254197508,
        "sender_full_name": "Justus Springer",
        "timestamp": 1632226929
    },
    {
        "content": "<p>May I use this occasion to mention that I am still waiting for reviews on <a href=\"https://github.com/leanprover-community/mathlib/issues/9101\">#9101</a>. I know it's a big one, but it seems like this is crucial for further development :)</p>",
        "id": 254197628,
        "sender_full_name": "Justus Springer",
        "timestamp": 1632226994
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384542\">@Justus Springer</span> you should have pinged earlier! I'll try to take a look today!</p>",
        "id": 254197921,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632227113
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Thanks! I just noticed yesterday that some tests were getting canceled for some reason, which is why it didn't show up on <a href=\"https://bit.ly/3kaztxO\">#queue</a>. I merged master again, now it succeeds.</p>",
        "id": 254198195,
        "sender_full_name": "Justus Springer",
        "timestamp": 1632227256
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/254188676\">said</a>:</p>\n<blockquote>\n<p>It can be proved, it just won't be a definitional equality.</p>\n</blockquote>\n<p>Oh I thought there were some constructivist concerns or such. I'll add it somewhere.</p>",
        "id": 254199714,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1632227922
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/254189046\">said</a>:</p>\n<blockquote>\n<p>Just looking at it, I'm not sure why the <code>eq_to_hom</code>s should be necessary at all since the equalities involved are definitional. What happens if you leave them out? Does Lean just take a long time?</p>\n</blockquote>\n<p>Lean complains that the types don't match. If I don't write out the <code>eq_to_hom</code> explicitly, they be come <code>_.mpr</code>'s, which are also a pain to work with.</p>\n<p>The more tricky one is the <code>coerce</code> from <code>f _* O(X)</code> to <code>g _*O(X)</code>. I can understand that it is needed, but my goal becomes a mess, and I needed stuff like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">structure_sheaf</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">presheaf.germ</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">F</span> <span class=\"n\">b</span> <span class=\"bp\">≫</span> <span class=\"n\">eq_to_hom</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">subst</span> <span class=\"n\">H</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>to solve it, since simply <code>rw H</code> says that the motive is not type correct. I am wondering if there is a better way to do this.</p>",
        "id": 254201098,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1632228577
    },
    {
        "content": "<p>I just PR'd <a href=\"https://github.com/leanprover-community/mathlib/issues/9357\">#9357</a>, generalizing things like <code>germ_exist</code> and other stalk-related lemmas from sheaves valued in <code>Type</code> to any \"nice enough\" concrete category.</p>",
        "id": 254739968,
        "sender_full_name": "Justus Springer",
        "timestamp": 1632503846
    },
    {
        "content": "<p>I have proven that a \"morphism on a basis\" from a presheaf to a sheaf (with values in an arbitrary category) on a topological space can be extended to an actual morphism (on all open sets): <a href=\"https://github.com/alreadydone/mathlib/commit/121a3444131fc1180ca021552b47b7563aebcaa5#diff-d7cc616887430b2cb5792e3d691f45c1bbc3eaa32c3abf1c4e735ab8b9a904d9R152\">https://github.com/alreadydone/mathlib/commit/121a3444131fc1180ca021552b47b7563aebcaa5#diff-d7cc616887430b2cb5792e3d691f45c1bbc3eaa32c3abf1c4e735ab8b9a904d9R152</a><br>\nThis appears necessary to construct the sheaf morphism in the Spec-Gamma adjunction; it should be equivalent to <a href=\"https://stacks.math.columbia.edu/tag/009V\">https://stacks.math.columbia.edu/tag/009V</a> (except that the source need not be a sheaf) which is used in the Stacks Project proof. My proof doesn't involve colimits like in <a href=\"https://stacks.math.columbia.edu/tag/009Q\">https://stacks.math.columbia.edu/tag/009Q</a> and only involves limits that are guaranteed to exist by the sheaf condition, so it works with any category of values (provided that the opens_le_cover formulation of the sheaf condition is used (which I think is the one that should be used in the definition of a sheaf)). Such a construction of extension is mentioned in the comment <a href=\"https://stacks.math.columbia.edu/tag/009H#comment-2589\">https://stacks.math.columbia.edu/tag/009H#comment-2589</a> and a reference for it is The Geometry of Schemes (GTM 197), p.17 (Stacks Project and the comment actually only talk about extension of a sheaf on a basis to all open sets and not a morphism, but in the case of the Spec-Gamma adjunction we already have the sheaves, so we only need to extend the morphism).</p>\n<p>Comments are welcome! The proofs are clumsy and I feel I'm missing some tricks; the style/naming may not yet conform to the mathlib norm; the implicit arguments may not be optimal; and I'm not sure if the is_basis and sheaf condition assumptions should be instances.</p>\n<p>Together with the nice preliminary work like <a href=\"https://github.com/leanprover-community/mathlib/issues/9101\">#9101</a> I imagine it's now relatively easy to prove the adjunction, and will work towards that goal given that <span class=\"user-mention\" data-user-id=\"384542\">@Justus Springer</span> is less active now (as he said, he has less time in October).</p>",
        "id": 256930540,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1633847835
    },
    {
        "content": "<p>I wonder how everyone would feel about rearranging things so <code>opens_le_cover</code> becomes the official definition?</p>",
        "id": 256932938,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1633850302
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> , it's great to see that more people are working on this! Note that development on this adjunction is still ongoing. I will have less time for Lean in October, but I will try to help finish the adjunction. <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> and I have also been working on doing sheaves on topological bases. Our goal is to get the equivalence of categories between sheaves on a bases and sheaves on all open sets. But because defining \"sheaf on a basis\" directly would be too much of a duplication of the original sheaf definition, we are trying to embed it into the general theory of sheaves on sites. In particular, Andrew has shown recently (<a href=\"https://github.com/leanprover-community/mathlib/issues/9431\">#9431</a>) that a cover-lifting functors between sites <code>G : C ⥤ D</code> extends to a functor between sheaves on <code>C</code> to sheaves on <code>D</code>. The way it's done has to do with the right Kan extension of a functor and it's a vast generalization of how you use limits to define the extension of a sheaf on a basis. But Andrew can tell you more about this than me. The abstract statement we are going for will be something like this: A cover-lifting fully faithful functor <code>G : C ⥤ D</code> between sites induces an equivalence of categories between sheaves on <code>C</code> and sheaves on <code>D</code>. This then gets applied to the inclusion functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">B</mi><mo>→</mo><mi>O</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>s</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal{B}\\to Opens(X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.03041em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Op</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span> from a topological bases to all open sets, which is easily seen to be cover-lifting and fully faithful.</p>",
        "id": 256940477,
        "sender_full_name": "Justus Springer",
        "timestamp": 1633857851
    },
    {
        "content": "<p>Another part of the puzzle is to finally connect the theory of sheaves on spaces to sheaves on sites, which is something I worked on and PR'd a few days ago: <a href=\"https://github.com/leanprover-community/mathlib/issues/9609\">#9609</a></p>",
        "id": 256940610,
        "sender_full_name": "Justus Springer",
        "timestamp": 1633857990
    },
    {
        "content": "<p>Admitted, for the Gamma-Spec adjunction, it is not necessary to know about the full equivalence between sheaves on bases and sheaves on the whole space. You don't even need to define sheaves on bases. You just need to know how to extend morphisms. So what you have done <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span>  would be the more direct route. I don't know what would be the best route to continue, but I think developing a bit of abstract API about sheaves on sites would be worth the detour.</p>",
        "id": 256940874,
        "sender_full_name": "Justus Springer",
        "timestamp": 1633858309
    },
    {
        "content": "<p>Also note that I have a tiny bit of code lying around on <a href=\"https://github.com/leanprover-community/mathlib/tree/spec_gamma_adjunction\">branch#spec_gamma_adjunction</a>. For some reason I decided a long time ago that it would be best to do the adjunction via defining unit and counit: The unit would be the isomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>≅</mo><msub><mi mathvariant=\"script\">O</mi><mrow><mi>S</mi><mi>p</mi><mi>e</mi><mi>c</mi><mo stretchy=\"false\">(</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow></msub><mo stretchy=\"false\">(</mo><mi>S</mi><mi>p</mi><mi>e</mi><mi>c</mi><mo stretchy=\"false\">(</mo><mi>R</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">R \\cong \\mathcal{O}_{Spec(R)}(Spec(R))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1052em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">Sp</span><span class=\"mord mathnormal mtight\">ec</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">Sp</span><span class=\"mord mathnormal\">ec</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">))</span></span></span></span> (which already exists) and for the counit, you'd need to define a morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><mi>S</mi><mi>p</mi><mi>e</mi><mi>c</mi><mo stretchy=\"false\">(</mo><msub><mi mathvariant=\"script\">O</mi><mi>X</mi></msub><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">X \\to Spec(\\mathcal{O}_X(X))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Sp</span><span class=\"mord mathnormal\">ec</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">))</span></span></span></span> for all locally ringed spaces. I have defined this morphism already as a continuous map, all that's missing is the corresponding sheaf homomorphism, seeing that it's local on stalks, and the triangle identities.</p>",
        "id": 256941051,
        "sender_full_name": "Justus Springer",
        "timestamp": 1633858486
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"384542\">@Justus Springer</span> for the updates on recent progress and roadmap; great to see that you're still actively contributing! I searched and saw you haven't posted on Zulip since the end of September, and didn't find recent PRs by you on Github, so I assumed you're not active; now I realize I should add <code>author:</code> when searching for PRs.</p>\n<p>I've only heard the name \"Kan extension\" before but never saw its definition or what it's used for, and my knowledge on Grothendieck topologies is rusty, but more generality and categorical foundations are definitely nice (especially as we work towards etale cohomology)! For example, I was trying to find an easy way to express the restriction of a presheaf morphism to a subcategory of the opens when I saw the definition of horizontal composition in mathlib documentation, and then realized that the restriction is a special case. I'm also glad to see PR <a href=\"https://github.com/leanprover-community/mathlib/issues/9609\">#9609</a> connecting a general definition to a special one.</p>\n<p>As for the adjunction, I was thinking of using <code>mk_of_hom_equiv</code>, but will now also consider the unit-counit route to see if it's easier. I see that <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> has defined the unit in <a href=\"https://github.com/leanprover-community/mathlib/blob/affine_schemes/src/algebraic_geometry/global_section_of_spec.lean#L67\">global_section_of_spec.lean</a> except for a <code>sorry</code> for localization at units. I've also seen your nice work in <a href=\"https://github.com/leanprover-community/mathlib/tree/spec_gamma_adjunction\">branch#spec_gamma_adjunction</a>, but unfortunately after merging master it becomes quite hard to find the relevant commits.</p>",
        "id": 256988460,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1633903494
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/256932938\">said</a>:</p>\n<blockquote>\n<p>I wonder how everyone would feel about rearranging things so <code>opens_le_cover</code> becomes the official definition?</p>\n</blockquote>\n<p>Oh sorry, I actually meant to propose to promote the <code>pairwise_intersections</code> definition to the official one. It's a natural generalization of the standard definition (<code>unique_gluing</code>, which is like <code>pairwise_intersections</code> applied to cones with cone point the free object on one element), and works for arbitrary category of values (doesn't require <code>has_products</code>) that only makes sense with concrete categories. Although <code>opens_le_cover</code> may be more convenient, we can go between both easily without <code>has_products</code>.</p>",
        "id": 256988498,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1633903527
    },
    {
        "content": "<p>About the sheaves on basis stuff, the current plan is to formalize <a href=\"/user_uploads/3121/i_7aZlNiTkru8oTq-XHRKDiD/image.png\">Theorem C2.2.3</a> in the elephant. Currently the functors on two sided are both constructed (in <a href=\"https://github.com/leanprover-community/mathlib/issues/9431\">#9431</a> and <a href=\"https://github.com/leanprover-community/mathlib/issues/9650\">#9650</a>), and it remains to show that the two functors are indeed inverses to each other. One side follows straight from existing lemmas in the mathlib, but the other side probably needs more work. That said, this construction still requires some existence of limits since Kan extension needs them. It would be great if these conditions can be inferred straight from the sheaf conditions and removed.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/i_7aZlNiTkru8oTq-XHRKDiD/image.png\" title=\"Theorem C2.2.3\"><img src=\"/user_uploads/3121/i_7aZlNiTkru8oTq-XHRKDiD/image.png\"></a></div><p>As for the counit, it is already tidied up and merged into master as <a href=\"https://leanprover-community.github.io/mathlib_docs/algebraic_geometry/Spec.html#algebraic_geometry.Spec_Γ_identity\">docs#algebraic_geometry.Spec_Γ_identity</a>.</p>",
        "id": 256989637,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1633904514
    },
    {
        "content": "<p>Yeah I just saw <a href=\"https://github.com/leanprover-community/mathlib/issues/9416\">#9416</a> a few minutes before you posted. Very nice! I think (at least in the topological space case) you'll need the existence of appropriate limits to extend a sheaf on a basis to all open sets (to define the objects at open sets not in the basis), but you probably don't need it to extend morphisms, as in the topological space case.</p>",
        "id": 256993412,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1633908454
    },
    {
        "content": "<p>btw, it seems I and <span class=\"user-mention\" data-user-id=\"384542\">@Justus Springer</span> agree that what you constructed is the unit (at least if we're proving the adjunction between Spec.right_op and Gamma, and not between Gamma.right_op and Spec), but you call it the counit ...</p>",
        "id": 256995275,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1633910469
    },
    {
        "content": "<p>Hmmm, isn't <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><mi>R</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>→</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma(\\mathrm{Spec}(R)) \\to R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Γ</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">Spec</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> the counit and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">X \\to \\mathrm{Spec}(\\Gamma(X))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Spec</span></span><span class=\"mopen\">(</span><span class=\"mord\">Γ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">))</span></span></span></span> the unit of the adjunction?<br>\nIf I'm wrong, the docs in mathlib about the iso probably needs fixing as well..</p>",
        "id": 257008546,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1633924548
    },
    {
        "content": "<p>The unit is the inverse map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>→</mo><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><mi>R</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">R\\to\\Gamma(\\mathrm{Spec}(R))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Γ</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">Spec</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">))</span></span></span></span> in CommRing<br>\nThe counit is indeed <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">X \\to \\mathrm{Spec}(\\Gamma(X))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Spec</span></span><span class=\"mopen\">(</span><span class=\"mord\">Γ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">))</span></span></span></span> but in the opposite category of LocallyRingedSpace so the arrow is reversed.</p>",
        "id": 257009727,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1633925572
    },
    {
        "content": "<p>Oh I forgot the opposites <span aria-label=\"sweat\" class=\"emoji emoji-1f613\" role=\"img\" title=\"sweat\">:sweat:</span> <br>\nWill probably fix the docs when the adjunction is actually done then...</p>",
        "id": 257011262,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1633927074
    },
    {
        "content": "<p>Another related problem is that you wrote Γ ⊣ Spec: if Γ is the left adjoint then the adjunction should be between Γ.right_op and Spec (between categories LocallyRingedSpace and CommRing^op), but since you have been working with Spec.right_op and Gamma, we'd probably like to change it to Spec ⊣ Γ.</p>",
        "id": 257013296,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1633928916
    },
    {
        "content": "<p>I also always confuse unit/counit and left/right in this adjunction. <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> I also didn't know much about grothendieck topologies a few weeks ago, I'm learning as I'm going.</p>",
        "id": 257027686,
        "sender_full_name": "Justus Springer",
        "timestamp": 1633939511
    },
    {
        "content": "<p>Regarding the sheaf definition, yeah since the <code>pairwise_intersections</code> definition doesn't require products, it should probably become the official definition. The general definition of a sheaf on a site also doesn't require products. However, my proof that the definition on sites is equivalent to the definition on spaces works with the equalizer definition, so the proof would have to be redone. Maybe we can do this later, I doubt that this extra bit of generality will be needed soon.</p>",
        "id": 257028151,
        "sender_full_name": "Justus Springer",
        "timestamp": 1633939783
    },
    {
        "content": "<p>Concerning fibre products of schemes (which have also been discussed in this thread), I stumbled upon <a href=\"http://math.stanford.edu/~vakil/d/FOAG/BOfiber-prods.pdf\">http://math.stanford.edu/~vakil/d/FOAG/BOfiber-prods.pdf</a> which is a nice way to organize things, I think.</p>",
        "id": 257028539,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1633940038
    },
    {
        "content": "<p>Also, getting the definition of a Zariski sheaf in mathlib would be a nice side effect (-;</p>",
        "id": 257028612,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1633940059
    },
    {
        "content": "<p>I think I will have to come to terms with the fact that I won’t have as much time for Lean now than I had in September. I will shift focus now and concentrate on my MSc thesis, so will probably no longer contribute to mathlib for a while. I was not able to finish the Gamma-Spec adjunction, which is a project I’ve been working on for the last month or two, and indirectly even longer. But I think it’s in reach now and it will be an important milestone. I thought I’d post here some of my thoughts on the adjunction in general, where I left off and how I think one can proceed. Maybe someone will find it useful.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>I left some code on <a href=\"https://github.com/leanprover-community/mathlib/tree/spec_gamma_adjunction\">branch#spec_gamma_adjunction</a>, outlining the way I imagine the construction would go. I don’t claim ownership to this branch anymore, anyone can feel free to adopt it. The construction roughly follows <a href=\"https://stacks.math.columbia.edu/tag/01I1\">stacks#01I1</a>. However, when I was working through the stacks proof, I somehow got the feeling that it might be easier to do the adjunction via providing unit and counit instead of the hom-equivalence. But this is not set in stone and the construction is very similar. </p>\n<p>The unit already exists, it’s the isomorphism <a href=\"https://leanprover-community.github.io/mathlib_docs/algebraic_geometry/Spec.html#algebraic_geometry.Spec_%CE%93_identity\">docs#algebraic_geometry.Spec_Γ_identity</a>. For the counit, the task is to construct a morphism of locally ringed spaces <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ψ</mi><mspace></mspace><mspace width=\"0.1111111111111111em\"/><mo lspace=\"0em\" rspace=\"0.17em\"></mo><mtext> ⁣</mtext><mo lspace=\"0em\" rspace=\"0em\">:</mo><mspace width=\"0.3333333333333333em\"/><mi>X</mi><mo>→</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\psi\\colon X\\to{\\rm Spec}(\\Gamma(X))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span><span class=\"mspace nobreak\"></span><span class=\"mspace\" style=\"margin-right:0.1111111111111111em;\"></span><span class=\"mpunct\"></span><span class=\"mspace\" style=\"margin-right:-0.16666666666666666em;\"></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mrel\">:</span></span><span class=\"mspace\" style=\"margin-right:0.3333333333333333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Spec</span></span></span><span class=\"mopen\">(</span><span class=\"mord\">Γ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">))</span></span></span></span> for every locally ringed space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>. As a map, this sends a point <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">x\\in X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> to the prime ideal of all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>∈</mo><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f\\in\\Gamma(X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Γ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span> that <em>vanish</em> in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>, i.e. such that the germ of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> at <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> is a non-unit. I proved this to be continuous already on <a href=\"https://github.com/leanprover-community/mathlib/tree/spec_gamma_adjunction\">branch#spec_gamma_adjunction</a>. For the sheaf morphism, one has to construct a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">O</mi><mrow><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow></msub><mo stretchy=\"false\">(</mo><mi>U</mi><mo stretchy=\"false\">)</mo><mo>→</mo><msub><mi mathvariant=\"script\">O</mi><mi>X</mi></msub><mo stretchy=\"false\">(</mo><msup><mi>ψ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><mi>U</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}_{{\\rm Spec}(\\Gamma(X))}(U)\\to\\mathcal{O}_X(\\psi^{-1}(U))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1052em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">Spec</span></span></span><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">Γ</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose mtight\">))</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">))</span></span></span></span> for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi><mo>⊂</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">U\\subset {\\rm Spec}\\Gamma(X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊂</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Spec</span></span></span><span class=\"mord\">Γ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span>. It is at this point that we need to know how to extend a morphism of sheaves on a basis, as this morphism can only directly be defined on basic opens <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi><mo>=</mo><mi>D</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">U=D(f)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span></span></span></span>. This is the biggest hole in the construction right now, as soon as this has been settled (either by proving the comparison theorem of topos theory as <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span>  is doing, or by a more direct approach a la <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> ), the rest of the construction should be pretty lean-able I believe.</p>\n<p>To get the morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">O</mi><mrow><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow></msub><mo stretchy=\"false\">(</mo><mi>D</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>→</mo><msub><mi mathvariant=\"script\">O</mi><mi>X</mi></msub><mo stretchy=\"false\">(</mo><msup><mi>ψ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><mi>D</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}_{{\\rm Spec}(\\Gamma(X))}(D(f))\\to\\mathcal{O}_X(\\psi^{-1}(D(f)))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1052em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">Spec</span></span></span><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">Γ</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose mtight\">))</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)))</span></span></span></span>, note that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>ψ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><mi>D</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi>D</mi><mi>X</mi></msub><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\psi^{-1}(D(f))=D_X(f)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>D</mi><mi>X</mi></msub><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo>⊂</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">D_X(f)\\subset X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊂</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> is the basic open on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, as defined in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebraic_geometry.RingedSpace.basic_open\">docs#algebraic_geometry.RingedSpace.basic_open</a>. By <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebraic_geometry.RingedSpace.is_unit_res_basic_open\">docs#algebraic_geometry.RingedSpace.is_unit_res_basic_open</a>, the restriction <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>→</mo><msub><mi mathvariant=\"script\">O</mi><mi>X</mi></msub><mo stretchy=\"false\">(</mo><msub><mi>D</mi><mi>X</mi></msub><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\Gamma(X)\\to\\mathcal{O}_X(D_X(f))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Γ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">))</span></span></span></span> sends <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> to a unit, hence lifts to a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">(</mo><mi>X</mi><msub><mo stretchy=\"false\">)</mo><mi>f</mi></msub><mo>→</mo><msub><mi mathvariant=\"script\">O</mi><mi>X</mi></msub><mo stretchy=\"false\">(</mo><msub><mi>D</mi><mi>X</mi></msub><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\Gamma(X)_f\\to\\mathcal{O}_X(D_X(f))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord\">Γ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">))</span></span></span></span>. Composing this with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebraic_geometry.structure_sheaf.basic_open_iso\">docs#algebraic_geometry.structure_sheaf.basic_open_iso</a> gives you the desired map.</p>\n<p>Excluding the issue of extending from a basis, the sorries left on <a href=\"https://github.com/leanprover-community/mathlib/tree/spec_gamma_adjunction\">branch#spec_gamma_adjunction</a> are as follows:</p>\n<ol>\n<li>Show naturality of the sheaf homomorphism on basic opens. </li>\n<li>Show that the stalk maps of the sheaf homomorphism are local. </li>\n<li>Show naturality of the counit <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">X\\to{\\rm Spec}(\\Gamma(X))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Spec</span></span></span><span class=\"mopen\">(</span><span class=\"mord\">Γ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">))</span></span></span></span> in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>. </li>\n<li>Show the left triangle identity. </li>\n<li>Show the right triangle identity.</li>\n</ol>\n<p>I am fairly confident that all of these should be pretty doable, but I haven’t tried in detail. Maybe someone else has already done some of them. For (2), I’d imagine we want to show that that the germ map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>→</mo><msub><mi mathvariant=\"script\">O</mi><mrow><mi>X</mi><mo separator=\"true\">,</mo><mi>x</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\Gamma(X)\\to\\mathcal{O}_{X,x}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Γ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.328331em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\">x</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> is a localisation map for the prime ideal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ψ</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\psi(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>, hence gives an isomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">(</mo><mi>X</mi><msub><mo stretchy=\"false\">)</mo><mrow><mi>ψ</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></msub><mo>≅</mo><msub><mi mathvariant=\"script\">O</mi><mrow><mi>X</mi><mo separator=\"true\">,</mo><mi>x</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\Gamma(X)_{\\psi(x)}\\cong \\mathcal{O}_{X,x}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1052em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\">Γ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">ψ</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">x</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.328331em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\">x</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>. Then we should show (by some uniqueness argument) that the stalk map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>ψ</mi><mi>x</mi></msub><mspace></mspace><mspace width=\"0.1111111111111111em\"/><mo lspace=\"0em\" rspace=\"0.17em\"></mo><mtext> ⁣</mtext><mo lspace=\"0em\" rspace=\"0em\">:</mo><mspace width=\"0.3333333333333333em\"/><msub><mi mathvariant=\"script\">O</mi><mrow><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>ψ</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></msub><mo>→</mo><msub><mi mathvariant=\"script\">O</mi><mrow><mi>X</mi><mo separator=\"true\">,</mo><mi>x</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\psi_x\\colon\\mathcal{O}_{{\\rm Spec}(\\Gamma(X)), \\psi(x)}\\to\\mathcal{O}_{X,x}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04964em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ψ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace nobreak\"></span><span class=\"mspace\" style=\"margin-right:0.1111111111111111em;\"></span><span class=\"mpunct\"></span><span class=\"mspace\" style=\"margin-right:-0.16666666666666666em;\"></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mrel\">:</span></span><span class=\"mspace\" style=\"margin-right:0.3333333333333333em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">Spec</span></span></span><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">Γ</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose mtight\">))</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">ψ</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">x</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.328331em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\">x</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> is equal to the composition of isomorphisms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">O</mi><mrow><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>ψ</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></msub><mo>→</mo><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">(</mo><mi>X</mi><msub><mo stretchy=\"false\">)</mo><mrow><mi>ψ</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></msub><mo>→</mo><msub><mi mathvariant=\"script\">O</mi><mrow><mi>X</mi><mo separator=\"true\">,</mo><mi>x</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}_{{\\rm Spec}(\\Gamma(X)), \\psi(x)}\\to\\Gamma(X)_{\\psi(x)}\\to\\mathcal{O}_{X,x}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.03853em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">Spec</span></span></span><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">Γ</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose mtight\">))</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">ψ</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">x</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1052em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\">Γ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">ψ</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">x</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.328331em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\">x</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>, hence is local. Here, the first isomorphism is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebraic_geometry.structure_sheaf.stalk_iso\">docs#algebraic_geometry.structure_sheaf.stalk_iso</a>.</p>\n<p>I don’t know how difficult it is to prove the triangle identities. Ultimately, that will probably decide whether it’s better to do the adjunction via unit/counit or the hom-equivalence. </p>\n</div></div>",
        "id": 257355556,
        "sender_full_name": "Justus Springer",
        "timestamp": 1634127777
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384542\">@Justus Springer</span> Thanks a lot for your contributions so far! What's your MSc project about?</p>",
        "id": 257356114,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1634127990
    },
    {
        "content": "<p>It was very fun! About my MSc project, I don't know for sure, I'm just starting out. But it will involve Cox Rings and some classification of Fano varieties with a torus action of complexity one :)</p>",
        "id": 257356996,
        "sender_full_name": "Justus Springer",
        "timestamp": 1634128407
    },
    {
        "content": "<p>Didn't expect it to take so long, but I finally finished the job before November! The Gamma-Spec adjunction is now defined and mathlib build succeeded on the cloud, even though some proofs are slow (to be improved, but I guess you can start reviewing the PR <a href=\"https://github.com/leanprover-community/mathlib/issues/9802\">#9802</a>!). And I chose to establish Gamma —| Spec instead of Spec —| Gamma, so no change in earlier documentation is needed.</p>",
        "id": 259812182,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1635719840
    },
    {
        "content": "<p>TIL the categories of ringed spaces and of locally ringed spaces have arbitrary limits, from this note by Martin Brandenburg: <a href=\"https://www.dropbox.com/s/y5t58kugrcaqbx8/fiber-products-of-locally-ringed-spaces-and-schemes.pdf?dl=0\">https://www.dropbox.com/s/y5t58kugrcaqbx8/fiber-products-of-locally-ringed-spaces-and-schemes.pdf?dl=0</a><br>\nAnd he then derives that the category of schemes has finite limits (4.3), because a finite intersection of opens is open and such open affines cover the whole space.<br>\nSeems a totally different construction than what I've learned and no gluing is involved! Maybe this is what we should aim for.</p>\n<p>I found the pdf from <a href=\"https://mathoverflow.net/questions/13616/a-book-on-locally-ringed-spaces\">https://mathoverflow.net/questions/13616/a-book-on-locally-ringed-spaces</a> in turn from <a href=\"https://math.stackexchange.com/questions/1033675/does-the-category-of-locally-ringed-spaces-have-products\">https://math.stackexchange.com/questions/1033675/does-the-category-of-locally-ringed-spaces-have-products</a><br>\nbecause after defining the adjunction between LRS and CommRing I was curious whether LRS also has fibred products: turns out it has much more.</p>\n<div class=\"message_inline_ref\"><a href=\"https://www.dropbox.com/s/y5t58kugrcaqbx8/fiber-products-of-locally-ringed-spaces-and-schemes.pdf?dl=0\" title=\"fiber-products-of-locally-ringed-spaces-and-schemes.pdf\"><img src=\"https://uploads.zulipusercontent.net/1a192ecf0bd2f7327bba38dc788812e1cf04327a/68747470733a2f2f7777772e64726f70626f782e636f6d2f7374617469632f696d616765732f737065637472756d2d69636f6e732f67656e6572617465642f636f6e74656e742f636f6e74656e742d7064662d6c617267652e706e67\"></a><div><div class=\"message_inline_image_title\">fiber-products-of-locally-ringed-spaces-and-schemes.pdf</div><desc class=\"message_inline_image_desc\"></desc></div></div>",
        "id": 259822893,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1635736700
    },
    {
        "content": "<p>Ooh, I'll have to read that when I have a bit more time! That seems like a interesting approach!</p>",
        "id": 259829972,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1635746580
    },
    {
        "content": "<p>I would have expected that you need separatedness for the \"intersection of opens is opens and such open affines cover\" bit of the argument. But like I said: I should read that pdf first.</p>",
        "id": 259829996,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1635746632
    },
    {
        "content": "<p>Here is an outline of a proof that <code>Scheme</code> has (binary) fiber products from the assumption that LRS has them. The fiber product in LRS is also the fiber product in <code>Scheme</code> provided the object lies in <code>Scheme</code>, so we only need to show that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>X</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">X_1, X_2, S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> are schemes, the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><msub><mo>×</mo><mi>S</mi></msub><msub><mi>X</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">X_1\\times_S X_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\"><span class=\"mbin\">×</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is also covered by open affines (by mathlib definition, means that every point has an open neighborhood such that the <code>restrict</code> along the inclusion of the neighborhood is isomorphic to the Spec of a ring).</p>\n<p>Given a point x of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>=</mo><msub><mi>X</mi><mn>1</mn></msub><msub><mo>×</mo><mi>S</mi></msub><msub><mi>X</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">X=X_1\\times_S X_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\"><span class=\"mbin\">×</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, consider its projection p(x) into S, and take an open neighborhood V of p(x) in S that is affine. Similarly take affine neighborhoods <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>U</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>U</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">U_1, U_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><msub><mi>p</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">p_1(x), p_2(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>X</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">X_1, X_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> respectively, then take basic opens within <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>U</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>U</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">U_1, U_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> that projects into V. We then need that the restriction of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Spec}(R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Spec</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span> to a basic open <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">D(f)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span></span></span></span> is isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><msub><mi>R</mi><mi>f</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Spec}(R_f)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Spec</span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, and that <code>restrict</code> commutes with composition of open embeddings.</p>\n<p>Now replace <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>U</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>U</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">U_1, U_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> by the basic opens, and use the <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310069.20Open.20immersions.20of.20presheafed.20spaces/near/259803751\">universal property of <code>restrict</code></a> (notice that the statement is only <code>lift</code> without the <code>fac</code> and <code>uniq</code> parts of the universal property) to obtain morphisms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>p</mi><mn>1</mn><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mo stretchy=\"false\">(</mo><msub><mi>U</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo><mo>∩</mo><msubsup><mi>p</mi><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mo stretchy=\"false\">(</mo><msub><mi>U</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo><mo>→</mo><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">p_1^{-1}(U_1)\\cap p_2^{-1}(U_2) \\to U_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.120547em;vertical-align:-0.266308em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.854239em;\"><span style=\"top:-2.433692em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.1031310000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.120547em;vertical-align:-0.266308em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.854239em;\"><span style=\"top:-2.433692em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1031310000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>→</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">U_i\\to V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> with all open sets endowed with the <code>restrict</code> LRS structure (here we use that the intersection of two opens is open). Then use the universal property to show that their compositions with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>→</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">U_i\\to V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> agree, and these three morphisms to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>U</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>U</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">U_1,U_2,V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> realizes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>p</mi><mn>1</mn><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mo stretchy=\"false\">(</mo><msub><mi>U</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo><mo>∩</mo><msubsup><mi>p</mi><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mo stretchy=\"false\">(</mo><msub><mi>U</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">p_1^{-1}(U_1)\\cap p_2^{-1}(U_2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.120547em;vertical-align:-0.266308em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.854239em;\"><span style=\"top:-2.433692em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.1031310000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.120547em;vertical-align:-0.266308em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.854239em;\"><span style=\"top:-2.433692em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1031310000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> as the fiber product <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>U</mi><mn>1</mn></msub><msub><mo>×</mo><mi>V</mi></msub><msub><mi>U</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">U_1\\times_V U_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\"><span class=\"mbin\">×</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.22222em;\">V</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> in LRS. Finally, use Gamma-Spec adjunction to show the fiber product isomorphic the Spec of a coproduct (tensor) of rings (here we need that Spec is a full functor which Andrew proved; is it now in mathlib?).</p>\n<p>A side comment is that instead of directly proving universal property of <code>restrict</code> (actually should be of <code>of_restrict</code>) we should probably first define open immersion, show that <code>of_restrict</code> is an open immersion, then show that all open immersions satisfy the universal property.</p>\n<p>Although all these are relatively straightforward to formalize, I'm posting here to find out which lemmas have already been done, as I know at least <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> has been working in this direction.</p>",
        "id": 259982777,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1635852838
    },
    {
        "content": "<p>The fact that Spec is fully faithful should follow straight from the counit(?) isomorphism, so I did not work to make that into mathlib.<br>\nI agree that we should provide the universal property in terms of open immersions. <br>\nI assume the biggest obstacle in leanifying that paper is in the part that LRS has fibre products. That definition seems quite ugly, and I don't really know or have time lately to think about how to formalize them properly (my midterms are coming...) <br>\nThat said, after seeing that note that you posted, I tried to look for similar results and stumbled upon <a href=\"https://arxiv.org/pdf/1103.2139.pdf\">https://arxiv.org/pdf/1103.2139.pdf</a>.<br>\nThis seems quite similar to the note above but wrapped everything in some categorical jargon, which may or may not make it easier to formalize, but I suppose it is an alternative.</p>",
        "id": 259984940,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1635854170
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/259984940\">said</a>:</p>\n<blockquote>\n<p>The fact that Spec is fully faithful should follow straight from the counit(?) isomorphism</p>\n</blockquote>\n<p>Indeed, faithfulness only needs the counit iso, though fullness also needs the unit and the right triangle identity (the harder one of the two asserting a LRS morphism is id): defining the preimage only needs the counit iso, but verifying it's a preimage needs right triangle.</p>",
        "id": 259996822,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1635860777
    },
    {
        "content": "<p>Hopefully the results of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.adjunction.fully_faithful/src\">src#category_theory.adjunction.fully_faithful</a> are helpful here?</p>",
        "id": 260053079,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1635884699
    },
    {
        "content": "<p>Nice, I've found the perserve_limits theorem but haven't looked into fully faithfulness yet. But the linkifier seems broken (the link points to a 404 page <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.adjunction.fully_faithful/src\">https://leanprover-community.github.io/mathlib_docs/find/category_theory.adjunction.fully_faithful/src</a> )  <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.adjunction.fully_faithful\">docs#category_theory.adjunction.fully_faithful</a> doesn't append src at the end but also isn't converting dots to slashes.</p>",
        "id": 260071789,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1635895793
    },
    {
        "content": "<p>So I’ve skimmed through Gillam’s paper and plan to adopt his approach, while Andrew keeps pursuing the gluing approach. Although fiber products of schemes require just one approach to build, I believe the two approaches will eventually be good for different purposes in the future, no matter which one is adopted for the current purpose.</p>\n<p>It’s now clear to me that Gillam’s localization functor from PRS (primed ringed spaces) to LRS is just a generalized version of Spec (to LRS) on CommRing: the constructions are very similar, and indeed it’s used to construct Spec in Lemma 3 (bottom of p.9), and it’s part of a general adjunction (Theorem 2) that subsumes the Gamma-Spec adjunction <a href=\"https://github.com/leanprover-community/mathlib/issues/9802\">#9802</a>. We would need to prove everything in structure_sheaf.lean in the more general form, so to avoid duplicate code, it would be a good idea to refactor to define Spec in terms of the localization functor. The Spec constructed this way will not have the underlying set equal to the prime spectrum, so an extra step seems necessary to transfer the LRS structure to the prime spectrum.</p>\n<p>Gillam first shows that PRS has all limits, and uses Theorem 2 (which says the localization functor PRS -&gt; LRS is a right adjoint with unit an iso) to deduce that LRS has all limits (I’m unable to find this implication in mathlib). PRS is easily shown to have all limits given that RS has all limits, which is just three sentences in [Gillam], unlike the lengthy argument in [Brandenburg] (Theorem 2.1). I think it’s indeed easy: PresheafedSpace can be shown to have all limits easily given that the value category has all colimits, now that we have pullback of presheaves in mathlib, similar to how it was shown that it has all colimits; then sheafification on the limit presheafed space would yield the limit in SheafedSpace. (Gillam only talks about inverse limits, but I believe the arguments apply for all (small) limits.) The sites version of sheafification recently completed by Adam Topaz would suffice but it’s yet to be merged into mathlib.</p>",
        "id": 261095823,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1636609208
    },
    {
        "content": "<p>Sounds good. But if these changes go through, it will be important to have a good API for the connection to <code>prime_spectrum</code>, I guess.</p>",
        "id": 261097910,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636611794
    },
    {
        "content": "<p>There's now a <a href=\"https://github.com/leanprover-community/mathlib/projects/13\">project page</a> dedicated to AG<br>\nif someone wants to track the current PRs and progress.</p>",
        "id": 261107385,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1636620788
    },
    {
        "content": "<p>Thanks a lot for creating this overview!</p>",
        "id": 261107505,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636620900
    },
    {
        "content": "<p>Seems like the maintainers have some homework!</p>",
        "id": 261107539,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636620930
    },
    {
        "content": "<p>I added a bunch of \"small subprojects\" to <a href=\"https://github.com/leanprover-community/mathlib/projects/13\">the project page</a> as a new column that I've thought about but haven't found time to code up, some essential to the main project (fibred product). Everyone is welcome to help! As I'm focusing on the main project, I'll probably only do the minimum required when the time comes if no one takes them up. You're welcome to add your ideas to the list, though for Andrew it's probably fastest to do everything himself. ;) I also renamed \"to do\" to \"main project\" and <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> probably want to add (references to) the gluing approach to that column as well?</p>",
        "id": 261213042,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1636693753
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/261095823\">said</a>:</p>\n<blockquote>\n<p>uses Theorem 2 (which says the localization functor PRS -&gt; LRS is a right adjoint with unit an iso) to deduce that LRS has all limits (I’m unable to find this implication in mathlib). </p>\n</blockquote>\n<p>and I actually found the dual form of this result in monad/limits (the left adjoint is a coreflective functor), mentioned in <a href=\"https://github.com/leanprover-community/mathlib/projects/13#card-72734619\">this card</a>.</p>",
        "id": 261213137,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1636693922
    },
    {
        "content": "<p>Just popping up to say that we can now glue schemes in <a href=\"https://github.com/leanprover-community/mathlib/tree/presheafed_spaces_glue\">branch#presheafed_spaces_glue</a>. </p>\n<p>This will probably come after a sea of PR spams <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span>.</p>",
        "id": 262684610,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1637833375
    },
    {
        "content": "<p>Thank you so much for pushing the algebraic geometry dream forwards! Many of us have been distracted by the Scholze project. In the distant past we'd been experimenting with doing algebraic geometry without using the category theory library, but Scott convinced me that we should use categories, so we defined schemes using the category theory library, went off to celebrate that mathlib had schemes, and then LTE came along and we never came back to it. In some sense this is the first big experiment to see if we can actually get category theory to do something in Lean other than more category theory, and for me this is a really important question but for a long time nobody was working on it. I'm really grateful that this new group of people have appeared (you and Junyan) who are pushing this forward, I think it's a really important experiment.</p>",
        "id": 262684840,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637833559
    },
    {
        "content": "<p>I don't really like this formulation: \"can we actually get category theory to do something in lean other than more category theory\". I mean, of course we know that category theory does something in <em>mathematics</em> other than more category theory, e.g. essentially all of modern algebraic geometry. Whether one can do modern algebraic geometry in Lean is a great and interesting question (surely the answer is \"yes\"), so why not just ask that?</p>",
        "id": 262686517,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637834585
    },
    {
        "content": "<p>But whatever --- this is great progress, and exciting to see, <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span>!</p>",
        "id": 262686567,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637834639
    },
    {
        "content": "<p>Yes sorry Scott -- just to be clear I absolutely meant \"can category theory be used <em>in Lean</em> to do anything other than more category theory\". I use cohomology theories all over the place in my non-Lean work and of course category theory powers this stuff via homological algebra. I meant to stress the point that until algebraic geometry, Lean's category theory library was being developed essentially independently of the rest of mathlib; it would sometimes use the rest of mathlib (e.g. when making the category of rings or the category of R-modules) but the rest of mathlib would never use it. It was Scott who argued strongly to use the category theory library when defining schemes (i.e. we didn't define <code>scheme X</code> like we have <code>ring R</code>, we defined <code>Scheme</code> directly) and this is what we did. This provided a link from category theory to another branch of mathlib (namely algebraic geometry) and then the question became \"does it actually work? Can we now do stuff?\". For a while the answer was \"we don't actually know because nobody is doing stuff\", but now people are doing stuff and it's working. It's also definitely worth pointing out that in a previous incarnation of schemes which didn't use the category theory library (and was never pushed to mathlib, it was Ramon Fernandez Mir's schemes repo) we did try to do gluing and it was really messy. </p>\n<p>The other big application I see of Lean category theory right now in an area of maths which isn't just more category theory is in the LTE repo. The ultimate goal is to show that an Ext group is zero and we have defined the Ext group using the category theory language, even though in applications I guess we want it to represent the assertion that there are no non-trivial extensions of a thing by another thing. We are getting to this stuff right now in LTE so this will represent another proof that Lean 3 categories can be used for things other than Lean 3 categories.</p>\n<p>Sorry for the confusion Scott! Hopefully you're less upset by this clarification. Let me know if you're still upset.</p>",
        "id": 262693162,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637838738
    },
    {
        "content": "<blockquote>\n<p>Lean's category theory library was being developed essentially independently of the rest of mathlib; it would sometimes use the rest of mathlib (e.g. when making the category of rings or the category of R-modules) but the rest of mathlib would never use it.</p>\n</blockquote>\n<p>To provide some visual emphasis on that point:</p>\n<p><a href=\"/user_uploads/3121/Chs1KeLC3yag3sI2RXSOC90T/image.png\">image.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/Chs1KeLC3yag3sI2RXSOC90T/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/Chs1KeLC3yag3sI2RXSOC90T/image.png\"></a></div><p>The highlighted notes are in the <code>category_theory</code>, and node groupings are based on imports</p>",
        "id": 262694059,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637839356
    },
    {
        "content": "<p>what's the blue bit on the right? <code>tactic</code>?</p>",
        "id": 262694644,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1637839733
    },
    {
        "content": "<p><code>core:init</code>. You can investigate yourself at <a href=\"https://eric-wieser.github.io/mathlib-import-graph/\">https://eric-wieser.github.io/mathlib-import-graph/</a>. <code>tactic</code> is more entangled</p>",
        "id": 262695264,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637840067
    },
    {
        "content": "<p>huh. TIL that mathlib has a <code>prelude</code> file: <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/tactic/transfer.lean\"><code>tactic.transfer</code></a></p>",
        "id": 262696614,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1637841074
    },
    {
        "content": "<p>I guess this was imported from core and never changed</p>",
        "id": 262696628,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1637841091
    },
    {
        "content": "<p>But now we have homological algebra, category theory will start to find applications in commutative algebra -- that will be the next area that it invades after alg geom. The reason it's taken so long is that basically it has been only Scott (and then later on Scott and Bhavik and Adam) and it has taken a long time to get to abelian categories. But now we're there! Adam proved that condensed abelian groups were an abelian category the other day, so that works too :D</p>",
        "id": 262697096,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637841442
    },
    {
        "content": "<p>The mathlib prelude file is one of the many interesting things in mathlib that make writing the import minimizer way more tricky in practice than it was in theory, I would be happy to see it gone!</p>",
        "id": 262701018,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637844187
    },
    {
        "content": "<p>Hi Kevin, thanks for the posts and the advertisement on Twitter. Most of the work was actually done by Andrew, as you can see from the number of merged PRs (I have only two). In my experience, the category library has been very useful and very often when I want a result it’s already in it.</p>\n<p>I haven’t had an active PR for a while but in the meantime I created two branches: <code>Gillam</code> for showing LRS has limits following Gillam’s paper, and <code>adjunction_mates</code> for defining lax/pseudofunctors and transferring them across adjunctions, because I found these necessary to work with presheaf pullback, e.g. when showing <code>PresheafedSpace</code> has limits. However, a recent realization has changed my development plan and moved focus towards a more abstract, general, categorical direction. The realization is that the construction of the categories <code>Top</code> from <code>Type</code>, <code>PresheafedSpace</code> from <code>Top</code>, and <code>SheafedSpace</code> from <code>PresheafedSpace</code>, are all examples of <a href=\"https://leanprover-community.github.io/mathlib_docs/category_theory/grothendieck.html\">the Grothendieck construction</a>, resulting from the functor F : C ⥤ Cat which gives a functor between fiber categories for each morphism in the base category. In the first case, the fiber categories are partial orders (the type of topologies on a type ordered by inclusion), in the second case the type of presheaves on a space, and in the last case subsingletons (the is_sheaf Prop; the functor here “is” the implication that a pushforward of a sheaf is a sheaf). However, <code>LocallyRingedSpace</code> from <code>RingedSpace</code> isn’t such an example, but <code>PrimedRingedSpace</code> from <code>RingedSpace</code> is (with fiber categories the partial orders of “prime systems”, actually an example of \"category of elements\").</p>\n<p>I haven’t checked all details, but it appears that the existence of colimits in the Grothendieck construction follows from the existence in the base category and in the fiber categories, plus some minor conditions (e.g. the functor preserves colimits), similar to the proof that PresheafedSpace has colimits, which seems mostly rely on the functors <code>pushforward_over</code>, <code>pushforward_under</code> and <code>pushforward_forget_adjunction</code> in my <a href=\"https://github.com/leanprover-community/mathlib/compare/Gillam?expand=1#diff-252fb30c3a3221e6472db5ba794344dfb423898696e70299653d95f635de06adR236-R277\">Gillam branch</a>, which can be generalized to any Grothendieck construction; moreover the forgetful functor to the base category would preserve colimits. For example, for Top, the functor “is” the coinduced(“quotient”) topology, and it’s adjoint to the functor of induced(“subspace”) topology, and adjoint functors give rise to <em>contravariantly isomorphic</em> Grothendieck constructions, so together with the fact that the topologies on a space form a complete lattice (fiber categories have both limits and colimits), we can show that Top has both limits and colimits. However, my goal is not to refactor the facts about Top, but to deal with limits in PresheafedSpace, where I need to deal with presheafed pullback, which is no longer a strict functor, but has a pseudofunctor structure <a href=\"https://github.com/leanprover-community/mathlib/compare/adjunction_mates#diff-834abea6600f7b555f0b1a8095fc5495aa2f3fed4f3521e0f72ed9109c64cd59R323-R332\">transferred from pushforward across adjunction</a> (the proofs should probably be replaced with a more conceptual and probably shorter/faster one using yoneda faithfulness + adjunction hom_equiv). So here I need to generalize the Grothendieck construction to allow pseudofunctors, or more generally lax functors, which is what I plan to do when I hopefully have some time in the weekend. Would like to hear what categorical people think about it! References are also welcome.</p>",
        "id": 262764463,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1637908572
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> Wow, that sounds like a cool plan!</p>",
        "id": 262765457,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637909896
    },
    {
        "content": "<p>You might be interested in <a href=\"https://arxiv.org/pdf/1705.04296.pdf\">displayed categories</a>. You could say it's a generalization of the Grothendieck construction which allows lax functors to the category of categories and profunctors. As a result you get not only Grothendieck fibrations but <em>all</em> functors (up to isomorphism), but really the point is that the general notion of displayed category is fairly easy to work with in type theory (although you need to use pathovers / <code>==</code> to state associativity etc).</p>\n<p>I don't know that using displayed categories for this formalisation would make things easier overall, but in case you're interested I wrote the basic definitions in Lean <a href=\"https://github.com/dwarn/nielsen-schreier-2/blob/04baa9f3c505efea29e141eaaf12caa4f2ac42c2/src/displayed.lean\">here</a>.</p>",
        "id": 262776690,
        "sender_full_name": "David Wärn",
        "timestamp": 1637919630
    },
    {
        "content": "<p>Another status update:</p>\n<p>we now have this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">Scheme</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_pullback</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"n\">has_pullback_of_cover</span> <span class=\"o\">(</span><span class=\"n\">Z.affine_cover.pullback_cover</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">g</span>\n</code></pre></div>\n<p>It is essentially sorry-free, where the only sorries involved are proved in the currently abandoned <a href=\"https://github.com/leanprover-community/mathlib/issues/9802\">#9802</a></p>\n<p>It is over at <a href=\"https://github.com/leanprover-community/mathlib/tree/open_subfunctor\">branch#open_subfunctor</a> and in the file <a href=\"https://github.com/leanprover-community/mathlib/blob/2eeb86d9e2c0867281b96806995ead6976c33d6b/src/algebraic_geometry/open_subfunctor.lean#L1203-L1204\">open_subfunctor.lean</a>.</p>\n<p>Although the file name, it is constructed via gluing naively, without the Zariski sheaf and the open subfunctor stuff.</p>",
        "id": 263381403,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1638407742
    },
    {
        "content": "<p>Wow! That's quite a milestone!</p>",
        "id": 263382700,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1638408680
    },
    {
        "content": "<p>Just a tiny bit of progress over <a href=\"https://github.com/leanprover-community/mathlib/compare/lax_grothendieck\">branch lax_grothendieck</a> from me last weekend; and I did find the result about limits <a href=\"https://ncatlab.org/nlab/show/Grothendieck+construction#limits_and_colimits\">in nLab</a> from a TCS paper ...</p>",
        "id": 263387430,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1638413581
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> have you seen the old-ish thread about 2-categories? What do you think about defining 2-categories and pseudofunctors in general?</p>",
        "id": 263432025,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1638449747
    },
    {
        "content": "<p><a href=\"#narrow/stream/116395-maths/topic/2-categories/near/231851198\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/2-categories/near/231851198</a></p>",
        "id": 263432244,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1638449853
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> I think I've seen that thread once. The definition of 2-categories is quite long as can be seen in <a href=\"https://github.com/leanprover-community/mathlib/blob/two-cat/src/category_theory/category/2-category.lean\">Bhavik Mehta's work</a>, and I don't have sufficient motivation to work in that generality when all I need in the current application are pseudofunctors from 1-categories to Cat. I also don't have experience working with 2-categories and can't suggest which approach is better. <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> expressed concerns about strict 2-categories gonna be infected with <code>eq.rec</code>and I think displayed categories are an attempt to address the issue, but in my practice <code>eq_to_hom</code> makes equality of objects reasonably pleasant to work with.</p>",
        "id": 263447813,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1638456627
    },
    {
        "content": "<p>@mathlib: Brace yourself. Incoming <code>Γ ⊣ Spec</code></p>\n<p>Big kudos to <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> and <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span></p>",
        "id": 267302260,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1641657415
    },
    {
        "content": "<p>And also to <span class=\"user-mention\" data-user-id=\"384542\">@Justus Springer</span> who laid most of the foundational works!</p>",
        "id": 267302321,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1641657518
    },
    {
        "content": "<p>Next job: fibre products!</p>",
        "id": 267304666,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641660898
    },
    {
        "content": "<p>Amazing work! Thanks <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> and <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> for putting so much work into finishing this project. I hope I can return to become an active contributor in the not-too-distant future. This adjunction should really open the door to the interplay between algebra and geometry. I'm guessing an easy consequence now would be the equivalence of categories between <code>CommRingᵒᵖ</code> and <code>AffineScheme</code>? Is this already formalized?</p>",
        "id": 267348972,
        "sender_full_name": "Justus Springer",
        "timestamp": 1641720902
    },
    {
        "content": "<p>The equivalence was done way back when I first got my hand on Lean. I've just tidied it up into a PR <a href=\"https://github.com/leanprover-community/mathlib/pull/11326\">#11326</a>.<br>\nLooking forward to having you back on board! Hopefully mathlib will know that fibre products exist by then (two-thirds of <a href=\"https://github.com/leanprover-community/mathlib/pull/10605\">#10605</a> is in mathlib now), and together with the adjunction, these will definitely open a lot of doors for us to play with.</p>",
        "id": 267354769,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1641729884
    },
    {
        "content": "<p>Congrats to <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> on the merging of fibered products (<a href=\"https://github.com/leanprover-community/mathlib/pull/11450\">#11450</a> and <a href=\"https://github.com/leanprover-community/mathlib/pull/10605\">#10605</a>)! I didn't follow closely lately but it seems you abandoned the open subfunctor approach at some point and adopted the proof on Hartshorne instead (despite the latter PR is still from a branch named <code>open_subfunctor</code>)? Searching for subfunctor or open_subfunctor turns up nothing relevant in the mathlib repo.</p>",
        "id": 269754284,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1643384103
    },
    {
        "content": "<p>Next step: sheaf cohomology! Or proof that projective morphisms are proper? <span class=\"user-mention\" data-user-id=\"252627\">@Jujian Zhang</span> how far are we from projective morphisms?</p>",
        "id": 269757740,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1643385518
    },
    {
        "content": "<p>Congratulations! </p>\n<p>Now for some additional low hanging fruit: we can use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.has_equalizers_of_pullbacks_and_binary_products\">docs#category_theory.limits.has_equalizers_of_pullbacks_and_binary_products</a> <br>\ntogether with the fact that <code>Scheme</code> has a terminal object (do we know this yet?) and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.finite_limits_from_equalizers_and_finite_products\">docs#category_theory.limits.finite_limits_from_equalizers_and_finite_products</a> to get all finite limits.</p>",
        "id": 269761526,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643387073
    },
    {
        "content": "<p>We may be missing some general construction to obtain binary products from pullbacks and a terminal object</p>",
        "id": 269761807,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643387202
    },
    {
        "content": "<p>Ah, we have it <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_binary_products_of_terminal_and_pullbacks\">docs#has_binary_products_of_terminal_and_pullbacks</a> (in the wrong namespace...)</p>",
        "id": 269762059,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643387306
    },
    {
        "content": "<p>On another branch we have a grading on multi aria level polynomial rings. So we could have projective n space by combining Proj construction and that branch. So we must not be far from projective morphisms but sheaf cohomology is further away I think.</p>",
        "id": 269763062,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1643387702
    },
    {
        "content": "<p>We don't have anything about right derived functors in terms of <em>injective</em> resolutions at the moment. Do we even have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.injective\">docs#category_theory.injective</a> ?</p>",
        "id": 269763317,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643387822
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/269762059\">said</a>:</p>\n<blockquote>\n<p>Ah, we have it <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_binary_products_of_terminal_and_pullbacks\">docs#has_binary_products_of_terminal_and_pullbacks</a> (in the wrong namespace...)</p>\n</blockquote>\n<p>Sorry! I wrote that before I figured out how the category namespaces should work!</p>",
        "id": 269766170,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1643389040
    },
    {
        "content": "<p>As for the next step, I'm trying to develop a framework to describe morphisms between schemes whose conditions are imposed locally. (quasi-compact, quasi-separated, affine, closed immersion, (locally) of finite type, finitely presented, finite, integral, etc.)<br>\nIf anyone want to get on this AG wagon that is in its full speed, a nice and useful result to have is the \"qcqs-lemma\" as called in the rising sea, i.e. these exercises in Hartshorne. Another good thing to have is to define dominant morphisms and proof <a href=\"https://stacks.math.columbia.edu/tag/0CC1\">stacks#0CC1</a>. <br>\n<a href=\"/user_uploads/3121/vUcGz08ByAVpiw4Kqf_b3svh/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/vUcGz08ByAVpiw4Kqf_b3svh/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/vUcGz08ByAVpiw4Kqf_b3svh/image.png\"></a></div>",
        "id": 269768596,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1643390003
    },
    {
        "content": "<p>Someone really need to snatch some AG work from me so that I can do more LTE stuff :(</p>",
        "id": 269769161,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1643390208
    },
    {
        "content": "<p>Another good thing to have is <a href=\"https://github.com/leanprover-community/mathlib/pull/4013\">#4013</a>. <br>\n<span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Is someone working on it now?</p>",
        "id": 269769589,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1643390357
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/269769589\">said</a>:</p>\n<blockquote>\n<p>Another good thing to have is <a href=\"https://github.com/leanprover-community/issue/pull/4013\">issue#4013</a>. <br>\n<span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> Is someone working on it now?</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib/pull/4013\">#4013</a>, issue#x assumes that it's a repo named <code>issue</code></p>",
        "id": 269769706,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643390400
    },
    {
        "content": "<p>Oh. Thanks!</p>",
        "id": 269769820,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1643390430
    },
    {
        "content": "<p>Btw if you need more boilerplate around ring homs (or any other hom, really!), I'm currently writing several hundred lines a day of it, so just tell me and I'll do it.</p>",
        "id": 269770185,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643390568
    },
    {
        "content": "<p>Also <span class=\"user-mention\" data-user-id=\"252627\">@Jujian Zhang</span>  what's the current status on sheaves of modules? I think I saw that you have been working on this too. Are you planning to return after the Proj construction?</p>",
        "id": 269772736,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1643391511
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> Yeah. I did mention somewhere above that I abandoned the open subfunctor approach. On one hand gluing directly only takes about 500 lines, and I didn't really want to spend much more time on this so that I can do more interesting stuff. On the other hand this also gives a good enough open cover of the fibred product.<br>\nAlthough we should eventually need all the open subfunctor stuff later for things like the Grassmanian.</p>",
        "id": 269773664,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1643391880
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"464700\">@David Ang</span> did anyone express an interest in the properties of ring homs listed in <a href=\"https://github.com/leanprover-community/mathlib/pull/4013\">#4013</a> ? Maybe you can tell the LSGNT students where we're up to now? Probably this is just the kind of algebraic geometry that some of them are learning.</p>",
        "id": 269783122,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1643395468
    },
    {
        "content": "<p>In some branch, category of bundled module is defined (restriction and extension of scalars). So sheaves of modules can be defined as functor into category of bundled module using restriction of scalar.</p>",
        "id": 269795595,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1643400868
    },
    {
        "content": "<p>Oh I see. Are you planning to do more stuff about them? Such as defining the associated sheaf of a module, defining coherence, API about submodules (ideals), etc?</p>",
        "id": 269797766,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1643401681
    },
    {
        "content": "<p>Btw is that category concrete? Do we have a good description about what the sheaf condition looks like in that category?</p>",
        "id": 269798173,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1643401887
    },
    {
        "content": "<p>For bundled modules using restriction, I think the forgetful functor to the underlying type of the module (and to the module part of the bundled morphism, noticing that restriction doesn't change the underlying type) is faithful, so it's concrete, no problem.</p>\n<p>(Note: I'm talking about <code>bundledMap</code> in <a href=\"#narrow/stream/113488-general/topic/timeout.20fixed.20by.20changing.20def.20to.20lemma/near/264705272\">this post</a>. I haven't seen the definition using extension instead of restriction, but I guess both resulting BundledModule categories will be isomorphic through extend-restrict adjunction? Notice that the category defined using restriction is an example of the <a href=\"https://leanprover-community.github.io/mathlib_docs/category_theory/grothendieck.html\">Grothendieck construction</a>, but for extension we'd need Grothendieck construction <a href=\"https://github.com/leanprover-community/mathlib/compare/lax_grothendieck?expand=1#diff-779e8ece193ac9cfb8b3ab087590457d8f57c59a774bd663d70eaa8e6a160ecdR135\">generalized to lax functors</a> (I haven't decided whether to refactor my work using the <a href=\"https://leanprover-community.github.io/mathlib_docs/category_theory/bicategory/functor.html#category_theory.oplax_functor\">bicategory formalism</a> recently developed by Yuma Mizuno).)</p>\n<p>I guess a weird thing when using sheaves of bundled modules is that we won't be able to say <code>M: module O_X</code> but have to say that the image of <code>M</code> under the projection functor from sheaves of bundled modules to sheaves of rings is equal to <code>O_X</code>. This might make it complicated to define operations between two <code>O_X</code> modules. Say you want to define the direct sum of two <code>O_X</code> modules, don't you need to transfer the module structure on each open across the equality of the rings on that open? (or maybe equality is evil, and we should use isomorphism instead.)</p>",
        "id": 269815494,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1643410961
    },
    {
        "content": "<p>It isn’t full though. I’m not sure the results still hold in this case?</p>",
        "id": 269816044,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1643411284
    },
    {
        "content": "<p>Yes. Equality is evil and we should use an iso. Still this is unpleasant to work with :(</p>\n<p>Would a typeclass [module Ox F] and some API converting this to and from a Sheaf BundledModule work?<br>\nI’ve never thought deep about these though. The problems elsewhere are already enough to take away all my attention.</p>",
        "id": 269816674,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1643411715
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/269815494\">said</a>:</p>\n<blockquote>\n<p>For bundled modules using restriction, I think the forgetful functor to the underlying type of the module (and to the module part of the bundled morphism, noticing that restriction doesn't change the underlying type) is faithful, so it's concrete, no problem.</p>\n</blockquote>\n<p>I don't think this is faithful. Take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> as a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span>-module with the trivial <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>-action where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> is abelian and has nontrivial automorphisms. You can have nonidentity morphisms on the ring level which are identity on the module in this case, so those would all map to the same morphism of the underlying module.</p>",
        "id": 269816844,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643411823
    },
    {
        "content": "<p>But you can just take the functor sending a bundled module to the product of the ring and the module, and that should be okay.</p>",
        "id": 269817022,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643411941
    },
    {
        "content": "<p>If you want a more geometric example, take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>=</mo><mi>k</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A = k[X,Y]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">]</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">M = k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> with the obvious <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-module structure obtained by identifying <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>=</mo><mi>A</mi><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">k = A/(X,Y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord\">/</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span></span></span></span>. Take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span></span></span></span> the automorphism of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> which interchanges <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>. Then for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">a \\in k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mo>∈</mo><mi>k</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">f(X,Y) \\in k[X,Y]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">]</span></span></span></span> you have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mo>⋅</mo><mi>a</mi><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>Y</mi><mo separator=\"true\">,</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>⋅</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">f(X,Y) \\cdot a = f(Y,X) \\cdot a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> so that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>σ</mi><mo separator=\"true\">,</mo><mn mathvariant=\"bold\">1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\sigma,\\mathbf{1})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathbf\">1</span><span class=\"mclose\">)</span></span></span></span> is a morphism in this category, which is not the identity, but restricts to the identity on the module.</p>",
        "id": 269817515,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643412261
    },
    {
        "content": "<p>Once you have the projection functor from sheaves of bundled modules to sheaves of commutative rings, you could \"curry\" this \"uncurried functor\" (in the sense of Grothendieck constructions) and obtain a pseudofunctor from sheaves on rings to the fiber categories of this projection. You could then define a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">O</mi><mi>X</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}_X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-module as an object in the image of this pseudofunctor under <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">O</mi><mi>X</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}_X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 269818197,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643412722
    },
    {
        "content": "<p>I'm sure there is some general nonsense result out there saying that you can get concreteness for algebras over any (multisorted) Lawvere theory.</p>",
        "id": 269820225,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643414061
    },
    {
        "content": "<blockquote>\n<p>You can have nonidentity morphisms on the ring level which are identity on the module</p>\n</blockquote>\n<p>Oh yes indeed, I take that back. I shouldn't forget about the morphism on rings. Or just take any two morphisms between two rings and the zero modules over them...</p>",
        "id": 269820259,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1643414094
    },
    {
        "content": "<p>Also tagging <span class=\"user-mention\" data-user-id=\"385895\">@Jon Eugster</span> since you seemed to have expressed interest in working on the AG library somewhere else.</p>",
        "id": 269867263,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1643466386
    }
]
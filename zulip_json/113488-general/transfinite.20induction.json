[
    {
        "content": "<p>Just for curiosity, is this a thing in Lean?</p>",
        "id": 123268706,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1520184236
    },
    {
        "content": "<p><a href=\"https://gitter.im/leanprover_public/Lobby?at=5a4a3b7a232e79134db2c204\" target=\"_blank\" title=\"https://gitter.im/leanprover_public/Lobby?at=5a4a3b7a232e79134db2c204\">https://gitter.im/leanprover_public/Lobby?at=5a4a3b7a232e79134db2c204</a></p>",
        "id": 123269021,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1520184927
    },
    {
        "content": "<p>I would like to make a transfinite induction on a type, with respect to a minimal well-order (for which the initial segments are shorter than the whole type). So, I would need something like the next lemma.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">exists_small_well_order</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">rel</span> <span class=\"n\">α</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">is_well_order</span> <span class=\"n\">α</span> <span class=\"n\">r</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n  <span class=\"bp\">#</span><span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"bp\">//</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">#</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>What we have on ordinals and cardinals contains this and much more, for sure, but I found the API hard to work with, and I could not locate this specific lemma (or a suitable variant). <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> , do you have a hint on where I should look?</p>",
        "id": 237813339,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1620390219
    },
    {
        "content": "<p>That is the defining property of <code>ord</code></p>",
        "id": 237813412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620390247
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal.ord\">docs#cardinal.ord</a></p>",
        "id": 237813468,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620390280
    },
    {
        "content": "<p>especially see <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal.card_typein_lt\">docs#cardinal.card_typein_lt</a></p>",
        "id": 237813589,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620390347
    },
    {
        "content": "<p>That's what I am trying to play with, but as far as I can tell these functions don't give me an order on my original type (only on <code>(cardinal.ord (#α)).out.α</code>), so I would need to transport my order through some equiv, but I don't find the lemmas saying that the image of a well-order under an equiv is a well-order.</p>",
        "id": 237814529,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1620390784
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> has done a lot of thing with well-orders recently. Maybe he can help.</p>",
        "id": 237814540,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620390786
    },
    {
        "content": "<p>The reason for the equality hypothesis in <code>card_typein_lt</code> is exactly so that you can use your original type alpha instead of the out type</p>",
        "id": 237816176,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620391564
    },
    {
        "content": "<p>Sure, this lemma is perfect once I know how to construct my well-order on <code>α</code> with the right ordinal type, and this is what I can't see how to do with the current API.</p>",
        "id": 237816393,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1620391656
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/ord_eq\">docs#ord_eq</a>?</p>",
        "id": 237816440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620391678
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 237816678,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1620391790
    },
    {
        "content": "<p>I struggled to get this one (this is so much harder to use a part of the library one doesn't know), but in the end it comes out pretty cleanly. Did you know that, assuming the continuum hypothesis, you can find a subset of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> which is very large if you see it through vertical lines (i.e., along each vertical line, it misses only a countable set), but it is very small if you see it through horizontal lines (i.e., along each horizontal line, it is countable)? This may seem to contradict Fubini (the set has full measure when integrated in one direction, zero measure in the other direction), but of course it is non-measurable.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.hahn_banach</span>\n<span class=\"kn\">import</span> <span class=\"n\">set_theory.cardinal_ordinal</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">cardinal</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">cardinal</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">countable_iff_lt_aleph_one</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">countable</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"bp\">#</span><span class=\"n\">s</span> <span class=\"bp\">&lt;</span> <span class=\"n\">aleph</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">aleph</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">aleph</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">aleph_succ</span><span class=\"o\">,</span> <span class=\"n\">ordinal.succ_zero</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">countable_iff</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">aleph_zero</span><span class=\"o\">,</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">lt_succ</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">sierpinski_pathological_family</span> <span class=\"o\">(</span><span class=\"n\">Hcont</span> <span class=\"o\">:</span> <span class=\"bp\">#</span><span class=\"n\">ℝ</span> <span class=\"bp\">=</span> <span class=\"n\">aleph</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">countable</span> <span class=\"o\">(</span><span class=\"n\">univ</span> <span class=\"bp\">\\</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">countable</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">ord_eq</span> <span class=\"n\">ℝ</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">resetI</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"bp\">|</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">},</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">univ</span> <span class=\"bp\">\\</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"bp\">|</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"bp\">|</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">mem_univ</span><span class=\"o\">,</span> <span class=\"n\">mem_set_of_eq</span><span class=\"o\">,</span> <span class=\"n\">mem_insert_iff</span><span class=\"o\">,</span> <span class=\"n\">union_singleton</span><span class=\"o\">,</span> <span class=\"n\">mem_diff</span><span class=\"o\">],</span>\n      <span class=\"n\">rcases</span> <span class=\"n\">trichotomous_of</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"k\">with</span> <span class=\"n\">h</span><span class=\"bp\">|</span><span class=\"n\">rfl</span><span class=\"bp\">|</span><span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">not_or_distrib</span><span class=\"o\">,</span> <span class=\"n\">false_iff</span><span class=\"o\">,</span> <span class=\"n\">not_true</span><span class=\"o\">],</span>\n        <span class=\"n\">split</span><span class=\"o\">,</span>\n        <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">irrefl_of</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n        <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">asymm</span> <span class=\"n\">h</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">true_or</span><span class=\"o\">,</span> <span class=\"n\">eq_self_iff_true</span><span class=\"o\">,</span> <span class=\"n\">iff_true</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"n\">irrefl</span> <span class=\"n\">x</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">iff_true</span><span class=\"o\">,</span> <span class=\"n\">or_true</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"n\">asymm</span> <span class=\"n\">h</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n    <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">countable.union</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">countable_singleton</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">countable_iff_lt_aleph_one</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Hcont</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">card_typein_lt</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">H</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"k\">assume</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">countable_iff_lt_aleph_one</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Hcont</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">card_typein_lt</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">H</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The part using well-orders can certainly be golfed a lot (why isn't <code>linarith</code> able to close this right away?), but the cardinal API is perfect here.</p>",
        "id": 237828147,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1620396319
    },
    {
        "content": "<p>This is a nice example! FWIW, a while ago I thought a little about creating an API for transfinite recursion, to show things like \"there's a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo>→</mo><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb R \\to \\mathbb R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> which is locally surjective\", where the end-user wouldn't have to think about recursion. For countable recursion, the Rasiowa-Sikorski lemma provides this sort of API, and I used it in <code>order/countable_dense_linear_order</code> to do the back-and-forth method without mentioning recursion. But the story with general transfinite recursion is a little more complicated. Returning to the local surjection example, you can imagine a partial order <code>P</code> of \"states\" for the recursion, where an element of <code>P</code> is a partial function R -&gt; R defined on less than continuum many points. Then you have continuum many \"desired properties\", of the form \"some element in (a,b) should map to x\". Crucially these are all individually \"easy to satisfy\", in the sense that they determine dense subsets of <code>P</code>. But you also need to able to take upper bounds of certain chains in <code>P</code>. Here you need to be careful: it's true that a countable chain in <code>P</code> has an upper bound, but it's possible that a chain of size <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi><mo>&lt;</mo><msup><mn>2</mn><msub><mi mathvariant=\"normal\">ℵ</mi><mn>0</mn></msub></msup></mrow><annotation encoding=\"application/x-tex\">\\kappa &lt; 2^{\\aleph_0}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">κ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.849108em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">ℵ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> has no upper bound. One way of rescuing this is to note that <code>P</code> has a sort of 'rank' function,  sending a partial function to the cardinality of its domain. Then you can say that each \"desired property\" can be satisfied without increasing the rank, and you can take upper bounds of chains given some condition on the ranks (and you get some condition on the rank of the upper bound)</p>",
        "id": 237844128,
        "sender_full_name": "David Wärn",
        "timestamp": 1620402245
    },
    {
        "content": "<p>You don't really need the continuum hypothesis for this, you could just prove it on any set of cardinality aleph 1</p>",
        "id": 237844473,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620402364
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/transfinite.20induction/near/237844473\">said</a>:</p>\n<blockquote>\n<p>You don't really need the continuum hypothesis for this, you could just prove it on any set of cardinality aleph 1</p>\n</blockquote>\n<p>Sure. But the goal is to use this in another proof, and that's the form I need.</p>",
        "id": 237847424,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1620403424
    },
    {
        "content": "<p>Martin's axiom is designed to solve this kind of problem</p>",
        "id": 237875380,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620414740
    },
    {
        "content": "<p>Unfortunately, it's an axiom as opposed to a theorem</p>",
        "id": 237875423,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620414755
    }
]
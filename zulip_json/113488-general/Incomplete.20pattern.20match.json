[
    {
        "content": "<p>There are three most popular ways to deal with partial functions in Lean.</p>\n<p>The first way is to require a proof of the membership of the function's domain as a separate argument. The problem is that we need a proof whenever we want to call the function, so we also need proofs in theorem statements. If there are multiple partial functions, the theorem statement becomes hard to state and comprehend.</p>\n<p>The second way is to use <code>option</code> type. It introduces unnecessary congitive overhead and forces us to work with option monad even if we want to prove something totally unrelated to the <code>option</code> type.</p>\n<p>The third way is to return a junk value. This way turned out to be the most useful and easiest to work with. However, the problem is that it allows us to prove things that are false in real math. For example, <code>nat.pred</code> is implemented such that it returns <code>0</code> for <code>0</code>, so we can prove that the predecessor of <code>0</code> is <code>0</code>, which is false. Also, <code>nat.sub</code> is implemented such that it returns <code>0</code> if the result would be negative, so we can prove that <code>5 - 7 = 0</code>, which doesn't make sense.</p>\n<p>In Isabelle/HOL, there is an axiomatically defined constant <code>undefined</code> which returns a \"random\" value of a given type (all types are inhabited). In Lean, we can implement <code>undefined</code> using <code>nonempty.some</code>, but it still allows us to prove nonsensical things, because <code>nonempty.some</code> always returns the same value for the same type, so it may cancel out if it's used in some other definition.</p>\n<p>It would be nice if we could do something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">pred</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sub</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sub</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>The equation compiler would basically do the following, except it would make the definitions computable:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">pred</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a.succ</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">nat.rec</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">pred_succ</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">pred</span> <span class=\"n\">a.succ</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"n\">pred._proof_1.some_spec</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">sub</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span>\n    <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a.succ</span> <span class=\"n\">b.succ</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">nat.rec</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">pred</span><span class=\"o\">)</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"n\">pred</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"n\">b</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">pred_succ</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">change</span> <span class=\"n\">pred</span> <span class=\"o\">(</span><span class=\"n\">pred</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">ih</span> <span class=\"o\">}},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">sub_zero'</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">sub</span> <span class=\"n\">a</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"n\">sub._proof_1.some_spec.1</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">sub_succ'</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">sub</span> <span class=\"n\">a.succ</span> <span class=\"n\">b.succ</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"n\">sub._proof_1.some_spec.2</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>So, we can't prove anything about <code>pred 0</code>, just like we can't prove anything about <code>5 - 7</code><br>\nWe can't even prove that <code>1 - 2</code> is equal to <code>2 - 3</code></p>\n<p>I guess it will never be implemented in Lean 3, but are there any plans to have something like this in Lean 4? The key point is to produce computable definitions.</p>",
        "id": 279786416,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1650610707
    },
    {
        "content": "<p>This is not intended as an answer to your question, but as my way of dealing with the junk values.  I have been <em>much</em> happier with nat-subtraction when I started parsing it in my mind as <code>max 0 (\"real subtraction\")</code>.  Thus, what you prove is correct, it is just that the symbol <code>lean.-</code> means something different than <code>maths.-</code>.</p>",
        "id": 279787872,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1650612014
    },
    {
        "content": "<p>Once I made peace with this, I started even enjoying the fact that if <code>f</code> is a polynomial, then <code>f.derivative.nat_degree ≤ f.nat_degree - 1</code>, with no extra assumptions!  Thus, <code>lean.-</code> is goofy, but has ways of surprising you with clean statements.</p>",
        "id": 279788093,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1650612203
    },
    {
        "content": "<p>In particular, our goofy nat subtraction has a lot of desirable properties. The main is probably that it is adjoint to addition, namely <code>a - b ≤ c ↔ a ≤ b + c</code> (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/tsub_le_iff_left\">docs#tsub_le_iff_left</a>). And many other \"nonsensical\" mathlib definitions are like this.</p>",
        "id": 279788973,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650612912
    },
    {
        "content": "<blockquote>\n<p>In Isabelle/HOL, there is an axiomatically defined constant <code>undefined</code> which returns a \"random\" value of a given type (all types are inhabited)</p>\n</blockquote>\n<p>In Lean too, it's called <code>undefined</code>/<code>sorry</code>.</p>",
        "id": 279789009,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650612948
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/Incomplete.20pattern.20match/near/279789009\">said</a>:</p>\n<blockquote>\n<p>In Lean too, it's called <code>undefined</code>/<code>sorry</code>.</p>\n</blockquote>\n<p>That's incorrect. In Lean, <code>sorry</code> is a way of cheating - it allows you to prove false (artificially inhabit an empty type). In Isabelle/HOL, <code>undefined</code> is used in real proofs for junk values and you can't derive <code>false</code> from it (implementation bugs aside).</p>",
        "id": 279789344,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1650613194
    },
    {
        "content": "<p>So what does <code>undefined : false</code> mean?</p>",
        "id": 279789463,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650613283
    },
    {
        "content": "<p>It means a syntax error. Isabelle is not a dependently-typed language.</p>",
        "id": 279789570,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1650613343
    },
    {
        "content": "<p>Here's a Lean 4 way to almost do the right thing (it's not quite right because for example <code>rfl : sub 0 1 = sub 0 2</code>).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">pred_undefined</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pred</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pred_undefined</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">constant</span> <span class=\"n\">sub_undefined</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sub</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sub_undefined</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sub</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">pred</span> <span class=\"mi\">0</span>\n<span class=\"c1\">-- 0</span>\n<span class=\"k\">#eval</span> <span class=\"n\">sub</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span>\n<span class=\"c1\">-- 0</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">pred</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">pred</span><span class=\"o\">,</span> <span class=\"n\">sub</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- ⊢ pred_undefined = sub_undefined</span>\n  <span class=\"n\">rfl</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  tactic 'rfl' failed, equality lhs</span>\n<span class=\"cm\">    pred_undefined</span>\n<span class=\"cm\">  is not definitionally equal to rhs</span>\n<span class=\"cm\">    sub_undefined</span>\n<span class=\"cm\">  ⊢ pred_undefined = sub_undefined</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>\n<p>Note that <code>constant</code> requires the type have an <code>Inhabited</code> instance, and it's not causing the definitions to depend on any additional axioms.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">sub</span>\n<span class=\"c1\">-- 'sub' does not depend on any axioms</span>\n</code></pre></div>",
        "id": 279809390,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1650626275
    },
    {
        "content": "<p>After writing that, it occurred to me that you can do the same sort of implementation in Lean 3, but using <code>irreducible</code> definitions instead of constants.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[irreducible]</span> <span class=\"kd\">def</span> <span class=\"n\">pred_undefined</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pred</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">pred_undefined</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">@[irreducible]</span> <span class=\"kd\">def</span> <span class=\"n\">sub_undefined</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sub</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sub_undefined</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sub</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">pred</span> <span class=\"mi\">0</span>\n<span class=\"c1\">-- 0</span>\n<span class=\"k\">#eval</span> <span class=\"n\">sub</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span>\n<span class=\"c1\">-- 0</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">pred</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">pred</span><span class=\"o\">,</span> <span class=\"n\">sub</span><span class=\"o\">],</span>\n  <span class=\"c1\">-- ⊢ pred_undefined = sub_undefined</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  invalid apply tactic, failed to unify</span>\n<span class=\"cm\">    pred_undefined = sub_undefined</span>\n<span class=\"cm\">  with</span>\n<span class=\"cm\">    ?m_2 = ?m_2</span>\n<span class=\"cm\">  state:</span>\n<span class=\"cm\">  ⊢ pred_undefined = sub_undefined</span>\n<span class=\"cm\">  -/</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 279809690,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1650626450
    },
    {
        "content": "<p>Here's one that goes a little farther by making there be more undefined values. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[irreducible]</span> <span class=\"kd\">def</span> <span class=\"n\">sub_undefined</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sub</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sub_undefined</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sub</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">sub</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span> <span class=\"mi\">0</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sub</span><span class=\"o\">],</span>\n  <span class=\"c1\">-- ⊢ sub_undefined 0 = sub_undefined 1</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  invalid apply tactic, failed to unify</span>\n<span class=\"cm\">    sub_undefined 0 = sub_undefined 1</span>\n<span class=\"cm\">  with</span>\n<span class=\"cm\">    ?m_2 = ?m_2</span>\n<span class=\"cm\">  -/</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 279810279,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1650626816
    },
    {
        "content": "<p>Though you can do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">sub</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Would that be provable in Isabelle/HOL?</p>",
        "id": 279810499,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1650626953
    },
    {
        "content": "<p>Your <code>sub_undefined</code> is interesting, because I think you can prove <code>1 - 2 = 2 - 3</code> (edit: without cheating like kevin)</p>",
        "id": 279811107,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650627363
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[irreducible]</span> <span class=\"kd\">def</span> <span class=\"n\">sub_undefined</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sub</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sub_undefined</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sub</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">sub</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span> <span class=\"mi\">0</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sub</span><span class=\"o\">],</span>\n  <span class=\"n\">delta</span> <span class=\"n\">sub_undefined</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"c1\">-- muhahaha</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 279811115,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1650627371
    },
    {
        "content": "<p>I think you'll find that if it compiles then it's not cheating, by definition!</p>",
        "id": 279811159,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1650627416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456794\">Patrick Johnson</span> <a href=\"#narrow/stream/113488-general/topic/Incomplete.20pattern.20match/near/279786416\">said</a>:</p>\n<blockquote>\n<p>In Isabelle/HOL, there is an axiomatically defined constant <code>undefined</code> which returns a \"random\" value of a given type (all types are inhabited). In Lean, we can implement <code>undefined</code> using <code>nonempty.some</code>, but it still allows us to prove nonsensical things, because <code>nonempty.some</code> always returns the same value for the same type, so it may cancel out if it's used in some other definition.</p>\n</blockquote>\n<p>I'm not familiar with Isabelle/HOL, but when trying to learn more about <code>undefined</code>, it looks like <code>undefined = undefined</code> for a given type. If that's true, that seems to mean it has the same properties as <code>nonempty.some</code>.</p>",
        "id": 279811319,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1650627513
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I forgot that <code>irreducible</code> only applies to the elaborator! Oh well. I think the Lean 4 version is safe from anything that (certainly you can't use <code>delta</code> on a <code>constant</code>).</p>",
        "id": 279811719,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1650627760
    },
    {
        "content": "<p>In Isabelle can you prove <code>0 - 1 = 0 - 2</code>?</p>",
        "id": 279811757,
        "sender_full_name": "Reid Barton",
        "timestamp": 1650627785
    },
    {
        "content": "<p>Oh, I guess you said you can't</p>",
        "id": 279811880,
        "sender_full_name": "Reid Barton",
        "timestamp": 1650627860
    },
    {
        "content": "<p>I think the semantics of this kind of thing get tricky. Let's say <code>sub</code> uses <code>undefined</code> in the \"garbage\" case. Then I copy and paste the definition of <code>sub</code> to <code>sub2</code>. Does <code>sub 0 1 = sub2 0 1</code>?</p>",
        "id": 279812027,
        "sender_full_name": "Reid Barton",
        "timestamp": 1650627965
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/Incomplete.20pattern.20match/near/279811757\">said</a>:</p>\n<blockquote>\n<p>In Isabelle can you prove <code>0 - 1 = 0 - 2</code>?</p>\n</blockquote>\n<p>It looks like it depends on how you define the function.</p>\n<p>If you do</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">fun</span> <span class=\"n\">sub</span> <span class=\"o\">::</span> <span class=\"s\">\"nat ⇒ nat =&gt; nat\"</span>\n<span class=\"kp\">where</span>\n  <span class=\"s\">\"sub a b = (case b of 0 ⇒ a | Suc b' =&gt; case sub a b' of Suc k ⇒ k)\"</span>\n</code></pre></div>\n<p>then the <code>undefined</code> jams up the <code>case</code> (and I, who installed Isabelle only about an hour ago, couldn't tell whether <code>case undefined of ...</code> could simplify to <code>undefined</code> or not).</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">foo4</span> <span class=\"o\">:</span> <span class=\"s\">\"sub 0 1 = sub 0 2\"</span>\n  <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">simp_all</span> <span class=\"n\">add</span><span class=\"o\">:</span> <span class=\"n\">sub_def</span><span class=\"o\">)</span>\n  <span class=\"c\">(* fails. goal: undefined = (case undefined of Suc k ⇒ k) *)</span>\n</code></pre></div>\n<p>If instead we define subtraction like</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">fun</span> <span class=\"n\">sub2</span> <span class=\"o\">::</span> <span class=\"s\">\"nat ⇒ nat =&gt; nat\"</span>\n<span class=\"kp\">where</span>\n  <span class=\"s\">\"sub2 a 0 = a\"</span>\n<span class=\"o\">|</span> <span class=\"s\">\"sub2 a (Suc b) = (case a of Suc a' ⇒ sub2 a' b)\"</span>\n</code></pre></div>\n<p>then you can prove <code>0 - 1 = 0 - 2</code> since it simplifies to <code>undefined = undefined</code>, which does end up being true in Isabelle.</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">foo24</span> <span class=\"o\">:</span> <span class=\"s\">\"sub2 0 1 = sub2 0 (Suc 1)\"</span>\n  <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">simp_all</span> <span class=\"n\">add</span><span class=\"o\">:</span> <span class=\"n\">sub_def</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">foo1</span><span class=\"o\">:</span> <span class=\"s\">\"(undefined::nat) = undefined\"</span>\n  <span class=\"k\">by</span> <span class=\"n\">simp_all</span>\n</code></pre></div>\n<p>With both definitions you can't prove <code>0 - 1 = 0</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">foo23</span><span class=\"o\">:</span> <span class=\"s\">\"sub2 0 1 = 0\"</span>\n  <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">simp_all</span> <span class=\"n\">add</span><span class=\"o\">:</span> <span class=\"n\">sub_def</span><span class=\"o\">)</span>\n  <span class=\"c\">(* fails. goal: undefined = 0 *)</span>\n</code></pre></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Isabelle code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span> <span class=\"n\">Scratch</span>\n  <span class=\"kp\">imports</span> <span class=\"n\">Main</span>\n<span class=\"k\">begin</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">foo1</span><span class=\"o\">:</span> <span class=\"s\">\"(undefined::nat) = undefined\"</span>\n  <span class=\"k\">by</span> <span class=\"n\">simp_all</span>\n\n<span class=\"k\">fun</span> <span class=\"n\">sub</span> <span class=\"o\">::</span> <span class=\"s\">\"nat ⇒ nat =&gt; nat\"</span>\n<span class=\"kp\">where</span>\n  <span class=\"s\">\"sub a b = (case b of 0 ⇒ a | Suc b' =&gt; case sub a b' of Suc k ⇒ k)\"</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">foo2</span><span class=\"o\">:</span> <span class=\"s\">\"sub 0 0 = 0\"</span>\n  <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">simp_all</span> <span class=\"n\">add</span><span class=\"o\">:</span> <span class=\"n\">sub_def</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">foo3</span><span class=\"o\">:</span> <span class=\"s\">\"sub 0 1 = 0\"</span>\n  <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">simp_all</span> <span class=\"n\">add</span><span class=\"o\">:</span> <span class=\"n\">sub_def</span><span class=\"o\">)</span>\n  <span class=\"c\">(* fails: undefined = 0 *)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">foo4</span> <span class=\"o\">:</span> <span class=\"s\">\"sub 0 1 = sub 0 2\"</span>\n  <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">simp_all</span> <span class=\"n\">add</span><span class=\"o\">:</span> <span class=\"n\">sub_def</span><span class=\"o\">)</span>\n  <span class=\"c\">(* fails:  undefined = (case undefined of Suc k ⇒ k) *)</span>\n\n<span class=\"k\">fun</span> <span class=\"n\">sub2</span> <span class=\"o\">::</span> <span class=\"s\">\"nat ⇒ nat =&gt; nat\"</span>\n<span class=\"kp\">where</span>\n  <span class=\"s\">\"sub2 a 0 = a\"</span>\n<span class=\"o\">|</span> <span class=\"s\">\"sub2 a (Suc b) = (case a of Suc a' ⇒ sub2 a' b)\"</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">foo22</span><span class=\"o\">:</span> <span class=\"s\">\"sub2 0 0 = 0\"</span>\n  <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">simp_all</span> <span class=\"n\">add</span><span class=\"o\">:</span> <span class=\"n\">sub_def</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">foo23</span><span class=\"o\">:</span> <span class=\"s\">\"sub2 0 1 = 0\"</span>\n  <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">simp_all</span> <span class=\"n\">add</span><span class=\"o\">:</span> <span class=\"n\">sub_def</span><span class=\"o\">)</span>\n  <span class=\"c\">(* fails: undefined = 0 *)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">foo24</span> <span class=\"o\">:</span> <span class=\"s\">\"sub2 0 1 = sub2 0 (Suc 1)\"</span>\n  <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">simp_all</span> <span class=\"n\">add</span><span class=\"o\">:</span> <span class=\"n\">sub_def</span><span class=\"o\">)</span>\n\n<span class=\"k\">end</span>\n</code></pre></div>\n</div></div>",
        "id": 279820610,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1650632630
    },
    {
        "content": "<p>So if the answer to \"can you prove <code>0 - 1 = 0 - 2</code>\" is \"it depends on the exact definition of <code>-</code>\" then I'm not convinced that is an improvement on the answer \"yes\"</p>",
        "id": 279822213,
        "sender_full_name": "Reid Barton",
        "timestamp": 1650633455
    },
    {
        "content": "<p>Whatever the answer, it seems like having a special</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[irreducible]</span> <span class=\"kd\">def</span> <span class=\"n\">undefined</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">arbitrary</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>could still be useful as a way to mark which values are explicitly junk, while doing so in a way that, if it's something you're concerned about, gives you some amount of protection from proving nonsense (so long as you avoid piercing through the <code>irreducible</code> like Kevin did, though that's irrelevant in Lean 4, and also with the caveat that you still need to think about whether a function will evaluate to <code>undefined</code>).</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Lean 3 example with undefined</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">foo</span>\n<span class=\"c1\">-- in a namespace since there is already a top-level `meta def undefined`</span>\n\n<span class=\"kd\">@[irreducible]</span> <span class=\"kd\">def</span> <span class=\"n\">undefined</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">arbitrary</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sub</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">undefined</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sub</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">sub</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span> <span class=\"mi\">0</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">sub</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">sub</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- ⊢ undefined = 0</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- failed to unify</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">foo</span>\n</code></pre></div>\n</div></div>",
        "id": 279823373,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1650634000
    },
    {
        "content": "<p>When I said</p>\n<blockquote>\n<p>In Isabelle/HOL, there is an axiomatically defined constant <code>undefined</code> which returns a \"random\" value of a given type (all types are inhabited). In Lean, we can implement <code>undefined</code> using <code>nonempty.some</code>, but it still allows us to prove nonsensical things, because <code>nonempty.some</code> always returns the same value for the same type, so it may cancel out if it's used in some other definition.</p>\n</blockquote>\n<p>my point was not that Isabelle has something that lean doesn't, but that different theorem provers deal with junk cases in different ways. And yes, <code>undefined</code> is just like <code>nonempty.some</code> in Lean (it's a fixed value of the given type, but we don't know the exact value, except for singleton types). The point is that in Isabelle, <code>undefined</code> is preferred over some exact default value in junk cases. But it's still not the best way to deal with it, since it may cancel out with undefineds from other functions.</p>\n<p>In Lean, I think this definition would be much better:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.string.basic</span>\n\n<span class=\"kd\">@[irreducible]</span>\n<span class=\"kd\">def</span> <span class=\"n\">junk</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">default</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pred</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">junk</span> <span class=\"s2\">\"pred\"</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sub</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">junk</span> <span class=\"o\">(</span><span class=\"s2\">\"sub\"</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sub</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>What I would like to see in Lean 4 is that we can make opaque rather than irreducible definitions (opaque is the kernel's version of irreducible, rather than elaborator's) and to have some macro <code>junk</code> which passes everything from the current definition's context to the <code>junk</code> function in a tuple, so that we don't have to deal with it explicitly.</p>",
        "id": 279833881,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1650639122
    },
    {
        "content": "<p>That's like <code>sub_undefined</code> in <a href=\"#narrow/stream/113488-general/topic/Incomplete.20pattern.20match/near/279810279\">this message</a> but generalized. For what it's worth, it does have some potentially unexpected behavior:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">sub</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 279837575,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1650640624
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456794\">Patrick Johnson</span> <a href=\"#narrow/stream/113488-general/topic/Incomplete.20pattern.20match/near/279833881\">said</a>:</p>\n<blockquote>\n<p>What I would like to see in Lean 4 is that we can make opaque rather than irreducible definitions (opaque is the kernel's version of irreducible, rather than elaborator's) and to have some macro <code>junk</code> which passes everything from the current definition's context to the <code>junk</code> function in a tuple, so that we don't have to deal with it explicitly.</p>\n</blockquote>\n<p>Expect for the macro part, <code>constant</code> does the first part, right?</p>",
        "id": 279837759,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1650640703
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">junk</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">default</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pred</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">junk</span> <span class=\"s2\">\"pred\"</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sub</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">junk</span> <span class=\"o\">(</span><span class=\"s2\">\"sub\"</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sub</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n</code></pre></div>",
        "id": 279838023,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1650640825
    },
    {
        "content": "<p>Naive question, why does it not make sense that <code>pred 0</code> is <code>0</code> and that <code>5 - 7 = 0</code> when the numbers are <code>Nat</code>? Seems very reasonable to me...</p>",
        "id": 289075900,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1657420698
    },
    {
        "content": "<p>It both makes sense and doesn't make sense. It makes sense in that it's <a href=\"https://en.wikipedia.org/wiki/Monus\">monus</a>, but it doesn't make sense in that it doesn't agree with the minus when you embed <code>Nat</code> into <code>Int</code>.</p>",
        "id": 289076236,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1657421132
    },
    {
        "content": "<p>I think whether it makes sense or not just depends on what you're trying to model.</p>",
        "id": 289076304,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1657421166
    },
    {
        "content": "<p>Mathematically it's bad, for sociological reasons. Computer scientists have seen phenomena like this before (eg perhaps 5/2=2 in a system with integers and division) but to a mathematician (who has probably never heard of types) statements like \"0-1=0\" and \"5/2=2\" are <em>indisputably wrong</em> which is problematic. When a mathematician talks about a-b with a,b naturals they would never mean monus, because they've never heard of monus and monus is basically mathematically useless even though it has a role in CS</p>",
        "id": 289081838,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1657428095
    },
    {
        "content": "<p>But if you haven't invented the integers or rationals yet, then why is <code>5 - 7 = 0</code> wrong? It wouldn't make sense to think of embeddings if those supersets haven't been defined yet right?</p>",
        "id": 289084408,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1657432381
    },
    {
        "content": "<p>We invented those things hundreds of years ago and we're not trying to market the software to mathematicians who haven't discovered them yet because they're all dead.</p>",
        "id": 289085124,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1657433628
    },
    {
        "content": "<p>The concept of the integers having \"not been defined yet\" is alien to us (as is the concept of being artificially restricted to answers in a certain type because we think about numerals in a more fluid way)</p>",
        "id": 289085170,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1657433672
    },
    {
        "content": "<p>If mathematicians want to write monus they normally end up writing something like <code>min 0 (a - b)</code> I've basically never seen this ceiling subtraction as it's own function</p>",
        "id": 289116152,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1657475981
    },
    {
        "content": "<p>Wouldn't they write \"max\"?</p>",
        "id": 289118336,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1657479192
    }
]
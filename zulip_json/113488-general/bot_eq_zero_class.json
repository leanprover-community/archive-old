[
    {
        "content": "<p>I'm thinking about a potential new typeclass extending <code>has_bot</code> and <code>has_zero</code> with the single field <code>bot_eq_zero : ⊥ = 0</code>. Such a typeclass would allow us to state a few important theorems on the bottom element, such as <code>∀ x, ⊥ ≤ x</code>, or <code>max x ⊥ = x</code>, in terms of zero, which is useful for rewriting. A nice consequence is that the lemma <code>zero_le</code> would no longer depend on the overpowered <code>canonically_ordered_add_monoid</code> class</p>",
        "id": 284700572,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654146779
    },
    {
        "content": "<p>The particular application I'm thinking of are ordinals, which cannot be a <code>canonically_ordered_add_monoid</code> whilst still satisfying <code>zero_le</code>, but I would bet that there's a few others.</p>",
        "id": 284700597,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654146821
    },
    {
        "content": "<p>I believe that this class, together with <code>partial_order</code>, <code>has_add</code>, and one of the <code>covariant</code> classes, should be enough to prove theorems like <code>one_lt_two</code> and such, which are currently gated behind the overpowered <code>ordered_semiring</code> class</p>",
        "id": 284700732,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654146965
    },
    {
        "content": "<p>(these lemmas aren't even about multiplication! Why do they require it?)</p>",
        "id": 284700748,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654146999
    },
    {
        "content": "<p>Well, <code>one_lt_two</code> and friends are true even when <code>0</code> isn't a bottom element, so I guess these new variants wouldn't obsolete the <code>semiring</code> ones</p>",
        "id": 284700971,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654147267
    },
    {
        "content": "<p>I think a new <code>zero_le_one_class</code> + <code>has_add</code> + <code>partial_order</code> + some <code>covariant</code> class should be enough to prove these lemmas though</p>",
        "id": 284701079,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654147388
    },
    {
        "content": "<p>So that's two proposals</p>",
        "id": 284701081,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654147392
    },
    {
        "content": "<p>Oh and also, these same conditions would be enough to prove <code>odd.pos</code></p>",
        "id": 284701251,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654147584
    },
    {
        "content": "<p>As referenced <a href=\"#narrow/stream/113488-general/topic/odd_gt_zero\">in this other thread</a></p>",
        "id": 284701267,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654147622
    },
    {
        "content": "<p>In fact! These lemmas about <code>one_lt_two</code> and such are all proven in terms of relatively weak typeclasses, with the sole exception of <code>ordered_semiring</code></p>",
        "id": 284702093,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654148717
    },
    {
        "content": "<p>Actually, the <code>zero_le_one_class</code> proposal seems simple and uncontroversial enough</p>",
        "id": 284702267,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654148929
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/14510\">#14510</a></p>",
        "id": 284702425,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654149147
    },
    {
        "content": "<p>I wonder if a <code>zero_lt_one_class</code> might be useful too. That would lead to an even more general form of the numeric comparison lemmas that doesn't depend on multiplication (since <code>zero_ne_one</code> currently depends on <code>mul_zero_one_class</code> and <code>nontrivial</code>)</p>",
        "id": 284702996,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654149719
    },
    {
        "content": "<p>The one example I can think of is <code>pgame</code>, which is not a <code>mul_zero_one_class</code> but still satisfies <code>1 &lt; 2</code> and all these similar lemmas</p>",
        "id": 284703060,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654149781
    },
    {
        "content": "<p>Again, I bet there's more</p>",
        "id": 284703065,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654149785
    },
    {
        "content": "<p>That's three proposals</p>",
        "id": 284703344,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654150019
    },
    {
        "content": "<p>Darn, it seems like my <code>zero_le_one_class</code> breaks dot notation on <code>zero_le_one</code></p>",
        "id": 284704057,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654150731
    },
    {
        "content": "<p>No idea why</p>",
        "id": 284704058,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654150733
    },
    {
        "content": "<p>Wait, what? This broke dot notation on <code>one_le_two</code> even though I didn't even tweak it</p>",
        "id": 284705213,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654151620
    },
    {
        "content": "<p>I must have done something wrong</p>",
        "id": 284705381,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654151785
    },
    {
        "content": "<p>Dot notation is elaborated quite early on, so it is quite sensitive to typeclass issues. Probably redefining <code>ordered_semiring</code> meant that you get a (different) diamond issue, and the issue happens too early to be resolved by unfolding the (not yet found?) instances</p>",
        "id": 284739950,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1654174664
    },
    {
        "content": "<p>This is a constant annoyance with my refactors too :(</p>",
        "id": 284740045,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1654174689
    },
    {
        "content": "<p>Is there any potential fix?</p>",
        "id": 284764090,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654184833
    },
    {
        "content": "<p>Wonder if it would be better for <code>zero_le_one</code> class to take <code>has_le</code> as an argument rather than a field. Just a hunch though</p>",
        "id": 284770278,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654187490
    },
    {
        "content": "<p>I don't really understand the difference between these two approaches</p>",
        "id": 284770289,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654187499
    },
    {
        "content": "<p>Huh, this approach seems to have fixed the issue</p>",
        "id": 284772015,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654188363
    },
    {
        "content": "<p>It builds!</p>",
        "id": 284820643,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654214892
    },
    {
        "content": "<p>Actually, since I'm not using this class to build the hierarchy, I think it might be a better idea to make it take <code>has_zero</code> and <code>has_one</code> as instance arguments</p>",
        "id": 284823689,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654218121
    },
    {
        "content": "<p>To state <code>zero_le_two</code>, I need both <code>add_zero_class</code> and <code>zero_le_one_class</code>, and since <code>add_zero_class</code> extends <code>has_zero</code> and <code>has_one</code> I can't really take both without this</p>",
        "id": 284824091,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654218504
    },
    {
        "content": "<p>What instances do you have in mind for this new class?</p>",
        "id": 284844056,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654240472
    },
    {
        "content": "<p>Because if the only example you have is \"ordinals\", why not just make a non-commutative version of the existing typeclasses (i.e. pick the strongest typeclass you can)</p>",
        "id": 284844407,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654240761
    },
    {
        "content": "<p>Also please don't touch <code>canonically_ordered_whatever</code>, I have a big refactor coming up and I suspect it will fix your problem.</p>",
        "id": 284846401,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1654242448
    },
    {
        "content": "<p>I thought I'd come up with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule\">docs#submodule</a> as an example of an instance, but it turns out that that's a <code>canonically_ordered_add_monoid</code> (<a href=\"https://github.com/leanprover-community/mathlib/pull/14529\">#14529</a>)</p>",
        "id": 284848652,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654244109
    },
    {
        "content": "<p>If you take <code>with_bot</code> of something with <code>zero_le_one_class</code> you should still obtain a <code>zero_le_one_class</code>, but <code>canonically_ordered</code> should not be preserved by the <code>with_bot</code> operation, right?</p>\n<p>E.g. <code>with_bot nat</code> has <code>zero_le_one_class</code>, but is not canonically ordered, since <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bot_eq_zero\">docs#bot_eq_zero</a> fails.</p>\n<p>Note that <code>with_bot nat</code> is the target of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.degree\">docs#polynomial.degree</a>.</p>",
        "id": 284850018,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1654245124
    },
    {
        "content": "<p>As for <code>zero_le_one_class</code>, I don't really have many examples, other than <code>pgame</code> and <code>ordinal</code>. I just find it a bit silly that:</p>\n<ul>\n<li>there's two classes <code>linear_ordered_comm_monoid_with_zero</code> and <code>ordered_semiring</code> with this assumption, yet only one gets to use the lemma in the root namespace <code>zero_le_one</code>.</li>\n<li>the assumptions for <code>zero_le_two</code> and <code>one_le_two</code>, which are laughably simple statements, are very overpowered.</li>\n</ul>",
        "id": 284961073,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654322139
    },
    {
        "content": "<p>As for <code>bot_eq_zero_class</code>, I think that should be a much easier sell. There's all sorts of structures like that: natural numbers, non-negative reals, ordinals, cardinals, ...</p>",
        "id": 284961132,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654322235
    },
    {
        "content": "<p>And I've seen a few certain lemmas, like <code>x ≤ 0 ↔ x = 0</code> or <code>¬ x &lt; 0</code> duplicated throughout these files</p>",
        "id": 284961418,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654322675
    },
    {
        "content": "<p>I'm doing the <code>zero_le_one_class</code> PR first since <code>bot_eq_zero_class</code> would imply that other one, which I suspect may lead to a bit of extra golfing</p>",
        "id": 284961632,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654323033
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> I'm not really modifying the <code>canonically_ordered_thing</code> in my PR</p>",
        "id": 284961652,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654323096
    },
    {
        "content": "<p>May I ask what your refactor is about? Wondering if it will magically fix my issues with ordinals</p>",
        "id": 284961702,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654323142
    },
    {
        "content": "<p>Still I doubt you will need it once I'm done. My refactor is to create a <code>canonical_order</code> mixin (actually, two, one for addition and one for multiplication), and use that in place of <code>canonically_ordered_...</code>, some of which are missing and creating weirdness.</p>",
        "id": 284964462,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1654327702
    },
    {
        "content": "<p>Those would extend <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_exists_add_of_le\">docs#has_exists_add_of_le</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_exists_mul_of_le\">docs#has_exists_mul_of_le</a>.</p>",
        "id": 284964471,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1654327740
    },
    {
        "content": "<p>You mean that I won't need <code>canonical_order_thing</code>, or that I won't need <code>zero_le_one_class</code>?</p>",
        "id": 284964489,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654327780
    },
    {
        "content": "<p>And yeah, your PR seems like it would indeed fix a lot of the current <code>ordinal</code> weirdness!</p>",
        "id": 284964569,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654327863
    },
    {
        "content": "<p>A huge problem right now is the fact that there's no such thing as a canonically ordered monoid without commutative addition</p>",
        "id": 284964574,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654327891
    },
    {
        "content": "<p>Is that actually a huge problem? I understand it would be nice to be able to use the same lemmas on ordinals and elsewhere; but this feels more like an \"annoying papercut\" rather than a \"problem\" that prevents things being formalized</p>",
        "id": 284965097,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654328668
    },
    {
        "content": "<p>Yeah I might have been a bit hyperbolic, it's really an annoying papercut</p>",
        "id": 284965177,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654328851
    },
    {
        "content": "<p>But it's one I'm glad to get rid of!</p>",
        "id": 284965181,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654328858
    },
    {
        "content": "<p>Ordinals have been plagued with these papercuts for the longest time, though a few recent PRs have greatly alleviated the situation</p>",
        "id": 284965292,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654329057
    },
    {
        "content": "<p>Note that your \"sided distributivity\" PR broke many rewrites in the sense that there now is a <code>right_distrib_class ...</code> gozl popping up.</p>",
        "id": 284965717,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1654329789
    },
    {
        "content": "<p>Was it really that many? Also, what's up with <code>rw</code> and adding typeclass goals?</p>",
        "id": 284965834,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654329990
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/bot_eq_zero_class/near/284965717\">said</a>:</p>\n<blockquote>\n<p>Note that your \"sided distributivity\" PR broke many rewrites in the sense that there now is a <code>right_distrib_class ...</code> gozl popping up.</p>\n</blockquote>\n<p>Do you have an example of this? This was one of the things I was afraid of.</p>",
        "id": 284972492,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654339755
    },
    {
        "content": "<p>I guess adding these classes to solve small problems isn't a net good after all <span aria-label=\"pensive\" class=\"emoji emoji-1f614\" role=\"img\" title=\"pensive\">:pensive:</span></p>",
        "id": 284989091,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654361499
    },
    {
        "content": "<p>I still think <code>bot_eq_zero_class</code> is totally worth it, but given that what I have for <code>zero_le_one_class</code> are just small complaints, I'm not so sure about that one</p>",
        "id": 284989625,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654362168
    },
    {
        "content": "<p>I'm not quite convinced that the distributivity refactor was a bad idea, though. I find it really surprising that ordinals are the only structure with one-sided distributivity we ever have to deal with. And though it did break a few <code>rw</code>s, it wasn't that many either</p>",
        "id": 284989667,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654362228
    },
    {
        "content": "<p>Do these extra classes actually cause a significant increase in compile time? Or is it just a few seconds and some random breakage here and there? Because if so, I think the sliver of extra convenience would still be a net gain</p>",
        "id": 284989833,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654362449
    },
    {
        "content": "<p>I should mention that my plan with <code>zero_le_one_class</code> was to follow it up with a <code>zero_lt_one_class</code>. That's a new typeclass giving more potential trouble, but I think it's usefulness should be much more obvious. It would allow to generalize lemmas like <code>0 &lt; 2</code> and such, which currently require <code>semiring</code>s, even though they're lemmas purely about addition. Once again, I only have <code>ordinal</code> and <code>pgame</code> as examples, but I'm much more confident that there should exist structures without well behaved multiplication where comparing natural numbers still makes sense.</p>",
        "id": 284990064,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654362792
    },
    {
        "content": "<p>I'm going to wait for feedback before following through with anything, because I don't really understand the negative consequences of these new typeclasses.</p>",
        "id": 284990350,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654363230
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/bot_eq_zero_class/near/284964462\">said</a>:</p>\n<blockquote>\n<p>My refactor is to create a <code>canonical_order</code> mixin (actually, two, one for addition and one for multiplication), and use that in place of <code>canonically_ordered_...</code>, some of which are missing and creating weirdness.</p>\n</blockquote>\n<p>First half in <a href=\"https://github.com/leanprover-community/mathlib/pull/14556\">#14556</a>.</p>",
        "id": 285002591,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1654380849
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/113488-general/topic/bot_eq_zero_class/near/284989833\">said</a>:</p>\n<blockquote>\n<p>Do these extra classes actually cause a significant increase in compile time? Or is it just a few seconds and some random breakage here and there? Because if so, I think the sliver of extra convenience would still be a net gain</p>\n</blockquote>\n<p>I think the issue with new classes is not as much about compile time increase as it is about maintainability and general understandability of the library. Ideally we would like mathematicians to actually recognize the mathematics we are doing, and coming up with too many bespoke typeclasses makes things harder to untangle. It's a general problem with increasing abstraction, the code eventually becomes utterly unrecognizable on concrete use cases</p>",
        "id": 285010368,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1654393973
    },
    {
        "content": "<p>although the length of the spine of typeclasses is actually directly relevant to the performance of typeclass inference and elaboration thereafter: if you have <code>A.to_C h</code> before and add an intermediate typeclass <code>B</code> you now have <code>A.to_B (B.to_C h)</code> appearing everywhere instead, which is a bigger term that needs more time to typecheck, rewrite, and otherwise manipulate, in addition to the cost of the larger typeclass search that lead to that term in the first place</p>",
        "id": 285010475,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1654394156
    },
    {
        "content": "<p>I don't think any of the classes I'm proposing significantly increases the complexity of the typeclass hierarchy</p>",
        "id": 285011730,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654395961
    },
    {
        "content": "<p>I'm thinking about the <code>bot_eq_zero_class</code> idea again</p>",
        "id": 285874027,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655086411
    },
    {
        "content": "<p>I think that ideally, it would work something like this:</p>\n<ul>\n<li>the class takes in <code>has_bot α</code> and <code>has_zero α</code>, and has a single field <code>bot_eq_zero : ⊥ = 0</code></li>\n<li><code>bot_eq_zero</code> is made into a <code>simp</code> lemma</li>\n<li>we come up with some sort of attribute <code>@[to_zero]</code> (?) that can be added on a lemma involving <code>⊥</code> and turns it into a lemma on <code>0</code>, with the same typeclass assumptions and attributes save for an extra <code>bot_eq_zero</code> typeclass assumption</li>\n</ul>",
        "id": 285874183,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655086575
    },
    {
        "content": "<p>The first two points are super easy to implement, but I have no idea how to do the third one</p>",
        "id": 285874216,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655086591
    },
    {
        "content": "<p>Although, surely it shouldn't be too hard to implement, we already have <code>to_additive</code> which is way more sophisticated</p>",
        "id": 285874236,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655086625
    },
    {
        "content": "<p>We may also want to consider a \"multiplicative\" variant of this idea with a <code>bot_eq_one_class</code>, though that's way more niche I believe</p>",
        "id": 285874313,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655086719
    },
    {
        "content": "<p>I believe <code>ℕ+</code> is the only concrete example we have of something like this</p>",
        "id": 285874343,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655086790
    },
    {
        "content": "<p>Can someone with metaprogramming experience tell me if this is a simple/good idea?</p>",
        "id": 285874399,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655086833
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/113488-general/topic/bot_eq_zero_class/near/285874343\">said</a>:</p>\n<blockquote>\n<p>I believe <code>ℕ+</code> is the only concrete example we have of something like this</p>\n</blockquote>\n<p>Actually, on that topic, do we have any concrete example whatsoever of a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/canonically_ordered_monoid\">docs#canonically_ordered_monoid</a>?</p>",
        "id": 285876385,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655089115
    },
    {
        "content": "<p>The docstring acknowledges that this is rare, and says that some duals of some objects have this property, but there don't seem to be any registered concrete instances</p>",
        "id": 285876408,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655089162
    },
    {
        "content": "<p>I didn't follow the conversation in this thread, but I just tried to bump mathlib in the sphere eversion project, and <code>zero_le_two</code> is now horribly broken. Minimized example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed.group.basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"mi\">2</span><span class=\"bp\">*∥</span><span class=\"n\">g</span><span class=\"bp\">∥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">mul_nonneg</span> <span class=\"n\">zero_le_two</span><span class=\"o\">,</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  type mismatch at application</span>\n<span class=\"cm\">    mul_nonneg zero_le_two</span>\n<span class=\"cm\">  term</span>\n<span class=\"cm\">    zero_le_two</span>\n<span class=\"cm\">  has type</span>\n<span class=\"cm\">    0 ≤ 2</span>\n<span class=\"cm\">  but is expected to have type</span>\n<span class=\"cm\">    0 ≤ ?m_3</span>\n<span class=\"cm\">  state:</span>\n<span class=\"cm\">  G : Type ?,</span>\n<span class=\"cm\">  _inst_1 : normed_group G,</span>\n<span class=\"cm\">  g : G</span>\n<span class=\"cm\">  ⊢ 0 ≤ 2 * ∥g∥</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>This used to work flawlessly. I know how to fix my proof, but I find it really sad.</p>",
        "id": 285897144,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1655109688
    },
    {
        "content": "<p>And next build error is about <code>zero_le_one</code>...</p>",
        "id": 285897458,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1655109852
    },
    {
        "content": "<p>Just so that it is written somewhere, I thought we agreed the plan was to not introduce <code>zero_le_one_class</code> until we made the <code>canonical_add_order</code> mixin I was talking about (<a href=\"https://github.com/leanprover-community/mathlib/pull/14556\">#14556</a> and then a PR I have yet to write), and then see whether we even needed it anymore.</p>",
        "id": 285897495,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1655109876
    },
    {
        "content": "<p>So I am more than happy to revert <a href=\"https://github.com/leanprover-community/mathlib/pull/14510\">#14510</a>.</p>",
        "id": 285897581,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1655109943
    },
    {
        "content": "<p>Fixing the sphere eversion project is rather time consuming so I would prefer if we don't oscillate too much.</p>",
        "id": 285897713,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1655110010
    },
    {
        "content": "<p>Well yeah I'm sorry I wasn't the one hitting merge on <a href=\"https://github.com/leanprover-community/mathlib/pull/14510\">#14510</a>.</p>",
        "id": 285897774,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1655110049
    },
    {
        "content": "<p>I builds now. It turns out that everything needed was related to either <code>zero_le_one</code>/<code>zero_le_two</code> or <code>set.finite</code> now being protected (I guess this is a side effect of Kyle's work but I have no idea why).</p>",
        "id": 285897885,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1655110095
    },
    {
        "content": "<p><code>refine</code> instead of <code>apply</code> works in your mwe</p>",
        "id": 285900318,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1655111332
    },
    {
        "content": "<p>Ok so... my plan was to follow up the <code>zero_le_one_class</code> PR with a <code>zero_lt_one_class</code> PR, but seeing how controversial that last one is, I'd like to put it on the table first</p>",
        "id": 287009436,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655878559
    },
    {
        "content": "<p>The main benefit of such a typeclass is that it allows us to generalize lemmas like <code>0 &lt; 2</code> or <code>1 &lt; 2</code>, which right now have the somewhat overpowered assumption of a nontrivial ordered semiring (these lemmas aren't even about multiplication!)</p>",
        "id": 287009522,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655878607
    },
    {
        "content": "<p>There's also this note on <a href=\"https://leanprover-community.github.io/mathlib_docs/find/zero_lt_one'\">docs#zero_lt_one'</a> about how <code>norm_num</code> can only use <code>0 &lt; 1</code> for the even stronger case of a linear ordered semiring, so such a class seems like it could be useful there too</p>",
        "id": 287009558,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655878673
    },
    {
        "content": "<p>As for concrete types that would benefit from this, I have <code>ordinal</code> and <code>game</code>. The typeclass could be defined on some <code>with_top</code> and <code>with_bot</code> types, though the numeric comparison lemmas wouldn't apply. I'm out of examples but hopeful there's a few more</p>",
        "id": 287009660,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655878778
    },
    {
        "content": "<p>One of the main complaints of the last refactor was random breakage due to typeclass inference. That could be remedied by just making the type argument explicit on all these lemmas. That would add a few extra characters throughout mathlib, but it would also get rid of the dozens of instances of <code>@zero_lt_two α _ _</code> and such.</p>",
        "id": 287010033,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655879087
    },
    {
        "content": "<p>Oh! This instance can also be defined on every linearly ordered commutative group with zero, surely that leads to extra uses?</p>",
        "id": 287012244,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655880955
    },
    {
        "content": "<p>There's also the example of <code>onote</code> though that's admittedly really niche</p>",
        "id": 287012288,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655880971
    },
    {
        "content": "<p>I'm working on generalizing lemmas like <code>zero_ne_one</code> and <code>zero_lt_one</code> by reducing their typeclass assumptions to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ne_zero\">docs#ne_zero</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/zero_le_one_class\">docs#zero_le_one_class</a>, and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/partial_order\">docs#partial_order</a> (no new typeclasses are introduced). This also needs to fix a lot of <code>@zero_lt_two α _ _</code>. <br>\nBefore finishing it I would like to ask if there are any more suggestions.</p>",
        "id": 308982773,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1668085100
    },
    {
        "content": "<p>What new types does it apply to?</p>",
        "id": 308985742,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668086120
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">zero_lt_one</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">zero_le_one_class</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ne_zero</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">zero_lt_two</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_zero_class</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">zero_le_one_class</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ne_zero</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">covariant_class</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span>\n</code></pre></div>",
        "id": 308989415,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1668087310
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>'s question is about what <code>α</code> you forsee this generalization being useful for</p>",
        "id": 308994331,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1668088827
    },
    {
        "content": "<p>It generalizes <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ordinal.zero_lt_one\">docs#ordinal.zero_lt_one</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal.zero_lt_one\">docs#cardinal.zero_lt_one</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/algebra/order/with_zero.html#zero_lt_one%E2%82%80\">docs#zero_lt_one₀</a>, and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/part_enat.zero_lt_one\">docs#part_enat.zero_lt_one</a>.</p>",
        "id": 308999074,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1668090169
    },
    {
        "content": "<p>Doesn't <a href=\"https://leanprover-community.github.io/mathlib_docs/find/zero_lt_one\">docs#zero_lt_one</a> already work for part_enat?</p>",
        "id": 309005214,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1668091983
    },
    {
        "content": "<p>There is no multiplication for part_enat.</p>",
        "id": 309006432,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1668092317
    },
    {
        "content": "<p>Here is the PR <a href=\"https://github.com/leanprover-community/mathlib/pull/17465\">#17465</a></p>",
        "id": 309019768,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1668095957
    },
    {
        "content": "<p>If you define <code>0* infty = 0</code> I think that makes <code>enat</code> an <code>ordered_semiring</code> though, so <code>zero_lt_one</code> should in principle apply.</p>",
        "id": 309022226,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1668096521
    },
    {
        "content": "<p>Indeed <code>enat</code> is already a <code>canonically_ordered_comm_semiring</code>, do we have a good reason for not doing the same with <code>part_enat</code></p>",
        "id": 309023235,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1668096790
    },
    {
        "content": "<p>I think the reason simply that no one cares much about part_enat</p>",
        "id": 309118083,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1668132462
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/part_enat\">docs#part_enat</a> I've never even heard of it</p>",
        "id": 309144815,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1668153701
    },
    {
        "content": "<p>Yeah ok it's constructive enat. Good luck using that. I remember the same thing with <code>ereal</code>, which I made once (reals and +- infinity). I defined neg but was scared to define add because I didn't know what -infty + infty was. Later on I realised I should probably have just made a random decision.</p>",
        "id": 309145148,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1668153871
    },
    {
        "content": "<p>It was the old <code>enat</code> until a month ago when it was renamed and replaced by <code>enat := with_top nat</code>.</p>",
        "id": 309145471,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1668154054
    },
    {
        "content": "<p>Yeah old enat I'm only too familiar with :-(</p>",
        "id": 309145848,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1668154248
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/bot_eq_zero_class/near/309145148\">said</a>:</p>\n<blockquote>\n<p>Yeah ok it's constructive enat. Good luck using that. I remember the same thing with <code>ereal</code>, which I made once (reals and +- infinity). I defined neg but was scared to define add because I didn't know what -infty + infty was. Later on I realised I should probably have just made a random decision.</p>\n</blockquote>\n<p>Since then, we have made a decision on what <code>-infty + infty</code>. It's <code>+infty</code> now. And unfortunately it's the bad convention. Indeed, <code>0 * infty</code> should absolutely by <code>0</code> in <code>ennreal</code> (this is really important in measure theory), and you really want <code>log</code> and <code>exp</code>  between <code>ennreal</code> and <code>ereal</code> to respect the operations. Yet another refactor that will have to de done some day...</p>",
        "id": 309165196,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1668162661
    },
    {
        "content": "<p>Oh wow I hadn't expected someone to come up with a plausible argument for one convention being better!</p>",
        "id": 309172997,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1668165933
    },
    {
        "content": "<p>This even came up in a concrete application (where entropy does not behave well on the empty space unless you have the good convention on ereal).</p>",
        "id": 309173242,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1668166034
    },
    {
        "content": "<p>I assume your claim is that it should be <code>-infty + infty = 0</code>?</p>",
        "id": 309190865,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1668172629
    },
    {
        "content": "<p>The idea is that exp is an isomorphism between <code>ereal</code> and <code>ennreal</code>, with log as the inverse. So if <code>0 * infty = 0</code> in <code>ennreal</code> (which is mathematically useful) then <code>-infty + infty = -infty</code> should be true in <code>ereal</code>.</p>",
        "id": 309191541,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1668172913
    },
    {
        "content": "<p>I split the generalization of <code>zero_ne_one</code> and made PR <a href=\"https://github.com/leanprover-community/mathlib/pull/17477\">#17477</a>. However <code>algebra/ne_zero</code> is ported to mathlib4. Can anyone give me access? My github name is negiizhao.</p>",
        "id": 309213621,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1668180459
    },
    {
        "content": "<p>(invitation sent, following a request elsewhere)</p>",
        "id": 309266857,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1668204670
    }
]
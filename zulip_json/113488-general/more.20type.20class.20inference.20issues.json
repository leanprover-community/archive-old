[
    {
        "content": "<p>It seems to me that for classes like <code>ring</code>defined in core lean or mathlib, you are kind of supposed to use type class inference to make them work.</p>",
        "id": 125320059,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524164368
    },
    {
        "content": "<p>For example, <code>class is_ring_hom {α : Type u} {β : Type v} [ring α] [ring β] (f : α → β) : Prop := ...</code> is now in mathlib</p>",
        "id": 125320070,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524164389
    },
    {
        "content": "<p>now I don't actually know how to make type class inference work in all cases, so I spend some of my time working around it.</p>",
        "id": 125320128,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524164423
    },
    {
        "content": "<p>Here's an example. I have the following structure in my code:</p>",
        "id": 125320162,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524164482
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">presheaf_of_rings</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">presheaf_of_types</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">Fring</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">OU</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">is_open</span> <span class=\"n\">U</span><span class=\"o\">),</span> <span class=\"n\">comm_ring</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">OU</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">res_is_ring_morphism</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">OU</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">is_open</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">OV</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">is_open</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">⊆</span> <span class=\"n\">U</span><span class=\"o\">),</span>\n  <span class=\"n\">is_ring_hom</span> <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">OU</span> <span class=\"n\">OV</span> <span class=\"n\">H</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 125320181,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524164512
    },
    {
        "content": "<p>Yesterday, <code>is_ring_hom</code> was about <code>comm_ring</code>, and I used it in my code via <code>@is_ring_hom _ _ (FPR.Fring HU) (GPR.Fring HU) ...</code>, explicitly giving the proof that something was a comm_ring.</p>",
        "id": 125320267,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524164590
    },
    {
        "content": "<p>But now it's changed to ring and so either I figure out a way of explicitly turning a comm_ring into a ring</p>",
        "id": 125320275,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524164624
    },
    {
        "content": "<p>or I ask here about how I should be doing this properly.</p>",
        "id": 125320318,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524164643
    },
    {
        "content": "<p>In short, Lean / mathlib seems to want me, by default, to prove that things are rings by type class inference.</p>",
        "id": 125320334,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524164671
    },
    {
        "content": "<p>How do I ensure that every time I access a <code>presheaf_of_rings</code> as defined above, <code>presheaf_of_rings.Fring</code> is added to the type class inference system?</p>",
        "id": 125320369,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524164712
    },
    {
        "content": "<p>Is there some clever trick involving an <code>instance</code> statement directly after the definition of <code>presheaf_of_rings</code>?</p>",
        "id": 125320463,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524164862
    },
    {
        "content": "<p>Oh yeah :-)</p>",
        "id": 125320625,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524165072
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">presheaf_of_rings_Fring</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">FPR</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_of_rings</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">OU</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">is_open</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"o\">(</span><span class=\"n\">FPR</span><span class=\"bp\">.</span><span class=\"n\">F</span> <span class=\"n\">OU</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">FPR</span><span class=\"bp\">.</span><span class=\"n\">Fring</span> <span class=\"n\">OU</span>\n</pre></div>",
        "id": 125320629,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524165087
    },
    {
        "content": "<p>As you were :-)</p>",
        "id": 125320631,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524165090
    },
    {
        "content": "<p>What does this mean?</p>",
        "id": 125322233,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524167424
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">presheaf_of_rings</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">presheaf_of_types</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">[</span><span class=\"n\">Fring</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">OU</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">is_open</span> <span class=\"n\">U</span><span class=\"o\">),</span> <span class=\"n\">comm_ring</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">OU</span><span class=\"o\">)]</span>\n<span class=\"o\">(</span><span class=\"n\">res_is_ring_morphism</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">OU</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">is_open</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">OV</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">is_open</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">⊆</span> <span class=\"n\">U</span><span class=\"o\">),</span>\n  <span class=\"n\">is_ring_hom</span> <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">OU</span> <span class=\"n\">OV</span> <span class=\"n\">H</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 125322237,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524167433
    },
    {
        "content": "<p>Is that a thing? It doesn't seem to be a thing.</p>",
        "id": 125322241,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524167441
    },
    {
        "content": "<p><code>comm_ring.to_ring</code> might help</p>",
        "id": 125322275,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1524167500
    },
    {
        "content": "<p><code>attribute [instance] presheaf_of_rings.Fring</code> might also help</p>",
        "id": 125322379,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1524167634
    },
    {
        "content": "<p>Just add that ^ line after the definition of <code>presheaf_of_rings</code></p>",
        "id": 125322454,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1524167728
    },
    {
        "content": "<p>Oh that's a better way :-) Thanks Chris, I'm glad I asked now.</p>",
        "id": 125323095,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524168557
    },
    {
        "content": "<p>I specifically wanted to avoid <code>comm_ring.to_ring</code> as I am pretty sure that the whole point of type class inference is that the end user shouldn't have to use such functions.</p>",
        "id": 125323244,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524168761
    },
    {
        "content": "<p>Actually, is the following a potential problem with the type class system:</p>",
        "id": 125324599,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524170612
    },
    {
        "content": "<p>My understanding (incomplete) of something Johannes was saying a few days ago to Patrick, was that the reason <code>topological_space</code> is defined as a <code>structure</code> with the <code>class</code> attribute added later, rather than a <code>class</code> directly, was that there were occasions when you might want to consider more than one topological space structure on a given type.</p>",
        "id": 125324670,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524170697
    },
    {
        "content": "<p>but ring is defined as a class in core lean</p>",
        "id": 125324680,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524170739
    },
    {
        "content": "<p>so what about the person who wants to prove theorems about putting different ring structures on a type?</p>",
        "id": 125324721,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524170763
    },
    {
        "content": "<p>Are they forced to abandon the type class system, and then they really would have to learn the names of all the theorems mapping a ring to an additive group etc?</p>",
        "id": 125324728,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524170791
    },
    {
        "content": "<p>And here's another question: what if the ring instance is in the same structure?</p>",
        "id": 125324903,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524171034
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">presheaf_of_rings_on_basis</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TX</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">HB</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">is_topological_basis</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">presheaf_of_types_on_basis</span> <span class=\"n\">HB</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">Fring</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"n\">BU</span><span class=\"o\">,</span> <span class=\"n\">comm_ring</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">BU</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">res_is_ring_morphism</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">BU</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"err\">∈</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">BV</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">∈</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">⊆</span> <span class=\"n\">U</span><span class=\"o\">),</span>\n  <span class=\"bp\">@</span><span class=\"n\">is_ring_hom</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Fring</span> <span class=\"n\">U</span> <span class=\"n\">BU</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fring</span> <span class=\"n\">BV</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">BU</span> <span class=\"n\">BV</span> <span class=\"n\">H</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 125324906,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524171046
    },
    {
        "content": "<p>Here a <code>presheaf_of_rings_on_basis</code> has <code>Fring</code> saying something is a commutative ring, and then <code>res_is_ring_morphism</code> which immediately wants to use type class inference to deduce that <code>Fring U BU</code> is a ring. Now do I really have to use <code>comm_ring.to_ring</code>?</p>",
        "id": 125324987,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524171136
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">presheaf_of_rings_on_basis</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TX</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">HB</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">is_topological_basis</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">presheaf_of_types_on_basis</span> <span class=\"n\">HB</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">Fring</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">BU</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"err\">∈</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">comm_ring</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">BU</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">res_is_ring_morphism</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">BU</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"err\">∈</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">BV</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">∈</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">⊆</span> <span class=\"n\">U</span><span class=\"o\">),</span>\n  <span class=\"bp\">@</span><span class=\"n\">is_ring_hom</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">comm_ring</span><span class=\"bp\">.</span><span class=\"n\">to_ring</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">Fring</span> <span class=\"n\">BU</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">comm_ring</span><span class=\"bp\">.</span><span class=\"n\">to_ring</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">Fring</span> <span class=\"n\">BV</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">BU</span> <span class=\"n\">BV</span> <span class=\"n\">H</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 125325099,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524171343
    },
    {
        "content": "<p>Type class inference is failing me badly here. Sorry for no MWE, hopefully people can see the problem; Lean wants me to use type class inference to prove that commutative rings are rings but I don't know how to make this happen in this situation.</p>",
        "id": 125325160,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524171409
    },
    {
        "content": "<p>that's what the brackets inside the structure are for</p>",
        "id": 125325164,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524171420
    },
    {
        "content": "<p>?</p>",
        "id": 125325231,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524171503
    },
    {
        "content": "<p>Oh!</p>",
        "id": 125325233,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524171506
    },
    {
        "content": "<p>:-)</p>",
        "id": 125325247,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524171552
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">presheaf_of_rings_on_basis</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TX</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">HB</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">is_topological_basis</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">presheaf_of_types_on_basis</span> <span class=\"n\">HB</span> <span class=\"o\">:=</span>\n<span class=\"o\">[</span><span class=\"n\">Fring</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">BU</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"err\">∈</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">comm_ring</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">BU</span><span class=\"o\">)]</span>\n<span class=\"o\">(</span><span class=\"n\">res_is_ring_morphism</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">BU</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"err\">∈</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">BV</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">∈</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">⊆</span> <span class=\"n\">U</span><span class=\"o\">),</span>\n  <span class=\"n\">is_ring_hom</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">BU</span> <span class=\"n\">BV</span> <span class=\"n\">H</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 125325251,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524171571
    },
    {
        "content": "<p>So just to be clear -- the square brackets inside the structure trigger type class inference only within the structure definitions?</p>",
        "id": 125325270,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524171602
    },
    {
        "content": "<p>I think they also mark it as an instance, but you should <code>#print</code> to be sure</p>",
        "id": 125325325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524171661
    },
    {
        "content": "<p>I don't think they do</p>",
        "id": 125325334,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524171670
    },
    {
        "content": "<p>because that was what prompted the question about why the square brackets within the structure definition was even a thing</p>",
        "id": 125325344,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524171697
    },
    {
        "content": "<p>earlier</p>",
        "id": 125325345,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524171701
    },
    {
        "content": "<p>you shouldn't need <code>@res</code> either</p>",
        "id": 125325421,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524171786
    },
    {
        "content": "<p>yes, that's gone now</p>",
        "id": 125325481,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524171857
    },
    {
        "content": "<p>But your change of is_ring_hom from [comm_ring] to [ring] has thrown up one final type class inference issue which I can't solve</p>",
        "id": 125325517,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524171926
    },
    {
        "content": "<p>possibly because it's not solvable</p>",
        "id": 125325520,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524171934
    },
    {
        "content": "<p>I think I do need an MWE for this one</p>",
        "id": 125325528,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524171944
    },
    {
        "content": "<p>Oh no it's Ok, indeed I am now pretty convinced that the square brackets in the structure definition do not insert anything into the type class inference system globally</p>",
        "id": 125325814,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524172277
    },
    {
        "content": "<p>because my final problem was solved by Chris' instance trick.</p>",
        "id": 125325890,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524172345
    },
    {
        "content": "<p>Oh this is great. I got stuck on these problems before and blamed it on the type class inference system not being smart enough.</p>",
        "id": 125325902,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524172368
    },
    {
        "content": "<p>I should have asked for help earlier.</p>",
        "id": 125325907,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524172376
    },
    {
        "content": "<p>Patrick said the same thing -- I told him to give up on coercions because they weren't smart enough</p>",
        "id": 125325924,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524172398
    },
    {
        "content": "<p>and he pointed out that whenever he'd got stuck before, you (Mario) had had a trick which got him through.</p>",
        "id": 125325932,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524172419
    },
    {
        "content": "<p>Here's a weird question. It feels to me like <code>comm_ring.to_ring</code> should not be the kind of function which end users have to worry about, because when the devs made <code>ring</code> a typeclass they are somehow declaring that Lean will automatically take care of inferences of this nature.</p>",
        "id": 125326155,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524172709
    },
    {
        "content": "<p>Am I right in thinking that an end user should only have to invoke <code>comm_ring.to_ring</code> in exceptional circumstances?</p>",
        "id": 125326166,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524172738
    },
    {
        "content": "<p>(says the person who just managed to avoid all uses of it when his code broke in lots of places)</p>",
        "id": 125326183,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524172767
    },
    {
        "content": "<p>(when a comm_ring changed to a ring)</p>",
        "id": 125326192,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524172781
    },
    {
        "content": "<p>Aah, more generally should an end user never have to explicitly invoke any theorem tagged with the <code>instance</code> attribute?</p>",
        "id": 125326297,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524172907
    },
    {
        "content": "<p>(unless they are putting more than one structure of a typeclass onto one type, say)</p>",
        "id": 125326358,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524172950
    },
    {
        "content": "<p>Sorry to hijack your thread, but I have a typeclass issue of my own</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">Zmod_setoid</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">n</span><span class=\"bp\">⟩</span> <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">Zmod</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Zmod_setoid</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">private</span> <span class=\"n\">def</span> <span class=\"n\">add_aux</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Zmod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Zmod</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">lift_on₂</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"err\">⟦</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"err\">⟧</span><span class=\"o\">)</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>It cannot infer the <code>setoid</code> instance, probably because it requires an argument. Not sure of a good solution to this.</p>",
        "id": 125328614,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1524176203
    },
    {
        "content": "<p>This is a common problem; I think the <code>lift_on</code> recursor does not correctly deliver the expected type to the lambda. The usual solution is to add an ascription at the lambda:</p>\n<div class=\"codehilite\"><pre><span></span>private def add_aux {n : ℤ} (a b : Zmod n) : Zmod n :=\nquotient.lift_on₂ a b (λ a b, (⟦a + b⟧ : Zmod n)) sorry\n</pre></div>",
        "id": 125328872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524176538
    },
    {
        "content": "<p>Still not working I'm getting this message</p>\n<div class=\"codehilite\"><pre><span></span>synthesized type class instance is not definitionally equal to expression inferred by typing rules, synthesized\n  ⁇\ninferred\n  Zmod_setoid n\n</pre></div>",
        "id": 125328985,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1524176757
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">Zmod_setoid</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">n</span><span class=\"bp\">⟩</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- fails</span>\n</pre></div>",
        "id": 125331043,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524180258
    },
    {
        "content": "<p>I'm not sure that I understand how parametrized instances work.</p>",
        "id": 125331049,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524180280
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">Zmod_setoid</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">n</span><span class=\"bp\">⟩</span> <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">Zmod</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Zmod_setoid</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"err\">⟦</span><span class=\"mi\">3</span><span class=\"err\">⟧</span> <span class=\"o\">:</span> <span class=\"n\">Zmod</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"c1\">-- failed to synthesize type class instance for setoid ℤ</span>\n</pre></div>",
        "id": 125331179,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524180575
    },
    {
        "content": "<p>I'm even less sure now</p>",
        "id": 125331180,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524180584
    },
    {
        "content": "<p><code>#check (⟦(3 : ℤ)⟧ : Zmod 5</code> gives</p>",
        "id": 125331268,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524180722
    },
    {
        "content": "<p><code>⁇ : Zmod 5</code> for information check result (in green)</p>",
        "id": 125331299,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524180761
    },
    {
        "content": "<p>and fails to synthesize the instance</p>",
        "id": 125331303,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524180785
    },
    {
        "content": "<p>Try:</p>\n<div class=\"codehilite\"><pre><span></span>import data.int.modeq\n\n@[reducible]\ndef Zmod (n : ℤ) : Type := ℤ\n\ninstance Zmod_setoid {n : ℤ} : setoid (Zmod n) :=\n{ r := int.modeq n,\n  iseqv := ⟨int.modeq.refl, @int.modeq.symm n, @int.modeq.trans n⟩ }\n\nexample {n : ℤ} : setoid (Zmod n) := by apply_instance\n\n#check ⟦ (3 : Zmod 5) ⟧\n</pre></div>",
        "id": 125331410,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1524181017
    },
    {
        "content": "<p>The problem is that instance inference is only working with <code>ℤ</code> (in your example) to find a setoid instance. It's not enough information to infer the <code>n</code> parameter. Now, I added a synonym for <code>ℤ</code> which provides that information.</p>",
        "id": 125331465,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1524181106
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">reducible</span><span class=\"o\">]</span>\n<span class=\"n\">def</span> <span class=\"n\">Z_aux</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"bp\">ℤ</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">Zmod_setoid</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"o\">(</span><span class=\"n\">Z_aux</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">n</span><span class=\"bp\">⟩</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"o\">(</span><span class=\"n\">Z_aux</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"n\">def</span> <span class=\"n\">Zmod</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Zmod_setoid</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"err\">⟦</span> <span class=\"mi\">3</span> <span class=\"err\">⟧</span> <span class=\"o\">:</span> <span class=\"n\">Zmod</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"c1\">-- 3 is interpreted as being in Z_aux 5 and this works</span>\n\n<span class=\"kn\">private</span> <span class=\"n\">def</span> <span class=\"n\">add_aux</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Zmod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Zmod</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">lift_on₂</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"err\">⟦</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"err\">⟧</span> <span class=\"o\">:</span> <span class=\"n\">Zmod</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"n\">sorry</span> <span class=\"c1\">-- no error yet</span>\n</pre></div>",
        "id": 125331928,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524181966
    },
    {
        "content": "<p>As a mathematician I'm a bit uneasy about having a thing which is Z but which is called Zmod n</p>",
        "id": 125331934,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524181989
    },
    {
        "content": "<p>so I renamed it Z_aux, but your trick is excellent all the same :-)</p>",
        "id": 125331935,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524182013
    },
    {
        "content": "<p>I was worried the check would fail because Lean wouldn't push 3 into Z_aux 5</p>",
        "id": 125331939,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524182037
    },
    {
        "content": "<p><code>setoid</code> is a class and this is in core lean.</p>",
        "id": 125332001,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524182107
    },
    {
        "content": "<p>I think this means that it's quite hard to have more than one instance of a setoid structure on a given type</p>",
        "id": 125332004,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524182133
    },
    {
        "content": "<p>Simon's trick shows how to get around this, by making lots of types, one for each structure</p>",
        "id": 125332006,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524182154
    },
    {
        "content": "<p>it's evil :-)</p>",
        "id": 125332009,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524182161
    },
    {
        "content": "<p>In general, if you need more than one instance of a class for a given type, it should make you suspicious</p>",
        "id": 125332056,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1524182193
    },
    {
        "content": "<p>it's also a good way to handle the multiple rings problem</p>",
        "id": 125332058,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524182205
    },
    {
        "content": "<p>yes</p>",
        "id": 125332059,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524182211
    },
    {
        "content": "<p>I don't think I'd seen it before</p>",
        "id": 125332060,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524182216
    },
    {
        "content": "<p>But you can also name the quotient instead of <code>Z</code>:</p>",
        "id": 125332061,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1524182217
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">Zmod_setoid</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"o\">(</span><span class=\"n\">Zmod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">modeq</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">n</span><span class=\"bp\">⟩</span> <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">Zmod&#39;</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">Zmod_setoid</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"err\">⟦</span> <span class=\"mi\">3</span> <span class=\"err\">⟧</span> <span class=\"o\">:</span> <span class=\"n\">Zmod&#39;</span> <span class=\"mi\">5</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 125332069,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1524182227
    },
    {
        "content": "<p>And if you equip <code>Zmod' 5</code> with <code>has_one</code>, <code>has_zero</code> and <code>has_add</code>, <code>#check (3 : Zmod' 5)</code> should work</p>",
        "id": 125332072,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1524182270
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 125332189,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524182482
    },
    {
        "content": "<p>no need for zero ;-)</p>",
        "id": 125332191,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524182488
    },
    {
        "content": "<p>Even better!</p>",
        "id": 125332193,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1524182499
    },
    {
        "content": "<p>sort of...</p>",
        "id": 125332195,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524182506
    },
    {
        "content": "<p>:-)</p>",
        "id": 125332198,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524182521
    },
    {
        "content": "<blockquote>\n<p>Simon's trick shows how to get around this, by making lots of types, one for each structure</p>\n<p>it's evil :-)</p>\n</blockquote>\n<p>I disagree. If you want the structure to be inferred implicitly, the information must be somewhere. The alternative is to have a different <code>+</code> / <code>*</code> operator for each one of those structures: <code>+_mod_5</code> / <code>*_mod_5</code>. That would be ugly and evil!</p>",
        "id": 125332241,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1524182534
    },
    {
        "content": "<p>If setoid were a structure rather than a class, do you think Chris' code would be OK?</p>",
        "id": 125332255,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524182587
    },
    {
        "content": "<p>The quotient knows the equivalence relation, and the information distinguishing the quotient types is in the equivalence relation</p>",
        "id": 125332260,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524182626
    },
    {
        "content": "<p><code>variables (Y : Type) [has_add Y] [has_one Y]</code></p>",
        "id": 125332359,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524182792
    },
    {
        "content": "<p>I think I just defined the positive integers :-)</p>",
        "id": 125332360,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524182799
    },
    {
        "content": "<p>Yeah I think that would be good. Maybe rather than making <code>setoid</code> a structure, just make <code>Zmod_setoid</code> into a definition because it is not unique</p>",
        "id": 125332361,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1524182805
    },
    {
        "content": "<p>then you'll lose access to the \\[[ notation</p>",
        "id": 125332379,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524182835
    },
    {
        "content": "<p>this goes back to the thing I was talking about earlier</p>",
        "id": 125332381,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524182852
    },
    {
        "content": "<p>once setoid is deemed to be a class</p>",
        "id": 125332382,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524182860
    },
    {
        "content": "<p>then pretty much whenever it's mentioned in a definition or theorem, it's in a square bracket</p>",
        "id": 125332385,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524182880
    },
    {
        "content": "<blockquote>\n<p>I think I just defined the positive integers :-)</p>\n</blockquote>\n<p>That looks like the Church numerals</p>",
        "id": 125332386,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1524182881
    },
    {
        "content": "<p>Sorry, I kind of jumped in the middle your conversation</p>",
        "id": 125332428,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1524182899
    },
    {
        "content": "<p>so it's a pain to work with if you decide not to use the type class inference system</p>",
        "id": 125332434,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524182941
    },
    {
        "content": "<p>Yes, I see now</p>",
        "id": 125332443,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1524182969
    },
    {
        "content": "<p>As Mario points out, it's the same sort of thing as the (hypothetical but not completely impossible) possibility of having more than one ring structure on a type</p>",
        "id": 125332444,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524182985
    },
    {
        "content": "<p>Is it ever necessary to have it inferred?</p>",
        "id": 125332445,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1524182987
    },
    {
        "content": "<p>it's just inconvenient not to have it inferred, if Lean wants it to be inferred.</p>",
        "id": 125332492,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524183017
    },
    {
        "content": "<p>That was what I discovered when I had a commutative ring earlier -- if you use the type class inference system then you also automatically have a ring, an additive group, and a whole bunch of other things</p>",
        "id": 125332499,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524183052
    },
    {
        "content": "<p>and if you don't then you're stuck making all of these yourself</p>",
        "id": 125332504,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524183064
    },
    {
        "content": "<p>What if you skip <code>\\[[</code> and instead rely on <code>coe</code> to convert integers to <code>Zmod</code> and <code>has_one</code> / <code>has_add</code> to use numerals?</p>",
        "id": 125332521,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1524183105
    },
    {
        "content": "<p>I guess the proof of the pudding would be in the eating</p>",
        "id": 125332584,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524183230
    },
    {
        "content": "<p>I was fine explictly writing my proofs that various types were commutative rings up to a point</p>",
        "id": 125332628,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524183252
    },
    {
        "content": "<p>and then it got inconvenient and then I figured out how to use type class inference.</p>",
        "id": 125332632,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524183264
    },
    {
        "content": "<p>Those things aren't quite church numerals</p>",
        "id": 125332637,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524183294
    },
    {
        "content": "<p>as far as I can see at least</p>",
        "id": 125332638,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524183299
    },
    {
        "content": "<p>but they do have a similar flavour</p>",
        "id": 125332647,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524183314
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">hudon_numeral</span> <span class=\"o\">:=</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span>\n<span class=\"n\">def</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">hudon_numeral</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">Y</span> <span class=\"n\">h_add</span> <span class=\"n\">h_one</span><span class=\"o\">,</span> <span class=\"n\">h_one</span>\n<span class=\"n\">def</span> <span class=\"n\">two</span> <span class=\"o\">:</span> <span class=\"n\">hudon_numeral</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">Y</span> <span class=\"n\">h_add</span> <span class=\"n\">h_one</span><span class=\"o\">,</span> <span class=\"n\">h_add</span> <span class=\"n\">h_one</span> <span class=\"n\">h_one</span>\n</pre></div>",
        "id": 125332757,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524183577
    },
    {
        "content": "<p>etc</p>",
        "id": 125332760,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524183589
    },
    {
        "content": "<p>Ah yes I see! 0 is missing and Church encodes <code>succ</code> rather than <code>add</code></p>",
        "id": 125332812,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1524183659
    },
    {
        "content": "<p>Any advice about how to deal with this issue? </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">Zmod_fintype</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">Zmod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">of_equiv</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">equiv_fin</span> <span class=\"n\">hn</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</pre></div>\n\n\n<p>I can't make this an instance, because it's only true if <code>n ≠ 0</code></p>",
        "id": 125443745,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1524222326
    },
    {
        "content": "<p>Why not let n be in pnat (positive integers) instead of Z?</p>",
        "id": 125444830,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524222888
    },
    {
        "content": "<p>Probably the best thing. Alternative is to define the equivalence relation differently in the case <code>n = 0</code>, so <code>Zmod 0</code> is a fintype.</p>",
        "id": 125444960,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1524223105
    },
    {
        "content": "<p>Then there's also the issue of proving it's a field in the case <code>prime p</code></p>",
        "id": 125445223,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1524223570
    },
    {
        "content": "<p><code>fintype (Zmod $ nat.succ m)</code></p>",
        "id": 125445230,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524223636
    },
    {
        "content": "<p><code>n</code> is an int currently</p>",
        "id": 125445289,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1524223768
    },
    {
        "content": "<p>I have another type class inference issue and this one is rather frustrating.</p>",
        "id": 125458960,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524245648
    },
    {
        "content": "<p>I am making a definition, so I really want to stay in term mode.</p>",
        "id": 125458969,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524245671
    },
    {
        "content": "<p>I wrote down something which should work</p>",
        "id": 125458971,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524245682
    },
    {
        "content": "<p>and Lean complained that it could not prove that a certain composition of two maps was a ring homomorphism.</p>",
        "id": 125458983,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524245712
    },
    {
        "content": "<p>So I tried again in tactic mode</p>",
        "id": 125458987,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524245727
    },
    {
        "content": "<p>(each map is a ring hom, with an instance, and the composite of two ring homs is a ring hom, and this is an instance too, so it should work)</p>",
        "id": 125459006,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524245752
    },
    {
        "content": "<p>and in tactic mode I have managed to get Lean into a state where the goal is to show that the map is a ring hom (I did this using <code>refine</code>)</p>",
        "id": 125459058,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524245792
    },
    {
        "content": "<p>and <code>apply_instance</code> fails</p>",
        "id": 125459059,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524245798
    },
    {
        "content": "<p>but <code>show ([cut and paste the goal])</code></p>",
        "id": 125459063,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524245812
    },
    {
        "content": "<p>followed by <code>apply_instance</code> succeeds.</p>",
        "id": 125459066,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524245818
    },
    {
        "content": "<p>In term mode, the proof should look like this:</p>",
        "id": 125459079,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524245854
    },
    {
        "content": "<p><code>to_fun := away.extend_map_of_im_unit ((of_comm_ring (away f) _) ∘ (of_comm_ring R (powers f))) H,</code></p>",
        "id": 125459080,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524245859
    },
    {
        "content": "<p>(it's some part of a structure I'm defining)</p>",
        "id": 125459087,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524245866
    },
    {
        "content": "<p>but <code>away.extend_map_of_im_unit</code> requires that the map (a composite of two ring homs) is a ring hom</p>",
        "id": 125459144,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524245906
    },
    {
        "content": "<p>So here it feels to me like Lean is not working as well as it could be.</p>",
        "id": 125459165,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524245944
    },
    {
        "content": "<p>But I don't have any feeling as to why not</p>",
        "id": 125459169,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524245951
    },
    {
        "content": "<p>If I set <code>pp.all true</code> I can see that the <code>show</code> command is doing something</p>",
        "id": 125459242,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524246060
    },
    {
        "content": "<p>but unfortunately these are complex maps defined between complex rings</p>",
        "id": 125459251,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524246075
    },
    {
        "content": "<p>and so I am having trouble figuring out what I have done wrong</p>",
        "id": 125459257,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524246103
    },
    {
        "content": "<p>and whether it's Lean's fault or mine</p>",
        "id": 125459260,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524246107
    },
    {
        "content": "<p>Here are the two (rather lengthy) goals.</p>",
        "id": 125459438,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524246313
    },
    {
        "content": "<p><a href=\"https://gist.github.com/kbuzzard/a09dc87e290c0497db65c4c702b37c2f\" target=\"_blank\" title=\"https://gist.github.com/kbuzzard/a09dc87e290c0497db65c4c702b37c2f\">https://gist.github.com/kbuzzard/a09dc87e290c0497db65c4c702b37c2f</a></p>",
        "id": 125459440,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524246314
    },
    {
        "content": "<p>Just to be clear: my problem is that I need to prove something in term mode because it's part of a definition. Type class inference fails me and I don't know why. In tactic mode I can make type class inference succeed.</p>",
        "id": 125459524,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524246427
    },
    {
        "content": "<p>I could go down the awful route of adding <code>@</code>s and explicitly chasing up the proof, but I would rather let type class inference do its job properly and just add hints.</p>",
        "id": 125459544,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524246477
    },
    {
        "content": "<p>if it's a proof (i.e. it's type is a <code>Prop</code>) I think you can use a tactic:</p>\n<div class=\"codehilite\"><pre><span></span>to_fun :=\nhave local_proof : something, by ...,\ndefinition_using_local_proof,\n</pre></div>",
        "id": 125459604,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1524246524
    },
    {
        "content": "<p>To my memory, <code>local_proof</code> gets compiled to an auxiliary definition / lemma and you'll have <code>to_fun := definition_using_local_proof</code> with a reference to that auxiliary definition (which will not be displayed because of proof erasure).</p>",
        "id": 125459924,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1524246931
    },
    {
        "content": "<p>Unfortunately this fails, because my local proof is not a proof of the correct thing.</p>",
        "id": 125460308,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524247399
    },
    {
        "content": "<p>My local proof is a proof of the second monstrous expression in the gist, which can be proved by type class inference.</p>",
        "id": 125460313,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524247421
    },
    {
        "content": "<p>I have two maps phi and psi</p>",
        "id": 125460320,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524247433
    },
    {
        "content": "<p>and I can prove <code>is_ring_hom (phi comp psi)</code> with <code>apply_instance</code></p>",
        "id": 125460361,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524247446
    },
    {
        "content": "<p>but when I write <code>foo (phi comp psi)</code></p>",
        "id": 125460370,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524247464
    },
    {
        "content": "<p>for some function foo which needs (phi comp psi) to be a ring hom</p>",
        "id": 125460372,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524247478
    },
    {
        "content": "<p>then type class inference fails</p>",
        "id": 125460374,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524247482
    },
    {
        "content": "<p>well, this is my understanding of the situation.</p>",
        "id": 125460384,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524247501
    },
    {
        "content": "<p>I tried to create a MWE but I could not reproduce the problem in a controlled environment</p>",
        "id": 125460405,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524247518
    },
    {
        "content": "<p>What do you know about <code>phi comp psi</code> that makes it a <code>is_ring_hom</code>? Could you create:</p>\n<div class=\"codehilite\"><pre><span></span>instance [... some context about (phi comp psi) ...] : is_ring_hom (phi comp psi) := ...\n</pre></div>\n\n\n<p>right before the structure you're trying to define?</p>",
        "id": 125460490,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1524247617
    },
    {
        "content": "<p><code>phi</code> and <code>psi</code> are both ring homs themselves, if I understand Kevin correctly</p>",
        "id": 125460538,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1524247677
    },
    {
        "content": "<p>Type class inference will make it a ring hom</p>",
        "id": 125460635,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524247791
    },
    {
        "content": "<p>Here is a very clear explanation of the situation I find myself in:</p>",
        "id": 125460684,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524247808
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>  <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"k\">have</span> <span class=\"n\">XXX</span> <span class=\"o\">:</span> <span class=\"n\">is_ring_hom</span>\n    <span class=\"o\">(</span><span class=\"n\">of_comm_ring</span> <span class=\"o\">(</span><span class=\"n\">away</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"o\">(</span><span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"err\">∘</span> <span class=\"o\">(</span><span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">)</span>\n    <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n  <span class=\"n\">away</span><span class=\"bp\">.</span><span class=\"n\">extend_map_of_im_unit</span>\n              <span class=\"o\">(</span><span class=\"n\">of_comm_ring</span> <span class=\"o\">(</span><span class=\"n\">away</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"o\">(</span><span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"err\">∘</span> <span class=\"o\">(</span><span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">)))</span>\n              <span class=\"n\">sorry</span><span class=\"o\">,</span>\n</pre></div>",
        "id": 125460694,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524247825
    },
    {
        "content": "<p>(the sorry at the end is just to save you from having to look at another term)</p>",
        "id": 125460701,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524247841
    },
    {
        "content": "<p>So this definition fails</p>",
        "id": 125460708,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524247850
    },
    {
        "content": "<p>there's a red squiggle under <code>away</code></p>",
        "id": 125460711,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524247857
    },
    {
        "content": "<p>and the error is</p>",
        "id": 125460715,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524247860
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"n\">class</span> <span class=\"kn\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">,</span>\n<span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span>\n<span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">D&#39;</span> <span class=\"n\">g</span> <span class=\"err\">⊆</span> <span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">D&#39;</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n<span class=\"n\">XXX</span> <span class=\"o\">:</span> <span class=\"n\">is_ring_hom</span> <span class=\"o\">(</span><span class=\"n\">of_comm_ring</span> <span class=\"o\">(</span><span class=\"n\">away</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"o\">(</span><span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"err\">∘</span> <span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">))</span>\n<span class=\"err\">⊢</span> <span class=\"n\">is_ring_hom</span> <span class=\"o\">(</span><span class=\"n\">of_comm_ring</span> <span class=\"o\">(</span><span class=\"n\">away</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"o\">(</span><span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"err\">∘</span> <span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 125460727,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524247885
    },
    {
        "content": "<p>Note that the goal looks exactly like <code>XXX</code></p>",
        "id": 125460736,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524247900
    },
    {
        "content": "<p>and what is even more frustrating is that the goal and <code>XXX</code> were both created in the same way</p>",
        "id": 125460745,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524247919
    },
    {
        "content": "<p>by typing the same string twice</p>",
        "id": 125460790,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524247937
    },
    {
        "content": "<p>namely the string which appears in the goal</p>",
        "id": 125460794,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524247942
    },
    {
        "content": "<p>however if I set pp.all true</p>",
        "id": 125460800,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524247955
    },
    {
        "content": "<p>then XXX and the goal expand into the two distinct, but defeq, monsters</p>",
        "id": 125460808,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524247970
    },
    {
        "content": "<p>and note that XXX was proved by type class inference</p>",
        "id": 125460830,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524248023
    },
    {
        "content": "<p>What I need to understand to proceed, I think, is that I'd like to understand how Lean can unfold the same string in two different ways in these two situations.</p>",
        "id": 125460885,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524248059
    },
    {
        "content": "<p>I am scared to use a let to define the function, because I am scared it will cause me problems further down the line</p>",
        "id": 125460896,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524248093
    },
    {
        "content": "<p>I am trying to prove that a map is a bijection and if I do something screwy when defining the map then I'm worried I won't be able to use it later</p>",
        "id": 125460917,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524248116
    },
    {
        "content": "<p>The problem might be in the two terms that are defeq but not identical. Cosmetic differences in the syntax can take the instance inference process in a different direction. Do you think you can make them exactly identical?</p>",
        "id": 125460977,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1524248207
    },
    {
        "content": "<p>this is exactly what I cannot do</p>",
        "id": 125460979,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524248219
    },
    {
        "content": "<p>because as you can see from my term</p>",
        "id": 125460982,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524248224
    },
    {
        "content": "<p>I created <code>XXX</code> and the input to <code>away.extend_map_of_im_unit </code> by typing exactly the same string of characters.</p>",
        "id": 125460989,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524248254
    },
    {
        "content": "<p>including the <code>@</code>?</p>",
        "id": 125460992,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1524248281
    },
    {
        "content": "<p>aah I see</p>",
        "id": 125461035,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524248296
    },
    {
        "content": "<p>I can try to be more persuasive</p>",
        "id": 125461038,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524248305
    },
    {
        "content": "<p>It will probably not be concise but we can work on that once we know it works</p>",
        "id": 125461051,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1524248359
    },
    {
        "content": "<p>by the way, am I right in thinking that I should not be using <code>let</code> in a defintion of a map?</p>",
        "id": 125461063,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524248395
    },
    {
        "content": "<p>Many thanks Simon</p>",
        "id": 125461117,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524248440
    },
    {
        "content": "<p>Explicitly telling Lean what the type of the composition was has solved the problem</p>",
        "id": 125461123,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524248451
    },
    {
        "content": "<p>Thanks a <em>lot</em> for persevering with this very awkward problem which was completely blocking me.</p>",
        "id": 125461141,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524248485
    },
    {
        "content": "<p>Many thanks indeed.</p>",
        "id": 125461152,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524248519
    },
    {
        "content": "<p>You're very welcome :)</p>",
        "id": 125461200,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1524248554
    },
    {
        "content": "<blockquote>\n<p>by the way, am I right in thinking that I should not be using <code>let</code> in a defintion of a map?</p>\n</blockquote>\n<p>I would avoid it especially if you're going to prove stuff about it. Maybe you're asking about the ùmathlibù style though. I haven't seen that mentioned anywhere but facilitating proofs using your definitions is likely to make you popular with the <code>mathlib</code> team.</p>",
        "id": 125461268,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1524248651
    },
    {
        "content": "<p>Have you tried using <code>by exact</code> in your definition? There is nothing wrong with using tactics in the definition of a term, although you may need to be more conscientious about junk added to your term by lean (or use <code>by clean</code>)</p>",
        "id": 125472229,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524265947
    },
    {
        "content": "<p>there is not a problem with using <code>let</code> or other techniques in defining a complicated function, although you will probably want to write simp lemmas providing your interface so you don't need to rely on definitional expansion</p>",
        "id": 125472249,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524266027
    },
    {
        "content": "<p>Gaargh I have another one. Here's a MWE.</p>",
        "id": 125504684,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524342859
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">ring</span>\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">uu</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">is_unique_R_alg_hom</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">sα</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sβ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">sα</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">sβ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">R_alg_hom</span> <span class=\"o\">:</span> <span class=\"n\">sβ</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"n\">sα</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_unique</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">is_ring_hom</span> <span class=\"n\">g</span> <span class=\"bp\">→</span> <span class=\"n\">sβ</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"err\">∘</span> <span class=\"n\">sα</span> <span class=\"bp\">→</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">comp_unique</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uu</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">γ</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">sα</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sβ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sγ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">sα</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">sβ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">sγ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_unique_R_alg_hom</span> <span class=\"n\">sα</span> <span class=\"n\">sβ</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">is_unique_R_alg_hom</span> <span class=\"n\">sβ</span> <span class=\"n\">sγ</span> <span class=\"n\">g</span> <span class=\"bp\">→</span> <span class=\"n\">is_unique_R_alg_hom</span> <span class=\"n\">sα</span> <span class=\"n\">sγ</span> <span class=\"n\">h</span> <span class=\"bp\">→</span> <span class=\"n\">g</span> <span class=\"err\">∘</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">Uf</span> <span class=\"n\">Ug</span> <span class=\"n\">Uh</span><span class=\"o\">,</span> <span class=\"n\">Uh</span><span class=\"bp\">.</span><span class=\"n\">is_unique</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"err\">∘</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Uf</span><span class=\"bp\">.</span><span class=\"n\">R_alg_hom</span><span class=\"o\">,</span><span class=\"n\">Ug</span><span class=\"bp\">.</span><span class=\"n\">R_alg_hom</span><span class=\"o\">])</span>\n</pre></div>",
        "id": 125504686,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524342872
    },
    {
        "content": "<p>Note the <code>by apply_instance</code> on the last line!</p>",
        "id": 125504689,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524342882
    },
    {
        "content": "<p>If I replace that with <code>_</code> then I get</p>",
        "id": 125504698,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524342907
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>don&#39;t know how to synthesize placeholder\ncontext:\nR : Type u,\nα : Type v,\nβ : Type w,\nγ : Type uu,\n_inst_1 : comm_ring R,\n_inst_2 : comm_ring α,\n_inst_3 : comm_ring β,\n_inst_4 : comm_ring γ,\nsα : R → α,\nsβ : R → β,\nsγ : R → γ,\nf : α → β,\ng : β → γ,\nh : α → γ,\n_inst_5 : is_ring_hom sα,\n_inst_6 : is_ring_hom sβ,\n_inst_7 : is_ring_hom sγ,\n_inst_8 : is_ring_hom f,\n_inst_9 : is_ring_hom g,\n_inst_10 : is_ring_hom h,\nUf : is_unique_R_alg_hom sα sβ f,\nUg : is_unique_R_alg_hom sβ sγ g,\nUh : is_unique_R_alg_hom sα sγ h\n⊢ is_ring_hom (g ∘ f)\n</pre></div>",
        "id": 125504699,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524342912
    },
    {
        "content": "<p>How does type class inference work? Is <code>_</code> something other than <code>by apply_instance</code>?</p>",
        "id": 125504701,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524342957
    },
    {
        "content": "<p>yes</p>",
        "id": 125504758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524343075
    },
    {
        "content": "<p>I guess I just proved that :-)</p>",
        "id": 125504796,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524343084
    },
    {
        "content": "<p><code>_</code> only does unification</p>",
        "id": 125504799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524343086
    },
    {
        "content": "<p>when it is omitted and the binder type is <code>[tc A]</code> it uses typeclass inference</p>",
        "id": 125504804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524343122
    },
    {
        "content": "<p>You need <code>is_unique_R_alg_hom.is_unique</code> to take a square bracket argument</p>",
        "id": 125504805,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1524343131
    },
    {
        "content": "<p><code>by apply_instance</code> does the same thing but manually</p>",
        "id": 125504807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524343135
    },
    {
        "content": "<p>So \"don't know how to synthesize placeholder\" -- what did it try??</p>",
        "id": 125504815,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524343147
    },
    {
        "content": "<p>unification</p>",
        "id": 125504817,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524343164
    },
    {
        "content": "<p>and nothing else</p>",
        "id": 125504820,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524343169
    },
    {
        "content": "<p>I don't know what unification means</p>",
        "id": 125504822,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524343193
    },
    {
        "content": "<p>isn't that something to do with finding something of the right type?</p>",
        "id": 125504860,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524343203
    },
    {
        "content": "<p>Oh</p>",
        "id": 125504865,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524343212
    },
    {
        "content": "<p>I remember</p>",
        "id": 125504866,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524343213
    },
    {
        "content": "<p>it means \"I will call this ?m_6\"</p>",
        "id": 125504869,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524343225
    },
    {
        "content": "<p>\"and sort it out later\"</p>",
        "id": 125504871,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524343230
    },
    {
        "content": "<p>Thanks Patrick:</p>",
        "id": 125504884,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524343305
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">is_unique_R_alg_hom</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">sα</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sβ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">sα</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">sβ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">R_alg_hom</span> <span class=\"o\">:</span> <span class=\"n\">sβ</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"n\">sα</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_unique</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">g</span><span class=\"o\">],</span> <span class=\"n\">sβ</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"err\">∘</span> <span class=\"n\">sα</span> <span class=\"bp\">→</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">comp_unique</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uu</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">γ</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">sα</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sβ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sγ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">sα</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">sβ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">sγ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_unique_R_alg_hom</span> <span class=\"n\">sα</span> <span class=\"n\">sβ</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">is_unique_R_alg_hom</span> <span class=\"n\">sβ</span> <span class=\"n\">sγ</span> <span class=\"n\">g</span> <span class=\"bp\">→</span> <span class=\"n\">is_unique_R_alg_hom</span> <span class=\"n\">sα</span> <span class=\"n\">sγ</span> <span class=\"n\">h</span> <span class=\"bp\">→</span> <span class=\"n\">g</span> <span class=\"err\">∘</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">Uf</span> <span class=\"n\">Ug</span> <span class=\"n\">Uh</span><span class=\"o\">,</span> <span class=\"n\">Uh</span><span class=\"bp\">.</span><span class=\"n\">is_unique</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"err\">∘</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Uf</span><span class=\"bp\">.</span><span class=\"n\">R_alg_hom</span><span class=\"o\">,</span><span class=\"n\">Ug</span><span class=\"bp\">.</span><span class=\"n\">R_alg_hom</span><span class=\"o\">])</span>\n</pre></div>",
        "id": 125504885,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524343313
    },
    {
        "content": "<p>You're welcome</p>",
        "id": 125504929,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1524343374
    },
    {
        "content": "<p>I have abstracted a standard trick :-)</p>",
        "id": 125504934,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524343390
    },
    {
        "content": "<p>I see, I was not even asking type class inference to do its job here. So this one is my bad.</p>",
        "id": 125504986,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524343468
    },
    {
        "content": "<p>Indeed</p>",
        "id": 125504987,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1524343481
    },
    {
        "content": "<p>How do I do this one:</p>",
        "id": 125508966,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524352524
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">α</span> <span class=\"n\">Hα</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">mul_assoc</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)}</span>\n</pre></div>",
        "id": 125508967,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524352530
    },
    {
        "content": "<p>Can I use type class inference here?</p>",
        "id": 125509119,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524352845
    },
    {
        "content": "<p>you need a prop</p>",
        "id": 125509132,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524352900
    },
    {
        "content": "<p>that isn't a prop</p>",
        "id": 125509133,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524352902
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">Hg</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">Hg</span><span class=\"bp\">;</span> <span class=\"k\">from</span> <span class=\"n\">mul_assoc</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">}</span>\n</pre></div>",
        "id": 125509135,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524352922
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">invalid</span> <span class=\"n\">type</span> <span class=\"n\">ascription</span><span class=\"o\">,</span> <span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Prop</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"n\">Hg</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n<span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">Hg</span>\n<span class=\"err\">⊢</span> <span class=\"kt\">Prop</span>\n</pre></div>",
        "id": 125509173,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524352924
    },
    {
        "content": "<p>I have some type mismatch error, I think I have more than one problem here</p>",
        "id": 125509187,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353023
    },
    {
        "content": "<p>which is?</p>",
        "id": 125509237,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524353104
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">Hg</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">mul_assoc</span> <span class=\"bp\">_</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">monoid</span><span class=\"bp\">.</span><span class=\"n\">to_semigroup</span> <span class=\"n\">g</span> <span class=\"err\">$</span> <span class=\"bp\">@</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">to_monoid</span> <span class=\"n\">g</span> <span class=\"n\">Hg</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 125509242,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524353129
    },
    {
        "content": "<p><code>mul_assoc a b c</code> isn't a prop, it's a proof.</p>",
        "id": 125509394,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353413
    },
    {
        "content": "<p>I know I can do it using @, I want to do it using type class inference</p>",
        "id": 125509395,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353425
    },
    {
        "content": "<p>I want to understand how to make type class inference work, not to understand how to work around it (which I already know)</p>",
        "id": 125509397,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353439
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">α</span> <span class=\"n\">Hα</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">one_mul</span> <span class=\"n\">a</span><span class=\"o\">}</span>\n</pre></div>",
        "id": 125509405,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353501
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>failed to synthesize type class instance for\nα : Type,\nHα : group α,\na : α\n⊢ group α\n</pre></div>",
        "id": 125509406,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353516
    },
    {
        "content": "<p>then just letI</p>",
        "id": 125509408,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524353517
    },
    {
        "content": "<p>Where do I put the letI?</p>",
        "id": 125509445,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353523
    },
    {
        "content": "<p>I am in the middle of a structure</p>",
        "id": 125509448,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353527
    },
    {
        "content": "<p><code>by letI := H\\a; from group.one_mul a</code></p>",
        "id": 125509449,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524353540
    },
    {
        "content": "<p>What if I don't want to go into tactic mode because I am actually defining something?</p>",
        "id": 125509450,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353573
    },
    {
        "content": "<p>What exactly are yuo suggesting?</p>",
        "id": 125509455,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353634
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">α</span> <span class=\"n\">Hα</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">Hα</span><span class=\"bp\">;</span> <span class=\"k\">from</span> <span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">one_mul</span> <span class=\"n\">a</span><span class=\"o\">}</span>\n</pre></div>",
        "id": 125509461,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353642
    },
    {
        "content": "<p>?</p>",
        "id": 125509493,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353643
    },
    {
        "content": "<p>yes</p>",
        "id": 125509494,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524353646
    },
    {
        "content": "<p>7 errors</p>",
        "id": 125509499,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353668
    },
    {
        "content": "<p>including \"unknown identifier <code>letI</code>\"</p>",
        "id": 125509502,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353689
    },
    {
        "content": "<p>But even if we can get this to work</p>",
        "id": 125509506,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353706
    },
    {
        "content": "<p>import anything from mathlib</p>",
        "id": 125509509,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524353711
    },
    {
        "content": "<p>I would rather just make type class inference work.</p>",
        "id": 125509512,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353728
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">α</span> <span class=\"n\">Hα</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">Hα</span><span class=\"bp\">;</span> <span class=\"k\">from</span> <span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">one_mul</span> <span class=\"n\">a</span><span class=\"o\">}</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">X</span><span class=\"bp\">._</span><span class=\"n\">proof_1</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">theorem X._proof_1 : ∀ (α : Type) (Hα : group α) (a : α), 1 * a = a :=</span>\n<span class=\"cm\">λ (α : Type) (Hα : group α) (a : α), let _inst : group α := Hα in group.one_mul a</span>\n<span class=\"cm\">-/</span>\n</pre></div>",
        "id": 125509514,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524353734
    },
    {
        "content": "<p>?!</p>",
        "id": 125509518,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353754
    },
    {
        "content": "<p>!?</p>",
        "id": 125509520,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524353761
    },
    {
        "content": "<p>which version of Lean are you using?</p>",
        "id": 125509561,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353791
    },
    {
        "content": "<p>aah</p>",
        "id": 125509562,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353805
    },
    {
        "content": "<p>I have no import</p>",
        "id": 125509563,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353807
    },
    {
        "content": "<p><code>letI</code> is some mathlib magic I guess</p>",
        "id": 125509568,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353842
    },
    {
        "content": "<p>it is.</p>",
        "id": 125509569,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524353849
    },
    {
        "content": "<p>it is Mario's workaround of Leo's changes.</p>",
        "id": 125509571,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524353855
    },
    {
        "content": "<p>So it's in mathlib.</p>",
        "id": 125509572,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524353857
    },
    {
        "content": "<p>Well thank you for your answer, which kind of stinks</p>",
        "id": 125509573,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353876
    },
    {
        "content": "<p>Your answer seems to indicate that <code>[group \\a]</code> is useless in my structure</p>",
        "id": 125509612,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353896
    },
    {
        "content": "<p>i.e. it didn't insert H\\a into the type class inference system anyway</p>",
        "id": 125509614,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353912
    },
    {
        "content": "<p>but wait a minute, isn't this what Patrick told me to do earlier?</p>",
        "id": 125509622,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353953
    },
    {
        "content": "<p>only typeclasses before the colon are inserted</p>",
        "id": 125509623,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524353954
    },
    {
        "content": "<p>that is Leo's changes</p>",
        "id": 125509624,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524353962
    },
    {
        "content": "<p>I am writing another localization interface by the way</p>",
        "id": 125509626,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353990
    },
    {
        "content": "<p>rewriting your universal properties</p>",
        "id": 125509627,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524353994
    },
    {
        "content": "<p>heh</p>",
        "id": 125509628,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524353998
    },
    {
        "content": "<p>you don't need to use <code>letI</code>, <code>by exactI</code> is the right solution for this application</p>",
        "id": 125509979,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524354733
    },
    {
        "content": "<p>aha</p>",
        "id": 125510034,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524354895
    },
    {
        "content": "<p><a href=\"https://github.com/kbuzzard/lean-stacks-project/blob/master/src/localization_UMP.lean\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-stacks-project/blob/master/src/localization_UMP.lean\">https://github.com/kbuzzard/lean-stacks-project/blob/master/src/localization_UMP.lean</a></p>",
        "id": 125510848,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524356756
    },
    {
        "content": "<p>I have finally battled through all my typeclass inference issues.</p>",
        "id": 125510887,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524356771
    },
    {
        "content": "<p>Kenny, I wrote an even better interface for localization</p>",
        "id": 125510888,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524356785
    },
    {
        "content": "<p>I put all the stuff which makes up the universal properties into one structure</p>",
        "id": 125510889,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524356810
    },
    {
        "content": "<p><code>is_unique_R_alg_hom</code></p>",
        "id": 125510892,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524356825
    },
    {
        "content": "<p>Mario, it's not quite mathlib-ready, but one day this should probably be in mathlib in some form if localization is in</p>",
        "id": 125510895,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524356847
    },
    {
        "content": "<p>because this file makes the localization stuff usable without ever having to touch the quotient type itself</p>",
        "id": 125510897,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524356865
    },
    {
        "content": "<p>I know because I'm using localization all the time in my schemes work and this work is what led me to the formalisation and the instances in the file I just linked to</p>",
        "id": 125510936,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524356912
    },
    {
        "content": "<p>There's one more instance of the structure which is commonly used which we still have to fill in</p>",
        "id": 125510937,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524356930
    },
    {
        "content": "<p>Shouldn't <code>comp_unique</code> read something like <code>is_unique_R_alg_hom sα sβ f → is_unique_R_alg_hom sβ sγ g → is_unique_R_alg_hom sα sγ (g ∘ f)</code>?</p>",
        "id": 125511151,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524357433
    },
    {
        "content": "<blockquote>\n<p><code>by rw ←HR.symm</code></p>\n</blockquote>\n<p>what?</p>",
        "id": 125511244,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524357656
    },
    {
        "content": "<p>Nice one!</p>",
        "id": 125523403,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1524388209
    },
    {
        "content": "<p>Kevin, is there is reason why your file doesn't have <code>open classical</code> towards the top? You write <code>classical.</code> quite a lot</p>",
        "id": 125523409,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1524388313
    },
    {
        "content": "<blockquote>\n<p>Shouldn't <code>comp_unique</code> read something like <code>is_unique_R_alg_hom sα sβ f → is_unique_R_alg_hom sβ sγ g → is_unique_R_alg_hom sα sγ (g ∘ f)</code>?</p>\n</blockquote>\n<p>No. That's not even true in general. The standard use of the universal property to prove that certain maps are isomorphisms is via the following argument: \"We are given maps X-&gt; Y and Y -&gt; X. The given map from X to Y is the only map X -&gt; Y with a certain property (e.g. being an R-algebra map). The map given Y -&gt; X is the only map Y -&gt; X with a certain property. Composition of two maps with the property has the property. The identity map X -&gt; X is the only map X -&gt; X with the property. Hence X -&gt; Y -&gt; X is the identity map by comp_unique. Furthermore the identity map Y -&gt; Y is the only map Y -&gt; Y with the property. Hence Y -&gt; X -&gt; Y is also the identity. So X isomorphic to Y\".</p>",
        "id": 125523921,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524389573
    },
    {
        "content": "<p>The reason your suggestion is not true is that there could be plenty of maps from A to C which don't factor through B.</p>",
        "id": 125523973,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524389711
    },
    {
        "content": "<p>I don't open classical because I typically don't open anything. I am very bad at namespaces in general. A whole bunch of my code is incorrectly sitting in the root namespace. The whole thing needs a clear-up.</p>",
        "id": 125524012,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524389785
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p><code>by rw ←HR.symm</code></p>\n</blockquote>\n<p>what?</p>\n</blockquote>\n<p>ha ha. I think it was getting late at that point. This was kind of stupid. I had that composition of f and g was h, but needed to show <code>forall x, f (g x) = h x</code>and I felt that this should just be an application of a standard lemma but I couldn't find it. So I just wrote \"lambda x, by rw (proof that f circ g = h)\" a few times, but then something was the other way round so I switched it and then something else was the other way around so I had to switch it back</p>",
        "id": 125524203,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524390282
    },
    {
        "content": "<blockquote>\n<p>Shouldn't <code>comp_unique</code> read something like <code>is_unique_R_alg_hom sα sβ f → is_unique_R_alg_hom sβ sγ g → is_unique_R_alg_hom sα sγ (g ∘ f)</code>?</p>\n</blockquote>\n<p>Maybe you'll like this one:</p>",
        "id": 125628730,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524588651
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">unique_R_of_unique_R_of_unique_Rloc</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uu</span><span class=\"o\">}</span>\n<span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">γ</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">sα</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">sα</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">fαβ</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">fαβ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">fβγ</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">fβγ</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"n\">is_unique_R_alg_hom</span> <span class=\"n\">sα</span> <span class=\"o\">(</span><span class=\"n\">fβγ</span> <span class=\"err\">∘</span> <span class=\"n\">fαβ</span> <span class=\"err\">∘</span> <span class=\"n\">sα</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fβγ</span> <span class=\"err\">∘</span> <span class=\"n\">fαβ</span><span class=\"o\">)</span>\n<span class=\"bp\">→</span> <span class=\"n\">is_unique_R_alg_hom</span> <span class=\"n\">fαβ</span> <span class=\"o\">(</span><span class=\"n\">fβγ</span> <span class=\"err\">∘</span> <span class=\"n\">fαβ</span><span class=\"o\">)</span> <span class=\"n\">fβγ</span>\n<span class=\"bp\">→</span> <span class=\"n\">is_unique_R_alg_hom</span> <span class=\"o\">(</span><span class=\"n\">fαβ</span> <span class=\"err\">∘</span> <span class=\"n\">sα</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fβγ</span>  <span class=\"err\">∘</span> <span class=\"n\">fαβ</span> <span class=\"err\">∘</span> <span class=\"n\">sα</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fβγ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</pre></div>",
        "id": 125628734,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524588661
    },
    {
        "content": "<p>If there's a unique R-alg hom from alpha to gamma and a unique alpha-alg hom from beta to gamma then there's a unique R-alg hom from beta to gamma (and it's the same map)</p>",
        "id": 125628799,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524588725
    },
    {
        "content": "<p>(oh, the R-alg hom from alpha to gamma must be the composite of a given map alpha -&gt; beta and our given alpha-alg map from beta to gamma)</p>",
        "id": 125628813,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524588765
    },
    {
        "content": "<p>This feels like you want to hit it with Yoneda and reduce it to some basic set-theoretic fact... But that is only instinct</p>",
        "id": 125629917,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1524590307
    },
    {
        "content": "<p>You're looking at both R-alg-homs and alpha-alg-homs... so maybe it is not that straightforward actually</p>",
        "id": 125629948,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1524590360
    },
    {
        "content": "<p>don't get him started on alpha</p>",
        "id": 125629956,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524590378
    },
    {
        "content": "<p>What do you mean?</p>",
        "id": 125629960,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1524590388
    },
    {
        "content": "<p>There is alpha's everywhere in his code</p>",
        "id": 125629968,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1524590397
    },
    {
        "content": "<p>I was actually surprised when I saw that</p>",
        "id": 125630009,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1524590404
    },
    {
        "content": "<p>don't say \"alpha\" and any mathematical object in the same sentence in front of kevin buzzard</p>",
        "id": 125630023,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524590427
    },
    {
        "content": "<p>But he just did that himself!</p>",
        "id": 125630032,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1524590446
    },
    {
        "content": "<p>it doesn't matter</p>",
        "id": 125630039,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524590457
    },
    {
        "content": "<p>Did you notice that when we were doing groups earlier I used alpha to be a group homomorphism just to wind up the CS folk?</p>",
        "id": 125630634,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524591234
    },
    {
        "content": "<p>alpha : G to H</p>",
        "id": 125630639,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524591241
    },
    {
        "content": "<p>The reason I am using alpha for a ring</p>",
        "id": 125630684,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524591252
    },
    {
        "content": "<p>is that the most important ring is called R</p>",
        "id": 125630687,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524591256
    },
    {
        "content": "<p>and then I needed three more</p>",
        "id": 125630689,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524591259
    },
    {
        "content": "<p>but I couldn't face S T U</p>",
        "id": 125630693,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524591267
    },
    {
        "content": "<p>so I thought alpha beta gamma was OK</p>",
        "id": 125630696,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524591274
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"k\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">Hαβ</span> <span class=\"n\">Hβγ</span><span class=\"o\">,</span>\n  <span class=\"n\">constructor</span><span class=\"o\">,</span><span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">gβγ</span> <span class=\"n\">Hgβγ</span> <span class=\"n\">H1</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">Hαγ</span> <span class=\"o\">:</span> <span class=\"n\">fβγ</span> <span class=\"err\">∘</span> <span class=\"n\">fαβ</span> <span class=\"bp\">=</span> <span class=\"n\">gβγ</span> <span class=\"err\">∘</span> <span class=\"n\">fαβ</span><span class=\"o\">,</span>\n    <span class=\"n\">exactI</span> <span class=\"o\">(</span><span class=\"n\">Hαβ</span><span class=\"bp\">.</span><span class=\"n\">is_unique</span> <span class=\"o\">(</span><span class=\"n\">gβγ</span> <span class=\"err\">∘</span> <span class=\"n\">fαβ</span><span class=\"o\">)</span> <span class=\"n\">H1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n  <span class=\"n\">exactI</span> <span class=\"n\">Hβγ</span><span class=\"bp\">.</span><span class=\"n\">is_unique</span> <span class=\"n\">gβγ</span> <span class=\"n\">Hαγ</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 125630729,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524591338
    },
    {
        "content": "<p>That was the proof</p>",
        "id": 125630733,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524591343
    },
    {
        "content": "<p>Haha, I seriously thought up to now that an \"alpha-alg-hom\" was a map of rings equipped with some fancy extra additional structure, like <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">λ</span></span></span></span>-rings or divided power rings or something.</p>",
        "id": 125631047,
        "sender_full_name": "Reid Barton",
        "timestamp": 1524591639
    },
    {
        "content": "<p>no, it's an alpha-algebra hom :-)</p>",
        "id": 125631446,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524592139
    },
    {
        "content": "<p>YOU SEE YOU CS PEOPLE</p>",
        "id": 125631453,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524592152
    },
    {
        "content": "<p>THE MOMENT YOU CALL RINGS ALPHA</p>",
        "id": 125631456,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524592154
    },
    {
        "content": "<p>WE GET THINGS LIKE THIS HAPPENING</p>",
        "id": 125631461,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524592159
    },
    {
        "content": "<p>wow, that was pretty <code>α</code>-male</p>",
        "id": 125631555,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1524592247
    },
    {
        "content": "<p>Here's today's type class inference issue:</p>",
        "id": 125747509,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524783294
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">canonical_iso_is_canonical_hom</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">D&#39;</span> <span class=\"n\">g</span> <span class=\"err\">⊆</span> <span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">D&#39;</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"k\">let</span> <span class=\"n\">gbar</span> <span class=\"o\">:=</span> <span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">g</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"n\">sα</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">loc</span> <span class=\"o\">(</span><span class=\"n\">away</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">gbar</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">of_comm_ring</span> <span class=\"o\">(</span><span class=\"n\">away</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">gbar</span><span class=\"o\">)</span> <span class=\"err\">∘</span> <span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"n\">sγ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">non_zero_on_U</span> <span class=\"o\">(</span><span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">D&#39;</span> <span class=\"n\">g</span><span class=\"o\">)))</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"n\">H2</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">canonical_iso</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_ring_hom</span> <span class=\"k\">in</span>\n<span class=\"n\">is_unique_R_alg_hom</span> <span class=\"n\">sγ</span> <span class=\"n\">sα</span> <span class=\"o\">(</span><span class=\"n\">canonical_iso</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 125747511,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524783299
    },
    {
        "content": "<p>that won't run</p>",
        "id": 125747515,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524783303
    },
    {
        "content": "<p>but hopefully I can explain the issue</p>",
        "id": 125747523,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524783314
    },
    {
        "content": "<p>I am trying to prove <code>is_unique_R_alg_hom sγ sα (canonical_iso H).to_fun</code></p>",
        "id": 125747533,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524783340
    },
    {
        "content": "<p>but the definition of <code>is_unique_R_alg_hom</code> expects H2 to be deduced from type class inference</p>",
        "id": 125747592,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524783388
    },
    {
        "content": "<p>and I've only managed to prove it the line before</p>",
        "id": 125747595,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524783396
    },
    {
        "content": "<p>so I can solve this with @</p>",
        "id": 125747597,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524783402
    },
    {
        "content": "<p>but given that it would then look like</p>",
        "id": 125747612,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524783419
    },
    {
        "content": "<p>...erm</p>",
        "id": 125747672,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524783487
    },
    {
        "content": "<p>even that didn't work</p>",
        "id": 125747674,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524783492
    },
    {
        "content": "<p><code>@is_unique_R_alg_hom _ _ _ _ _ _ sγ sα (canonical_iso H).to_fun _ _ H2 </code></p>",
        "id": 125747690,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524783531
    },
    {
        "content": "<p>actually it did work, I now have an unrelated problem</p>",
        "id": 125747691,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524783539
    },
    {
        "content": "<p>So can I insert H2 into the type class inference system before I have even started my proof, because I need it to make my term typecheck?</p>",
        "id": 125747701,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524783573
    },
    {
        "content": "<p>I have got it working with <code>@</code></p>",
        "id": 125748084,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524784163
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">canonical_iso_is_canonical_hom</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">D&#39;</span> <span class=\"n\">g</span> <span class=\"err\">⊆</span> <span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">D&#39;</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"k\">let</span> <span class=\"n\">gbar</span> <span class=\"o\">:=</span> <span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">g</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"n\">sα</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">loc</span> <span class=\"o\">(</span><span class=\"n\">away</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">gbar</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">of_comm_ring</span> <span class=\"o\">(</span><span class=\"n\">away</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">gbar</span><span class=\"o\">)</span> <span class=\"err\">∘</span> <span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"n\">sγ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">non_zero_on_U</span> <span class=\"o\">(</span><span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">D&#39;</span> <span class=\"n\">g</span><span class=\"o\">)))</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"n\">H2</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">canonical_iso</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_ring_hom</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"n\">H3</span> <span class=\"o\">:</span> <span class=\"n\">is_ring_hom</span> <span class=\"n\">sα</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"n\">H4</span> <span class=\"o\">:</span> <span class=\"n\">is_ring_hom</span> <span class=\"n\">sγ</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"k\">in</span>\n<span class=\"bp\">@</span><span class=\"n\">is_unique_R_alg_hom</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">sγ</span> <span class=\"n\">sα</span> <span class=\"o\">(</span><span class=\"n\">canonical_iso</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">H4</span> <span class=\"n\">H3</span> <span class=\"n\">H2</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 125748085,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524784167
    },
    {
        "content": "<p>The first three lets are simply there to make the statement look clearer</p>",
        "id": 125748090,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524784186
    },
    {
        "content": "<p>the last three are there because type class inference asked for them all</p>",
        "id": 125748098,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524784201
    },
    {
        "content": "<p>Change those last three <code>let</code>s to <code>letI</code> I think</p>",
        "id": 125748163,
        "sender_full_name": "Reid Barton",
        "timestamp": 1524784288
    },
    {
        "content": "<p><code>letI</code> doesn't work there</p>",
        "id": 125748209,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524784336
    },
    {
        "content": "<p>well, it doesn't work for me</p>",
        "id": 125748210,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524784343
    },
    {
        "content": "<p>It works in a proof</p>",
        "id": 125748212,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524784347
    },
    {
        "content": "<p>Sorry, I just noticed this was in term mode</p>",
        "id": 125748213,
        "sender_full_name": "Reid Barton",
        "timestamp": 1524784347
    },
    {
        "content": "<p>but this is before the proof</p>",
        "id": 125748214,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524784352
    },
    {
        "content": "<p>the issue is that we're before the colon</p>",
        "id": 125748215,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524784357
    },
    {
        "content": "<p>I think</p>",
        "id": 125748216,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524784358
    },
    {
        "content": "<p>But I think <code>by letI ...; exact</code> is fine</p>",
        "id": 125748217,
        "sender_full_name": "Reid Barton",
        "timestamp": 1524784361
    },
    {
        "content": "<p>I have only seen letI after the colon</p>",
        "id": 125748219,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524784363
    },
    {
        "content": "<p>Though, it does make me vaguely uneasy to put it in the theorem statement.</p>",
        "id": 125748230,
        "sender_full_name": "Reid Barton",
        "timestamp": 1524784415
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">canonical_iso_is_canonical_hom</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">D&#39;</span> <span class=\"n\">g</span> <span class=\"err\">⊆</span> <span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">D&#39;</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"k\">let</span> <span class=\"n\">gbar</span> <span class=\"o\">:=</span> <span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">g</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"n\">sα</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">loc</span> <span class=\"o\">(</span><span class=\"n\">away</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">gbar</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">of_comm_ring</span> <span class=\"o\">(</span><span class=\"n\">away</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">gbar</span><span class=\"o\">)</span> <span class=\"err\">∘</span> <span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"n\">sγ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">non_zero_on_U</span> <span class=\"o\">(</span><span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">D&#39;</span> <span class=\"n\">g</span><span class=\"o\">)))</span> <span class=\"k\">in</span>\n<span class=\"k\">by</span> <span class=\"n\">letI</span> <span class=\"n\">H2</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">canonical_iso</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_ring_hom</span><span class=\"bp\">;</span> <span class=\"n\">exact</span>\n<span class=\"n\">is_unique_R_alg_hom</span> <span class=\"n\">sγ</span> <span class=\"n\">sα</span> <span class=\"o\">(</span><span class=\"n\">canonical_iso</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>(untested, hopefully I deleted the right amount of stuff)</p>",
        "id": 125748310,
        "sender_full_name": "Reid Barton",
        "timestamp": 1524784552
    },
    {
        "content": "<p>Using <code>letI</code> in theorem types is fine, and <code>by letI ...; exact</code> or <code>by exactI</code> is the recommended way to introduce a typeclass thing from the context in term mode</p>",
        "id": 125751156,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524789561
    },
    {
        "content": "<p>Don't use let in the statement of a theorem.</p>",
        "id": 125761174,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1524811431
    },
    {
        "content": "<blockquote>\n<p>Don't use let in the statement of a theorem.</p>\n</blockquote>\n<p>This is easy to fix -- the let is in some sense for my own sanity.</p>",
        "id": 125761407,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524811896
    },
    {
        "content": "<p>Note that <code>haveI</code> when used in a tactic doesn't actually produce a <code>have</code> term, the result is just like you would get if it were actually inferred by regular tc inference</p>",
        "id": 125761455,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524811984
    },
    {
        "content": "<p>If in doubt, just <code>#print</code> the statement to make sure it doesn't look weird</p>",
        "id": 125761462,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524812012
    },
    {
        "content": "<p>I can't get the syntax right for this</p>",
        "id": 125761464,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812022
    },
    {
        "content": "<p>having tried for 10 seconds</p>",
        "id": 125761465,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812028
    },
    {
        "content": "<p>I need to insert three hypotheses into the type class inference box</p>",
        "id": 125761507,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812075
    },
    {
        "content": "<p>and I don't understand the syntax of this by thing</p>",
        "id": 125761511,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812093
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">canonical_iso_is_canonical_hom</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">D&#39;</span> <span class=\"n\">g</span> <span class=\"err\">⊆</span> <span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">D&#39;</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"k\">let</span> <span class=\"n\">gbar</span> <span class=\"o\">:=</span> <span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">g</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"n\">sα</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">loc</span> <span class=\"o\">(</span><span class=\"n\">away</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">gbar</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">of_comm_ring</span> <span class=\"o\">(</span><span class=\"n\">away</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">gbar</span><span class=\"o\">)</span> <span class=\"err\">∘</span> <span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"n\">sγ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">non_zero_on_U</span> <span class=\"o\">(</span><span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">D&#39;</span> <span class=\"n\">g</span><span class=\"o\">)))</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"n\">H2</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">canonical_iso</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_ring_hom</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"n\">H3</span> <span class=\"o\">:</span> <span class=\"n\">is_ring_hom</span> <span class=\"n\">sα</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"n\">H4</span> <span class=\"o\">:</span> <span class=\"n\">is_ring_hom</span> <span class=\"n\">sγ</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"k\">in</span>\n<span class=\"bp\">@</span><span class=\"n\">is_unique_R_alg_hom</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">sγ</span> <span class=\"n\">sα</span> <span class=\"o\">(</span><span class=\"n\">canonical_iso</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">H4</span> <span class=\"n\">H3</span> <span class=\"n\">H2</span> <span class=\"o\">:=</span>\n</pre></div>",
        "id": 125761521,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812138
    },
    {
        "content": "<p>This works</p>",
        "id": 125761522,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812140
    },
    {
        "content": "<p>good luck proving that</p>",
        "id": 125761524,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524812154
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"k\">begin</span>\n<span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">canonical_iso</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_ring_hom</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">H5</span> <span class=\"o\">:=</span> <span class=\"n\">unique_R_alg_from_loc</span> <span class=\"o\">(</span><span class=\"n\">canonical_iso</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">H6</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">canonical_iso</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">R_alg_hom</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n<span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">H6</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H5</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">H5</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 125761562,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812167
    },
    {
        "content": "<p>done</p>",
        "id": 125761565,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812169
    },
    {
        "content": "<p>ok you win</p>",
        "id": 125761566,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524812177
    },
    {
        "content": "<p>Now I have good interface</p>",
        "id": 125761569,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812197
    },
    {
        "content": "<p>so all the proofs are \"this canonical thing is canonical\"</p>",
        "id": 125761570,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812204
    },
    {
        "content": "<p>or \"this canonical thing is unique\"</p>",
        "id": 125761571,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812216
    },
    {
        "content": "<p>or \"this unique thing is canonical\"</p>",
        "id": 125761573,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812220
    },
    {
        "content": "<p>I was trying to put all three hypotheses into one \"by\"</p>",
        "id": 125761635,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812346
    },
    {
        "content": "<p>but I don't understand the syntax</p>",
        "id": 125761638,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812353
    },
    {
        "content": "<p>but I've got it working</p>",
        "id": 125761644,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812363
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">canonical_iso_is_canonical_hom</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">D&#39;</span> <span class=\"n\">g</span> <span class=\"err\">⊆</span> <span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">D&#39;</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"k\">let</span> <span class=\"n\">gbar</span> <span class=\"o\">:=</span> <span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">g</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"n\">sα</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">loc</span> <span class=\"o\">(</span><span class=\"n\">away</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">gbar</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">of_comm_ring</span> <span class=\"o\">(</span><span class=\"n\">away</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">gbar</span><span class=\"o\">)</span> <span class=\"err\">∘</span> <span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"n\">sγ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">non_zero_on_U</span> <span class=\"o\">(</span><span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">D&#39;</span> <span class=\"n\">g</span><span class=\"o\">)))</span> <span class=\"k\">in</span>\n<span class=\"k\">by</span> <span class=\"n\">letI</span> <span class=\"n\">H2</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">canonical_iso</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_ring_hom</span><span class=\"bp\">;</span> <span class=\"n\">exact</span>\n<span class=\"k\">by</span> <span class=\"n\">letI</span> <span class=\"n\">H3</span> <span class=\"o\">:</span> <span class=\"n\">is_ring_hom</span> <span class=\"n\">sα</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"bp\">;</span> <span class=\"n\">exact</span>\n<span class=\"k\">by</span> <span class=\"n\">letI</span> <span class=\"n\">H4</span> <span class=\"o\">:</span> <span class=\"n\">is_ring_hom</span> <span class=\"n\">sγ</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"bp\">;</span> <span class=\"n\">exact</span>\n<span class=\"bp\">@</span><span class=\"n\">is_unique_R_alg_hom</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">sγ</span> <span class=\"n\">sα</span> <span class=\"o\">(</span><span class=\"n\">canonical_iso</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">H4</span> <span class=\"n\">H3</span> <span class=\"n\">H2</span> <span class=\"o\">:=</span>\n</pre></div>",
        "id": 125761645,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812374
    },
    {
        "content": "<p>I can't even parse that</p>",
        "id": 125761646,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812383
    },
    {
        "content": "<p>and now the moment of truth...</p>",
        "id": 125761649,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812400
    },
    {
        "content": "<p>wooah</p>",
        "id": 125761698,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812429
    },
    {
        "content": "<p>stop everything</p>",
        "id": 125761699,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812432
    },
    {
        "content": "<p>lean has silently crashed</p>",
        "id": 125761701,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812436
    },
    {
        "content": "<p>OK great, when I restart Lean it just quietly exits</p>",
        "id": 125761761,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812555
    },
    {
        "content": "<p>Restarting VS Code and I am back up and running</p>",
        "id": 125761771,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812639
    },
    {
        "content": "<p>and it doesn't work after all</p>",
        "id": 125761814,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812671
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">canonical_iso_is_canonical_hom</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">D&#39;</span> <span class=\"n\">g</span> <span class=\"err\">⊆</span> <span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">D&#39;</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"k\">let</span> <span class=\"n\">gbar</span> <span class=\"o\">:=</span> <span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">g</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"n\">sα</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">loc</span> <span class=\"o\">(</span><span class=\"n\">away</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">gbar</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">of_comm_ring</span> <span class=\"o\">(</span><span class=\"n\">away</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">gbar</span><span class=\"o\">)</span> <span class=\"err\">∘</span> <span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"n\">sγ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">of_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">non_zero_on_U</span> <span class=\"o\">(</span><span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">D&#39;</span> <span class=\"n\">g</span><span class=\"o\">)))</span> <span class=\"k\">in</span>\n<span class=\"k\">by</span> <span class=\"n\">letI</span> <span class=\"n\">H2</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">canonical_iso</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_ring_hom</span><span class=\"bp\">;</span>\n<span class=\"n\">letI</span> <span class=\"n\">H3</span> <span class=\"o\">:</span> <span class=\"n\">is_ring_hom</span> <span class=\"n\">sα</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"bp\">;</span>\n<span class=\"n\">letI</span> <span class=\"n\">H4</span> <span class=\"o\">:</span> <span class=\"n\">is_ring_hom</span> <span class=\"n\">sγ</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"bp\">;</span> <span class=\"n\">exact</span>\n<span class=\"bp\">@</span><span class=\"n\">is_unique_R_alg_hom</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">sγ</span> <span class=\"n\">sα</span> <span class=\"o\">(</span><span class=\"n\">canonical_iso</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">H4</span> <span class=\"n\">H3</span> <span class=\"n\">H2</span> <span class=\"o\">:=</span>\n</pre></div>\n\n\n<p>doesn't work</p>",
        "id": 125761869,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812782
    },
    {
        "content": "<p>It's not a problem because my multi-let <code>@</code> solution works</p>",
        "id": 125761871,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812800
    },
    {
        "content": "<p>I'll construct a MWE. I think this is just a syntax thing</p>",
        "id": 125761872,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524812809
    },
    {
        "content": "<p>gaargh it's not a syntax thing, my MWE is too minimal and strings of <code>by letI ...; exact</code> work fine</p>",
        "id": 125762346,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524813724
    },
    {
        "content": "<p>My <code>by apply_instance</code> proofs seem to be failing when wrapped up in the outer <code>by</code></p>",
        "id": 125762486,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524814030
    },
    {
        "content": "<p>I am torn between giving up and constructing a MWE</p>",
        "id": 125762657,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524814387
    },
    {
        "content": "<p>lemme help you</p>",
        "id": 125762659,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524814395
    },
    {
        "content": "<p>give up.</p>",
        "id": 125762660,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524814397
    },
    {
        "content": "<p>OK</p>",
        "id": 125762661,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524814400
    },
    {
        "content": "<p>thanks</p>",
        "id": 125762662,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524814402
    },
    {
        "content": "<p>no probs</p>",
        "id": 125762663,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524814406
    },
    {
        "content": "<p>Your <code>letI : ... := by apply_instance</code> lines are redundant. If the typeclass system can already find it, there's no reason to add it to the typeclass system. Unless you are trying to limit search depth?</p>",
        "id": 125763632,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524816397
    },
    {
        "content": "<p>Also I recommend <code>haveI</code> over <code>letI</code> when possible. The only time you need <code>letI</code> is if you are unfolding the exact definition of the inferred ring or whatever later on in the same proof</p>",
        "id": 125763651,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524816478
    },
    {
        "content": "<p>About type classes, let me quickly share <a href=\"https://gist.github.com/PatrickMassot/0d28b74be6f7bc9c0814a87393c91663\" target=\"_blank\" title=\"https://gist.github.com/PatrickMassot/0d28b74be6f7bc9c0814a87393c91663\">https://gist.github.com/PatrickMassot/0d28b74be6f7bc9c0814a87393c91663</a> It's a draft of documentation of something that took me an embarrassingly long time to understand (I don't say it's directly related to your issues, it's only general knowledge about type class magic)</p>",
        "id": 125764739,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1524818846
    },
    {
        "content": "<p>I think the <code>..prod.has_op</code> on the last instance is unnecessary</p>",
        "id": 125764855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524819046
    },
    {
        "content": "<p>it is inferred if you don't specify</p>",
        "id": 125764861,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524819069
    },
    {
        "content": "<p>oooh</p>",
        "id": 125764904,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1524819128
    },
    {
        "content": "<p>that's even better</p>",
        "id": 125764906,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1524819132
    },
    {
        "content": "<p>How does this new magic trick work?</p>",
        "id": 125764909,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1524819153
    },
    {
        "content": "<p>This file is all about understanding more magic</p>",
        "id": 125764911,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1524819160
    },
    {
        "content": "<p>The <code>comm_magma.mk</code> structure constructor has the <code>to_has_op</code> parent field as instance implicit, and in structure notation that translates to an optional field</p>",
        "id": 125764989,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524819319
    },
    {
        "content": "<p>same with anonymous constructor notation, you could write it as just <code>⟨proof of commutativity⟩</code> instead of <code>{op_comm := proof of commutativity}</code></p>",
        "id": 125765037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1524819410
    },
    {
        "content": "<p>Today's typeclass tale of woe:</p>",
        "id": 125801928,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524878563
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span>\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">u&#39;</span> <span class=\"n\">v&#39;</span> <span class=\"n\">w&#39;</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u&#39;</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v&#39;</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w&#39;</span><span class=\"o\">}</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">canonically_isomorphic_add_group_homs</span> <span class=\"o\">(</span><span class=\"n\">Cα</span> <span class=\"o\">:</span> <span class=\"n\">equiv</span> <span class=\"n\">α</span> <span class=\"n\">α&#39;</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Cβ</span> <span class=\"o\">:</span> <span class=\"n\">equiv</span> <span class=\"n\">β</span> <span class=\"n\">β&#39;</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f&#39;</span> <span class=\"o\">:</span> <span class=\"n\">α&#39;</span> <span class=\"bp\">→</span> <span class=\"n\">β&#39;</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">add_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_group</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_group</span> <span class=\"n\">α&#39;</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_group</span> <span class=\"n\">β&#39;</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">is_group_hom</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_group_hom</span> <span class=\"n\">f&#39;</span><span class=\"o\">]</span>\n<span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 125801930,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524878578
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>failed to synthesize type class instance for\nα : Type u,\nβ : Type v,\nα&#39; : Type u&#39;,\nβ&#39; : Type v&#39;,\nCα : α ≃ α&#39;,\nCβ : β ≃ β&#39;,\nf : α → β,\nf&#39; : α&#39; → β&#39;,\n_inst_1 : add_group α,\n_inst_2 : add_group β,\n_inst_3 : add_group α&#39;,\n_inst_4 : add_group β&#39;,\n_inst_5 : is_group_hom f\n⊢ group β&#39;\n</pre></div>",
        "id": 125801936,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524878598
    },
    {
        "content": "<p>dammit</p>",
        "id": 125802086,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524878986
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span>\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">u&#39;</span> <span class=\"n\">v&#39;</span> <span class=\"n\">w&#39;</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u&#39;</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v&#39;</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w&#39;</span><span class=\"o\">}</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">canonically_isomorphic_add_group_homs</span> <span class=\"o\">(</span><span class=\"n\">Cα</span> <span class=\"o\">:</span> <span class=\"n\">equiv</span> <span class=\"n\">α</span> <span class=\"n\">α&#39;</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Cβ</span> <span class=\"o\">:</span> <span class=\"n\">equiv</span> <span class=\"n\">β</span> <span class=\"n\">β&#39;</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f&#39;</span> <span class=\"o\">:</span> <span class=\"n\">α&#39;</span> <span class=\"bp\">→</span> <span class=\"n\">β&#39;</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">Hα</span> <span class=\"o\">:</span> <span class=\"n\">add_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hβ</span> <span class=\"o\">:</span> <span class=\"n\">add_group</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_group</span> <span class=\"n\">α&#39;</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hβ&#39;</span> <span class=\"o\">:</span> <span class=\"n\">add_group</span> <span class=\"n\">β&#39;</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">is_group_hom</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">Hα</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">is_group_hom</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">Hβ&#39;</span> <span class=\"n\">f&#39;</span><span class=\"o\">]</span>\n<span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 125802087,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524878993
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>type mismatch at application\n  is_group_hom\nterm\n  Hα\nhas type\n  add_group α\nbut is expected to have type\n  group α\n</pre></div>",
        "id": 125802128,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524879021
    },
    {
        "content": "<p>Damn you Lean</p>",
        "id": 125802133,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524879025
    },
    {
        "content": "<p>finding out how to turn an <code>add_group</code> to a <code>group</code> is <em>exactly</em> the kind of question which you should be good at.</p>",
        "id": 125802135,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524879048
    },
    {
        "content": "<p>thus saving me from having to remember the details about names of instances.</p>",
        "id": 125802141,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524879076
    },
    {
        "content": "<p>Why am I constantly running into type class inference issues <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> ? Is this sort of thing going to change in Lean 4, do you think?</p>",
        "id": 125802181,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524879129
    },
    {
        "content": "<p>I find the whole <code>letI</code> stuff both essential and extremely confusing</p>",
        "id": 125802182,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524879134
    },
    {
        "content": "<p>I probably need to write some <code>letI</code> docs</p>",
        "id": 125802185,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524879168
    },
    {
        "content": "<p>but am I right in thinking that <code>letI</code> is just a hack which we will be doing away with in Lean 4 as the amazing new type class inference system / syntax comes in?</p>",
        "id": 125802192,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524879206
    },
    {
        "content": "<p>I know that Mario has work hard to keep up with Leo's changes in the type class inference system</p>",
        "id": 125802231,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524879275
    },
    {
        "content": "<p>but that means that it's currently really confusing for end users</p>",
        "id": 125802232,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524879288
    },
    {
        "content": "<p>I believe in Lean so much</p>",
        "id": 125802234,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524879302
    },
    {
        "content": "<p>and I am really hoping for a beautiful solution.</p>",
        "id": 125802239,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524879309
    },
    {
        "content": "<p>Type class inference issues are stopping me from working right now.</p>",
        "id": 125802279,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524879367
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">to_group</span> <span class=\"o\">[</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">add_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n</pre></div>",
        "id": 125802460,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524879762
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>tactic.mk_instance failed to generate instance for\n  group α\nstate:\nα : Type,\nH : add_group α\n⊢ group α\n</pre></div>",
        "id": 125802462,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524879780
    },
    {
        "content": "<p>There are no plans to change class inference for Lean 4. On the other hand, lifting the distinction between <code>group</code> and <code>add_group</code> is the primary motivation behind refactoring the algebraic hierarchy.</p>",
        "id": 125814582,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1524908290
    },
    {
        "content": "<p>but the algebraic hierarchy also has its own problems, right</p>",
        "id": 125814583,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524908316
    },
    {
        "content": "<blockquote>\n<p>Today's typeclass tale of woe:</p>\n</blockquote>\n<p>look, I already wrote you an <code>is_add_group_hom</code></p>",
        "id": 125814601,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1524908351
    },
    {
        "content": "<p>Oh, I see, I am an idiot. Lean regards the <code>add_group</code> hierarchy as completely different to, the <code>group</code> hierarchy. I have mixed my hierarchies without noticing</p>",
        "id": 125820595,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524923310
    },
    {
        "content": "<p>The reason I have made this mistake</p>",
        "id": 125820600,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524923319
    },
    {
        "content": "<p>is that the two heirarchies are canonically isomorphic</p>",
        "id": 125820603,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524923328
    },
    {
        "content": "<p>and indeed there is a unique canonical isomorphism in each direction</p>",
        "id": 125820604,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524923339
    },
    {
        "content": "<p>however the type class inference procedure might not use these canonical isomorphisms</p>",
        "id": 125820609,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524923363
    },
    {
        "content": "<p>because neither of the hierarchies is \"better\" than the other one</p>",
        "id": 125820610,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524923381
    },
    {
        "content": "<p>so it would be asymmetric to let type class inference move from one to the other</p>",
        "id": 125820611,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524923396
    },
    {
        "content": "<p>and there is a risk of diamonds if we let it move between them freely</p>",
        "id": 125820653,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524923414
    },
    {
        "content": "<p>On the other hand, to a mathematician, they are the same object</p>",
        "id": 125820654,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524923425
    },
    {
        "content": "<p>canonical isomorphism is different to type class resolution</p>",
        "id": 125820655,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524923440
    },
    {
        "content": "<p>and I was applying canonical isomorphism</p>",
        "id": 125820656,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1524923444
    },
    {
        "content": "<p>Does this mean I introduced a diamond:</p>\n<blockquote>\n<p>synthesized type class instance is not definitionally equal to expression inferred by typing rules, synthesized<br>\n  subset.submodule 𝔥<br>\ninferred<br>\n  lie_algebra.to_module ↥𝔥</p>\n</blockquote>",
        "id": 128108229,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1529049280
    },
    {
        "content": "<p>So the context is as follows:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">lie_algebra</span> <span class=\"o\">{</span><span class=\"err\">𝔥</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"err\">𝔤</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">is_lie_subalgebra</span> <span class=\"n\">R</span> <span class=\"n\">ri</span> <span class=\"err\">𝔤</span> <span class=\"n\">la</span> <span class=\"err\">𝔥</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"n\">lie_algebra</span> <span class=\"n\">R</span> <span class=\"err\">𝔥</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">bracket</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">],</span> <span class=\"n\">is_lie_subalgebra</span><span class=\"bp\">.</span><span class=\"n\">closed</span> <span class=\"bp\">_</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">left_linear</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n    <span class=\"n\">constructor</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">x₁</span> <span class=\"n\">x₂</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">lie_algebra</span><span class=\"bp\">.</span><span class=\"n\">left_linear</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"o\">,</span> <span class=\"c1\">-- FAILS</span>\n      <span class=\"n\">sorry</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">r</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span><span class=\"o\">,</span>\n      <span class=\"c1\">-- apply (lie_algebra.left_linear y).smul, FAILS</span>\n      <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n  <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">right_linear</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">alternating</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"err\">$</span> <span class=\"n\">lie_algebra</span><span class=\"bp\">.</span><span class=\"n\">alternating</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">Jacobi_identity</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"err\">$</span> <span class=\"n\">lie_algebra</span><span class=\"bp\">.</span><span class=\"n\">Jacobi_identity</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">anti_comm</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"err\">$</span> <span class=\"n\">lie_algebra</span><span class=\"bp\">.</span><span class=\"n\">anti_comm</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</pre></div>",
        "id": 128112522,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1529056900
    },
    {
        "content": "<p>How do I tell Lean that it should infer <code>subset.submodule 𝔥</code>, instead of <code>lie_algebra.to_module ↥𝔥</code>.</p>",
        "id": 128112567,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1529056928
    },
    {
        "content": "<p>I really don't get why the type class system is tripping up in this case. After all, the first instance unifies completely. The second instance has one meta-variable in it (and rightly so, because it can't infer that <code>𝔥</code> is a <code>lie_algebra</code> since that is exactly what I'm trying to prove.</p>",
        "id": 128112594,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1529057011
    },
    {
        "content": "<p>So it seems to me like the type class inference went down a wrong path, but still got convinced that it did a good job. (While the correct path is actually there in Lean.)</p>",
        "id": 128112638,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1529057065
    },
    {
        "content": "<p>Aaaahhrg.....</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"o\">[</span><span class=\"n\">class_instances</span><span class=\"o\">]</span>  <span class=\"n\">class</span><span class=\"bp\">-</span><span class=\"kn\">instance</span> <span class=\"n\">resolution</span> <span class=\"n\">trace</span>\n<span class=\"o\">[</span><span class=\"n\">class_instances</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">x_0</span> <span class=\"o\">:</span> <span class=\"n\">has_bracket</span> <span class=\"err\">𝔤</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">commutator_bracket</span> <span class=\"err\">?</span><span class=\"n\">x_1</span> <span class=\"err\">?</span><span class=\"n\">x_2</span> <span class=\"err\">?</span><span class=\"n\">x_3</span> <span class=\"err\">?</span><span class=\"n\">x_4</span> <span class=\"err\">?</span><span class=\"n\">x_5</span> <span class=\"err\">?</span><span class=\"n\">x_6</span>\n<span class=\"o\">[</span><span class=\"n\">class_instances</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">x_2</span> <span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"err\">?</span><span class=\"n\">x_1</span> <span class=\"o\">:=</span> <span class=\"n\">ri</span>\n<span class=\"o\">[</span><span class=\"n\">class_instances</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">x_4</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">lie_algebra</span> <span class=\"n\">R</span> <span class=\"err\">?</span><span class=\"n\">x_3</span> <span class=\"n\">ri</span> <span class=\"o\">:=</span> <span class=\"n\">la</span>\n<span class=\"o\">[</span><span class=\"n\">class_instances</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">x_6</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"err\">𝔤</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">nonneg_ring</span><span class=\"bp\">.</span><span class=\"n\">to_ring</span> <span class=\"err\">?</span><span class=\"n\">x_7</span> <span class=\"err\">?</span><span class=\"n\">x_8</span>\n<span class=\"o\">[</span><span class=\"n\">class_instances</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">x_8</span> <span class=\"o\">:</span> <span class=\"n\">nonneg_ring</span> <span class=\"err\">𝔤</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">linear_nonneg_ring</span><span class=\"bp\">.</span><span class=\"n\">to_nonneg_ring</span> <span class=\"err\">?</span><span class=\"n\">x_9</span> <span class=\"err\">?</span><span class=\"n\">x_10</span>\n<span class=\"o\">[</span><span class=\"n\">class_instances</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">x_6</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"err\">𝔤</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">domain</span><span class=\"bp\">.</span><span class=\"n\">to_ring</span> <span class=\"err\">?</span><span class=\"n\">x_7</span> <span class=\"err\">?</span><span class=\"n\">x_8</span>\n<span class=\"o\">[</span><span class=\"n\">class_instances</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">x_8</span> <span class=\"o\">:</span> <span class=\"n\">domain</span> <span class=\"err\">𝔤</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">linear_nonneg_ring</span><span class=\"bp\">.</span><span class=\"n\">to_domain</span> <span class=\"err\">?</span><span class=\"n\">x_9</span> <span class=\"err\">?</span><span class=\"n\">x_10</span>\n<span class=\"o\">[</span><span class=\"n\">class_instances</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">x_8</span> <span class=\"o\">:</span> <span class=\"n\">domain</span> <span class=\"err\">𝔤</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">to_domain</span> <span class=\"err\">?</span><span class=\"n\">x_9</span> <span class=\"err\">?</span><span class=\"n\">x_10</span>\n<span class=\"o\">[</span><span class=\"n\">class_instances</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">x_10</span> <span class=\"o\">:</span> <span class=\"n\">linear_ordered_ring</span> <span class=\"err\">𝔤</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">linear_nonneg_ring</span><span class=\"bp\">.</span><span class=\"n\">to_linear_ordered_ring</span> <span class=\"err\">?</span><span class=\"n\">x_11</span> <span class=\"err\">?</span><span class=\"n\">x_12</span>\n<span class=\"o\">[</span><span class=\"n\">class_instances</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">x_10</span> <span class=\"o\">:</span> <span class=\"n\">linear_ordered_ring</span> <span class=\"err\">𝔤</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">linear_ordered_field</span><span class=\"bp\">.</span><span class=\"n\">to_linear_ordered_ring</span> <span class=\"err\">?</span><span class=\"n\">x_11</span> <span class=\"err\">?</span><span class=\"n\">x_12</span>\n<span class=\"o\">[</span><span class=\"n\">class_instances</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">x_12</span> <span class=\"o\">:</span> <span class=\"n\">linear_ordered_field</span> <span class=\"err\">𝔤</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">discrete_linear_ordered_field</span><span class=\"bp\">.</span><span class=\"n\">to_linear_ordered_field</span> <span class=\"err\">?</span><span class=\"n\">x_13</span> <span class=\"err\">?</span><span class=\"n\">x_14</span>\n</pre></div>\n\n\n<p>[the list goes on and on...]</p>",
        "id": 128114320,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1529060326
    },
    {
        "content": "<p>No stupid! It's a Lie algebra!</p>",
        "id": 128114327,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1529060340
    },
    {
        "content": "<p>Everywhere in this file it has realised immediately that <code>𝔤</code> is a Lie algebra, and therefore has a bracket.</p>",
        "id": 128114337,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1529060376
    },
    {
        "content": "<p>But somehow, here it messes up completely.</p>",
        "id": 128114338,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1529060380
    },
    {
        "content": "<p>I notice type class inference issues are quite common in this chat. Maybe in the future a visualization aide would be helpful for people trying to debug  the process</p>",
        "id": 128114684,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1529061054
    },
    {
        "content": "<p>Actually for myself I don't know any better method to debug it than to write out the expression in full, and then in order work forwards as if I was doing the search by hand...</p>",
        "id": 128114691,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1529061109
    },
    {
        "content": "<p>Right... which is not really what you would expect in this \"computer-era\"</p>",
        "id": 128114731,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1529061158
    },
    {
        "content": "<p>you'd be disappointed in how much paper I go through while using a computerized theorem prover... or programming in general</p>",
        "id": 128115009,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1529061672
    },
    {
        "content": "<p>I have mentioned this in previous instance issues, but <code>comm_ring ?x_1</code> is a bad sign in an instance trace, that will usually run away</p>",
        "id": 128115071,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529061816
    },
    {
        "content": "<p>what is the type of <code>commutator_bracket</code>?</p>",
        "id": 128115074,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529061828
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n<span class=\"kn\">instance</span> <span class=\"n\">commutator_bracket</span> <span class=\"o\">:</span> <span class=\"n\">has_bracket</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"bp\">-</span> <span class=\"n\">y</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"bp\">⟩</span>\n</pre></div>",
        "id": 128115592,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1529062751
    },
    {
        "content": "<p>That can't be right, the printout has six variables not two</p>",
        "id": 128115668,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529062919
    },
    {
        "content": "<p>what does <code>#print commutator_bracket</code> show?</p>",
        "id": 128115709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529062931
    },
    {
        "content": "<p>Anyway, my point is that <code>𝔤</code> is a Lie algebra, and by definition that means it <code>extends has_bracket</code>. So I would hope that Lean could figure this one out.</p>",
        "id": 128115711,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1529062936
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span>\n<span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">commutator_bracket</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ri</span> <span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"err\">𝔤</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">la</span> <span class=\"o\">:</span> <span class=\"n\">lie_algebra</span> <span class=\"n\">R</span> <span class=\"err\">𝔤</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"n\">S</span><span class=\"o\">],</span>\n  <span class=\"n\">has_bracket</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ri</span> <span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"err\">𝔤</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">la</span> <span class=\"o\">:</span> <span class=\"n\">lie_algebra</span> <span class=\"n\">R</span> <span class=\"err\">𝔤</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"n\">S</span><span class=\"o\">],</span>\n  <span class=\"o\">{</span><span class=\"n\">bracket</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">-</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n</pre></div>",
        "id": 128115718,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1529062966
    },
    {
        "content": "<p>there's your problem</p>",
        "id": 128115721,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529062976
    },
    {
        "content": "<p>Which is crazy...</p>",
        "id": 128115722,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1529062978
    },
    {
        "content": "<p>It pulls in way too much stuff.</p>",
        "id": 128115728,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1529062996
    },
    {
        "content": "<p>did you <code>include</code> stuff at the top maybe?</p>",
        "id": 128115732,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529063010
    },
    {
        "content": "<p>try defining it outside the section, this instance has nothing to do with lie algebras</p>",
        "id": 128115807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529063090
    },
    {
        "content": "<p>Yes... thanks for catching that!</p>",
        "id": 128115819,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1529063107
    },
    {
        "content": "<p>Hmm, I need to run. In fact, I should try to get rid of those <code>include ri la</code>, but that seems to be non-trivial.</p>",
        "id": 128115879,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1529063207
    },
    {
        "content": "<p>Anyway, I'll be back later. AFK</p>",
        "id": 128115887,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1529063223
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">punit_instances</span>\n\n<span class=\"c1\">-- works fine</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"n\">class</span> <span class=\"n\">G_module</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"kn\">extends</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">has_scalar</span> <span class=\"n\">G</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"err\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"err\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"err\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">linear</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- fails</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">maximum class-instance resolution depth has been reached (the limit can be increased by setting option &#39;class.instance_max_depth&#39;) (the class-instance resolution trace can be visualized by setting option &#39;trace.class_instances&#39;)</span>\n<span class=\"cm\">state:</span>\n<span class=\"cm\">⊢ add_comm_group unit</span>\n<span class=\"cm\">-/</span>\n</pre></div>\n\n\n<p>What did I do to deserve that? Is the class bad in some way?</p>",
        "id": 167024345,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559329441
    },
    {
        "content": "<p><code>set_option class.instance_max_depth 1000</code> doesn't fix it</p>",
        "id": 167024427,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559329483
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>[class_instances]  class-instance resolution trace\n[class_instances] (0) ?x_0 : add_comm_group unit := @G_module.to_add_comm_group ?x_1 ?x_2 ?x_3 ?x_4\n[class_instances] (1) ?x_2 : group ?x_1 := @subtype.group ?x_5 ?x_6 ?x_7 ?x_8\n[class_instances] (2) ?x_6 : group ?x_5 := @subtype.group ?x_9 ?x_10 ?x_11 ?x_12\n[class_instances] (3) ?x_10 : group ?x_9 := @subtype.group ?x_13 ?x_14 ?x_15 ?x_16\n[class_instances] (4) ?x_14 : group ?x_13 := @subtype.group ?x_17 ?x_18 ?x_19 ?x_20\n[class_instances] (5) ?x_18 : group ?x_17 := @subtype.group ?x_21 ?x_22 ?x_23 ?x_24\n[class_instances] (6) ?x_22 : group ?x_21 := @subtype.group ?x_25 ?x_26 ?x_27 ?x_28\n[class_instances] (7) ?x_26 : group ?x_25 := @subtype.group ?x_29 ?x_30 ?x_31 ?x_32\n[class_instances] (8) ?x_30 : group ?x_29 := @subtype.group ?x_33 ?x_34 ?x_35 ?x_36\n[class_instances] (9) ?x_34 : group ?x_33 := @subtype.group ?x_37 ?x_38 ?x_39 ?x_40\n[class_instances] (10) ?x_38 : group ?x_37 := @subtype.group ?x_41 ?x_42 ?x_43 ?x_44\n[class_instances] (11) ?x_42 : group ?x_41 := @subtype.group ?x_45 ?x_46 ?x_47 ?x_48\n[class_instances] (12) ?x_46 : group ?x_45 := @subtype.group ?x_49 ?x_50 ?x_51 ?x_52\n[class_instances] (13) ?x_50 : group ?x_49 := @subtype.group ?x_53 ?x_54 ?x_55 ?x_56\n[class_instances] (14) ?x_54 : group ?x_53 := @subtype.group ?x_57 ?x_58 ?x_59 ?x_60\n[class_instances] (15) ?x_58 : group ?x_57 := @subtype.group ?x_61 ?x_62 ?x_63 ?x_64\n[class_instances] (16) ?x_62 : group ?x_61 := @subtype.group ?x_65 ?x_66 ?x_67 ?x_68\n[class_instances] (17) ?x_66 : group ?x_65 := @subtype.group ?x_69 ?x_70 ?x_71 ?x_72\n[class_instances] (18) ?x_70 : group ?x_69 := @subtype.group ?x_73 ?x_74 ?x_75 ?x_76\n[class_instances] (19) ?x_74 : group ?x_73 := @subtype.group ?x_77 ?x_78 ?x_79 ?x_80\n[class_instances] (20) ?x_78 : group ?x_77 := @subtype.group ?x_81 ?x_82 ?x_83 ?x_84\n[class_instances] (21) ?x_82 : group ?x_81 := @subtype.group ?x_85 ?x_86 ?x_87 ?x_88\n[class_instances] (22) ?x_86 : group ?x_85 := @subtype.group ?x_89 ?x_90 ?x_91 ?x_92\n[class_instances] (23) ?x_90 : group ?x_89 := @subtype.group ?x_93 ?x_94 ?x_95 ?x_96\n[class_instances] (24) ?x_94 : group ?x_93 := @subtype.group ?x_97 ?x_98 ?x_99 ?x_100\n[class_instances] (25) ?x_98 : group ?x_97 := @subtype.group ?x_101 ?x_102 ?x_103 ?x_104\n[class_instances] (26) ?x_102 : group ?x_101 := @subtype.group ?x_105 ?x_106 ?x_107 ?x_108\n[class_instances] (27) ?x_106 : group ?x_105 := @subtype.group ?x_109 ?x_110 ?x_111 ?x_112\n[class_instances] (28) ?x_110 : group ?x_109 := @subtype.group ?x_113 ?x_114 ?x_115 ?x_116\n[class_instances] (29) ?x_114 : group ?x_113 := @subtype.group ?x_117 ?x_118 ?x_119 ?x_120\n[class_instances] (30) ?x_118 : group ?x_117 := @subtype.group ?x_121 ?x_122 ?x_123 ?x_124\n[class_instances] (31) ?x_122 : group ?x_121 := @subtype.group ?x_125 ?x_126 ?x_127 ?x_128\n[class_instances] (32) ?x_126 : group ?x_125 := @subtype.group ?x_129 ?x_130 ?x_131 ?x_132\n</pre></div>",
        "id": 167024506,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559329556
    },
    {
        "content": "<p>Can I solve this with some priority hack? Why does this happen?</p>",
        "id": 167024586,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559329593
    },
    {
        "content": "<p>the class is bad, as you suspect</p>",
        "id": 167024656,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559329656
    },
    {
        "content": "<p>Make <code>add_comm_group M</code> an argument of the class.</p>",
        "id": 167024677,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1559329678
    },
    {
        "content": "<p>and the offending instance is right there in the trace - <code>G_module.to_add_comm_group</code></p>",
        "id": 167024679,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559329679
    },
    {
        "content": "<p>something like </p>\n<div class=\"codehilite\"><pre><span></span>class G_module (G : Type*) (M : Type*) [group G] [add_comm_group M]\n  extends has_scalar G M :=\n</pre></div>",
        "id": 167024793,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1559329763
    },
    {
        "content": "<p>That sounds like a really super instance though.</p>",
        "id": 167024796,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559329769
    },
    {
        "content": "<p>There is some subtlety here which I don't understand -- this is exactly one of those times where you're saying \"don't do it this way, do it in some way which looks exactly the same to a mathematician\". Is there some general principle I'm unaware of?</p>",
        "id": 167024876,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559329818
    },
    {
        "content": "<p>Don't have a parent instance with fewer type arguments than the class</p>",
        "id": 167024899,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559329841
    },
    {
        "content": "<p>wait, what is a parent instance?</p>",
        "id": 167024929,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559329867
    },
    {
        "content": "<p><code>extends</code> produces an instance</p>",
        "id": 167024936,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559329878
    },
    {
        "content": "<p>And Floris' suggestion doesn't?</p>",
        "id": 167024949,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559329894
    },
    {
        "content": "<p>In the original case it was <code>[G_module G M] : add_comm_group M</code></p>",
        "id": 167024977,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559329918
    },
    {
        "content": "<p>no, I am in complete agreement with floris</p>",
        "id": 167025031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559329931
    },
    {
        "content": "<p>floris is proposing to remove this instance, which is bad because <code>G</code> is \"dangling\"</p>",
        "id": 167025055,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559329966
    },
    {
        "content": "<p>Yes I understand that. And this is not generated in the suggested fix?</p>",
        "id": 167025056,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559329968
    },
    {
        "content": "<p>Sorry, I had a little internet time-out. My comment referred to \"extends produces an instance\"</p>",
        "id": 167025085,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559329993
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> You know about <a href=\"https://github.com/leanprover-community/mathlib/blob/66a86ffe010ffc32ee92e2e92cbdaf83487af168/src/group_theory/group_action.lean#L173\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/66a86ffe010ffc32ee92e2e92cbdaf83487af168/src/group_theory/group_action.lean#L173\">https://github.com/leanprover-community/mathlib/blob/66a86ffe010ffc32ee92e2e92cbdaf83487af168/src/group_theory/group_action.lean#L173</a> ?</p>",
        "id": 167025086,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559329994
    },
    {
        "content": "<p>reading it from right to left, <code>G</code> just appears and lean doesn't know how to pick a value</p>",
        "id": 167025090,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559330001
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"c\">/-</span><span class=\"cm\">- Typeclass for multiplicative actions on additive structures. This generalizes group modules. -/</span>\n<span class=\"n\">class</span> <span class=\"n\">distrib_mul_action</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">mul_action</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">smul_add</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"err\">•</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">r</span> <span class=\"err\">•</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">smul_zero</span> <span class=\"o\">{}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 167025096,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559330011
    },
    {
        "content": "<blockquote>\n<p>reading it from right to left, <code>G</code> just appears and lean doesn't know how to pick a value</p>\n</blockquote>\n<p>I appreciate the problem; I am just saying that my understanding of why it occurs the way I did it and not the way Floris did it is hazy. <code>extends</code> produces an instance, this is the point. So Floris' method produces no instances?</p>",
        "id": 167025238,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559330109
    },
    {
        "content": "<p>Johan -- no, I didn't know about this.</p>",
        "id": 167025242,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559330117
    },
    {
        "content": "<p>My solution doesn't generate the instance, because Lean will need to synthesize the instance <code>add_comm_group M</code> before it can even start searching for an instance of <code>G_module G M</code></p>",
        "id": 167025246,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1559330123
    },
    {
        "content": "<p>Right.</p>",
        "id": 167025266,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559330135
    },
    {
        "content": "<p>there is still a parent instance coming from the other <code>extends</code> clause</p>",
        "id": 167025299,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559330159
    },
    {
        "content": "<p>In a parallel universe someone could tell me that this [Floris' suggestion] produces an instance anyway, and I would happily believe them.</p>",
        "id": 167025301,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559330160
    },
    {
        "content": "<p>The easiest way to think of it is <code>extends</code> is notation for an extra field in the class + an instance to get to the parent from the child</p>",
        "id": 167025418,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559330228
    },
    {
        "content": "<p>AFAIK it's the only way to get autogenerated instances</p>",
        "id": 167025511,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559330286
    },
    {
        "content": "<p>Well, let's try do define this instance:</p>\n<div class=\"codehilite\"><pre><span></span>instance (G : Type*) (M : Type*) [group G] [add_comm_group M] [G_module G M] :\n  add_comm_group M :=\n_\n</pre></div>\n\n\n<p>What would you pick for the value of the underscore? It's the instance you already got as an argument. So this instance says \"if you want <code>add_comm_group M</code> then you need to search for <code>add_comm_group M</code> (and a bunch more things). It's (worse than) useless.</p>",
        "id": 167025524,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1559330311
    },
    {
        "content": "<p>My understanding of what is going on here is hazy at best. I even don't really understand, in some sense, why the instance is bad, because I don't really understand how type class inference works; I can of course see that it's bad because of what just happened, but the fact that I asked here instead of trying to fix it myself (which is nowadays my preferred solution with problems I run into) is just an indication of my poor understanding of this stuff. </p>\n<p>I keep meaning to write some doc for <code>docs/extras/</code> about the nitty-gritty of how type class inference works but I've had a busy year. The next three months are looking much nicer though, maybe I should actually do this; writing the docs myself will show me what I don't understand.</p>",
        "id": 167025571,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559330366
    },
    {
        "content": "<p>It's a prolog-like search</p>",
        "id": 167025595,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559330386
    },
    {
        "content": "<p>Every instance says \"to prove A it suffices to prove B, C, D\" and lean just applies all instances greedily hoping to get somewhere</p>",
        "id": 167025827,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559330535
    },
    {
        "content": "<p>[prolog] Yeah, somehow this is exactly the problem. I can believe that at some point in CS UG there's a chance to do some lectures / problem sets on how prolog works. In maths departments we don't do this. On a couple of occasions now I've sat down to fathom this out (even installing prolog on one occasion) but then never wrote down any of my thoughts and then I just forget them again. Writing things down is really helpful for me at my age -- only today did I look at my <code>simp</code> notes that I wrote so I could find out how to turn the trace on for <code>simp</code> -- I always forget, but I know where to look. The docs I write are \"by me now, for me next week\" :-)</p>",
        "id": 167025859,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559330566
    },
    {
        "content": "<p>Btw, I don't have some magical superpower that I know how to do these things. The general strategy for a lot of formalization is to see if someone has done something similar before. If so, copy their code and adapt it to your case. In this case, the definition of <code>module</code> is similar:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/algebra/module.lean#L25\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/algebra/module.lean#L25\">https://github.com/leanprover-community/mathlib/blob/master/src/algebra/module.lean#L25</a><br>\nOften the design decisions will be the same for your case.</p>",
        "id": 167025861,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1559330570
    },
    {
        "content": "<blockquote>\n<p>Btw, I don't have some magical superpower</p>\n</blockquote>\n<p>Rotten luck! Mathematicians have a super-power.</p>",
        "id": 167025910,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559330611
    },
    {
        "content": "<p>I do this all the time, even if I wrote the previous code. Past me was usually much more aware of all the pitfalls (because he fell into them, and then changed the code).</p>",
        "id": 167025919,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1559330623
    },
    {
        "content": "<p>Unfortunately, Lean disables our super-power.</p>",
        "id": 167025931,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559330637
    },
    {
        "content": "<p>You should mostly assume that lean applies instances in the worst possible order, because anything else is luck. So if there is an instance like \"to prove T A it suffices to prove T (A x A)\" then it should be clear that lean will loop</p>",
        "id": 167025973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559330643
    },
    {
        "content": "<p>ha ha, that rule of thumb stinks! It's crying out for a fix.</p>",
        "id": 167026010,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559330673
    },
    {
        "content": "<p>The rule of thumb makes perfect sense,  but somehow says \"we could be doing this better\". I guess we had this conversation once before quite recently.</p>",
        "id": 167026051,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559330704
    },
    {
        "content": "<p>It's not as bad as it sounds; you just have to make sure that the worst possible order isn't that bad</p>",
        "id": 167026067,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559330711
    },
    {
        "content": "<p>I know that making typeclass inference better is on Leo's mind.</p>",
        "id": 167026081,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559330722
    },
    {
        "content": "<p>i really think we should use <code>priority n</code> more in mathlib so that we can decide which instances should be applied first and which ones should be applied last.</p>",
        "id": 167026105,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1559330749
    },
    {
        "content": "<p>[we had a brief email exchange when perfectoids got done, and he mentioned it]</p>",
        "id": 167026110,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559330753
    },
    {
        "content": "<p>I agree that more use of priority would be a good thing, but I currently don't have a good model for how to structure the priorities</p>",
        "id": 167026191,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559330794
    },
    {
        "content": "<p>My gut feeling says priorities should be as follows:</p>\n<ul>\n<li>Structural instances: an instance which only works for certain types (like <code>group A -&gt; group B -&gt; group (prod A B)</code> or <code>ring int</code>). If such an instance applies, then it's almost always the instance you want to apply. So the order doesn't matter that much, but you can put the more common instances in front.</li>\n<li>Forgetful instances, like <code>comm_group A -&gt; group A</code>. Here you want to order them by how likely they are to apply (taking into consideration how long it would take for this instance to fail). Ultimately this will depend on which area of maths you're doing. When doing ring theory, you'll want to apply <code>ring.to_add_comm_group</code>first, while in other cases you might want to do apply <code>ordered_comm_group.to_add_comm_group</code> first (this is not a great example, I think you almost always want to apply <code>ring.to_add_comm_group</code> first).</li>\n</ul>\n<p>Looking a bit over <code>#print instances</code>, it looks like mathlib does this mostly right. I think this is partially accidental, since forgetful instances tend to be declared before structural instances are, and so even if they have the same priority they will be considered later. Some things I noticed:</p>\n<ul>\n<li>Sometimes there are \"shortcuts\", like <code>decidable_linear_ordered_comm_group.to_add_comm_group</code> and <code>ordered_comm_group.to_add_comm_group</code> (or <code>linear_ordered_ring.to_linear_order</code> and <code>linear_ordered_semiring.to_linear_order</code>). If these instances do not apply, the search through the \"order hierarchy\" will happen twice, right? Probably these shortcuts should be removed?</li>\n<li><code>nonneg_comm_group.to_add_comm_group</code> should have a lower priority.</li>\n<li>Some declarations should probably not be instances: <code>decidable_eq_of_decidable_le</code> or <code>decidable_lt_of_decidable_le</code>. Unfortunately they are in core...</li>\n</ul>",
        "id": 167029799,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1559333298
    },
    {
        "content": "<p>We need a real test to find out if shortcuts are taken twice</p>",
        "id": 167030029,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559333486
    },
    {
        "content": "<p>Is <code>set_option trace.class_instances true</code> a reliable test?</p>\n<div class=\"codehilite\"><pre><span></span>example : add_comm_group bool := by apply_instance\n</pre></div>\n\n\n<p>gives</p>\n<div class=\"codehilite\"><pre><span></span>[...]\n[class_instances] (0) ?x_0 : add_comm_group bool := @decidable_linear_ordered_comm_group.to_add_comm_group ?x_1 ?x_2\n[class_instances] (1) ?x_2 : decidable_linear_ordered_comm_group bool := int.decidable_linear_ordered_comm_group\nfailed is_def_eq\n[class_instances] (1) ?x_2 : decidable_linear_ordered_comm_group bool := @decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_comm_group ?x_3 ?x_4\n[class_instances] (2) ?x_4 : decidable_linear_ordered_comm_ring bool := @linear_nonneg_ring.to_decidable_linear_ordered_comm_ring ?x_5 ?x_6 ?x_7 ?x_8\n[class_instances] (2) ?x_4 : decidable_linear_ordered_comm_ring bool := int.decidable_linear_ordered_comm_ring\nfailed is_def_eq\n[class_instances] (2) ?x_4 : decidable_linear_ordered_comm_ring bool := @discrete_linear_ordered_field.to_decidable_linear_ordered_comm_ring ?x_5 ?x_6\n[class_instances] (0) ?x_0 : add_comm_group bool := @ordered_comm_group.to_add_comm_group ?x_1 ?x_2\n[...]\n[class_instances] (4) ?x_8 : linear_ordered_comm_ring bool := @decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring ?x_9 ?x_10\n[class_instances] (5) ?x_10 : decidable_linear_ordered_comm_ring bool := @linear_nonneg_ring.to_decidable_linear_ordered_comm_ring ?x_11 ?x_12 ?x_13 ?x_14\n[class_instances] (5) ?x_10 : decidable_linear_ordered_comm_ring bool := int.decidable_linear_ordered_comm_ring\nfailed is_def_eq\n[class_instances] (5) ?x_10 : decidable_linear_ordered_comm_ring bool := @discrete_linear_ordered_field.to_decidable_linear_ordered_comm_ring ?x_11 ?x_12\n[class_instances] (1) ?x_2 : ordered_comm_group bool := @decidable_linear_ordered_comm_group.to_ordered_comm_group ?x_3 ?x_4\n[class_instances] (2) ?x_4 : decidable_linear_ordered_comm_group bool := int.decidable_linear_ordered_comm_group\nfailed is_def_eq\n[class_instances] (2) ?x_4 : decidable_linear_ordered_comm_group bool := @decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_comm_group ?x_5 ?x_6\n[class_instances] (3) ?x_6 : decidable_linear_ordered_comm_ring bool := @linear_nonneg_ring.to_decidable_linear_ordered_comm_ring ?x_7 ?x_8 ?x_9 ?x_10\n[class_instances] (3) ?x_6 : decidable_linear_ordered_comm_ring bool := int.decidable_linear_ordered_comm_ring\nfailed is_def_eq\n[class_instances] (3) ?x_6 : decidable_linear_ordered_comm_ring bool := @discrete_linear_ordered_field.to_decidable_linear_ordered_comm_ring ?x_7 ?x_8\n</pre></div>\n\n\n<p>It seems like it considered <code>decidable_linear_ordered_comm_ring bool</code> three times.</p>",
        "id": 167030675,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1559333916
    },
    {
        "content": "<p>Now sometimes duplication is impossible to avoid, without changing the code to the search, when you have diamonds...</p>",
        "id": 167030809,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1559333997
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n<span class=\"n\">class</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">A</span> <span class=\"n\">α</span> <span class=\"n\">n</span>\n<span class=\"n\">class</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">B</span> <span class=\"n\">α</span> <span class=\"n\">n</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">C_nat</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">ℕ</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"bp\">_⟩</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">C_of_A&#39;</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"bp\">_⟩</span><span class=\"o\">)</span>\n<span class=\"kn\">instance</span> <span class=\"n\">shortcut</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">C</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"kn\">set_option</span> <span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">class_instances</span> <span class=\"n\">true</span>\n<span class=\"kn\">set_option</span> <span class=\"n\">class</span><span class=\"bp\">.</span><span class=\"n\">instance_max_depth</span> <span class=\"mi\">1000</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">ℕ</span> <span class=\"mi\">30</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>it's considering <code>shortcut</code> at each level but it's not exponential</p>",
        "id": 167031132,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559334217
    },
    {
        "content": "<p>About the <code>decidable_eq_of_decidable_le</code>issue: maybe we should set their priorities in <code>mathlib</code> to <code>0</code>, and decide that <code>local attribute [instance, priority 10] classical.prop_decidable</code> should happen at priority 10, not 0. Now, it probably searches through big chunks of the order hierarchy twice, when you want that <code>prop_decidable</code> should decide an equality on any type:</p>\n<ul>\n<li>through <code>decidable_linear_order α</code></li>\n<li>through <code>decidable_eq_of_decidable_le</code></li>\n</ul>",
        "id": 167031274,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1559334309
    },
    {
        "content": "<p>oh wait, <code>C unit 7</code> is definitely exponential</p>",
        "id": 167031300,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559334327
    },
    {
        "content": "<p>that's disconcerting</p>",
        "id": 167031320,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559334345
    },
    {
        "content": "<p>once again I am staggered that typeclass inference works at all</p>",
        "id": 167031431,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559334413
    },
    {
        "content": "<p>numerals have special support on <code>nat</code>, maybe that makes a difference?</p>",
        "id": 167031475,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1559334458
    },
    {
        "content": "<p>no, that just makes it a bit easier to write a bunch of succs here</p>",
        "id": 167031497,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559334478
    },
    {
        "content": "<p>Compare the instance trace on <code>C unit 7</code> with and without <code>shortcut</code></p>",
        "id": 167031570,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559334507
    },
    {
        "content": "<p>the problem is that your first instance <em>never</em> fails: all instances it tries succeed. Each branch is linear: backtracking is exponential.</p>",
        "id": 167031597,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1559334530
    },
    {
        "content": "<p>To some extent that's not unreasonable - I'm not sure how much we should care about failing searches</p>",
        "id": 167031728,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559334610
    },
    {
        "content": "<p>a lot</p>",
        "id": 167031789,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1559334664
    },
    {
        "content": "<p>whenever you do <code>local attribute [instance, priority 0] classical.prop_decidable</code> there are a whole lot of failing searches.</p>",
        "id": 167031811,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1559334683
    },
    {
        "content": "<p>probably half of the \"Forgetful instances\" will fail. (even if applying another instance succeeds)</p>",
        "id": 167031837,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1559334712
    },
    {
        "content": "<p>here's a case where the instance succeeds but takes a long time:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n<span class=\"kn\">instance</span> <span class=\"n\">D_unit</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"n\">unit</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"bp\">_⟩</span>\n<span class=\"kn\">instance</span> <span class=\"n\">D_of_C</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">C</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"bp\">_⟩</span>\n\n<span class=\"kn\">set_option</span> <span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">class_instances</span> <span class=\"n\">true</span>\n<span class=\"kn\">set_option</span> <span class=\"n\">class</span><span class=\"bp\">.</span><span class=\"n\">instance_max_depth</span> <span class=\"mi\">1000</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"n\">unit</span> <span class=\"mi\">7</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 167031936,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559334778
    },
    {
        "content": "<p>when doing some testing on my own</p>\n<div class=\"codehilite\"><pre><span></span>(message too long, truncated at 262144 characters)\n</pre></div>\n\n\n<p>lol,</p>\n<p>But I think it's pretty clear we should remove these shortcuts of \"forgetful\" instances.</p>",
        "id": 167032404,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1559335131
    },
    {
        "content": "<p>this is a real shame, these could be useful in principle but lean really doesn't like them</p>",
        "id": 167032576,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559335263
    },
    {
        "content": "<blockquote>\n<p>(message too long, truncated at 262144 characters)</p>\n</blockquote>\n<p>Gabriel put that check there precisely because I was fiddling around with this sort of thing once and managed to get a message that was so long that it broke stuff.</p>",
        "id": 167032635,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559335312
    },
    {
        "content": "<p>but actually I don't know to what degree we can make our hierarchy \"tree-like\"</p>",
        "id": 167032642,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559335317
    },
    {
        "content": "<p>algebraic hierarchies don't work like that</p>",
        "id": 167032712,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559335339
    },
    {
        "content": "<p>There should really be a different algorithm for these \"forgetful instances\". Make a graph of all instances that change the class but not the type (like <code>add_comm_group \\a -&gt; add_group \\a</code>) and when you have searched through all structural instances (or all instances with priority &gt;= default priority), then use a graph reachability algorithm to quickly search for a path to any instance in the local context.</p>",
        "id": 167033408,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1559335850
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> how about you make type class search user-configurable? Everyone has different ideas :-)</p>",
        "id": 167036451,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559338571
    },
    {
        "content": "<p>I think that is one of the plans for Lean 4</p>",
        "id": 167054394,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559363465
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Making typeclass inference based on customizable tactics has been proposed before, but no one has figured out how to combine that with instance caching</p>",
        "id": 167081954,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1559410387
    },
    {
        "content": "<p>My comment was really tongue-in-cheek I guess</p>",
        "id": 167081965,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559410424
    },
    {
        "content": "<p>The moment you let users do what they want is presumably the moment that things get really inefficient</p>",
        "id": 167082024,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559410452
    },
    {
        "content": "<p>We have seen type class inference doing some silly things recently</p>",
        "id": 167082031,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559410482
    },
    {
        "content": "<p>But it is not clear to me that there is some unified sensible algorithm which stops all of those silly things happening at once whilst remaining efficient</p>",
        "id": 167082060,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559410521
    },
    {
        "content": "<p>Why not just let prolog do it and make prolog a dependency?</p>",
        "id": 167082072,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559410553
    },
    {
        "content": "<p>Some people claimed that prolog was better than lean at prolog-like searches</p>",
        "id": 167082121,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559410583
    },
    {
        "content": "<p>I of course am in no position to comment</p>",
        "id": 167082130,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559410605
    },
    {
        "content": "<p>The difference is maybe that Prolog does a Prolog search, instead of merely a prolog-like search <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>",
        "id": 167082162,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559410665
    },
    {
        "content": "<p>For starters, Lean's unification is much more complex than Prolog's. You wouldn't want to lose delta reduction in instance searches</p>",
        "id": 167082220,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1559410717
    },
    {
        "content": "<p>I still reserve the right to snicker when Lean tries 20 random things in order to prove that rat has a one, before finally stumbling on <code>rat.has_one</code></p>",
        "id": 167082221,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559410718
    },
    {
        "content": "<blockquote>\n<p>I still reserve the right to snicker when Lean tries 20 random things in order to prove that rat has a one, before finally stumbling on <code>rat.has_one</code></p>\n</blockquote>\n<p><span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span> Completely agree. I think that guessing the correct name is one place where we could really win, and possibly win a lot.</p>",
        "id": 167082252,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559410773
    },
    {
        "content": "<p>For this reason, I've been trying to always use the auto-generated name for instances, in the hope that this will pay of in the future.</p>",
        "id": 167082313,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559410809
    },
    {
        "content": "<p>This is one example where some instance indexing approach in Lean 4 should make the search instantaneous. Well, assuming you really have the same \"one\" in goal and instance.</p>",
        "id": 167082321,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1559410833
    },
    {
        "content": "<p>It might break some sort of psychological/abstraction barrier in the software though: names ought to be irrelevant to Lean, and only relevant for humans.</p>",
        "id": 167082328,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559410857
    },
    {
        "content": "<p>Use some hidden name that isn't the name we have to look at.</p>",
        "id": 167082487,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1559411043
    },
    {
        "content": "<p>Why does searching for instances in the local context work with explicit arguments but not under a lambda?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">myclass</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"n\">def</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">myclass</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n\n<span class=\"n\">def</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">myclass</span> <span class=\"bp\">ℕ</span><span class=\"o\">]:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"n\">foo</span> <span class=\"n\">n</span> <span class=\"c1\">-- good</span>\n\n<span class=\"n\">def</span> <span class=\"n\">bar&#39;</span><span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">myclass</span> <span class=\"bp\">ℕ</span><span class=\"o\">],</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">foo</span> <span class=\"n\">n</span>\n<span class=\"c\">/-</span><span class=\"cm\"> failed to synthesize type class instance for</span>\n<span class=\"cm\">n : ℕ,</span>\n<span class=\"cm\">h : myclass ℕ</span>\n<span class=\"cm\">⊢ myclass ℕ -/</span>\n</pre></div>",
        "id": 170638724,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1562855631
    },
    {
        "content": "<p>Performance reasons I think. You can do </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">bar&#39;</span><span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">myclass</span> <span class=\"bp\">ℕ</span><span class=\"o\">],</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">exactI</span> <span class=\"n\">foo</span> <span class=\"n\">n</span>\n</pre></div>\n\n\n<p>or</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">bar&#39;</span><span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">myclass</span> <span class=\"bp\">ℕ</span><span class=\"o\">],</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">resetI</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">foo</span> <span class=\"n\">n</span>\n</pre></div>",
        "id": 170638952,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1562855750
    },
    {
        "content": "<p>Ah indeed, local instances are \"frozen\". <code>unfreeze_local_instances</code> is the intrinsic for this. Thanks!</p>",
        "id": 170639240,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1562855903
    }
]
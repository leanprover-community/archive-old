[
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">blah</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"n\">class</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">foo</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">blah2</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span>\n\n<span class=\"n\">class</span> <span class=\"n\">baz</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">foo</span> <span class=\"n\">A</span> <span class=\"bp\">.</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">blah</span> <span class=\"o\">:=</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"n\">blah2</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span><span class=\"o\">}</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- works</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">baz</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- fails</span>\n</pre></div>\n\n\n<p>Why doesn't this work?</p>",
        "id": 151259224,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544432989
    },
    {
        "content": "<p>why would it work? You declared an instance of <code>bar</code> but not <code>baz</code></p>",
        "id": 151259885,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544433949
    },
    {
        "content": "<p>I can figure out how to make an instance of <code>baz</code>, that's why I can believe it would work. All the fields are there. This is my problem -- I don't know what the type class inference system is _doing_.</p>",
        "id": 151260147,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544434256
    },
    {
        "content": "<p>Oh sorry there's a typo -- I meant to write</p>\n<p><code>example : foo ℤ := by apply_instance -- works</code></p>\n<p>I didn't declare an instance of <code>foo</code> but it found it anyway.</p>",
        "id": 151260186,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544434311
    },
    {
        "content": "<p>I literally do not know what it can and cannot do.</p>",
        "id": 151260244,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544434344
    },
    {
        "content": "<p>All I know is that it can do less than me, because I can solve <code>baz</code>.</p>",
        "id": 151260256,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544434362
    },
    {
        "content": "<p><code>class baz (A : Type) extends foo A .</code><br>\nthis creates an instance <code>baz.to_foo</code></p>",
        "id": 151260277,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544434391
    },
    {
        "content": "<p>if you want to make <code>baz</code> from <code>foo</code> then you would need to use <code>{ .. infer_instance }</code></p>",
        "id": 151260291,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544434408
    },
    {
        "content": "<p>Well, maybe I should just create an instance <code>baz.from_foo</code></p>",
        "id": 151260308,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544434438
    },
    {
        "content": "<p>or maybe <code>foo.to_baz</code> would be more appropriate.</p>",
        "id": 151260369,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544434464
    },
    {
        "content": "<p>congratulations, you've thrown yourself into a loop</p>",
        "id": 151260399,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544434509
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">blah</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"n\">class</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">foo</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">blah2</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span>\n\n<span class=\"n\">class</span> <span class=\"n\">baz</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">foo</span> <span class=\"n\">A</span> <span class=\"bp\">.</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">blah</span> <span class=\"o\">:=</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"n\">blah2</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span><span class=\"o\">}</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- works</span>\n\n<span class=\"c1\">-- type class inference is so stupid, why doesn&#39;t it just guess this.</span>\n<span class=\"kn\">instance</span> <span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">to_baz</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">foo</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">baz</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">refine</span> <span class=\"o\">{}</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- fails? WTF?</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">baz</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- still fails</span>\n</pre></div>\n\n\n<p>I broke everything.</p>",
        "id": 151260514,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544434631
    },
    {
        "content": "<p>I don't understand why everything is broken. Everything is defeq, right?</p>",
        "id": 151260535,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544434664
    },
    {
        "content": "<p>you now have <code>foo.to_baz</code> and <code>baz.to_foo</code></p>",
        "id": 151260617,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544434690
    },
    {
        "content": "<p>so the machine gets stuck forever</p>",
        "id": 151260621,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544434695
    },
    {
        "content": "<p><code>example (A : Type) (H : foo A) : H = baz.to_foo A := rfl</code></p>",
        "id": 151260645,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544434743
    },
    {
        "content": "<p>I don't understand why it gets stuck forever. What is it doing? I am pretty convinced it's not playing the \"let's see how many instances I can make from this instance, for no reason whatsoever\" game. I ask the type class inference system to produce me a term of a typeclass, it should just try and try until it finds one and then stop.</p>",
        "id": 151260716,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544434807
    },
    {
        "content": "<p>Of course I completely understand that I have made a loop. What I don't understand is why this even matters.</p>",
        "id": 151260728,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544434824
    },
    {
        "content": "<p>oh it <em>is</em> playing that game</p>",
        "id": 151260734,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544434828
    },
    {
        "content": "<p>It is??</p>",
        "id": 151260737,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544434839
    },
    {
        "content": "<p>wait no it isn't</p>",
        "id": 151260742,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544434846
    },
    {
        "content": "<p>But your response makes me think that you can write some simple thing which will make it play this game.</p>",
        "id": 151260756,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544434868
    },
    {
        "content": "<p>well you want it to figure out <code>baz</code>. then it goes like \"hey I can make this from <code>foo</code>\". then it goes like \"hey I can make this from <code>baz</code>\". ad nauseam</p>",
        "id": 151260772,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544434906
    },
    {
        "content": "<p>so maybe priority is the answer</p>",
        "id": 151260775,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544434910
    },
    {
        "content": "<p>Do you know where it starts? At the top or the bottom?</p>",
        "id": 151260823,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544434930
    },
    {
        "content": "<p>It says \"Hmm, I want to make  an instance of <code>baz A</code>\". Now does it say \"OK so how do we make instances of <code>baz A</code>? or does it say \"OK what other typeclasses can I make with <code>A</code>\"? Hmm, I guess it must be the former.</p>",
        "id": 151260859,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544434971
    },
    {
        "content": "<p>it is the former</p>",
        "id": 151260883,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544435001
    },
    {
        "content": "<p>So the type class system looks through <em>all instances</em> and tries to find one whose head term is <code>baz</code>?</p>",
        "id": 151260925,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544435031
    },
    {
        "content": "<p>Say it finds ten such things. What does it do now?</p>",
        "id": 151260929,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544435040
    },
    {
        "content": "<p>apply each one</p>",
        "id": 151260970,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544435049
    },
    {
        "content": "<p>(but mind you, it uses depth-first search)</p>",
        "id": 151260973,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544435057
    },
    {
        "content": "<p>\"Head term\" -- is that the right phrase? I mean \"a term which is a function <code>baz [something]</code></p>",
        "id": 151260979,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544435077
    },
    {
        "content": "<p>What is depth-first search?</p>",
        "id": 151260983,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544435087
    },
    {
        "content": "<p>depth-first search = dig this hole as deep as possible until you find gold or you are blocked by a stone, and then move on to the next hole</p>",
        "id": 151261002,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544435128
    },
    {
        "content": "<p>Is this the one where it finds the first instance of <code>baz A</code> and finds that it needs <code>moo A</code> and it checks for a term of type <code>moo A</code> and temporarily forgets all about the other nine ideas about <code>baz</code> and just looks for <code>moo</code> stuff?</p>",
        "id": 151261014,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544435154
    },
    {
        "content": "<p>breadth-first search = dig this hole 1 cm, go to next hole and dig 1cm, and so on until you run out of holes, and then go back to the first hole and dig 1cm, etc</p>",
        "id": 151261087,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544435175
    },
    {
        "content": "<blockquote>\n<p>Is this the one where it finds the first instance of <code>baz A</code> and finds that it needs <code>moo A</code> and it checks for a term of type <code>moo A</code> and if it can't find that it forgets all about the other nine ideas about <code>baz</code> and just looks for <code>moo</code> stuff?</p>\n</blockquote>\n<p>precisely</p>",
        "id": 151261114,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544435182
    },
    {
        "content": "<p>How does it conclude that it is blocked by a stone?</p>",
        "id": 151261125,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544435208
    },
    {
        "content": "<p>Can this only happen when there are literally no instances which have the right head term or whatever the phrase is?</p>",
        "id": 151261151,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544435246
    },
    {
        "content": "<p>yes</p>",
        "id": 151261160,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544435268
    },
    {
        "content": "<p>so for example there is no instance that produces <code>ordered_canonical_discrete_ordered_field</code> or whatever the flying that is</p>",
        "id": 151261214,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544435293
    },
    {
        "content": "<p>because it's the highest structure</p>",
        "id": 151261221,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544435302
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">H1</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"bp\">.</span>\n\n<span class=\"n\">class</span> <span class=\"n\">H11</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">H1</span> <span class=\"n\">A</span> <span class=\"bp\">.</span>\n\n<span class=\"n\">class</span> <span class=\"n\">H12</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">H1</span> <span class=\"n\">A</span> <span class=\"bp\">.</span>\n</pre></div>\n\n\n<p>Does this segfault for you?</p>",
        "id": 151261260,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544435371
    },
    {
        "content": "<p>I am trying to do some simple experiments.</p>",
        "id": 151261317,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544435403
    },
    {
        "content": "<p>no it doesn't</p>",
        "id": 151261336,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544435416
    },
    {
        "content": "<blockquote>\n<p>Can this only happen when there are literally no instances which have the right head term or whatever the phrase is?</p>\n</blockquote>\n<p>No, it's sufficient that no instance of the target class can be unified with the target</p>",
        "id": 151261421,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1544435524
    },
    {
        "content": "<p>Hmm, thanks, I'll restart VS Code.</p>",
        "id": 151261476,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544435624
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> what's the difference?</p>",
        "id": 151261537,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544435662
    },
    {
        "content": "<p>The head symbol could match but not the rest</p>",
        "id": 151261551,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1544435694
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">H1</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"bp\">.</span>\n\n<span class=\"n\">class</span> <span class=\"n\">H11</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">H1</span> <span class=\"n\">A</span> <span class=\"bp\">.</span>\n\n<span class=\"n\">class</span> <span class=\"n\">H12</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">H1</span> <span class=\"n\">A</span> <span class=\"bp\">.</span>\n\n<span class=\"n\">class</span> <span class=\"n\">H111</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">H11</span> <span class=\"n\">A</span> <span class=\"bp\">.</span>\n\n<span class=\"n\">class</span> <span class=\"n\">H121</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">H12</span> <span class=\"n\">A</span> <span class=\"bp\">.</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">H1</span><span class=\"bp\">.</span><span class=\"n\">to_H11</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">H1</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">H11</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">refine</span> <span class=\"o\">{}</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">H11</span><span class=\"bp\">.</span><span class=\"n\">to_H111</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">H11</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">H111</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">refine</span> <span class=\"o\">{}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">H121</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">refine</span> <span class=\"o\">{}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">H111</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n</pre></div>\n\n\n<p>That seems to have gone really well.</p>",
        "id": 151261571,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544435729
    },
    {
        "content": "<p>I am trying to get into trouble. I am trying to get max class inference thingy error</p>",
        "id": 151261646,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544435785
    },
    {
        "content": "<p>but you didn't create any loop...</p>",
        "id": 151261672,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544435826
    },
    {
        "content": "<p>oh wait you did</p>",
        "id": 151261675,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544435835
    },
    {
        "content": "<p>Right, H1 and H11 loop</p>",
        "id": 151261679,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544435848
    },
    {
        "content": "<p>but I managed to get past the loop and up to H111</p>",
        "id": 151261682,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544435859
    },
    {
        "content": "<p>Kevin, in your case there exactly one instance to try at each step, and it clearly succeeds without ever risking a loop:</p>\n<div class=\"codehilite\"><pre><span></span>[class_instances]  class-instance resolution trace\n[class_instances] (0) ?x_0 : H111 unit := @H11.to_H111 ?x_1 ?x_2\n[class_instances] (1) ?x_2 : H11 unit := @H1.to_H11 ?x_3 ?x_4\n[class_instances] (2) ?x_4 : H1 unit := @H12.to_H1 ?x_5 ?x_6\n[class_instances] (3) ?x_6 : H12 unit := @H121.to_H12 ?x_7 ?x_8\n[class_instances] (4) ?x_8 : H121 unit := unit.H121\n</pre></div>\n\n\n<p>You can simply draw the instance graph and see it</p>",
        "id": 151262058,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1544436403
    },
    {
        "content": "<p>I want to make it get stuck in a loop</p>",
        "id": 151262747,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544437498
    },
    {
        "content": "<p>To find <code>H111</code> it suffices to find <code>H1</code>. Can I make it look for <code>H1</code> by going back to <code>H12</code>?</p>",
        "id": 151262764,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544437549
    },
    {
        "content": "<p>Oh I see, that instance is not even there.</p>",
        "id": 151262817,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544437570
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">H1</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"bp\">.</span>\n\n<span class=\"n\">class</span> <span class=\"n\">H11</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">H1</span> <span class=\"n\">A</span> <span class=\"bp\">.</span>\n\n<span class=\"n\">class</span> <span class=\"n\">H12</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">H1</span> <span class=\"n\">A</span> <span class=\"bp\">.</span>\n\n<span class=\"n\">class</span> <span class=\"n\">H111</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">H11</span> <span class=\"n\">A</span> <span class=\"bp\">.</span>\n\n<span class=\"n\">class</span> <span class=\"n\">H121</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">H12</span> <span class=\"n\">A</span> <span class=\"bp\">.</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">H1</span><span class=\"bp\">.</span><span class=\"n\">to_H11</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">H1</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">H11</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">refine</span> <span class=\"o\">{}</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">H11</span><span class=\"bp\">.</span><span class=\"n\">to_H111</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">H11</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">H111</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">refine</span> <span class=\"o\">{}</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">H1</span><span class=\"bp\">.</span><span class=\"n\">to_H12</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">H1</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">H12</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">refine</span> <span class=\"o\">{}</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">H12</span><span class=\"bp\">.</span><span class=\"n\">to_H121</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">H12</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">H121</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">refine</span> <span class=\"o\">{}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">H121</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">refine</span> <span class=\"o\">{}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">H111</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- max depth reached</span>\n</pre></div>\n\n\n<p>Bingo.</p>",
        "id": 151262875,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544437653
    },
    {
        "content": "<p>So whatever is type class inference thinking here? Why go back to <code>H12</code> when we have been there already?</p>",
        "id": 151262890,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544437675
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">set_option</span> <span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">class_instances</span> <span class=\"n\">true</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">H111</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- max depth reached</span>\n</pre></div>\n\n\n<p>gives random stuff such as</p>\n<div class=\"codehilite\"><pre><span></span>[class_instances] (0) ?x_0 : has_one ℕ := unsigned.has_one\n</pre></div>\n\n\n<p>Who said anything about nat?</p>",
        "id": 151263019,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544437813
    },
    {
        "content": "<p>I'm glad the type class inference system's job isn't finding its way out of mazes.</p>",
        "id": 151263079,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544437915
    },
    {
        "content": "<p>usually one writes a depth first search with a search stack to prevent loops like this</p>",
        "id": 151263165,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544437989
    },
    {
        "content": "<p>The nat thing is related to my question to Sebastian about shortcut. It has nothing to do with your problem, it's something Lean solves for itself in its meta-work</p>",
        "id": 151263180,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1544438016
    },
    {
        "content": "<p>I'm not sure why typeclass inference doesn't have one</p>",
        "id": 151263184,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544438022
    },
    {
        "content": "<p>then again, this wouldn't prevent problems with loops that look different the second time around</p>",
        "id": 151263234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544438056
    },
    {
        "content": "<p>i.e. the same instances are being used but the instantiations are different</p>",
        "id": 151263243,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544438074
    },
    {
        "content": "<p>OK this is great. I have to interview a bunch of people now but I will probably be back later on with more dumb questions. This has been a great start. Thanks to all.</p>",
        "id": 151264966,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544440052
    },
    {
        "content": "<p>Conceptually, Lean could require one to prove instance backchaining is well-founded.  Haskell has static checks to ensure this, but those can be bypassed via language pragma.</p>",
        "id": 151390897,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1544469642
    },
    {
        "content": "<p>I'm coming back to this; I'm trying to understand the details of type class inference better, because mathematicians are better at doing type class inference than Lean.</p>\n<p>What's going on here?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">pi_instances</span> <span class=\"c1\">-- prod.add_group defined here</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">add_group</span> <span class=\"o\">(</span><span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">add_group</span> <span class=\"o\">(</span><span class=\"bp\">ℤ</span> <span class=\"bp\">×</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">add_group</span> <span class=\"o\">(</span><span class=\"bp\">ℤ</span> <span class=\"bp\">×</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">×</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">add_group</span> <span class=\"o\">(</span><span class=\"bp\">ℤ</span> <span class=\"bp\">×</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">×</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">×</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">add_group</span> <span class=\"o\">(</span><span class=\"bp\">ℤ</span> <span class=\"bp\">×</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">×</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">×</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">×</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- fails</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">add_group</span>\n</pre></div>",
        "id": 163798765,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555758428
    },
    {
        "content": "<p>I'm pretty sure if you look at the instance trace it will be 5 orders of magnitude longer than you think it should be</p>",
        "id": 163798814,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1555758542
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">pi_instances</span> <span class=\"c1\">-- prod.add_group defined here</span>\n\n<span class=\"kn\">set_option</span> <span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">class_instances</span> <span class=\"n\">true</span>\n<span class=\"c1\">-- set_option class.instance_max_depth 39 -- a fix</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">add_group</span> <span class=\"o\">(</span><span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- needs class.instance_max_depth 7</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">add_group</span> <span class=\"o\">(</span><span class=\"bp\">ℤ</span> <span class=\"bp\">×</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- needs 15</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">add_group</span> <span class=\"o\">(</span><span class=\"bp\">ℤ</span> <span class=\"bp\">×</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">×</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- needs 23</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">add_group</span> <span class=\"o\">(</span><span class=\"bp\">ℤ</span> <span class=\"bp\">×</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">×</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">×</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- needs 31</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">add_group</span> <span class=\"o\">(</span><span class=\"bp\">ℤ</span> <span class=\"bp\">×</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">×</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">×</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">×</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- default is 32</span>\n</pre></div>",
        "id": 163798932,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555758729
    },
    {
        "content": "<p>Yeah, my search through the tree is a lot more efficient than Lean's.</p>",
        "id": 163798934,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555758747
    },
    {
        "content": "<p>Can't we have <code>set_option class_instance.backend Kevin</code>?</p>",
        "id": 163798946,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1555758800
    },
    {
        "content": "<p>It could send me a notification on Zulip and I'll suggest some hints.</p>",
        "id": 163798948,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555758830
    },
    {
        "content": "<p>OK it is time for me to understand the output of <code>trace.class_instances</code>.</p>",
        "id": 163798949,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555758841
    },
    {
        "content": "<p>Here's Lean trying to prove the trivial statement that Z^4 is a group:</p>",
        "id": 163798992,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555758859
    },
    {
        "content": "<p><a href=\"https://gist.github.com/kbuzzard/94813d4b0a01f896f740c91b2d971cd8\" target=\"_blank\" title=\"https://gist.github.com/kbuzzard/94813d4b0a01f896f740c91b2d971cd8\">https://gist.github.com/kbuzzard/94813d4b0a01f896f740c91b2d971cd8</a></p>",
        "id": 163798997,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555758902
    },
    {
        "content": "<p>Let's start at the top.</p>\n<div class=\"codehilite\"><pre><span></span>[class_instances] (0) ?x_0 : add_group (ℤ × ℤ × ℤ × ℤ) := @prod.add_group ?x_1 ?x_2 ?x_3 ?x_4\n[class_instances] (1) ?x_3 : add_group ℤ := @prod.add_group ?x_5 ?x_6 ?x_7 ?x_8\nfailed is_def_eq\n[class_instances] (1) ?x_3 : add_group ℤ := @pi.add_group ?x_9 ?x_10 ?x_11\nfailed is_def_eq\n[class_instances] (1) ?x_3 : add_group ℤ := @subtype.add_group ?x_12 ?x_13 ?x_14 ?x_15\nfailed is_def_eq\n[class_instances] (1) ?x_3 : add_group ℤ := @additive.add_group ?x_16 ?x_17\nfailed is_def_eq\n[class_instances] (1) ?x_3 : add_group ℤ := @add_comm_group.to_add_group ?x_18 ?x_19\n[class_instances] (2) ?x_19 : add_comm_group ℤ := @prod.add_comm_group ?x_20 ?x_21 ?x_22 ?x_23\n</pre></div>",
        "id": 163799006,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555758935
    },
    {
        "content": "<p>What does (0), (1) and (2) mean?</p>",
        "id": 163799010,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555758947
    },
    {
        "content": "<p>It seems to me that Lean has _very_ quickly decided that <code>prod.add_group</code> is a good idea.</p>",
        "id": 163799055,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555758971
    },
    {
        "content": "<p>Why?</p>",
        "id": 163799059,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555758984
    },
    {
        "content": "<p>The number is the depth of the search so-far,<br>\nand I think it found it just trying in some random order, respecting priorities</p>",
        "id": 163799065,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1555759014
    },
    {
        "content": "<p>So for example there are multiple (1)s because the first few things at that depth which it tries were rejected, before it found something the could possibly work (it didn't give a <code>failed is_def_eq</code>) there</p>",
        "id": 163799078,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1555759077
    },
    {
        "content": "<p>Obviously <code>prod.add_group</code> is a good first move. But then its next move is an attempt to prove <code>add_group Z</code> using <code>pi.add_group</code> which is equally obviously a completely stupid move.</p>",
        "id": 163799079,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555759077
    },
    {
        "content": "<p>So I believe we are doing a depth-first search here, and my understanding is that the <code>(n)</code> is telling us the depth we're allowed to go before...what? Before giving up?</p>",
        "id": 163799142,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555759196
    },
    {
        "content": "<p>The <code>pi.add_group</code> is not a horrible move; it is quickly discarded without an expensive subproof</p>",
        "id": 163799192,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1555759228
    },
    {
        "content": "<p>Before giving up going down that hole and turning back, presumably, rather than giving up and saying <code>maximum class-instance resolution depth has been reached</code>?</p>",
        "id": 163799194,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555759242
    },
    {
        "content": "<p>the <code>(n)</code> is just telling you what depth we are at currently, AFAIK it's not (directly) connected to a timeout</p>",
        "id": 163799208,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1555759294
    },
    {
        "content": "<p>Why is it discarded? Because the \"head terms\" don't match? Is that the correct phrase? Is the \"head term\" of <code>int</code> just <code>int</code>, and the \"head term\" of <code>pi.add_group</code> is something else?</p>",
        "id": 163799210,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555759305
    },
    {
        "content": "<p>yes</p>",
        "id": 163799213,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1555759312
    },
    {
        "content": "<p>lean knows that <code>pi bla bla != int</code></p>",
        "id": 163799259,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1555759332
    },
    {
        "content": "<p>To make things extra confusing, there are two notions of depth in type class search -- iirc, the max_depth option is not controlling the maximum number that you see in the trace, it's something to do with the backtracking depth. But I might be misremembering the details. Johannes wrote something about this last month.</p>",
        "id": 163799264,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1555759354
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">pi</span><span class=\"bp\">.</span><span class=\"n\">add_group</span> <span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span> <span class=\"n\">add_group</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)],</span> <span class=\"n\">add_group</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>For this to work, indeed <code>int</code> would have to be <code>Pi ...</code>.</p>",
        "id": 163799269,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555759357
    },
    {
        "content": "<p><a href=\"https://github.com/johoelzl/tc-log-parser\" target=\"_blank\" title=\"https://github.com/johoelzl/tc-log-parser\">https://github.com/johoelzl/tc-log-parser</a></p>",
        "id": 163799281,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1555759410
    },
    {
        "content": "<p>So is my observation \"clearly this won't work\" exactly what Lean is doing here? It has a big list of a whole bunch of definitions all tagged with the instance tag, and it looks at all of the instances of the form <code>X -&gt; add_group Y</code> or <code>add_group Y</code> and then tries them all in a random order?</p>",
        "id": 163799284,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555759429
    },
    {
        "content": "<p>oh crap, chores beckon. Back in 30 minutes. I want to understand why we're using up 8 levels for each extra int.</p>",
        "id": 163799332,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555759463
    },
    {
        "content": "<blockquote>\n<p><a href=\"https://github.com/johoelzl/tc-log-parser\" target=\"_blank\" title=\"https://github.com/johoelzl/tc-log-parser\">https://github.com/johoelzl/tc-log-parser</a></p>\n</blockquote>\n<p>Has anyone talked to Sebastian or Leo about this issue?</p>",
        "id": 163801969,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555764171
    },
    {
        "content": "<p><code>#print notation × -- _ </code>×<code>:35 _:34 := prod #1 #0</code> -- <code>\\times</code> is right associative!</p>",
        "id": 163802053,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555764346
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>[class_instances] (1) ?x_3 : add_group ℤ := @prod.add_group ?x_5 ?x_6 ?x_7 ?x_8\nfailed is_def_eq\n</pre></div>\n\n\n<p>That fails because <code>int</code> isn't <code>prod ?x ?y</code> for any choices of <code>?x</code> and <code>?y</code>. But</p>\n<div class=\"codehilite\"><pre><span></span>[class_instances] (3) ?x_34 : nonneg_comm_group ℤ := @linear_nonneg_ring.to_nonneg_comm_group ?x_35 ?x_36\n[class_instances] (3) ?x_34 : nonneg_comm_group ℤ := @nonneg_ring.to_nonneg_comm_group ?x_35 ?x_36\n</pre></div>\n\n\n<p>That's a different failure, right? Lean figured that if it could find a term of type <code>linear_nonneg_ring ℤ</code> then it would be done, but it does not even write</p>\n<div class=\"codehilite\"><pre><span></span>[class_instances] (4) ?x_36 : linear_nonneg_ring ℤ := ...\n</pre></div>\n\n\n<p>--- why not? </p>\n<p>How do I find every instance of <code>X1 -&gt; X2 -&gt; ... -&gt; Xn -&gt; linear_nonneg_ring x</code> in Lean's type class inference system? Here n can be 0.</p>",
        "id": 163802228,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555764696
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>[class_instances]  class-instance resolution trace\n[class_instances] (0) ?x_0 : inhabited ℕ := @quotient_add_group.inhabited ?x_1 ?x_2 ?x_3 ?x_4 ?x_5\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := @quotient_group.inhabited ?x_6 ?x_7 ?x_8 ?x_9 ?x_10\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := @parser.inhabited ?x_11\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := @array.inhabited ?x_12 ?x_13 ?x_14\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := @d_array.inhabited ?x_15 ?x_16 ?x_17\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := @vector.inhabited ?x_18 ?x_19 ?x_20\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := @finset.inhabited ?x_21\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := @multiset.inhabited ?x_22\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := int.inhabited\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := @unique.inhabited ?x_23 ?x_24\n[class_instances] (1) ?x_24 : unique ℕ := punit.unique\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := @psigma.inhabited ?x_1 ?x_2 ?x_3 ?x_4\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := @sigma.inhabited ?x_5 ?x_6 ?x_7 ?x_8\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := @set.inhabited ?x_9\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := tactic.rcases_patt_inverted.inhabited\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := tactic.rcases_patt.inhabited\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := punit.inhabited\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := occurrences.inhabited\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := environment.inhabited\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := expr.inhabited\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := level.inhabited\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := format.inhabited\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := options.inhabited\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := option.inhabited ?x_10\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := name.inhabited\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := @sum.inhabited_right ?x_11 ?x_12 ?x_13\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := @sum.inhabited_left ?x_14 ?x_15 ?x_16\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := @subtype.inhabited ?x_17 ?x_18 ?x_19 ?x_20\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := string.inhabited\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := char.inhabited\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := list.inhabited ?x_21\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited ℕ := nat.inhabited\n</pre></div>\n\n\n<p>Even though, when I make a term of type <code>inhabited ℕ</code> as an instance, Lean by default calls it <code>nat.inhabited</code> -- even though this, Lean doesn't think to look for <code>nat.inhabited</code> as the answer when it's trying to solve <code>inhabited ℕ</code> using type class inference?</p>",
        "id": 163802650,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555765482
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>...\n[class_instances] (0) ?x_0 : inhabited Prop := string.inhabited\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited Prop := char.inhabited\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited Prop := list.inhabited ?x_21\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited Prop := nat.inhabited\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited Prop := @prod.inhabited ?x_22 ?x_23 ?x_24 ?x_25\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited Prop := true.inhabited\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited Prop := bool.inhabited\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited Prop := @pi.inhabited ?x_26 ?x_27 ?x_28\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited Prop := @fun.inhabited ?x_29 ?x_30 ?x_31\nfailed is_def_eq\n[class_instances] (0) ?x_0 : inhabited Prop := prop.inhabited\n</pre></div>\n\n\n<p>You are so dumb Lean! What did you think it was going to be called??</p>",
        "id": 163802801,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555765727
    },
    {
        "content": "<p>Hahaha!</p>",
        "id": 163802803,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1555765736
    },
    {
        "content": "<p>36 failures before it hit upon that one</p>",
        "id": 163802818,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555765778
    },
    {
        "content": "<p>:D</p>",
        "id": 163802824,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1555765793
    },
    {
        "content": "<p>Actually that's a really good point. With a proper indexing lean could just guess the name and skip the search</p>",
        "id": 163803111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1555766270
    },
    {
        "content": "<p>The answer to your earlier question is <code>#print instances linear_nonneg_ring</code></p>",
        "id": 163803161,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1555766340
    },
    {
        "content": "<p>There are no instances of <code>linear_nonneg_ring</code>, so it probably performed the (empty) search and that's why you don't see it</p>",
        "id": 163803175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1555766385
    },
    {
        "content": "<p>Thanks. I just learnt about <code>#print instances</code> from re-reading TPIL.</p>",
        "id": 163803240,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555766418
    },
    {
        "content": "<p>OK so I tried to explain type class inference to my 16 year old son and basically I realised that I had to abstract it before I could explain it. How does this sound?</p>",
        "id": 163803272,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555766519
    },
    {
        "content": "<p>We have 1000 puzzles, P1 up to P1000. We also have a bunch of techniques: each technique is of the form \"if you can solve this finite set of puzzles, you can also solve that puzzle\". For example if you can solve P1 and P3 and P10, you can also solve P11.</p>",
        "id": 163803329,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555766575
    },
    {
        "content": "<p>A degenerate example of a technique is \"if you can solve no puzzles at all, then you can solve P1\"</p>",
        "id": 163803345,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555766589
    },
    {
        "content": "<p>The question is: \"solve puzzle 53\"</p>",
        "id": 163803348,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555766602
    },
    {
        "content": "<p>(using only the techniques you have).</p>",
        "id": 163803351,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555766620
    },
    {
        "content": "<p>My son suggested first solving all the puzzles which need no input; I guess that's all the instances which are just of the form <code>ring int</code> or whatever.</p>",
        "id": 163803407,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555766675
    },
    {
        "content": "<p>Now is this the point where I need to understand what a prolog-like search is?</p>",
        "id": 163803420,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555766704
    },
    {
        "content": "<p>If this were an IOI problem, I would be told how many puzzles there were and how many techniques.</p>",
        "id": 163803433,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555766761
    },
    {
        "content": "<p>Each technique is an instance in Lean I guess.</p>",
        "id": 163803483,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555766778
    },
    {
        "content": "<blockquote>\n<p>Actually that's a really good point. With a proper indexing lean could just guess the name and skip the search</p>\n</blockquote>\n<p>How much easier is checking whether a bunch of strings matches <code>prop.inhabited</code> than checking whether a bunch of Types matches <code>inhabited Prop</code>?</p>\n<p>Also, I'm surprised that the error is <code>failed is_def_eq</code>. Doesn't type class inference care about syntactic equality?</p>",
        "id": 163803487,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1555766790
    },
    {
        "content": "<p>Oh -- my son is asking if there can be loops!</p>",
        "id": 163803488,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555766791
    },
    {
        "content": "<p>It's much easier to check whether <code>prop.inhabited</code> is what we want, because we don't have to linearly search through instances, we can just jump straight to the def by name</p>",
        "id": 163803637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1555767026
    },
    {
        "content": "<p>It uses defeq with a really strict unfold predicate</p>",
        "id": 163803658,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1555767075
    },
    {
        "content": "<p>so that it can handle reducible defs and beta reduction</p>",
        "id": 163803710,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1555767133
    },
    {
        "content": "<p>I thought that the whole point of wrapper types was that you absolutely did not want Lean to solve <code>has_add my_int</code> by noticing that <code>my_int</code> was defined to be <code>int</code> and solving <code>has_add int</code></p>",
        "id": 163803782,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555767275
    },
    {
        "content": "<p>I told my son that in Lean and mathlib they try to avoid loops. We don't want P6 -&gt; P7 and P7 -&gt; P6.</p>",
        "id": 163803801,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555767329
    },
    {
        "content": "<p>We don't, unless we do</p>",
        "id": 163804623,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1555768832
    },
    {
        "content": "<p>Most types are not marked reducible for exactly this reason</p>",
        "id": 163804626,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1555768848
    },
    {
        "content": "<p>but reducible types are transparent to typeclass inference, which can be convenient if you want to inherit all the typeclasses from the original</p>",
        "id": 163804640,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1555768895
    },
    {
        "content": "<p>There are lots of implementations of prolog</p>",
        "id": 163804686,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555768931
    },
    {
        "content": "<p>Why doesn't Leo just use one of these and get it to solve typeclass problems for him?</p>",
        "id": 163804687,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555768958
    },
    {
        "content": "<p>prolog is quite a bit better at this than lean</p>",
        "id": 163804688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1555768960
    },
    {
        "content": "<p>there are mechanisms for controlling the search, avoiding backtracking and ordering rules, etc</p>",
        "id": 163804699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1555768984
    },
    {
        "content": "<p>I don't really know if typeclass search is actually an issue in practice, but I guess one day it might become an issue</p>",
        "id": 163804769,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555769060
    },
    {
        "content": "<p>I guess my students having hard-to-debug code because they accidentally coerced an int to a nat is an issue</p>",
        "id": 163804789,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555769110
    },
    {
        "content": "<p>I am completely confused by this still. Why does Lean try to solve [has_zero nat] in lots of ways and then have [has_neg nat] fail every time?</p>",
        "id": 163804850,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555769199
    },
    {
        "content": "<p>That's my understanding of what was going on there</p>",
        "id": 163804853,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555769214
    },
    {
        "content": "<p>Lots of different but defeq solutions to 0 and 1</p>",
        "id": 163804868,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555769242
    },
    {
        "content": "<p>And then a possibly expensive add and a failing neg</p>",
        "id": 163804876,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555769265
    },
    {
        "content": "<p>My view on this is that typeclass inference needs a major rewrite, we can do much better than what we have today</p>",
        "id": 163806231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1555771746
    },
    {
        "content": "<p>well, you can definitely add a bunch of heuristics</p>",
        "id": 163807163,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1555773279
    },
    {
        "content": "<p>if you like slides and python-ish pseudocode, <a href=\"http://aima.eecs.berkeley.edu/slides-pdf/chapter05.pdf\" target=\"_blank\" title=\"http://aima.eecs.berkeley.edu/slides-pdf/chapter05.pdf\">http://aima.eecs.berkeley.edu/slides-pdf/chapter05.pdf</a></p>",
        "id": 163807167,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1555773295
    },
    {
        "content": "<p>is the CS undergrad overview of backtracking</p>",
        "id": 163807182,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1555773310
    },
    {
        "content": "<p>with accompanying pdf: <a href=\"http://aima.cs.berkeley.edu/newchap05.pdf\" target=\"_blank\" title=\"http://aima.cs.berkeley.edu/newchap05.pdf\">http://aima.cs.berkeley.edu/newchap05.pdf</a></p>",
        "id": 163807272,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1555773453
    },
    {
        "content": "<p>Thanks Andrew. Part of me wants to go back to college and do an UG degree in computer science, except skipping all the hardware stuff</p>",
        "id": 163807635,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555774079
    },
    {
        "content": "<p>But I guess I know now that I can learn this stuff from references; I just need to be pointed in the right direction.</p>",
        "id": 163807681,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555774099
    },
    {
        "content": "<p>abusing type class inference to solve the n-queens problem in lean: <a href=\"https://gist.github.com/Kha/2cdd2df8bd318019bea75f1ea87ae4a0\" target=\"_blank\" title=\"https://gist.github.com/Kha/2cdd2df8bd318019bea75f1ea87ae4a0\">https://gist.github.com/Kha/2cdd2df8bd318019bea75f1ea87ae4a0</a></p>",
        "id": 163808449,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1555775507
    },
    {
        "content": "<p>I always thought this example was cute</p>",
        "id": 163808454,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1555775519
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">equation</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span><span class=\"o\">,</span> <span class=\"n\">term</span>\n  <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">expr</span> <span class=\"n\">ff</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">expr</span>\n</pre></div>\n\n\n<p>:-(</p>",
        "id": 163808570,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1555775693
    },
    {
        "content": "<p>replace the triple backtick with single</p>",
        "id": 163808637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1555775772
    }
]
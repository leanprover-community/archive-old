[
    {
        "content": "<p>some people have expressed interest in kevin's xenaproject lean posts being posted somewhere in this zulip so that they don't miss it, so i am making this topic.</p>\n<p>use this topic for posting and discussing new and old xena blog posts.<br>\nlink to the blog: <a href=\"https://xenaproject.wordpress.com/\">https://xenaproject.wordpress.com/</a></p>",
        "id": 202807376,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593785369
    },
    {
        "content": "<p>newest post: <a href=\"https://xenaproject.wordpress.com/2020/07/03/equality-specifications-and-implementations/\">Equality, specifications, and implementations</a></p>",
        "id": 202807445,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593785403
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 202807992,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593785792
    },
    {
        "content": "<p>The blog does have an RSS feed :) . However, it might not make much sense to post blog updates to the same #rss channel as repo updates</p>",
        "id": 202808848,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1593786356
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/113488-general/topic/XenaProject.20blog.20posts/near/202808848\">said</a>:</p>\n<blockquote>\n<p>The blog does have an RSS feed :) . However, it might not make much sense to post blog updates to the same #rss channel as repo updates</p>\n</blockquote>\n<p>i hope that this topic will already work organically. most avid lean users likely read kevin's blog anyways, so someone will most certainly post it eventually now that there's a place for it. in addition, we can also use this topic for discussion!</p>",
        "id": 202809211,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593786558
    },
    {
        "content": "<p>Yes, this RSS question also came to my mind, but I didn't suggest it because this has a clearly distinct flavor from what we put in the rss stream.</p>",
        "id": 202809280,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1593786597
    },
    {
        "content": "<p>It might be possible to use different streams for different feeds, but I don't mind this being solved by manual labor</p>",
        "id": 202809729,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1593786845
    },
    {
        "content": "<p>For what it's worth, of course I don't mind what happens ultimately wrt posting here, but I've not been posting these things here myself here because for me the point of this Zulip is that it is a professional place where experts hang out and help solve Lean problems and make progress with lean and mathlib. My blog posts are just supposed to be for a general mathematical audience. I have no qualms advertising them on the Xena discord but that's full of non-experts.</p>",
        "id": 202813756,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593789221
    },
    {
        "content": "<p>i think that exactly because they are for a general mathematical audience, they are of interest to the experts here. </p>\n<p>discussion on how to improve the theorem proving experience also seems to be an important part of this zulip, and for that this kind of perspective (and any related discussion) is very valuable.<br>\nafter all, judging from twitter, even plenty of people that build theorem provers read your posts (likely for that exact reason!).<br>\nbesides, as a cs person myself i found many of your posts very helpful, not only to understand how lean works, but also to gain a broader perspective in terms of how decisions in the lean design impact the people formalizing mathematics :)</p>",
        "id": 202815131,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593790120
    },
    {
        "content": "<p>(this is in part why i am in favor of this topic working organically as opposed to being run by an rss bot: if people do not deem some post from your blog interesting for this zulip, perhaps because it is entirely unrelated to lean, they will simply not post it)</p>",
        "id": 202816241,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593790912
    },
    {
        "content": "<p>This is a very naïve and probably not well-thought-out question about the latest blog post. When we want to work with specifications in Lean, we usually use structures or type classes, right? Is the issue with using structures for reals that the API is way too big to hide in a structure?</p>",
        "id": 202818740,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593792611
    },
    {
        "content": "<p>no, we could certainly do that</p>",
        "id": 202819667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593793231
    },
    {
        "content": "<p>indeed, when we get to lean 4 I'm thinking of setting up a single structure <code>constant R : RealInterface := ...</code> that proves that there exists an implementation of \"the reals\" so that we really can get some isolation</p>",
        "id": 202819780,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593793310
    },
    {
        "content": "<p>but I think there are not too many times when we want a hard barrier like that</p>",
        "id": 202819860,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593793349
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> said:</p>\n<blockquote>\n<p>But you’ll find that it’s a real bore with Dedekind cuts, because Dedekind cuts have this annoying property that you need a convention for the cuts corresponding to rational numbers: whether to put the rational number itself into the lower or upper cut. Neither convention gives a nice definition of addition. You can’t just add the lower cuts and the upper cuts, because the sum of two irrationals can be a rational.</p>\n</blockquote>\n<p>Actually addition on dedekind cuts isn't as bad as this. You can say that a dedekind cut is just the lower set (exclusive), and then pointwise addition works just fine. The thing about multiplication is true, but you can avoid the problem by only defining positive reals</p>",
        "id": 202820115,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593793547
    },
    {
        "content": "<p>From  a related file I'm (serendipitously) working on, how does  <code>class conditionally_complete_linear_ordered_field (F : Type*) extends discrete_linear_ordered_field F,\n  conditionally_complete_linear_order F</code> sound as the structure?</p>",
        "id": 202820192,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1593793574
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/XenaProject.20blog.20posts/near/202819780\">said</a>:</p>\n<blockquote>\n<p>indeed, when we get to lean 4 I'm thinking of setting up a single structure <code>constant R : RealInterface := ...</code> that proves that there exists an implementation of \"the reals\" so that we really can get some isolation</p>\n</blockquote>\n<p>The question is: can we do that and still use the notation <code>ℝ</code> to denote some implementation (we don't care which one). And I don't mean having <code>{ℝ : Type} [RealInterface  ℝ] (x y z :  ℝ)</code></p>",
        "id": 202820420,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1593793710
    },
    {
        "content": "<p>The idea would be that <code>R</code> there is now a bundled type + real axioms, and so we would define <code>def ℝ := R.carrier</code> and so on</p>",
        "id": 202820486,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593793761
    },
    {
        "content": "<p>This is still just one type, we just don't know what type it is</p>",
        "id": 202820530,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593793792
    },
    {
        "content": "<p>Does it mean that coercions would be involved everytime we manipulate a real number?</p>",
        "id": 202820612,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1593793827
    },
    {
        "content": "<p>how so?</p>",
        "id": 202820624,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593793838
    },
    {
        "content": "<p>no more than currently</p>",
        "id": 202820630,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593793842
    },
    {
        "content": "<p>Ok, then I really don't understand what you mean.</p>",
        "id": 202820639,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1593793854
    },
    {
        "content": "<p>Since this <code>ℝ</code> type will be a complete ordered field you can write <code>2 : ℝ</code> as normal</p>",
        "id": 202820666,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593793872
    },
    {
        "content": "<p>the only thing that will be different is that you will not be able to prove theorems about <code>ℝ</code> by proving them about the underlying cauchy sequence representation</p>",
        "id": 202820797,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593793950
    },
    {
        "content": "<p>which we are already doing for the most part by making <code>real</code> irreducible</p>",
        "id": 202820839,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593793987
    },
    {
        "content": "<p>Ok, sounds good, especially if it allows us to finally switch to Bourbaki reals <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 202820841,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1593793988
    },
    {
        "content": "<p>The difference with lean 4's <code>constant</code> is that now there will be a literal meta theorem saying that you can swap out for dedekind cuts and nothing will break</p>",
        "id": 202820868,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593794026
    },
    {
        "content": "<p>So this will make it easier to apply polynomial theorems to our favorite super fast polynomial implementation or whatever?</p>",
        "id": 202821166,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1593794276
    },
    {
        "content": "<p>Nice</p>",
        "id": 202821249,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1593794358
    },
    {
        "content": "<p>Ah, I hadn't thought of that. Indeed, if there are any buggy lean tactics that don't take the hint when they see <code>irreducible</code>, <code>constant</code> will be able to block them before they waste too much time</p>",
        "id": 202821496,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593794587
    },
    {
        "content": "<p>At this point I should probably mention that <span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> and I are at least <em>considering</em> introducing a simple module system for Lean 4 (where module = file, not functors involved). It would allow you to view a <code>def</code> inside a file as a <code>constant</code> outside of it (by default or not? All details TBD). The main motivation is to drastically speed up recompilation while <em>programming</em> in Lean, but as discussed, hiding implementations can be useful while proving as well.</p>",
        "id": 202821947,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1593795017
    },
    {
        "content": "<p>I would recommend against tying file structure to this behavior. What about a <code>module</code> keyword that acts mostly like a section, but makes everything in the section <code>private</code>, then compile the module to a structure + an implementation of that structure as a <code>constant</code> + re-exporting the fields of that structure as theorems with the original chosen names</p>",
        "id": 202823234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593796233
    },
    {
        "content": "<p>(note in particular that this does not require any kernel changes)</p>",
        "id": 202823274,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593796268
    },
    {
        "content": "<p>I would be very happy if we could have a feature like Coq modules but with all the mess going through a \"module compiler\" so that there is no kernel impact</p>",
        "id": 202823402,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593796361
    },
    {
        "content": "<p>I'm not planning to change the kernel, this would be implemented in the import logic (which also means that we could drastically reduce the amount of data being imported). Autogenerating structures is not realistic when the majority of declarations in each file should be made opaque (at least for programming). Think of it as GHC's interface files produced for separate compilation.</p>",
        "id": 202823864,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1593796817
    },
    {
        "content": "<p>maybe a special variant of <code>import</code> that triggers this behavior?</p>",
        "id": 202824184,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593797120
    },
    {
        "content": "<p>I think in mathlib this would be a small minority of files, you can't just seal all defs</p>",
        "id": 202824203,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593797150
    },
    {
        "content": "<p>+1 for not tying this to files but introducing something like a <code>module</code> keyword.</p>",
        "id": 202824305,
        "sender_full_name": "Kevin Kappelmann",
        "timestamp": 1593797182
    },
    {
        "content": "<p>Yes, the default <code>import</code> would most likely be unchanged</p>",
        "id": 202824339,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1593797221
    },
    {
        "content": "<p>I will point out that Haskell also uses <code>module</code>, even though it's written once at the top of every file so it's easy to confuse with file based management</p>",
        "id": 202824356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593797246
    },
    {
        "content": "<p>Alternatively, this could be tied to some attribute of the definition. I imagine that most of the defs you want to apply this to are what lean 3 would call <code>meta def</code>s</p>",
        "id": 202824449,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593797308
    },
    {
        "content": "<p>congratulations, they aren't meta anymore, but that doesn't change the fact that you have no intention to prove any property about them. Maybe make that explicit by using <code>constant</code></p>",
        "id": 202824500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593797360
    },
    {
        "content": "<p>Do you have an example where you need a definition to be transparent in the file and opaque in the next file?</p>",
        "id": 202824601,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593797422
    },
    {
        "content": "<p>You mean apart from <code>real</code> etc? Well, maybe you still need it to be transparent in the next file, but at some point you want to seal it and that will most likely be at a file boundary.</p>",
        "id": 202824895,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1593797689
    },
    {
        "content": "<p>For programming you want every definition sealed unless you want it to be inlined or specialized</p>",
        "id": 202825041,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1593797874
    },
    {
        "content": "<p>In the case of <code>real</code> there is a well defined module boundary. I'm wondering about the programming case</p>",
        "id": 202832410,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593805357
    },
    {
        "content": "<p>Like you say, it seems like you want every definition sealed immediately, in which case there isn't really a reason to use <code>def</code> in the first place since <code>constant</code> already expresses this</p>",
        "id": 202832450,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593805402
    },
    {
        "content": "<p>Do you think you could achieve your performance goals by using <code>constant</code> everywhere and not changing <code>import</code> for big programming developments?</p>",
        "id": 202832549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593805496
    },
    {
        "content": "<p>Files are a relatively natural boundary for limiting interprocedural optimizations, especially during development (you rarely want to build such high-level languages completely without optimizations). For example, \"Without -O, GHC does inlining within a module, but no cross-module inlining.\".</p>",
        "id": 202874671,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1593870704
    },
    {
        "content": "<p>But I can see that the requirements for programming and proving might not be that similar here after all, so I'd be happy to see someone build a modules-as-structures system in Lean 4. That is more or less what we imagined a superior replacement for <code>parameter</code> could look like after all.</p>",
        "id": 202874862,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1593871004
    },
    {
        "content": "<p>Today, Kevin shared his thoughts about the traditional field axiom <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mi>x</mi><mn>0</mn></mfrac><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\"> \\frac x  0 = 0 </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.040392em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>:<br>\n<a href=\"https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/\">https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/</a></p>",
        "id": 202930392,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1593970091
    },
    {
        "content": "<p>Today we have <code>nnreal</code>s and can define <code>nnreal.sqrt</code> to be the \"mathematically correct\" square root. Then <code>a * b</code> will figure out <code>0 ≤ a * b</code> automatically.</p>",
        "id": 202931176,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593971576
    },
    {
        "content": "<p>You can't subtract them though :-)</p>",
        "id": 202932167,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593973212
    },
    {
        "content": "<p>For a while now <span class=\"user-mention\" data-user-id=\"110865\">@Jeremy Avigad</span> has been saying that formal theorem proving presents a unique opportunity for logicians and philosophers of mathematics.  Just like the early 1900s when logicians were starting to make formal vague terms like \"theorem\", \"proof\", and \"algorithm\", we have an opportunity to refine those ideas to fit practicing mathematics.  (The example Jeremy often used was that formally logicians say that a \"proof\" is a sequence or tree of statements with certain properties, but is that <em>really</em> how mathematicians think of a proof?)  I think this problem of partial functions is a great use case for Jeremy's proposed program.  When we say <code>a - b</code>, <code>a/b</code>, <code>sqrt a</code>, or the push forward of the probability measure <code>mu</code> under the map <code>f</code>, we have all these assumptions in mind.  Is there a formal logic (maybe very different from anything out there) that captures these statements and makes operations like rewriting seamless. Of course this new logic may only be an impossible pipe dream, but it doesn't seem beyond the realm of possibility.  (And if it does exist, it may have applications for programming language design as well, since dividing by zero or taking the 101th element of a list with only 100 elements can lead to bad errors in code.)</p>",
        "id": 202933039,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593974622
    },
    {
        "content": "<p>Also, if there is no such logic (or it is hard to find), because this is all related to the ambiguity of human language, then I hold out hope for soft tools like machine learning, especially neural based AI, which has shown itself to be good at working with incomplete and vague information.  An AI agent could realize that <code>a - b + b = a</code> is \"morally true\" (as I've heard mathematicians call it).  Then it could prove a lemma automatically by rewriting with that assumption, and then go back and \"dot all the i's and cross all the t's\" by proving the necessary assumptions needed to make the rewrites work.  Again, this may seem like a pipe dream, but I think the tools we have are making a lot of progress in that direction.</p>",
        "id": 202933461,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593975242
    },
    {
        "content": "<p>A proof is a solution of a level in a computer game</p>",
        "id": 202934011,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593976145
    },
    {
        "content": "<p>I agree with Kevin that this Lean's handling of division by zero isn't the most important issue facing formalized mathematics today, but mathematicians are right to show some concern. It would be disconcerting if it turned out that some important formalized theorem about perfectoid spaces turned out to be false when we change the value of 1/0. Right now, we don't have good ways of ensuring that won't happen, or even determining whether it is the case.</p>\n<p>There is a nice survey of logics for partial terms by Feferman: <a href=\"https://math.stanford.edu/~feferman/papers/definedness.pdf\">https://math.stanford.edu/~feferman/papers/definedness.pdf</a>. The best known implementation of a proof assistant that builds in partiality is Farmer's IMPS (<a href=\"https://link.springer.com/article/10.1007/BF00881906\">https://link.springer.com/article/10.1007/BF00881906</a>), but I can't speak for its usability.</p>\n<p>The two common ways of dealing partiality in a type theory involve either modifying the output type to take an undefined value (<code>option</code> or <code>roption</code>) or modifying the input type to restrict the valid inputs, with the condition bundled as a subtype or unbundled as a precondition. My preferred solution for division would be to have the fact that the denominator is nonzero is a precondition, one that is handled by automation so that we rarely think about it.</p>\n<p>It is sometimes not entirely clear what the mathematics should mean when we deal with partial functions. There are two ways of interpreting the statement \"f(x) -&gt; 0 as x -&gt; 0\" when f is partial, described here: <a href=\"https://math.stackexchange.com/questions/2883458/what-is-the-right-definition-of-the-limit-of-a-function/2883484#2883484\">https://math.stackexchange.com/questions/2883458/what-is-the-right-definition-of-the-limit-of-a-function/2883484#2883484</a>. A couple of years ago I generalized the <code>tendsto</code> relation to cover partial functions and multifunctions (<a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/partial.lean\">https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/partial.lean</a>), in the hopes that this would be useful for set-valued analysis. But I never got back to it.</p>",
        "id": 202977289,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1594034669
    },
    {
        "content": "<blockquote>\n<p>It would be disconcerting if it turned out that some important formalized theorem about perfectoid spaces turned out to be false when we change the value of 1/0. Right now, we don't have good ways of ensuring that won't happen, or even determining whether it is the case.</p>\n</blockquote>\n<p>Right now we're ok because I suspect that no theorem about perfectoid spaces will ever mention division. But for theorems about Banach spaces maybe life isn't so easy.</p>",
        "id": 202980163,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594037179
    },
    {
        "content": "<p>If the theorem mentions division it's always going to be quite easy to prove the statement about partial division given the statement about Lean's division. Maybe not I guess if it mentions division somewhere deep down.</p>",
        "id": 202980966,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1594037803
    },
    {
        "content": "<p>If a theorem which mathematicians are interested in mentions division then what you're dividing by won't be allowed to be zero, either by theorem or by (possibly unwritten) assumption.</p>\n<p>\"Does there exists a real number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>r</mi><mo>=</mo><mn>0</mn><mo stretchy=\"false\">?</mo></mrow><annotation encoding=\"application/x-tex\">1/r=0?</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mord\">/</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">?</span></span></span></span> is a good example. It's impossible to find a mathematician who will say \"yes\" to this, and they will have no complaints about the question being well-posed: we implicitly add the assumption that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo>≠</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">r\\not=0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mord\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> when parsing.</p>",
        "id": 202981326,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594038119
    },
    {
        "content": "<p>It's funny, right. Mathematicians have these promises that they will never do something wrong, hence you can swap out objects and replace them by canonically isomorphic ones...<br>\nBut if you do this with their field operation, all of a sudden they become very uneasy. It's an implementation detail, but we are getting very close to the boundary of where the \"promise\" still holds/works.</p>",
        "id": 202984390,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1594040123
    },
    {
        "content": "<blockquote>\n<p>The idiomatic way to do it is to allow garbage inputs like negative numbers into your square root function, and return garbage outputs. It is in the theorems where one puts the non-negativity hypotheses. </p>\n</blockquote>\n<p>Just out of curiosity, is the choice of garbage output unique (to make the function total)? Any particular reason to choose 0 except that it seems to be more \"neutral\" than other choices? When <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord\">∞</span></span></span></span> is available, should it be chosen because it's more \"extreme\" than zero?</p>\n<p>I asking this also because something inside me wishes the outputs of further operations on the garbage result are also garbage-ish. Maybe it's just part of the symptoms described in the last part of the post.</p>\n<p>The lesson learned here may be: one should not expect sanity from definitions (they should be allowed to be wild), instead the sanity lies in theorems and theorems only.</p>",
        "id": 202986440,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594041178
    },
    {
        "content": "<p>I guess the rule of thumb is that the garbage output should make as many theorems still true without the condition that the input not be garbage as possible, to reduce the proof obligations on the user later.<br>\nFor the square root of negative reals for example you might want that</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">real</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">sqrt</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">sqrt</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">sqrt</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>this isn't true without some additional assumption, but I believe if you send negatives to zero then you only need to assume one of a or b is nonnegative, but if you use any other fixed number as garbage then you'll need to assume both a and b are nonnegative for this to hold.<br>\nThe square root function is also still continuous with this definition, which might be nice.</p>",
        "id": 202987211,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1594041653
    },
    {
        "content": "<blockquote>\n<p>If a theorem which mathematicians are interested in mentions division then what you're dividing by won't be allowed to be zero, either by theorem or by (possibly unwritten) assumption.</p>\n</blockquote>\n<p>Exactly. So now you prove a theorem formally, and your mathematician friend wants to know: \"Why should I be interested in your theorem? I trust my own theorems because I know what they say. But I don't trust all your formal nonsense, especially when you tell me 1/0 = 0.\"</p>\n<p>Right now the best we can do for a formal sanity check is to find a formulation that doesn't mention division and then prove that it follows from your formal statement. But, as Chris says, when the theorem is built on top of definitions that use division all the way down, that's hard to do.</p>\n<p>To repeat: I don't think this is the most serious issue we are facing now. But it is a legitimate concern, and there should be better solutions.</p>",
        "id": 202996800,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1594045742
    },
    {
        "content": "<p>But the definitions don't have to avoid division, they just need to not rely on division by zero</p>",
        "id": 202996923,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594045802
    },
    {
        "content": "<p>Yes, but how can to determine that they don't?</p>",
        "id": 202997111,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1594045903
    },
    {
        "content": "<p>by looking at them</p>",
        "id": 202997133,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594045914
    },
    {
        "content": "<p>you have to do this anyway in order to verify the statement is what you expect</p>",
        "id": 202997196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594045930
    },
    {
        "content": "<p>Even where there are nontrivial modifications like <code>field</code>, you get a metatheorem like \"Let a Lean-field be a field with an operation <code>/'</code> that matches division away from zero and satisfies <code>a /' 0 = 0</code>. Then any theorem about Lean-fields using <code>/'</code> away from zero is also true of fields using division.\"</p>",
        "id": 202997543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046092
    },
    {
        "content": "<p>If sqrt(x) were defined to be sqrt(|x|) then <code>sqrt_mul</code> would be true unconditionally. I'm not the first person to observe this.</p>",
        "id": 202997566,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594046103
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/XenaProject.20blog.20posts/near/202997566\">said</a>:</p>\n<blockquote>\n<p>If sqrt(x) were defined to be sqrt(|x|) then <code>sqrt_mul</code> would be true unconditionally. I'm not the first person to observe this.</p>\n</blockquote>\n<p>I was thinking that when I wrote it, we did this for log right?</p>",
        "id": 202997662,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1594046157
    },
    {
        "content": "<p>FWIW I like <code>sqrt x = 0</code> for negative <code>x</code> because that's the real part of the square root function</p>",
        "id": 202997854,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046249
    },
    {
        "content": "<p>What does it mean to \"not rely on division by 0\"? If the definitions use our division, and our division takes a value when you divide by 0, the the definitions rely on division by 0. Some of the theorem <code>(x + y) / z</code> along the way do as well.</p>\n<p>Mathematicians can (in principle) say that division by 0 is undefined and that the theorems are nonetheless true with that understanding. That is patently false for some theorems in mathlib, and true for others. But how do you tell which is which?</p>",
        "id": 202998010,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1594046316
    },
    {
        "content": "<p>Any assumption that uses division in a statement needs appropriate quantifier bounds to ensure that the value doesn't matter</p>",
        "id": 202998111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046368
    },
    {
        "content": "<p>that is enough to eliminate a large fraction of spurious uses</p>",
        "id": 202998139,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046386
    },
    {
        "content": "<p>the use of theorems and proofs that use division by zero along the way doesn't matter, only whether the final theorem statement contains divisions not guarded by a quantifier bound</p>",
        "id": 202998344,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046487
    },
    {
        "content": "<p>Kevin's example <code>\\exists x, 1/x = 0</code> is obviously violating this condition, it has a division and no quantifier bound saying <code>x != 0</code></p>",
        "id": 202998473,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046550
    },
    {
        "content": "<p>Something like <code>\\exists x &gt; 1, 1 / x = 0</code>, even if the <code>/</code> is Lean-division, is okay because the division occurs in a context where <code>x != 0</code> is provable</p>",
        "id": 202998625,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046641
    },
    {
        "content": "<p>What does it mean to say a \"theorem about Lean-fields uses <code>/'</code> away from 0\", especially when there are definitions involved? You need some guarantee that when you unwrap all the definitions and quantifier bounds all the way down, you can prove that anything the division every gets applied to is nonzero. If you can do that, you may as well do an automatic translation to a version with a <code>/''</code> that has formal preconditions.</p>",
        "id": 202998832,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1594046737
    },
    {
        "content": "<p>If this quantifier bound condition were all there were to it, it would not be difficult to write a program to analyze the statement and determine if the condition is satisfied (or at least, produce a bunch of proof obligations that imply that the statement is okay)</p>",
        "id": 202998940,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046777
    },
    {
        "content": "<p>yes, just like that</p>",
        "id": 202998960,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046785
    },
    {
        "content": "<p>It gets harder when you have definitions that legitimately use division by zero, like <code>field</code></p>",
        "id": 202999023,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046824
    },
    {
        "content": "<p>here you have to track definedness conditions on the use of the new definition that imply that they are safe and propagate them (so other functions also become partial)</p>",
        "id": 202999090,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046876
    },
    {
        "content": "<blockquote>\n<p>If you can do that, you may as well do an automatic translation to a version with a /'' that has formal preconditions.</p>\n</blockquote>\n<p>I'm not sure what this translation would be though</p>",
        "id": 202999217,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046937
    },
    {
        "content": "<p>Maybe we could use an attribute to flag such definitions?</p>",
        "id": 202999222,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1594046939
    },
    {
        "content": "<p>It basically boils down to a definition that doesn't mean the same as what the mathematician thinks they mean</p>",
        "id": 202999404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594047045
    },
    {
        "content": "<p>But I think we have bigger fish to fry in this arena, for example <code>0 &lt; 0.1</code> being false</p>",
        "id": 202999442,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594047070
    },
    {
        "content": "<p>Exactly. It would be nice to have automation that does it.  It is easy to do in simple cases. When I first proved the prime number theorem in Isabelle many years ago, it said \"pi n * log n / n --&gt; 1\". In the definition of the limit of a sequence, n could be 0. It is pretty obvious that this doesn't break anything; for example, you can substitute \"n+1\" for \"n\" and the problem goes away. But I think it is reasonable for a mathematician to complain that an entire analysis library is built on top of division, with no sort of guarantee that it is being used correctly.</p>",
        "id": 202999498,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1594047111
    },
    {
        "content": "<p>You think / type faster than me. The \"Exactly\" referred to the statement that it would be nice if we could check all the implicit side conditions.</p>",
        "id": 202999640,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1594047182
    },
    {
        "content": "<p><code>0 &lt; 0.1</code> is false??? Is that because <code>0.1</code> is a natural number?</p>",
        "id": 202999737,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1594047231
    },
    {
        "content": "<p>yes</p>",
        "id": 202999744,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594047238
    },
    {
        "content": "<p>Of course it is...</p>",
        "id": 202999750,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1594047241
    },
    {
        "content": "<p>If it quacks like a duck...</p>",
        "id": 202999805,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1594047254
    },
    {
        "content": "<p>I think you need to look at the problem modularly, where you say \"does <code>log</code> match what I think natural log is?\" If you can do that for all the definitions, then you will have a good understanding of the visible theorem statement, and all you have to worry about is the explicit division in PNT</p>",
        "id": 202999815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594047261
    },
    {
        "content": "<p>That is, for each formal notion you work out what its mathematical meaning is, without presupposing that it is exactly the same as the math notion</p>",
        "id": 202999908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594047317
    },
    {
        "content": "<p>I often have to do this anyway if the formal statement uses some unfamiliar terminology</p>",
        "id": 202999978,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594047359
    },
    {
        "content": "<p>like I would probably look up <code>--&gt;</code> in that isabelle statement</p>",
        "id": 203000062,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594047391
    },
    {
        "content": "<p>I'm sure it means limit, but is it a limit over natural numbers? Real numbers? How does it handle partiality? These questions must be answered by looking at the formal definition</p>",
        "id": 203000163,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594047451
    },
    {
        "content": "<p>I don't think an automated tool can solve this problem because it is fundamentally about the difference between a formal object and an informal object (the meaning in the mathematician's head)</p>",
        "id": 203000413,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594047576
    },
    {
        "content": "<p>Given that this topic is about my blog posts, I may as well give you some stats. In the same week that Rob announced that there had been as much mathlib activity in 2020 as there had been in the whole of 2019 (I forget how he measured it, perhaps commits or lines of code), I made it to 42000 views on the blog, beating the 41000 views I got in all of 2019. I'll make it to 50K within the next few days I think. The general pattern seems to be that if I post something which either hacker news or reddit r/math or twitter likes, then I get 1000+ views per day for the next couple of days, e.g. the \"mathematics in type theory\" post from two weeks ago got 1000+ views for three days from Twitter and then 2000+ views for two days, when hacker news got excited about it. These sorts of posts seem to be the most popular ones -- where a general computer scientist or mathematician who doesn't know anything about Lean can at least read and understand the post and think \"hmm, I learnt something about how doing mathematics in type theory / Lean works from reading this\". </p>\n<p>I will repeat the offer I occasionally make -- if there is anyone out there who thinks they have something which will appeal to mathematics undergraduates who perhaps don't know anything about Lean (these are usually the people I'm thinking about when I write) or perhaps to a more general audience (e.g. people who read hacker news or r/math) then they should feel free to get in touch and propose writing a guest post. So far Chris Hughes is the only person who did this. Ideally the post will have some relation to mathematics, and will be more accurate than the kind of poorly researched nonsense I churn out.</p>",
        "id": 203013765,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594054332
    },
    {
        "content": "<p>Even more accurate than that? You're setting the bar too high.</p>",
        "id": 203026464,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1594061333
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/XenaProject.20blog.20posts/near/202999442\">said</a>:</p>\n<blockquote>\n<p>But I think we have bigger fish to fry in this arena, for example <code>0 &lt; 0.1</code> being false</p>\n</blockquote>\n<p>I'm in the mood for fish bbq: <a href=\"https://github.com/leanprover-community/lean/issues/381\">lean#381</a></p>",
        "id": 203031613,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1594064287
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> I don't think we got to a consensus whether this change is desirable.</p>",
        "id": 203031863,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1594064483
    },
    {
        "content": "<p>To be clear, this is more of an RFC.  I'm also not sure if it's a good idea, particularly given how unlikely it would be to have this in Lean 4.</p>",
        "id": 203031958,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1594064531
    },
    {
        "content": "<p>See discussion below this post for the discussion about this topic: <a href=\"#narrow/stream/113488-general/topic/37/near/202221745\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202221745</a></p>",
        "id": 203032049,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1594064596
    },
    {
        "content": "<p>I propose a truce between the \"it's obvious from the lemma statement whether division by 0 can arise\" camp and the \"it's subtle and mathematicians have reasons to worry\" camp. Since the proof of the pudding is in the eating, one should just have a division operator that carries a proof in addition to the current one and, for those statements where we care/worry about this, prove the lemma with that operator, reusing the lemma proved using the Lean division. That proof should be easy/trivial in most cases, notably those that have a guard. That's what I'd do if I were to base a math textbook on a Lean formalization.</p>",
        "id": 203034913,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1594066161
    },
    {
        "content": "<p>It would certainly make some mathematicians happy</p>",
        "id": 203035308,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594066407
    },
    {
        "content": "<p>I'm always surprised that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mi mathvariant=\"normal\">/</mi><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">x/0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mord\">/</span><span class=\"mord\">0</span></span></span></span> is such a contentious topic.  There is one good and canonical choice, namely the one which makes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><mo>⋅</mo></mrow><annotation encoding=\"application/x-tex\">1/\\cdot</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mord\">/</span><span class=\"mord\">⋅</span></span></span></span> a pseudo-inverse.  Extending structures and operations to have nicer properties is so basic it borders on being invisible.  Who would object to prove a property of integers by embedding them into the real numbers, even though it extends the division operation?  How is it any different to embed fields into simple meadows?  Meanwhile there are multiple reasonable ways to define <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>0</mn><mn>0</mn></msup></mrow><annotation encoding=\"application/x-tex\">0^0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span>, or what about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>log</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\log(-1)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>?</p>",
        "id": 203037473,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1594067658
    },
    {
        "content": "<p>What's a simple meadow?</p>",
        "id": 203039664,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1594068961
    },
    {
        "content": "<p>Found the <a href=\"https://math.stackexchange.com/questions/1186171/the-prime-meadow-of-a-meadow\">definition</a></p>",
        "id": 203040212,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1594069317
    },
    {
        "content": "<p>Meadow are like field if you replace the axioms for division by being a pseudo-inverse (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mi mathvariant=\"normal\">/</mi><mi>y</mi><mo stretchy=\"false\">)</mo><mi>y</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">(x/y)y = x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mord\">/</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span>).  Then they are a variety, in particular the smallest variety containing the fields.  (Every meadow is a direct product of fields.)</p>",
        "id": 203040522,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1594069486
    },
    {
        "content": "<p>Funnily enough, I first heard of meadows before I got involved with proof assistants.  But now after I am looking again at the paper that introduced them, I have to realize that they were motivated by formalization.</p>",
        "id": 203040805,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1594069664
    },
    {
        "content": "<p>The whole 1/0 topic is silly and the reason I wrote the blog post was precisely because mathematicians were asking about it on Twitter and I thought I should at least try and put down some coherent thoughts into one place so that I can refer people to it later. But now I'm getting people saying to me that the systems should adapt and make it work the way mathematicians are used to, and just do the type theory way behind the scenes</p>",
        "id": 203041709,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594070186
    },
    {
        "content": "<p>The axiom reminds me a lot of <a href=\"https://en.wikipedia.org/wiki/Von_Neumann_regular_ring\">von Neumann regular rings</a>, where for every <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> there is an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>=</mo><mi>x</mi><mi>a</mi><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x=xax</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">x</span></span></span></span>.  It's not just a von Neumann regular ring, though, since a meadow has an involutive map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>↦</mo><msup><mi>x</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">x \\mapsto x^{-1}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.522em;vertical-align:-0.011em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> that gives the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>.</p>",
        "id": 203041825,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1594070276
    },
    {
        "content": "<p>It seems like a classic bikeshedding problem. Everyone understands the question so you get an outsized number of complaints/suggestions</p>",
        "id": 203042075,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594070389
    },
    {
        "content": "<p>(Though it looks like commutative von Neumann regular rings have such an involution, so I guess I'm not sure whether meadows are any different from commutative von Neumann regular rings.  I like the name, though.)</p>",
        "id": 203042215,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1594070472
    },
    {
        "content": "<p>(By the way, if every Xena post generates this much discussion, one Zulip topic may not be enough)</p>",
        "id": 203042307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594070526
    },
    {
        "content": "<p>This one is now trending on Hacker news so I'm getting 500 views an hour.</p>",
        "id": 203045358,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594072512
    },
    {
        "content": "<p>And it's about such a ridiculous subject!</p>",
        "id": 203045365,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594072522
    },
    {
        "content": "<p>(Here's a fun fact to justify the color of Lean's bikeshed.  The class of <a href=\"https://en.wikipedia.org/wiki/ELEMENTARY\">elementary recursive functions</a> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi><mo>→</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}\\to\\mathbb{N}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span></span></span> can be given as expressions involving only the variable, <code>nat.add</code>, <code>nat.sub</code>, <code>nat.div</code>, and <code>nat.pow</code> as Lean defines them.)</p>",
        "id": 203046144,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1594073019
    },
    {
        "content": "<p>That is a good point about bike shedding.  I’ll try to be more careful in the future.</p>",
        "id": 203057722,
        "sender_full_name": "Jason Rute",
        "timestamp": 1594083136
    },
    {
        "content": "<p>I was just experimenting with a way to hide domain hypotheses inside equations.  I'm sure others have tried something like this before.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">safe_minus</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span>\n\n<span class=\"n\">reserve</span> <span class=\"kn\">infixl</span> <span class=\"bp\">`</span> <span class=\"bp\">-!</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">65</span>\n\n<span class=\"kn\">notation</span> <span class=\"n\">x</span> <span class=\"bp\">`</span> <span class=\"bp\">-!</span> <span class=\"bp\">`</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">safe_minus</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">linarith</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">-!</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>   <span class=\"c1\">-- Lean can figure out this is OK</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">dunfold</span> <span class=\"n\">safe_minus</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">-!</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>   <span class=\"c1\">-- if you remove the h hypothesis, Lean will complain</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">exact</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">sub_add_cancel</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 203222590,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1594172007
    },
    {
        "content": "<p>Yup, it's really cool when it works, but when it breaks it's a pain (at least in lean).<br>\nI do think there is potential for something like this. However, I have don't have a good idea how to treat <code>-!</code> when <code>linarith</code> fails. Is the fallback scenario simply that the user must write</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">foobar</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"k\">proof</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">safe_sub_add_cancel</span><span class=\"o\">,</span> <span class=\"c1\">-- now linarith can figure it out</span>\n</code></pre></div>",
        "id": 203230964,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1594183457
    },
    {
        "content": "<p>LFTCM post mortem: <a href=\"https://xenaproject.wordpress.com/2020/07/17/lean-for-the-curious-mathematician-2020/\">https://xenaproject.wordpress.com/2020/07/17/lean-for-the-curious-mathematician-2020/</a></p>",
        "id": 204466693,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595274057
    },
    {
        "content": "<blockquote>\n<p>Johannes Hoelzl, a very experienced formaliser, told me that in his opinion porting mathlib from Lean 3 to Lean 4 whilst simultaneously refactoring it would be a bad idea.</p>\n</blockquote>\n<p>I fully agree with Johannes. A basic principle of programming is to start with a program that works (e.g. <code>int main() { return 0; }</code>) and do the smallest change possible so that the program still works. And indeed, that's pretty much what Kevin suggests when he points out that it's good to have a syntactically correct proof at (almost) all times. Porting is a very big step, but one should aim at keeping it as small as possible. Refactoring can be done in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> iterations afterwards. Doing both together, in the best of cased, might save some work; but it makes the worst case (the whole thing going off tracks) much more likely.</p>",
        "id": 204514809,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1595311487
    },
    {
        "content": "<p>This was a fun read: <a href=\"https://xenaproject.wordpress.com/2020/07/23/two-types-of-universe-for-two-types-of-mathematician/\">https://xenaproject.wordpress.com/2020/07/23/two-types-of-universe-for-two-types-of-mathematician/</a></p>",
        "id": 204912494,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595596003
    },
    {
        "content": "<p>I might split that post into two, I'm not sure. I think the link between Gowers' two kinds of mathematician and Prop v Type is interesting but I also think it's interesting that the mathlib commiters are a bunch of random people from different departments and ranging from undergraduates to professors</p>",
        "id": 204921726,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595600754
    },
    {
        "content": "<p>I was just knocking something up quickly so that the quanta guy had something to read</p>",
        "id": 204921826,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595600796
    },
    {
        "content": "<p>(I was interviewed by someone from Quanta yesterday, who will be writing a piece on computer proof systems in a couple of weeks). But I really rushed that post</p>",
        "id": 204921928,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595600844
    },
    {
        "content": "<p>I just realized I'm the only contributor with a net negative number of lines contributed to mathlib.</p>",
        "id": 204982920,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1595642740
    },
    {
        "content": "<p>We need some appropriate efficiency measure.</p>",
        "id": 204983067,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595642965
    },
    {
        "content": "<p>IMO the real metric should be something like lines of comments minus lines of code</p>",
        "id": 204983138,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595643059
    },
    {
        "content": "<p>Each tactic should have a running total of the number of lines of proof that were saved through its use.</p>",
        "id": 204983341,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1595643352
    },
    {
        "content": "<p><a href=\"https://xenaproject.wordpress.com/2020/09/19/thoughts-on-the-pythagorean-theorem/\">https://xenaproject.wordpress.com/2020/09/19/thoughts-on-the-pythagorean-theorem/</a></p>\n<blockquote>\n<p>And then there is the proof, which originally is either due to Pythagoras or not depending on who you believe.</p>\n</blockquote>\n<p>That's LEM, right there...</p>",
        "id": 210625798,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1600536618
    },
    {
        "content": "<p><a href=\"https://xenaproject.wordpress.com/2020/12/05/liquid-tensor-experiment/\">https://xenaproject.wordpress.com/2020/12/05/liquid-tensor-experiment/</a></p>",
        "id": 218956351,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1607206826
    },
    {
        "content": "<blockquote>\n<p>This is a guest post, written by Peter Scholze, explaining a liquid real vector space mathematical formalisation challenge.</p>\n</blockquote>",
        "id": 218956432,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1607206996
    },
    {
        "content": "<p>What's the appropriate emoji for \"solid\"? <span aria-label=\"black large square\" class=\"emoji emoji-2b1b\" role=\"img\" title=\"black large square\">:black_large_square:</span> ?</p>",
        "id": 218957284,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607208022
    },
    {
        "content": "<p>Is <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> ready to coordinate this ? <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span></p>",
        "id": 218957508,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607208416
    },
    {
        "content": "<p>i find section 6 to be especially interesting, which provides context for the motivation of the challenge</p>",
        "id": 218957785,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1607208901
    },
    {
        "content": "<p>Yes, this Section 6 comes a bit late, maybe Kevin should warn readers who fear the pure math part they can skip to that section.</p>",
        "id": 218957837,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607208976
    },
    {
        "content": "<p>Although people should make sure not to miss Example 2.3 if they think they understand decimal expansions of real numbers.</p>",
        "id": 218957860,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607209072
    },
    {
        "content": "<blockquote>\n<p>secretly, in high school we learn to think of the interval as a quotient of a profinite set.</p>\n</blockquote>\n<p><span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 218958181,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1607209615
    },
    {
        "content": "<p>I'm guessing the recent <a href=\"https://github.com/leanprover-community/mathlib/issues/5147\">#5147</a> was motivated by this (or condensed math in general)? Is there a roadmap or a list of some other milestones for this project?</p>",
        "id": 218959145,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1607211253
    },
    {
        "content": "<p>Good question! I guess I have been thinking about proving some basic condensed sets stuff, but at some point I'm going to have to understand more of the content of the post. We had a study group on the condensed stuff at Imperial and I think several others on this chat have done as well.</p>",
        "id": 218960468,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607213588
    },
    {
        "content": "<p>I think getting small sheaves, rather than all sheaves is a good goal regardless of this challenge. I vaguely recall it being mentioned before, but no idea where.</p>",
        "id": 218960516,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1607213660
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/XenaProject.20blog.20posts/near/218957837\">said</a>:</p>\n<blockquote>\n<p>Yes, this Section 6 comes a bit late, maybe Kevin should warn readers who fear the pure math part they can skip to that section.</p>\n</blockquote>\n<p>I added a sentence to my introduction.</p>",
        "id": 218961937,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607216279
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130272\">David Michael Roberts</span> <a href=\"#narrow/stream/113488-general/topic/XenaProject.20blog.20posts/near/218960516\">said</a>:</p>\n<blockquote>\n<p>I think getting small sheaves, rather than all sheaves is a good goal regardless of this challenge. I vaguely recall it being mentioned before, but no idea where.</p>\n</blockquote>\n<p>There is a big design decision to be made here. Do we just consider profinite sets in <code>Type</code> and sheaves on these sets, which will I guess live in <code>Type 1</code>, or do we do all the cardinality hoop-jumping to prove that it all descends nicely? Scholze outlines the details of how to avoid universe-bumping in <a href=\"http://www.math.uni-bonn.de/people/scholze/Condensed.pdf\">lecture 1 of condensed.pdf</a> (compare for example Definition 1.2 of a condensed set, and then remarks 1.3 and 1.4, where a modified \"correct\" definition is made). </p>\n<p>But there is a counterpoint to David's point here. In R. Hamming's <a href=\"https://www.imsc.res.in/~sitabhra/teaching/mm12/hamming_unreasonable_effectiveness.pdf\">The unreasonable effectiveness of mathematics</a> he emphasizes (in a big box on page 86!) <strong>The Postulates of Mathematics Were Not on the Stone Tablets that Moses Brought Down from Mt. Sinai.</strong> He is arguing that fixating on one particular set of axioms (like ZFC) might hinder rather than help mathematics, and \"we should be prepared to change postulates when the need becomes apparent\". I was talking to Reid about whether we should worry about all these cardinality bounds and he observed that there was a saying in computer science \"Build one to throw away\". Thus one approach could be just to ignore these things for now, and worry about them later. Note that Grothendieck took this approach in SGA4 -- he assumed the existence of universes so he could push on with his study of topoi, and then other people did the necessary contortions afterwards to force the theory of etale cohomology and hence the proof of the Weil conjectures back into ZFC.</p>",
        "id": 218962316,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607216969
    },
    {
        "content": "<p>Heh, let it be known that it is a theorem that ZFC is overkill for étale cohomology.</p>",
        "id": 218962855,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1607217953
    },
    {
        "content": "<p>I suspect that if one is reasonably careful no universe bumping is needed at all, even temporarily. But this is, as you say, a design decision.</p>",
        "id": 218962906,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1607218009
    },
    {
        "content": "<blockquote>\n<p>We will then define the category of condensed sets as the (large) colimit of the category of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span>-condensed sets along the  filtered poset of all uncountable strong limit cardinals <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span> (from Condensed.pdf)</p>\n</blockquote>\n<p>well, for a start, this is much better than working with a general filtered poset [sic], it's a well-ordered class, hence linearly ordered. So one can just (!) take the union with no extra identifications of objects or morphisms, as the inclusions are fully faithful. Objects of the category of condensed sets are pairs consisting of a strong limit cardinal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span> (the uncountability is moot) and an appropriate sheaf. A morphism  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>κ</mi><mo separator=\"true\">,</mo><mi>F</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mo stretchy=\"false\">(</mo><mi>λ</mi><mo separator=\"true\">,</mo><mi>G</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\kappa,F) \\to (\\lambda,G)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">κ</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">λ</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">)</span></span></span></span> consists of a map of sheaves where we have extend the smaller of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> to the site of profinite sets of size <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo><mrow><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">x</mi></mrow><mo stretchy=\"false\">{</mo><mi>κ</mi><mo separator=\"true\">,</mo><mi>λ</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\leq\\mathrm{max}\\{\\kappa,\\lambda\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">a</span><span class=\"mord mathrm\">x</span></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">κ</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">λ</span><span class=\"mclose\">}</span></span></span></span>.</p>\n<p>In particular, this is not just a universe-bumping issue, since even allowing ourselves universes, this is not the same thing as sheaves on the large site of all profinite sets. The proposal</p>\n<blockquote>\n<p>Do we just consider profinite sets in <code>Type</code> and sheaves on these sets, which will I guess live in <code>Type 1</code></p>\n</blockquote>\n<p>is the pyknotic approach.</p>",
        "id": 218963784,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1607219759
    },
    {
        "content": "<p>And, now that I think about it, I'm not sure that strong limit cardinals need to be singled out here at all as far as constructing the category of condensed sets goes. The only thing that is needed is that every cardinal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\mu</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">μ</span></span></span></span> is has a strong limit cardinal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span> above it, so that every sheaf on <em>any</em> small category of profinite sets (bounded above in size by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\mu</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">μ</span></span></span></span>), extends to a sheaf on a category of profinite sets of size up to but below <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span>. This should hopefully be enough to access the nice properties that the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span> s afford.</p>\n<p>This means the definition of a condensed set is even easier: it consists of a pair <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>μ</mi><mo separator=\"true\">,</mo><mi>F</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\mu,F)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">μ</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mclose\">)</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\mu</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">μ</span></span></span></span> is an arbitrary cardinal and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> is a sheaf on the site of profinite sets smaller than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\mu</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">μ</span></span></span></span>.</p>\n<p>Proving any particular topological space/abelian group/vector space is a condensed set/abelian group/vector space  would then be a matter of picking an appropriate <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\mu</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">μ</span></span></span></span>, for instance something a few powersets above the size of the space/abelian group/vector space. Just enough to get a cover from a profinite set to the space etc. Once one has <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\mu</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">μ</span></span></span></span>, then knowing continuous maps to a space form a sheaf should do.</p>",
        "id": 218964146,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1607220469
    },
    {
        "content": "<p>This seems amenable to an abstract framework, at least as a definition. Of course, proving things about this is less easy, but one can only try it and see. The definition of sheaf on (bounded in size) profinite sets is, mercifully, less complicated than for general spaces!</p>",
        "id": 218964257,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1607220652
    },
    {
        "content": "<p>This is a situation where things easily expressable in set theory don't match up well with things easily expressible in type theory</p>",
        "id": 218964925,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607222038
    },
    {
        "content": "<p>Even having a small category of \"sets of cardinality <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">&lt; \\kappa</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span>\" is not that simple, and it's worse if you want it to have (say) finite limits and colimits</p>",
        "id": 218964970,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607222076
    },
    {
        "content": "<p>It almost seems easier to represent just the small sheaves as formal colimits, and then try to compute the correct Hom sets between them somehow.</p>",
        "id": 218965101,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607222384
    },
    {
        "content": "<p>That's why we have universes, I think.</p>",
        "id": 218965199,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1607222548
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>  hmm, you're right. I guess essentially small doesn't quite cut it...</p>",
        "id": 218970756,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1607233252
    },
    {
        "content": "<p>I <a href=\"#narrow/stream/113488-general/topic/XenaProject.20blog.20posts/near/218964146\">said</a>:</p>\n<blockquote>\n<p>And, now that I think about it, I'm not sure that strong limit cardinals need to be singled out here at all as far as constructing the category of condensed sets goes. The only thing that is needed is that every cardinal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\mu</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">μ</span></span></span></span> is has a strong limit cardinal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span> above it, so that every sheaf on <em>any</em> small category of profinite sets (bounded above in size by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\mu</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">μ</span></span></span></span>), extends to a sheaf on a category of profinite sets of size up to but below <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span>. This should hopefully be enough to access the nice properties that the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span> s afford.</p>\n<p>This means the definition of a condensed set is even easier: it consists of a pair <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>μ</mi><mo separator=\"true\">,</mo><mi>F</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\mu,F)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">μ</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mclose\">)</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\mu</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">μ</span></span></span></span> is an arbitrary cardinal and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> is a sheaf on the site of profinite sets smaller than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\mu</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">μ</span></span></span></span>.</p>\n</blockquote>\n<p>OK, so Peter S <a href=\"https://mathoverflow.net/questions/378261/why-strong-limit-cardinals-in-the-definition-of-condensed-sets?noredirect=1#comment959960_378261\">confirmed my guess</a> over on MathOverflow. The issue is only about proving nice stability properties of each topos (sheaves on the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span>-proétale site) in the large diagram whose colimit is  the category of condensed sets.</p>",
        "id": 219074336,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1607344791
    },
    {
        "content": "<p>But since this is not helping with actual formalisation I'll pipe down, now.</p>",
        "id": 219074400,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1607344810
    },
    {
        "content": "<p><a href=\"https://xenaproject.wordpress.com/2021/01/09/the-end-of-the-summer/\">The end of summer</a></p>\n<blockquote>\n<p>So, what’s been happening? Well, the Lean 4 developers told us in mid-June that Lean 4 would be released at “the end of the summer“. And on Monday Lean 4 got released! The corollary is that it’s the end of the summer now, so it must finally be time to talk about the summer projects, and some of the things which happened since then.</p>\n</blockquote>",
        "id": 222194495,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1610234189
    },
    {
        "content": "<p>It's great to hear about some of the projects done in the Discord server. I hope more of the users there will share their work here (and maybe make some PRs to mathlib)!</p>",
        "id": 222195069,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1610235144
    },
    {
        "content": "<p>The reason I've not written a blog post for months is that I always felt that the next one I should write should be about the summer projects and that would involve trying to figure out some of the things worth mentioning, which took a while today. I'm half way through the next post now, my thoughts on LT2021.</p>\n<p>Some kids are really not into the Zulip. These are people who use Discord under a pseudonym and aren't scared to ask stupid questions there. They have this perception that Zulip is where the experts hang out so it's not really for them yet. On the other hand we have a healthy culture of people asking questions on the discord now and other students answering, as well as a healthy dose of people working on harder stuff like category theory (Bhavik is a regular there, he has become our resident category theory expert, which is wonderful).</p>",
        "id": 222195450,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610235873
    },
    {
        "content": "<p>A bunch of recent graph theory stuff (some of which has been PR'ed) was created in live streams on the Discord with people like Alena coding and people like Bhavik and Shing watching.</p>",
        "id": 222195645,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610236209
    },
    {
        "content": "<p>I'm glad there are alternative spaces for students who might feel more comfortable with a different crowd. But I do hope at least some of the fun things they're doing make it to the rest of us!</p>",
        "id": 222195732,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1610236378
    },
    {
        "content": "<p>The goofy stuff with the widgets seems to be a discord thing, which is a shame, because widgets are really fun! Angela Li (who disappears during term time and appears in the vacation) has been looking at <a href=\"https://www.chiark.greenend.org.uk/~sgtatham/puzzles/\">Simon Tatham's puzzle games</a>. I know these games very well. In 2017 before I got into Lean the Android app of these puzzle games was the only game I had installed on my phone, and before I was Lean-competent I was offering MSc projects to prove that various of these games were PSPACE-complete or whatever.</p>",
        "id": 222195901,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610236666
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/stream/113488-general/topic/XenaProject.20blog.20posts/near/222195732\">said</a>:</p>\n<blockquote>\n<p>I'm glad there are alternative spaces for students who might feel more comfortable with a different crowd. But I do hope at least some of the fun things they're doing make it to the rest of us!</p>\n</blockquote>\n<p>We try to encourage people to ask questions and post here too!</p>",
        "id": 222196946,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1610238277
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/XenaProject.20blog.20posts/near/222195450\">said</a>:</p>\n<blockquote>\n<p>These are people who use Discord under a pseudonym and aren't scared to ask stupid questions there. </p>\n</blockquote>\n<p>Perhaps they might come here but with a fantasy name. Using <a href=\"https://www.fantasynamegenerators.com/video-game-names.php\">Fantasy Name Generator</a> at the top click <code>Real Names</code> and then pick a specialization. If they do this they should stick with one name and not use a new name each time. </p>\n<hr>\n<p>One downside that I find with <code>Discord</code> is that searching for something is not easy. While I have not used <code>Zulip</code> much I do use <code>Discourse</code> daily and find that searching for info with in <code>Discourse</code> is much more effective.</p>",
        "id": 222215568,
        "sender_full_name": "EricGT",
        "timestamp": 1610273627
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366057\">EricGT</span> <a href=\"#narrow/stream/113488-general/topic/XenaProject.20blog.20posts/near/222215568\">said</a>:</p>\n<blockquote>\n<p>Perhaps they might come here but with a fantasy name. Using <a href=\"https://www.fantasynamegenerators.com/video-game-names.php\">Fantasy Name Generator</a> at the top click <code>Real Names</code> and then pick a specialization. If they do this they should stick with one name and not use a new name each time. </p>\n</blockquote>\n<p>We strongly discourage this. Real names are simply much much more convenient. Even people GitHub pseudonyms are annoying.</p>",
        "id": 222215893,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1610274248
    },
    {
        "content": "<p>Whenever someone on the Discord suggests asking on Zulip I always tell them to use their real name. Right now it's like mathoverflow with most people doing this but not all, but I definitely agree with Patrick that real names are better here</p>",
        "id": 222216273,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610274990
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/XenaProject.20blog.20posts/near/222215893\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"366057\">EricGT</span> <a href=\"#narrow/stream/113488-general/topic/XenaProject.20blog.20posts/near/222215568\">said</a>:</p>\n<blockquote>\n<p>Perhaps they might come here but with a fantasy name. Using <a href=\"https://www.fantasynamegenerators.com/video-game-names.php\">Fantasy Name Generator</a> at the top click <code>Real Names</code> and then pick a specialization. If they do this they should stick with one name and not use a new name each time. </p>\n</blockquote>\n<p>We strongly discourage this. Real names are simply much much more convenient. Even people GitHub pseudonyms are annoying.</p>\n</blockquote>\n<p>I would agree that using false names here should be discouraged. However the use of separate sites doing the same IMHO feels like the start of a division in the community.</p>\n<p>In other words, is there a way to get the users that are afraid to ask questions here to ask them here? I know this is not a problem unique to this site, idea, etc. </p>\n<p>Personally I would like to see such questions and replies being a beginner myself trying to learn LEAN starting with LEAN 4.</p>",
        "id": 222217938,
        "sender_full_name": "EricGT",
        "timestamp": 1610277816
    },
    {
        "content": "<p>I would guess that whatever it is that makes people afraid to ask questions here has little to do with usage of real names. If we're talking unconfident undergraduates, generally it isn't a problem to use real names but they might feel they are \"imposing\" by asking questions. The folks who deliberately avoid using their real name either do it by habit from other parts of the internet or have a strong information privacy mentality</p>",
        "id": 222220064,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610281691
    },
    {
        "content": "<p>The latter type are just as likely to balk at the need to sign up for an account to get into zulip in the first place</p>",
        "id": 222220079,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610281763
    },
    {
        "content": "<p><a href=\"https://xenaproject.wordpress.com/2021/04/03/induction-and-inductive-types/\">Induction, and inductive types</a></p>\n<p><a href=\"https://xenaproject.wordpress.com/2021/04/18/induction-on-equality/\">Induction on equality</a></p>",
        "id": 235092473,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1618772356
    },
    {
        "content": "<p><a href=\"https://xenaproject.wordpress.com/2021/06/05/half-a-year-of-the-liquid-tensor-experiment-amazing-developments/\">Half a year of the Liquid Tensor Experiment: Amazing developments</a> (guest post by Peter Scholze)</p>",
        "id": 241639347,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1622903386
    },
    {
        "content": "<p><a href=\"https://news.ycombinator.com/item?id=27405693\">https://news.ycombinator.com/item?id=27405693</a></p>",
        "id": 241648609,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622916206
    },
    {
        "content": "<p>How long before it hits the front page of HN?</p>",
        "id": 241648820,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1622916404
    },
    {
        "content": "<p>I think it's a bit mathsy for hacker news</p>",
        "id": 241649685,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622917373
    },
    {
        "content": "<p>also on Reddit! <a href=\"https://www.reddit.com/r/math/comments/nsyebd/half_a_year_of_the_liquid_tensor_experiment/\">https://www.reddit.com/r/math/comments/nsyebd/half_a_year_of_the_liquid_tensor_experiment/</a></p>",
        "id": 241651170,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1622919295
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/XenaProject.20blog.20posts/near/241649685\">said</a>:</p>\n<blockquote>\n<p>I think it's a bit mathsy for hacker news</p>\n</blockquote>\n<p>I think with the right title it might be popular on HN, but the current one is certainly not sensationalist enough :)</p>",
        "id": 241651590,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1622919797
    },
    {
        "content": "<p><a href=\"https://xenaproject.wordpress.com/2022/07/29/teaching-formalisation-to-mathematics-undergraduates/\">Teaching formalisation to mathematics undergraduates</a></p>",
        "id": 291408458,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1659158744
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284997\">@Zhangir Azerbayev</span> 's post about <a href=\"https://xenaproject.wordpress.com/2022/08/16/the-future-of-interactive-theorem-proving/\">Lean Chat</a> on my blog is getting some traction on <a href=\"https://news.ycombinator.com/item?id=32489099\">Hacker news</a> if people want to vote it up...</p>",
        "id": 293813742,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660690512
    }
]
[
    {
        "content": "<p>I defined a presheaf like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">presheaf_of_types</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">⊆</span> <span class=\"n\">U</span><span class=\"o\">),</span> <span class=\"n\">F</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">U</span><span class=\"o\">),</span> <span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">comp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hUV</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">⊆</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hVW</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"err\">⊆</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">U</span><span class=\"o\">),</span>\n  <span class=\"n\">res</span> <span class=\"n\">hVW</span> <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"n\">hUV</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">hVW</span> <span class=\"n\">hUV</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>I had to make a call about the target of <code>presheaf_of_types.F</code>. I went for the same universe as X, because I have this vaguely uncomfortable feeling about having universes in my structures which are not extractable from the input data.</p>\n<p>I now realise that I can't define pushforwards of presheaves along continuous maps, at least continuous maps X -&gt; Y where X is in universe u1 and Y in universe u2.</p>\n<p>There are lots of solutions to this. </p>\n<p>1) Let F take values in universe v (and then feed in v manually later)<br>\n2) Restrict the theory to continuous maps X -&gt; Y living in universe u<br>\n3) Openly question this whole universe polymorphism stuff and let everything take values in Type.</p>\n<p>I developed a bunch of the schemes repo over Type and never had any problems.</p>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> any comments?</p>",
        "id": 162501867,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554363389
    },
    {
        "content": "<p>I should stress that I spent 25 years doing research whilst living in Type and I never had any problems.</p>",
        "id": 162501889,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554363419
    },
    {
        "content": "<p>I will tentatively recommend that you restrict the theory to continuous maps in Type u</p>",
        "id": 162501985,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554363523
    },
    {
        "content": "<p>If I bundle everything, and I'm going to try, then I feel like I'll be spending my life feeding universes into things anyway. It seems to me that (2) is a cop-out, I am either polymorphic or I am not, and (2) seems like a half way house that will satisfy nobody. I am unclear about the dangers of (1). Is it simply that I have to just put {u v} in a few places?</p>",
        "id": 162501998,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554363535
    },
    {
        "content": "<p>and we will see if an issue arises later</p>",
        "id": 162501999,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554363538
    },
    {
        "content": "<p>So you are (1)-averse?</p>",
        "id": 162502014,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554363561
    },
    {
        "content": "<p>(1) will cause you to put .{u v} in lots of places</p>",
        "id": 162502020,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554363579
    },
    {
        "content": "<p>Keep in mind that Scott convinced me on the equiv thread in #maths to try bundling.</p>",
        "id": 162502022,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554363582
    },
    {
        "content": "<p>I think the friction isn't worth it to you</p>",
        "id": 162502024,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554363588
    },
    {
        "content": "<p>If the friction isn't worth it then you're telling me I should use (3)</p>",
        "id": 162502081,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554363607
    },
    {
        "content": "<p>(2) is about as good as (3) in terms of \"don't worry about it\" ism</p>",
        "id": 162502093,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554363650
    },
    {
        "content": "<p>Or are you saying the philosophy is that I should be as polymorphic as possible whilst avoiding at all costs the pain of having to annotate my universes?</p>",
        "id": 162502094,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554363651
    },
    {
        "content": "<p>There are still ways to recover maps between different universes with (2), but they are more cumbersome</p>",
        "id": 162502115,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554363704
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> if I were approaching these definitions with bundling and categories in mind (I want to define an equiv of presheaves of types) then what would your choice be?</p>",
        "id": 162502164,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554363724
    },
    {
        "content": "<p>and that seems like a reasonable tradeoff: make additional universes cumbersome in order to make the common case nicer</p>",
        "id": 162502169,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554363736
    },
    {
        "content": "<p>if indeed everything is in Type eventually then this shouldn't ever happen anyway</p>",
        "id": 162502174,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554363765
    },
    {
        "content": "<p>Grothendieck would have just observed that (1) and (2) were the same because you can just move to a bigger universe</p>",
        "id": 162502185,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554363777
    },
    {
        "content": "<p>That's what I mean</p>",
        "id": 162502195,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554363787
    },
    {
        "content": "<p>but I have no experience of the pain that this would involve in Lean</p>",
        "id": 162502196,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554363794
    },
    {
        "content": "<p>and I am pain averse</p>",
        "id": 162502197,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554363800
    },
    {
        "content": "<p>you have to use <code>ulift</code></p>",
        "id": 162502199,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554363801
    },
    {
        "content": "<p>ulift is a closed book to me</p>",
        "id": 162502206,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554363811
    },
    {
        "content": "<p>it's a universe shifting function that preserves all structure</p>",
        "id": 162502214,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554363833
    },
    {
        "content": "<p>I thought Reid's comment was telling in the other thread -- he stuck to Type because he could not be bothered to ulift the reals</p>",
        "id": 162502216,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554363838
    },
    {
        "content": "<p>is it canonical?</p>",
        "id": 162502267,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554363857
    },
    {
        "content": "<p>ah, there is that</p>",
        "id": 162502268,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554363857
    },
    {
        "content": "<p>Fortunately the valuations I have on my stalks are not real-valued</p>",
        "id": 162502274,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554363874
    },
    {
        "content": "<p>sure it's canonical</p>",
        "id": 162502275,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554363875
    },
    {
        "content": "<p>it's like the canonical injection map</p>",
        "id": 162502286,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554363892
    },
    {
        "content": "<p>they are taking values in a totally ordered monoid</p>",
        "id": 162502287,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554363893
    },
    {
        "content": "<p>I love that I managed to get you to say canonical</p>",
        "id": 162502293,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554363904
    },
    {
        "content": "<p>in ZFC it is just inclusion</p>",
        "id": 162502298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554363907
    },
    {
        "content": "<p>when neither of us know what it means</p>",
        "id": 162502304,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554363922
    },
    {
        "content": "<p>that's just how it works in maths too</p>",
        "id": 162502313,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554363934
    },
    {
        "content": "<p>it's canonical in lean because it's a function :P</p>",
        "id": 162502318,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554363946
    },
    {
        "content": "<p>we sagely nod and agree that it's canonical</p>",
        "id": 162502323,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554363957
    },
    {
        "content": "<p>is it functorial?</p>",
        "id": 162502369,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554363970
    },
    {
        "content": "<p>yep, it is all the things</p>",
        "id": 162502376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554363978
    },
    {
        "content": "<p>I don't know why people are so afraid of it then</p>",
        "id": 162502393,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554364013
    },
    {
        "content": "<p>it's also a thing</p>",
        "id": 162502396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554364019
    },
    {
        "content": "<p>which is one more than no thing</p>",
        "id": 162502407,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554364026
    },
    {
        "content": "<p>You can look forward to the \"ulift hell\" thread</p>",
        "id": 162502409,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554364029
    },
    {
        "content": "<p>Thanks for the comments. Scott, I'd be interested to hear yours.</p>",
        "id": 162502429,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554364056
    },
    {
        "content": "<p>I guess one final observation is that I have now coded up presheaves of types twice (once for schemes, once for this), Ramon coded it up for Schemes Reloaded, Johan did it, probably Scott did it, and somehow it's still not in mathlib. Maybe it's time someone PR'ed it...</p>",
        "id": 162502530,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554364188
    },
    {
        "content": "<p>Ok, per request, I PR'd <a href=\"https://github.com/leanprover-community/mathlib/pull/886\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/pull/886\">one version of (bundled) presheaves</a>. The definition is I hope inarguably the correct one. :-)</p>",
        "id": 162523639,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554383830
    },
    {
        "content": "<p>The essential definitions are:</p>\n<div class=\"codehilite\"><pre><span></span>structure Presheaf :=\n(X : Top.{v})\n(𝒪 : (opens X)ᵒᵖ ⥤ C)\n\nstructure Presheaf_hom (F G : Presheaf.{v} C) :=\n(f : F.X ⟶ G.X)\n(c : G.𝒪 ⟹ ((opens.map f).op ⋙ F.𝒪))\n</pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span>instance category_of_presheaves : category (Presheaf.{v} C) :=\n{ hom := Presheaf_hom,\n  ... }\n</pre></div>\n\n\n<p>and</p>\n<div class=\"codehilite\"><pre><span></span>def functor.map_presheaf (F : C ⥤ D) : Presheaf.{v} C ⥤ Presheaf.{v} D := ...\n</pre></div>",
        "id": 162523657,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554383845
    },
    {
        "content": "<p>There are still some things I'm unhappy with --- some places I need to use <code>erw</code>, where <code>simp</code> should suffice.</p>",
        "id": 162523746,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554383908
    },
    {
        "content": "<p>Scott, I think what we are probably also interested in is the category of presheaves on a space <code>X</code>.</p>",
        "id": 162523780,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554383948
    },
    {
        "content": "<p>I.e. unbundled presheaves on bundled spaces.</p>",
        "id": 162523794,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554383961
    },
    {
        "content": "<p>Of course this is just a functor category...</p>",
        "id": 162523806,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554383976
    },
    {
        "content": "<p>But we might want some specialised coercions/simp lemmas</p>",
        "id": 162523824,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554383989
    },
    {
        "content": "<p>Hmm... so what do you want besides <code>def presheaf (X : Top) := (opens X)^op \\func C</code>?</p>",
        "id": 162524028,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554384097
    },
    {
        "content": "<p>The push-forward functor should be easily accessible</p>",
        "id": 162524137,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554384168
    },
    {
        "content": "<p>And maybe for terms of type <code>presheaf</code> we can actually make <code>F.obj</code> a coercion?</p>",
        "id": 162524210,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554384225
    },
    {
        "content": "<p>I didn't experiment with it though</p>",
        "id": 162524225,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554384236
    },
    {
        "content": "<p>Need to run to catch a train</p>",
        "id": 162524268,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554384244
    },
    {
        "content": "<p>I actually don't see what this particular bundled <code>Presheaf</code> is useful for, other than as an example</p>",
        "id": 162530083,
        "sender_full_name": "Reid Barton",
        "timestamp": 1554388074
    },
    {
        "content": "<p>For example, I don't see how you could build \"<code>Sheaf</code>\" out of \"<code>Presheaf</code>\"</p>",
        "id": 162530196,
        "sender_full_name": "Reid Barton",
        "timestamp": 1554388119
    },
    {
        "content": "<p>(Also, \"presheaf\" for me just means a (contravariant) functor from some category to sets. So there isn't really anything to define for presheaves that we don't have already.)</p>",
        "id": 162530848,
        "sender_full_name": "Reid Barton",
        "timestamp": 1554388495
    },
    {
        "content": "<p>It might make sense though to define pseudofunctors to categories and the Grothendieck construction</p>",
        "id": 162531042,
        "sender_full_name": "Reid Barton",
        "timestamp": 1554388614
    },
    {
        "content": "<p>maybe this opens too many cans of worms at once</p>",
        "id": 162531170,
        "sender_full_name": "Reid Barton",
        "timestamp": 1554388689
    },
    {
        "content": "<p>I wrote an unbundled version of presheaves of types.</p>",
        "id": 162555613,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554403542
    },
    {
        "content": "<p><a href=\"https://gist.github.com/kbuzzard/567b88f2afae5730016c392ec2efc851\" target=\"_blank\" title=\"https://gist.github.com/kbuzzard/567b88f2afae5730016c392ec2efc851\">https://gist.github.com/kbuzzard/567b88f2afae5730016c392ec2efc851</a></p>",
        "id": 162555711,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554403588
    },
    {
        "content": "<p>I needed the notion of an <code>equiv</code> for them. But I was not convinced I had got it right until I had proved refl, symm and trans. They took me some time. I had to deal with heqs.</p>",
        "id": 162555757,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554403621
    },
    {
        "content": "<p>My understanding is that Scott has done something less general than what I need. I need the notion of an equiv of pairs (X,F), i.e. two possibly distinct topological spaces equipped with presheaves.</p>",
        "id": 162556436,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554404007
    },
    {
        "content": "<p>heqs sounds bad, where did they come up?</p>",
        "id": 162556574,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554404083
    },
    {
        "content": "<p>In fact Scott it makes sense to tell you <em>exactly</em> what I need, just out of interest. I need the notion of an isomorphism of the following data: a topological space X, a presheaf of topological rings on X, and an equivalence class of valuations on the stalks (where the direct limits are the limit of a direct system of rings only, not topological rings). I know how to do this. It's just a case of working out what is the best way to do this.</p>\n<p>I have never used the category theory library. I did equivs of data (X,F) with X a top space and F a presheaf on X today so I know it can all be done. I went with Mario's annoying solution to the universe issue by staying in one universe for everything (X : type u and F U : type u).</p>",
        "id": 162556767,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554404198
    },
    {
        "content": "<p>heqs came up because I was changing X.</p>",
        "id": 162556778,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554404208
    },
    {
        "content": "<p>I instantly turned every heq into an eq</p>",
        "id": 162556800,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554404221
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">structure</span><span class=\"w\"> </span><span class=\"n\">f_map</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"err\">𝒢</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">presheaf_of_typesU</span><span class=\"w\"> </span><span class=\"nc\">Y</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"err\">ℱ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">presheaf_of_typesU</span><span class=\"w\"> </span><span class=\"nc\">X</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"></span>\n<span class=\"p\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nc\">X</span><span class=\"w\"> </span><span class=\"err\">→</span><span class=\"w\"> </span><span class=\"nc\">Y</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">[</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">continuous</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"p\">(</span><span class=\"err\">ρ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"err\">∀</span><span class=\"w\"> </span><span class=\"nc\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">opens</span><span class=\"w\"> </span><span class=\"nc\">Y</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"err\">𝒢</span><span class=\"o\">.</span><span class=\"nc\">F</span><span class=\"w\"> </span><span class=\"nc\">V</span><span class=\"w\"> </span><span class=\"err\">→</span><span class=\"w\"> </span><span class=\"err\">ℱ</span><span class=\"o\">.</span><span class=\"nc\">F</span><span class=\"w\"> </span><span class=\"err\">⟨</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"err\">⁻¹&#39;</span><span class=\"w\"> </span><span class=\"nc\">V</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">_</span><span class=\"w\"> </span><span class=\"nc\">V</span><span class=\"o\">.</span><span class=\"mi\">2</span><span class=\"err\">⟩</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">(</span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"err\">∀</span><span class=\"w\"> </span><span class=\"nc\">U</span><span class=\"w\"> </span><span class=\"nc\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">opens</span><span class=\"w\"> </span><span class=\"nc\">Y</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"err\">∀</span><span class=\"w\"> </span><span class=\"n\">hUV</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nc\">V</span><span class=\"w\"> </span><span class=\"err\">⊆</span><span class=\"w\"> </span><span class=\"nc\">U</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"err\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"err\">𝒢</span><span class=\"o\">.</span><span class=\"nc\">F</span><span class=\"w\"> </span><span class=\"nc\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"err\">ρ</span><span class=\"w\"> </span><span class=\"nc\">V</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"err\">𝒢</span><span class=\"o\">.</span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"n\">hUV</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"err\">ℱ</span><span class=\"o\">.</span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">by</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hUV</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"p\">})</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"err\">ρ</span><span class=\"w\"> </span><span class=\"nc\">U</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">))</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>That's a definition of a morphism in my category</p>",
        "id": 162556851,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554404248
    },
    {
        "content": "<p>But when defining equivs I wanted to say that two morphisms were equal, and this involved saying the f's were equal and then the rho's were ==</p>",
        "id": 162556944,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554404285
    },
    {
        "content": "<p>rho is not a good notation, it's not a restriction, rho is the map between the presheaves. f is the map between the spaces and rho, soon to be renamed, is the map between the presheaves. I think heq is inevitable here. But I managed to battle all of them off.</p>",
        "id": 162557059,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554404356
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">ext</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">f_map</span> <span class=\"err\">𝒢</span> <span class=\"n\">ℱ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">β</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hρ</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">ρ</span> <span class=\"bp\">==</span> <span class=\"n\">β</span><span class=\"bp\">.</span><span class=\"n\">ρ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">α</span> <span class=\"k\">with</span> <span class=\"n\">αf</span> <span class=\"n\">αhf</span> <span class=\"n\">αρ</span> <span class=\"n\">αnat</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">β</span> <span class=\"k\">with</span> <span class=\"n\">βf</span> <span class=\"n\">βhf</span> <span class=\"n\">βρ</span> <span class=\"n\">βnat</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">presheaf_of_typesU</span><span class=\"bp\">.</span><span class=\"n\">f_map</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"bp\">.</span><span class=\"n\">inj_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"bp\">⟨</span><span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">hρ</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>That was what Lean gave me, so I went with it.</p>",
        "id": 162557662,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554404691
    },
    {
        "content": "<p>first observation: this should be a definition</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹</span><span class=\"err\">&#39;</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">hf</span> <span class=\"bp\">_</span> <span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">⟩</span>\n</pre></div>",
        "id": 162557713,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554404724
    },
    {
        "content": "<p>Yeah, I couldn't find that!</p>",
        "id": 162557735,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554404745
    },
    {
        "content": "<p>I read all of topology.opens :-)</p>",
        "id": 162557812,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554404774
    },
    {
        "content": "<p>It's not very complete, I think it's just what is needed to define the category</p>",
        "id": 162557838,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554404796
    },
    {
        "content": "<p>you may also want to bundle continuous maps for this purpose</p>",
        "id": 162557855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554404805
    },
    {
        "content": "<p>I'm still not very good at understanding sentences with the word <code>bundle</code> in.</p>",
        "id": 162557907,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554404833
    },
    {
        "content": "<p>Oh -- you mean <code>continuous_map X Y</code>?</p>",
        "id": 162557971,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554404869
    },
    {
        "content": "<p>yes</p>",
        "id": 162557980,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554404877
    },
    {
        "content": "<p>I am very interested in hearing the way Scott would handle this stuff. My understanding of his PR is that he has not yet defined the morphisms I need -- <code>f_map</code>. They caused me some pain, I don't know whether they will cause him more or less pain, or whether he can use my work.</p>",
        "id": 162558222,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554405021
    },
    {
        "content": "<blockquote>\n<p>first observation: this should be a definition</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹</span><span class=\"err\">&#39;</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">hf</span> <span class=\"bp\">_</span> <span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">⟩</span>\n</pre></div>\n\n\n</blockquote>\n<p>Is <code>{f : α → β}</code> ok here? It was only after reading your code that I discovered that <code>continuous</code> wasn't a typeclass :-)</p>",
        "id": 162559483,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554405854
    },
    {
        "content": "<p>It can be, but you end up with unhelpful <code>opens.comap _ U</code> terms in your goal, like <code>classical.some _</code></p>",
        "id": 162559577,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554405956
    },
    {
        "content": "<p>also <code>opens</code> seems to be a bit indecisive about whether to use <code>\\sub</code> or <code>\\le</code> for subsets</p>",
        "id": 162559715,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554406052
    },
    {
        "content": "<p>And why is this called <code>opens.comap</code> (which I assume is topological_space.opens.comap) and not <code>continuous.comap</code>? I am still not very good at naming.</p>",
        "id": 162559728,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554406065
    },
    {
        "content": "<p>You can use projection notation either way, but the distinguishing feature is that <code>opens</code> is the thing being comapped. You aren't going to comap <code>opens</code> with something other than a continuous function, but continuous functions can comap other things</p>",
        "id": 162559857,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554406144
    },
    {
        "content": "<p>I make your change and I now have to fix errors like</p>\n<div class=\"codehilite\"><pre><span></span>type mismatch at application\n  ℱ.res _ x\nterm\n  x\nhas type\n  ℱ.F V\nbut is expected to have type\n  ℱ.F (topological_space.opens.comap (λ (x : X), x) continuous_id V)\n</pre></div>\n\n\n<p>I guess this is to be expected.</p>",
        "id": 162559985,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554406221
    },
    {
        "content": "<p>Lovely lines such as </p>\n<div class=\"codehilite\"><pre><span></span>    change ℱ.res _ (ℱ.res _ (ℱ.res _ x)) = ℱ.res _ x,\n</pre></div>\n\n\n<p>now don't compile at all :-(</p>",
        "id": 162560159,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554406334
    },
    {
        "content": "<p>no that's a complete lie, I fixed the first error and all the other errors magically fixed themselves. I've got it working :D</p>",
        "id": 162561187,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554407047
    },
    {
        "content": "<p>Revised version at <a href=\"https://gist.github.com/kbuzzard/567b88f2afae5730016c392ec2efc851\" target=\"_blank\" title=\"https://gist.github.com/kbuzzard/567b88f2afae5730016c392ec2efc851\">https://gist.github.com/kbuzzard/567b88f2afae5730016c392ec2efc851</a></p>",
        "id": 162561443,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554407222
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> would using category theory stuff make any of this easier?</p>",
        "id": 162561475,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554407245
    },
    {
        "content": "<p>Conversely, could I use this to make a bundled version of presheaves of types easier to implement? I think what I have that Scott doesn't have is that I am allowed to change my base with morphisms</p>",
        "id": 162561504,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554407278
    },
    {
        "content": "<p>I'm working on a more complete working-out of the proposal</p>",
        "id": 162562808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554408177
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">namespace</span> <span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">opens</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">γ</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">comap</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹</span><span class=\"err\">&#39;</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">hf</span> <span class=\"bp\">_</span> <span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">comap_id</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">comap</span> <span class=\"n\">id</span> <span class=\"n\">continuous_id</span> <span class=\"n\">U</span> <span class=\"bp\">=</span> <span class=\"n\">U</span> <span class=\"o\">:=</span> <span class=\"n\">ext</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">comap_comp</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">g</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">comap</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">hg</span><span class=\"o\">)</span> <span class=\"n\">U</span> <span class=\"bp\">=</span> <span class=\"n\">comap</span> <span class=\"bp\">_</span> <span class=\"n\">hf</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"bp\">_</span> <span class=\"n\">hg</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ext</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">comap_mono</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">≤</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"bp\">≤</span> <span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">hx</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">opens</span>\n\n\n\n<span class=\"kn\">structure</span> <span class=\"n\">f_map</span> <span class=\"o\">(</span><span class=\"err\">𝒢</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_of_typesU</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ℱ</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_of_typesU</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"err\">𝒢</span><span class=\"bp\">.</span><span class=\"n\">F</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">ℱ</span><span class=\"bp\">.</span><span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">nat</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">hUV</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">U</span><span class=\"o\">,</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"err\">𝒢</span><span class=\"bp\">.</span><span class=\"n\">F</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">ρ</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"err\">𝒢</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">hUV</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">ℱ</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">comap_mono</span> <span class=\"n\">hUV</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"n\">U</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 162562869,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554408229
    },
    {
        "content": "<p>It seems to me that the only thing category theory can offer me here is free proofs of refl symm and trans given comp_id and comp_assoc</p>",
        "id": 162563753,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554408765
    },
    {
        "content": "<p>I don't see the benefit of using it here.</p>",
        "id": 162563783,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554408783
    },
    {
        "content": "<p>I think Scott also allows you to change the base space.</p>",
        "id": 162563913,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554408850
    },
    {
        "content": "<p>In fact, <code>opens X \\func Type u</code> is defeq to your definition (modulo iota for records).</p>",
        "id": 162564014,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554408942
    },
    {
        "content": "<p>So I think it also doesn't hurt to use the category lib</p>",
        "id": 162564037,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554408958
    },
    {
        "content": "<p>I found it incredibly hard to construct a certain adjunction using the category lib. I don't think that would become any easier by avoiding the category lib.</p>",
        "id": 162564128,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554409011
    },
    {
        "content": "<p>Remark : I think you can prove refl symm and trans for equiv using only comp_assoc and id_comp -- you don't seem to need comp_id</p>",
        "id": 162564133,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554409018
    },
    {
        "content": "<p>The thing I took from Scott's comments were that I could define an equiv as a morphism with a two sided inverse instead of having to write down what I mean by an isomorphism</p>",
        "id": 162564319,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554409138
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, sorry, I haven't caught up everything here --- but your first comment:</p>\n<blockquote>\n<p>My understanding is that Scott has done something less general than what I need. I need the notion of an equiv of pairs (X,F), i.e. two possibly distinct topological spaces equipped with presheaves.</p>\n</blockquote>\n<p>is exactly wrong. Did you look at my definition?</p>",
        "id": 162565784,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554410101
    },
    {
        "content": "<p>A morphism is exactly:</p>\n<div class=\"codehilite\"><pre><span></span>structure Presheaf_hom (F G : Presheaf.{v} C) :=\n(f : F.X ⟶ G.X)\n(c : G.𝒪 ⟹ ((opens.map f).op ⋙ F.𝒪))\n</pre></div>\n\n\n<p>i.e. a pair, a continuous map, changing the topological space, along with a map from the presheaf on the target space to the pushforward of the presheaf on the source space.</p>",
        "id": 162565944,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554410197
    },
    {
        "content": "<p>I then define a category structure on these, so you get the notion of an equivalence of pairs simply by writing <code>\\iso</code>.</p>",
        "id": 162566012,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554410244
    },
    {
        "content": "<p>Sorry if I sound a bit grumpy, but as far as I can tell what you guys have been talking about needing since I went to bed last night is exactly what I PR'd.</p>",
        "id": 162566232,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554410385
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>'s</p>\n<div class=\"codehilite\"><pre><span></span>structure f_map (𝒢 : presheaf_of_typesU Y) (ℱ : presheaf_of_typesU X) :=\n(f : X → Y)\n(hf : continuous f)\n(ρ : ∀ V : opens Y, 𝒢.F V → ℱ.F (V.comap f hf))\n(nat : ∀ U V : opens Y, ∀ hUV : V ≤ U,\n  ∀ x : 𝒢.F U, ρ V (𝒢.res hUV x) = ℱ.res (comap_mono hUV) (ρ U x))\n</pre></div>\n\n\n<p>is exactly a long winded way of saying my <code>Presheaf_hom</code>, and _less_ general, since it restricts to presheaves valued in <code>Type</code>, rather than an arbitrary category.</p>",
        "id": 162566325,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554410429
    },
    {
        "content": "<p>Please tell me if I'm missing something.</p>",
        "id": 162566382,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554410469
    },
    {
        "content": "<p>Here's a completed revision of Kevin's file: <a href=\"https://gist.github.com/digama0/9bfe808e7e51fecc001d8ac8976db19c\" target=\"_blank\" title=\"https://gist.github.com/digama0/9bfe808e7e51fecc001d8ac8976db19c\">https://gist.github.com/digama0/9bfe808e7e51fecc001d8ac8976db19c</a></p>",
        "id": 162566536,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554410556
    },
    {
        "content": "<p>Grah!!!</p>",
        "id": 162566598,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554410593
    },
    {
        "content": "<p>Where is <code>opens.map</code>?</p>",
        "id": 162566615,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554410623
    },
    {
        "content": "<p>Where it's been for months, in <code>category_theory/instances/topological_spaces.lean</code>.</p>",
        "id": 162566695,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554410654
    },
    {
        "content": "<p>I can definitely believe that these are the same issues that come up in the categorical formulation</p>",
        "id": 162566698,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554410657
    },
    {
        "content": "<p>For the record, I'm just making epsilon improvements to Kevin's proposal, not a complete rewrite. I haven't looked in detail at the stuff in this area, I'm just talking about how to deal with dependent types</p>",
        "id": 162566774,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554410732
    },
    {
        "content": "<p>Okay... but as far as I can tell it's all done in my PR from last night. (Which was just a tidy up of a file I showed people months ago....)</p>",
        "id": 162566889,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554410794
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, I'm inclined to believe that Scott has already done all the hard work of these definitions in the category theory lib, and handled the dependencies right because they have been an issue from day one. As for friction of using category theory here: <code>opens</code> is already a category (it was designed to be one), and <code>Type</code> is a category. So those shouldn't cause a problem. You shouldn't have to deal with universe issues since you only care about <code>Type u</code> which has homs in the same universe. Unfolding these morphisms into continuous functions and such is probably going to be a little bit of boilerplate; hopefully this doesn't come up too often, especially if you care about the global structure more than individual morphisms. So I say try Scott's proposal for presheaves and see what happens.</p>",
        "id": 162567743,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554411309
    },
    {
        "content": "<p>I will be very happy if we see a real use of the category theory lib outside of category theory</p>",
        "id": 162567871,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554411382
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>  I can't read the category theory code easily -- I did look at it, but all this whiskering stuff etc and the completely new language and notation basically means that I have to sit down and study it more carefully than I had time to (I was on a train when I saw your message and about to get off; I'd spent the journey finishing my own code and wasn't connected to the internet) and then when I got it I had family stuff. I'll try to get to it this evening but basically, due to my lack of experience, the code looked mostly incomprehensible to me. I'm sure I can change this. </p>\n<p>The work I did has basically taught me what needs to be done to define an equiv of these objects. I had to deal with heqs, although they turned out painless, and some proofs really had me scratching my head for a while, but I got through them all in the end. Once I have wrestled through all the foreign notation, which I will have to do at some stage, I'll be able to make some kind of judgement as to what this category theory stuff is buying me.</p>",
        "id": 162568177,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554411574
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">id&#39;</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℱ</span><span class=\"bp\">.</span><span class=\"n\">F</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℱ</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">ℱ</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n</pre></div>\n\n\n<p>That's a crazy use of <code>h</code> :-) I hadn't really internalised that trick until now.</p>",
        "id": 162568394,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554411686
    },
    {
        "content": "<p>Lean infers it must be a proof of U \\sub U</p>",
        "id": 162568432,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554411711
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">pushforward</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">ℱ</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_of_typesU</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">presheaf_of_typesU</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">ℱ</span><span class=\"bp\">.</span><span class=\"n\">F</span> <span class=\"bp\">⟨</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹</span><span class=\"err\">&#39;</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">hf</span> <span class=\"bp\">_</span> <span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">res</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">hUV</span><span class=\"o\">,</span> <span class=\"n\">ℱ</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">hUV</span> <span class=\"n\">hx</span><span class=\"o\">),</span>\n  <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">ℱ</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">comp</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">hUV</span> <span class=\"n\">hVW</span><span class=\"o\">,</span> <span class=\"n\">ℱ</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</pre></div>\n\n\n<p>Any reason why you didn't use <code>opens.comap</code> in the definition of <code>F</code>?</p>",
        "id": 162568588,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554411795
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">ext</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">f_map</span> <span class=\"err\">𝒢</span> <span class=\"n\">ℱ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">β</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">hρ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">V</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">ρ</span> <span class=\"n\">V</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">ℱ</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">le_of_eq</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">congr&#39;</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">β</span><span class=\"bp\">.</span><span class=\"n\">ρ</span> <span class=\"n\">V</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n</pre></div>\n\n\n<p>You have a <code>heq</code>-free <code>ext</code>! Probably very wise :-)</p>",
        "id": 162568889,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554411983
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  --- stop reading Mario's version, and start reading mine. :-) You'll see the same tricks being used, because Mario showed them to me when I wrote my version last year.</p>",
        "id": 162569135,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554412163
    },
    {
        "content": "<p>And you'll see I do use <code>opens.map</code> (which is the already-in-mathlib synonym for the <code>opens.comap</code> you've been using) in the definition of the pushforward.</p>",
        "id": 162569233,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554412217
    },
    {
        "content": "<p>I want to read Mario's first because it's much easier for me :-) I'll read yours next!</p>",
        "id": 162569247,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554412233
    },
    {
        "content": "<p>oops, I missed that one</p>",
        "id": 162569503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554412409
    },
    {
        "content": "<p>I would love to use the category theory Scott, Reid and Johan worked on. But I totally understand Kevin's reaction. Clearly the code is frightening. I hope one day I'll learn to read it</p>",
        "id": 162569614,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1554412485
    },
    {
        "content": "<p>My proof of equiv.refl was much worse than Mario's because I had not yet proved id_comp -- I only realised I needed it when I was proving equiv.trans :-)</p>",
        "id": 162569699,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554412555
    },
    {
        "content": "<p>OK so I just read all of Mario's code and the main thing I learnt was that the heq can be avoided.</p>",
        "id": 162569777,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554412582
    },
    {
        "content": "<p>Ok now to brave Scott's :-/</p>",
        "id": 162569790,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554412592
    },
    {
        "content": "<p>After 2 minutes I have decided that I cannot possibly read Scott's code unless I read it in Lean, but I thankfully now understand git well enough nowadays to pull his PR branch and compile it. Back in 15 minutes.</p>",
        "id": 162570342,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554412938
    },
    {
        "content": "<p>Until then, Scott let me give you some idea what I think when I look at your code:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">Presheaf</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">Top</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">})</span>\n<span class=\"o\">(</span><span class=\"err\">𝒪</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"err\">ᵒᵖ</span> <span class=\"err\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">Presheaf_hom</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Presheaf</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"err\">𝒪</span> <span class=\"err\">⟹</span> <span class=\"o\">((</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span> <span class=\"err\">⋙</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"err\">𝒪</span><span class=\"o\">))</span>\n</pre></div>\n\n\n<p>I think \"What is <code>⥤</code>, I guess it must be a functor, what is that insane arrow <code>⟶</code>, I have no idea, what is <code> ⟹</code>, what is <code>⋙</code>. That's why I can't just sit down and read your code. But you have made it amply clear that now is the time to start finding out.</p>",
        "id": 162570619,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554413133
    },
    {
        "content": "<p>Oh dear. I'm sorry, I had no idea you didn't even know the arrows. :-) Sorry.</p>",
        "id": 162570705,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554413188
    },
    {
        "content": "<p>The insane arrow <code>⟶</code> is just the \"morphism in a category\" arrow. Think of it just like the usual arrow in <code>Type</code>, but on steroids.</p>",
        "id": 162570767,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554413263
    },
    {
        "content": "<p>(In fact, you can use the \"insane\" arrow in place of the normal arrow, for types. This will pull in the category instance on <code>Type</code>, and be definitionally equal to the normal arrow.)</p>",
        "id": 162570833,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554413309
    },
    {
        "content": "<p><code>⥤</code> is the functor arrow</p>",
        "id": 162570841,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554413319
    },
    {
        "content": "<p><code>⟹</code> is the natural transformation arrow.</p>",
        "id": 162570850,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554413330
    },
    {
        "content": "<p><code>≫</code> is composition of morphisms (so if <code>f : X \\hom Y</code>, and <code>g : Y \\hom Z</code>, you can write <code>f ≫ g</code> to get a <code>X \\hom Z</code>)</p>",
        "id": 162570892,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554413371
    },
    {
        "content": "<p><code>⋙</code> is composition of functors.</p>",
        "id": 162570910,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554413387
    },
    {
        "content": "<p>and finally, in the definition of composition of <code>Presheaf_hom</code>,  (and in <code>ext</code>),</p>",
        "id": 162570975,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554413416
    },
    {
        "content": "<p><code>⊟</code> is \"vertical composition of natural transformations\"</p>",
        "id": 162570981,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554413426
    },
    {
        "content": "<p>Finally, the last piece of notation is the one you've been asking about: <code>≅</code>, which gives you all the different notations of equivalence, all with uniform notation. :-)</p>",
        "id": 162571128,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554413530
    },
    {
        "content": "<p>and <code>.op</code>?</p>",
        "id": 162571144,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554413549
    },
    {
        "content": "<p>As an example, we have</p>\n<div class=\"codehilite\"><pre><span></span>/-- `opens.map f` gives the functor from open sets in Y to open set in X,\n    given by taking preimages under f. -/\ndef map\n  {X Y : Top.{u}} (f : X ⟶ Y) : opens Y ⥤ opens X :=\n{ obj := λ U, ⟨ f.val ⁻¹&#39; U, f.property _ U.property ⟩,\n  map := λ U V i, ⟨ ⟨ λ a b, i.down.down b ⟩ ⟩ }.\n\ndef map_iso {X Y : Top.{u}} (f g : X ⟶ Y) (h : f = g) : map f ≅ map g := ...\n</pre></div>\n\n\n<p>In the last line there is an appearance of <code>≅</code>. Lean looks at this, realises that both <code>map f</code> and <code>map g</code> are functors from <code>opens Y</code> to <code>opens X</code>, successfully realises there are category structures on both of these, whose morphisms are natural transformations, so <code>≅</code> must mean an isomorphism in that category, i.e., a natural isomorphism. (No special notation or special cases for <code>functor_equiv</code>!)</p>",
        "id": 162571252,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554413654
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, unfortunately there are several <code>op</code>s, and it's still too confusing. This <code>.op</code> is applied as field notation to a functor, so it must be <code>functor.op</code>, which takes a <code>F : C \\func D</code> and spits out a functor <code>C^\\op \\func D^\\op</code>.</p>",
        "id": 162571322,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554413725
    },
    {
        "content": "<p>I guess this isn't going to give you a generic function from <code>A ≅ B</code> to the plain equiv <code>A ~= B</code>?</p>",
        "id": 162571334,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554413739
    },
    {
        "content": "<p>what's the <code>.down.down</code> in the definition of <code>opens.map</code> for?</p>",
        "id": 162571431,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554413817
    },
    {
        "content": "<p>We can possibly fix that <code>.down.down</code> now, actually. We used to not be able to define categories with morphisms in <code>Prop</code>.</p>",
        "id": 162571983,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554414241
    },
    {
        "content": "<p>This was recently fixed.</p>",
        "id": 162572029,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554414245
    },
    {
        "content": "<p>I find it strange that I used to think I knew what was a sheaf but never needed to learn \"vertical composition of natural transformations\"</p>",
        "id": 162572053,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1554414298
    },
    {
        "content": "<p>So the definition of <code>hom</code> in <code>opens X</code> is <code>ulift (plift X &lt;= Y)</code></p>",
        "id": 162572066,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554414307
    },
    {
        "content": "<p>Okay, but if you don't learn the definition of \"vertical composition of natural transformations\" you will spend the rest of your life checking more naturality squares than you need to. :-)</p>",
        "id": 162572103,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554414350
    },
    {
        "content": "<p>Who checks naturality squares anyway?</p>",
        "id": 162572159,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1554414373
    },
    {
        "content": "<p>...</p>",
        "id": 162572160,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554414380
    },
    {
        "content": "<p>mostly <code>tidy</code>, to be honest.</p>",
        "id": 162572162,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554414387
    },
    {
        "content": "<p>It exists precisely because I don't check naturality squares either.</p>",
        "id": 162572171,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554414401
    },
    {
        "content": "<p>Is \"vertical composition of natural transformations\" the same as \"composition of natural transformations\"?</p>",
        "id": 162573301,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554415273
    },
    {
        "content": "<p>Thanks a lot for the notation cheat sheet. I have been doing housework but am now desperate to get back to this</p>",
        "id": 162573830,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554415686
    },
    {
        "content": "<p>I did look at some category theory last summer when an UG got interested in it, and I did pick up some of the notation then, but I didn't use it since then and if I don't use things regularly then I forget them quite efficiently nowadays</p>",
        "id": 162574984,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554416573
    },
    {
        "content": "<p>So topological spaces have all limits and colimits in Lean? Do commutative rings?</p>",
        "id": 162575415,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554417001
    },
    {
        "content": "<p>Would <code>tidy</code> have been any use to Mario or me in our approach?</p>",
        "id": 162575588,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554417147
    },
    {
        "content": "<p>I think Ramon wrote colimits for rings ages ago</p>",
        "id": 162576095,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554417636
    },
    {
        "content": "<p>Do we have the category of topological rings?</p>",
        "id": 162576343,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554417877
    },
    {
        "content": "<blockquote>\n<p>I will be very happy if we see a real use of the category theory lib outside of category theory</p>\n</blockquote>\n<p>Yeah but the problem is that it's a real PITA to use some unmerged branch of mathlib and we want them ASAP. I've got too used to having olean files on tap, it has made a huge difference to my workflow</p>",
        "id": 162576879,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554418398
    },
    {
        "content": "<p>I see now that it should be possible to build a category of topological rings and to make the category of presheaves of topological rings. But how to put this extra structure of an equivalence class of valuations on the stalks? Can one modify the presheaf category or does one have to start again? Am object of the category we want is a space with a presheaf of topological rings plus this extra data of valuations on the stalks and I don't immediately see how to add it.</p>",
        "id": 162577193,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554418709
    },
    {
        "content": "<p>One can pull back an equivalence class of valuations via a morphism of rings. You can think of an equivalence class of valuations on a commutative ring as just being a binary relation on the ring satisfying some axioms by the way</p>",
        "id": 162577249,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554418791
    },
    {
        "content": "<p>But the axioms are in the perfectoid project</p>",
        "id": 162577320,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554418807
    },
    {
        "content": "<p>I could never write that proof of <code>comp_id</code> -- it looks terrifying</p>",
        "id": 162577482,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554418978
    },
    {
        "content": "<p>Mario's<code>comp_id</code> is</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">comp_id</span> <span class=\"o\">(</span><span class=\"n\">fℱ</span><span class=\"err\">𝒢</span> <span class=\"o\">:</span> <span class=\"n\">f_map</span> <span class=\"n\">ℱ</span> <span class=\"err\">𝒢</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">comp</span> <span class=\"n\">fℱ</span><span class=\"err\">𝒢</span> <span class=\"o\">(</span><span class=\"n\">f_map</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"err\">𝒢</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">fℱ</span><span class=\"err\">𝒢</span> <span class=\"o\">:=</span>\n<span class=\"n\">f_map</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"n\">rfl</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">V</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">begin</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">comp</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"o\">],</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"err\">𝒢</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"o\">]</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>basically painless</p>",
        "id": 162577627,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554419117
    },
    {
        "content": "<blockquote>\n<p>You shouldn't have to deal with universe issues since you only care about <code>Type u</code> which has homs in the same universe.</p>\n</blockquote>\n<p>Wait wait wait I'm only sticking to Type u because you told me to! I thought I was supposed to care about being maximally polymorphic!</p>",
        "id": 162577862,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554419400
    },
    {
        "content": "<p>I mean that the homs of the category <code>Type u</code> live in a particular universe, namely <code>Type u</code>, rather than some arbitrary other universe. So you don't have to deal with the two-variable problem that appears in general categories</p>",
        "id": 162579501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554421244
    },
    {
        "content": "<p>There is no category <code>Type*</code> that spans multiple universes anyway</p>",
        "id": 162579531,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554421271
    },
    {
        "content": "<p>aka \"<code>Type u</code> is a <code>large_category</code>\"</p>",
        "id": 162579547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554421312
    },
    {
        "content": "<p>But there's some other two variable problem -- aah but maybe Scott's approach solves this correctly?</p>",
        "id": 162579710,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554421483
    },
    {
        "content": "<p>Okay, I will definitely need to look at <code>comp_id</code>.</p>",
        "id": 162579824,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554421615
    },
    {
        "content": "<p>What scott's approach will not give you is a way to talk about homs between presheaves living in different universes. There is basically no way to have a holistic view of these cross-universe homs</p>",
        "id": 162579838,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554421626
    },
    {
        "content": "<p>I agree mine is bad. :-(</p>",
        "id": 162579841,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554421637
    },
    {
        "content": "<p>it's basically the same problem as why <code>functor</code> in core only has a <code>&lt;$&gt;</code> acting on functions between types in the same universe</p>",
        "id": 162579914,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554421689
    },
    {
        "content": "<p>You can use <code>ulift</code> to recover some universe polymorphism</p>",
        "id": 162579947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554421738
    },
    {
        "content": "<p>Okay, <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>, I have refactored quite a bit, pulling out the stuff that is about presheaves on a fixed space, and then later doing pairs (space, presheaf on it).</p>",
        "id": 162612484,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554462185
    },
    {
        "content": "<p>The proofs are much simpler now.</p>",
        "id": 162612493,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554462191
    },
    {
        "content": "<p>e.g. my <code>comp_id</code> and so on are so much simpler they have disappeared :-) (Once they are down to <code>ext; dsimp; simp</code> I'm happy to omit them and let <code>tidy</code> fill them in!)</p>",
        "id": 162612523,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554462226
    },
    {
        "content": "<p>I wrote some stuff about stalks.</p>",
        "id": 162612527,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554462239
    },
    {
        "content": "<p>And got as far as constructing <br>\n<code>def stalk_map {F G : Presheaf.{v} C} (α : F ⟶ G) (x : F.X) : stalk (α.f x) ⟶ stalk x := ...</code></p>",
        "id": 162612588,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554462275
    },
    {
        "content": "<p>I have proved nothing about about that map, at this point, however, so I don't know whether it is usable.</p>",
        "id": 162612613,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554462324
    },
    {
        "content": "<p>I'm not sure if I like your \"hack\" where you replace <code>opens X</code> with its opposite...</p>",
        "id": 162612746,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554462482
    },
    {
        "content": "<p>I knew you wouldn't like this.</p>",
        "id": 162612971,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554462695
    },
    {
        "content": "<p>It just saves so so much pain, you wouldn't believe.</p>",
        "id": 162612976,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554462705
    },
    {
        "content": "<p>That doesn't sound good</p>",
        "id": 162613035,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554462728
    },
    {
        "content": "<p>I can rename it if you like, but I'm not going to be able to write this stuff with explicit <code>op</code>s everywhere.</p>",
        "id": 162613039,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554462733
    },
    {
        "content": "<p>What if we want to do the etale site?</p>",
        "id": 162613047,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554462752
    },
    {
        "content": "<p>We will need to deal with the <code>op</code>s there...</p>",
        "id": 162613052,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554462766
    },
    {
        "content": "<p>But we can worry about that in the future.</p>",
        "id": 162613069,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554462786
    },
    {
        "content": "<p>That sounds like a good place to deal with them. :-)</p>",
        "id": 162613071,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554462791
    },
    {
        "content": "<p>So... let's redefine stalks using filtered colimits...</p>",
        "id": 162613087,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554462836
    },
    {
        "content": "<p>That means we first need a definition of filtered colimit in mathlib</p>",
        "id": 162613146,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554462855
    },
    {
        "content": "<p>I should sleep soon, but I agree this is a good thing to do, and we're actually not that far.</p>",
        "id": 162614563,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554464366
    },
    {
        "content": "<p>Do you want to talk about it tomorrow? I can probably find some time.</p>",
        "id": 162614566,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554464384
    },
    {
        "content": "<p>We could even try out the new VS Code collaborative mode :-)</p>",
        "id": 162614569,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554464395
    },
    {
        "content": "<p>Thank you very much Scott</p>",
        "id": 162614570,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1554464399
    },
    {
        "content": "<p>I'm not sure if I have time tomorrow... maybe...</p>",
        "id": 162614627,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554464413
    },
    {
        "content": "<p>I'm doing presheaves with preorders on the stalks right now. :-)</p>",
        "id": 162614632,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554464425
    },
    {
        "content": "<p>Nooooo you need the <code>op</code>s</p>",
        "id": 162618447,
        "sender_full_name": "Reid Barton",
        "timestamp": 1554467586
    },
    {
        "content": "<p>How would you even define sheaves? \"A collection of maps <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>{</mo><mi>U</mi><mo>→</mo><msub><mi>U</mi><mi>α</mi></msub><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">\\{U \\to U_\\alpha\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">{</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"mrel\">→</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.0037em;\">α</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span> is a co-cover if ...\"?</p>",
        "id": 162618566,
        "sender_full_name": "Reid Barton",
        "timestamp": 1554467666
    },
    {
        "content": "<p>Does it save real pain, or does it just save writing <code>op</code> a lot?</p>",
        "id": 162618625,
        "sender_full_name": "Reid Barton",
        "timestamp": 1554467716
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I'm not sure how far you got with filtered colimits, but I pushed my old implementation which I never got around to PRing to the <code>filtered-colimits</code> branch</p>",
        "id": 162634532,
        "sender_full_name": "Reid Barton",
        "timestamp": 1554479011
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/commit/bc457fb5716fbffe63cbcc10b4ce7a253c720f84\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/commit/bc457fb5716fbffe63cbcc10b4ce7a253c720f84\">https://github.com/leanprover-community/mathlib/commit/bc457fb5716fbffe63cbcc10b4ce7a253c720f84</a></p>",
        "id": 162634615,
        "sender_full_name": "Reid Barton",
        "timestamp": 1554479085
    },
    {
        "content": "<blockquote>\n<p>Is \"vertical composition of natural transformations\" the same as \"composition of natural transformations\"?</p>\n</blockquote>\n<p>Yes.</p>",
        "id": 162640590,
        "sender_full_name": "Reid Barton",
        "timestamp": 1554483955
    },
    {
        "content": "<p>Ok, I think while walking the dog I understood what my problem with the <code>op</code>s has been, and I hope that I can restore them. The price that is I will have to define <code>opens.op_map : (opens X)^op \\func (opens Y)^op</code> separately from <code>opens.map</code>, rather than just using <code>(opens.map).op</code> as I have been. This is only a few lines of duplication.</p>",
        "id": 162666636,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554502943
    },
    {
        "content": "<p>I should say that in contrast to Johan, I don't mind at all about you having reversed the arrows in <code>opens X</code> -- you could even have just defined <code>opens_op X</code>. But if you think you've figured out what's going on then great :-)</p>",
        "id": 162666725,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554503019
    },
    {
        "content": "<p>The underlying problem is that <code>opens.map</code> is really a 2-functor from {topological spaces}&lt;={continuous maps}&lt;={equalities} to {categories}&lt;={functors}&lt;={nat trans}, and so we have some dependent type theory hell waiting the break loose. Too many <code>op</code>s in the wrong places prevent things simplifying at the right moments.</p>",
        "id": 162666799,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554503061
    },
    {
        "content": "<p>Another realisation while walking the dog is that since we've generalised the category theory library to allow <code>Prop</code> valued homs, the avenue is open to using \"functor extensionality\" for functors into Prop-level categories. The point is that you only need to check equality on objects, and then proof irrelevance guarantees equality of morphisms. This means that the usual <code>eq.rec</code> balrog that functor extensionality rouses should not be a problem.</p>",
        "id": 162666988,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554503222
    },
    {
        "content": "<p>I'm not quite there with \"bundled presheaves whose stalks have preorders, and whose morphisms preserve the preorders\", but I think I'm pretty close. Hopefully this afternoon. :-)</p>",
        "id": 162667092,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554503297
    },
    {
        "content": "<p>Yes, I didn't know how you were going to do this. I did wonder whether doing presheaves in the funky functor way would somehow not really help, whereas with the structures Mario and I made you can just add more fields</p>",
        "id": 162667149,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554503365
    },
    {
        "content": "<p>I'm just doing more fields, too.</p>",
        "id": 162667690,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554503828
    },
    {
        "content": "<p>I don't know how to add more fields to the objects of a category</p>",
        "id": 162668368,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554504344
    },
    {
        "content": "<p>Just bundle more. A object of the new category is an object of the old category, along with some extra piece of data.</p>",
        "id": 162668480,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554504417
    },
    {
        "content": "<p>I just didn't know how easy this was to do in practice. Of course the morphisms change too etc.</p>",
        "id": 162668633,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554504543
    },
    {
        "content": "<p>With structures I can see how it all would work but in this bundled setting I don't have the experience.</p>",
        "id": 162668652,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554504560
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>, no I've done basically nothing on filtered colimits yet, so this is great.</p>",
        "id": 162678953,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554518068
    },
    {
        "content": "<p>Can we PR it?</p>",
        "id": 162678954,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554518076
    }
]
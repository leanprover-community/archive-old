[
    {
        "content": "<p>Q) Why does <code>refl</code> fail to finish the proof of <code>Spv.refl</code> in the code below? </p>\n<p>I am about to write a bunch of API for a type <code>Spv</code> and I am going to have to get the hang of <code>letI</code>, <code>exactI</code> etc. I feel like my understanding of type class inference is now better than it was, and that I could do with a clearer picture of what is going on. Here's some documented minimised fully working code. Writing it has made me understand stuff better but I don't see why <code>refl</code> fails below.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">order</span><span class=\"bp\">.</span><span class=\"n\">bounded_lattice</span> <span class=\"c1\">-- for with_bot</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u₀</span> <span class=\"n\">u₁</span>\n\n<span class=\"c1\">-- what I need from with_bot</span>\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"err\">Γ</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"o\">(</span><span class=\"n\">with_bot</span> <span class=\"err\">Γ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"n\">def</span> <span class=\"n\">valuation</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"err\">Γ</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">with_bot</span> <span class=\"err\">Γ</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">Spv</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">ineq</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"o\">{</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"err\">Γ</span><span class=\"o\">],</span>\n <span class=\"k\">by</span> <span class=\"n\">exactI</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">ineq</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Spv</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">reflexive</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"err\">Γ</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"err\">Γ</span><span class=\"o\">,</span> <span class=\"n\">v0</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- hΓ : partial_order Γ</span>\n  <span class=\"c1\">-- but presumably type class inference doesn&#39;t know this yet.</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"err\">Γ</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- now it does</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- v0 r : with_bot Γ</span>\n  <span class=\"c1\">-- ⊢ v0 r ≤ v0 r, and this ≤ is coming direct from hΓ and the</span>\n  <span class=\"c1\">-- instance in the example above.</span>\n\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  refl, -- fails!</span>\n\n<span class=\"cm\">  invalid apply tactic, failed to unify</span>\n<span class=\"cm\">  v0 r ≤ v0 r</span>\n<span class=\"cm\">with</span>\n<span class=\"cm\">  ∀ [_inst_1 : preorder ?m_1] (a : ?m_1), a ≤ a</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">exact</span> <span class=\"n\">le_refl</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"c1\">-- works</span>\n<span class=\"kn\">end</span>\n\n<span class=\"c1\">-- version without with_bot</span>\n\n<span class=\"n\">def</span> <span class=\"n\">valuation&#39;</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"err\">Γ</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"err\">Γ</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">Spv&#39;</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">ineq</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"o\">{</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"err\">Γ</span><span class=\"o\">],</span>\n <span class=\"k\">by</span> <span class=\"n\">exactI</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuation&#39;</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">ineq</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">Spv&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Spv&#39;</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">reflexive</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"err\">Γ</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"err\">Γ</span><span class=\"o\">,</span> <span class=\"n\">v0</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- Don&#39;t even need letI</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"c1\">-- refl must now have worked</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>So there are two variants of a reflexivity proof. Let me talk through the code.</p>\n<p>In the definition of Spv there is an inequality <code>v r ≤ v s</code> which, to make sense, relies on finding a preorder on <code>with_bot Γ</code>. The <code>by exactI</code> must be doing this. But it seems to me that what must be happening in practice is that the term generated by the definition of <code>Spv</code> must be plugging the partial order on <code>with_bot  Γ</code> directly in, rather than saying \"oh, we will deal with this using type class inference\". Maybe this is how fully elaborated terms always work -- this is just dawning on me now as I write, I guess.</p>\n<p>So in practice I am going to be writing a bunch of <code>letI := hΓ</code>'s in my code I think. In the proof of <code>Spv.refl</code>, I do this.</p>\n<p>But why does <code>refl</code> fail to finish the proof of Spv.refl? </p>\n<p>Type class inference isn't finding the pre-order on <code>with_bot Γ</code>, even though I thought I inserted the partial order on <code>Γ</code> as early as I could.</p>",
        "id": 159987835,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551777478
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Spv</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">reflexive</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"err\">Γ</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"err\">Γ</span><span class=\"o\">,</span> <span class=\"n\">v0</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">exactI</span> <span class=\"n\">le_refl</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"c1\">-- works</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p><code>exactI</code> also works. What does <code>exactI</code> do? I understand <code>letI</code> and <code>haveI</code>.</p>",
        "id": 159987938,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551777569
    },
    {
        "content": "<p>Independent issue:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"n\">refl</span><span class=\"o\">]</span> <span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">refl</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">invalid binary relation declaration, relation &#39;reflexive&#39; must have two explicit parameters</span>\n<span class=\"cm\">-/</span>\n</pre></div>\n\n\n<p>??</p>",
        "id": 159988510,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551778184
    },
    {
        "content": "<p>Do you know about <code>resetI</code>? <code>resetI</code> means \"make everything in the context available for type class resolution\". Of course things \"to the left of the colon\" were already available, so the point is to add things bound by a lambda, or by <code>rcases</code>, etc.--in particular your <code>hΓ</code>, I'm guessing.<br>\n<code>exactI</code> is <code>resetI</code> followed by <code>exact</code>.</p>",
        "id": 160024356,
        "sender_full_name": "Reid Barton",
        "timestamp": 1551808619
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">order</span><span class=\"bp\">.</span><span class=\"n\">bounded_lattice</span> <span class=\"c1\">-- for with_bot</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u₀</span> <span class=\"n\">u₁</span>\n\n<span class=\"c1\">-- what I need from with_bot</span>\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"err\">Γ</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"o\">(</span><span class=\"n\">with_bot</span> <span class=\"err\">Γ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"n\">def</span> <span class=\"n\">valuation</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"err\">Γ</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">with_bot</span> <span class=\"err\">Γ</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">Spv</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">ineq</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"o\">{</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"err\">Γ</span><span class=\"o\">],</span>\n <span class=\"k\">by</span> <span class=\"n\">exactI</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">ineq</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Spv</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">reflexive</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"err\">Γ</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"err\">Γ</span><span class=\"o\">,</span> <span class=\"n\">v0</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">resetI</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"o\">(</span><span class=\"n\">with_bot</span> <span class=\"err\">Γ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n  <span class=\"n\">resetI</span><span class=\"o\">,</span>\n  <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"n\">v0</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">with_bot</span> <span class=\"err\">Γ</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">v0</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"c1\">-- fails</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  invalid apply tactic, failed to unify</span>\n<span class=\"cm\">  v0 r ≤ v0 r</span>\n<span class=\"cm\">with</span>\n<span class=\"cm\">  ∀ [_inst_1 : preorder ?m_1] (a : ?m_1), a ≤ a</span>\n<span class=\"cm\">state:</span>\n<span class=\"cm\">R : Type u₀,</span>\n<span class=\"cm\">v : Spv R,</span>\n<span class=\"cm\">r : R,</span>\n<span class=\"cm\">Γ : Type u₀,</span>\n<span class=\"cm\">hΓ : partial_order Γ,</span>\n<span class=\"cm\">v0 : valuation R Γ,</span>\n<span class=\"cm\">h : ∀ (r s : R), v0 r ≤ v0 s ↔ v.val r s,</span>\n<span class=\"cm\">_inst : preorder (with_bot Γ) := partial_order.to_preorder (with_bot Γ)</span>\n<span class=\"cm\">⊢ v0 r ≤ v0 r</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 160025024,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551809141
    },
    {
        "content": "<p>It just seems to be an issue with <code>refl</code>. <code>exact le_refl _</code> works fine.</p>",
        "id": 160025595,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551809616
    },
    {
        "content": "<p>The issue with <code>attribute [refl] Spv.refl</code> is that the type of <code>Spv.refl</code> isn't asserting reflexivity of anything, it's proving <code>reflexive bla</code>. Lean is expecting a proof of <code>my_rel bla x x</code></p>",
        "id": 160028328,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551811323
    },
    {
        "content": "<p>I think if you just unfold <code>reflexive</code> in the statement lean will accept it... but then the relation you are proving reflexive is <code>subtype.val</code> which is a bit weird</p>",
        "id": 160028461,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551811386
    },
    {
        "content": "<p>You should probably hide the implementation details of <code>Spv</code> by using something other than <code>.1</code> to extract the relation from an Spv</p>",
        "id": 160028596,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551811457
    },
    {
        "content": "<p>like define <code>Spv.rel : Spv R -&gt; R -&gt; R -&gt; Prop := subtype.val</code> and then you can prove <code>Spv.refl : Spv.rel v x x</code> and mark it <code>@[refl]</code></p>",
        "id": 160028717,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551811546
    }
]
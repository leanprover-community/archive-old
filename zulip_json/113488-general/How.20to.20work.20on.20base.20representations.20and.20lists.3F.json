[
    {
        "content": "<p>I'm trying to work out with integers base representations using <code>data.nat.digits</code> and here is a MWE where I am completely stuck:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.digits</span>\n\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mwe</span>\n  <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">):</span>\n  <span class=\"n\">list.sum</span> <span class=\"o\">((</span><span class=\"n\">nat.digits</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">conv</span> <span class=\"o\">{</span>\n      <span class=\"n\">to_rhs</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">nat.of_digits_digits</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n    <span class=\"n\">rw</span> <span class=\"n\">nat.of_digits_eq_foldr</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- how to carry on?</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span>\n</code></pre></div>\n<p>I have the feeling the <code>list</code> API is not really enough and unsure if I should switch to something like <code>finset</code> and use only <code>finset</code> in my code but as the base repr API provides me only with <code>list</code>, I'm not sure.</p>\n<p>I guess what should I do is to develop adhoc lemmas to show that foldr and the map_with_index coincide in the way I want using induction or something like this.</p>",
        "id": 224487487,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1611934494
    },
    {
        "content": "<p>Seems like there is indeed a <code>map_with_index</code>-shaped hole in the mathlib API -- quick <code>grep</code> didn't find anything. For this particular application, you need the lemma that <code>map_with_index</code> is equal to a <code>foldr</code>; after that you should be able to use <code>foldr</code> fusion to get rid of the <code>sum</code>. The <code>map_with_index</code> lemma would probably go into <code>data/list/indexes.lean</code>.</p>",
        "id": 224493715,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1611936542
    },
    {
        "content": "<p>Does <code>rw map_with_index</code> make progress? Or is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.map_with_index\">docs#list.map_with_index</a> not defined conveniently?</p>\n<p>Edit now the link is there: Looks like it's not. Maybe it should be redefined in terms of foldr?</p>",
        "id": 224496099,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611937415
    },
    {
        "content": "<p>This applies to a lot of the list functions. Could be that the direct recursive formulation is more efficient than the <code>foldr</code> one.</p>",
        "id": 224497057,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1611937770
    },
    {
        "content": "<p>I think it's simpler than that - <code>map_with_index</code> is defined before <code>foldr</code> (and both are in lean core)</p>",
        "id": 224497731,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611937986
    },
    {
        "content": "<p>I would make a lemma that says that <code>l.map_with_index f</code> can be expressed as a <code>l.enum.map (uncurry f)</code> or something</p>",
        "id": 224504838,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611940758
    },
    {
        "content": "<p>And then you'll be in the clear, because <code>enum</code> and <code>map</code> have way more lemmas.</p>",
        "id": 224504851,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611940770
    },
    {
        "content": "<p>For example, the relevant one here could be <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.enum_eq_zip_range\">docs#list.enum_eq_zip_range</a></p>",
        "id": 224505001,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611940838
    },
    {
        "content": "<p>And I expect there might be an inductive step here.</p>",
        "id": 224505057,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611940871
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F/near/224493715\">said</a>:</p>\n<blockquote>\n<p>Seems like there is indeed a <code>map_with_index</code>-shaped hole in the mathlib API -- quick <code>grep</code> didn't find anything. For this particular application, you need the lemma that <code>map_with_index</code> is equal to a <code>foldr</code>; after that you should be able to use <code>foldr</code> fusion to get rid of the <code>sum</code>. The <code>map_with_index</code> lemma would probably go into <code>data/list/indexes.lean</code>.</p>\n</blockquote>\n<p>Would that be something like: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">list.sum_map_with_index_eq_foldr</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">as</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">):</span>\n  <span class=\"o\">(</span><span class=\"n\">as.map_with_index</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"bp\">=</span> <span class=\"n\">as.foldr</span> <span class=\"o\">(</span><span class=\"n\">something</span> <span class=\"n\">here</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>?</p>",
        "id": 224506948,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1611941715
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">function.uncurry</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"n\">function.uncurry</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">prod.map</span> <span class=\"o\">(</span><span class=\"n\">has_add.add</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">id</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n   <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"c1\">-- why is it simplified to a single arg function on the lhs?</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Curious case, I encountered while trying the path <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> suggested ; and what would be a standard way to move forward?</p>",
        "id": 224527946,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1611951754
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">function.uncurry</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"n\">function.uncurry</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">prod.map</span> <span class=\"o\">(</span><span class=\"n\">has_add.add</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">id</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 224528163,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611951871
    },
    {
        "content": "<p>Okay, indeed, that was simple, thanks !</p>",
        "id": 224528232,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1611951907
    },
    {
        "content": "<p>While I'm on the subject, is this,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">list.map_with_index_core_eq_map_with_index</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">as</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">):</span>\n  <span class=\"n\">list.map_with_index_core</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"n\">as</span> <span class=\"bp\">=</span> <span class=\"n\">list.map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">as</span>\n  <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>something that is \"in the library\" or follows quitely easily from the library or should be proved?</p>",
        "id": 224528785,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1611952260
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">list.map_with_index_core_eq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">l.map_with_index_core</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">l.map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">hl</span> <span class=\"n\">generalizing</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">list.map_with_index</span><span class=\"o\">,</span> <span class=\"n\">list.map_with_index_core</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">list.map_with_index</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">list.map_with_index_core</span><span class=\"o\">,</span> <span class=\"n\">hl</span><span class=\"o\">,</span> <span class=\"n\">add_left_comm</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 224528951,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611952332
    },
    {
        "content": "<p>I had to prove this, it wasn't in the library</p>",
        "id": 224528960,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611952338
    },
    {
        "content": "<p>Thanks a lot <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> !</p>",
        "id": 224529484,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1611952587
    },
    {
        "content": "<p>Full proof:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.digits</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.list.range</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">list.map_with_index_core_eq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">l.map_with_index_core</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">l.map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">hl</span> <span class=\"n\">generalizing</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">list.map_with_index</span><span class=\"o\">,</span> <span class=\"n\">list.map_with_index_core</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">list.map_with_index</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">list.map_with_index_core</span><span class=\"o\">,</span> <span class=\"n\">hl</span><span class=\"o\">,</span> <span class=\"n\">add_left_comm</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">list.map_uncurry_zip_eq_zip_with</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">list.map</span> <span class=\"o\">(</span><span class=\"n\">function.uncurry</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l.zip</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">list.zip_with</span> <span class=\"n\">f</span> <span class=\"n\">l</span> <span class=\"n\">l'</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">hl</span> <span class=\"n\">generalizing</span> <span class=\"n\">l'</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">l'</span> <span class=\"k\">with</span> <span class=\"n\">hd'</span> <span class=\"n\">tl'</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hl</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">list.zip_with_map_left</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">list.zip_with</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">l.map</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">l'</span> <span class=\"bp\">=</span> <span class=\"n\">list.zip_with</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"n\">l'</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">hl</span> <span class=\"n\">generalizing</span> <span class=\"n\">l'</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">l'</span> <span class=\"k\">with</span> <span class=\"n\">hd'</span> <span class=\"n\">tl'</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hl</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">list.zip_with_map_right</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">list.zip_with</span> <span class=\"n\">f</span> <span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">l'.map</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">list.zip_with</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"n\">l'</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">hl</span> <span class=\"n\">generalizing</span> <span class=\"n\">l'</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">l'</span> <span class=\"k\">with</span> <span class=\"n\">hd'</span> <span class=\"n\">tl'</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hl</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">list.map_with_index_eq_enum_map_uncurry</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">l.map_with_index</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">l.enum.map</span> <span class=\"o\">(</span><span class=\"n\">function.uncurry</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">hl</span> <span class=\"n\">generalizing</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">list.map_with_index</span><span class=\"o\">,</span> <span class=\"n\">list.map_with_index_core</span><span class=\"o\">,</span> <span class=\"n\">list.enum_eq_zip_range</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">list.map_with_index</span><span class=\"o\">,</span> <span class=\"n\">list.map_with_index_core</span><span class=\"o\">,</span> <span class=\"n\">list.map_with_index_core_eq</span><span class=\"o\">,</span> <span class=\"n\">hl</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">list.enum_eq_zip_range</span><span class=\"o\">,</span> <span class=\"n\">list.range_succ_eq_map</span><span class=\"o\">,</span> <span class=\"n\">list.zip_with_map_left</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">list.sum_zip_with_distrib_left</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">list.zip_with</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"n\">l'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">l.zip_with</span> <span class=\"n\">f</span> <span class=\"n\">l'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">hl</span> <span class=\"n\">generalizing</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"n\">l'</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">l'</span> <span class=\"k\">with</span> <span class=\"n\">hd'</span> <span class=\"n\">tl'</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hl</span><span class=\"o\">,</span> <span class=\"n\">mul_add</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">aux</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">list.zip_with</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">nat.succ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">list.range</span> <span class=\"n\">l.length</span><span class=\"o\">)</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"bp\">=</span>\n  <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">list.zip_with</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">list.range</span> <span class=\"n\">l.length</span><span class=\"o\">)</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">list.zip_with</span> <span class=\"o\">(((</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">nat.succ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">list.range</span> <span class=\"n\">l.length</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"bp\">=</span>\n      <span class=\"n\">list.zip_with</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">list.range</span> <span class=\"n\">l.length</span><span class=\"o\">)</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"n\">congr</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">pow_succ</span><span class=\"o\">],</span>\n  <span class=\"n\">ring</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mwe</span>  <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">list.sum</span> <span class=\"o\">((</span><span class=\"n\">nat.digits</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">conv</span> <span class=\"o\">{</span>\n      <span class=\"n\">to_rhs</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">nat.of_digits_digits</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">list.map_with_index_eq_enum_map_uncurry</span><span class=\"o\">,</span> <span class=\"n\">list.enum_eq_zip_range</span><span class=\"o\">,</span>\n      <span class=\"n\">list.map_uncurry_zip_eq_zip_with</span><span class=\"o\">,</span> <span class=\"n\">nat.of_digits_eq_foldr</span> <span class=\"n\">b</span><span class=\"o\">],</span>\n  <span class=\"n\">induction</span> <span class=\"n\">b.digits</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">hl</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">list.range_succ_eq_map</span><span class=\"o\">,</span> <span class=\"n\">list.zip_with_map_left</span><span class=\"o\">,</span> <span class=\"n\">aux</span><span class=\"o\">,</span> <span class=\"n\">hl</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>",
        "id": 224530930,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611953350
    },
    {
        "content": "<p>Feel free to PR any of these to mathlib.</p>",
        "id": 224530948,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611953364
    },
    {
        "content": "<p>The crucial part was to just consider <code>nat.digits b n</code> as some random list. For that, your work to use <code>nat.of_digits_digits</code> and <code>nat.of_digits_eq_foldr</code> was crucial.</p>",
        "id": 224531389,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611953499
    },
    {
        "content": "<p>Everything else is just juggling the various list operations. And writing a distrib lemma.</p>",
        "id": 224531614,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611953543
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F/near/224531614\">said</a>:</p>\n<blockquote>\n<p>Everything else is just juggling the various list operations. And writing a distrib lemma.</p>\n</blockquote>\n<p>Indeed, but the proofs you wrote are a lot nicer than mine which were a bit tedious and slow I guess, thank you for the example, I learnt a lot from this!</p>",
        "id": 224534900,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1611955031
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F/near/224530948\">said</a>:</p>\n<blockquote>\n<p>Feel free to PR any of these to mathlib.</p>\n</blockquote>\n<p>I will try to open a PR in the next hours with those :)</p>",
        "id": 224534984,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1611955068
    },
    {
        "content": "<p>I think it's really neat that a lot of the proofs are just:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">hl</span> <span class=\"n\">generalizing</span> <span class=\"n\">l'</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">l'</span> <span class=\"k\">with</span> <span class=\"n\">hd'</span> <span class=\"n\">tl'</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hl</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 224535214,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611955175
    },
    {
        "content": "<p>That means that there are good simp lemmas elsewhere, and that the list operation makes sense.</p>",
        "id": 224535249,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611955193
    },
    {
        "content": "<p>There can probably be some general <code>list.zip_with</code> <code>congr</code> lemma that expects hypotheses that would prove goals of this type.</p>",
        "id": 224535390,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611955255
    },
    {
        "content": "<p>Here's a first PR: <a href=\"https://github.com/leanprover-community/mathlib/pull/5963\">https://github.com/leanprover-community/mathlib/pull/5963</a> — <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> Let me know how do you want to be credited for the proofs :)</p>",
        "id": 224544781,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1611959495
    },
    {
        "content": "<p>And here's the second one: <a href=\"https://github.com/leanprover-community/mathlib/pull/5964\">https://github.com/leanprover-community/mathlib/pull/5964</a></p>",
        "id": 224547320,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1611960956
    },
    {
        "content": "<p>Follow-up question <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> — how would you simplify the proof of:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">map_of_map_with_index_eq_map</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">):</span>\n  <span class=\"n\">list.map</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">list.map_with_index</span> <span class=\"n\">f</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">list.map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">L</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">hl</span> <span class=\"n\">generalizing</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">list.map_with_index</span><span class=\"o\">,</span> <span class=\"n\">list.map_with_index_core</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">list.map_with_index</span><span class=\"o\">,</span> <span class=\"n\">list.map_with_index</span><span class=\"o\">,</span>\n      <span class=\"n\">list.map_with_index_core</span><span class=\"o\">,</span> <span class=\"n\">list.map_with_index_core</span><span class=\"o\">,</span>\n      <span class=\"n\">list.map_with_index_core_eq</span><span class=\"o\">,</span> <span class=\"n\">list.map_with_index_core_eq</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hl</span><span class=\"o\">],</span>\n  <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>It seems like I cannot rewrite both sides directly with one application of <code>rw</code>, unsure of a simpler path?</p>",
        "id": 224552335,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1611964775
    },
    {
        "content": "<p>Also I suppose there's no easy way to write down the composition as <code>g \\circ f</code> and that would still be a currified function?</p>",
        "id": 224552463,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1611964887
    },
    {
        "content": "<p>Also, more difficult question I guess about casts, I have a cast in front of some <code>map_with_index</code> which I want to be lifted inside the function, it appears to me that <code>norm_cast</code> does not work out of the box, so I supposed there was some coercion theorem missing here, I tried to write down this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[norm_cast]</span> <span class=\"kd\">lemma</span> <span class=\"n\">cast_map_index_sum</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">}</span>\n<span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">γ</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">has_lift_t</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">):</span>\n  <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">list.map_with_index</span> <span class=\"n\">f</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">list.map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"o\">:</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n   <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">hl</span><span class=\"o\">,</span>\n   <span class=\"n\">unfold</span> <span class=\"n\">list.map_with_index</span><span class=\"o\">,</span>\n   <span class=\"n\">unfold</span> <span class=\"n\">list.map_with_index_core</span><span class=\"o\">,</span>\n   <span class=\"n\">rw</span> <span class=\"n\">list.sum_nil</span><span class=\"o\">,</span>\n   <span class=\"n\">rw</span> <span class=\"n\">list.sum_nil</span><span class=\"o\">,</span>\n   <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n   <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span>\n</code></pre></div>\n<p>but unsure if I'm going through the right way, also I do not see how to clear out <code>coe 0 = 0</code> — surely, a coercion of 0 is still 0?</p>",
        "id": 224555461,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1611967444
    },
    {
        "content": "<p>Here's a MWE of what I'm trying to do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.special_functions.pow</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.digits</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">of_digits_eq_sum_map_with_index</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">):</span>\n  <span class=\"n\">nat.of_digits</span> <span class=\"n\">b</span> <span class=\"n\">L</span> <span class=\"bp\">=</span> <span class=\"n\">list.sum</span> <span class=\"o\">(</span><span class=\"n\">L.map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mwe</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">):</span> <span class=\"n\">abs</span> <span class=\"o\">((</span><span class=\"n\">nat.of_digits</span> <span class=\"n\">b</span> <span class=\"n\">l</span><span class=\"o\">):</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">list.sum</span> <span class=\"o\">(</span><span class=\"n\">l.map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">↑</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw_mod_cast</span> <span class=\"n\">of_digits_eq_sum_map_with_index</span><span class=\"o\">,</span> <span class=\"n\">norm_cast</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 224555808,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1611967771
    },
    {
        "content": "<p>If you just assume <code>has_lift_t β γ</code>, that just means you have a coe from beta to gamma that could do anything</p>",
        "id": 224556312,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611968206
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">list.map_map_with_index_core</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">l.map_with_index_core</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">l.map_with_index_core</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"n\">generalizing</span> <span class=\"n\">n</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">list.map_with_index_core</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">list.map_map_with_index</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">l.map_with_index</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">l.map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">list.map_map_with_index_core</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">of_digits_eq_sum_map_with_index</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">):</span>\n  <span class=\"n\">nat.of_digits</span> <span class=\"n\">b</span> <span class=\"n\">L</span> <span class=\"bp\">=</span>\n  <span class=\"n\">list.sum</span> <span class=\"o\">(</span><span class=\"n\">L.map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mwe</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">):</span> <span class=\"n\">abs</span> <span class=\"o\">((</span><span class=\"n\">nat.of_digits</span> <span class=\"n\">b</span> <span class=\"n\">l</span><span class=\"o\">):</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">list.sum</span> <span class=\"o\">(</span><span class=\"n\">l.map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">↑</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">congr</span><span class=\"o\">,</span>\n  <span class=\"n\">rw_mod_cast</span> <span class=\"n\">of_digits_eq_sum_map_with_index</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">list.sum_hom</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">nat.cast_add_monoid_hom</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">list.map_map_with_index</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 224557037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611968981
    },
    {
        "content": "<p>In the continuity of list lemmas that I'm not sure they exist or should exist, I'm looking now at:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">list.le_map_with_index</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">canonically_linear_ordered_add_monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">):</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i_le</span><span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">l.length</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">l</span> <span class=\"n\">i</span> <span class=\"n\">i_le</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">g</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">l</span> <span class=\"n\">i</span> <span class=\"n\">i_le</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">l.map_with_index</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">l.map_with_index</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h_f_le</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">hl</span> <span class=\"n\">generalizing</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">list.map_with_index</span><span class=\"o\">,</span> <span class=\"n\">list.map_with_index_core</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">list.map_with_index</span><span class=\"o\">,</span> <span class=\"n\">list.map_with_index_core</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">list.map_with_index_core_eq</span><span class=\"o\">,</span> <span class=\"n\">list.map_with_index_core_eq</span><span class=\"o\">],</span>\n    <span class=\"n\">apply</span> <span class=\"n\">add_le_add</span><span class=\"o\">,</span>\n    <span class=\"n\">convert</span> <span class=\"n\">h_f_le</span> <span class=\"mi\">0</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">convert</span> <span class=\"n\">hl</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">i</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n    <span class=\"n\">convert</span> <span class=\"n\">h_f_le</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hi</span><span class=\"o\">],</span>\n   <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I was able to produce the proof by myself, but I would be interested into feedback regarding whether this is a good statement, and would there be a more natural way to prove it?</p>",
        "id": 224605929,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612042124
    },
    {
        "content": "<p>And another question also:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">mwe</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">):</span>\n  <span class=\"n\">list.sum</span> <span class=\"o\">(</span><span class=\"n\">l.map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">abs</span> <span class=\"o\">((</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">)))</span> <span class=\"bp\">=</span> <span class=\"n\">list.sum</span> <span class=\"o\">(</span><span class=\"n\">l.map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">congr</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">is_absolute_value.abv_mul</span><span class=\"o\">,</span> <span class=\"n\">is_absolute_value.abv_pow</span><span class=\"o\">],</span>\n    <span class=\"n\">norm_cast</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">mul_nonneg</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">nat.zero_le</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">pow_nonneg</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">nat.zero_le</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span>\n</code></pre></div>\n<p>Is there a way to avoid proving this by proving equality of functions, it seems like a simple rewrite cannot \"enter the function\" and assume generic parameters to perform its rewrite?</p>",
        "id": 224608636,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612044910
    },
    {
        "content": "<p>Btw, your <code>mwe</code> is not a true <code>mwe</code>; you're missing imports. Adding <code>import data.real.basic</code> makes the code error-free. (It's not a huge deal but figuring out what imports need to be added is annoying.)</p>",
        "id": 224611372,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1612049208
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"355764\">Hanting Zhang</span> <a href=\"#narrow/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F/near/224611372\">said</a>:</p>\n<blockquote>\n<p>Btw, your <code>mwe</code> is not a true <code>mwe</code>; you're missing imports. Adding <code>import data.real.basic</code> makes the code error-free. (It's not a huge deal but figuring out what imports need to be added is annoying.)</p>\n</blockquote>\n<p>Sorry for that, I'll change it</p>",
        "id": 224611671,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612049672
    },
    {
        "content": "<p><code>simp</code> can enter binders like this</p>",
        "id": 224611699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612049755
    },
    {
        "content": "<p>The issue here seems to be that you are using a lemma that isn't suitable for simp; with <code>abs_mul</code> it works fine</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">mwe</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">):</span>\n  <span class=\"n\">list.sum</span> <span class=\"o\">(</span><span class=\"n\">l.map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">abs</span> <span class=\"o\">((</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">)))</span> <span class=\"bp\">=</span> <span class=\"n\">list.sum</span> <span class=\"o\">(</span><span class=\"n\">l.map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">abs_mul</span><span class=\"o\">,</span> <span class=\"n\">abs_pow</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 224611833,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612049996
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F/near/224611833\">said</a>:</p>\n<blockquote>\n<p>The issue here seems to be that you are using a lemma that isn't suitable for simp; with <code>abs_mul</code> it works fine</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">mwe</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">):</span>\n  <span class=\"n\">list.sum</span> <span class=\"o\">(</span><span class=\"n\">l.map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">abs</span> <span class=\"o\">((</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">)))</span> <span class=\"bp\">=</span> <span class=\"n\">list.sum</span> <span class=\"o\">(</span><span class=\"n\">l.map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">abs_mul</span><span class=\"o\">,</span> <span class=\"n\">abs_pow</span><span class=\"o\">]</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Alright, makes sense</p>",
        "id": 224612085,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612050400
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> what does it mean for a lemma to be suitable for <code>simp</code> ?<br>\ne.g. what makes <code>abs_mul</code> more suitable than <code>abv_mul</code> ?</p>",
        "id": 224612204,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612050610
    },
    {
        "content": "<p>the lhs of <code>abv_mul</code> starts with a variable, so there is no key</p>",
        "id": 224612293,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612050747
    },
    {
        "content": "<p>Ah alright, indeed, adding explicitly the absolute value makes it work in general context, thanks!</p>",
        "id": 224612298,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612050778
    },
    {
        "content": "<p>the fact that <code>abs_mul</code> is about the constant <code>abs</code> rather than an arbitrary absolute value like thing is what makes the difference</p>",
        "id": 224612305,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612050790
    },
    {
        "content": "<p>Hello again, I'm stuck on a le lemmas for lists, here's a MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.cau_seq</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.special_functions.pow</span>\n\n\n<span class=\"kd\">lemma</span> <span class=\"n\">list.le_map_with_index</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">canonically_linear_ordered_add_monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i_le</span><span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">l.length</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">l</span> <span class=\"n\">i</span> <span class=\"n\">i_le</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">g</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">list.nth_le</span> <span class=\"n\">l</span> <span class=\"n\">i</span> <span class=\"n\">i_le</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">l.map_with_index</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">l.map_with_index</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">mwe</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_abs</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span><span class=\"o\">):</span>\n<span class=\"n\">list.sum</span> <span class=\"o\">(</span><span class=\"n\">l.map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"bp\">*</span> <span class=\"o\">((</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n  <span class=\"bp\">≤</span> <span class=\"n\">list.sum</span> <span class=\"o\">(</span><span class=\"n\">l.map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I have an (ugly) proof of the <code>le_map_with_index</code> lemma, but it looks like for some reason (I suppose casts/coercions), I cannot apply it very well to this situation, I can convert from <code>h_abs</code> to the proper required hypothesis easily (and can add it), but a simple <code>apply</code> does not even work with an unification error</p>",
        "id": 224670306,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612133063
    },
    {
        "content": "<p>I would try to convert <code>map_with_index</code> to <code>zip_with</code> and then write some lemmas about how separable functions of <code>zip_with</code> are the same as some combination of <code>zip_with</code> of mapped lists</p>",
        "id": 224670350,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1612133157
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F/near/224670350\">said</a>:</p>\n<blockquote>\n<p>I would try to convert <code>map_with_index</code> to <code>zip_with</code> and then write some lemmas about how separable functions of <code>zip_with</code> are the same as some combination of <code>zip_with</code> of mapped lists</p>\n</blockquote>\n<p>Got it, I will try something</p>",
        "id": 224670657,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612133623
    },
    {
        "content": "<p>Almost there! What's the lemma you would use to solve that <code>le</code>-quality?</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.cau_seq</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.special_functions.pow</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.list.indexes</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">list.sum_ext_le</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ordered_add_comm_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hl</span> <span class=\"o\">:</span> <span class=\"n\">l.length</span> <span class=\"bp\">=</span> <span class=\"n\">l'.length</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hle</span><span class=\"o\">),</span> <span class=\"n\">l.nth_le</span> <span class=\"n\">i</span> <span class=\"n\">hle</span> <span class=\"bp\">≤</span> <span class=\"n\">l'.nth_le</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">hl</span> <span class=\"bp\">▸</span> <span class=\"n\">hle</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">l.sum</span> <span class=\"bp\">≤</span> <span class=\"n\">l'.sum</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">IH</span> <span class=\"n\">generalizing</span> <span class=\"n\">l'</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">l'</span> <span class=\"bp\">=</span> <span class=\"n\">list.nil</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">list.length_eq_zero</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hl.symm</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">l'</span> <span class=\"k\">with</span> <span class=\"n\">hd'</span> <span class=\"n\">tl'</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">hl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hl</span><span class=\"o\">,</span>\n      <span class=\"n\">simp_rw</span> <span class=\"n\">list.sum_cons</span><span class=\"o\">,</span>\n      <span class=\"n\">refine</span> <span class=\"n\">add_le_add</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">nat.zero_lt_succ</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">IH</span> <span class=\"n\">hl</span><span class=\"o\">,</span>\n        <span class=\"n\">intros</span> <span class=\"n\">i</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">nat.succ_lt_succ</span> <span class=\"n\">hi</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">list</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">zip_with_const_left</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">zip_with</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"n\">l'</span> <span class=\"bp\">=</span> <span class=\"n\">take</span> <span class=\"n\">l'.length</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">hl</span> <span class=\"n\">generalizing</span> <span class=\"n\">l'</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">l'</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hl</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">zip_with_const_right</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">zip_with</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"n\">l'</span> <span class=\"bp\">=</span> <span class=\"n\">take</span> <span class=\"n\">l.length</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">hl</span> <span class=\"n\">generalizing</span> <span class=\"n\">l'</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">l'</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hl</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">zip_with_separable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">α'</span> <span class=\"n\">β'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α'</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">β'</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">β'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">zip_with</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"n\">l</span> <span class=\"n\">l'</span> <span class=\"bp\">=</span> <span class=\"n\">zip_with</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">g</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">h</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">hl</span> <span class=\"n\">generalizing</span> <span class=\"n\">l'</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">l'</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hl</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">mwe</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_abs</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span><span class=\"o\">):</span>\n<span class=\"n\">list.sum</span> <span class=\"o\">(</span><span class=\"n\">l.map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"bp\">*</span> <span class=\"o\">((</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n  <span class=\"bp\">≤</span> <span class=\"n\">list.sum</span> <span class=\"o\">(</span><span class=\"n\">l.map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)),</span>\n    <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">clear</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">map_with_index_eq_enum_map_uncurry</span><span class=\"o\">,</span> <span class=\"n\">enum_eq_zip_range</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">zip_with_separable</span><span class=\"o\">],</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">take</span> <span class=\"n\">l.length</span> <span class=\"bp\">=</span> <span class=\"n\">take</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">pow</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">l.length</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">congr'</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">take_length</span><span class=\"o\">],</span> <span class=\"n\">clear</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">sum_ext_le</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">i</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">h_abs</span> <span class=\"o\">(</span><span class=\"n\">l.nth_le</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">hi</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">nth_le_mem</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span> <span class=\"c1\">-- I don't know the right le lemma here</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>",
        "id": 224673137,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1612137567
    },
    {
        "content": "<p>That's on your <a href=\"https://github.com/leanprover-community/mathlib/tree/raito-mapwithindex-list\">branch#raito-mapwithindex-list</a></p>",
        "id": 224673145,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1612137584
    },
    {
        "content": "<p>Wouldn't <code>le_abs_self</code> be the right lemma?</p>",
        "id": 224673361,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612137829
    },
    {
        "content": "<p>Something like, le_trans + le_abs_self + mul_le_mul_left and some simplification of *1</p>",
        "id": 224673434,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612137933
    },
    {
        "content": "<p>Hmm, annoyingly it will require to do case work on <code>b</code> pos with zero, unsure if there is a faster way</p>",
        "id": 224674103,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612139009
    },
    {
        "content": "<p>Thanks a lot though <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> !</p>",
        "id": 224674106,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612139019
    },
    {
        "content": "<p>Also, if you notice, your <code>h_abs</code> can be simplified to <code>a \\le 1</code>, because of course <code>a \\le abs a</code></p>",
        "id": 224674172,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1612139101
    },
    {
        "content": "<p>Indeed, because those are natural integers</p>",
        "id": 224674249,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612139224
    },
    {
        "content": "<p>I mean, that's true for anything <code>abs</code> is defined on: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/le_abs_self\">docs#le_abs_self</a></p>",
        "id": 224674337,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1612139374
    },
    {
        "content": "<p>Hmm, then the simplification is not always possible, right?<br>\nI mean, <code>a \\le 1</code> does not imply <code>abs a \\le 1</code> in general under the theorem: <code>a \\le abs a</code>, or am I too tired? :D</p>",
        "id": 224674415,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612139485
    },
    {
        "content": "<p>(counterexample: -5 \\le 1, though 5 \\ge 1 even though -5 \\le 5, right?)</p>",
        "id": 224674486,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612139552
    },
    {
        "content": "<p>I mean, here, you're always coercing from <code>nat</code>. So <code>abs (a : \\R)</code> must be <code>(a : \\R)</code></p>",
        "id": 224675181,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1612140509
    },
    {
        "content": "<p>So here is the final proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">mwe</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hle</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span><span class=\"o\">):</span>\n<span class=\"n\">list.sum</span> <span class=\"o\">(</span><span class=\"n\">l.map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"bp\">*</span> <span class=\"o\">((</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n  <span class=\"bp\">≤</span> <span class=\"n\">list.sum</span> <span class=\"o\">(</span><span class=\"n\">l.map_with_index</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)),</span>\n    <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">clear</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">map_with_index_eq_enum_map_uncurry</span><span class=\"o\">,</span> <span class=\"n\">enum_eq_zip_range</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">zip_with_separable</span><span class=\"o\">],</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">take</span> <span class=\"n\">l.length</span> <span class=\"bp\">=</span> <span class=\"n\">take</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">pow</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">l.length</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">congr'</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">take_length</span><span class=\"o\">],</span> <span class=\"n\">clear</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">sum_ext_le</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">i</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">l.nth_le</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">hi</span><span class=\"o\">),</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">this</span> <span class=\"o\">},</span>\n  <span class=\"n\">refine</span> <span class=\"n\">mul_le_mul</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">),</span>\n  <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">hle</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">nth_le_mem</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 224675191,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1612140530
    },
    {
        "content": "<p>As you can see, I changed the <code>h_abs</code> to <code>hle</code></p>",
        "id": 224675213,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1612140594
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F/near/224675181\">said</a>:</p>\n<blockquote>\n<p>I mean, here, you're always coercing from <code>nat</code>. So <code>abs (a : \\R)</code> must be <code>(a : \\R)</code></p>\n</blockquote>\n<p>Ah! I completely agree, yes</p>",
        "id": 224675263,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612140613
    },
    {
        "content": "<p>So even in the <code>l.map_with_index</code> lambda, you don't need the <code>abs</code>.</p>",
        "id": 224675331,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1612140719
    },
    {
        "content": "<p>Indeed, but this is only true in this \"minimum\" example, in general, I'm using arbitrary absolute values on which <code>abs a != a</code> even for nat, so I can only bound them through le_abv_self if I'm not wrong</p>",
        "id": 224675611,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612140991
    },
    {
        "content": "<p>Again, feel free to PR any of the lemmas. What was crucial here was to  prove some general lemmas about sums over lists, or about <code>zip_with</code>. The <code>zip_with_separable</code> allowed us to get it to a form where we can throw away oen of the lists. But it can't be a simp lemma because we have (in your branch, at least) <code>map_uncurry_zip_eq_zip_with</code> as a simp lemma. And Jannis's comment here: <a href=\"https://github.com/leanprover-community/mathlib/pull/5974#discussion_r567509308\">https://github.com/leanprover-community/mathlib/pull/5974#discussion_r567509308</a> indicates that it probably shouldn't be! Additionally, he also came up with <code>zip_with_separable</code>, but in reverse:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/pull/5974#discussion_r567508963\">https://github.com/leanprover-community/mathlib/pull/5974#discussion_r567508963</a></p>",
        "id": 224675707,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1612141098
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F/near/224675707\">said</a>:</p>\n<blockquote>\n<p>Again, feel free to PR any of the lemmas. What was crucial here was to  prove some general lemmas about sums over lists, or about <code>zip_with</code>. The <code>zip_with_separable</code> allowed us to get it to a form where we can throw away oen of the lists. But it can't be a simp lemma because we have (in your branch, at least) <code>map_uncurry_zip_eq_zip_with</code> as a simp lemma. And Jannis's comment here: <a href=\"https://github.com/leanprover-community/mathlib/pull/5974#discussion_r567509308\">https://github.com/leanprover-community/mathlib/pull/5974#discussion_r567509308</a> indicates that it probably shouldn't be! Additionally, he also came up with <code>zip_with_separable</code>, but in reverse:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/pull/5974#discussion_r567508963\">https://github.com/leanprover-community/mathlib/pull/5974#discussion_r567508963</a></p>\n</blockquote>\n<p>Sure thing! Thanks for the comments and insights, I missed the fact that Jannis reviewed the PR, will address those comments tomorrow hopefully</p>",
        "id": 224675804,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612141246
    },
    {
        "content": "<p>Therefore, as we removed the simp attribute on map-uncurry lemma, should I add the simp on <code>zip_with_map</code> <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> <span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> ?</p>",
        "id": 224726341,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612186700
    },
    {
        "content": "<p>I'd say yes. It's a bit specialised, but <code>zip_with</code> is not a common symbol so we won't run into performance issues.</p>",
        "id": 224739996,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1612192638
    },
    {
        "content": "<p>Alright, will do the change!</p>",
        "id": 224740203,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612192731
    },
    {
        "content": "<p>Done :)</p>",
        "id": 224740315,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612192788
    }
]
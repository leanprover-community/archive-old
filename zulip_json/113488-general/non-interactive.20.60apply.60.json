[
    {
        "content": "<p>Consider the following tactic block:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">lt_mul_iff_one_lt_right</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I would like to know how to write a non-interactive tactic <code>def foo (n : name) : tactic unit</code>, so that when it is passed <code>`lt_mul_iff_one_lt_right</code> for <code>n</code>, it implements exactly the first <code>apply</code> tactic invocation, producing precisely two subgoals.</p>\n<p>This function <code>foo</code> should work out how many explicit arguments <code>mk_const n</code> has, provide those as metavariables, check that the result is an <code>iff</code>, and then apply <code>iff.mpr</code>.</p>",
        "id": 230027842,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1615555649
    },
    {
        "content": "<p>My attempts so far are failing</p>",
        "id": 230027862,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1615555662
    },
    {
        "content": "<p>because when I introduce metavariables for the arguments of <code>lt_mul_iff_one_lt_right</code>, I can't help but produce too many, so by the time I have an expression ready to pass to <code>tactic.apply</code>, too many extra goals get generated (for the various implicit arguments).</p>",
        "id": 230028011,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1615555732
    },
    {
        "content": "<p>Is this too dumb?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">mpr_apply</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">applyc</span> <span class=\"bp\">`</span><span class=\"n\">iff.mpr</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">applyc</span> <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 230032506,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1615557651
    },
    {
        "content": "<p>Ah... I missed a major constraint: which is that this function has to actually build an <code>expr</code> to pass to a single <code>apply</code> call!</p>",
        "id": 230033992,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1615558191
    },
    {
        "content": "<p>I wonder if I can reverse engineer my expression by actually running your two <code>applyc</code> tactics, however (i.e. use the <code>show_term</code> trick).</p>",
        "id": 230034666,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1615558422
    },
    {
        "content": "<p>Hmm, no, if I time-travel back before the two <code>applyc</code> invocations, the new metavariables created by them will get stranded. :-(</p>",
        "id": 230035305,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1615558581
    },
    {
        "content": "<p>Uh, this might be an xy thing. I think it's safer to let <code>apply</code> create the mvars for you than to manually create the goals you need and build the expression for apply. But if that's really what you have to do, you could do something like this, where I haven't implemented <code>replace_mvars_with_fresh_ones</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">mpr_apply</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">t</span> <span class=\"bp\">←</span> <span class=\"n\">target</span><span class=\"o\">,</span>\n   <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">prod.snd</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"o\">(</span><span class=\"n\">solve_aux</span> <span class=\"n\">t</span> <span class=\"bp\">$</span> <span class=\"n\">applyc</span> <span class=\"bp\">`</span><span class=\"n\">iff.mpr</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">applyc</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">instantiate_mvars</span><span class=\"o\">,</span>\n   <span class=\"n\">trace</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n   <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">replace_mvars_with_fresh_ones</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n   <span class=\"n\">apply</span> <span class=\"n\">e</span> <span class=\"bp\">$&gt;</span> <span class=\"o\">()</span>\n</code></pre></div>",
        "id": 230037780,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1615559484
    },
    {
        "content": "<p>Using <code>apply</code> on an expr with handmade mvars doesn't add those mvars as goals, does it? Or am I misremembering?</p>",
        "id": 230039861,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1615560250
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span>, this is now failing in the opposite direction than my previous attempts. Here's what I have so far, filling out your solution:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">tactic</span> <span class=\"n\">expr</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">expr</span>\n\n<span class=\"sd\">/-- Implementation of `expr.mreplace`. -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">mreplace_aux</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">alternative</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">expr</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">app</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">app</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;|&gt;</span>\n  <span class=\"o\">(</span><span class=\"k\">do</span> <span class=\"n\">Rf</span> <span class=\"bp\">←</span> <span class=\"n\">mreplace_aux</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Rx</span> <span class=\"bp\">←</span> <span class=\"n\">mreplace_aux</span> <span class=\"n\">x</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">return</span> <span class=\"bp\">$</span> <span class=\"n\">app</span> <span class=\"n\">Rf</span> <span class=\"n\">Rx</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">lam</span> <span class=\"n\">nm</span> <span class=\"n\">bi</span> <span class=\"n\">ty</span> <span class=\"n\">bd</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">lam</span> <span class=\"n\">nm</span> <span class=\"n\">bi</span> <span class=\"n\">ty</span> <span class=\"n\">bd</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;|&gt;</span>\n  <span class=\"o\">(</span><span class=\"k\">do</span> <span class=\"n\">Rty</span> <span class=\"bp\">←</span> <span class=\"n\">mreplace_aux</span> <span class=\"n\">ty</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Rbd</span> <span class=\"bp\">←</span> <span class=\"n\">mreplace_aux</span> <span class=\"n\">bd</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">return</span> <span class=\"bp\">$</span> <span class=\"n\">lam</span> <span class=\"n\">nm</span> <span class=\"n\">bi</span> <span class=\"n\">Rty</span> <span class=\"n\">Rbd</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">pi</span> <span class=\"n\">nm</span> <span class=\"n\">bi</span> <span class=\"n\">ty</span> <span class=\"n\">bd</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">pi</span> <span class=\"n\">nm</span> <span class=\"n\">bi</span> <span class=\"n\">ty</span> <span class=\"n\">bd</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;|&gt;</span>\n  <span class=\"o\">(</span><span class=\"k\">do</span> <span class=\"n\">Rty</span> <span class=\"bp\">←</span> <span class=\"n\">mreplace_aux</span> <span class=\"n\">ty</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Rbd</span> <span class=\"bp\">←</span> <span class=\"n\">mreplace_aux</span> <span class=\"n\">bd</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">return</span> <span class=\"bp\">$</span> <span class=\"n\">pi</span> <span class=\"n\">nm</span> <span class=\"n\">bi</span> <span class=\"n\">Rty</span> <span class=\"n\">Rbd</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">elet</span> <span class=\"n\">nm</span> <span class=\"n\">ty</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">elet</span> <span class=\"n\">nm</span> <span class=\"n\">ty</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;|&gt;</span>\n  <span class=\"o\">(</span><span class=\"k\">do</span> <span class=\"n\">Rty</span> <span class=\"bp\">←</span> <span class=\"n\">mreplace_aux</span> <span class=\"n\">ty</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"n\">Ra</span> <span class=\"bp\">←</span> <span class=\"n\">mreplace_aux</span> <span class=\"n\">a</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"n\">Rb</span> <span class=\"bp\">←</span> <span class=\"n\">mreplace_aux</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"n\">return</span> <span class=\"bp\">$</span> <span class=\"n\">elet</span> <span class=\"n\">nm</span> <span class=\"n\">Rty</span> <span class=\"n\">Ra</span> <span class=\"n\">Rb</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">e</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">R</span> <span class=\"n\">e</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">return</span> <span class=\"n\">e</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Monadic equivalent of `expr.replace`.</span>\n\n<span class=\"sd\">The function `R` visits each subexpression `e`, and is called with `R e n`, where</span>\n<span class=\"sd\">`n` is the number of binders above `e`.</span>\n<span class=\"sd\">If `R e n` returns some value, `e` is replaced with that value (and `mreplace` does not visit</span>\n<span class=\"sd\">its subexpressions).</span>\n<span class=\"sd\">If `R e n` fails, the `mreplace` continues visiting subexpressions of `e`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">mreplace</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">alternative</span> <span class=\"n\">m</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span>\n<span class=\"n\">mreplace_aux</span> <span class=\"n\">R</span> <span class=\"n\">e</span> <span class=\"mi\">0</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Replace each metavariable in an expression with a fresh metavariable of the same type.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">refresh_mvars</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span>\n<span class=\"n\">e.mreplace</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">f.is_mvar</span> <span class=\"k\">then</span> <span class=\"n\">infer_type</span> <span class=\"n\">f</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">mk_meta_var</span> <span class=\"k\">else</span> <span class=\"n\">failed</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">expr</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Prepares a ``(n ___).mpr` expression that can be applied against the goal,</span>\n<span class=\"sd\">where `___` is however many `_`s are needed to obtain an `iff`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">iff_mpr_apply</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">t</span> <span class=\"bp\">←</span> <span class=\"n\">target</span><span class=\"o\">,</span>\n   <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">prod.snd</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"o\">(</span><span class=\"n\">solve_aux</span> <span class=\"n\">t</span> <span class=\"bp\">$</span> <span class=\"n\">applyc</span> <span class=\"bp\">`</span><span class=\"n\">iff.mpr</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">applyc</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">instantiate_mvars</span><span class=\"o\">,</span>\n   <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">e.refresh_mvars</span><span class=\"o\">,</span>\n   <span class=\"n\">return</span> <span class=\"n\">e.app_fn</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">lt_mul_iff_one_lt_right</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">iff_mpr_apply</span> <span class=\"bp\">`</span><span class=\"n\">lt_mul_iff_one_lt_right</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">trace</span><span class=\"o\">,</span> <span class=\"c1\">-- looks good: `(lt_mul_iff_one_lt_right ?m_1).mpr`</span>\n  <span class=\"n\">iff_mpr_apply</span> <span class=\"bp\">`</span><span class=\"n\">lt_mul_iff_one_lt_right</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">apply</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- but we only get one goal :-(</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 230139806,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1615615027
    },
    {
        "content": "<p>It seems <code>iff_mpr_apply</code> is producing exactly the expression we were hoping for. I'm just not working out how to get <code>apply</code> to do what I want!</p>",
        "id": 230140034,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1615615275
    },
    {
        "content": "<p>I think I'm having the opposite problem that you were worried about: I want <code>apply</code> to create new goals for these metavariables.</p>",
        "id": 230140114,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1615615341
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113488-general/topic/non-interactive.20.60apply.60/near/230140114\">said</a>:</p>\n<blockquote>\n<p>I think I'm having the opposite problem that you were worried about: I want <code>apply</code> to create new goals for these metavariables.</p>\n</blockquote>\n<p>Yeah, I get that's what you want, but it's not what <code>apply</code> does. Which is why this feels kind of xy to me -- you're trying to duplicate some of the behavior of <code>apply</code>, so that you can call <code>apply</code> in a way it's not really designed for.</p>",
        "id": 230159170,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1615637999
    },
    {
        "content": "<p>Instead of using <code>refresh_mvars</code> (and <code>e.app_fn</code>) you could lambda abstract the mvars in <code>e</code>. Then you get something you can apply.</p>",
        "id": 230159238,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1615638049
    },
    {
        "content": "<p>FYI there's a non-docstring comment on <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tactic.i_to_expr_for_apply/src\">src#tactic.i_to_expr_for_apply</a> that might be relevant here. At least pointing out that there are subtleties in doing this correctly</p>",
        "id": 230159430,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1615638259
    },
    {
        "content": "<p>Sorry -- to explain the <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> behind this, I am writing a tactic <code>tactify</code>, which eats a term mode proof and attempts to spit out a human-plausible tactic mode proof for it. (Why? Helpful for teaching what tactics do, and perhaps helpful for generating training data.)</p>\n<p>With the notable exception of proofs which use <code>cases</code>, <code>induction</code>, or pattern matching, this is actually pretty doable. (See <a href=\"https://github.com/leanprover-community/mathlib/tree/tactify\">branch#tactify</a>; it's extremely messy at the moment.)</p>\n<p>I'm at the point where I want to make some proofs more human-plausible. A very common pattern at the moment is that it spits out proof scripts that look like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">apply</span> <span class=\"n\">iff.mpr</span><span class=\"o\">,</span>\n<span class=\"n\">apply</span> <span class=\"n\">lt_mul_iff_one_lt_right</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>which no human in their right mind would write, because the first <code>apply</code> is unmotivated. Instead I want:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">lt_mul_iff_one_lt_right</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>The general way that <code>tactify</code> works is that it maintains a list of <code>solutions</code> for the current goals, and after inspecting the current solution for the main goal, it decides on a tactic to use, then runs that tactic and uses unification to generate the corresponding new list of solutions for the new goals.</p>\n<p>This means that I need to be able to simulate \"under the hood\" exactly the behaviour of the interactive mode tactic that I am going to propose in the tactic script. Hopefully this explains the xy!</p>\n<p>(As a general point, I think it's pretty important that we can reproduce in non-interactive tactics the exact behaviour of the interactive tactics, and I'm a bit sad to be struggling here --- perhaps if one could use antiquotations inside <code>`[...]</code> blocks we'd be okay.)</p>",
        "id": 230193719,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1615673852
    },
    {
        "content": "<p>I'm worried with your new suggestion (lamba abstract the mvars) I will have to generate the tactic step <code>apply (λ x, (lt_mul_iff_one_lt_right x).mpr</code>, which again does not look human-plausible.</p>",
        "id": 230193787,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1615673922
    }
]
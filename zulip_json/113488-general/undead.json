[
    {
        "content": "<p>\"Undead\" is a game from [Simon Tatham's portable puzzle collection] (<a href=\"https://www.chiark.greenend.org.uk/~sgtatham/puzzles/\" target=\"_blank\" title=\"https://www.chiark.greenend.org.uk/~sgtatham/puzzles/\">https://www.chiark.greenend.org.uk/~sgtatham/puzzles/</a>). These games are perfect information one player puzzle games, and often solving a level completely (for me at least, in most of these games) involves finding a constructive proof that there is precisely one solution to the level. I'm probably going to supervise a masters project this coming academic year on games like this, so I thought it was about time I understood what I could do with them in Lean.</p>\n<p>Here's a [pic of an undead level] (<a href=\"http://wwwf.imperial.ac.uk/~buzzard/xena/blog/undead_initial.png\" target=\"_blank\" title=\"http://wwwf.imperial.ac.uk/~buzzard/xena/blog/undead_initial.png\">http://wwwf.imperial.ac.uk/~buzzard/xena/blog/undead_initial.png</a>). The diagonal lines in some squares are (two-sided) mirrors. The vacant squares need to be each filled with exactly one of a vampire, ghost or zombie. There are 9 vacant squares and we're told at the top that we need to fill them with three ghosts, three vampires and three zombies. The numbers around the outside of the board are the number of monsters you can see if you look into the board from where the number is, with the caveat that you can't see a ghost directly and you can't see a vampire through a mirror. So for example, the zero on the top row, second from the left, indicates that you can't see the monster in the top left hand corner through a mirror, so it must be a vampire, and the 3 at the left of the top row indicates that exactly one of the monsters in the first column is a ghost (because you can only see three of the four monsters in that column).</p>\n<div class=\"message_inline_image\"><a href=\"http://wwwf.imperial.ac.uk/~buzzard/xena/blog/undead_initial.png\" target=\"_blank\" title=\"http://wwwf.imperial.ac.uk/~buzzard/xena/blog/undead_initial.png\"><img src=\"https://uploads.zulipusercontent.net/92ef1384545d96f90cc96adcb994bdac8caeb2a5/687474703a2f2f777777662e696d70657269616c2e61632e756b2f7e62757a7a6172642f78656e612f626c6f672f756e646561645f696e697469616c2e706e67\"></a></div><p>This sort of game is really easy to model in Lean; like mathematics, it seems to fit very gracefully into the language of dependent type theory. The nine empty squares can be thought of as 9 variables of type <code>square</code> (or type <code>monster</code> or whatever), the 16 numbers and three totals give 19 equations involving these variables, and the two main claims here are (1) that there's a solution to the equations and (2) it's unique.</p>\n<p>Here is a formalisation of the level in Lean, plus some preliminary lemmas.</p>\n<p><a href=\"https://gist.github.com/kbuzzard/53712d672a894d7b158a512f7aa5f836\" target=\"_blank\" title=\"https://gist.github.com/kbuzzard/53712d672a894d7b158a512f7aa5f836\">https://gist.github.com/kbuzzard/53712d672a894d7b158a512f7aa5f836</a></p>\n<p>The lemmas reduce the problem to the following position:</p>\n<div class=\"message_inline_image\"><a href=\"http://wwwf.imperial.ac.uk/~buzzard/xena/blog/undead.png\" target=\"_blank\" title=\"http://wwwf.imperial.ac.uk/~buzzard/xena/blog/undead.png\"><img src=\"https://uploads.zulipusercontent.net/1d14fa6dc9bea88e32196efc36215e0269995eb3/687474703a2f2f777777662e696d70657269616c2e61632e756b2f7e62757a7a6172642f78656e612f626c6f672f756e646561642e706e67\"></a></div><p>(and actually a little further because I worked out something about a7 after taking that screenshot). The search space initially has size 3^9, which is a bit big perhaps for Lean, but the lemmas I prove about the solution reduce the space to something like 2^7 * 3, which sounds a bit more reasonable. I think I'd now like to brute force it and get a proof that there's a unique solution, plus a description of the solution, but I'm not sure how to do that in Lean. I have these random facts like \"variable a6 isn't a vampire\" but I am not sure how to write the procedural code in Lean which will save me from generating a gazillion cases with a6 being a vampire. The issue is that I want to do cases on all 8 remaining variables at once, but for the variables where I've proved something I want to immediately eliminate all cases which contradict what I've proved. Am I making sense? I just want to solve the level now, in Lean, without running out of memory, and ideally I'd like to output the solution. I feel like I've done the lion's share of the work now but I've not quite finished.</p>",
        "id": 132629895,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535020548
    },
    {
        "content": "<p><code>@[derive decidable_eq]</code></p>",
        "id": 132630343,
        "sender_full_name": "Sean Leather",
        "timestamp": 1535021264
    },
    {
        "content": "<p>Oh yeah that was it :-) I derived it myself :-) I think I'd find it easier to remember that if I understood what was going on there. Is this the same as <code>@[simp]</code>? It doesn't look like it.</p>",
        "id": 132630393,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535021329
    },
    {
        "content": "<p><code>init/meta/derive.lean</code> says: “Attribute that can automatically derive typeclass instances.”</p>",
        "id": 132630465,
        "sender_full_name": "Sean Leather",
        "timestamp": 1535021421
    },
    {
        "content": "<p>Maybe that note will also help me remember the syntax. I don't use it very often, so I have to keep looking for it. But if I know that it's an attribute, I know it must be in <code>@[...]</code>.</p>",
        "id": 132630478,
        "sender_full_name": "Sean Leather",
        "timestamp": 1535021483
    },
    {
        "content": "<p>I'm working on square 7. After the line <code>  cases a₂;cases a₃;cases a₅;cases h₇;cases h₁₅,</code> in tactic mode, it's difficult for me to see what happened. Each of the a's has three possibilities, so after the three cases tactics there are now 27 goals. But for most of them (I think) there is a contradiction with assumptions h7 and h15, so after that entire line is processed we are back to one goal (unless I have misunderstood Lean's output). However I don't seem to be able to read off which of the cases we are in. Is there a trick for me to track which of the 27 branches survived?</p>",
        "id": 132655747,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535051891
    },
    {
        "content": "<p>Prove it's equivalent to proving <code>∃! (a₁ ∈ [vampire, ghost]) (a₂ ∈ [ghost, zmobie]) ...</code> and use dec_trivial. You might have to guide simp a bit, and prove lemmas like <code>a ! = zombie iff a = vampire or a = ghost</code></p>",
        "id": 132656912,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1535053641
    },
    {
        "content": "<p>Actually I am now confused about whether I have even done what I think I've done. Is this a bug? What happens if you type this into a Lean file:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">square</span>\n<span class=\"bp\">|</span> <span class=\"n\">vampire</span> <span class=\"o\">:</span> <span class=\"n\">square</span>\n<span class=\"bp\">|</span> <span class=\"n\">ghost</span> <span class=\"o\">:</span> <span class=\"n\">square</span>\n<span class=\"bp\">|</span> <span class=\"n\">zombie</span> <span class=\"o\">:</span> <span class=\"n\">square</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">square</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">a</span><span class=\"bp\">;</span><span class=\"n\">cases</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">c</span><span class=\"bp\">;</span><span class=\"n\">cases</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">sorry</span><span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>and then put your cursor just after the end comma in the <code>cases a;cases b,</code> line? I expect to see 9 goals but I only see one. Typing \"sorry\" makes the next one appear :-) Typing a few sorries eventually sorts things out and then it's back to 9 goals.</p>",
        "id": 132657067,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535053821
    },
    {
        "content": "<p>Even weirder:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">square</span>\n<span class=\"bp\">|</span> <span class=\"n\">vampire</span> <span class=\"o\">:</span> <span class=\"n\">square</span>\n<span class=\"bp\">|</span> <span class=\"n\">ghost</span> <span class=\"o\">:</span> <span class=\"n\">square</span>\n<span class=\"bp\">|</span> <span class=\"n\">zombie</span> <span class=\"o\">:</span> <span class=\"n\">square</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">square</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">a</span><span class=\"bp\">;</span><span class=\"n\">cases</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">c</span><span class=\"bp\">;</span><span class=\"n\">cases</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">sorry</span><span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>After the <code>b,</code> there are 9 cases, after the next sorry there are 8, and after the next one it drops to one. The others are still there, they're just not being displayed for some reason.</p>\n<div class=\"codehilite\"><pre><span></span>\n</pre></div>",
        "id": 132657172,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535053978
    },
    {
        "content": "<p>It seems to be being parsed as this</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">square</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">a</span><span class=\"bp\">;</span> <span class=\"o\">{</span><span class=\"n\">cases</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">c</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">sorry</span><span class=\"o\">}},</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 132657277,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1535054144
    },
    {
        "content": "<p>Actually not quite.</p>",
        "id": 132657330,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1535054187
    },
    {
        "content": "<p>I think the <code>;</code> just messes up the information on the current line.  If you put <code>skip,</code> on another line it shows the expected number of goals.</p>",
        "id": 132657422,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1535054303
    },
    {
        "content": "<p>Information about the goal is stored in a very unstructured form at the moment: essentially there is a function <code>tactic.save_info</code> which stores the corresponding string at a user-specified position (= line/column pair, and yes this can be almost anywhere..).</p>",
        "id": 132657546,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1535054458
    },
    {
        "content": "<p>If you put <code>skip</code> then on the line <em>before</em> the <code>skip</code> it displays correctly. So perhaps it's the second semicolon which is causing the confusion.</p>",
        "id": 132657821,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535054848
    },
    {
        "content": "<p>Yes, the semicolon seems to break the goal output between the surrounding commas.  If you add a <code>skip,</code> then you add a comma which keeps the breakage away.</p>",
        "id": 132657983,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1535055017
    },
    {
        "content": "<p>I've noticed repeatedly that using semi-colon is very confusing in this way</p>",
        "id": 132660215,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1535057736
    },
    {
        "content": "<p>About the general problem, isn't something that could be handled entirely by the type class system? It looks like problem designed for solving using prolog.</p>",
        "id": 132660271,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1535057778
    },
    {
        "content": "<p>i believe sebastian solved the n-queens problem using type classes</p>",
        "id": 132660854,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1535058481
    },
    {
        "content": "<p>this is really an abuse of inference I think :)</p>",
        "id": 132660967,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1535058605
    },
    {
        "content": "<blockquote>\n<p>Prove it's equivalent to proving <code>∃! (a₁ ∈ [vampire, ghost]) (a₂ ∈ [ghost, zmobie]) ...</code> and use dec_trivial. You might have to guide simp a bit, and prove lemmas like <code>a ! = zombie iff a = vampire or a = ghost</code></p>\n</blockquote>\n<p>So how does <code>dec_trivial</code> work? Does it look at hypotheses? Why doesn't this work:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">derive</span> <span class=\"n\">decidable_eq</span><span class=\"o\">]</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">square</span>\n<span class=\"bp\">|</span> <span class=\"n\">vampire</span> <span class=\"o\">:</span> <span class=\"n\">square</span>\n<span class=\"bp\">|</span> <span class=\"n\">ghost</span> <span class=\"o\">:</span> <span class=\"n\">square</span>\n<span class=\"bp\">|</span> <span class=\"n\">zombie</span> <span class=\"o\">:</span> <span class=\"n\">square</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">square</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">thing</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">square</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">vampire</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">ghost</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">zombie</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span> <span class=\"c1\">-- fails</span>\n</pre></div>\n\n\n<p>It looks pretty decidably trivial to me. How can I make this work?</p>",
        "id": 132661039,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535058721
    },
    {
        "content": "<p>Prove fintype square</p>",
        "id": 132661087,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1535058747
    },
    {
        "content": "<p><code>@[derive fintype]</code>?</p>",
        "id": 132661203,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535058952
    },
    {
        "content": "<p>look at my <code>three</code> elsewhere lol</p>",
        "id": 132661276,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1535059026
    },
    {
        "content": "<p>What is this derive? I see this from time to time but never know what it means</p>",
        "id": 132661277,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1535059030
    },
    {
        "content": "<p>What I wrote doesn't work.</p>",
        "id": 132661358,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535059142
    },
    {
        "content": "<p><code>failed to find a derive handler for 'fintype'</code></p>",
        "id": 132661371,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535059158
    },
    {
        "content": "<p>I believe the derive stuff is user-written extensions that add functionality to a type. like <code>@[derive decidable_eq]</code> adds an automatically generated instance saying that the type is decidable</p>",
        "id": 132661688,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1535059560
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">finset_square</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">square</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">vampire</span><span class=\"o\">,</span><span class=\"n\">ghost</span><span class=\"o\">,</span><span class=\"n\">zombie</span><span class=\"o\">],</span>\n  <span class=\"n\">nodup</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n    <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">constructor</span><span class=\"o\">,</span><span class=\"n\">intro</span> <span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">cases</span> <span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">exact</span> <span class=\"n\">dec_trivial</span><span class=\"o\">}},</span>\n    <span class=\"n\">constructor</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span>\n<span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">square</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">elems</span> <span class=\"o\">:=</span> <span class=\"n\">finset_square</span><span class=\"o\">,</span>\n  <span class=\"n\">complete</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span><span class=\"k\">by</span> <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"bp\">;</span><span class=\"n\">exact</span> <span class=\"n\">dec_trivial</span>\n<span class=\"o\">}</span>\n</pre></div>\n\n\n<p>:-)</p>",
        "id": 132661874,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535059778
    },
    {
        "content": "<p>I reckon that could be automated...</p>",
        "id": 132661922,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535059804
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">three</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">elems</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">C</span><span class=\"o\">},</span>\n  <span class=\"n\">complete</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n</pre></div>\n\n\n<p>Kenny's <code>three</code></p>",
        "id": 132661973,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535059882
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">fintype</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">derive</span> <span class=\"n\">decidable_eq</span><span class=\"o\">]</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">square</span>\n<span class=\"bp\">|</span> <span class=\"n\">vampire</span> <span class=\"o\">:</span> <span class=\"n\">square</span>\n<span class=\"bp\">|</span> <span class=\"n\">ghost</span> <span class=\"o\">:</span> <span class=\"n\">square</span>\n<span class=\"bp\">|</span> <span class=\"n\">zombie</span> <span class=\"o\">:</span> <span class=\"n\">square</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">square</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">square</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">elems</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">vampire</span><span class=\"o\">,</span><span class=\"n\">ghost</span><span class=\"o\">,</span><span class=\"n\">zombie</span><span class=\"o\">},</span>\n  <span class=\"n\">complete</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span><span class=\"k\">by</span> <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"bp\">;</span><span class=\"n\">exact</span> <span class=\"n\">dec_trivial</span>\n<span class=\"o\">}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">square</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">thing2</span> <span class=\"o\">:</span> <span class=\"bp\">∃!</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">square</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">vampire</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span> <span class=\"c1\">-- fails</span>\n</pre></div>\n\n\n<p>That looks pretty trivial too. Error is</p>\n<div class=\"codehilite\"><pre><span></span>failed to synthesize type class instance for\n⊢ decidable (∃! (a : square), a = vampire)\n</pre></div>",
        "id": 132662313,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535060387
    },
    {
        "content": "<p>you need to import something iirc</p>",
        "id": 132662380,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1535060442
    },
    {
        "content": "<p><code>unfold exists_unique</code> first</p>",
        "id": 132662383,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1535060448
    },
    {
        "content": "<p>rofl I just tried it for the actual problem and I got this error: <a href=\"https://gist.github.com/kbuzzard/84dbdf0fab4b96148099f49ac4f1770e\" target=\"_blank\" title=\"https://gist.github.com/kbuzzard/84dbdf0fab4b96148099f49ac4f1770e\">https://gist.github.com/kbuzzard/84dbdf0fab4b96148099f49ac4f1770e</a> . I think I've seen this before when you do exists_unique with multiple variables, it unfolds to something quite unwieldy.</p>",
        "id": 132662611,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535060738
    },
    {
        "content": "<p>nice goal!</p>",
        "id": 132662675,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1535060788
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">exists_unique</span><span class=\"o\">,</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">∃ (x : ℕ),</span>\n<span class=\"cm\">    (∃ (x_1 : ℕ),</span>\n<span class=\"cm\">         (∃ (x_2 : ℕ), x + x_1 + x_2 = 0 ∧ ∀ (y : ℕ), x + x_1 + y = 0 → y = x_2) ∧</span>\n<span class=\"cm\">           ∀ (y : ℕ),</span>\n<span class=\"cm\">             (∃ (x_1 : ℕ), x + y + x_1 = 0 ∧ ∀ (y_1 : ℕ), x + y + y_1 = 0 → y_1 = x_1) → y = x_1) ∧</span>\n<span class=\"cm\">      ∀ (y : ℕ),</span>\n<span class=\"cm\">        (∃ (x : ℕ),</span>\n<span class=\"cm\">           (∃ (x_1 : ℕ), y + x + x_1 = 0 ∧ ∀ (y_1 : ℕ), y + x + y_1 = 0 → y_1 = x_1) ∧</span>\n<span class=\"cm\">             ∀ (y_1 : ℕ),</span>\n<span class=\"cm\">               (∃ (x : ℕ), y + y_1 + x = 0 ∧ ∀ (y_2 : ℕ), y + y_1 + y_2 = 0 → y_2 = x) → y_1 = x) →</span>\n<span class=\"cm\">        y = x</span>\n<span class=\"cm\">-/</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 132662688,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535060813
    },
    {
        "content": "<p>Does it have to do that? Why not just \"exists a b c, a + b + c = 0 and forall a' b' c', a' + b' + c' = 0 implies a=a' and b=b' and c=c'\"?</p>",
        "id": 132662703,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535060845
    },
    {
        "content": "<p>It's parsed as a load of nested <code>exists_uniques</code>. I imagine your definition is quite hard to write</p>",
        "id": 132662959,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1535061203
    },
    {
        "content": "<p>Wait, does it even mean the right thing then?</p>",
        "id": 132663069,
        "sender_full_name": "Reid Barton",
        "timestamp": 1535061345
    },
    {
        "content": "<p>Isn't this \"there exists a unique a such that there exists a unique b such that ...\", but maybe for some other a there's multiple b's which would work, and so there isn't actually a unique (a,b,c)</p>",
        "id": 132663141,
        "sender_full_name": "Reid Barton",
        "timestamp": 1535061479
    },
    {
        "content": "<p>Say <code>P x y</code> holds if and only if (x, y) is (1, 2) or (3, 4) or (3, 5). Then <code>∃! x y, P x y = ∃! x, ∃! y, P x y</code> is true because <code>∃! y, P x y</code> holds only for x = 1.</p>",
        "id": 132663480,
        "sender_full_name": "Reid Barton",
        "timestamp": 1535061898
    },
    {
        "content": "<p>But I'm sure what you really wanted is <code>∃! p, P p.1 p.2</code>.</p>",
        "id": 132663491,
        "sender_full_name": "Reid Barton",
        "timestamp": 1535061926
    },
    {
        "content": "<p>That's a pretty nasty trap</p>",
        "id": 132663542,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1535061972
    },
    {
        "content": "<p><em>makes note to remove this \"feature\" as soon as possible</em></p>",
        "id": 132663616,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1535062138
    },
    {
        "content": "<p>I think I once tried to prove exactly the goal above and decided at the end of it that it seemed to be an extremely roundabout way of saying the correct thing.</p>",
        "id": 132663779,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535062420
    },
    {
        "content": "<p>I think it unfolds to something more complicated than what Reid is suggesting.</p>",
        "id": 132663910,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535062629
    },
    {
        "content": "<p>In particular I'm suggesting that Chris' comment is oversimplifying the matter.</p>",
        "id": 132663916,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535062664
    },
    {
        "content": "<p>Here's an example of an intermediate goal that you have to prove when proving the exists_unique statement above:</p>\n<div class=\"codehilite\"><pre><span></span>y : ℕ,\nh : ∃ (x : ℕ), 0 + y + x = 0 ∧ ∀ (y_1 : ℕ), 0 + y + y_1 = 0 → y_1 = x\n⊢ y = 0\n</pre></div>",
        "id": 132663971,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535062726
    },
    {
        "content": "<p>This is after you set a and b to 0, right?</p>",
        "id": 132664036,
        "sender_full_name": "Reid Barton",
        "timestamp": 1535062844
    },
    {
        "content": "<p>You shouldn't be given the <code>∀ (y_1 : ℕ), 0 + y + y_1 = 0 → y_1 = x</code> part of the hypothesis</p>",
        "id": 132664041,
        "sender_full_name": "Reid Barton",
        "timestamp": 1535062861
    },
    {
        "content": "<p>I think. Actually staring at this is making me confused.</p>",
        "id": 132664053,
        "sender_full_name": "Reid Barton",
        "timestamp": 1535062894
    },
    {
        "content": "<p>But in general, the way that Lean interprets <code>∃! x y, ...</code> is as <code>∃! x, ∃! y, ...</code>, right?</p>",
        "id": 132664101,
        "sender_full_name": "Reid Barton",
        "timestamp": 1535062926
    },
    {
        "content": "<blockquote>\n<p>Description: An alternate definition of double existential uniqueness (see 2eu4 2371). A mistake sometimes made in the literature is to use ∃!𝑥∃!𝑦 to mean \"exactly one 𝑥 and exactly one 𝑦.\" (For example, see Proposition 7.53 of [TakeutiZaring] p. 53.) It turns out that this is actually a weaker assertion, as can be seen by expanding out the formal definitions. This theorem shows that the erroneous definition can be repaired by conjoining ∀𝑥∃* 𝑦𝜑 as an additional condition. The correct definition apparently has never been published. (∃* means \"exists at most one.\")</p>\n</blockquote>\n<p><a href=\"http://us.metamath.org/mpeuni/2eu5.html\" target=\"_blank\" title=\"http://us.metamath.org/mpeuni/2eu5.html\">http://us.metamath.org/mpeuni/2eu5.html</a></p>",
        "id": 132664341,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1535063366
    },
    {
        "content": "<p>You want to prove (0, 0, 0) is the unique solution (let's say). Then you ought to be able to prove</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">),</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"err\">⊢</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</pre></div>",
        "id": 132664344,
        "sender_full_name": "Reid Barton",
        "timestamp": 1535063371
    },
    {
        "content": "<p>the simplest way to assert multiple existential uniqueness is to claim unique existence of a triple</p>",
        "id": 132664437,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1535063491
    },
    {
        "content": "<p>also: why are you using lean as a sat solver? It's not particularly smart for this</p>",
        "id": 132664553,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1535063694
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> you might like this challenge:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">∧</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃!</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>Mario -- did I get this right? I just spent 15 minutes on it and failed to do one way; I don't want to waste Kenny's time. </p>\n<p>I'm using Lean as a whatever-you-said because I'm trying to figure out what can and can't and should be done using Lean when it comes to puzzles like this.</p>",
        "id": 132665771,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535065677
    },
    {
        "content": "<p>as Reid points out, as well as the quote I gave, that theorem is false</p>",
        "id": 132665962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1535065971
    },
    {
        "content": "<p>There are other tools out there which are a better fit for these kinds of constraint satisfaction problems. One of which even shares an author with Lean.</p>",
        "id": 132666080,
        "sender_full_name": "Reid Barton",
        "timestamp": 1535066166
    },
    {
        "content": "<p>right, I just went back to it and figured that it couldn't possibly be provable.</p>",
        "id": 132666081,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535066176
    },
    {
        "content": "<p>However, you can't beat the convenience of already knowing the input language.</p>",
        "id": 132666088,
        "sender_full_name": "Reid Barton",
        "timestamp": 1535066196
    },
    {
        "content": "<p>In which case I don't understand what this exists_unique even means.</p>",
        "id": 132666093,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535066202
    },
    {
        "content": "<p>I could solve this undead puzzle in python just with some dull loop. I was trying to work out what Lean could offer me that python couldn't.</p>",
        "id": 132666142,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535066283
    },
    {
        "content": "<p>So Lean really does do what Chris says? \"There exists a unique x such that there exists a unique y such that...\"? That's not what I would have guessed from the notation.</p>",
        "id": 132666168,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535066373
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>example : ¬ ∀ (p : ℕ → ℕ → Prop),\n  (∃ m n, p m n ∧ (∀ b c : ℕ, p b c → b = m ∧ c = n)) ↔ ∃! m n : ℕ, p m n :=\nλ H, begin\n  let p := λ m n, m = 0 → n = 0,\n  have : ∃! m n : ℕ, p m n,\n  { refine ⟨0, ⟨0, λ _, rfl, λ n h, h rfl⟩, λ m h, _⟩,\n    rcases h with ⟨m&#39;, h₁, h₂⟩,\n    by_contra h,\n    have := h₂ 1 h.elim,\n    rw ← h₂ 0 (λ _, rfl) at this,\n    cases this },\n  rcases (H _).2 this with ⟨m, n, h₁, h₂⟩,\n  simpa [(h₂ 0 0 id).1.symm] using h₂ 1 1 id\nend\n</pre></div>",
        "id": 132666375,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1535066701
    },
    {
        "content": "<p>this is what all nested binders are unfolded to in lean</p>",
        "id": 132666391,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1535066728
    },
    {
        "content": "<p>in most cases it works brilliantly - forall, exists, indexed union, supremum, infinite sum... it is only exists unique which doesn't have a nice interpretation</p>",
        "id": 132666452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1535066794
    },
    {
        "content": "<p>rofl</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">silly</span> <span class=\"o\">:</span> <span class=\"bp\">∃!</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">existsi</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"n\">existsi</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"n\">left</span><span class=\"o\">,</span><span class=\"n\">exact</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"n\">intro</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">H</span><span class=\"o\">,</span><span class=\"n\">exact</span> <span class=\"n\">H</span><span class=\"o\">,</span><span class=\"n\">cases</span> <span class=\"n\">H</span><span class=\"o\">,</span><span class=\"n\">cases</span> <span class=\"n\">H</span><span class=\"o\">,</span><span class=\"n\">cases</span> <span class=\"n\">H_left</span><span class=\"o\">,</span><span class=\"n\">cases</span> <span class=\"n\">H</span><span class=\"o\">,</span><span class=\"n\">cases</span> <span class=\"n\">H_left</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">y</span> <span class=\"n\">Hy</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">p</span> <span class=\"n\">at</span> <span class=\"n\">Hy</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">Hy</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">Hx</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">Hx</span> <span class=\"k\">with</span> <span class=\"n\">H</span> <span class=\"n\">H1</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">H</span><span class=\"o\">,</span><span class=\"n\">exact</span> <span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">H</span><span class=\"o\">,</span><span class=\"n\">cases</span> <span class=\"n\">H</span> <span class=\"k\">with</span> <span class=\"n\">Hy</span> <span class=\"n\">Hx</span><span class=\"o\">,</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">H1</span><span class=\"o\">,</span><span class=\"n\">rw</span> <span class=\"n\">Hx</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"n\">H1</span> <span class=\"mi\">4</span><span class=\"o\">,</span>\n  <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"mi\">4</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span><span class=\"o\">,</span>\n    <span class=\"n\">revert</span> <span class=\"n\">this</span><span class=\"o\">,</span><span class=\"n\">exact</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">H</span><span class=\"o\">,</span><span class=\"n\">rw</span> <span class=\"n\">Hy</span><span class=\"o\">,</span><span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">H</span> <span class=\"k\">with</span> <span class=\"n\">Hy</span> <span class=\"n\">Hx</span><span class=\"o\">,</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">H1</span><span class=\"o\">,</span><span class=\"n\">rw</span> <span class=\"n\">Hx</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"n\">H1</span> <span class=\"mi\">3</span><span class=\"o\">,</span>\n  <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"o\">,</span>\n    <span class=\"n\">revert</span> <span class=\"n\">this</span><span class=\"o\">,</span><span class=\"n\">exact</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">H</span><span class=\"o\">,</span><span class=\"n\">rw</span> <span class=\"n\">Hy</span><span class=\"o\">,</span><span class=\"n\">simp</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 132666531,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535066958
    },
    {
        "content": "<p>I had no idea <code>∃!</code> meant that in Lean. That is for me a very surprising design decision. <code>∃! a b</code> doesn't even mean the same as <code>∃! b a</code>, right?</p>",
        "id": 132666593,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535067010
    },
    {
        "content": "<p>no, they are not logically equivalent</p>",
        "id": 132666599,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1535067033
    },
    {
        "content": "<p>frankly the problem is that <code>∃!</code> is a shitty binder notation</p>",
        "id": 132666608,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1535067058
    },
    {
        "content": "<p>wo</p>",
        "id": 132666610,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535067059
    },
    {
        "content": "<p>w</p>",
        "id": 132666611,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535067060
    },
    {
        "content": "<p>it's not monotone</p>",
        "id": 132666618,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1535067073
    },
    {
        "content": "<p>So in fact the thing I'm trying to prove with this undead thing is not even formulated correctly.</p>",
        "id": 132666626,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535067099
    },
    {
        "content": "<p>like I said, the easy way to say this without having to think much is to use exists unique in a pair type</p>",
        "id": 132666669,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1535067136
    },
    {
        "content": "<p>I don't care what Lean thinks <code>∃!</code> means. All I want to say is that there exists a unique 9-tuple with some property, and I've just realised that I'd better spell it out rather than using this terrifying notation.</p>",
        "id": 132666698,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535067203
    },
    {
        "content": "<p>I wonder if any of the mathematicians here can find a mathematician who thinks <code>∃! a b, p a b</code> means anything other than what I suggested it meant above with that false lemma.</p>",
        "id": 132666757,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535067266
    },
    {
        "content": "<p>I see. The reason this has happened is that Lean has one inbuilt system for dealing with multiple variables with one binder, and to put it bluntly it doesn't work with this one, so really perhaps a different system should be used for this one binder and that might be what Sebastian was saying. Maybe I've caught up at last.</p>",
        "id": 132666837,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535067377
    },
    {
        "content": "<blockquote>\n<p>I wonder if any of the mathematicians here can find a mathematician who thinks ∃! a b, p a b means anything other than what I suggested it meant above with that false lemma.</p>\n</blockquote>\n<p>Most mathematicians think ∃! a b, p a b means what you wrote. They also think that ∃! a, ∃! b, p a b encodes this statement, and they are wrong</p>",
        "id": 132666999,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1535067702
    },
    {
        "content": "<p>it is obvious once you give it more than a cursory examination, but it's one of those things that often escapes notice</p>",
        "id": 132667051,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1535067745
    },
    {
        "content": "<blockquote>\n<p>Most mathematicians think ∃! a b, p a b means what you wrote. They also think that ∃! a, ∃! b, p a b encodes this statement, and they are wrong</p>\n</blockquote>\n<p>I don't think I'd ever even considered the concept <code>∃! a, ∃! b, p a b</code> until this evening and I suspect that many mathematicians would also not have come across it. It looks very weird to me. Of course, hindsight is a wonderful thing...</p>",
        "id": 132667177,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535068002
    }
]
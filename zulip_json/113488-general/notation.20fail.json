[
    {
        "content": "<p>I am in a situation where this term compiles fine:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"err\">𝒞</span><span class=\"bp\">.</span><span class=\"n\">equiv</span> <span class=\"o\">(</span><span class=\"n\">locally_ringed_valued_space</span><span class=\"bp\">.</span><span class=\"n\">to_</span><span class=\"err\">𝒞</span><span class=\"bp\">.</span><span class=\"n\">restrict</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"err\">𝒞</span><span class=\"bp\">.</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">))</span>\n</pre></div>\n\n\n<p>but if I put</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">notation</span> <span class=\"n\">A</span> <span class=\"bp\">`</span> <span class=\"err\">≅</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"err\">𝒞</span><span class=\"bp\">.</span><span class=\"n\">equiv</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>and try </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"o\">(</span><span class=\"n\">locally_ringed_valued_space</span><span class=\"bp\">.</span><span class=\"n\">to_</span><span class=\"err\">𝒞</span><span class=\"bp\">.</span><span class=\"n\">restrict</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"err\">≅</span> <span class=\"o\">(</span><span class=\"err\">𝒞</span><span class=\"bp\">.</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>I get the error</p>\n<div class=\"codehilite\"><pre><span></span>type mismatch at application\n  (λ (x_1 : 𝒞 ↥U) (x_2 : 𝒞 ?m_1[x_1]), x_1 ≅ x_2)\n    (𝒞.restrict U (𝒱.to_𝒞 locally_ringed_valued_space))\n    (𝒞.Spa A)\nterm\n  𝒞.Spa A\nhas type\n  𝒞 ↥(Spa A) : Type (?+1)\nbut is expected to have type\n  𝒞 ?m_1[𝒞.restrict U (𝒱.to_𝒞 locally_ringed_valued_space)] : Type (max ? (?+1))\n</pre></div>\n\n\n<p>Similarly if I switch the two terms around I get</p>\n<div class=\"codehilite\"><pre><span></span>type mismatch at application\n  (λ (x_1 : 𝒞 ↥(Spa A)) (x_2 : 𝒞 ?m_1[x_1]), x_1 ≅ x_2) (𝒞.Spa A)\n    (𝒞.restrict U (𝒱.to_𝒞 locally_ringed_valued_space))\nterm\n  𝒞.restrict U (𝒱.to_𝒞 locally_ringed_valued_space)\nhas type\n  𝒞 ↥U : Type (max u (?+1))\nbut is expected to have type\n  𝒞 ?m_1[𝒞.Spa A] : Type (max ? (?+1))\n</pre></div>\n\n\n<p>Is this a limitation of notation somehow? I'd be surprised -- I'd be more likely to believe that I'm not using it correctly or I've made some other error. If notation is just syntactic sugar then as far as I can see the thing that's failing just directly translates into the thing that's succeeding.</p>",
        "id": 164352552,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556397451
    },
    {
        "content": "<p>Oh! I've got to the bottom of it and it's part of the story which I didn't mention. The <code>\\iso</code> notation is overloaded, and for some reason Lean isn't trying as hard to unify because it is not sure which function I mean. If I change my notation to an un-overloaded one then it works.</p>",
        "id": 164352698,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556397636
    },
    {
        "content": "<p>I guess Lean is being more cautious in trying to unify because it doesn't want to end up spending a lot of time trying to typecheck something which doesn't typecheck, or something.</p>",
        "id": 164352714,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556397684
    }
]
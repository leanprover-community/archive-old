[
    {
        "content": "<p>I am in a situation where this term compiles fine:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"err\">ğ’</span><span class=\"bp\">.</span><span class=\"n\">equiv</span> <span class=\"o\">(</span><span class=\"n\">locally_ringed_valued_space</span><span class=\"bp\">.</span><span class=\"n\">to_</span><span class=\"err\">ğ’</span><span class=\"bp\">.</span><span class=\"n\">restrict</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"err\">ğ’</span><span class=\"bp\">.</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">))</span>\n</pre></div>\n\n\n<p>but if I put</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">notation</span> <span class=\"n\">A</span> <span class=\"bp\">`</span> <span class=\"err\">â‰…</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"err\">ğ’</span><span class=\"bp\">.</span><span class=\"n\">equiv</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>and try </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"o\">(</span><span class=\"n\">locally_ringed_valued_space</span><span class=\"bp\">.</span><span class=\"n\">to_</span><span class=\"err\">ğ’</span><span class=\"bp\">.</span><span class=\"n\">restrict</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"err\">â‰…</span> <span class=\"o\">(</span><span class=\"err\">ğ’</span><span class=\"bp\">.</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>I get the error</p>\n<div class=\"codehilite\"><pre><span></span>type mismatch at application\n  (Î» (x_1 : ğ’ â†¥U) (x_2 : ğ’ ?m_1[x_1]), x_1 â‰… x_2)\n    (ğ’.restrict U (ğ’±.to_ğ’ locally_ringed_valued_space))\n    (ğ’.Spa A)\nterm\n  ğ’.Spa A\nhas type\n  ğ’ â†¥(Spa A) : Type (?+1)\nbut is expected to have type\n  ğ’ ?m_1[ğ’.restrict U (ğ’±.to_ğ’ locally_ringed_valued_space)] : Type (max ? (?+1))\n</pre></div>\n\n\n<p>Similarly if I switch the two terms around I get</p>\n<div class=\"codehilite\"><pre><span></span>type mismatch at application\n  (Î» (x_1 : ğ’ â†¥(Spa A)) (x_2 : ğ’ ?m_1[x_1]), x_1 â‰… x_2) (ğ’.Spa A)\n    (ğ’.restrict U (ğ’±.to_ğ’ locally_ringed_valued_space))\nterm\n  ğ’.restrict U (ğ’±.to_ğ’ locally_ringed_valued_space)\nhas type\n  ğ’ â†¥U : Type (max u (?+1))\nbut is expected to have type\n  ğ’ ?m_1[ğ’.Spa A] : Type (max ? (?+1))\n</pre></div>\n\n\n<p>Is this a limitation of notation somehow? I'd be surprised -- I'd be more likely to believe that I'm not using it correctly or I've made some other error. If notation is just syntactic sugar then as far as I can see the thing that's failing just directly translates into the thing that's succeeding.</p>",
        "id": 164352552,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556397451
    },
    {
        "content": "<p>Oh! I've got to the bottom of it and it's part of the story which I didn't mention. The <code>\\iso</code> notation is overloaded, and for some reason Lean isn't trying as hard to unify because it is not sure which function I mean. If I change my notation to an un-overloaded one then it works.</p>",
        "id": 164352698,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556397636
    },
    {
        "content": "<p>I guess Lean is being more cautious in trying to unify because it doesn't want to end up spending a lot of time trying to typecheck something which doesn't typecheck, or something.</p>",
        "id": 164352714,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556397684
    }
]
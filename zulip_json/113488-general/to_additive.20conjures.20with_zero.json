[
    {
        "content": "<p>Here is a somewhat mwe of a weird <code>to_additive</code> issue I am hitting. Why is it erroring with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"bp\">@</span><span class=\"n\">linear_ordered_add_comm_monoid.to_ordered_add_comm_monoid</span> <span class=\"n\">α</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">linear_ordered_comm_monoid_with_zero.to_linear_ordered_comm_monoid</span> <span class=\"n\">α</span> <span class=\"n\">_inst_1</span><span class=\"o\">)</span>\n<span class=\"n\">term</span>\n  <span class=\"bp\">@</span><span class=\"n\">linear_ordered_comm_monoid_with_zero.to_linear_ordered_comm_monoid</span> <span class=\"n\">α</span> <span class=\"n\">_inst_1</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">linear_ordered_comm_monoid</span> <span class=\"n\">α</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">linear_ordered_add_comm_monoid</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>My proofs don't even mention any <code>α</code>, nor does the sorried proof below talk about any order on <code>S</code> itself...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.order.with_zero</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- use `x * pnpow_rec n x` and not `pnpow_rec n x * x` in the definition to make sure that</span>\n<span class=\"c1\">-- definitional unfolding of `pnpow_rec` is blocked, to avoid deep recursion issues.</span>\n<span class=\"sd\">/-- The fundamental power operation in a monoid. `pnpow_rec n a = a*a*...*a` n times.</span>\n<span class=\"sd\">Use instead `a ^ n`,  which has better definitional behavior. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">pnpow_rec</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">pnat.rec_on</span> <span class=\"n\">n</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- The fundamental scalar multiplication in an additive monoid. `pnsmul_rec n a = a+a+...+a` n</span>\n<span class=\"sd\">times. Use instead `n • a`, which has better definitional behavior. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">pnsmul_rec</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">pnat.rec_on</span> <span class=\"n\">n</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">to_additive</span> <span class=\"n\">pnsmul_rec</span><span class=\"o\">]</span> <span class=\"n\">pnpow_rec</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">has_mul.has_pow</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_pow</span> <span class=\"n\">M</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">pnpow_rec</span> <span class=\"n\">n</span> <span class=\"n\">x</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">has_add.has_scalar_pnat</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">pnsmul_rec</span><span class=\"o\">⟩</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">to_additive</span> <span class=\"n\">has_add.has_scalar_pnat</span><span class=\"o\">]</span> <span class=\"n\">has_mul.has_pow</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[to_additive is_infinite_add_order]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_infinite_order</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"n\">j</span>\n\n<span class=\"kd\">@[to_additive quasi_add_idempotent]</span>\n<span class=\"kd\">def</span> <span class=\"n\">quasi_idempotent</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">n'</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">),</span> <span class=\"n\">n'</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">set.inj_on</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set.Iic</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">),</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">@[to_additive is_infinite_add_order_or_quasi_add_idempotent]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">is_infinite_order_or_quasi_idempotent</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semigroup</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_infinite_order</span> <span class=\"n\">x</span> <span class=\"bp\">∨</span> <span class=\"n\">quasi_idempotent</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">or_iff_not_imp_left.mpr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"n\">is_infinite_order</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">push_neg</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span> <span class=\"bp\">∧</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">j</span> <span class=\"bp\">∧</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"n\">i.to_pnat'</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"n\">j.to_pnat'</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">hj</span><span class=\"o\">⟩,</span> <span class=\"n\">hne</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">hj</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">hne</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">h</span><span class=\"bp\">;</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">subtype.ext_iff</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">hj</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">set</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">nat.find</span> <span class=\"n\">h'</span> <span class=\"k\">with</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h''</span> <span class=\"o\">:=</span> <span class=\"n\">nat.find_spec</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">set.inj_on</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set.Iic</span> <span class=\"n\">i.to_pnat'</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">hm'</span><span class=\"o\">⟩</span> <span class=\"n\">hm</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">hn'</span><span class=\"o\">⟩</span> <span class=\"n\">hn</span> <span class=\"n\">hmn</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">nat.exists_eq_succ_of_ne_zero</span> <span class=\"n\">hm'.ne'</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">nat.exists_eq_succ_of_ne_zero</span> <span class=\"n\">hn'.ne'</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_Iic</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">pnat.coe_le_coe</span><span class=\"o\">,</span> <span class=\"n\">pnat.mk_coe</span><span class=\"o\">,</span> <span class=\"n\">nat.le_find_iff</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">not_exists</span><span class=\"o\">,</span>\n               <span class=\"n\">not_and</span><span class=\"o\">,</span> <span class=\"n\">nat.to_pnat'_coe</span><span class=\"o\">,</span> <span class=\"n\">nat.find_pos</span><span class=\"o\">,</span> <span class=\"n\">not_lt_zero'</span><span class=\"o\">,</span> <span class=\"n\">false_and</span><span class=\"o\">,</span> <span class=\"n\">exists_false</span><span class=\"o\">,</span>\n               <span class=\"n\">not_false_iff</span><span class=\"o\">,</span> <span class=\"n\">if_true</span><span class=\"o\">,</span> <span class=\"n\">exists_and_distrib_left</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hm</span> <span class=\"n\">hn</span> <span class=\"n\">hmn</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">lt_trichotomy</span> <span class=\"n\">k</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">H</span><span class=\"bp\">|</span><span class=\"n\">rfl</span><span class=\"bp\">|</span><span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">absurd</span> <span class=\"n\">hmn</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">hn</span> <span class=\"n\">k.succ</span> <span class=\"o\">(</span><span class=\"n\">nat.succ_lt_succ</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"n\">k.succ_pos</span> <span class=\"n\">l.succ</span> <span class=\"n\">l.succ_pos</span> <span class=\"o\">(</span><span class=\"n\">nat.succ_lt_succ</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">absurd</span> <span class=\"n\">hmn.symm</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">hm</span> <span class=\"n\">l.succ</span> <span class=\"o\">(</span><span class=\"n\">nat.succ_lt_succ</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"n\">l.succ_pos</span> <span class=\"n\">k.succ</span> <span class=\"n\">k.succ_pos</span> <span class=\"o\">(</span><span class=\"n\">nat.succ_lt_succ</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">i.to_pnat'</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- { simp },</span>\n  <span class=\"c1\">-- sorry,</span>\n  <span class=\"c1\">-- intros k hk,</span>\n  <span class=\"c1\">-- rw ←hi at h'',</span>\n  <span class=\"c1\">-- obtain ⟨hi', j, hj, hne, hij⟩ := h'',</span>\n  <span class=\"c1\">-- cases positive_or_negative x with hx hx;</span>\n  <span class=\"c1\">-- { refine hx.pnpow_eq_of_eq hij _ _ hk,</span>\n  <span class=\"c1\">--   simp [subtype.ext_iff, hj, hne] }</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 274031633,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1646338006
    },
    {
        "content": "<p>try <code>@not_lt_zero' nat</code> in that simp only</p>",
        "id": 274031845,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1646338104
    },
    {
        "content": "<p>c.f. <a href=\"https://github.com/leanprover-community/mathlib/blob/16d48d7ed350fea30a1e072db9013c72534fd119/src/group_theory/exponent.lean#L71\">https://github.com/leanprover-community/mathlib/blob/16d48d7ed350fea30a1e072db9013c72534fd119/src/group_theory/exponent.lean#L71</a></p>",
        "id": 274031937,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1646338146
    },
    {
        "content": "<p>Awesome! That worked. Very arcane.</p>",
        "id": 274037165,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1646340366
    }
]
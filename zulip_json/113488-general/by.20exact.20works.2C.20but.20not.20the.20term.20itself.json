[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.quot</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">rel</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">of</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">rel</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n<span class=\"bp\">|</span> <span class=\"n\">compat</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">rel</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">rel</span> <span class=\"n\">x</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">rel</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">rel</span> <span class=\"n\">y</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">rel</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">rel</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">rel</span> <span class=\"n\">x</span> <span class=\"n\">z</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">thing</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">rel</span> <span class=\"n\">r</span> <span class=\"n\">π</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">rel.refl</span><span class=\"o\">,</span> <span class=\"n\">rel.symm</span><span class=\"o\">,</span> <span class=\"n\">rel.trans</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">thing</span> <span class=\"n\">r</span> <span class=\"n\">π</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- This works.</span>\n<span class=\"kd\">def</span> <span class=\"n\">δ0</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">r</span> <span class=\"n\">π</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">r</span> <span class=\"n\">π</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">quotient.lift</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">thing</span> <span class=\"n\">r</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">quotient.mk'</span> <span class=\"bp\">$</span> <span class=\"n\">π</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">quotient.sound'</span> <span class=\"bp\">$</span> <span class=\"n\">rel.compat</span> <span class=\"n\">h</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- This fails.</span>\n<span class=\"kd\">def</span> <span class=\"n\">δ1</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">r</span> <span class=\"n\">π</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">r</span> <span class=\"n\">π</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">quotient.lift</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">thing</span> <span class=\"n\">r</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">quotient.mk'</span> <span class=\"bp\">$</span> <span class=\"n\">π</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">quotient.sound'</span> <span class=\"bp\">$</span> <span class=\"n\">rel.compat</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 218056049,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606451275
    },
    {
        "content": "<p>What's happening here? How come <code>(by exact (λ x y h, quotient.sound' $ rel.compat h))</code> works but <code>(λ x y h, quotient.sound' $ rel.compat h)</code> doesn't?</p>",
        "id": 218056095,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606451309
    },
    {
        "content": "<p>Using <code>by exact term</code> causes Lean to delay the elaboration of <code>term</code> until the end, and this is sometimes more successful because more instances and other stuff have been figured out. Gabriel explained it better <a href=\"#narrow/stream/113488-general/topic/division.20and.20numerals/near/151794384\">here</a>.</p>",
        "id": 218056309,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1606451651
    },
    {
        "content": "<p>That makes sense. Thanks <span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span></p>",
        "id": 218056439,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606451957
    },
    {
        "content": "<p>in other words, because Lean is weird and that's just how things work</p>",
        "id": 218058786,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1606456485
    },
    {
        "content": "<p>It's because elaboration is hard and just because humans know the order to do things doesn't mean that computers do.</p>",
        "id": 218064988,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606464299
    },
    {
        "content": "<p>How far into the expression can you push the <code>by exact</code>?</p>",
        "id": 218066156,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606465410
    },
    {
        "content": "<p>I think it's the <code>rel.compat</code> causing the issue here... So I think putting the exact to the left of <code>rel.compat</code> should work too</p>",
        "id": 218090923,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606483087
    },
    {
        "content": "<p>Is it possible to define \\delta0 without any tactic mode and without any other definitions?</p>",
        "id": 218090974,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606483138
    },
    {
        "content": "<p>I can't seem to move the <code>by exact</code> at all</p>",
        "id": 218091499,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606483478
    },
    {
        "content": "<p>Oh</p>",
        "id": 218091513,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606483492
    },
    {
        "content": "<p>I suspect things are going wrong for you because <code>setoid</code> is usually used as a typeclass instance, and that's not what you're doing here</p>",
        "id": 218091645,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606483579
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">δ0'</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">r</span> <span class=\"n\">π</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">r</span> <span class=\"n\">π</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">quotient.lift</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">thing</span> <span class=\"n\">r</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">quotient.mk'</span> <span class=\"bp\">$</span> <span class=\"n\">π</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">quotient.sound'</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">thing</span> <span class=\"n\">r</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">rel.compat</span> <span class=\"n\">h</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 218091711,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606483633
    },
    {
        "content": "<p>Because it prevents <code>quotient.sound'</code> using typeclass search to find the setoid</p>",
        "id": 218091732,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606483649
    },
    {
        "content": "<p><code>quotient.sound'</code> has no <code>[...]</code> in its type</p>",
        "id": 218091820,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606483700
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/by.20exact.20works.2C.20but.20not.20the.20term.20itself/near/218090974\">said</a>:</p>\n<blockquote>\n<p>Is it possible to define \\delta0 without any tactic mode and without any other definitions?</p>\n</blockquote>\n<p>Why do you want to avoid tactic mode? You're filling in a proof so there's no harm in using tactic mode.</p>",
        "id": 218091849,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606483715
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> just for a sanity check</p>",
        "id": 218091890,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606483748
    },
    {
        "content": "<p><code>quotient.sound</code> uses typeclasses to find the equivalence relation, <code>quotient.sound'</code> uses unification.</p>",
        "id": 218091924,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606483782
    },
    {
        "content": "<p>typeclasses are not appropriate here because the equivalence relation depends on the variable <code>π</code>.</p>",
        "id": 218092047,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606483851
    },
    {
        "content": "<p>And it's strange that <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> 's definition works!</p>",
        "id": 218092081,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606483876
    },
    {
        "content": "<p>I think it doesn't help that you build the second quotient with <code>quotient.mk'</code> and Lean has no way to see yet what kind of quotient it should be</p>",
        "id": 218092087,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606483884
    },
    {
        "content": "<p><code>def pre (π : α → α) := α</code> would give you something you can stick a typeclass on</p>",
        "id": 218092097,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606483901
    },
    {
        "content": "<p>Why is it strange? He's filling in the relation.</p>",
        "id": 218092106,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606483906
    },
    {
        "content": "<p>Oh nevermind thats right</p>",
        "id": 218092169,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606483928
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">δ1</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">r</span> <span class=\"n\">π</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">r</span> <span class=\"n\">π</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">quotient.lift</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">thing</span> <span class=\"n\">r</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">quotient.mk'</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">thing</span> <span class=\"n\">r</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"n\">π</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">quotient.sound'</span> <span class=\"o\">(</span><span class=\"n\">rel.compat</span> <span class=\"n\">h</span><span class=\"o\">))</span>   <span class=\"c1\">-- also works</span>\n</code></pre></div>",
        "id": 218092177,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606483934
    },
    {
        "content": "<p>because you use <code>@quotient.lift</code>, Lean won't use the expected type of the whole body to elaborate the arguments</p>",
        "id": 218092208,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606483961
    },
    {
        "content": "<p>so there is a bit of a puzzle for it to solve</p>",
        "id": 218092228,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606483976
    },
    {
        "content": "<p>in <code>quotient.mk'</code>, what quotient? in <code>quotient.sound'</code>, what quotient?</p>",
        "id": 218092283,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606484011
    },
    {
        "content": "<p>But humans can figure it out from the type of Delta, so why can't lean?</p>",
        "id": 218092379,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606484046
    },
    {
        "content": "<p>Lean is not a human</p>",
        "id": 218092408,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606484058
    },
    {
        "content": "<p>It can, when you tell it to use a certain elaboration strategy (with <code>by exact</code>).</p>",
        "id": 218092431,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606484073
    },
    {
        "content": "<p>I think what happens is (because of the outer <code>@</code>) Lean tries to elaborate all the arguments of <code>quotient.lift</code> before attempting to unify its type with the declared type of the definition</p>",
        "id": 218092530,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606484123
    },
    {
        "content": "<p>and this strategy can't work because Lean would need to invent the term <code>thing r π</code> as the setoid on the target that it can prove using <code>rel.compat</code></p>",
        "id": 218092657,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606484194
    },
    {
        "content": "<p>if you stick <code>by exact</code> in a certain place then Lean says \"we'll figure this stuff out later\" and then once it looks at the type of the <code>def</code> it knows what to do</p>",
        "id": 218092705,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606484229
    },
    {
        "content": "<p>I see. So with Eric's code all lean has to do is unify the <code>thing ...</code> with the <code>setoid.r</code></p>",
        "id": 218092752,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606484271
    },
    {
        "content": "<p>I'm not sure why there isn't a <code>quotient.lift'</code> to go with <code>mk'</code> and <code>sound'</code></p>",
        "id": 218093111,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606484450
    },
    {
        "content": "<p>Sometimes (like here) it's annoying that using <code>@</code> to specify some implicit argument also changes the overall elaboration strategy</p>",
        "id": 218093165,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606484489
    },
    {
        "content": "<p>I don't understand why setoid is a class anyway...</p>",
        "id": 218093187,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606484503
    },
    {
        "content": "<p>With a <code>quotient.lift'</code> the natural thing with no <code>@</code>s or other funny business does work.</p>",
        "id": 218093461,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606484651
    },
    {
        "content": "<p>I guess it just never came up before</p>",
        "id": 218093485,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606484668
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/by.20exact.20works.2C.20but.20not.20the.20term.20itself/near/218093187\">said</a>:</p>\n<blockquote>\n<p>I don't understand why setoid is a class anyway...</p>\n</blockquote>\n<p>The old answer was \"because it's in core\".</p>",
        "id": 218093514,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606484688
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">δ2</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">r</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">r</span> <span class=\"n\">π</span> <span class=\"o\">:=</span> <span class=\"n\">quotient.lift_on'</span> <span class=\"n\">q</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">quotient.mk'</span> <span class=\"bp\">$</span> <span class=\"n\">π</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">quotient.sound'</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">thing</span> <span class=\"n\">r</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">rel.compat</span> <span class=\"n\">h</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Only one <code>@</code></p>",
        "id": 218094388,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606485207
    },
    {
        "content": "<p>but I couldn't get it down to 0</p>",
        "id": 218094435,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606485233
    },
    {
        "content": "<p>does this count?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">elab_with_expected_type</span><span class=\"o\">]</span> <span class=\"n\">quotient.lift_on'</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">δ1</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">r</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">r</span> <span class=\"n\">π</span> <span class=\"o\">:=</span> <span class=\"n\">quotient.lift_on'</span> <span class=\"n\">q</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">quotient.mk'</span> <span class=\"bp\">$</span> <span class=\"n\">π</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">quotient.sound'</span> <span class=\"o\">(</span><span class=\"n\">rel.compat</span> <span class=\"n\">h</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 218094828,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606485436
    },
    {
        "content": "<p>for nondependent eliminators it's better not to use <code>elab_as_eliminator</code> I think</p>",
        "id": 218094957,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606485502
    },
    {
        "content": "<p><a href=\"#narrow/stream/113488-general/topic/elab_as_eliminator/near/128740170\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/elab_as_eliminator/near/128740170</a></p>",
        "id": 218095371,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606485758
    },
    {
        "content": "<p>This works too</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">δ1</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">r</span> <span class=\"n\">π</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">r</span> <span class=\"n\">π</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">quotient.lift_on'</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">quot.mk</span> <span class=\"o\">(</span><span class=\"n\">thing</span> <span class=\"n\">r</span> <span class=\"n\">π</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">r</span> <span class=\"bp\">$</span> <span class=\"n\">π</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">quot.sound</span> <span class=\"bp\">$</span> <span class=\"n\">rel.compat</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 218095623,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606485902
    },
    {
        "content": "<p>But the mixing of <code>quot</code> and <code>quotient</code> might make some people uneasy...</p>",
        "id": 218095652,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606485924
    },
    {
        "content": "<p>I think the name <code>setoid</code> itself (and not something along the lines of <code>equivalence_relation</code>) partly explains why it would be a class</p>",
        "id": 218096325,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606486350
    },
    {
        "content": "<p>but since Lean has quotients, it's sort of a vestigial thing</p>",
        "id": 218096393,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606486406
    },
    {
        "content": "<p>Are there any guidelines for picking between <code>quotient</code> and <code>quot</code> in definitions?</p>",
        "id": 218096525,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606486495
    },
    {
        "content": "<p>One reason (and this is why I'm using quotient in my case) is that I want to use <code>quotient.exact</code> in a proof somewhere in a nontrivial way. And using <code>quot.exact</code> instead would be annoying.</p>",
        "id": 218096749,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606486623
    },
    {
        "content": "<p>The definition of the free algebra on a monoid used <code>quot</code> I believe, because after you make the polynomial ring with a variable for every element of the monoid you have a clear idea about which relations you _want_, but you don't have a handle on the equivalence relation generated by those relations, so <code>quot</code> is forced on you.</p>",
        "id": 218097237,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606486939
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/f30200e5b17a3265b638103e7d47f8e4c83d6b07/src/linear_algebra/tensor_algebra.lean#L64\">https://github.com/leanprover-community/mathlib/blob/f30200e5b17a3265b638103e7d47f8e4c83d6b07/src/linear_algebra/tensor_algebra.lean#L64</a></p>",
        "id": 218097316,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606487018
    },
    {
        "content": "<p>This is probably a better example:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/blob/f30200e5b17a3265b638103e7d47f8e4c83d6b07/src/algebra/free_algebra.lean\">https://github.com/leanprover-community/mathlib/blob/f30200e5b17a3265b638103e7d47f8e4c83d6b07/src/algebra/free_algebra.lean</a></p>",
        "id": 218097433,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606487105
    },
    {
        "content": "<p>The issue that Amelia ran into with this definition was that now injectivity of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>M</mi><mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mo>→</mo><mi>R</mi><mo stretchy=\"false\">[</mo><mi>M</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">M^{\\otimes n}\\to R[M]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊗</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">]</span></span></span></span> was not clear, and with no handle on the actual equivalence relation seemed very difficult to prove.</p>",
        "id": 218097435,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606487109
    },
    {
        "content": "<p>Amelia is now making another model for the tensor algebra, as a direct sum of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>M</mi><mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">M^{\\otimes n}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊗</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span>. I found it interesting that even with the universal property and an explicit model, one still needed another model in order to prove some theorems (Amelia now has this second model in a branch of mathlib).</p>",
        "id": 218097550,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606487194
    },
    {
        "content": "<p>On the other hand, in the representation theory of reductive groups, there is the theory of the Whittaker model and the theory of the Kirillov model, both of which are an explicit function space isomorphic to a given (generic) smooth admissible irreducible complex representation of (say) <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><msub><mi>L</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">GL_2(\\mathbb{Q}_p)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>.</p>",
        "id": 218097636,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606487270
    },
    {
        "content": "<p>Another approach would have been to put a grading on the gigantic gadget, proved that all the relations were between things of the same grading, deduced that the associated ideal was graded and then got an induced grading on the quotient.</p>",
        "id": 218097769,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606487366
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/by.20exact.20works.2C.20but.20not.20the.20term.20itself/near/218097435\">said</a>:</p>\n<blockquote>\n<p>The issue that Amelia ran into with this definition was that now injectivity of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>M</mi><mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mo>→</mo><mi>R</mi><mo stretchy=\"false\">[</mo><mi>M</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">M^{\\otimes n}\\to R[M]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊗</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">]</span></span></span></span> was not clear, and with no handle on the actual equivalence relation seemed very difficult to prove.</p>\n</blockquote>\n<p>I think I made a start on trying to prove this in <a href=\"https://github.com/leanprover-community/mathlib/issues/5034\">#5034</a> via <a href=\"https://leanprover-community.github.io/mathlib_docs/find/free_algebra.equiv_monoid_algebra_free_monoid\">docs#free_algebra.equiv_monoid_algebra_free_monoid</a>, but somehow got waylaid trying to prove <a href=\"https://leanprover-community.github.io/mathlib_docs/find/free_abelian_group.of\">docs#free_abelian_group.of</a> was injective, which I couldn't do but also don't remember why I needed</p>",
        "id": 218098310,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606487743
    },
    {
        "content": "<p>But that's ultimately the case you describe, of needing another model</p>",
        "id": 218098391,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606487777
    },
    {
        "content": "<p>I was quite surprised by this from a psychological point of view -- the model in my head was that the universal property tells you that there's at most one object with the properties you want, and the construction -- any construction -- tells you that there's at least one. Here there seemed to be a benefit of more than one construction.</p>",
        "id": 218098929,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606488141
    },
    {
        "content": "<p>The direct sum representation of the tensor algebra comes with its own headaches, right? For example, in proving associativity you need to show that two terms in a dependent type <code>T n</code>, <code>n : nat</code>, are equal for <code>n = (a + b) + c</code> and <code>n = a + (b + c)</code>.</p>",
        "id": 218099130,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606488322
    },
    {
        "content": "<p>How did you avoid <code>heq</code> in this case?</p>",
        "id": 218099164,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606488342
    },
    {
        "content": "<p>In my experience facing that, the proofs aren't impossible, it just makes your theorem statement ugly</p>",
        "id": 218099803,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606488706
    },
    {
        "content": "<p>And using <code>heq</code> is not the end of the world</p>",
        "id": 218099983,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606488807
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/by.20exact.20works.2C.20but.20not.20the.20term.20itself/near/218098310\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/by.20exact.20works.2C.20but.20not.20the.20term.20itself/near/218097435\">said</a>:</p>\n<blockquote>\n<p>The issue that Amelia ran into with this definition was that now injectivity of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>M</mi><mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mo>→</mo><mi>R</mi><mo stretchy=\"false\">[</mo><mi>M</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">M^{\\otimes n}\\to R[M]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊗</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">]</span></span></span></span> was not clear, and with no handle on the actual equivalence relation seemed very difficult to prove.</p>\n</blockquote>\n<p>I think I made a start on trying to prove this in <a href=\"https://github.com/leanprover-community/mathlib/issues/5034\">#5034</a> via <a href=\"https://leanprover-community.github.io/mathlib_docs/find/free_algebra.equiv_monoid_algebra_free_monoid\">docs#free_algebra.equiv_monoid_algebra_free_monoid</a>, but somehow got waylaid trying to prove <a href=\"https://leanprover-community.github.io/mathlib_docs/find/free_abelian_group.of\">docs#free_abelian_group.of</a> was injective, which I couldn't do but also don't remember why I needed</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.free_abelian_group</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">free_abelian_group</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">of_injective</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">of</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">free_abelian_group</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">hoxy</span><span class=\"o\">,</span> <span class=\"n\">classical.by_contradiction</span> <span class=\"bp\">$</span> <span class=\"k\">assume</span> <span class=\"n\">hxy</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n<span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">free_abelian_group</span> <span class=\"n\">α</span> <span class=\"bp\">→+</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"n\">lift</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"k\">have</span> <span class=\"n\">hfx1</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">of</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"o\">(</span><span class=\"n\">lift.of</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"bp\">$</span> <span class=\"n\">if_pos</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">hfy1</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">of</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">hoxy</span> <span class=\"bp\">▸</span> <span class=\"n\">hfx1</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">hfy0</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">of</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"o\">(</span><span class=\"n\">lift.of</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"bp\">$</span> <span class=\"n\">if_neg</span> <span class=\"n\">hxy</span><span class=\"o\">,</span>\n<span class=\"n\">one_ne_zero</span> <span class=\"bp\">$</span> <span class=\"n\">hfy1.symm.trans</span> <span class=\"n\">hfy0</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">free_abelian_group</span>\n</code></pre></div>",
        "id": 218100556,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1606489130
    },
    {
        "content": "<p>You can play the same trick to prove the map from <code>M</code> to the tensor algebra is injective by mapping into the square-zero algebra generrated by <code>M</code>.</p>",
        "id": 218100841,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606489296
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/5109\">#5109</a></p>",
        "id": 218100928,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1606489334
    },
    {
        "content": "<p>but this doesn't scale to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>M</mi><mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">M^{\\otimes n}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊗</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span> -- you might as well have used the direct sum construction</p>",
        "id": 218100976,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1606489368
    },
    {
        "content": "<p>Amelia has been dealing with <code>heq</code>. Chris Hughes knows some techniques for taming <code>heq</code>, he has been working with it for years, and Chris and Amelia are amongst a group of Imperial students all living in the same house share at the minute, so she's in a great position to pick up tips!</p>",
        "id": 218101043,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606489414
    },
    {
        "content": "<p>@Kenny, is that PR'd anywhere?</p>",
        "id": 218101129,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606489458
    },
    {
        "content": "<p>is what PR'd anywhere?</p>",
        "id": 218101267,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1606489560
    },
    {
        "content": "<p>The code snippet you pasted</p>",
        "id": 218101316,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606489578
    },
    {
        "content": "<p>(I now remember that I wanted to prove that in order to prove that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/free_ring.of\">docs#free_ring.of</a> was injective)</p>",
        "id": 218101687,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606489820
    },
    {
        "content": "<p>no, it is not PR'd anywhere</p>",
        "id": 218102003,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1606490026
    },
    {
        "content": "<p>feel free to PR it</p>",
        "id": 218102020,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1606490036
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/5131\">#5131</a></p>",
        "id": 218102743,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606490459
    },
    {
        "content": "<p>Thanks for the hint <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span>, that strategy works to prove that <code>free_algebra.ι</code> is injective too</p>",
        "id": 218106517,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606492885
    },
    {
        "content": "<p>great</p>",
        "id": 218106552,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1606492913
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/stream/113488-general/topic/by.20exact.20works.2C.20but.20not.20the.20term.20itself/near/218100976\">said</a>:</p>\n<blockquote>\n<p>but this doesn't scale to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>M</mi><mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">M^{\\otimes n}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊗</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span> -- you might as well have used the direct sum construction</p>\n</blockquote>\n<p>What is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>M</mi><mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">M^{\\otimes n}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊗</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span>?</p>",
        "id": 218106686,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606492987
    },
    {
        "content": "<p>Assuming that's just the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>-th tensor powers, I don't see where the direct sum fits in</p>",
        "id": 218106731,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606493029
    },
    {
        "content": "<p>because <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msubsup><mo>⨁</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mi mathvariant=\"normal\">∞</mi></msubsup><msup><mi>M</mi><mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">F(M) = \\bigoplus_{n=0}^\\infty M^{\\otimes n}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.104002em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">⨁</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.804292em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">0</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">∞</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊗</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span></p>",
        "id": 218106804,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1606493063
    },
    {
        "content": "<p>Oh, were you talking about proving the injectivity of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>M</mi><mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mo>→</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">M^{\\otimes n} \\to F(M)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊗</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span>, which is difficult if you only have the universal property of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F(M)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span>?</p>",
        "id": 218107085,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606493255
    },
    {
        "content": "<p>yes</p>",
        "id": 218107171,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1606493291
    },
    {
        "content": "<p>Well thankfully we can't even state that yet using the definitions currently in mathlib...</p>",
        "id": 218107251,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606493363
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/by.20exact.20works.2C.20but.20not.20the.20term.20itself/near/218100841\">said</a>:</p>\n<blockquote>\n<p>You can play the same trick to prove the map from <code>M</code> to the tensor algebra is injective by mapping into the square-zero algebra generrated by <code>M</code>.</p>\n</blockquote>\n<p>Done in <a href=\"https://github.com/leanprover-community/mathlib/issues/5712\">#5712</a>. Handily this works for the exterior_algebra too.</p>",
        "id": 222461449,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1610470800
    }
]
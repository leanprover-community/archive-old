[
    {
        "content": "<p>I'm having some trouble proving this. Help would be much appreciated.<br>\n<code>lean lemma sum_keji {α β : Type*} [add_comm_monoid α] {f : β → α}\n  (s : finset β) (g : Π a ∈ s, β) (h₁ : ∀ a ha, f a + f (g a ha) = 0)\n  (h₂ : ∀ a ha, g a ha ≠ a) (h₂ : ∀ a₁ a₂ ha₁ ha₂, g a₁ ha₁ = g a₂ ha₂ → a₁ = a₂)\n  (h₃ : ∀ a ha, ∃ b hb, g b hb = a) : s.sum f = 0 := sorry </code></p>",
        "id": 130977419,
        "sender_full_name": "Morenikeji Neri",
        "timestamp": 1533560869
    },
    {
        "content": "<p>I guess you should first prove <code>g a ha ∈ s</code> using the pigeonhole principle</p>",
        "id": 130979862,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533563685
    },
    {
        "content": "<p>then the assumptions say that <code>g : s -&gt; s</code> is a bijection, so you can use <code>sum_bij</code> to shift things around and cancel using <code>h1</code></p>",
        "id": 130979907,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533563758
    },
    {
        "content": "<p>Oh wait, you only have that it is an <code>add_comm_monoid</code>, that's not enough to conclude</p>",
        "id": 130979982,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533563824
    },
    {
        "content": "<p>you will be able to prove <code>s.sum f + s.sum f = 0</code></p>",
        "id": 130979991,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533563845
    },
    {
        "content": "<p>So for example if <code>α = Z/2Z</code>, <code>β=Z/3Z</code>, <code>s={0,1,2}</code>, <code>f a = 1</code> and <code>g n = n+1</code> then we have a counterexample</p>",
        "id": 130980256,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533564107
    },
    {
        "content": "<p>sorry about that. I realized I missed out a few assumptions in the theorem.<br>\nIt should read.</p>\n<p><code>lean lemma sum_keji {α β : Type*} [add_comm_monoid α] {f : β → α}\n  (s : finset β) (g : Π a ∈ s, β) (h₁ : ∀ a ha, f a + f (g a ha) = 0)\n  (h₂ : ∀ a ha, g a ha ≠ a) (h₂ : ∀ a₁ a₂ ha₁ ha₂, g a₁ ha₁ = g a₂ ha₂ → a₁ = a₂)\n  (h₃ : ∀ a ha, ∃ b hb, g b hb = a) (h₄ : ∀ a ha, g a ha ∈ s) (h₅ : ∀ a ha, g (g a ha) (h₄ a ha) = a ) : s.sum f = 0 := sorry </code></p>",
        "id": 130982346,
        "sender_full_name": "Morenikeji Neri",
        "timestamp": 1533566235
    },
    {
        "content": "<p>Oh I see, it's an involution</p>",
        "id": 130982614,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533566434
    },
    {
        "content": "<p>You can prove this by complete induction on <code>s</code>. Just take out <code>a</code> and <code>g a ha</code> in one step of the induction</p>",
        "id": 130982654,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533566467
    },
    {
        "content": "<p>Is there a short proof using lemmas?</p>",
        "id": 130982680,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1533566492
    },
    {
        "content": "<p>not with those hypotheses</p>",
        "id": 130982691,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533566505
    },
    {
        "content": "<p>half of the work will be unpacking them</p>",
        "id": 130982711,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533566521
    },
    {
        "content": "<p>I mean, the stuff about <code>sum</code> is there but most of the work is showing that the reduced <code>g</code> function is still an involution</p>",
        "id": 130982788,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533566559
    },
    {
        "content": "<p>yep!</p>",
        "id": 130982854,
        "sender_full_name": "Morenikeji Neri",
        "timestamp": 1533566626
    },
    {
        "content": "<p>Okay... after way too many inequalities (thanks, everyone!), I now have \"the right\" proof that $\\sum_m \\binom n m = 2^n$, based on reindexing sums and splitting off and joining single terms. This uses the following four lemmas:</p>\n<div class=\"codehilite\"><pre><span></span>lemma finset.sum.interval_split_left (n m : ℕ) (h₁ : n &lt; m) (f : ℕ → β) :\n(interval n m).sum f = f n + (interval (n+1) m).sum f :=\n\nlemma finset.sum.interval_split_right (n m : ℕ) (h : m &gt; n) (f : ℕ → β) :\n(interval n m).sum f = (interval n (m-1)).sum f + f (m-1) :=\n\nlemma finset.sum.interval_reindex_left (k n m : ℕ) (h : k ≤ n) (f : ℕ → β) :\n(interval n m).sum f = (interval (n-k) (m-k)).sum (λ x, f (x + k)) :=\n\nlemma finset.sum.interval_reindex_right (k n m : ℕ) (f : ℕ → β) :\n(interval n m).sum f = (interval (n+k) (m+k)).sum (λ x, f (x - k)) :=\n</pre></div>\n\n\n<p>which I've proved (and some infrastructure for <code>interval</code>).</p>",
        "id": 148271569,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543054553
    },
    {
        "content": "<p>The proofs still need a lot of golfing, but I think it's progress.</p>",
        "id": 148271613,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543054593
    },
    {
        "content": "<p>I would like to write some tactics to help with this, so you can just write things like \"reindex_sum +3\" in tactic mode, and it will <code>conv</code> it's way to the first <code>(interval n m).sum f</code>, and replace it with <code>(interval (n+3) (m+3)).sum (\\lambda x, f (x-3))</code>, etc.</p>",
        "id": 148271669,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543054690
    },
    {
        "content": "<p>Now on to multinomial coefficients!</p>",
        "id": 148271672,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543054727
    },
    {
        "content": "<p>I'd also like to write a <code>conv</code> tactic for rewriting inside the summand of a <code>finset.sum</code>, that gives you a hypothesis saying you're actually in the domain.</p>",
        "id": 148271675,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543054740
    },
    {
        "content": "<p>If I'm going to clean this up for a PR, where should it go? In <code>big_operators.lean</code>? Or start a new file for summations over intervals in <code>nat</code>?</p>",
        "id": 148271831,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543055057
    },
    {
        "content": "<p>I think a file for summations over intervals is appropriate</p>",
        "id": 148271914,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543055255
    },
    {
        "content": "<p>I think the name should be <code>finset.Icc</code> though</p>",
        "id": 148271960,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543055293
    },
    {
        "content": "<p>thiat gives us plenty of room for future variation</p>",
        "id": 148271964,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543055320
    },
    {
        "content": "<p>er, <code>Ico</code>?</p>",
        "id": 148271969,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543055336
    },
    {
        "content": "<p>does that stand for \"interval closed open\"?</p>",
        "id": 148271987,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543055380
    },
    {
        "content": "<p>okay</p>",
        "id": 148271989,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543055385
    },
    {
        "content": "<p>yeah, for compatibility with <code>set.Ico</code></p>",
        "id": 148271995,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543055397
    },
    {
        "content": "<p>how about when I define <code>Ico</code> as a list/multiset/finset? Should those go in those three files, or in the file about summations over intervals?</p>",
        "id": 148272044,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543055428
    },
    {
        "content": "<p>they can all be in the same file, I think</p>",
        "id": 148272047,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543055449
    },
    {
        "content": "<p>excellent, that means I can safely use tactics :-)</p>",
        "id": 148272061,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543055466
    },
    {
        "content": "<p>oh, you mean the definitions themselves</p>",
        "id": 148272065,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543055481
    },
    {
        "content": "<p>yes...</p>",
        "id": 148272069,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543055496
    },
    {
        "content": "<p>I guess they could go near <code>finset.range</code></p>",
        "id": 148272071,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543055501
    },
    {
        "content": "<p>but the development should go in its own file</p>",
        "id": 148272079,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543055517
    },
    {
        "content": "<p>especially stuff combining sums and these sets</p>",
        "id": 148272119,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543055534
    },
    {
        "content": "<p>okay, that's what I've done so far --- in fact put them next to <code>list.range'</code>, <code>multiset.range</code>, and <code>finset.range</code>, and then the actual lemmas about dealing with <code>(Ico n m).sum</code> are in their own file.</p>",
        "id": 148272126,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543055548
    },
    {
        "content": "<p>great</p>",
        "id": 148272130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543055555
    },
    {
        "content": "<p>a few lemmas about slicing and dicing intervals use <code>tidy</code> to blast through... those proofs will have to be rewritten if they are going to live in <code>finset.lean</code> or earlier.</p>",
        "id": 148272164,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543055636
    },
    {
        "content": "<p>oh well...</p>",
        "id": 148272167,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543055640
    },
    {
        "content": "<p>(Not having <code>work_on_goal</code> available will make me cry, as it means I'll actually have to restructure the proofs <code>tidy</code> outputs.)</p>",
        "id": 148272211,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543055671
    },
    {
        "content": "<p>oh no, structured proof</p>",
        "id": 148272241,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543055760
    },
    {
        "content": "<p>don't hold your breath :-) This PR is going to have some low-quality tactic proofs, that get the job done.</p>",
        "id": 148272346,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543055888
    },
    {
        "content": "<p>On the subject, if anyone wants to suggest to me some nice examples of proofs that rely on re-indexing and slicing and dicing sums, please do!</p>",
        "id": 148272542,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543056354
    },
    {
        "content": "<p>you should look at <code>exp_add</code></p>",
        "id": 148272764,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543056740
    },
    {
        "content": "<p>and possibly quadratic reciprocity</p>",
        "id": 148272770,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543056774
    },
    {
        "content": "<p>Seriously guys, what's wrong with you? What the fuck is this thread?</p>",
        "id": 148273678,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543058519
    },
    {
        "content": "<p>I really think this proof assistant thing is going nowhere if we keep working like this, ignoring everything done by other people, including the ones who proved they can do much more than what we can currently do</p>",
        "id": 148273733,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543058630
    },
    {
        "content": "<p>I've pointed out repeatedly the existence of mathcomp's bigop library. They figured out all the issues, and they use it in linear algebra, in calculus, in finite group theory... I said it would very important to try to port that library to mathlib. Nobody cared. I started trying to do it, nobody cared. I struggled with nat substraction so I gave up for now. Then suddenly Scott asks many nat substraction questions, and, guess what, he is doing big operators again.</p>",
        "id": 148273831,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543058780
    },
    {
        "content": "<p>The point is to see if our new techniques help with the proofs</p>",
        "id": 148273841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543058832
    },
    {
        "content": "<p>I think the point is people thinking they are smarter than Gonthier and his friends</p>",
        "id": 148273846,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543058875
    },
    {
        "content": "<p>if you get ahead of yourself writing theorems before the automation or appropriate structures and idioms come you get a load of unmaintainable hackery</p>",
        "id": 148273888,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543058890
    },
    {
        "content": "<p>I'm afraid I can't read any of gonthier's proofs</p>",
        "id": 148273891,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543058923
    },
    {
        "content": "<p>Then why don't you ask?</p>",
        "id": 148273892,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543058934
    },
    {
        "content": "<p>I highly respect him and I know he has a method to the madness but ssreflect style is not something I want to teach</p>",
        "id": 148273899,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543058950
    },
    {
        "content": "<p>We have Assia and Cyril who can read them, and explain everything</p>",
        "id": 148273900,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543058951
    },
    {
        "content": "<p>And they are really puzzled by our attitude</p>",
        "id": 148273905,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543058969
    },
    {
        "content": "<p>It has nothing to do with SSReflect crazyness</p>",
        "id": 148273906,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543058980
    },
    {
        "content": "<p>They thought about what are the right data structures, how to formulate the right induction principles for big operators, in what order to prove stuff</p>",
        "id": 148273981,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543059047
    },
    {
        "content": "<p>And it <em>works</em></p>",
        "id": 148273983,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543059053
    },
    {
        "content": "<p>sure, that's valuable</p>",
        "id": 148273995,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543059072
    },
    {
        "content": "<p>it's the reason I periodically bring up metamath here, because many of our new problems are old problems somewhere else</p>",
        "id": 148274000,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543059100
    },
    {
        "content": "<p>but I can't help that my experience is in metamath, not coq</p>",
        "id": 148274002,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543059119
    },
    {
        "content": "<p>to get good information about how to do stuff in coq we would need Assia or Cyril guiding the path, and they have better things to do</p>",
        "id": 148274061,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543059187
    },
    {
        "content": "<p>What about letting them decide whether they have better things to do?</p>",
        "id": 148274071,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543059211
    },
    {
        "content": "<p>They both repeatedly offered to help us understand what's in mathcomp</p>",
        "id": 148274078,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543059227
    },
    {
        "content": "<p>of course, if they actually think that's a good idea I'm all ears, that's not a rejection at all</p>",
        "id": 148274122,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543059251
    },
    {
        "content": "<p>but in my view it's one more idea on the table, which can be considered equally among others</p>",
        "id": 148274127,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543059301
    },
    {
        "content": "<p>And what about trying to work together? <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> could you publicly write why you chose to restart from scratch instead of helping me in my attempt?</p>",
        "id": 148274133,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543059326
    },
    {
        "content": "<p>I don't think we should blindly port any specific library</p>",
        "id": 148274135,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543059335
    },
    {
        "content": "<p>I'm not saying we should blindly do anything. Quite the contrary, I'm suggesting to open our eyes to the existing stuff</p>",
        "id": 148274179,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543059372
    },
    {
        "content": "<p>are you referring to the notation for filtered sums of nats?</p>",
        "id": 148274182,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543059384
    },
    {
        "content": "<p>I don't think Lean would be there is Leo had the same attitude with existing software. And it doesn't mean Lean is \"blindly ported\"</p>",
        "id": 148274195,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543059425
    },
    {
        "content": "<p>It's not only about notations, I proved many lemmas in <a href=\"https://github.com/PatrickMassot/bigop/blob/master/src/bigop.lean\" target=\"_blank\" title=\"https://github.com/PatrickMassot/bigop/blob/master/src/bigop.lean\">https://github.com/PatrickMassot/bigop/blob/master/src/bigop.lean</a>. I know some stuff should be rethought, and everything could be improved, but why not starting there?</p>",
        "id": 148274243,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543059485
    },
    {
        "content": "<p>one could ask the same of that approach... try it on <code>exp_sum</code>, try it on quadratic reciprocity, see if it helps</p>",
        "id": 148274272,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543059586
    },
    {
        "content": "<p>this is not in any way a loaded question, it's a test bed for new ideas</p>",
        "id": 148274322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543059607
    },
    {
        "content": "<p>if it's a good approach, the proof will reflect that</p>",
        "id": 148274332,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543059620
    },
    {
        "content": "<p>I don't know if scott's <code>Ico</code> will make things better than just using <code>range</code>, we need more data</p>",
        "id": 148274352,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543059672
    },
    {
        "content": "<p>It's lunch time, and this conversation is going nowhere anyway. Bye</p>",
        "id": 148274361,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543059715
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> do you have any comments on this? I remember a couple of times over the summer you saying you were having to battle with finite sums. What did you feel was missing from the library? Maybe it's time to compile a wishlist instead of all writing our own workarounds. Last year I wrote <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>a</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn><mo>−</mo><mi>j</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\sum_{i=1}^na_i=\\sum_{j=1}^na_{n+1-j}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.804292em;\"></span><span class=\"strut bottom\" style=\"height:1.24011em;vertical-align:-0.43581800000000004em;\"></span><span class=\"base\"><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.804292em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mathrm mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathit\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mrel\">=</span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.804292em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mrel mtight\">=</span><span class=\"mord mathrm mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.43581800000000004em;\"></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathit\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mathrm mtight\">1</span><span class=\"mbin mtight\">−</span><span class=\"mord mathit mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span></span></span></span> because I needed it for an example sheet question, and I remember it being a real pain.</p>",
        "id": 148275683,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543062236
    },
    {
        "content": "<p>My impression of nat subtraction is it's best to avoid it appearing in lemmas to start with</p>",
        "id": 148275731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543062316
    },
    {
        "content": "<p>Well it's in my lemma :-/</p>",
        "id": 148275732,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543062331
    },
    {
        "content": "<p>oh I see what you mean</p>",
        "id": 148275737,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543062351
    },
    {
        "content": "<p>I wonder how much mileage you can get out of <code>finset.diag : finset (nat x nat) := {(0, n), ..., (n, 0)}</code></p>",
        "id": 148275776,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543062364
    },
    {
        "content": "<p>you want me to prove that the function sending i to n+1-i is a bijection and then have some lemma about summing over a bijection, which actually might be in there already I guess. Is it?</p>",
        "id": 148275788,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543062401
    },
    {
        "content": "<p>I want to be able to sum between integers and naturals, and also do non commutative products over arbitrary lists. I think Patrick's approach seems to unify all these things nicely.</p>",
        "id": 148275794,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1543062409
    },
    {
        "content": "<p><code>sum_bij</code> is the lemma</p>",
        "id": 148275801,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1543062422
    },
    {
        "content": "<blockquote>\n<p>the function sending i to n+1-i is</p>\n</blockquote>\n<p>nope, you said minus</p>",
        "id": 148275810,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543062441
    },
    {
        "content": "<p>the goal is to state the whole theorem without using minus</p>",
        "id": 148275854,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543062485
    },
    {
        "content": "<p>But I literally needed to prove that the sum of <code>F i</code> was equal to the sum of <code>F (n + 1 - i)</code></p>",
        "id": 148275855,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543062491
    },
    {
        "content": "<p><code>finset.diag.map swap = finset.diag.reverse</code></p>",
        "id": 148275856,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543062502
    },
    {
        "content": "<p>no minus</p>",
        "id": 148275859,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543062511
    },
    {
        "content": "<p>and <code>swap</code> is a bijection, etc etc</p>",
        "id": 148275861,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543062534
    },
    {
        "content": "<p>If I set as an example sheet question <code>binom n m = binom n (n - m)</code> you can't now avoid the minus. Are you suggesting that binom should take integer coefficients?</p>",
        "id": 148275873,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543062576
    },
    {
        "content": "<p>if it's literally the input statement, then you should apply a lemma to get rid of it first, and work with that</p>",
        "id": 148275878,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543062601
    },
    {
        "content": "<p>so what lemma gets me rid of <code>n - m</code> in my input statement? :-/</p>",
        "id": 148275924,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543062620
    },
    {
        "content": "<p><code>binom n i = binom n j</code> when <code>i + j = n</code></p>",
        "id": 148275926,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543062626
    },
    {
        "content": "<p><em>boggle</em></p>",
        "id": 148275927,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543062634
    },
    {
        "content": "<p>aka <code>(i, j) in finset.diag</code></p>",
        "id": 148275929,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543062641
    },
    {
        "content": "<p>inductions go through so much more smoothly when there is no break in the function</p>",
        "id": 148275990,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543062737
    },
    {
        "content": "<p>My theorem isn't even true when <code>m &gt; n</code></p>",
        "id": 148275996,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543062766
    },
    {
        "content": "<p>my theorem can't even have m &gt; n</p>",
        "id": 148275999,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543062780
    },
    {
        "content": "<p>right</p>",
        "id": 148276005,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543062787
    },
    {
        "content": "<p>of course you can substitute in <code>n</code> in that statement, and then it's an easy induction on i,j</p>",
        "id": 148276016,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543062835
    },
    {
        "content": "<p>in general you might also want to generalize i,j and do induction on n, or something related</p>",
        "id": 148276062,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543062883
    },
    {
        "content": "<p>So one way of proving <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mo>:</mo><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><mo>:</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>(</mo><mo>−</mo><mn>1</mn><msup><mo>)</mo><mi>i</mi></msup><mrow><mo fence=\"true\">(</mo><mfrac linethickness=\"0px\"><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>i</mi></mrow></mfrac><mo fence=\"true\">)</mo></mrow></mrow><annotation encoding=\"application/x-tex\">s : \\mathbb{Z} :=\\sum_{i=0}^{2n+1}(-1)^i\\binom{2n+1}{i}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.954008em;\"></span><span class=\"strut bottom\" style=\"height:1.304018em;vertical-align:-0.35001em;\"></span><span class=\"base\"><span class=\"mord mathit\">s</span><span class=\"mrel\">:</span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mrel\">:</span><span class=\"mrel\">=</span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.954008em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mathrm mtight\">0</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">2</span><span class=\"mord mathit mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mathrm mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord mathrm\">1</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.824664em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">i</span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size1\">(</span></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8951079999999999em;\"><span style=\"top:-2.3550000000000004em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">i</span></span></span></span><span style=\"top:-3.144em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">2</span><span class=\"mord mathit mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mathrm mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size1\">)</span></span></span></span></span></span> is 0 is to set <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>j</mi><mo>=</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo>−</mo><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">j=2n+1-i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.65952em;\"></span><span class=\"strut bottom\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05724em;\">j</span><span class=\"mrel\">=</span><span class=\"mord mathrm\">2</span><span class=\"mord mathit\">n</span><span class=\"mbin\">+</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">−</span><span class=\"mord mathit\">i</span></span></span></span> and note that this substitution proves that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mo>=</mo><mo>−</mo><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s=-s</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.58333em;\"></span><span class=\"strut bottom\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"base\"><span class=\"mord mathit\">s</span><span class=\"mrel\">=</span><span class=\"mord\">−</span><span class=\"mord mathit\">s</span></span></span></span>. You would do all this without any nat subtraction?</p>",
        "id": 148276073,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543062920
    },
    {
        "content": "<blockquote>\n<p>@Scott Morrison could you publicly write why you chose to restart from scratch instead of helping me in my attempt?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>, my apologies if it appeared that I was intentionally ignoring your work at &lt;<a href=\"https://github.com/PatrickMassot/bigop/blob/master/src/bigop.lean\" target=\"_blank\" title=\"https://github.com/PatrickMassot/bigop/blob/master/src/bigop.lean\">https://github.com/PatrickMassot/bigop/blob/master/src/bigop.lean</a>&gt;. In fact I didn't even know that it existed. I remember looking at the top of <code>big_operators.lean</code> and thinking \"huh, that's funny, Patrick's name isn't in the <code>Authors</code> line, I thought he helped write this file\". But that was the extent of my memory of what you'd done. :-(</p>\n<p>I'd be very happy to discuss what you wrote already and to make some plans about how to proceed.</p>\n<p>Right now I need to go out for a while, but I'll look more closely at your repo soon. There is a lot there, and I see that working over <code>int</code> rather than <code>nat</code> index sets makes life easier. However I don't much like that you've \"rolled your own\" subsets built into your <code>bigop</code> notation, containing both a <code>list I</code> and an <code>I -&gt; Prop</code>, rather than using existing technology (e.g. <code>multiset</code>, and <code>filter</code>). I think it's best if we decouple as much as possible here.</p>",
        "id": 148287845,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543086514
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>, moreover, I will attempt to read the big operators paper. :-)</p>",
        "id": 148294592,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543100678
    },
    {
        "content": "<p>I see already that your <code>list I</code> and <code>I -&gt; Prop</code> is imitating what they do, although my limited understanding so far is that they do something more general than <code>list I</code>.</p>",
        "id": 148294612,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543100726
    },
    {
        "content": "<p>I just came back from the hospital after some climbing session, so I didn't see your message earlier</p>",
        "id": 148294656,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543100821
    },
    {
        "content": "<p>I'm sorry I was so upset this morning, but I'm really tired of these problems.</p>",
        "id": 148294663,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543100857
    },
    {
        "content": "<p>I didn't \"roll my own subset\" rather using filter, everything is based on filter. The question is the interface question, and this is precisely the kind of question where I think it makes sense to have a look at what mathcomp successfully used</p>",
        "id": 148294712,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543100938
    },
    {
        "content": "<p>I moved from nat to int mostly because of nat substraction hell, but also because sums indexed by integers do arise, for instance with Fourier series</p>",
        "id": 148294783,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543101115
    },
    {
        "content": "<p>Okay, a few disorganised thoughts post bike-ride:<br>\n1) While I absolutely agree that we want \"generic operation\" big operations, I mostly wanted to explore writing useful tactics for manipulating big operations, and thought that testing this out more narrowly (just with <code>finset.sum</code> at first) would be helpful.</p>\n<p>2) The sort of tactics I have in mind are: <code>shift 5</code> (and <code>shift -2</code>, and <code>shift_left</code>, etc.), <code>split_first</code>, <code>split_at</code>, etc, and very importantly making it possible to <code>conv</code> your way inside the summand, and be given a hypothesis that you're in the domain, so you can perform appropriate conditional rewrites. There are many more tactics suitable for multivariable big operations, changing between int and nat, etc. (Does the Coq library provide tactic level support?)</p>\n<p>3) I feel pretty dubious about the Coq model where there is apparently a multiset, and a filter, being carried around in the notation. It then seems there are two places we can add an extra filter: on the actual multiset, and composed with the filter. There's then an extra dimension worth of rewriting to move the filters back on forth. Why cause yourself that trouble? (I still haven't read the Coq paper -- so this question is perhaps an invitation for someone to point me to a relevant comment.)</p>\n<p>4) In Patrick's prototype, I think there's a real semantic problem with using a <code>list I</code> and a <code>I -&gt; Prop</code>. What is the meaning of repeated elements in the list? Presumably that we're summing with multiplicity. What is the meaning of the order of the list? It's strange that the filter removes all copies of some element --- surely you want to be able to control multiplicities directly if you're summing with multiplicity? I suspect here that the answer is just to change from <code>list I</code> to <code>finset I</code>.</p>\n<p>5) A more fundamental objection to following the Coq approach is indexing by the binary operation, rather than the carrier type, is completely alien to the rest of the design in Lean. Pursuing this for a big operators library seems likely to cause of lot of friction. In their paper (okay, I've now read the first 3 pages) they say they don't want to index by the carrier type because of course there is more than one relevant operation we want bigops for, for a single type (their example is nat, with +,*, max, min, lcm, gcd, and so on). I think this is actually an easy problem to solve, that we've solved elsewhere in mathlib by \"wrapper types\", and providing alternative instances for the wrapper. For example we might define </p>\n<div class=\"codehilite\"><pre><span></span>def as_gcd_monoid (X : Type) := X\n</pre></div>\n\n\n<p>and then</p>\n<div class=\"codehilite\"><pre><span></span>instance [has_gcd X] : has_mul (as_gcd_monoid X) := ...\n</pre></div>\n\n\n<p>and finally </p>\n<div class=\"codehilite\"><pre><span></span>def finset.gcd (t : finset X) (f : X -&gt; Y) [has_gcd Y] := @finset.big_op X (as_gcd_monoid Y) t (\\lambda x, f x)\n</pre></div>\n\n\n<p>(or something like that... )</p>",
        "id": 148302363,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543118221
    },
    {
        "content": "<p>don't drive and derive...</p>",
        "id": 148302414,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1543118353
    },
    {
        "content": "<p>Also, if we're going to make some progress on big ops, I think it would be great if we can ask Assia and Cyril for some advice. I'd like to do a few experiments perhaps first (actually try writing some of the <code>conv</code> style tactics for manipulating sums, and seeing if it really is okay to index by carrier type), but maybe we could even schedule a skype call with whoever is interested so we can ask them some questions.</p>",
        "id": 148302765,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543119051
    },
    {
        "content": "<p>Scott, I think you completely missed the point that we want to handle non-commutative operations</p>",
        "id": 148314025,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543142434
    },
    {
        "content": "<p>Next, I think the list + predicate is there to handle the very common case of summing on a range of integers subjects to conditions, like \"sum for n from 1 to N, with n odd\"</p>",
        "id": 148314037,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543142499
    },
    {
        "content": "<p>I'm not sure I understand what you'd like your tactic to do that a rewriting lemma couldn't</p>",
        "id": 148314038,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543142522
    },
    {
        "content": "<p>I did miss the intention to also do noncommutative things. What do you have in mind? (And in any case, while we're writing prototypes, I'd prefer to work in simpler special cases, so I suspect I'll propose we ignore the noncommutative stuff for now anyway.)</p>",
        "id": 148335113,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543185347
    },
    {
        "content": "<p>It might be good to at some point list all the things that conceivably could count as \"big operations\". Here's a sampling of things that could conceivably be in scope:</p>\n<ul>\n<li>sums, </li>\n<li>products, </li>\n<li>unions, </li>\n<li>maxs, </li>\n<li>gcds, </li>\n<li>convergent sums, </li>\n<li>integrals, </li>\n<li>limits (e.g. as x goes to a), </li>\n<li>limits (of a functor over a diagram).</li>\n</ul>",
        "id": 148335286,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543185686
    },
    {
        "content": "<p>But Patrick, why not just filter the list, if you want to sum over odd integers? I really don't understand why you want to carry around an \"unapplied\" filter.</p>",
        "id": 148335293,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543185721
    },
    {
        "content": "<p>And I think my point stands, even if we're going to do noncommutative operations: a list is a bad way to model a ordered set. Using a list commits us to dealing with multiplicities, and I don't think that's what you intend.</p>",
        "id": 148335464,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543186007
    },
    {
        "content": "<p>Regarding tactics: at the moment, rewriting inside the summand is a royal pain. As far as I can see, you need to use <code>rw sum_congr</code>, having carefully prepared the equation you want to rewrite along ahead of time in the form <code>\\forall x \\in t, f x  = g x</code>. <code>conv</code> completely fails to enter the summand giving you appropriate hypotheses, and this could easily be fixed.</p>",
        "id": 148335685,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543186367
    },
    {
        "content": "<p>Going back to my \"big list of big operations\"... I think it would be a bad idea to try to write a framework so general it encompasses all of these.</p>",
        "id": 148335754,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543186500
    },
    {
        "content": "<p>So for non commutative stuff, might it be better to use a finset with <code>linear_order</code> on the indexing type? I like that idea.</p>",
        "id": 148335806,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1543186591
    },
    {
        "content": "<p>It's possible. I'm not sure though how to make the commutative case a specialisation of the non-commutative case.</p>",
        "id": 148335959,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543186808
    },
    {
        "content": "<p>Another possibility is to have the range of the big operation be a \"list without duplicates\" (a new type?), and then have extra lemmas that apply when the operation is known to be commutative, and that list comes from a finset.</p>",
        "id": 148335976,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543186868
    },
    {
        "content": "<p>That design would mean lemmas proved about the noncommutative case would specialise.</p>",
        "id": 148335979,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543186892
    },
    {
        "content": "<p>Are there any concrete examples of where a list with duplicates is annoying?</p>",
        "id": 148336031,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1543186973
    },
    {
        "content": "<p>I don't want to ask for that proof obligation without a good reason.</p>",
        "id": 148336037,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1543187002
    },
    {
        "content": "<p>I ... guess not.</p>",
        "id": 148336105,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543187142
    },
    {
        "content": "<p>One problem is perhaps getting a list back out of a finset in the first place.</p>",
        "id": 148336148,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543187193
    },
    {
        "content": "<p>I'm still unhappy about carrying along unapplied predicates, but I'm now open to the idea of using a list to represent the range.</p>",
        "id": 148336160,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543187235
    },
    {
        "content": "<p>Just thinking out loud for a moment here: I wonder about really embracing the typeclass system here. What if we did big operations over arbitrary types A, and require an extra piece of evidence, possibly depending on the summand function <code>f : A -&gt; X</code> that the big operation makes sense. There could be lots of mechanisms here:</p>\n<ul>\n<li><code>[fintype A] [ordered A] [monoid X]</code> (summing over an ordered finite set)</li>\n<li><code>[fintype A] [comm_monoid X]</code> (summing over a unordered finite set)</li>\n<li>with <code>f : (near a) -&gt; X</code>, where <code>def near {A : Type} (a : A) := A</code>, the evidence for <code>lim_{a : near A} f</code> could be computed from something like <code>[topological_space A] [continuous_at f a]</code></li>\n<li><code>[normed_space X]  [absolute_convergence f]</code>,</li>\n<li><code>[category A] [category X] [is_functorial f] [has_limits_of_shape A]</code> (computing a limit)<br>\nCould one prove enough of the needed lemmas in this ridiculous generality that it would be worth doing?</li>\n</ul>",
        "id": 148337035,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543189017
    },
    {
        "content": "<p>distributivity of multiplication is true for lots of types of sums. Not sure how you'd state or prove that though. Unless you made a new class for more or less every lemma.</p>",
        "id": 148337512,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1543189973
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I think that limits (in topology or category theory) are a completely different kind of big operators from the others. All the others have some sort of iterative or recursive aspect to them. (Btw, we could add tensor products to your big list.) For those iterative instances I think it will probably be very useful to also have <code>product L</code> if <code>L</code> is a list of matrices. So we do care about the non-commutative case, I think.<br>\nAbout tactics vs rewrites: I completely agree that it is crucial that we have slick rewriting of the summand, and currently this is a pain. I also agree with <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> That most of the \"slicing and dicing\" probably doesn't need tactics, but could be done with regular rewrite lemmas, because that doesn't touch the summand.<br>\nBut making <code>conv</code> access the summand would be get you a major hooray from my side! I just recently reexperienced how awful it is, when I tried to prove that <code>boundary_boundary</code> lemma in the simplicial branch. You get nested sums over finsets, and manipulating them is a silly gamble where you just hope that <code>simp</code> and <code>erw</code> drill down far enough to make a bit of progress.</p>",
        "id": 148345914,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543207049
    },
    {
        "content": "<p>The other tactic support I realised we can do is unrolling sums of \"explicit length\". Just like my <code>fin_cases</code> command, we can have a single tactic that takes for example $\\sum_{n=k}^{k+3} f(n)$ and replaces it with $f(k) + f(k+1) + f(k+2) + f(k+3)$. This is quite a pain to achieve with pure rewriting, and is not so bad to automate in tactic mode.</p>",
        "id": 148351986,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543218569
    },
    {
        "content": "<p>I'm not sure sure that limits (in category theory or in topology) are completely different big operators. If you just categorify your natural numbers as finite sets, a sum of natural numbers is just the colimit of the discrete diagram of those sets (and a product is just the colimit)! Nevertheless, I wasn't seriously suggested we do this --- in fact I was setting up a straw man to try to argue we should not go for maximum generality. :-)</p>",
        "id": 148352070,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543218713
    },
    {
        "content": "<blockquote>\n<p>The other tactic support I realised we can do is unrolling sums of \"explicit length\". Just like my <code>fin_cases</code> command, we can have a single tactic that takes for example $\\sum_{n=k}^{k+3} f(n)$ and replaces it with $f(k) + f(k+1) + f(k+2) + f(k+3)$. This is quite a pain to achieve with pure rewriting, and is not so bad to automate in tactic mode.</p>\n</blockquote>\n<p>I suppose this could be done with <code>repeat { rw split_last }, simp</code>.</p>",
        "id": 148352123,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543218771
    },
    {
        "content": "<p>But I agree that an <code>unroll_bigop</code> tactic might make sense.</p>",
        "id": 148352148,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543218829
    },
    {
        "content": "<p>I'm not quite convinced it's that easy, but perhaps I'm thinking about the <code>fin_cases</code> situation, which was quite a bit more painful.</p>",
        "id": 148352194,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543218863
    },
    {
        "content": "<p>I agree it seems to make sense to drop the predicate part, at least until we see a need for it, although I'll try to ask Cyril and Assia before doing so. But non-commutative operators are crucial. I started this project because I wanted to do group theory. And I still hope that one day we will be able to handle differential forms as well.  Now that I think about it, I'm not sure I could find any big operator in one of my papers that uses a commutative operation.</p>",
        "id": 148356624,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543224997
    },
    {
        "content": "<p>I worked on my bigop attempt today, reaching a new sorry-free equilibrium point. I did find a use for the predicate thing as a convenient way to prove stuff, keeping track of information.</p>",
        "id": 148367393,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543239773
    },
    {
        "content": "<p>Ok, I pushed <a href=\"https://github.com/leanprover-community/mathlib/tree/bigop\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/tree/bigop\">https://github.com/leanprover-community/mathlib/tree/bigop</a> Any contributor is very welcome. In particular, cleaning up <a href=\"https://github.com/leanprover-community/mathlib/blob/bigop/pending_lemmas.lean\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/bigop/pending_lemmas.lean\">https://github.com/leanprover-community/mathlib/blob/bigop/pending_lemmas.lean</a>  requires no big operators skills, only knowing mathlib (or searching efficiently), or being good at either list or nat vs int bashing.</p>",
        "id": 148371544,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543243727
    }
]
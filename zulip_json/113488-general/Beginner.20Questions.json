[
    {
        "content": "<p>I'm really new to LEAN (and anything like it), and I've had some problems that might be considered a little too simple.</p>",
        "id": 128751244,
        "sender_full_name": "Clyde Watson",
        "timestamp": 1530154467
    },
    {
        "content": "<p>Questions answered so far:</p>\n<p>Let's say that I declared a variable a of type int. How do I attribute a value to it (let's say, 3)?</p>\n<p>How would I define a function that searches for a given object in a list?</p>\n<p>How do I know that I've reached the end of a list? I want to know this in order to compare if two strings have the same characters at the same positions.</p>\n<p>Is there a document where I can check all the avaliable commands for Lean?</p>\n<p>How would I declare a local variable inside a function?</p>\n<p>New Questions:</p>\n<p>Do string and list char represent the same type?</p>\n<p>That's it, for now. Thank you all for your time and patience :)</p>",
        "id": 128751249,
        "sender_full_name": "Clyde Watson",
        "timestamp": 1530154467
    },
    {
        "content": "<p>First question: you want a definition. You do it with <code>def my_def : int := 7</code></p>",
        "id": 128751446,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530154811
    },
    {
        "content": "<p>Thank you for that, Simon!</p>",
        "id": 128751738,
        "sender_full_name": "Clyde Watson",
        "timestamp": 1530155447
    },
    {
        "content": "<p>Second question: </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">find</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">option</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">none</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">::</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"mi\">0</span>\n         <span class=\"k\">else</span> <span class=\"n\">do</span> <span class=\"n\">r</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">find</span> <span class=\"n\">ys</span>\n                 <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 128751894,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530155779
    },
    {
        "content": "<p>Thanks again! <span class=\"emoji emoji-1f642\" title=\"simple smile\">:simple_smile:</span> I will try to understand the code.</p>",
        "id": 128752529,
        "sender_full_name": "Clyde Watson",
        "timestamp": 1530156989
    },
    {
        "content": "<p>Don't hesitate to ask more questions. I tried to put as little mysterious stuff as possible but I think if you're not a Haskell adept, <code>do</code>, <code>&lt;-</code>  and <code>return</code> are not obvious.</p>",
        "id": 128752644,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530157228
    },
    {
        "content": "<blockquote>\n<p>First one: Let's say that I declared a variable a of type int. How do I attribute a value to it (let's say, 3)?</p>\n</blockquote>\n<p>The first thing to understand about lean is that it is a <em>functional programming language</em>. If you are used to a more traditional imperative programming language, like C, Java, Python, etc, then there is a bit of culture shock to be had. The big thing to know is that there are no \"variables* in lean in the sense meant by this word in imperative languages. (My professor always said this was a bad name for them and preferred the term \"assignable\" for C/Java style mutable memory locations.) In lean, variables are things that you can substitute values for, but their values never change from the time they are declared. In an imperative language you would call these immutable variables, but there are no mutable variables in lean.</p>\n<p>To declare a variable and give it a value, you can use <code>let</code>:</p>\n<div class=\"codehilite\"><pre><span></span>def f (x : nat) : nat :=\nlet y := 3 in ...\n</pre></div>\n\n\n<p>Here <code>f</code> is a function with an input variable of type <code>nat</code>, and inside the body of the function I've declared a variable <code>y</code> (also of type <code>nat</code>) with value <code>3</code>.</p>",
        "id": 128754968,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530162252
    },
    {
        "content": "<blockquote>\n<p>Second one: How would I define a function that searches for a given object in a list?</p>\n<p>Third, that's related to the second one: How do I know that I've reached the end of a list? I want to know this in order to compare if two strings have the same characters at the same positions.</p>\n</blockquote>\n<p>Usually, a function which is defined on lists will be done by pattern matching, as in Simon's code. This is done in the first two lines, with <code>| [] :=</code> and <code>| (y :: ys) :=</code>. This says what to do if the list is empty, and what to do if it is nonempty with head <code>y</code> and tail <code>ys</code>. Defining the function this way automatically takes care of \"knowing when I've reached the end of a list\", because you can't even get the value from a list unless you are already in the nonempty case - the nonempty check and value retrieval happen at the same time.</p>",
        "id": 128755050,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530162466
    },
    {
        "content": "<p>Here's a function that compares two strings and returns true iff they are equal:</p>\n<div class=\"codehilite\"><pre><span></span>def is_equal : list char → list char → bool\n| []        []        := tt\n| (x :: xs) []        := ff\n| []        (y :: ys) := ff\n| (x :: xs) (y :: ys) := (x = y) &amp;&amp; is_equal xs ys\n</pre></div>",
        "id": 128755147,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530162630
    },
    {
        "content": "<blockquote>\n<p>Fourth: Is there a document where I can check all the avaliable commands for Lean?</p>\n</blockquote>\n<p>This depends on what you mean by \"command\". There are relatively few actual keywords recognized by the lean language, and you can find a relatively complete list in chapters 4 and 5 of the <a href=\"https://leanprover.github.io/reference/\" target=\"_blank\" title=\"https://leanprover.github.io/reference/\">lean reference manual</a>.</p>",
        "id": 128755265,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530162889
    },
    {
        "content": "<blockquote>\n<p>Fifth: How would I declare a local variable inside a function? I tried doing the following:</p>\n</blockquote>\n<div class=\"codehilite\"><pre><span></span>def example_def (a : int) : int :=\nvariable k : int\n</pre></div>\n\n\n<blockquote>\n<p>I have a feeling that I might have to use let k := int in ..., but I'm not really sure.</p>\n</blockquote>\n<p>Since as mentioned there is no such thing as a local assignable in lean, the best you can do is to have a <code>let</code> declaration, which also requires that you provide the local variable with a value. This is because unlike most pointer based languages, there is no \"universal null\" value in all types - the values of a type are all explicitly determined by the type. So if you define a variable of type <code>int</code>, then it must contain an integer value, maybe <code>0</code> or <code>42</code> or something but \"unassigned\" is not an option. <code>let k := int</code> actually declares <code>k</code> to be a variable of type <code>Type</code> with value <code>int</code>, which is probably not what you want.</p>",
        "id": 128755374,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530163157
    },
    {
        "content": "<blockquote>\n<p>Don't hesitate to ask more questions. I tried to put as little mysterious stuff as possible but I think if you're not a Haskell adept, <code>do</code>, <code>&lt;-</code>  and <code>return</code> are not obvious.</p>\n</blockquote>\n<p>You are right, it isn't that obvious. What does \"some 0\" mean?<br>\nI'm having some trouble understand the \"do r &lt;- find ys return (r +1)\" part.  Isn't find missing one argument, that is, the x that it's searching? Also, for some reason, Lean considers ys to have the type \"option nat\".</p>",
        "id": 128804676,
        "sender_full_name": "Clyde Watson",
        "timestamp": 1530235365
    },
    {
        "content": "<p>Thanks a lot for all the explanations, Mario! It really is a shock. It's the first time I'm seeing a functional programming language.</p>",
        "id": 128804735,
        "sender_full_name": "Clyde Watson",
        "timestamp": 1530235477
    },
    {
        "content": "<blockquote>\n<p>Here's a function that compares two strings and returns true iff they are equal:</p>\n</blockquote>\n<p>def is_equal : list char → list char → bool<br>\n| []        []        := tt<br>\n| (x :: xs) []        := ff<br>\n| []        (y :: ys) := ff<br>\n| (x :: xs) (y :: ys) := (x = y) &amp;&amp; is_equal xs ys</p>\n<div class=\"codehilite\"><pre><span></span>\n</pre></div>\n\n\n<p>So, according to the piece of code you sent, whenever I want to compare two kinds of lists, I only have to \"place them\" side by side?</p>",
        "id": 128804790,
        "sender_full_name": "Clyde Watson",
        "timestamp": 1530235617
    },
    {
        "content": "<p>One new quesion: In Lean, are there any differences between string and list char?</p>",
        "id": 128805114,
        "sender_full_name": "Clyde Watson",
        "timestamp": 1530236260
    },
    {
        "content": "<blockquote>\n<p>You are right, it isn't that obvious. What does \"some 0\" mean?</p>\n</blockquote>\n<p><code>some 0</code> could also be written <code>return 0</code>. Both are expressions of type <code>option nat</code>. <code>option nat</code> has two kinds of values <code>none</code> or <code>some n</code> where <code>n</code> is a natural number. That means <code>option nat</code> either contains a single natural number or nothing. <code>return 0</code> comes in handy when you think of <code>option nat</code> as a sequential program that may fail or return a natural number. This leads us to your second question:</p>\n<blockquote>\n<p>I'm having some trouble understand the \"do r &lt;- find ys return (r +1)\" part. Isn't find missing one argument, that is, the x that it's searching? Also, for some reason, Lean considers ys to have the type \"option nat\".</p>\n</blockquote>\n<p>I apologize, the expression has a syntax error in it. It should be <code>do r &lt;- find ys, return (r +1)</code> (notice the comma in the middle). You can read it as \"call <code>find ys</code> then, if it doesn't fail (i.e. produce the value <code>none</code>) take the result (a natural number), call it <code>r</code> and return from the sequence of two instructions with the value of <code>r+1</code>\"</p>",
        "id": 128805586,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530237166
    },
    {
        "content": "<blockquote>\n<p>One new quesion: In Lean, are there any differences between string and list char?</p>\n</blockquote>\n<p>This is extracted from the core library (<a href=\"https://github.com/leanprover/lean/blob/master/library/init/data/string/basic.lean#L10-L18\" target=\"_blank\" title=\"https://github.com/leanprover/lean/blob/master/library/init/data/string/basic.lean#L10-L18\"><code>init/data/string/basic.lean</code></a>):</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c\">/-</span><span class=\"cm\"> In the VM, strings are implemented using a dynamic array and UTF-8 encoding. -/</span>\n<span class=\"kn\">structure</span> <span class=\"n\">string_imp</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">data</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">char</span><span class=\"o\">)</span>\n<span class=\"n\">def</span> <span class=\"n\">string</span> <span class=\"o\">:=</span> <span class=\"n\">string_imp</span>\n</pre></div>",
        "id": 128813110,
        "sender_full_name": "Sean Leather",
        "timestamp": 1530252088
    },
    {
        "content": "<blockquote>\n<p>So, according to the piece of code you sent, whenever I want to compare two kinds of lists, I only have to \"place them\" side by side?</p>\n</blockquote>\n<p>That's the way pattern match syntax works. In this case, since the type of the function is <code>is_equal : list char → list char → bool</code>, there are two arguments, both lists of chars, and so each case should include two variables, possibly broken into cases. In my code snippet I broke into all four cases, but you can combine some of them with wildcards <code>_</code>, depending on the function you are defining. You should read the second case <code>| (x :: xs) [] := ff</code> as being shorthand for the partial specification <code>is_equal (x :: xs) [] = ff</code> of the function <code>is_equal</code>.</p>",
        "id": 128814743,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530255364
    },
    {
        "content": "<blockquote>\n<p>One new quesion: In Lean, are there any differences between string and list char?</p>\n</blockquote>\n<p>Just to unpack Sean's answer a bit: In lean, a string is a wrapper around a <code>list char</code>. The wrapper is there because there is a change of underlying data representation - I believe <code>string</code> is stored as an array of bytes, while <code>list char</code> is a linked list, like all <code>list</code> structures.</p>\n<p>In fact, the whole function <code>is_equal</code> already exists in lean so you don't need to define it - it's just <code>a = b</code> where <code>a b : string</code>. Pretty much all data types defined in lean have an equality test implemented, and you can write equality tests for your own data structures easily as well.</p>",
        "id": 128814833,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530255594
    },
    {
        "content": "<p>Here's another way to write Simon's <code>find</code> function using pattern matching instead of monad notation:</p>\n<div class=\"codehilite\"><pre><span></span>def find (x : nat) : list nat -&gt; option nat\n| [] := none\n| (y :: ys) :=\n  if x = y then some 0 else\n  match find ys with\n  | none := none\n  | some r := some (r + 1)\n  end\n</pre></div>\n\n\n<p>The <code>match</code> acts just like the top level pattern match - it takes the result of <code>find ys</code>, which is an <code>option nat</code>, and breaks into cases depending on if it is <code>none</code> or <code>some r</code> for some <code>r</code>. I mentioned before that lean has no \"universal null\" value, but when you explicitly want to indicate a \"null\" value, you do it with the <code>option</code> type. Essentially, this function either returns a result, wrapped in <code>some</code>, or it returns failure to find the value, encoded as <code>none</code> here (you might use \"null\" for this in other languages).</p>",
        "id": 128815011,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530255923
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120239\">@Clyde Watson</span> I started with Lean after very little functional programming experience (I knew some python / java but only as a hobbyist; I am a professional mathematician). I found <a href=\"http://learnyouahaskell.com/\" target=\"_blank\" title=\"http://learnyouahaskell.com/\">http://learnyouahaskell.com/</a> extremely helpful. Your questions about basic pattern matching seem to indicate that you might be able to learn a lot from this resource (or from some other Haskell learning resources, if the informality of this one is not to your taste). Basically the rule is that if you're defining functions on, or proving things about, so-called \"inductive types\" like the natural numbers or lists, then you use induction (or recursion), and a syntax which is a completely basic part of functional programming with these \"|\"s.</p>",
        "id": 128816419,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530258883
    },
    {
        "content": "<p>terminology note: In Haskell, what we call \"inductive types\" are called (generalized) algebraic data types or GADTs</p>",
        "id": 128816592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530259242
    },
    {
        "content": "<blockquote>\n<p>I started with Lean after very little functional programming experience (I knew some python / java but only as a hobbyist; I am a professional mathematician). I found <a href=\"http://learnyouahaskell.com/\" target=\"_blank\" title=\"http://learnyouahaskell.com/\">http://learnyouahaskell.com/</a> extremely helpful.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> That's pretty cool that you used Learn You a Haskell for Great Good. Did you learn Haskell first and then move to Lean or use it as a tutorial about the related concepts in Lean?</p>",
        "id": 128823178,
        "sender_full_name": "Sean Leather",
        "timestamp": 1530271205
    },
    {
        "content": "<p>I am not sure I have learnt Haskell in any real sense. The reason I mentioned it was that the website I mentioned showed me how to define functions on lists by recursion using exactly the notation that the OP was originally asking about. Basically my history was: hobbyist programmer (written simple Android apps in java etc), then in 2016 I attempted to read learnyouahaskell just because (a) I knew the people on our joint maths and computing degree had to learn it in their first term and (b) I'd had an undergraduate doing a maths project with me on elliptic curves and they'd used Haskell to write their code, and then later in 2016 I tried reading it again, and then in 2017 I started trying to code in Lean and then I went back to it for a third time and this time it all made sense. But the concept of defining a function on lists by defining it on the constructors was something which dawned on me on the first reading.</p>",
        "id": 128823396,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530271634
    },
    {
        "content": "<blockquote>\n<p>Isn't find missing one argument</p>\n</blockquote>\n<p>This is a syntactic oddity of lean--when referring to the thing currently being defined (here <code>find</code>) inside its own definition, parameters to the left of the colon (here <code>(x : nat)</code>) are fixed, and you don't even write them.</p>",
        "id": 128845444,
        "sender_full_name": "Reid Barton",
        "timestamp": 1530299848
    },
    {
        "content": "<p>So <code>find ys</code> inside the definition of <code>find</code> means the same as <code>find x ys</code> outside it</p>",
        "id": 128845733,
        "sender_full_name": "Reid Barton",
        "timestamp": 1530300140
    },
    {
        "content": "<blockquote>\n<p>What does \"some 0\" mean?</p>\n</blockquote>\n<p>I'll show you how to figure this out yourself!</p>\n<p>One really important thing to learn in Lean is that every question of this form is a question which you can begin to investigate yourself, and the sooner you learn how to do this the sooner you can figure out what you need to learn next; you can ask really targetted questions which in general receive better answers. </p>\n<p>Here's how you can use Lean to answer your own question, in VS Code. First open a completely new file called scratch.lean and let's see if we can isolate your question. Make this as the only line:</p>\n<p><code>definition X := some 0</code></p>\n<p>It works! </p>\n<p>[technical note: This isn't always the case -- sometimes the thing you're trying to understand might rely on some file being imported or some namespace being open and you'll have to resort to right-clicking -- see later.]</p>\n<p>Now we have <code>X</code> we can see what this <code>some</code> command really is -- it's defined in the root namespace and is in core lean, so it's probably important. </p>\n<p>Now we can write stuff like</p>\n<p><code>#check X</code></p>\n<p>to see that <code>X</code> is a term of type <code>option ℕ</code>. So it looks like <code>option</code> is a function which eats <code>ℕ</code>. What is the type of <code>ℕ</code>? We just check with</p>\n<p><code>#check ℕ</code></p>\n<p>and we see that <code>ℕ</code> has type <code>Type</code>. So <code>option</code> is a function which eats something of type <code>Type</code>. We can look at what <code>option</code> is with</p>\n<p><code>#check option </code></p>\n<p>and we see it's a function from <code>Type</code> to <code>Type</code> (just ignore the universes, you can worry about these later). So <code>some 0</code> is a term of type <code>option ℕ</code>which has type <code>Type</code>. So that's where <code>some 0</code> lives in the tree of terms, types and universes.</p>\n<p>[Pro tip: always be checking there are no red underlines in your code. Sometimes random typos which you don't bother to fix can have weird consequences later on. Learn how to use <code>sorry</code> to fix red errors in half-written code]</p>\n<p>We didn't look at any definitions yet, we just looked at the types of everything in sight. Everything has a type, and <code>#check x</code> tells you the type of <code>x</code>. Here is a simple picture of the entire type theory of Lean. There are six kinds of things. There are two universes, <code>Type</code> and <code>Prop</code>. A type is something of type <code>Type</code>, and a term is something of type <code>α</code> for <code>α</code> a type. A proposition is something of type <code>Prop</code>, and a proof is something of type <code>H</code> for <code>H</code> a proposition. That's it. The <code>Type</code> stuff is where computer programs live. <code>Prop</code> is where theorems and proofs live. So <code>some 0</code> is a computable thing, it's a term of type <code>option ℕ : Type</code>. </p>\n<p>Next let's actually unravel the definitions. Right-click on <code>some</code> in VS Code and select <code>Go to definition</code> (or left-click and press F12). A new file will open called <code>core.lean</code> and you'll be taken to about line 279 where you'll see that <code>option α</code> is an inductive type with two constructors: <code>none</code> and <code>some val</code> with <code>val : α</code>. So in abstracta your question is answered -- <code>some</code> is a constructor which takes <code>n : ℕ</code> and returns <code>some n : option ℕ</code>. We can just check that with </p>\n<p><code>#check some</code></p>\n<p>and the answer...looks a bit messy. It's clearly some kind of function, but there are question marks. If you don't like those <code>?M_1</code> things, you could use the following trick:</p>\n<p><code>#check @some</code></p>\n<p>which works with functions and which might produce nicer output. Now we see that <code>some</code> is actually a Pi type.</p>\n<p>Here's a gist with all those commands in. One of the fiddly little VS Code options on the right is \"show the output of all the <code>#check</code>s at once\"; that might be the one you want here.</p>\n<p><a href=\"https://gist.github.com/kbuzzard/455709bfd5d8fed57f5e4321481adf5b\" target=\"_blank\" title=\"https://gist.github.com/kbuzzard/455709bfd5d8fed57f5e4321481adf5b\">https://gist.github.com/kbuzzard/455709bfd5d8fed57f5e4321481adf5b</a></p>\n<p>If you get stuck at some point, send the entire file as a gist (just google for how to do it) or, if it's got quite big, just a minimal working example of your question. It's much easier for experts to answer questions with the full file in front of them. Even experts make silly mistakes sometimes, which others can spot instantly. Actually, sometimes I find my own silly mistakes when I am making the minimal working example. And did I mention to make sure there are no errors in your file?</p>\n<p>So that's <code>option</code>, and how to ask if you get stuck along the way. But if you want some more insight as to what the point of this type is, or perhaps want to know more about what an inductive type is or a Pi type, or what the different kinds of brackets all mean (round, squiggly, square), now is the time to go to the docs -- Theorem Proving In Lean is a really good place to look for basic stuff. It's here:</p>\n<p><a href=\"https://leanprover.github.io/theorem_proving_in_lean/\" target=\"_blank\" title=\"https://leanprover.github.io/theorem_proving_in_lean/\">https://leanprover.github.io/theorem_proving_in_lean/</a></p>\n<p>I find the web search functionality really hard to use though; there's a pdf download and I usually search with my pdf viewer and then maybe switch to the html manual later because it looks nicer, if I want to know more. If you want to know more about <code>option</code> then the fourth occurrence of \" option \" in the pdf is the one you want; it's on p101. There you can see a brief description of the point of <code>option</code> and examples of other inductive types which have similar structures. I wish I had learnt this method earlier -- it took a while to dawn on me that you could just work everything out by right clicking and figuring out if you were a term or a type, a proof or a proposition.</p>\n<p>You also need to learn a kind of filter -- stuff you can just ignore for the time being.  Stuff like typeclasses, <code>opt_param</code>/<code>out_param</code>, <code>[stuff in brackets]</code> and universes, you can start to worry about them later. Universes are to do with subtle set-theoretic issues like avoiding Russell's Paradox, and the other stuff is technical computer science stuff which you can just treat as magic for the time being. [Typeclasses are some crazy computer science generalisation of notation overloading]</p>",
        "id": 128853494,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530311359
    },
    {
        "content": "<p>Another beginner question here: Is it possible to \"overload\" an instance?</p>\n<p><code>format</code> has an instance for <code>list α</code>:<br>\n<a href=\"https://github.com/leanprover/lean/blob/e53f8021ec3bd8b6c7c2eb998932ec79cb941b18/library/init/meta/format.lean#L87-L92\" target=\"_blank\" title=\"https://github.com/leanprover/lean/blob/e53f8021ec3bd8b6c7c2eb998932ec79cb941b18/library/init/meta/format.lean#L87-L92\">https://github.com/leanprover/lean/blob/e53f8021ec3bd8b6c7c2eb998932ec79cb941b18/library/init/meta/format.lean#L87-L92</a><br>\nAnd I'd like to customize that in various places. For instance, say, I'd want to drop the outer square brackets, or another time make the items semicolon-separated rather than comma-separated</p>",
        "id": 128879959,
        "sender_full_name": "Amin Bandali",
        "timestamp": 1530364085
    },
    {
        "content": "<p>It is possible but I wouldn't advise using it that way. Instead, you should explicitly invoke the formatting code that you're interested in. Just to be sure, can you show an example where that would be handy?</p>",
        "id": 128884679,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530373120
    },
    {
        "content": "<p>I see. The example I was aiming to use that for was a <code>structure</code> with a <code>(exts : list string)</code> field, which I wanted format using <code>format!\"EXTENDS {my_struct.exts}\"</code></p>",
        "id": 128884895,
        "sender_full_name": "Amin Bandali",
        "timestamp": 1530373545
    },
    {
        "content": "<p>Yes, that's what I thought. If you replace <code>format!\"EXTENDS {my_struct.exts}\"</code> with `format!\"EXTENDS {my_to_fmt my_struct.exts}\" you should get the same result. Unlike in Haskell, Lean doesn't guarantee global uniqueness of instances so you have to be vigilant not to make the instance search more difficult</p>",
        "id": 128885052,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1530373854
    },
    {
        "content": "<p>Thanks for the explanations <span class=\"emoji emoji-1f642\" title=\"simple smile\">:simple_smile:</span>  makes sense</p>",
        "id": 128885421,
        "sender_full_name": "Amin Bandali",
        "timestamp": 1530374602
    },
    {
        "content": "<p>Hi, I'm following a simple tutorial for Lean and an exercice is to define a curry function and an uncurry function.<br>\nCould anyone help me with this please?</p>\n<p>def curry (α β γ : Type) (f : α × β → γ) : α → β → γ := sorry<br>\ndef uncurry (α β γ : Type) (f : α → β → γ) : α × β → γ := sorry</p>",
        "id": 129013476,
        "sender_full_name": "Guy Leroy",
        "timestamp": 1530611889
    },
    {
        "content": "<p>If you have <code>a : α</code> and <code>b : β</code> then I can make an element of type <code>α × β</code> by writing <code>⟨a, b⟩</code>. The pointy bracket is written with <code>\\&lt;</code>. If I have <code>x : α × β</code>, then <code>x.1</code> is the first element of the pair and <code>x.2</code> is the second element.</p>",
        "id": 129013840,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1530612601
    },
    {
        "content": "<p>Oh thank you. I am still struggling though, the best I came up with is:</p>\n<p>def curry (α β γ : Type) (f : α × β → γ) : α → β → γ := λ f x, f x.1 x.2 <br>\ndef uncurry (α β γ : Type) (f : α → β → γ) : α × β → γ := λ f a b, f ⟨a, b⟩  </p>\n<p>which is obvisouly wrong  as the types don't match but I can't figure out how to make it work</p>",
        "id": 129014538,
        "sender_full_name": "Guy Leroy",
        "timestamp": 1530613541
    },
    {
        "content": "<p>Any other hint?</p>",
        "id": 129014608,
        "sender_full_name": "Guy Leroy",
        "timestamp": 1530613589
    },
    {
        "content": "<p>Your answers are perfect, except they are swapped</p>",
        "id": 129014636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530613635
    },
    {
        "content": "<p>To add to Chris's answer, there are a couple of things you can do to learn what you need to do.</p>\n<ul>\n<li><code>×</code> is notation for <code>prod</code>. How would you know this? You can do <code>#print ×</code> in a file and see <code>_ </code>×<code>:35 _:34 := prod #1 #0</code>.</li>\n<li>Want to find out more about <code>prod</code>, use <code>#print prod</code>.</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">derive</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">pexpr</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"n\">has_reflect</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">pexpr</span><span class=\"o\">)]</span>\n<span class=\"kn\">structure</span> <span class=\"n\">prod</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"n\">fields</span><span class=\"o\">:</span>\n<span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">},</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">snd</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">},</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span>\n</pre></div>\n\n\n<ul>\n<li><code>structure</code>s have a default constructor <code>mk</code>. Try <code>#print prod.mk</code>.</li>\n<li>Lastly, <code>⟨a, ..., z⟩</code> is the anonymous constructor that works for many structures and types.</li>\n</ul>",
        "id": 129014639,
        "sender_full_name": "Sean Leather",
        "timestamp": 1530613652
    },
    {
        "content": "<p>They're not quite perfect. You need to get rid of the <code>f</code>s in the lambdas. In lean syntax anything before the colon doesn't need to be introduced with a lambda.</p>",
        "id": 129014717,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1530613773
    },
    {
        "content": "<p>This is correct.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">curry</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">⟩</span>\n<span class=\"n\">def</span> <span class=\"n\">uncurry</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n</pre></div>",
        "id": 129014776,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1530613817
    },
    {
        "content": "<p>Just to help you see, these are also possible:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">curry</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">⟩</span>\n<span class=\"n\">def</span> <span class=\"n\">uncurry</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n</pre></div>",
        "id": 129014805,
        "sender_full_name": "Sean Leather",
        "timestamp": 1530613917
    },
    {
        "content": "<p>Thank you all for the detailed answers! Greatly appreciate it</p>",
        "id": 129014848,
        "sender_full_name": "Guy Leroy",
        "timestamp": 1530613928
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111947\">@Guy Leroy</span> Everything is completely logical and you have a logical brain; I remember being confused about all of this a year ago. You came to my talk yesterday, right? <code>alpha -&gt; beta -&gt; gamma</code> is a type, and you make terms of that type using <code>lambda</code>. After the <code>lambda</code> you'd better take a term of type alpha and then a term of type beta, and then you need to return a term of type gamma. So now hopefully you can get your terms sorted out. For products however, you need to learn the notation. The type is <code>\\alpha \\times \\beta</code> so now you need to know the constructor and the eliminators, which is a fancy way of saying that you need to know how to get something of type <code>alpha x beta</code> from <code>a : alpha</code> and <code>b : beta</code> (that's the constructor for the product) and then you also need to know how to get the things of type alpha and beta from the thing of type <code>alpha x beta</code> -- those are the eliminators. So that's three different pieces of notation -- one for making the product type (that's \\times), one for the constructor (that's pointy brackets) and one for the elminators (that's the <code>.1</code> and <code>.2</code> notation). A year ago all of these were floating around in my head and I'd just try any of them until something worked. But now I realise that if you keep everything straight then it all starts fitting into place. The pointy brackets are often used for constructors, the dots are often used for eliminators (I hope they are called eliminators, I'm no expert) and the notation for the types depends on the type but is something you pick up as you go along.</p>",
        "id": 129015912,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530615652
    },
    {
        "content": "<p>As for the stuff before or after the colon, I've realised that this trips mathematicians up. I need to write something about functions. There's so much functiony stuff which CS people do which is very cool but which we don't see in maths at all! Even using functions as maps from props to props is new to mathematicians.</p>",
        "id": 129015940,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530615720
    },
    {
        "content": "<p>Actually <code>.1</code> is called a projection</p>",
        "id": 129016068,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530615911
    },
    {
        "content": "<p>an eliminator is <code>prod.rec</code> for example</p>",
        "id": 129016073,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530615922
    },
    {
        "content": "<p>Thank you for the explanation. Yes I came yesterday. The syntax is slowly starting to make sense, I'm a bit confused at first as we were taught Haskell in first year and it has some similar features.</p>",
        "id": 129016118,
        "sender_full_name": "Guy Leroy",
        "timestamp": 1530615967
    },
    {
        "content": "<p>But I understand the curry/uncurry functions and their syntax now I think</p>",
        "id": 129016126,
        "sender_full_name": "Guy Leroy",
        "timestamp": 1530616016
    },
    {
        "content": "<blockquote>\n<p>an eliminator is <code>prod.rec</code> for example</p>\n</blockquote>\n<p>Technical interlude: are the projections defined using <code>prod.rec</code> or are they inbuilt and appear like axioms when the product type is defined? I don't know how to figure this out. I guess they would be easy to define using <code>prod.rec</code>.</p>",
        "id": 129016361,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530616348
    },
    {
        "content": "<blockquote>\n<p>But I understand the curry/uncurry functions and their syntax now I think</p>\n</blockquote>\n<p>When I did that exercise last year, the first thing I wanted to prove was that if you curried and then uncurried, you got back to where you started! But at that point in TPIL you don't have enough tools to do that.</p>",
        "id": 129016391,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530616438
    },
    {
        "content": "<p>\"The dot operator is how you access the members of an object\" I think I once read in a book on Java. Is this not the appropriate language in Lean? It feels like the same sort of thing.</p>",
        "id": 129016497,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530616563
    },
    {
        "content": "<p>It's a bit hard to tell just by looking at the definition, but projections are defined using the recursor/eliminator</p>",
        "id": 129016598,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530616777
    },
    {
        "content": "<p><a href=\"https://www.quora.com/In-type-theory-what-is-an-eliminator-and-what-is-its-opposite\" target=\"_blank\" title=\"https://www.quora.com/In-type-theory-what-is-an-eliminator-and-what-is-its-opposite\">In type theory, what is an eliminator, and what is its opposite?</a></p>",
        "id": 129016607,
        "sender_full_name": "Sean Leather",
        "timestamp": 1530616802
    },
    {
        "content": "<p>Conclusion: a projection is an eliminator.</p>",
        "id": 129016667,
        "sender_full_name": "Sean Leather",
        "timestamp": 1530616901
    },
    {
        "content": "<p>In lean, projections are a limited version of the <code>cases_on</code> eliminator</p>",
        "id": 129016806,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530617106
    },
    {
        "content": "<p>They only work when the inductive only has one constructor (which is why they are only generated for <code>structure</code>s)</p>",
        "id": 129016815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530617141
    },
    {
        "content": "<p>and they are obviously nonrecursive (in programming languages with a fixpoint operator this is not as important as it is in lean)</p>",
        "id": 129016862,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530617173
    },
    {
        "content": "<p>The projections are even harder to unfold than I remember... Even <code>#reduce</code> doesn't unfold them, I have to unfold first to the underlying projection macro (printed as <code>[prod.fst c]</code>), and then force that to expand through a <code>change</code>:</p>\n<div class=\"codehilite\"><pre><span></span>#print prod.fst\n-- @[reducible]\n-- def prod.fst : Π {α : Type u} {β : Type v}, prod α β → α :=\n-- λ (α : Type u) (β : Type v) (c : prod α β), [prod.fst c]\nexample {α β} (a : α × β) : prod.fst.{0 0} a = sorry :=\nbegin\n  delta prod.fst,\n  change @prod.cases_on _ _ _ _ _ = _,\n  -- prod.cases_on a (λ (fst : α) (snd : β), fst) = sorry\nend\n</pre></div>",
        "id": 129017129,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530617644
    },
    {
        "content": "<p>I tend to do <code>cases a, dsimp</code> while writing a proof, though I can usually remove the <code>dsimp</code> before I'm done.</p>",
        "id": 129017389,
        "sender_full_name": "Sean Leather",
        "timestamp": 1530618051
    },
    {
        "content": "<p>Rohan Mitta has just asked me how to formalise an exercise on the topological spaces example sheet: prove that if T1 and T2 are topologies on X (i.e. T1 and T2 are sets of subsets of X) then their intersection is a topology.</p>",
        "id": 129033519,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530635421
    },
    {
        "content": "<p>this is in lean already</p>",
        "id": 129033547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530635466
    },
    {
        "content": "<p>That sounds like a question to me, but somehow when you formalise it in Lean it becomes more like a construction. I figured that he needed some predicate <code>is_open_sets</code> and I just glanced through the topological space lean file and didn't spot it</p>",
        "id": 129033550,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530635470
    },
    {
        "content": "<p>I'm sure it's in Lean already, they form some complete semilattice or whatever</p>",
        "id": 129033562,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530635484
    },
    {
        "content": "<p>it's part of the construction of the complete lattice</p>",
        "id": 129033572,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530635493
    },
    {
        "content": "<p>I just saw that. But Rohan is trying to learn how to use Lean so I am happy to encourage him to figure this exercise out himself!</p>",
        "id": 129033578,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530635501
    },
    {
        "content": "<p>It's in Lean but it doesn't look like a proposition, it looks like a construction</p>",
        "id": 129033592,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530635520
    },
    {
        "content": "<p>Is <code>is_open_sets</code> in Lean? I couldn't find it</p>",
        "id": 129033642,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530635542
    },
    {
        "content": "<p>it is a construction</p>",
        "id": 129033644,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530635543
    },
    {
        "content": "<p>It looks like an exercise</p>",
        "id": 129033659,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530635561
    },
    {
        "content": "<p>what does <code>is_open_sets</code> mean?</p>",
        "id": 129033665,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530635569
    },
    {
        "content": "<p><code>is_open_sets</code> is a map from set (set X) to Prop and it's the conjunction of the axioms saying that the sets are the opens in a topology. Am I not thinking straight?</p>",
        "id": 129033700,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530635624
    },
    {
        "content": "<p>And he wants to prove is_open_sets A and is_open_sets B implies is_open_sets (A intersect B)</p>",
        "id": 129033765,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530635663
    },
    {
        "content": "<p>Am I making sense?</p>",
        "id": 129033773,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530635671
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">is_open_sets</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">is_open</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">is_open</span> <span class=\"n\">univ</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">is_open</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">is_open</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"err\">∩</span> <span class=\"n\">t</span><span class=\"o\">))</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">t</span><span class=\"err\">∈</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">is_open</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"err\">⋃₀</span> <span class=\"n\">s</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 129033890,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530635768
    },
    {
        "content": "<p>I think it's that</p>",
        "id": 129033894,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530635773
    },
    {
        "content": "<p>Now I can make the example sheet question into a proposition.</p>",
        "id": 129034040,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530635952
    },
    {
        "content": "<p>Is this some equivalent way of formalising the notion of a topological space? Why did we choose the other way?</p>",
        "id": 129034141,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530636053
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">is_to_top</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">is_open</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">is_open_sets</span> <span class=\"o\">(</span><span class=\"n\">is_open</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_open</span> <span class=\"o\">:=</span> <span class=\"n\">is_open</span><span class=\"o\">,</span>\n  <span class=\"n\">is_open_univ</span> <span class=\"o\">:=</span> <span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">,</span>\n  <span class=\"n\">is_open_inter</span> <span class=\"o\">:=</span> <span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">,</span>\n  <span class=\"n\">is_open_sUnion</span> <span class=\"o\">:=</span> <span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"bp\">.</span><span class=\"n\">right</span>\n<span class=\"o\">}</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">top_to_is</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_open_sets</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">is_open</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">is_open_univ</span><span class=\"o\">,</span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">is_open_inter</span><span class=\"o\">,</span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">is_open_sUnion</span><span class=\"bp\">⟩</span>\n</pre></div>",
        "id": 129034388,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530636306
    },
    {
        "content": "<p>They're kind of the same</p>",
        "id": 129034394,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530636311
    },
    {
        "content": "<p>yes, it is equivalent to unbundling the set (set A) part of topological_space</p>",
        "id": 129034413,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530636340
    },
    {
        "content": "<p>The difference is just that the mathlib definition does not have the properties split off together into a separate structure/definition</p>",
        "id": 129034414,
        "sender_full_name": "Reid Barton",
        "timestamp": 1530636342
    },
    {
        "content": "<p>So what I find myself wondering again and again is what the best way is. A year ago there were plenty of things I could formalise in 0 ways; now I find there are plenty of things I can formalise in two ways, and I really struggle to know the right way. What I have now understood is that in some sense it doesn't matter, because if I write a good enough API then probably any one of my choices will be fine. But I am beginning to realise that there's more at stake than this.</p>",
        "id": 129035139,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530637179
    },
    {
        "content": "<p>particularly in view of the complete lattice structure, the intersection theorem is only one part of bigger structure, and using it as such makes  sense of the whole finer/coarser thing in a more disciplined way</p>",
        "id": 129035491,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530637557
    },
    {
        "content": "<p>I really am a beginner, so forgive me if I sound incredibly stupid.<br>\nI'm trying to define a function which can add vectors with entries in <code>ℕ</code>.<br>\nI tried something like this:<br>\n<code>namespace vectest\n    universe u\n    constant vec : Type u → ℕ → Type u\n    def vec_add (n : ℕ) : vec (list ℕ) n → vec (list ℕ) n → vec (list ℕ) n := sorry\nend vectest </code><br>\nI don't see how I could specify the desired function like this - of course I intend my input to be a vector of length <code>n</code> with entries in <code>ℕ</code>, but Lean just sees (as far as I can tell) something of Type <code>list ℕ</code> which happens to depend on <code>n</code>. I can't really expect to be able to extract values from the list and add them, then put them back into a new list of length <code>n</code>, if Lean doesn't know that's what I'm talking about, right?</p>",
        "id": 129076394,
        "sender_full_name": "Sjoerd de Vries",
        "timestamp": 1530699244
    },
    {
        "content": "<p>Hi Sjoerd. I would generally discourage the use of <code>constant</code>. Is the idea that you want to model vectors of length <code>n</code> with entries in <code>nat</code>?</p>",
        "id": 129076676,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530699681
    },
    {
        "content": "<p>Yes, that's the idea.</p>",
        "id": 129076678,
        "sender_full_name": "Sjoerd de Vries",
        "timestamp": 1530699697
    },
    {
        "content": "<p>The best way to do that is a function <code>fin n → nat</code>. <code>fin n</code> is a type with <code>n</code> elements.</p>",
        "id": 129076726,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1530699758
    },
    {
        "content": "<p>So I can think of <code>fin n</code> as being a discrete set with <code>n</code> elements and of vectors as functions. Is there a pre-defined way of adding functions that I can then use to add vectors? And how would I find out if this thing exists without asking any of you?</p>",
        "id": 129076959,
        "sender_full_name": "Sjoerd de Vries",
        "timestamp": 1530700118
    },
    {
        "content": "<p>I think it's not so hard to write these functions yourself and it would probably be a good exercise.</p>",
        "id": 129077522,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530701132
    },
    {
        "content": "<p><code>algebra/pi_instances</code> contains all of these for <code>add</code>, <code>mul</code> etc</p>",
        "id": 129077578,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1530701183
    },
    {
        "content": "<p>Sjoerd -- feel free to send me a private message if you don't want to spam the chat. <code>fin n</code> is a type which has exactly <code>n</code> terms, which you can think of as 0,1,...,n-1.</p>",
        "id": 129077664,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530701289
    },
    {
        "content": "<p>Defining <code>vector</code> as a function is quite unusual because of the resulting runtime complexity (which you may not be interested in). The common definitions are as an inductive type (<a href=\"https://github.com/leanprover/lean/blob/a4aae537fe771ee92d746d4a2be1e73c543e48b9/tests/lean/run/smt_ematch3.lean#L5-L7\" target=\"_blank\" title=\"https://github.com/leanprover/lean/blob/a4aae537fe771ee92d746d4a2be1e73c543e48b9/tests/lean/run/smt_ematch3.lean#L5-L7\">e.g.</a>) or as a subtype of <code>list</code> (<a href=\"https://github.com/leanprover/lean/blob/master/library/data/vector.lean\" target=\"_blank\" title=\"https://github.com/leanprover/lean/blob/master/library/data/vector.lean\"><code>data.vector</code></a>).</p>",
        "id": 129077943,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1530701733
    },
    {
        "content": "<p>Hey, would anyone mind explaining how to prove <code>A ∨ B</code> given two propositions <code>A</code> and <code>B</code> and a proof of A?</p>",
        "id": 129318433,
        "sender_full_name": "Zak",
        "timestamp": 1531094245
    },
    {
        "content": "<p>I think the question looks a bit like this; </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">prove_or</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">proof_A</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∨</span> <span class=\"n\">B</span>\n</pre></div>",
        "id": 129318435,
        "sender_full_name": "Zak",
        "timestamp": 1531094273
    },
    {
        "content": "<p>You can prove it as:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">prove_or</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">proof_A</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∨</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">proof_A</span>\n</pre></div>\n\n\n<p>or </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">prove_or</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">proof_A</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∨</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">proof_A</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 129318792,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1531095036
    },
    {
        "content": "<p>Thank you :D <code>left</code> will be very useful</p>",
        "id": 129318803,
        "sender_full_name": "Zak",
        "timestamp": 1531095114
    },
    {
        "content": "<p>Fun fact: <code>left</code> works with any inductive type. It applies the first constructor while <code>right</code> applies the second constructor.</p>",
        "id": 129320318,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1531098678
    },
    {
        "content": "<p><a href=\"https://leanprover.github.io/theorem_proving_in_lean/tactics.html#more-tactics\" target=\"_blank\" title=\"https://leanprover.github.io/theorem_proving_in_lean/tactics.html#more-tactics\">https://leanprover.github.io/theorem_proving_in_lean/tactics.html#more-tactics</a></p>",
        "id": 129329261,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1531115071
    },
    {
        "content": "<p>I was mulling over <code>∨</code> as a result of this question, thinking how one could explain to a beginner how to work this out, and as a result I ran into something which I myself didn't understand. Is <code>∨</code> left associative or right associative? If you can't remember then I figured that one way of finding out was just checking for yourself:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span> <span class=\"bp\">=</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</pre></div>\n\n\n<p>I was expecting precisely one of these to work. But neither does! The first one (which is the right answer) gives the error</p>\n<div class=\"codehilite\"><pre><span></span>type mismatch, term\n  rfl\nhas type\n  ?m_2 = ?m_2\nbut is expected to have type\n  P ∨ Q ∨ R = P ∨ Q ∨ R\n</pre></div>",
        "id": 129334456,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531123581
    },
    {
        "content": "<p>Why does <code>rfl</code> not prove that?</p>",
        "id": 129334461,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531123611
    },
    {
        "content": "<p>because <code>=</code> is less important than <code>∨</code></p>",
        "id": 129334482,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1531123672
    },
    {
        "content": "<p>think about what a = b or c = d means</p>",
        "id": 129334521,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1531123687
    },
    {
        "content": "<p>(pp.all would have shown you the problem)</p>",
        "id": 129334533,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1531123742
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</pre></div>",
        "id": 129334550,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1531123801
    },
    {
        "content": "<p>Another beginner question: I would like to understand why <code>apply</code> is failing in the following example:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">real</span> <span class=\"n\">order</span><span class=\"bp\">.</span><span class=\"n\">filter</span>\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">real</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tendsto</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">tendsto_mul</span><span class=\"o\">,</span>   <span class=\"c1\">-- this line fails</span>\n  <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">tendsto_const_nhds</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">tendsto_id</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>I know how to work it out with <code>apply tendsto_mul _ _</code> or <code>refine tendsto_mul _ _</code> or a direct term proof, but with the above it fails with the error message</p>\n<div class=\"codehilite\"><pre><span></span>invalid apply tactic, failed to unify\n  tendsto (λ (x : ℝ), a * x) (nhds c) (nhds (a * c))\nwith\n  tendsto ?m_3 ?m_4 (nhds ?m_6) → tendsto ?m_7 ?m_4 (nhds ?m_8) → tendsto (λ (x : ?m_1), ?m_3 x * ?m_7 x) ?m_4 (nhds (?m_6 * ?m_8))\n</pre></div>\n\n\n<p>What I don't get is why this unification problem is hard. Any hint?</p>",
        "id": 129334753,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1531124099
    },
    {
        "content": "<p>This is higher order unification</p>",
        "id": 129334812,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1531124166
    },
    {
        "content": "<p>You want Lean to recognize a product of functions</p>",
        "id": 129334820,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1531124215
    },
    {
        "content": "<p>no that isn't it</p>",
        "id": 129334825,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1531124229
    },
    {
        "content": "<p>But it could be a product in many ways, in principle</p>",
        "id": 129334826,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1531124229
    },
    {
        "content": "<p>I suspect it's <code>apply</code> not knowing which term is the last thing</p>",
        "id": 129334884,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1531124314
    },
    {
        "content": "<p>Hum, it's weird that <code>apply tendsto_mul _ _</code> works</p>",
        "id": 129334905,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1531124356
    },
    {
        "content": "<p>note that <code>tendsto</code> is itself defined as a pi</p>",
        "id": 129334982,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531124445
    },
    {
        "content": "<p>this has been known to confuse <code>apply</code> in the past</p>",
        "id": 129334989,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531124462
    },
    {
        "content": "<blockquote>\n<p>because <code>=</code> is less important than <code>∨</code></p>\n</blockquote>\n<p>How ironic that the reason the question came up was that the output of <code>#print notation ∨</code> was what inspired me to ask the question, so I already knew that <code>∨</code> was unimportant. Thanks Kenny. It's not the first time I've been done over by binding powers -- I get caught out by <code>∃</code> occasionally too.</p>",
        "id": 129335071,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531124605
    },
    {
        "content": "<blockquote>\n<p>note that <code>tendsto</code> is itself defined as a pi</p>\n</blockquote>\n<p>You mean <code>apply</code> unfolds the definition of <code>tendsto</code> all the way up to the filter inclusion, which is indeed a pi? And then I am not surprised it is confused. Is there a way to tell lean that is should never unfold by itself the definition of <code>tendsto</code>, to avoid the problem?</p>",
        "id": 129335914,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1531125917
    },
    {
        "content": "<p>these instructions are already in place</p>",
        "id": 129336027,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531126095
    },
    {
        "content": "<p><code>apply</code> is not supposed to look that deep, but it does</p>",
        "id": 129336028,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531126107
    },
    {
        "content": "<p>it will even look through <code>@[irreducible]</code> definitions, unlike almost anything else</p>",
        "id": 129336037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531126143
    },
    {
        "content": "<p>Yes, I can see that the definition of subset is protected... Do you know if this behavior of <code>apply</code>is by design, and for what reason? This is a real pain for what I would like to do.</p>",
        "id": 129336172,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1531126393
    },
    {
        "content": "<p>It's certainly a bug, but we've got to live with it until lean 4 comes around. It only concerns the calculation of how many underscores to insert, and only then in limited circumstances (I'm not sure Patrick was that far off the mark with the note about higher order unification)</p>",
        "id": 129336641,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531127254
    },
    {
        "content": "<p>I think, after you unfold EVERYTHING, the tendsto becomes a bunch of pis applied to a metavariable (the unknown target topology set), which may unfold to still more pis but lean can't be sure</p>",
        "id": 129336770,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531127418
    },
    {
        "content": "<p>Thanks for your explanations. Indeed, for proofs written by hand, adding some underscores is not a problem. </p>\n<p>I wanted to try my hand at automation, adding <code>@[tendsto_rules]</code> before <code>tendsto</code> lemmas. With the aim that writing <code>applys [tendsto_rules]</code> would try to <code>apply</code>successively all the tagged rules, to prove convergence statements. Since <code>apply</code> does not work well in this context, I will have to find another exercise to learn tactics.</p>\n<p>For fun, an even \"better\" example: in my example above, if you try to replace the line <code>exact tendsto_const_nhds</code> with <code>apply tendsto_const_nhds</code> it fails (while the unification looks even easier as there are no premises in <code>tendsto_const_nhds</code>), but it works with <code>apply @tendsto_const_nhds _ _ _ _ _</code> (I agree, it is only a matter of getting the right number of underscores :)</p>",
        "id": 129338353,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1531129778
    },
    {
        "content": "<p>You could write a tactic which is <code>apply</code> but which works the way you want it to ;-) I have no idea how hard that would be!</p>",
        "id": 129339844,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531131633
    },
    {
        "content": "<p>It looks like <code>apply</code> is written in C, not Lean</p>",
        "id": 129342154,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1531134540
    },
    {
        "content": "<p>I probably speak C++ better than lean, but still I will rather find another exercise, this one is not for me!</p>",
        "id": 129343466,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1531136413
    },
    {
        "content": "<p>I'm sure there's a simple way to use combine values of Prop and if-then-else statements. But I can't find it. What would you put in the place of <code>sorry</code> below? Thanks!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">5</span>\n<span class=\"kd\">def</span> <span class=\"n\">uni</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">Fin</span> <span class=\"n\">k</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">em</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span>  <span class=\"n\">uni</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">k</span> <span class=\"k\">then</span> <span class=\"o\">⟨</span> <span class=\"n\">n</span> <span class=\"o\">,</span> <span class=\"gr\">sorry</span> <span class=\"o\">⟩</span>\n           <span class=\"k\">else</span> <span class=\"o\">⟨</span> <span class=\"n\">k</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 318018898,
        "sender_full_name": "Tomáš Jakl",
        "timestamp": 1672100727
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">em</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span>  <span class=\"n\">uni</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">k</span> <span class=\"k\">then</span> <span class=\"o\">⟨</span> <span class=\"n\">n</span> <span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">⟩</span>\n           <span class=\"k\">else</span> <span class=\"o\">⟨</span> <span class=\"n\">k</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 318019215,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672101010
    },
    {
        "content": "<p>Krásný večer přeji!</p>",
        "id": 318135779,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672163344
    },
    {
        "content": "<p>Continuing with shockingly trivial questions. I'm trying to define the type of all (directed) graphs. From what I know from type theory, the type should be defined as <code>\\sum a : Type, Graph a</code> where <code>Graph a</code> could be defined as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Graph</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">edge</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>why is it that then</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Graphs</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"bp\">\\</span><span class=\"n\">sum</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"n\">Graph</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>gives me an error \"expected token\"?</p>\n<p>Am I doing something fundamentally wrong or what am I not understanding? Thanks a lot for any pointers!</p>",
        "id": 318578801,
        "sender_full_name": "Tomáš Jakl",
        "timestamp": 1672404440
    },
    {
        "content": "<p>Because you either have to use the pure ASCII identifier of the Sigma type or the actual unicode:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Graph</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">edge</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">×</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Graphs</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"bp\">Σ</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"n\">Graph</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>or</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Graphs</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">Sigma</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Graph</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>also note that there is no need to dive into type theory or anything here, you can also define it as a structure if you wish:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Graphs</span> <span class=\"n\">where</span>\n  <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Graph</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 318580258,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1672404920
    },
    {
        "content": "<p>Thanks for answering. Sorry for being sloppy, I did use unicode in the editor but not here. It turns out that I was using ∑ (i.e. <code>\\sum</code>) instead of Σ (i.e. <code>\\Sigma</code>) <span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span> No idea how come I missed that there's a distinction between the two in Lean...</p>\n<p>(Although, it is a bit weird that <strong>sum</strong> types are not typeset with <code>\\sum</code>...)</p>",
        "id": 318589886,
        "sender_full_name": "Tomáš Jakl",
        "timestamp": 1672408117
    },
    {
        "content": "<p>As a mathematician I would say the converse -- it would have been a bit weird if mathematical <strong>sum</strong>s of real numbers were not typeset with <code>\\sum</code>.</p>",
        "id": 318606451,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672413527
    },
    {
        "content": "<p>Is it possible to prove that <code>ℕ ≠ ℤ</code>?</p>",
        "id": 318612995,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1672415889
    },
    {
        "content": "<p>What do you mean by that?</p>",
        "id": 318613092,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672415933
    },
    {
        "content": "<p>Is it possible to fill in the <code>sorry</code> in this code?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">≠</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 318613195,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1672415981
    },
    {
        "content": "<p>This question isn’t for any particular purpose, I just wondered if that’s a thing that can be done in Lean</p>",
        "id": 318613404,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1672416027
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"574896\">Sabrina Jewson</span> <a href=\"#narrow/stream/113488-general/topic/Beginner.20Questions/near/318613195\">said</a>:</p>\n<blockquote>\n<p>Is it possible to fill in the <code>sorry</code> in this code?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">≠</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This is a good question that I, unfortunately, cannot answer.</p>",
        "id": 318613522,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672416077
    },
    {
        "content": "<p>No, it's not possible.</p>",
        "id": 318613695,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672416151
    },
    {
        "content": "<p>I was thinking about something different. You somehow identify <code>(1 : ℕ)</code> with <code>(1 : ℤ)</code> and <code>(2 : ℕ)</code> with <code>(2 : ℤ)</code> and so on and you want to show that there are elements of <code>ℤ</code> with no corresponding thing on the <code>ℕ</code> side.</p>",
        "id": 318613767,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672416184
    },
    {
        "content": "<p>Which is not a claim about the sizes of the sets, but it speaks about a concrete embedding of natural numbers into integers.</p>",
        "id": 318613872,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672416234
    },
    {
        "content": "<p>I was thinking about taking <code>N : set ℕ := λ n, true</code> and <code>Z : set ℤ := λ z, true</code> and then wanting to reason about <code>N</code> coerced to act like <code>set ℤ</code> instance.</p>",
        "id": 318614423,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672416441
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/Beginner.20Questions/near/318613695\">said</a>:</p>\n<blockquote>\n<p>No, it's not possible.</p>\n</blockquote>\n<p>Interesting — more generally, for which types <code>T</code> and <code>U</code> is it impossible to prove that <code>T ≠ U</code>? I discovered that I can easily do it for <code>empty ≠ ℕ</code> using <code>not_nonempty_iff</code>, so is it just possible for the empty/nonempty distinction or are they more ways?</p>",
        "id": 318614673,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1672416525
    },
    {
        "content": "<p>I'd be first interested for which types <code>T</code> and <code>U</code> we can prove <code>T = U</code>. The identity relation is defined for all <code>Sort</code> levels, so it should a syntactically valid proposition.</p>",
        "id": 318614939,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672416615
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"574896\">Sabrina Jewson</span> <a href=\"#narrow/stream/113488-general/topic/Beginner.20Questions/near/318614673\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/Beginner.20Questions/near/318613695\">said</a>:</p>\n<blockquote>\n<p>No, it's not possible.</p>\n</blockquote>\n<p>Interesting — more generally, for which types <code>T</code> and <code>U</code> is it impossible to prove that <code>T ≠ U</code>?</p>\n</blockquote>\n<p>The only way is to prove that T and U have different cardinalities</p>",
        "id": 318615180,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672416718
    },
    {
        "content": "<p>oh okay, that makes sense, let me try it</p>",
        "id": 318615306,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1672416757
    },
    {
        "content": "<p>Okay got it working :D</p>",
        "id": 318616455,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1672417181
    },
    {
        "content": "<p>Thanks for the advice, that’s very interesting</p>",
        "id": 318616473,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1672417192
    },
    {
        "content": "<p>Can you please show us what you proved?</p>",
        "id": 318616602,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672417224
    },
    {
        "content": "<p>I want to learn what can be done with types.</p>",
        "id": 318616625,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672417234
    },
    {
        "content": "<p>I didn’t put effort into making my proof nice though, be warned :V</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">c1</span>\n<span class=\"bp\">|</span> <span class=\"n\">c2</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"n\">c1</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"k\">from</span> <span class=\"o\">⟨</span><span class=\"n\">a.c1</span><span class=\"o\">,</span> <span class=\"n\">a.c2</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">contradiction</span> <span class=\"kd\">end</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">ha</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">ha</span> <span class=\"k\">with</span> <span class=\"n\">y</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"n\">contradiction</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 318616857,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1672417274
    },
    {
        "content": "<p>I prove first that <code>∃ x y : a, x ≠ y</code>, then substitute in <code>a</code> for <code>b</code>, then show that this is a contradiction (as all <code>b</code> values are equal)</p>",
        "id": 318617029,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1672417334
    },
    {
        "content": "<p>You could also prove this by showing that the cardinality of a is 2 and the cardinality of b is 1. In general this is the only technique to prove that types are unequal in lean because the cardinality model of Lean's type theory would have all types of a given cardinality being type synonyms for a fixed type; in that model Nat does equal Int, which is why it's not possible to prove that they're unequal in lean</p>",
        "id": 318617496,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672417473
    },
    {
        "content": "<p>So <code>ℕ = ℤ</code> can be proved?</p>",
        "id": 318617601,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672417521
    },
    {
        "content": "<p>No. It just can't be disproved.</p>",
        "id": 318617629,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672417536
    },
    {
        "content": "<p>Good.</p>",
        "id": 318617640,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672417544
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113488-general/topic/Beginner.20Questions/near/318614939\">said</a>:</p>\n<blockquote>\n<p>I'd be first interested for which types <code>T</code> and <code>U</code> we can prove <code>T = U</code>. The identity relation is defined for all <code>Sort</code> levels, so it should a syntactically valid proposition.</p>\n</blockquote>\n<p>..</p>",
        "id": 318617673,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672417561
    },
    {
        "content": "<p>Trying to prove equality of types is \"evil\" in a precise sense. It's not the right question in Lean's type theory.</p>",
        "id": 318617819,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672417616
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"574896\">Sabrina Jewson</span> <a href=\"#narrow/stream/113488-general/topic/Beginner.20Questions/near/318616857\">said</a>:</p>\n<blockquote>\n<p>I didn’t put effort into making my proof nice though, be warned :V</p>\n</blockquote>\n<p>I know that nobody asked and nobody cares, but this is my refactor of your proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"n\">a.c1</span><span class=\"o\">,</span> <span class=\"n\">use</span> <span class=\"n\">a.c2</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">ha</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">neq</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">neq</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 318618612,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672417901
    },
    {
        "content": "<p>You taught me a new thing — equality between types can be used in <code>rw</code>.</p>",
        "id": 318618811,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672417968
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Beginner.20Questions/near/318617819\">said</a>:</p>\n<blockquote>\n<p>Trying to prove equality of types is \"evil\" in a precise sense. It's not the right question in Lean's type theory.</p>\n</blockquote>\n<p>Can someone tell us more than \"don't do it\" please?</p>",
        "id": 318618931,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1672418017
    },
    {
        "content": "<p>You can prove equalities of types in roughly three scenarios:</p>\n<ul>\n<li>The types are definitionally equal, i.e. if <code>def foo := nat</code> then <code>foo</code> and <code>nat</code> are provably equal.</li>\n<li>The types are built from the same inductive families applied to equal arguments, for example <code>fin (a + b)</code>  and <code>fin (b + a)</code> are equal because <code>a + b = b + a</code> and <code>fin</code> is a function (a type function, but a function nonetheless)</li>\n<li>There is a coincidence of different indices of an inductive family being equal because of cardinality considerations (roughly: cantor's theorem). That is, if you have an inductive family <code>inductive foo : set Type -&gt; Type</code> then it can't be injective because no such function can be.</li>\n</ul>",
        "id": 318619410,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672418175
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">@[derive fintype]</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">c1</span>\n<span class=\"bp\">|</span> <span class=\"n\">c2</span>\n\n<span class=\"kd\">@[derive fintype]</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"n\">c1</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"kd\">by</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨⟩</span> <span class=\"o\">:</span> <span class=\"n\">fintype.card</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">fintype.card</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 318637989,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672425740
    },
    {
        "content": "<p>I think this can be golfed, but I can't get rid of the <code>simp only</code> because the rewrite isn't type-correct.</p>",
        "id": 318638107,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672425796
    },
    {
        "content": "<p>Golfing your proof using mathlib <code>rcases</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">c1</span>\n<span class=\"bp\">|</span> <span class=\"n\">c2</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"n\">c1</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hab</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">a.c1</span><span class=\"o\">,</span> <span class=\"n\">a.c2</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">a.no_confusion</span> <span class=\"n\">m</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">hab</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨⟨⟩,</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 318643000,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672428053
    },
    {
        "content": "<p>Lean 4 has <code>rcases</code> in <code>Std</code> so you don't need to use mathlib to have access to it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.RCases</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">c1</span>\n<span class=\"bp\">|</span> <span class=\"n\">c2</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"n\">c1</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hab</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">a.c1</span><span class=\"o\">,</span> <span class=\"n\">a.c2</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.noConfusion</span> <span class=\"n\">m</span><span class=\"o\">⟩</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hab</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨⟨⟩,</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 318643565,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672428293
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Beginner.20Questions/near/318617819\">said</a>:</p>\n<blockquote>\n<p>Trying to prove equality of types is \"evil\" in a precise sense. It's not the right question in Lean's type theory.</p>\n</blockquote>\n<p>Note that it can be interesting to prove equality of types (or lemmas that let you rewrite one type into the other) When writing functions though. For example when we are operating on length indexed lists and there is two different arithmetic expression in the length index of two lists and we would like to say zip it with a function of type <code>List a n -&gt; List b n -&gt; List (Prod a b) n</code> it can be interesting to prove that the types of the two lists are in fact equal by showing that the two arithmetic expressions in their indices match up.</p>",
        "id": 318668585,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1672443638
    },
    {
        "content": "<p>Precisely this sort of problem, when the two <code>n</code>s aren't definitionally equal, was a genuine issue with category theory in LTE. We have had to develop tools such as <code>eq_to_hom</code> and <code>eq_to_iso</code> to manage the stuck <code>eq.rec</code> terms.</p>",
        "id": 318676372,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672449968
    },
    {
        "content": "<p>I proved they weren't equal in term mode in Lean 4:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">c1</span>\n<span class=\"bp\">|</span> <span class=\"n\">c2</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"n\">c1</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">xₐ</span> <span class=\"n\">yₐ</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">xₐ</span> <span class=\"bp\">≠</span> <span class=\"n\">yₐ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">a.c1</span><span class=\"o\">,</span> <span class=\"n\">a.c2</span><span class=\"o\">,</span> <span class=\"n\">a.noConfusion</span><span class=\"o\">⟩</span>\n  <span class=\"k\">have</span> <span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span> <span class=\"o\">:</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">x'</span> <span class=\"bp\">≠</span> <span class=\"n\">y'</span> <span class=\"o\">:=</span> <span class=\"n\">hab</span> <span class=\"bp\">▸</span> <span class=\"n\">h</span>\n  <span class=\"n\">hb.casesOn</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨⟩</span> <span class=\"o\">⟨⟨⟩,</span> <span class=\"n\">hxy</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">hxy</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 318676389,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672450010
    },
    {
        "content": "<p>The equality in Lean is \"underspecified\", i.e. we don't determine everything with the current rules and axioms. A few ways to specify that are</p>\n<ul>\n<li>Add the ability to pattern match on types, which gives us a no-confusion thing. This sort of makes the universe an inductive type.</li>\n<li>Univalence.</li>\n<li>Something in the style of observational type theory. This sort of makes the universe a coinductive type.</li>\n</ul>",
        "id": 318681080,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1672454786
    },
    {
        "content": "<p>A quick way to see if something cannot be proved in Lean, is to look at these three possibilities. If they disagree then the proposition can't be proved or disproved. (For the N=Z thing, the result is \"false, true, depends\", so you know you can't prove or disprove it)</p>",
        "id": 318681324,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1672455043
    },
    {
        "content": "<p>I would like function of this form:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">finmap.map_keys</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">finmap</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">γ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f_inj</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">finmap</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I spent a while trying to implement it myself and ended up with around 50 lines of code:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Lots of code…</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">list.map_keys</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n  <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">list.map</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">pair</span><span class=\"o\">,</span> <span class=\"n\">sigma.mk</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">pair.fst</span><span class=\"o\">)</span> <span class=\"n\">pair.snd</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">list.map_keys_cons</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">tl</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">γ</span><span class=\"o\">)}</span>\n  <span class=\"o\">:</span> <span class=\"n\">list.map_keys</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">hd</span> <span class=\"o\">::</span> <span class=\"n\">tl</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">sigma.mk</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">hd.fst</span><span class=\"o\">)</span> <span class=\"n\">hd.snd</span> <span class=\"o\">::</span> <span class=\"n\">list.map_keys</span> <span class=\"n\">f</span> <span class=\"n\">tl</span>\n<span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">finmap.map_keys</span>\n  <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">finmap</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">γ</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f_inj</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">finmap</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"n\">m.lift_on</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">m.entries.map_keys</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finmap</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">perm</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">cases</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">a_entries</span> <span class=\"n\">a_nodupkeys</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"n\">b_entries</span> <span class=\"n\">b_nodupkeys</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">perm</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">perm</span> <span class=\"k\">with</span>\n        <span class=\"n\">head</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"n\">l₁_perm_l₂</span> <span class=\"n\">perm_ih</span>\n        <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">tail</span>\n        <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"n\">l₃</span> <span class=\"n\">l₁_perm_l₂</span> <span class=\"n\">l₂_perm_l₃</span> <span class=\"n\">perm_ih₁</span> <span class=\"n\">perm_ih₂</span>\n    <span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">list.map_keys_cons</span><span class=\"o\">,</span> <span class=\"n\">list.map_keys_cons</span><span class=\"o\">,</span> <span class=\"n\">finmap.to_finmap_cons</span><span class=\"o\">,</span> <span class=\"n\">finmap.to_finmap_cons</span><span class=\"o\">],</span>\n      <span class=\"n\">rw</span> <span class=\"n\">perm_ih</span> <span class=\"o\">(</span><span class=\"n\">list.nodupkeys_cons.mp</span> <span class=\"n\">a_nodupkeys</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">list.nodupkeys_cons.mp</span> <span class=\"n\">b_nodupkeys</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n    <span class=\"o\">{</span>\n      <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">list.map_keys_cons</span><span class=\"o\">,</span> <span class=\"n\">finmap.to_finmap_cons</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n      <span class=\"n\">apply</span> <span class=\"n\">finmap.insert_insert_of_ne</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">a_nodupkeys</span><span class=\"o\">,</span>\n      <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">a_nodupkeys.left</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"o\">(</span><span class=\"n\">f_inj</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">),</span>\n    <span class=\"o\">},</span>\n    <span class=\"o\">{</span>\n      <span class=\"k\">have</span> <span class=\"n\">l₂_nodupkeys</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"o\">(</span><span class=\"n\">list.perm_nodupkeys</span> <span class=\"n\">l₁_perm_l₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">a_nodupkeys</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">perm_ih₁</span> <span class=\"n\">a_nodupkeys</span> <span class=\"n\">l₂_nodupkeys</span><span class=\"o\">,</span> <span class=\"n\">perm_ih₂</span> <span class=\"n\">l₂_nodupkeys</span> <span class=\"n\">b_nodupkeys</span><span class=\"o\">],</span>\n    <span class=\"o\">}</span>\n  <span class=\"kd\">end</span><span class=\"o\">)</span>\n</code></pre></div>\n</div></div>\n<p>It’s unfortunately quite a lot — is there any way to shorten this? Is there a really useful method in mathlib that I’m missing?</p>",
        "id": 318755617,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1672501902
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Beginner.20Questions/near/318676372\">said</a>:</p>\n<blockquote>\n<p>Precisely this sort of problem, when the two <code>n</code>s aren't definitionally equal, was a genuine issue with category theory in LTE. We have had to develop tools such as <code>eq_to_hom</code> and <code>eq_to_iso</code> to manage the stuck <code>eq.rec</code> terms.</p>\n</blockquote>\n<p>In graph theory, we don't have the luxury of identity morphisms, so we instead had to develop tools like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.walk.copy\">docs#simple_graph.walk.copy</a></p>\n<p>This was recently added to category theory as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quiver.hom.cast\">docs#quiver.hom.cast</a> for work on quivers, which can't in general just use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.eq_to_hom\">docs#category_theory.eq_to_hom</a></p>",
        "id": 318756874,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1672502384
    },
    {
        "content": "<p>It seems to be a good dependent types design pattern to write a custom <code>eq.rec</code> that's specifically for rewriting indices in type constructors, to \"cast\" terms of the type to terms of an equal type in a more controlled way. For example, having a <code>cast</code> function to rewrite the length of a length-indexed list types.</p>",
        "id": 318757220,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1672502559
    },
    {
        "content": "<p>Informally, I might try to prove that <code>ℕ ≠ ℤ</code> by observing that <code>-1 ∈ ℤ</code> and that <code>-1 ∉ ℕ</code>. Is this not a correct proof / is this not possible in Lean?</p>",
        "id": 318783649,
        "sender_full_name": "Tyler Josephson ⚛️",
        "timestamp": 1672522005
    },
    {
        "content": "<p>That's just a syntax error in lean: for <code>a \\mem b</code> to typecjeck b must be a term of type <code>set something</code></p>",
        "id": 318786525,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672524580
    },
    {
        "content": "<p>You could interpret this as showing <code>set.Ici (0 : ℤ) ≠ set.univ</code>, but that certainly isn't showing <code>ℕ ≠ ℤ</code>.</p>",
        "id": 318787529,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1672525433
    },
    {
        "content": "<p>I spent an embarrassingly long time trying to prove that <code>ℕ ≠ ℤ</code> and I now think that it is unlikely that such a proof is possible in Lean. Here's why I think that:<br>\nNatural numbers and integers have the same cardinality, so there is some bijection <code>nat_to_int</code> between them. We choose such a bijection (preferably one where <code>nat_to_int (0 : ℕ) = (0 : ℤ)</code>). We can now define the <code>ℤ</code> equivalent of <code>nat.succ</code> by converting from int to nat, adding 1, then converting back. I call this new function <code>new_succ</code>. It has type <code>ℤ -&gt; ℤ</code>.<br>\nAn important fact about natural numbers is that every natural number is expressible as <code>nat.succ</code> applied some amount of times to <code>nat.zero</code>. Now with our new function, every integer is expressible as <code>new_succ</code> applied some amount of times to <code>(0 : ℤ)</code>. I can prove this by showing that the recursor for natural numbers also holds true for integers:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Lots of code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">set_theory.cardinal.basic</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cardinality_equal</span> <span class=\"o\">:</span> <span class=\"n\">cardinal.mk</span> <span class=\"n\">ℕ</span> <span class=\"bp\">=</span> <span class=\"n\">cardinal.mk</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"n\">eq.trans</span> <span class=\"n\">cardinal.mk_nat</span> <span class=\"n\">cardinal.mk_int.symm</span>\n<span class=\"kd\">def</span> <span class=\"n\">nat_to_int_conversion_exists</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">≃</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">quotient.exact</span> <span class=\"n\">cardinality_equal</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">nat_to_int_conversion</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">≃</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"n\">classical.choice</span> <span class=\"n\">nat_to_int_conversion_exists</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">nat_to_int</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"n\">nat_to_int_conversion.to_fun</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">int_to_nat</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">nat_to_int_conversion.inv_fun</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">nat_to_int_left_inv</span> <span class=\"o\">:</span> <span class=\"n\">function.left_inverse</span> <span class=\"n\">int_to_nat</span> <span class=\"n\">nat_to_int</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat_to_int_conversion.left_inv</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">nat_to_int_right_inv</span> <span class=\"o\">:</span> <span class=\"n\">function.right_inverse</span> <span class=\"n\">int_to_nat</span> <span class=\"n\">nat_to_int</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat_to_int_conversion.right_inv</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">new_succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">nat_to_int</span> <span class=\"o\">((</span><span class=\"n\">int_to_nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">int.new_rec</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">},</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">nat_to_int</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">new_succ</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">motive</span> <span class=\"n\">base_case</span> <span class=\"n\">ind_case</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">set</span> <span class=\"n\">motive'</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">nat_to_int</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">hmot</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">base_case'</span> <span class=\"o\">:</span> <span class=\"n\">motive'</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">hmot</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">base_case</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">ind_case'</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">motive'</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">motive'</span> <span class=\"n\">n.succ</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">k</span> <span class=\"n\">prev_step</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">hmot</span> <span class=\"n\">at</span> <span class=\"bp\">⊢</span> <span class=\"n\">prev_step</span><span class=\"o\">,</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">ind_case</span> <span class=\"o\">(</span><span class=\"n\">nat_to_int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">prev_step</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">new_succ</span> <span class=\"n\">at</span> <span class=\"n\">ind_case</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">nat_to_int_left_inv</span> <span class=\"n\">k</span> <span class=\"n\">at</span> <span class=\"n\">ind_case</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">ind_case</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">nat.rec</span> <span class=\"n\">motive'</span> <span class=\"n\">base_case'</span> <span class=\"n\">ind_case'</span> <span class=\"o\">(</span><span class=\"n\">int_to_nat</span> <span class=\"n\">n</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"n\">hmot</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">nat_to_int_right_inv</span> <span class=\"n\">n</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>\n<p>Note how <code>int.new_rec</code> basically has the same type as <code>nat.rec</code>, except we have <code>int</code> instead of <code>nat</code> and <code>new_succ</code> instead of <code>nat.succ</code>. We also have <code>nat_to_int 0</code> instead of <code>0</code> but it would be <code>(0 : ℤ)</code> if I chose a more convenient bijection. Since every proof about natural numbers essentially boils down to a bunch of <code>nat.zero</code>, <code>nat.succ</code>, and <code>nat.rec</code> calls, any proof about the natural numbers can be translated to a proof about the integers simply by replacing all instances of <code>nat.succ</code> with <code>new_succ</code>, etc. (well, at least I think it can, I don't know if it has the same definitional equalities).</p>\n<p>Since every proof about natural numbers can be translated to an equivalent proof about integers, there's no way to prove <code>ℕ ≠ ℤ</code> because then that proof could be translated to <code>ℤ ≠ ℤ</code> by doing the substitution described above.</p>\n<p>I'm not entirely sure if my argument is sound, but it made sense in my head at least.</p>",
        "id": 318912066,
        "sender_full_name": "Niels Voss",
        "timestamp": 1672612207
    },
    {
        "content": "<p>You could have believed Reid :)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/Beginner.20Questions/near/318613695\">said</a>:</p>\n<blockquote>\n<p>No, it's not possible.</p>\n</blockquote>",
        "id": 318913817,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1672613788
    },
    {
        "content": "<p>I figured as much, I just wanted to see if I could justify why to myself</p>",
        "id": 318913888,
        "sender_full_name": "Niels Voss",
        "timestamp": 1672613872
    },
    {
        "content": "<p>I'm not sure your argument is sound. If your argument is correct, wouldn't it <em>prove</em> that $\\mathbb{Z} = \\mathbb{N}$, by translating one side of the true statement $\\mathbb{N} = \\mathbb{N}$?</p>",
        "id": 318915981,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1672616155
    },
    {
        "content": "<p>No, because there's no way in Lean to make a function that takes some arbitrary proof and substitutes all instances of <code>nat.succ</code> with <code>new_succ</code>, etc. The rules of Lean don't really allow it, and the closest would could get is a tactic. My argument is necessarily meta-theoretic. Assuming I didn't make a mistake in my reasoning, it would only prove that equality of types is independent of the axioms, and neither prove nor disprove it.<br>\nOn the other hand, I'm not entirely sure my argument is watertight either because I don't really have a great understanding of type theory and there might be some detail I missed that would make it impossible to translate all proofs (something like the computation rule not getting translated).</p>",
        "id": 318917095,
        "sender_full_name": "Niels Voss",
        "timestamp": 1672617461
    }
]
[
    {
        "content": "<p>Hello! Something I would really like for working with types that have many constructors is some kind of code generator for structural recursion in which I only want to touch some subsets of the constructors. For example, consider a simple type of formulas:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">var</span><span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">plus</span><span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">mult</span><span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n</pre></div>\n\n\n<p>for which I need to write a rename-variables function that changes all 'x's to 'y's:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">rename</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">):</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">nm</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">nm</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">nm</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">plus</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">plus</span> <span class=\"o\">(</span><span class=\"n\">rename</span> <span class=\"n\">f₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rename</span> <span class=\"n\">f₂</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">mult</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">mult</span> <span class=\"o\">(</span><span class=\"n\">rename</span> <span class=\"n\">f₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rename</span> <span class=\"n\">f₂</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>Most of this function is trivial and simply calls itself recursively on occurrences of the same type within constructors. Writing such functions is boring and most of the code is boilerplate. Instead, I would like a way to simply say:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">recurse</span><span class=\"o\">]</span>\n<span class=\"n\">def</span> <span class=\"n\">rename</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">):</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">nm</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">nm</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>or something similarly short and have Lean autogenerate the rest. Does anyone know if something like or close to it is possible? Has it been done in another language?<br>\n(This seems like the kind of thing some variation on lenses could work for but I'm not quite sure.)</p>",
        "id": 185274492,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1578619492
    },
    {
        "content": "<p>I think I would break down the problem into generating a <code>replace</code> function which looks like:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">replace</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">formula</span><span class=\"o\">):</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">y</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">var</span> <span class=\"n\">v</span>\n    <span class=\"bp\">|</span> <span class=\"n\">plus</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">plus</span> <span class=\"o\">(</span><span class=\"n\">replace</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">replace</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">mult</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">mult</span> <span class=\"o\">(</span><span class=\"n\">replace</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">replace</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n    <span class=\"kn\">end</span>\n  <span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>(not sure if that compiles) and then define your recursive function (by hand or automatically) as:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">rename</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">nm</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"err\">$</span> <span class=\"k\">if</span> <span class=\"n\">nm</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">none</span>\n\n<span class=\"n\">def</span> <span class=\"n\">rename&#39;</span>  <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"o\">:=</span>\n<span class=\"n\">replace</span> <span class=\"o\">(</span><span class=\"n\">rename</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 185275016,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1578620089
    },
    {
        "content": "<p>The code for <code>replace</code> can be generated using the <code>induction</code> tactic.</p>",
        "id": 185275033,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1578620124
    },
    {
        "content": "<p>Actually, no. All the hash function is doing is checking that the proof object is unchanged. Lean could concatenate a version number to the proof it gives to Axiom (for the GCD, for example). When Axiom returns the GCD computation, Lean has to decide to trust the result. So Axiom provides the proof that Lean initially provided for GCD (which Axiom stored a long time ago) and the hash code. Lean can then concatenate the version number of the proof checker to the proof source code, compute the hash and compare it to the prior hash. If either the version number is wrong or the proof text has changed then the hash won't match.</p>\n<p>A hash mismatch due to a version number change on Lean's proof checker means that Lean needs to fully check the provided proof. If the version number hasn't changed then the proof text must have changed and Lean needs to fully check the provided proof. But if the hash matches then nothing has changed and there is evidence that the GCD proof previously passed Lean's proof checker so it doesn't need to be re-checked, saving a lot of work.</p>\n<p>The hash has nothing to do with the actual method of proof.</p>\n<p>The problem to solve is to scale proof checking and trusted computation to larger computations. A Groebner basis can have many steps using other algorithms and each proof of each sub-algorithm needs to be provided to Lean to be checked. A hash checker would make this a very low cost but very trustable operation.</p>",
        "id": 185282186,
        "sender_full_name": "Tim Daly",
        "timestamp": 1578631857
    },
    {
        "content": "<p>The cryptographic idea that directly applies is called HMAC.key-hashed message authentication codes.</p>",
        "id": 185282641,
        "sender_full_name": "Tim Daly",
        "timestamp": 1578632454
    },
    {
        "content": "<p>Thanks Simon! <code>replace</code> doesn't compile but a version where the structural recursion is top-level does:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">replace₂</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">formula</span><span class=\"o\">):</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">z</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">y</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">z</span>\n  <span class=\"kn\">end</span>\n<span class=\"bp\">|</span> <span class=\"n\">z</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">plus</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">y</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">plus</span> <span class=\"o\">(</span><span class=\"n\">replace₂</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">replace₂</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"kn\">end</span>\n<span class=\"bp\">|</span> <span class=\"n\">z</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">mult</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">y</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">mult</span> <span class=\"o\">(</span><span class=\"n\">replace₂</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">replace₂</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>It works for the simple case, however I should have been more specific in that I also want to consider functions which may include arbitrary processing of recursive results, e.g.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">recurse</span><span class=\"o\">]</span>\n<span class=\"n\">def</span> <span class=\"n\">rename</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">):</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">nm</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">nm</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">nm</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">plus</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">mult</span> <span class=\"o\">(</span><span class=\"n\">rename</span> <span class=\"n\">f₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rename</span> <span class=\"n\">f₂</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>which I'm not sure generalize into a single higher-order function since then one cannot call <code>replace</code> from <code>rename</code>. This is the reason why I asked about code generation. I guess that's what tactics do and <code>induction</code> is a good shout for going some way towards shorter definitions.</p>",
        "id": 185302002,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1578655828
    },
    {
        "content": "<p>Let's try this again, then.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">rewrite</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span><span class=\"o\">):</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">e</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">e</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">plus</span> <span class=\"n\">e</span> <span class=\"n\">e&#39;</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">plus</span> <span class=\"o\">(</span><span class=\"n\">rewrite</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rewrite</span> <span class=\"n\">e&#39;</span><span class=\"o\">))</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">mult</span> <span class=\"n\">e</span> <span class=\"n\">e&#39;</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">mult</span> <span class=\"o\">(</span><span class=\"n\">rewrite</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rewrite</span> <span class=\"n\">e&#39;</span><span class=\"o\">))</span>\n</pre></div>\n\n\n<p>Then you should be able to write <code>rename</code> so that, together with <code>rewrite</code> it will form <code>rename_all</code>. What do you think?</p>",
        "id": 185307320,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1578660902
    },
    {
        "content": "<p>I think this is also one of the big selling points of recursion schemes (ala Haskell) if you're interested, but I haven't actually studied them enough to know if you could implement them in Lean. <span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> Do you know if anything like Haskell's <code>Fix</code> can be done with Lean?</p>",
        "id": 185307758,
        "sender_full_name": "Chris B",
        "timestamp": 1578661297
    },
    {
        "content": "<p>I also love recursion schemes. <code>Fix</code> is hard to encode directly but there are ways to get close. The simplest approach would be to define it as:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">fix</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">fix</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">fix</span>\n</pre></div>\n\n\n<p>It's not quite perfect though. For one thing, <code>fix</code> lies in a different universe than <code>F</code> so <code>F fix</code> is not type correct. More type trickery can still help here.</p>\n<p>In another direction, <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, <span class=\"user-mention\" data-user-id=\"110865\">@Jeremy Avigad</span> and I wrote a paper last year defining quotients of polynomial functors and using them to construct broader classes of inductive and coinductive data types in Lean. <code>Fix</code> is a direct result of that theory <a href=\"https://www.andrew.cmu.edu/user/avigad/Papers/qpf.pdf\" target=\"_blank\" title=\"https://www.andrew.cmu.edu/user/avigad/Papers/qpf.pdf\">QPF</a>.</p>",
        "id": 185308549,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1578662096
    },
    {
        "content": "<blockquote>\n<p>Then you should be able to write <code>rename</code> so that, together with <code>rewrite</code> it will form <code>rename_all</code>. What do you think?</p>\n</blockquote>\n<p>Indeed that should work, but it will not if I modify the function a bit:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">weird_rename</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">):</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">nm</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">nm</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">nm</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">plus</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">mult</span> <span class=\"n\">f₁</span> <span class=\"o\">(</span><span class=\"n\">weird_rename</span> <span class=\"n\">f₂</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>To express this, <code>rewrite</code> would have to pass both rewritten and not-rewritten results, which can be done but I think it would have to make the resulting <code>rewrite'</code> very specific. On first glance recursion schemes do seem to be solving a similar problem, thanks for the link!</p>",
        "id": 185309823,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1578663220
    },
    {
        "content": "<p>No worries</p>",
        "id": 185313233,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1578665963
    },
    {
        "content": "<p>Consider the following, I think it helps with your weird case:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">open</span> <span class=\"n\">formula</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">formula_struct</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">plus₁</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">f₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">formula_struct</span> <span class=\"n\">f₁</span> <span class=\"o\">(</span><span class=\"n\">plus</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">plus₂</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">f₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">formula_struct</span> <span class=\"n\">f₂</span> <span class=\"o\">(</span><span class=\"n\">plus</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">mult₁</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">f₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">formula_struct</span> <span class=\"n\">f₁</span> <span class=\"o\">(</span><span class=\"n\">mult</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">mult₂</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">f₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">formula_struct</span> <span class=\"n\">f₂</span> <span class=\"o\">(</span><span class=\"n\">mult</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">weird_rename</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">):</span> <span class=\"bp\">Π</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">formula</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">f&#39;</span><span class=\"o\">,</span> <span class=\"n\">formula_struct</span> <span class=\"n\">f&#39;</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">nm</span><span class=\"o\">)</span> <span class=\"n\">rec</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"err\">$</span> <span class=\"k\">if</span> <span class=\"n\">nm</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">nm</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">plus</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span><span class=\"o\">)</span> <span class=\"n\">rec</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"err\">$</span> <span class=\"n\">mult</span> <span class=\"n\">f₁</span> <span class=\"o\">(</span><span class=\"n\">rec</span> <span class=\"n\">f₂</span> <span class=\"err\">$</span> <span class=\"k\">by</span> <span class=\"n\">constructor</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">mult</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">none</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">well_founded_struct</span> <span class=\"o\">:</span> <span class=\"n\">well_founded</span> <span class=\"n\">formula_struct</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">variable</span> <span class=\"n\">step</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">formula</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">f&#39;</span><span class=\"o\">,</span> <span class=\"n\">formula_struct</span> <span class=\"n\">f&#39;</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">formula</span>\n\n<span class=\"kn\">notation</span> <span class=\"bp\">`</span><span class=\"err\">♯</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">constructor</span>\n\n<span class=\"n\">def</span> <span class=\"n\">rewrite</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"o\">:=</span>\n<span class=\"n\">well_founded</span><span class=\"bp\">.</span><span class=\"n\">fix</span> <span class=\"n\">well_founded_struct</span> <span class=\"err\">$</span>\n<span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n<span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">e</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">rec</span><span class=\"o\">,</span>\n               <span class=\"k\">match</span> <span class=\"n\">step</span> <span class=\"n\">e</span> <span class=\"n\">rec</span> <span class=\"k\">with</span>\n               <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">e&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">e&#39;</span>\n               <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">e</span>\n               <span class=\"kn\">end</span>\n<span class=\"bp\">|</span> <span class=\"n\">e</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">plus</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">rec</span><span class=\"o\">,</span>\n               <span class=\"k\">match</span> <span class=\"n\">step</span> <span class=\"n\">e</span> <span class=\"n\">rec</span> <span class=\"k\">with</span>\n               <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">e&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">e&#39;</span>\n               <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">plus</span> <span class=\"o\">(</span><span class=\"n\">rec</span> <span class=\"n\">x</span> <span class=\"err\">♯</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rec</span> <span class=\"n\">y</span> <span class=\"err\">♯</span><span class=\"o\">)</span>\n               <span class=\"kn\">end</span>\n<span class=\"bp\">|</span> <span class=\"n\">e</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">mult</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">rec</span><span class=\"o\">,</span>\n               <span class=\"k\">match</span> <span class=\"n\">step</span> <span class=\"n\">e</span> <span class=\"n\">rec</span> <span class=\"k\">with</span>\n               <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">e&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">e&#39;</span>\n               <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">mult</span> <span class=\"o\">(</span><span class=\"n\">rec</span> <span class=\"n\">x</span> <span class=\"err\">♯</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rec</span> <span class=\"n\">y</span> <span class=\"err\">♯</span><span class=\"o\">)</span>\n               <span class=\"kn\">end</span>\n<span class=\"kn\">end</span>\n\n<span class=\"n\">def</span> <span class=\"n\">weird_rename_all</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">):</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"o\">:=</span>\n<span class=\"n\">rewrite</span> <span class=\"o\">(</span><span class=\"n\">weird_rename</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 185313248,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1578665984
    },
    {
        "content": "<p>(it compiles)</p>",
        "id": 185313258,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1578665990
    },
    {
        "content": "<p>But the proof of well-foundedness of the structural ordering is left as an exercise</p>",
        "id": 185313327,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1578666028
    },
    {
        "content": "<p>You can also opt for a different well-founded relation</p>",
        "id": 185313346,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1578666047
    },
    {
        "content": "<p>Thanks Simon, this is quite an interesting solution! By the way, is the generation of a <code>formula_struct</code> roughly similar to what the equation compiler does?</p>",
        "id": 185317563,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1578668723
    },
    {
        "content": "<blockquote>\n<p>By the way, is the generation of a formula_struct roughly similar to what the equation compiler does?</p>\n</blockquote>\n<p>No. When declaring <code>formula</code>, an axiom is added to the system:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"bp\">@</span><span class=\"n\">formula</span><span class=\"bp\">.</span><span class=\"n\">rec</span>\n<span class=\"c1\">-- formula.rec :</span>\n<span class=\"c1\">--   Π {C : formula → Sort u_1},</span>\n<span class=\"c1\">--     (Π (a : string), C (formula.var a)) →</span>\n<span class=\"c1\">--     (Π (a a_1 : formula), C a → C a_1 → C (formula.plus a a_1)) →</span>\n<span class=\"c1\">--     (Π (a a_1 : formula), C a → C a_1 → C (formula.mult a a_1)) →</span>\n<span class=\"c1\">--      Π (n : formula), C n</span>\n</pre></div>\n\n\n<p>This is called a recursor. It is expressive enough to encode structural recursion and induction.</p>",
        "id": 185340685,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1578683196
    },
    {
        "content": "<p>Right, <code>weird_rename</code> is indeed expressible via <code>formula.rec</code>. I was wondering more whether the equation compiler is capable of generating well-foundedness relations similar to <code>formula_struct</code> in the <code>wf_rec</code> module when structural recursion fails, as is the case for <code>rewrite</code> but to think of it now that seems to be asking for way too much.</p>",
        "id": 185362075,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1578699823
    },
    {
        "content": "<p>We could get <code>formula_struct</code> generated ourselves</p>",
        "id": 185362431,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1578700194
    }
]
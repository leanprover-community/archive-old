[
    {
        "content": "<p>We seem to have a diamond as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.lattice</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- Succeeds</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">set.boolean_algebra</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">pi.boolean_algebra</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- Fails</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">set.complete_boolean_algebra</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">pi.complete_boolean_algebra</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Is this known?</p>",
        "id": 303258442,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665407763
    },
    {
        "content": "<p>Hmm that's something I thought I had fixed. I'll investigate</p>",
        "id": 303260313,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665408541
    },
    {
        "content": "<p>Thanks, I'd be very grateful!</p>",
        "id": 303260352,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665408553
    },
    {
        "content": "<p>Note that this does not morally need fixing (because <code>set</code> is a type synonym) but in this case I know that this working is related to defeqs we do care about.</p>",
        "id": 303260677,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665408668
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Did you find time to investigate this? If not, I'm happy just to open an issue for it and move on.</p>",
        "id": 303633074,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665583174
    },
    {
        "content": "<p>I appreciate the point about <code>set</code> being a type synonym but if it helps here is an example where this comes up for me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.measure.measure_space</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span> <span class=\"n\">measure_theory</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">limsup_sdiff</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">complete_boolean_algebra</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">l.limsup</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">\\</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">l.limsup</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">\\</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">limsup_eq_infi_supr</span><span class=\"o\">,</span> <span class=\"n\">sdiff_eq</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"n\">binfi_inf</span> <span class=\"o\">(⟨</span><span class=\"n\">set.univ</span><span class=\"o\">,</span> <span class=\"n\">univ_mem</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">),</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">inf_comm</span><span class=\"o\">,</span> <span class=\"n\">inf_bsupr_eq</span><span class=\"o\">,</span> <span class=\"n\">inf_comm</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">limsup_ae_eq_of_forall_ae_eq</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"n\">n</span> <span class=\"bp\">=ᵐ</span><span class=\"o\">[</span><span class=\"n\">μ</span><span class=\"o\">]</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"c1\">-- limsup at_top s =ᵐ[μ] t :=</span>\n  <span class=\"bp\">@</span><span class=\"n\">limsup</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">ℕ</span> <span class=\"n\">_</span> <span class=\"n\">at_top</span> <span class=\"n\">s</span> <span class=\"bp\">=ᵐ</span><span class=\"o\">[</span><span class=\"n\">μ</span><span class=\"o\">]</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp_rw</span> <span class=\"n\">ae_eq_set</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">limsup_sdiff</span> <span class=\"n\">at_top</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">measure_limsup_eq_zero</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"o\">},</span> <span class=\"c1\">-- Omitting this proof to keep MWE short</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 303633244,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665583213
    },
    {
        "content": "<p>The point is that I am forced to write <code>@limsup (set α) ℕ _ at_top s</code> rather than <code>limsup at_top s</code> because of the diamond.</p>",
        "id": 303633372,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665583250
    },
    {
        "content": "<p>I believe the reason this is happening is that in the hypothesis <code>h : ∀ n, s n =ᵐ[μ] t</code>, Lean is required to see through the <code>set</code> type synonym and so then it continues doing that for the conclusion.</p>",
        "id": 303633628,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665583320
    },
    {
        "content": "<p>That's what's bad, right? You should never write <code>s n</code> but instead <code>n ∈ s</code></p>",
        "id": 303633788,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665583362
    },
    {
        "content": "<p><code>s</code> here is a family of sets</p>",
        "id": 303634028,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665583440
    },
    {
        "content": "<p>Should it be <code>h : ∀ n, (∈ s n) =ᵐ[μ] (∈ t)</code>?</p>",
        "id": 303634208,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665583482
    },
    {
        "content": "<p>What's happening is that we have a design decision in our measure theory library to define almost-equal sets as almost-equal functions.</p>",
        "id": 303634215,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665583484
    },
    {
        "content": "<p>Hmm... That goes against the general design decision of making <code>set α</code> a proper type synonym.</p>",
        "id": 303634428,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665583547
    },
    {
        "content": "<p>Yes it does.</p>",
        "id": 303634460,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665583558
    },
    {
        "content": "<p>But it's been done.</p>",
        "id": 303634521,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665583566
    },
    {
        "content": "<p>And when we eventually make <code>set</code> a structure your trick doesn't work anymore and we have to change even more files to fix it.</p>",
        "id": 303634539,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665583570
    },
    {
        "content": "<p>Can you remind me what the notation above unfolds to?</p>",
        "id": 303634554,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665583576
    },
    {
        "content": "<p>I'm not familiar with measure theory notation</p>",
        "id": 303634591,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665583590
    },
    {
        "content": "<p>It means that, for a full measure set of points <code>x</code>, then <code>x</code> belongs to <code>s n</code> iff it belongs to <code>t</code>.</p>",
        "id": 303634730,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1665583633
    },
    {
        "content": "<p>What's the declaration behind the notation though?</p>",
        "id": 303634798,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665583653
    },
    {
        "content": "<p>And yes, we are abusing defeq to avoid duplicating the API. And yes, it's bad :-)</p>",
        "id": 303634847,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1665583672
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Diamond.20of.20complete.20boolean.20algebras.20on.20sets/near/303634554\">said</a>:</p>\n<blockquote>\n<p>Can you remind me what the notation above unfolds to?</p>\n</blockquote>\n<p>It's <code>∀ n, ∀ᶠ x in μ.ae, s n x = t x</code></p>",
        "id": 303634937,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665583695
    },
    {
        "content": "<p>I think we should just add the <code> ∈</code>s</p>",
        "id": 303634961,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665583704
    },
    {
        "content": "<p>We did that for a bunch of <code>decidable</code> arguments a while ago and it was generally an improvement</p>",
        "id": 303635133,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665583762
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Diamond.20of.20complete.20boolean.20algebras.20on.20sets/near/303634961\">said</a>:</p>\n<blockquote>\n<p>I think we should just add the <code> ∈</code>s</p>\n</blockquote>\n<p>Can you clarify what this means?</p>",
        "id": 303635348,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665583829
    },
    {
        "content": "<p>I mean do what I said in the message above</p>",
        "id": 303635434,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665583859
    },
    {
        "content": "<p>The canonical way to view a set as a function is <code>(∈ s)</code></p>",
        "id": 303635502,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665583879
    },
    {
        "content": "<p>Which as a bonus, works for finset, submonoid, ... too</p>",
        "id": 303635706,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665583928
    },
    {
        "content": "<p>I am trying that randomly in some files, and it doesn't seem to break anything. So I agree it's probably a good idea. Let me try to complete this.</p>",
        "id": 303635852,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1665583970
    },
    {
        "content": "<p>Oh I see. If I do that then Lean still uses <code>pi.complete_boolean_algebra</code> which is a problem when I try to apply <code>limsup_sdiff</code> because <code>t</code> is a set.</p>",
        "id": 303635968,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665584007
    },
    {
        "content": "<p>What's your full modified version?</p>",
        "id": 303636121,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665584049
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.measure.measure_space</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span> <span class=\"n\">measure_theory</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">limsup_sdiff</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">complete_boolean_algebra</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">l.limsup</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">\\</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">l.limsup</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">\\</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">limsup_eq_infi_supr</span><span class=\"o\">,</span> <span class=\"n\">sdiff_eq</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"n\">binfi_inf</span> <span class=\"o\">(⟨</span><span class=\"n\">set.univ</span><span class=\"o\">,</span> <span class=\"n\">univ_mem</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">),</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">inf_comm</span><span class=\"o\">,</span> <span class=\"n\">inf_bsupr_eq</span><span class=\"o\">,</span> <span class=\"n\">inf_comm</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">limsup_ae_eq_of_forall_ae_eq</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=ᵐ</span><span class=\"o\">[</span><span class=\"n\">μ</span><span class=\"o\">]</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">limsup</span> <span class=\"n\">at_top</span> <span class=\"n\">s</span> <span class=\"bp\">=ᵐ</span><span class=\"o\">[</span><span class=\"n\">μ</span><span class=\"o\">]</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n  <span class=\"c1\">-- @limsup (set α) ℕ _ at_top s =ᵐ[μ] t :=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- change (∀ n, ∀ᶠ x in μ.ae, s n x = t x) at h,</span>\n  <span class=\"n\">simp_rw</span> <span class=\"n\">ae_eq_set</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">limsup_sdiff</span> <span class=\"n\">at_top</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">measure_limsup_eq_zero</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"o\">},</span> <span class=\"c1\">-- Omitting this proof to keep MWE short</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 303636141,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665584058
    },
    {
        "content": "<p>The conclusion needs <code>∈</code>s too</p>",
        "id": 303636208,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665584089
    },
    {
        "content": "<p>As does <code>t</code>, as in my above comment</p>",
        "id": 303636294,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665584114
    },
    {
        "content": "<p>Hmm, I'm trying this but failing. One moment.</p>",
        "id": 303636677,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665584264
    },
    {
        "content": "<p>OK using this idea make progress. Indeed the following allows me to avoid mangling the hypothesis and conclusion:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">limsup_ae_eq_of_forall_ae_eq</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"n\">n</span> <span class=\"bp\">=ᵐ</span><span class=\"o\">[</span><span class=\"n\">μ</span><span class=\"o\">]</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">limsup</span> <span class=\"n\">at_top</span> <span class=\"n\">s</span> <span class=\"bp\">=ᵐ</span><span class=\"o\">[</span><span class=\"n\">μ</span><span class=\"o\">]</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n  <span class=\"c1\">-- @limsup (set α) ℕ _ at_top s =ᵐ[μ] t :=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp_rw</span> <span class=\"n\">ae_eq_set</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">erw</span> <span class=\"n\">limsup_sdiff</span> <span class=\"n\">at_top</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">measure_limsup_eq_zero</span><span class=\"o\">,</span> <span class=\"c1\">-- This now fails because it expects `set`s</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"o\">},</span> <span class=\"c1\">-- Omitting this proof to keep MWE short</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>but then I have the problem that <code>measure_limsup_eq_zero</code> expects <code>set</code>s.</p>",
        "id": 303637742,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665584611
    },
    {
        "content": "<p>More precisely, <code>measure_limsup_eq_zero</code> is a statement about a <code>limsup</code> in the complete lattice of <code>set</code>s, which is (unfortunately) definitionally different from what I have if I make a statement about the <code>pi.complete_lattice</code>.</p>",
        "id": 303638269,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665584778
    },
    {
        "content": "<p>Okay, I don't understand what's going on. I thought this would be fine given that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.Sup_eq_sUnion\">docs#set.Sup_eq_sUnion</a> is defeq.</p>",
        "id": 303638740,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665584931
    },
    {
        "content": "<p>It's this failure, right:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">pi.has_Sup</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">set.has_Sup</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- Fails</span>\n</code></pre></div>",
        "id": 303649118,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665585441
    },
    {
        "content": "<p>(likewise Inf)</p>",
        "id": 303649162,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665585456
    },
    {
        "content": "<p>Currently it seems that <code>Sup s</code> on sets is defined as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 303666853,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665589293
    },
    {
        "content": "<p>Whereas on pi types it's</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">⨆</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"bp\">↑</span><span class=\"n\">f</span> <span class=\"n\">i</span>\n</code></pre></div>",
        "id": 303667224,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665589429
    },
    {
        "content": "<p>My hunch is that changing that to one of <code>⨆ (f ∈ s), ↑f i</code> or <code>Sup (eval i '' s)</code> would fix that</p>",
        "id": 303667529,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665589514
    },
    {
        "content": "<p>I've opened an issue <a href=\"https://github.com/leanprover-community/mathlib/pull/16932\">#16932</a> for now at least.</p>",
        "id": 303667595,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665589541
    },
    {
        "content": "<p>(mostly to give me something to reference in a PR which is forced to include the <code>@</code> characters)</p>",
        "id": 303667667,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665589563
    },
    {
        "content": "<p>I agree that we should fix this diamond, but I also think that separately we should fix this measure theory defeq abuse</p>",
        "id": 303667771,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665589597
    },
    {
        "content": "<p>Yes, agreed on both points.</p>",
        "id": 303667802,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665589608
    },
    {
        "content": "<p>It's not just measure theory, unfortunately, it's also used for general filters. See <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.eventually_eq_set\">docs#filter.eventually_eq_set</a>. I'm gonna try to fix all these, but it might take longer than I was expecting naively.</p>",
        "id": 303677725,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1665592806
    },
    {
        "content": "<p>Oh! Well if you have the appetite, such a heroic effort would be great.</p>",
        "id": 303677870,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665592863
    },
    {
        "content": "<p>I just looked at the complete lattice diamond issue and it seems to me that we would need to change the definition of both <code>set.has_Sup</code> and <code>pi.has_Sup</code>.</p>",
        "id": 303834071,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665668281
    },
    {
        "content": "<p>I think the following might work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.lattice</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pi.has_Sup'</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">has_Sup</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">has_Sup</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">⨆</span> <span class=\"n\">f</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">i</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">set.has_Sup'</span> <span class=\"o\">:</span> <span class=\"n\">has_Sup</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"bp\">⨆</span> <span class=\"n\">t</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span><span class=\"o\">}⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">pi.has_Sup'</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">set.has_Sup'</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 303834151,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665668301
    },
    {
        "content": "<p>It's actually a one-character change in each case:</p>\n<ul>\n<li>For <code>pi.has_Sup</code>: <code>f : s</code> becomes <code>f ∈ s</code></li>\n<li>For <code>set.has_Sup</code>: <code>∃ t ∈ s</code> becomes <code>⨆ t ∈ s</code></li>\n</ul>",
        "id": 303834557,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665668436
    },
    {
        "content": "<p>I'm tempted to try this but first I thought I'd see if anyone who has been more involved in the order hierarchy can see an obvious reason why this is doomed?</p>",
        "id": 303834661,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665668481
    },
    {
        "content": "<p>(same remarks for <code>Inf</code>s ofc)</p>",
        "id": 303834717,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665668503
    },
    {
        "content": "<p>Maybe it's easier to make such instances definitionally equal if we consistently define <code>Sup</code> in terms of <code>Sup</code> of the \"lower\" structure, instead of defining it using <code>bsupr</code> (which is a <code>Sup</code> of an image over another <code>Sup</code>)?</p>",
        "id": 303838153,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1665669567
    },
    {
        "content": "<p>i.e.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.lattice</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pi.has_Sup'</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">has_Sup</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">has_Sup</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Sup</span> <span class=\"o\">(</span><span class=\"n\">function.eval</span> <span class=\"n\">i</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">set.has_Sup'</span> <span class=\"o\">:</span> <span class=\"n\">has_Sup</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">Sup</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">)}⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">pi.has_Sup'</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">set.has_Sup'</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 303838912,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1665669768
    },
    {
        "content": "<p>Thanks, this might indeed be better! If I take this up I'd be tempted to go with whichever change is easier to implement given what we already have in place but if its a tie, I think I'll go for this.</p>",
        "id": 303839453,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1665669925
    },
    {
        "content": "<p>We explicitly prefer <code>⨆ i ∈ s, f i</code> over <code>Sup (f '' s)</code>, though.</p>",
        "id": 303839524,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665669951
    },
    {
        "content": "<p>See for example, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/with_top.coe_Sup\">docs#with_top.coe_Sup</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/lower_set.coe_Sup\">docs#lower_set.coe_Sup</a>, ...</p>",
        "id": 303839933,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665670079
    },
    {
        "content": "<p>We rely a lot on the defeq of <code>set.has_Sup</code>, so changing this would be a pain.</p>",
        "id": 303840415,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665670221
    },
    {
        "content": "<p>Note that <code>⨆ i ∈ s, f i</code> almost always returns garbage in a conditionally complete lattice (because when <code>i</code> is not in <code>s</code>you are looking at the Sup of the empty set, which might be anything), while <code>Sup (f '' s)</code> is typically better behaved.</p>",
        "id": 303840830,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1665670338
    },
    {
        "content": "<p>Yes, that's the one reason we use it, but we avoid it completely in complete lattices.</p>",
        "id": 303841019,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665670397
    },
    {
        "content": "<p>This might be a historical accident, by the way: at the beginning there were only complete lattices, and conditionally complete ones were added much later on.</p>",
        "id": 303841408,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1665670489
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/Diamond.20of.20complete.20boolean.20algebras.20on.20sets/near/303839524\">said</a>:</p>\n<blockquote>\n<p>We explicitly prefer <code>⨆ i ∈ s, f i</code> over <code>Sup (f '' s)</code>, though.</p>\n</blockquote>\n<p>In lemma statements about complete lattices I agree, but on the basic plumbing in definitions like <code>pi.has_Sup</code> I think it's weird to define <code>Sup</code> in terms of a more complicated (but equal) operation in the <code>β i</code>.<br>\nWe probably do (ab?)use the defeq of <code>set.has_Sup</code> though...</p>",
        "id": 303841582,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1665670544
    },
    {
        "content": "<p><code>⨆ (i : s), f i</code> is good also in conditionally complete lattices, and maybe better defeqwise than <code>Sup (f '' s)</code>.</p>",
        "id": 303841595,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1665670546
    },
    {
        "content": "<p>I think those two are defeq?</p>",
        "id": 303847561,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1665670574
    },
    {
        "content": "<p>oh no, the former is in terms of <code>set.range</code>...</p>",
        "id": 303847630,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1665670596
    },
    {
        "content": "<p>No, they are one <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subtype.exists\">docs#subtype.exists</a> away from each other.</p>",
        "id": 303847632,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665670597
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Diamond.20of.20complete.20boolean.20algebras.20on.20sets/near/303635502\">said</a>:</p>\n<blockquote>\n<p>The canonical way to view a set as a function is <code>(∈ s)</code></p>\n</blockquote>\n<p>I did the experiment to change the measure theory folder to replace the defeq abuse <code>s =ᵐ[μ] t</code> with the more correct <code>(∈ s) =ᵐ[μ] (∈ t)</code>. You can see the outcome in <a href=\"https://github.com/leanprover-community/mathlib/pull/16960\">#16960</a>. Personally, I am not convinced: readability is really worse, and the gain is virtually null (and the linter is not happy). So unless some people insist they like the new version better, I'll just close this in a few days.</p>",
        "id": 303899951,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1665686217
    },
    {
        "content": "<p>There's always the option of making an <code>abbreviation</code> to turn <code>(∈ s) =ᵐ[μ] (∈ t)</code>into <code>s =ᵐˢ[μ] t</code> (ot somet other notation) and restore readability.</p>",
        "id": 303908156,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665689090
    },
    {
        "content": "<p>Oh, I now see that <a href=\"https://github.com/leanprover-community/mathlib/pull/16960\">#16960</a> is related to this thread (I didn't read the whole thread before). I agree that that PR makes the readability worse, but we have been avoiding the <code>set</code>-defeq as much as we could. So I'm not sure if we should go further with it...</p>",
        "id": 303916742,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1665692376
    },
    {
        "content": "<p>The readability loss is really horrible.</p>",
        "id": 303917221,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1665692570
    },
    {
        "content": "<p>It makes more sense to define another variation on <code>eq_on</code> instead of using these lambdas everywhere</p>",
        "id": 303917479,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665692666
    },
    {
        "content": "<p>Another systematic abuse is around presieves and sieves in category theory / Grothendieck topology /sites: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.presieve\">docs#category_theory.presieve</a> is defined to be <code>set</code> but you can see it's used like a function as in <code>S f</code> in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.presieve.bind\">docs#category_theory.presieve.bind</a>. There is even a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.sieve.has_coe_to_fun\">docs#category_theory.sieve.has_coe_to_fun</a> instance.</p>\n<p>There are some implicit arguments involved so maybe you can't directly write <code>∈ S</code> but it should be possible to define a <code>set_like</code> instance to a sigma type like <a href=\"https://github.com/leanprover-community/mathlib/pull/16742/files#diff-3eb4bd9f7c708a63eb6dd66cf8b16b765b39abea5afbc7284f84b33a1da98097R133-R135\">we did in the subgroupoid PR</a>.</p>\n<p>But then you have to write <code>⟨Y, f⟩ ∈ S</code> instead of just <code>f ∈ S</code> but you may define another notation like <code>f ∈' S</code> that is more succinct.</p>",
        "id": 303927952,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665696943
    },
    {
        "content": "<p>For what it's worth, if someone can make <code>∈ S</code> work here, then I'm in favour of removing the coe_to_fun and removing the defeq abuse. Alternatively we could change presieves to be phrased in terms of predicates, and enforce <code>set_of</code></p>",
        "id": 304103728,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1665776312
    }
]
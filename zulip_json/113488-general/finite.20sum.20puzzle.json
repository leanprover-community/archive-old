[
    {
        "content": "<div class=\"codehilite\"><pre><span></span>import tactic.ring\n\ntheorem  finset_sum_is_list_sum (f : ℕ → ℕ) (n : ℕ) :\n(finset.range n).sum f = ((list.range n).map f).sum :=  sorry\n</pre></div>",
        "id": 124390119,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522367619
    },
    {
        "content": "<p>I've been thinking a lot about induction today.</p>",
        "id": 124390133,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522367638
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Is there some super-cute way of doing this already?</p>",
        "id": 124390183,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522367685
    },
    {
        "content": "<p>I have been trying to formalise quite an abstract approach to questions like these but for all I know this sort of thing is completely well-known. Note that a mathematician would say this proof was trivial and indeed it would be hard to explain to a mathematician why this needed a proof.</p>",
        "id": 124390201,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522367744
    },
    {
        "content": "<p>It should be by definition, more or less</p>",
        "id": 124390250,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522367809
    },
    {
        "content": "<p>does <code>rfl</code> work?</p>",
        "id": 124390252,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522367820
    },
    {
        "content": "<p>Also, of course that needs a proof, stop thinking that proofs that are simple by induction are trivial enough to not need a proof</p>",
        "id": 124390310,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522367907
    },
    {
        "content": "<p>Don't you need the commutativity of \"+\" on natural numbers?</p>",
        "id": 124390311,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1522367913
    },
    {
        "content": "<p>that's on the same lines as saying commutativity of natural numbers is trivial</p>",
        "id": 124390315,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522367932
    },
    {
        "content": "<p>Ah, it's not quite by definition, because multiset prod is not defined in terms of list prod but instead is defined using foldl. This works:</p>\n<div class=\"codehilite\"><pre><span></span>theorem finset_sum_is_list_sum (f : ℕ → ℕ) (n : ℕ) :\n  (finset.range n).sum f = ((list.range n).map f).sum :=\nmultiset.coe_sum _\n</pre></div>",
        "id": 124390473,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522368236
    },
    {
        "content": "<p>Here's a slightly less magical way to write it:</p>\n<div class=\"codehilite\"><pre><span></span>theorem finset_sum_is_list_sum (f : ℕ → ℕ) (n : ℕ) :\n  (finset.range n).sum f = ((list.range n).map f).sum :=\nshow ((list.range n).map f : multiset ℕ).sum = ((list.range n).map f).sum, from\nmultiset.coe_sum _\n</pre></div>",
        "id": 124390533,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522368322
    },
    {
        "content": "<p><code>f</code> can map to an <code>add_comm_monoid</code></p>",
        "id": 124390583,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522368415
    },
    {
        "content": "<p>sure</p>",
        "id": 124390587,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522368424
    },
    {
        "content": "<p>that's what you need, I believe.</p>",
        "id": 124390588,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522368425
    },
    {
        "content": "<p>the theorem you stated is not maximally general</p>",
        "id": 124390594,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522368451
    },
    {
        "content": "<p>So this one seems genuinely easier than Chris' problem?</p>",
        "id": 124390597,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522368461
    },
    {
        "content": "<p>yes, because finset sum is defined as a multiset sum over the map</p>",
        "id": 124390600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522368481
    },
    {
        "content": "<p>Here's three more trivial statements:</p>",
        "id": 124390837,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522368921
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>import tactic.ring\nuniverse u\nopen nat\n\ntheorem list_range_map_sum_induction {X : Type u} [has_add X] [has_zero X] {n : ℕ} (f : ℕ → X) :\n  ((list.range (succ n)).map f).sum = ((list.range n).map f).sum + f n := sorry\n\ntheorem finset_range_sum_induction {R : Type u} [add_comm_monoid R] {f : ℕ → R} {d : ℕ} :\n  (finset.range (succ d)).sum f = (finset.range d).sum f + f d := sorry\n\ntheorem finset_univ_sum_fin_induction {R : Type u} [add_comm_monoid R] {d : ℕ}\n  {f : fin (nat.succ d) → R} :\n  finset.univ.sum f =\n    finset.univ.sum (λ i : fin d, f ⟨i.val,lt_trans i.is_lt $ nat.lt_succ_self d⟩) -- d or _?\n    + f ⟨d,nat.lt_succ_self _⟩ -- is _ or d better style at the end?\n  := sorry\n</pre></div>",
        "id": 124390842,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522368958
    },
    {
        "content": "<p>They all say the same trivial thing in maths</p>",
        "id": 124390886,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522368970
    },
    {
        "content": "<p>so I am really interested in the slickest possible proofs in Lean</p>",
        "id": 124390888,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522368997
    },
    {
        "content": "<p>because I suspect that occasionally my students will want statements like this to just go away</p>",
        "id": 124390892,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522369025
    },
    {
        "content": "<p>If these get unsorried then we get the following proof of Chris' problem from yesterday:</p>",
        "id": 124390947,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522369122
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>theorem chris_example (n : ℕ) (f : ℕ → ℕ) (g : fin n → ℕ) (h : ∀ i : fin n, f i.1  = g i) :\n(finset.range n).sum f = finset.univ.sum g := begin\ninduction n with d Hd, refl, -- base case trivial\n-- for the inductive step it&#39;s handy to have notation for the restriction of g,\nlet gres : fin d → ℕ := λ i,g ⟨i.val,lt_trans i.is_lt $ nat.lt_succ_self d⟩,\n-- goal now of form &quot;first kind of sum to succ d equals second kind&quot;\nrw finset_range_sum_induction,\nrw finset_univ_sum_fin_induction,\n-- goal now &quot;first sum to d + f d = second sum to d + g d&quot;\nrw [(Hd gres (λ i, h ⟨i.val,_⟩))], -- first sum equals second sum\nrw h ⟨d,_⟩, -- f d = g d -- so done\nend\n</pre></div>",
        "id": 124390956,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522369154
    },
    {
        "content": "<p>with not a <code>pmap</code> in sight</p>",
        "id": 124390957,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522369158
    },
    {
        "content": "<p>I would argue that this was a \"natural\" proof which hides away the abstraction.</p>",
        "id": 124391040,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522369310
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> Here's what another proof of your fin n question might look like.</p>",
        "id": 124391103,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522369389
    },
    {
        "content": "<p>By the way, here's a(nother) proof of chris's theorem:</p>\n<div class=\"codehilite\"><pre><span></span>example (n : ℕ) (f : ℕ → ℕ) (g : fin n → ℕ) (h : ∀ i : fin n, f i.1 = g i) :\n  (finset.range n).sum f = finset.univ.sum g :=\nshow ((list.range n).map f : multiset ℕ).sum =\n   (((list.range n).pmap fin.mk _).map g : multiset ℕ).sum,\nby rw [multiset.coe_sum, multiset.coe_sum, ← (funext h : _ = g),\n       list.map_pmap, ← list.pmap_eq_map]\n</pre></div>",
        "id": 124391106,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522369402
    },
    {
        "content": "<p>What I don't like about your proofs is that they seem (to me) to involve knowing about some internal implementation of things. My proof is implementation-free. The library maintainer just creates those <code>blah_sum_induction</code> proofs (the three things sorried above) , and then the end user can construct proofs of Chris' theorem without having to worry about any other implementation.</p>",
        "id": 124391190,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522369562
    },
    {
        "content": "<p>Each of the induction laws gives rise to an abstraction which looks like this:</p>",
        "id": 124391225,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522369583
    },
    {
        "content": "<p>I agree, chris has found a hole in the mathlib coverage here</p>",
        "id": 124391233,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522369614
    },
    {
        "content": "<p>Your second theorem is provable by <code>simp</code>, but <code>list.range</code> doesn't break up nicely because the numbers are listed in increasing order</p>",
        "id": 124391244,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522369655
    },
    {
        "content": "<p>I'm not a big fan of your statement of <code>finset_univ_sum_fin_induction</code>, it's all too complicated in the theorem statement</p>",
        "id": 124391303,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522369755
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>@[reducible] definition sum_map_range {R : Type u} [add_comm_monoid R] (addend : ℕ → R) : ℕ → R\n| zero := (0 : R)\n| (succ n) := sum_map_range n + addend n\n\ntheorem list_range_map_sum_abstraction {R : Type} [add_comm_monoid R]\n  (f : ℕ → R) (n : ℕ) : ((list.range n).map f).sum = sum_map_range f n := sorry\n\ntheorem finset_range_sum_abstraction {R : Type u} [add_comm_monoid R] (f : ℕ → R) (n : ℕ) :\n  (finset.range n).sum f = sum_map_range f n := sorry\n\ntheorem finset_univ_sum_fin_abstraction {R : Type u} [add_comm_monoid R] (f : ℕ → R) (n : ℕ) :\n  finset.univ.sum (λ i : fin n, f(i.val)) = sum_map_range f n := sorry\n</pre></div>",
        "id": 124391308,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522369787
    },
    {
        "content": "<p>yes, the fin one stinks.</p>",
        "id": 124391312,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522369795
    },
    {
        "content": "<p>If you use lists or finsets then f is a function on N, but to do Chris' problem you had to use a function on fin n</p>",
        "id": 124391365,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522369848
    },
    {
        "content": "<p>I think there are functions for raising <code>fin n</code> to <code>fin (n+1)</code>. Alternatively, you could use <code>fin2</code>, which has a natural inductive construction instead of being a subtype of nat</p>",
        "id": 124391367,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522369850
    },
    {
        "content": "<p><code>fin2</code> is not really developed much, but it is defined in <code>dioph.lean</code></p>",
        "id": 124391379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522369881
    },
    {
        "content": "<p>I specifically wanted to design functions which gave me the biggest chance of being covered for all variants of the following question:\"this Lean statement is trivially true in maths because it says <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f(0)+f(1)+\\cdots+f(n-1)=f(0)+f(1)+\\cdots+f(n-1)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">0</span><span class=\"mclose\">)</span><span class=\"mbin\">+</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span><span class=\"mbin\">+</span><span class=\"minner\">⋯</span><span class=\"mbin\">+</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">0</span><span class=\"mclose\">)</span><span class=\"mbin\">+</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span><span class=\"mbin\">+</span><span class=\"minner\">⋯</span><span class=\"mbin\">+</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span></span></span></span>, so how do you prove it in Lean?\"</p>",
        "id": 124391432,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522369967
    },
    {
        "content": "<p>I feel like I have convinced myself that for any way of representing the set <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo separator=\"true\">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">\\{0,1,...,n-1\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">{</span><span class=\"mord mathrm\">0</span><span class=\"mpunct\">,</span><span class=\"mord mathrm\">1</span><span class=\"mpunct\">,</span><span class=\"mord mathrm\">.</span><span class=\"mord mathrm\">.</span><span class=\"mord mathrm\">.</span><span class=\"mpunct\">,</span><span class=\"mord mathit\">n</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">}</span></span></span></span> in Lean</p>",
        "id": 124391442,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522370013
    },
    {
        "content": "<p>there is an induction principle and an abstraction principle.</p>",
        "id": 124391447,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522370028
    },
    {
        "content": "<p>Do I have the right names for these things?</p>",
        "id": 124391448,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522370037
    },
    {
        "content": "<p>As you can see, the examples I have attempted to work out are <code>list.range n</code>, <code>fin n</code> and <code>finset.range n</code></p>",
        "id": 124391500,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522370150
    },
    {
        "content": "<p>Sounds like I need to do <code>fin2 n</code></p>",
        "id": 124391502,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522370160
    },
    {
        "content": "<p>I should say that I have not proved the induction hypotheses in all cases yet.</p>",
        "id": 124391541,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522370175
    },
    {
        "content": "<p>It's mostly used for technical reasons; you can also define recursion principles on <code>fin n</code> with the same structure as <code>fin2</code></p>",
        "id": 124391544,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522370208
    },
    {
        "content": "<p>but I think that <code>fz</code> and <code>fs</code> are the right way to think about induction on <code>fin n</code></p>",
        "id": 124391552,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522370244
    },
    {
        "content": "<p>But as a mathematician I would find a proof of these sorts of thing rather distasteful (they're all \"obvious by induction\")</p>",
        "id": 124391555,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522370252
    },
    {
        "content": "<p>so I feel like they should be hidden from view.</p>",
        "id": 124391597,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522370285
    },
    {
        "content": "<p>It's always messy when the function is only partially defined, so that you can't even talk about it out of domain</p>",
        "id": 124391601,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522370304
    },
    {
        "content": "<p>that's what makes <code>list.pmap</code> necessary, and also what makes it a pain to work with</p>",
        "id": 124391603,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522370323
    },
    {
        "content": "<p>What makes Chris's problem hard is the usage of <code>g : fin n -&gt; N</code></p>",
        "id": 124391610,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522370366
    },
    {
        "content": "<p>same for your induction principle, <code>fin (succ n) -&gt; N</code> is even worse</p>",
        "id": 124391614,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522370385
    },
    {
        "content": "<p>I get the sense that you want to put everything in the form <code>map_sum_range</code> of something, but that doesn't work for partial functions</p>",
        "id": 124391671,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522370442
    },
    {
        "content": "<p>Here's a 4th one</p>",
        "id": 124391812,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522370734
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>theorem multiset_sum_map_range_induction {X : Type u} [add_comm_monoid X] {n : ℕ} (f : ℕ → X) :\n  ((multiset.range (succ n)).map f).sum =\n   ((multiset.range n).map f).sum + f n := sorry\n</pre></div>",
        "id": 124391815,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522370758
    },
    {
        "content": "<p>Corresponding to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">\\{0,1,\\ldots,n-1\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">{</span><span class=\"mord mathrm\">0</span><span class=\"mpunct\">,</span><span class=\"mord mathrm\">1</span><span class=\"mpunct\">,</span><span class=\"minner\">…</span><span class=\"mpunct\">,</span><span class=\"mord mathit\">n</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">}</span></span></span></span> = <code>multiset.range n</code></p>",
        "id": 124391855,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522370786
    },
    {
        "content": "<p>Each model gives you a new induction principle</p>",
        "id": 124391859,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522370799
    },
    {
        "content": "<p>which I think mathlib could offer with a standard name</p>",
        "id": 124391867,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522370827
    },
    {
        "content": "<p>There are only a finite number of ways that a mathematician can say this trivial thing, and it would be nice if we could just pull a proof out of a hat for each one.</p>",
        "id": 124391914,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522370884
    },
    {
        "content": "<p>Could I even write a tactic which proves all these things? Just in some stupid way -- it just tries all the proofs and chooses the one that works.</p>",
        "id": 124391923,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522370923
    },
    {
        "content": "<p>aah, <code>simp</code> works on that one.</p>",
        "id": 124391932,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522370965
    },
    {
        "content": "<p>I support the definition of your <code>map_sum_range</code>, which I and I think chris called <code>series</code>; it's on my to do list</p>",
        "id": 124391981,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522371013
    },
    {
        "content": "<p>That would make your <code>multiset_sum_map_range_induction</code> theorem, which I might otherwise call <code>multiset.range_succ_map_sum</code>, just <code>series_succ</code></p>",
        "id": 124391984,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522371052
    },
    {
        "content": "<p>It's not called <code>induction</code> because it's not an induction principle</p>",
        "id": 124391992,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522371070
    },
    {
        "content": "<p>As I've said, I think it will alleviate many of the issues you are having with these sums. If you urgently need it, why not try writing it yourself? Don't worry about connecting it to <code>finset.range</code>, just prove everything directly by induction. Then we can relate it to the other ways to talk about finite sums</p>",
        "id": 124392042,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522371222
    },
    {
        "content": "<p><code>simp</code> does the multiset and finset variants, but not the list variant.</p>",
        "id": 124392084,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522371283
    },
    {
        "content": "<p>Can you tell me exactly what you are suggesting I prove? I am interested in getting this done ASAP and I have some time now, term finished.</p>",
        "id": 124392096,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522371358
    },
    {
        "content": "<p>I think your sketches above should enable me to prove everything</p>",
        "id": 124392135,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522371374
    },
    {
        "content": "<p>Sorry about the induction name. I thought carefully about the abstract syntax of the names but I seem to have used the wrong term.</p>",
        "id": 124392154,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522371460
    },
    {
        "content": "<p>I love <code>dioph.lean</code></p>",
        "id": 124392315,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522371809
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>(D∃4 $ D∃5 $ D∃6 $ D∃7 $ D∃8 $\nD&amp;7 D* D&amp;7 D- (D&amp;5 D* D&amp;5 D- D.1) D* D&amp;8 D* D&amp;8 D= D.1 D∧\nD&amp;4 D* D&amp;4 D- (D&amp;5 D* D&amp;5 D- D.1) D* D&amp;3 D* D&amp;3 D= D.1 D∧\nD&amp;2 D* D&amp;2 D- (D&amp;0 D* D&amp;0 D- D.1) D* D&amp;1 D* D&amp;1 D= D.1 D∧\n</pre></div>",
        "id": 124392316,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522371823
    },
    {
        "content": "<p>who could fail to love that bit</p>",
        "id": 124392318,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522371826
    },
    {
        "content": "<p>whatever is going on in that file</p>",
        "id": 124392359,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522371850
    },
    {
        "content": "<p>That's the closest lean comes to a domain specific language right now</p>",
        "id": 124392429,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522372073
    },
    {
        "content": "<p>So there is <code>vector</code> and <code>vector3</code>. Is there a <code>vector2</code>? I can't find it. (<code>fin2</code> is used to build <code>vector3</code>)</p>",
        "id": 124392482,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522372154
    },
    {
        "content": "<p>I have a Masters student working on Matiesevich's theorem for their project, so I showed them <code>dioph.lean</code>. They know no Lean. I'm not sure they found it very helpful.</p>",
        "id": 124392530,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522372217
    },
    {
        "content": "<p>There was once a vector2, but I deleted it because it wasn't needed. <code>vector2</code> was inductively defined by</p>\n<div class=\"codehilite\"><pre><span></span>inductive vector2 (A : Type u) : nat -&gt; Type u\n| nil : vector2 0\n| cons (n) : A -&gt; vector2 n -&gt; vector2 (succ n)\n</pre></div>",
        "id": 124392536,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522372271
    },
    {
        "content": "<p>From the names, you can guess that <code>vector</code>, <code>vector2</code> and <code>vector3</code> are all isomorphic</p>",
        "id": 124392542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522372321
    },
    {
        "content": "<p>I think you can find it in the file history of <code>dioph.lean</code></p>",
        "id": 124392596,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522372387
    },
    {
        "content": "<p>I can't believe it. I feel like I have learnt something new about induction today, and I have been teaching it for 20 years.</p>",
        "id": 124393725,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522374959
    },
    {
        "content": "<p>what is it?</p>",
        "id": 124393765,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522374970
    },
    {
        "content": "<p>well there's always more to learn :P</p>",
        "id": 124393769,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522374976
    },
    {
        "content": "<p>yes but I'm usually trying to look nearer the top</p>",
        "id": 124393775,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522374992
    },
    {
        "content": "<p>There is one abstract principle of induction <code>g := lam n, sum_to_n f</code></p>",
        "id": 124393844,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522375144
    },
    {
        "content": "<p>which you can prove assuming a hypothesis of the form <code>\\forall n, g (succ n) = g n + f n</code></p>",
        "id": 124393898,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522375214
    },
    {
        "content": "<p>but the problem is that there are several ways to encode <code>sum_to_n</code>in Lean</p>",
        "id": 124393911,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522375290
    },
    {
        "content": "<p>e.g. the \"pure\" way via an inductive type</p>",
        "id": 124393915,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522375305
    },
    {
        "content": "<p>or ways which create an auxiliary type along the way, like <code>sum_to_n f = ((list.range n).map f).sum</code> which at some point builds a list and then sums over it</p>",
        "id": 124393963,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522375377
    },
    {
        "content": "<p>and for each of these design decisions about how you're going to sum this series (e.g. a design decision that some other program has forced upon you) you are given a definition of <code>sum_to_n : (ℕ → R) → (ℕ → R)</code></p>",
        "id": 124394065,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522375606
    },
    {
        "content": "<p>(e.g. <code>λ f, λ n ((list.range n).map f).sum</code> )</p>",
        "id": 124394071,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522375648
    },
    {
        "content": "<p>it's now your job to prove <code>∀ n, sum_to_n (succ n) = sum_to_n n + f n</code></p>",
        "id": 124394119,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522375716
    },
    {
        "content": "<p>And that's quite annoying because list doesn't deconstruct like that.</p>",
        "id": 124394220,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522375925
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> do you have a list of goals?</p>",
        "id": 124394520,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522376667
    },
    {
        "content": "<p>I'm writing a blog post about it. This has been a most enjoyable day.</p>",
        "id": 124394527,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522376713
    },
    {
        "content": "<blockquote>\n<p>it's now your job to prove <code>∀ n, sum_to_n (succ n) = sum_to_n n + f n</code></p>\n</blockquote>\n<p>done</p>",
        "id": 124394727,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522377240
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>theorem sum_to_n.succ : sum_to_n (n+1) = sum_to_n n + f n :=\nbegin\n  dsimp [sum_to_n],\n  rw [list.range_concat],\n  rw [list.map_append],\n  rw [list.sum_append],\n  rw [list.map_singleton],\n  rw [list.sum_cons],\n  rw [list.sum_nil],\n  rw [add_zero]\nend\n</pre></div>",
        "id": 124394764,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522377244
    },
    {
        "content": "<p>version 2</p>",
        "id": 124394965,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522377727
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>theorem sum_to_n.succ : sum_to_n (n+1) = sum_to_n n + f n :=\nby simp [sum_to_n, list.range_concat]\n</pre></div>",
        "id": 124394966,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522377728
    },
    {
        "content": "<p><a href=\"https://wordpress.com/post/xenaproject.wordpress.com/1344\" target=\"_blank\" title=\"https://wordpress.com/post/xenaproject.wordpress.com/1344\">https://wordpress.com/post/xenaproject.wordpress.com/1344</a></p>",
        "id": 124399570,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522387458
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> did you sleep?</p>",
        "id": 124399701,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522387752
    },
    {
        "content": "<p>Meh <a href=\"https://xenaproject.wordpress.com/2018/03/30/proofs-by-induction/\" target=\"_blank\" title=\"https://xenaproject.wordpress.com/2018/03/30/proofs-by-induction/\">https://xenaproject.wordpress.com/2018/03/30/proofs-by-induction/</a> is better</p>",
        "id": 124399746,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522387805
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> or <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> Feel free to leave comments if you have definitions for <code>sum_to_n</code></p>",
        "id": 124399747,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522387805
    },
    {
        "content": "<blockquote>\n<p>but, unfortunately, because I fear that in practice people really might occasionally find themselves in a situation where they need a new kind of proof by induction </p>\n</blockquote>\n<p>writing new recursion principles is common and expected, from what i've seen out there</p>",
        "id": 124399750,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522387849
    },
    {
        "content": "<p>“using the fucking ring tactic”</p>",
        "id": 124399807,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522387939
    },
    {
        "content": "<p>you can see some of this in mathlib, where new elimination lemmas are defined fairly frequently</p>",
        "id": 124399819,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522388041
    },
    {
        "content": "<p>if we go back to the nats, strong induction is commonplace yet requires a proof</p>",
        "id": 124399859,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522388083
    },
    {
        "content": "<p>In lean web editor link, <code>tactic.ring</code> is not available so I had to prove it the old skool way! Thank you <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> for <code>tactic.ring</code>. No, it appears I didn't go to sleep and now the sun is up. Crap. I'm behaving like a kid.</p>",
        "id": 124399920,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522388250
    },
    {
        "content": "<p>lol</p>",
        "id": 124399923,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522388280
    },
    {
        "content": "<p>i am shocked</p>",
        "id": 124399972,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522388302
    },
    {
        "content": "<blockquote>\n<p>writing new recursion principles is common and expected, from what i've seen out there</p>\n</blockquote>\n<p>I realised that Chris could solve his problem with good recursion principles.</p>",
        "id": 124399975,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522388314
    },
    {
        "content": "<p>I don't have to be up at 7am though, because the kids have finished school now.</p>",
        "id": 124399979,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522388342
    },
    {
        "content": "<p>so the philosophy is to always write eliminators for the things you create?</p>",
        "id": 124399987,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522388359
    },
    {
        "content": "<p>If I don't get my act together I'll be up at 7am anyway.</p>",
        "id": 124399988,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522388368
    },
    {
        "content": "<p>I guess that might be what I am saying.</p>",
        "id": 124399992,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522388384
    },
    {
        "content": "<p>also as a matter of style, you could give names to your function variables as opposed to always lambda-ing them</p>",
        "id": 124399993,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522388390
    },
    {
        "content": "<p>Or some version of this.</p>",
        "id": 124399994,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522388390
    },
    {
        "content": "<p>i am still shocked <span class=\"emoji emoji-1f61b\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 124399995,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522388394
    },
    {
        "content": "<p>for example <code>def square : ℕ → ℕ := λ i, i ^ 2 </code> could be <code>def square n : nat := n ^ 2</code></p>",
        "id": 124400038,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522388416
    },
    {
        "content": "<p>fin has no eliminator though</p>",
        "id": 124400039,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522388426
    },
    {
        "content": "<p>hence the problem</p>",
        "id": 124400040,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522388432
    },
    {
        "content": "<p>yes, my approach with fin was not much fun.</p>",
        "id": 124400041,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522388452
    },
    {
        "content": "<p>But I need to sleep.</p>",
        "id": 124400042,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522388461
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110025\">@Andrew Ashworth</span> I think he decided he does not care about styles</p>",
        "id": 124400045,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522388464
    },
    {
        "content": "<p>I just wrote it in the way that appealed to me most.</p>",
        "id": 124400048,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522388490
    },
    {
        "content": "<p>I have also written three solutions to the problems.</p>",
        "id": 124400052,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522388505
    },
    {
        "content": "<p>when you're a professor, you can write your homework exercises however you like, haha</p>",
        "id": 124400053,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522388513
    },
    {
        "content": "<p>One of them is just \"axiom axiom constant\" etc etc, and it's very cool, you can still do the last part :-)</p>",
        "id": 124400093,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522388533
    },
    {
        "content": "<p>constant name : false</p>",
        "id": 124400096,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522388554
    },
    {
        "content": "<p>theorem RH : sorry := false.elim name</p>",
        "id": 124400097,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522388570
    },
    {
        "content": "<p>I might be a professor but I am still very much a learner at this game. I'd be happy for any more stylistic comments.</p>",
        "id": 124400099,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522388571
    },
    {
        "content": "<p>it's only really meaningful in large, complicated definitions</p>",
        "id": 124400142,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522388649
    },
    {
        "content": "<p>of which square does not count</p>",
        "id": 124400143,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522388657
    },
    {
        "content": "<p>i will continue to file nitpicking issues if i see them, though</p>",
        "id": 124400146,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522388683
    },
    {
        "content": "<p>actually later on you give summand a nice name so i take back everything i wrote, haha</p>",
        "id": 124400603,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522389668
    },
    {
        "content": "<p>In fact my initial draft had an error in which I only spotted when I tried to prove that my genuine summing function was equal the one I defined with constants and axioms</p>",
        "id": 124400647,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522389735
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I did define sums and sums between nats here. <a href=\"https://github.com/dorhinj/lean/blob/master/sum_between_nats.lean\" target=\"_blank\" title=\"https://github.com/dorhinj/lean/blob/master/sum_between_nats.lean\">https://github.com/dorhinj/lean/blob/master/sum_between_nats.lean</a> The proofs aren't mathlib ready and I don't think series is a particularly good name. I proved various basic properties as well.</p>",
        "id": 124407580,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1522404514
    }
]
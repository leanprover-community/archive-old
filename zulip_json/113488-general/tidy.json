[
    {
        "content": "<p><code>tidy</code> has been merged! <span class=\"emoji emoji-1f389\" title=\"tada\">:tada:</span> <span class=\"emoji emoji-1f389\" title=\"tada\">:tada:</span> <span class=\"emoji emoji-1f389\" title=\"tada\">:tada:</span></p>",
        "id": 132940411,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1535482589
    },
    {
        "content": "<p>Mathlib is looking in really good shape at the minute. Many unmerged things are either WIPs or very new.</p>",
        "id": 132940649,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535482857
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110524\">@Scott Morrison</span> does mathlib's <code>tidy</code> not contain \"backwards reasoning\"? Or am I just not seeing it?</p>",
        "id": 134173949,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537285259
    },
    {
        "content": "<p>At least the version merged in Orsay didn't</p>",
        "id": 134174192,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537285491
    },
    {
        "content": "<p>I see. That throws a minor <span class=\"emoji emoji-1f527\" title=\"wrench\">:wrench:</span> in my <code>continuity</code> plans, but nothing too serious</p>",
        "id": 134175055,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537286287
    },
    {
        "content": "<p>Actually I'm curious to know why we got that nerfed <code>tidy</code></p>",
        "id": 134175083,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537286332
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> not Scott but that's currently still chilling out in <a href=\"https://github.com/semorrison/lean-tidy/tree/master/src/tidy\" target=\"_blank\" title=\"https://github.com/semorrison/lean-tidy/tree/master/src/tidy\">https://github.com/semorrison/lean-tidy/tree/master/src/tidy</a></p>",
        "id": 134175465,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1537286731
    },
    {
        "content": "<p>Thanks Keeley!<br>\nPatrick, I wonder too. It looks like <code>backwards_reasoning</code> is fairly simple.</p>",
        "id": 134175925,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537287173
    },
    {
        "content": "<p>In particular I'm not sure whether I should try to PR backwards_reasoning into mathlib, or roll my own version to use in continuity</p>",
        "id": 134176805,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537288144
    },
    {
        "content": "<p>No, it's not there yet. It wasn't necessary for the early parts of the<br>\ncategory theory library, so I took it out just to reduce the initial PR<br>\nfootprint.</p>",
        "id": 134190776,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537302303
    },
    {
        "content": "<p>I agree it would be good to get in soon. It was written before <code>ext</code> was available, and the appearance of <code>ext</code> took away a lot of the need for the \"more aggressive\" <code>backwards_reasoning</code>.</p>",
        "id": 134203898,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537319365
    },
    {
        "content": "<p>I think it would be worth rewriting <code>backwards_reasoning</code> one more time, looking to see what we can share with <code>ext</code>.</p>",
        "id": 134203908,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537319392
    },
    {
        "content": "<p>I'm trying to catch up on non-Lean life this week, so if someone wants to go ahead with a PR, please do, otherwise I'll do it \"soon\".</p>",
        "id": 134203956,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537319425
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>, <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> (et al.)<br>\nI've found there a two types of lemmas one frequently wants to apply backwards reasoning with. The \"strong\" variety are just lemmas that you always want to <code>apply</code> whenever they match. There's also a \"weak\" variety where you want to make sure that any hypotheses of the lemma can be immediately discharged from hypotheses.</p>",
        "id": 134300961,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537440486
    },
    {
        "content": "<p>In my first implementation of <code>backwards_reasoning</code>, I introduced two attributes <code>@[back]</code> and <code>@[back']</code> for labelling the strong and weak cases.</p>",
        "id": 134300973,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537440514
    },
    {
        "content": "<p>This is terrible naming!</p>",
        "id": 134300978,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537440520
    },
    {
        "content": "<p>But I'm unsure what the right way to handle this is. Any suggestions welcome, and I'll get on with a <code>backwards_reasoning</code> PR.</p>",
        "id": 134300995,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537440551
    },
    {
        "content": "<p>(I've decided my limits PR may be painful without having <code>backwards_reasoning</code> available.)</p>",
        "id": 134301093,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537440630
    },
    {
        "content": "<p>How about <code>@[backward]</code> and <code>@[strong_back]</code>? Also, do you have an example of the kind of proof it does?</p>",
        "id": 134305714,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1537446006
    },
    {
        "content": "<p>You could also go with <code>@[backward strong]</code> and <code>@[backward weak]</code> with <code>weak</code> being the default?</p>",
        "id": 134305766,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1537446110
    },
    {
        "content": "<p>I'll (eventually) prepare some examples; at the moment everything I have is invisible, because <code>tidy</code> is just doing it in secret. :-) I think actually <code>strong</code> should be the default --- for lemmas that are \"safe\" to always apply, whereas <code>weak</code> is the more dangerous \"you can apply this, but you have to be careful you can actually immediately solve all new goals\" setting.</p>",
        "id": 134306006,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537446373
    },
    {
        "content": "<p>How about <code>@[back!]</code> and <code>@[back]</code>?</p>",
        "id": 134307560,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537448403
    },
    {
        "content": "<p>or <code>@[back]</code> and <code>@[back?]</code></p>",
        "id": 134307631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537448484
    },
    {
        "content": "<p>I would just comment that the \"safe\"/\"unsafe\" terminology can be confusing--if you mark something as \"safe\" when it's safe to apply and \"unsafe\" otherwise then it's \"more safe\" (i.e., more likely to be correct/sound) to mark something as \"unsafe\" than as \"safe\".</p>",
        "id": 134308545,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537449460
    },
    {
        "content": "<p>For example the Haskell FFI uses <code>safe</code>/<code>unsafe</code> in the opposite sense from your terminology: <code>unsafe</code> is used to mark a function which is called \"unsafely\" (without any special setup/teardown), which means it had better be a function which is \"safe\" to call from any context (e.g., <code>sin</code>). <code>safe</code> means that the RTS will prepare a safe context from which to call the function, so it's safe to import most functions as <code>safe</code>. I'm used to this naming convention but I know some people find it confusing.</p>",
        "id": 134308897,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537449756
    },
    {
        "content": "<p>Back on topic, I'm not sure I have a good intuition for which lemmas should fall into either of these two categories.</p>",
        "id": 134309283,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537450097
    },
    {
        "content": "<p>Is there a way to tell <code>tidy</code> that is should never unfold something, possibly with some attribute? Whenever there are real numbers involved, it unfolds them to Cauchy sequences. For instance,</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">tidy</span><span class=\"o\">,</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>gives a goal of the form</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">x_val</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">,</span>\n<span class=\"n\">x_property</span> <span class=\"o\">:</span> <span class=\"n\">is_cau_seq</span> <span class=\"n\">abs</span> <span class=\"n\">x_val</span>\n<span class=\"err\">⊢</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">setoid</span><span class=\"bp\">.</span><span class=\"n\">r</span> <span class=\"bp\">⟨</span><span class=\"n\">x_val</span><span class=\"o\">,</span> <span class=\"n\">x_property</span><span class=\"bp\">⟩</span>\n</pre></div>",
        "id": 136775268,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1540905061
    },
    {
        "content": "<p>unfolding real numbers should be tagged <code>untidy</code></p>",
        "id": 136775987,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1540905771
    },
    {
        "content": "<p>Ugh, that is bad. :-) I'll admit I've never touched a real number in Lean!</p>",
        "id": 136805385,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540931982
    },
    {
        "content": "<p>The problem is just that <code>auto_cases</code> applies first, and it, somewhat ridiculously, runs <code>induction x</code> immediately.</p>",
        "id": 136805448,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540932007
    },
    {
        "content": "<p>There are certainly cases where this _is_ helpful behaviour, on the other hand.</p>",
        "id": 136805492,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540932060
    },
    {
        "content": "<p>I wonder if there is a useful line to draw.</p>",
        "id": 136805504,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540932083
    },
    {
        "content": "<p>One dumb solution is to just remove induction on quotients from <code>auto_cases</code> entirely, and have users of <code>tidy</code> explicitly add back in a tactic that does this (e.g. the very blunt <code>case_bash</code> tactic I have somewhere, which just tries cases on everything!)</p>",
        "id": 136805597,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540932188
    },
    {
        "content": "<p>I suspect that the occasions where it makes sense to use induction on a quotient, the quotient relation is \"very near at hand\". But I'm having trouble thinking how to quantify/measure that.</p>",
        "id": 136805706,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540932284
    },
    {
        "content": "<p>Is the induction on quotients often helpful? I mean, if you remove it from <code>auto_cases</code>, does it break something in your category library? If not, I guess it is safe to remove it. Otherwise, one would need a mechanism to fine tune it, maybe with some attributes..</p>",
        "id": 136831493,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1540970078
    },
    {
        "content": "<p>It breaks exactly one thing, and clearly that doesn't justify the hassle caused elsewhere. I'll PR a one line change to auto_cases soon*.</p>",
        "id": 136838627,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540980538
    },
    {
        "content": "<p>Ok, I've PR'd this one-line change: <a href=\"https://github.com/leanprover/mathlib/pull/451\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/pull/451\">https://github.com/leanprover/mathlib/pull/451</a></p>",
        "id": 136850749,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540991535
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 136853102,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1540994033
    },
    {
        "content": "<p>Huh, it turns out someone else was using <code>tidy</code> in a way that relied on induction on quotients: <a href=\"https://travis-ci.org/leanprover/mathlib/jobs/448843966\" target=\"_blank\" title=\"https://travis-ci.org/leanprover/mathlib/jobs/448843966\">https://travis-ci.org/leanprover/mathlib/jobs/448843966</a></p>",
        "id": 136885843,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541024976
    },
    {
        "content": "<p>I can just rewrite that proof.</p>",
        "id": 136885847,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541024988
    },
    {
        "content": "<p>An alternative would be to have <code>auto_cases</code> perform induction on \"things that are explicitly quotients\"</p>",
        "id": 136885905,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541025009
    },
    {
        "content": "<p>For one, this would include things that actually match <code>quot _</code> or <code>quotient _</code>.</p>",
        "id": 136885914,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541025029
    },
    {
        "content": "<p>But for this use case I'd also want to to fire on <code>quotient_module.quotient</code>.</p>",
        "id": 136885931,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541025059
    },
    {
        "content": "<p>And it seems the only way to handle that would be to make decisions based on the _name_ itself.</p>",
        "id": 136885944,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541025075
    },
    {
        "content": "<p>Yes there's a huge difference between real numbers as quotient and quotient modules as quotients! I guess another fix would be to rewrite the real numbers as Dedekind cuts ;-)</p>",
        "id": 136886552,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541025772
    },
    {
        "content": "<p>Or make <code>real</code> irreducible (after the file <code>data.real.basic</code>) and not unfold irreducible definitions?</p>",
        "id": 136886818,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1541026107
    },
    {
        "content": "<p>Hmm, it seems making <code>real</code> irreducible doesn't work; lots of things fail.</p>",
        "id": 136913655,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541069125
    },
    {
        "content": "<p>e.g.  <code>rw div_mul_div at this</code> producing:</p>\n<div class=\"codehilite\"><pre><span></span>/home/travis/build/leanprover/mathlib/data/real/irrational.lean:19:2: error: rewrite tactic failed, did not find instance of the pattern in the target expression\n  ?m_3 / ?m_4 * (?m_5 / ?m_6)\nstate:\nsqrt_two_irrational : irrational (sqrt 2)\nn : ℤ\nd : ℕ\nh : d &gt; 0\nc : nat.coprime (int.nat_abs n) d\ne : sqrt 2 = ↑n / ↑d\nd0 : 0 &lt; ↑d\nthis : ↑n / ↑d * (↑n / ↑d) = 2\n</pre></div>",
        "id": 136913717,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541069198
    },
    {
        "content": "<p>I don't really understand how reducibility caused a problem there.</p>",
        "id": 136913822,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541069335
    },
    {
        "content": "<p>The issue is that this expression no longer type checks after real is made irreducible</p>\n<div class=\"codehilite\"><pre><span></span>example : @cau_seq.completion.has_mul ℚ _ ℚ _ abs _ =  (show has_mul ℝ, by apply_instance) :=\n</pre></div>\n\n\n<p><code>real.mul_self_sqrt</code> uses <code>cau_seq.completion.has_mul</code>, so you end up with two <code>has_mul</code>'s that are no longer reduced to the same thing.</p>",
        "id": 136914854,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541070789
    },
    {
        "content": "<p>Making <code>cau_seq.completion</code> irreducible instead might be a better idea.</p>",
        "id": 136915002,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541070964
    },
    {
        "content": "<p>Thanks! I will investigate that.</p>",
        "id": 136915843,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541072255
    },
    {
        "content": "<p>Hmm, making <code>attribute [irreducible] cau_seq.completion.Cauchy</code> (is that what you had in mind, <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span>?) seems to cause troubles later:</p>\n<div class=\"codehilite\"><pre><span></span>/Users/scott/projects/lean/mathlib/analysis/real.lean:185:29: error: type mismatch at application\n</pre></div>\n\n\n<p>Perhaps this is a dead-end.</p>",
        "id": 136918194,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541075126
    },
    {
        "content": "<p>I tried making real irreducible immediately after <code>exists_sup</code> and that seemed to work. Two proofs in analysis broke, but they were easy to fix.</p>",
        "id": 136918270,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541075235
    },
    {
        "content": "<p>Would you be interested in pursuing that to a PR? (Both because I think you'll do a better job at it that I would, and also I need to go to sleep? :-)</p>",
        "id": 136918348,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541075291
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> , it looks like something cropped up later:</p>\n<div class=\"codehilite\"><pre><span></span>/home/travis/build/leanprover/mathlib/analysis/bounded_linear_maps.lean:100:9: error: synthesized type class instance is not definitionally equal to expression inferred by typing rules, synthesized\n  normed_ring.to_ring ℝ\ninferred\n  domain.to_ring ℝ\n</pre></div>",
        "id": 136951464,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541107778
    },
    {
        "content": "<p>I haven't managed to work out what's going on there.</p>",
        "id": 136952443,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541108769
    },
    {
        "content": "<p>Done some investigation. There's some weird behaviour going on.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">normed_ring</span><span class=\"bp\">.</span><span class=\"n\">to_ring</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"bp\">=</span> <span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">--works</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">normed_ring</span><span class=\"bp\">.</span><span class=\"n\">to_ring</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">one</span> <span class=\"bp\">=</span> <span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">one</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">--works</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">normed_ring</span><span class=\"bp\">.</span><span class=\"n\">to_ring</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"bp\">=</span> <span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">--works</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">normed_ring</span><span class=\"bp\">.</span><span class=\"n\">to_ring</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"bp\">=</span> <span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">--works</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">normed_ring</span><span class=\"bp\">.</span><span class=\"n\">to_ring</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">add_comm</span> <span class=\"bp\">=</span> <span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">add_comm</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">--doesn&#39;t work</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">normed_ring</span><span class=\"bp\">.</span><span class=\"n\">to_ring</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mul_assoc</span> <span class=\"bp\">=</span> <span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">mul_assoc</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">--doesn&#39;t work</span>\n</pre></div>\n\n\n<p>Not quite sure why all the data is equal by <code>rfl</code> but none of the proofs. <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, what's happening?</p>",
        "id": 137088872,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541200450
    },
    {
        "content": "<p>I don't have the setup to test that myself right now, but if they are proofs then it should be an easy rfl, as long as the statement itself typechecks</p>",
        "id": 137088949,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541200597
    },
    {
        "content": "<p>They are proofs and the statement type checks and it isn't an easy <code>rfl</code>.</p>",
        "id": 137088971,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541200682
    },
    {
        "content": "<p><code>proof_irrel _ _</code> works though</p>",
        "id": 137089018,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541200728
    },
    {
        "content": "<p>The context is that I made <code>real</code> irreducible in case you hadn't caught up with the discussion</p>",
        "id": 137089029,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541200758
    },
    {
        "content": "<p>is <code>normed_ring.to_ring ℝ = real.ring</code> doesn't work, I assume?</p>",
        "id": 137089104,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541200828
    },
    {
        "content": "<p>That doesn't work.</p>",
        "id": 137089106,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541200839
    },
    {
        "content": "<p>How is the instance <code>normed_ring ℝ</code> defined? Is <code>normed_ring</code> an old style structure?</p>",
        "id": 137089137,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541200911
    },
    {
        "content": "<p>For reals it's derived from <code>norm_field \\R</code>, which is a new style structure, as is <code>normed_ring</code></p>",
        "id": 137089285,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541201134
    },
    {
        "content": "<p>In that case, the <code>normed_ring</code> instance should literally include <code>real.ring</code> as the appropriate component in its definition</p>",
        "id": 137089381,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541201281
    },
    {
        "content": "<p>But that's doesn't really work, since it's defined from a general instance <code>normed_field.to_normed_ring</code></p>",
        "id": 137089557,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541201513
    },
    {
        "content": "<p>aha:</p>\n<div class=\"codehilite\"><pre><span></span>@[instance]\nprotected def normed_field.to_normed_ring : Π {α : Type u_1} [i : normed_field α], normed_ring α :=\nλ {α : Type u_1} [i : normed_field α],\n  {to_has_norm := normed_field.to_has_norm α i,\n   to_ring := {add := discrete_field.add (normed_field.to_discrete_field α),\n               add_assoc := _,\n               zero := discrete_field.zero α (normed_field.to_discrete_field α),\n               zero_add := _,\n               add_zero := _,\n               neg := discrete_field.neg (normed_field.to_discrete_field α),\n               add_left_neg := _,\n               add_comm := _,\n               mul := discrete_field.mul (normed_field.to_discrete_field α),\n               mul_assoc := _,\n               one := discrete_field.one α (normed_field.to_discrete_field α),\n               one_mul := _,\n               mul_one := _,\n               left_distrib := _,\n               right_distrib := _},\n   to_metric_space := normed_field.to_metric_space α i,\n   dist_eq := _,\n   norm_mul := _}\n</pre></div>\n\n\n<p>Apparently <code>..i</code> unfolds the ring component unnecessarily</p>",
        "id": 137089642,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541201623
    },
    {
        "content": "<p>adding <code>to_ring := by apply_instance</code> there simplifies the generated term</p>",
        "id": 137089729,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541201742
    },
    {
        "content": "<p>does that fix the issue?</p>",
        "id": 137089736,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541201758
    },
    {
        "content": "<p>Yes. Thanks. I'm not sure if it's worth making reals irreducible if it generates this sort of problem however.</p>",
        "id": 137090074,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541202252
    },
    {
        "content": "<p>As in, I was hoping for a solution which only changed <code>data.real.basic</code></p>",
        "id": 137090089,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541202288
    },
    {
        "content": "<p>well, I think this is a bug in structure literals, but indeed even eta expanding <code>real.ring</code> should be defeq because it's a structure. Did you mark <code>real.ring</code> irreducible?</p>",
        "id": 137090402,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541202805
    },
    {
        "content": "<p>No, just <code>real</code></p>",
        "id": 137090407,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541202834
    },
    {
        "content": "<p>Oh, but then I think I can see how the problem arises... <code>real.comm_ring</code> expands to <code>cau_seq.completion.comm_ring</code>, which contains <code>real</code> internals in its type</p>",
        "id": 137090511,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541202988
    },
    {
        "content": "<p>you should try changing the definition to <code>real.comm_ring := {.. cau_seq.completion.comm_ring}</code></p>",
        "id": 137090513,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541203022
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>local attribute [reducible] real\n</pre></div>\n\n\n<p>in real.lean is a real doozy. By marking it irreducible but locally reducible, you get terms that typecheck locally, which stop typechecking later</p>",
        "id": 137090584,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541203153
    },
    {
        "content": "<p>so you just put <code>local attribute [irredible] real</code> just afterwards, right?</p>",
        "id": 137090650,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541203231
    },
    {
        "content": "<p>well, that's the same thing</p>",
        "id": 137090652,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541203239
    },
    {
        "content": "<p>I mean you can switch it on when you need it</p>",
        "id": 137090655,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541203255
    },
    {
        "content": "<p>I think one principle we need is that any definition which would not typecheck in the current environment (because of irreducible markings) should itself be irreducible</p>",
        "id": 137090669,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541203273
    },
    {
        "content": "<p>I was about to say: I haven't been following closely but I feel like we need a more principled approach to all this.</p>",
        "id": 137090679,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541203298
    },
    {
        "content": "<p>In this case, <code>real.comm_ring := cau_seq.completion.comm_ring</code> does not typecheck once the definition of real is hidden</p>",
        "id": 137090688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541203315
    },
    {
        "content": "<p>I'm hopeful that the right irreducibility annotations will make the real numbers generally more pleasant to work with, but I would guess that tweaking annotations one by one is not the best way to get there. This feels related to enforcing abstraction boundaries, something Lean seems to have no capabilities for.</p>",
        "id": 137091120,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541203863
    },
    {
        "content": "<p>I tried this change <code>instance : comm_ring ℝ := { ..cau_seq.completion.comm_ring }</code>, but it has the same problem. I guess the proofs still don't type check.</p>",
        "id": 137109695,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541243831
    },
    {
        "content": "<p>what about</p>\n<div class=\"codehilite\"><pre><span></span>@[irreducible] def real.comm_ring&#39; : comm_ring ℝ := cau_seq.completion.comm_ring\ninstance : comm_ring ℝ := {.. real.comm_ring&#39; }\n</pre></div>",
        "id": 137109802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541244069
    },
    {
        "content": "<p>Breaks a lot of proofs in <code>real.basic</code></p>",
        "id": 137109847,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541244186
    },
    {
        "content": "<p>It seems like making things <code>irreducible</code> after proving things about them isn't really practical.</p>",
        "id": 137109935,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541244417
    },
    {
        "content": "<p>you may have to do the same trickery with local reducible, global irreducible</p>",
        "id": 137110157,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541244900
    },
    {
        "content": "<p>That seems like a really bad idea, because then things that typechecked when I wrote them no longer typecheck</p>",
        "id": 137110322,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541245252
    },
    {
        "content": "<p>that's why we're making the things that depend on irreducible things irreducible</p>",
        "id": 137110376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541245418
    },
    {
        "content": "<p>Making <code>real.comm_ring</code> irreducible at the same time that <code>real</code> is made irreducible actually works. I can't do the same thing with <code>discrete_field</code> however, otherwise <code>discrete_field.to_comm_ring</code> or whatever, won't be equal to <code>real.comm_ring</code></p>",
        "id": 137110649,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541245939
    },
    {
        "content": "<p>This fails now <code>example : field.to_comm_ring ℝ = real.comm_ring := rfl</code></p>",
        "id": 137110716,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541246145
    },
    {
        "content": "<p>you just have to make sure the right things end up opaque</p>",
        "id": 137110770,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541246240
    },
    {
        "content": "<p>I think if you build another <code>discrete_linear_ordered_field ℝ</code> over top of <code>real.comm_ring'</code> and  <code>discrete_linear_ordered_field ℝ</code> , and make the latter two opaque, you should be able to prove the unfolding</p>",
        "id": 137110812,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541246295
    },
    {
        "content": "<p>Without abbreviating things, the longhand way to do this is to define terms <code>zero : R</code>, <code>one : R</code>, <code>zero_add : zero + x = x</code> etc, make them all opaque, and then build typeclasses on top of them</p>",
        "id": 137110820,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541246398
    },
    {
        "content": "<p>Typeclass unfolding should never be opaque, this causes problems</p>",
        "id": 137110894,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541246422
    },
    {
        "content": "<p>That seems to fix everything.</p>",
        "id": 137111247,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541247235
    },
    {
        "content": "<p>It does seem like a slightly fragile solution, and that it might cause problems later on.</p>",
        "id": 137111303,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541247334
    },
    {
        "content": "<p>In metamath we actually took a really hard line on making real opaque, which is weird since we don't do that anywhere else</p>",
        "id": 137111555,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541247828
    },
    {
        "content": "<p>we construct the reals, forget the construction and axiomatize</p>",
        "id": 137111595,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541247845
    },
    {
        "content": "<p>It's actually a nice and principled way to do it, because you can pick an appropriate axiomatization of the reals that you know to be complete (no pun intended)</p>",
        "id": 137111610,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541247919
    },
    {
        "content": "<p>You don't need all the discrete field axioms, of course some of them are redundant</p>",
        "id": 137111616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541247946
    },
    {
        "content": "<p>Now a whole load of <code>rfl</code> proofs have broken in <code>complex.basic</code>.</p>",
        "id": 137111675,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541248035
    },
    {
        "content": "<p>that's not good</p>",
        "id": 137111681,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541248048
    },
    {
        "content": "<p>they should be \"above\" the construction</p>",
        "id": 137111682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541248057
    },
    {
        "content": "<p>They shouldn't be proved with <code>rfl</code>? It is nice that some things about reals are definitional.</p>",
        "id": 137111725,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541248091
    },
    {
        "content": "<p>oh, shoot - I just remembered that some things are definitional like 0 + 0 = 0</p>",
        "id": 137111728,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541248109
    },
    {
        "content": "<p>oh man</p>",
        "id": 137111744,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541248132
    },
    {
        "content": "<p>that's out the window if you axiomatize</p>",
        "id": 137111746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541248138
    },
    {
        "content": "<p>lol this is probably that bunch of simp proofs that kenny made <code>rfl</code></p>",
        "id": 137111760,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541248189
    },
    {
        "content": "<p>I'm pretty sure it is that. I think the reason they weren't <code>rfl</code> in the first place, is because <code>complex.basic</code> was written with old reals.</p>",
        "id": 137111812,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541248227
    },
    {
        "content": "<p>but I think that it is actually a bad idea to use <code>rfl</code></p>",
        "id": 137111817,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541248237
    },
    {
        "content": "<p>this is why I say defeq breaks abstractions</p>",
        "id": 137111824,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541248254
    },
    {
        "content": "<p>it's bad practice to rely on definitional details</p>",
        "id": 137111834,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541248277
    },
    {
        "content": "<p>I like those claims. They are reassuring. I was getting used to thinking that I should care a lot about defeq. But now you make me think that I should stick to my mathematical habits (-;</p>",
        "id": 137111879,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541248336
    },
    {
        "content": "<p>I managed to fix everything. The problems were things like <code>((1 : nat) : real) = (1 : real)</code> no longer being definitional.</p>",
        "id": 137113939,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541252648
    },
    {
        "content": "<p>Just reporting that <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span>'s recent fixes to reducibility have solved <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span>'s original complaint:</p>\n<blockquote>\n<p>Is there a way to tell tidy that is should never unfold something, possibly with some attribute? Whenever there are real numbers involved, it unfolds them to Cauchy sequences. For instance,</p>\n</blockquote>\n<div class=\"codehilite\"><pre><span></span>lemma foo {x : ℝ} : 0 ≤ x :=\nbegin\n  tidy,\n  sorry\nend\n</pre></div>\n\n\n<blockquote>\n<p>gives a goal of the form</p>\n</blockquote>\n<div class=\"codehilite\"><pre><span></span>x_val : ℕ → ℚ,\nx_property : is_cau_seq abs x_val\n⊢ 0 ≤ quot.mk setoid.r ⟨x_val, x_property⟩\n</pre></div>",
        "id": 146844437,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541478771
    },
    {
        "content": "<p>Is there some reason <code>tidy</code> doesn't have <code>tauto</code> in its default list of things to try?</p>",
        "id": 199883969,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1591367193
    },
    {
        "content": "<p>Probably speed</p>",
        "id": 199883993,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591367207
    },
    {
        "content": "<p>usually <code>tauto</code> is pretty fast for me, whereas <code>tidy</code> seems to die with deterministic timeout rather than failing when <code>tauto</code> could have closed the goal.</p>",
        "id": 199884119,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1591367278
    },
    {
        "content": "<p>You can locally mark it with the <code>tidy</code> attribute, to include it in the list.</p>",
        "id": 199884592,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591367472
    },
    {
        "content": "<p>But I guess it gets tagged onto the end of the list...</p>",
        "id": 199884604,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591367483
    },
    {
        "content": "<p>I mean in this case the solution for me is just to use tauto instead of tidy :)</p>",
        "id": 199885493,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1591367849
    },
    {
        "content": "<p>What's an example that <code>tauto</code> solves where <code>tidy</code> gets stuck?</p>",
        "id": 199885590,
        "sender_full_name": "Reid Barton",
        "timestamp": 1591367883
    },
    {
        "content": "<p>let me <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>-ify it</p>",
        "id": 199885840,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1591368024
    },
    {
        "content": "<p>If tauto works then using it is better, but I would have thought tidy tries most things that tauto does, so I'm a bit surprised. It could be that tidy goes down the wrong path using simp and can't recover, or something.</p>",
        "id": 199886267,
        "sender_full_name": "Reid Barton",
        "timestamp": 1591368236
    },
    {
        "content": "<p>aha my example was a non-example. I had a stray edit to one of the imports which I think lean was trying to recompile (even though I had not saved the imported file?!)</p>",
        "id": 199886421,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1591368298
    },
    {
        "content": "<p>i think that caused the timeout</p>",
        "id": 199886440,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1591368308
    },
    {
        "content": "<p>oh nvm<br>\nit's still timing out with <code>tidy</code></p>",
        "id": 199886489,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1591368331
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">direct_sum_module</span>\n       <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">tensor_product</span>\n       <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">basis</span>\n       <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">finsupp_vector_space</span>\n       <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finsupp</span>\n       <span class=\"n\">tactic</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">module</span>\n\n<span class=\"n\">def</span> <span class=\"n\">free</span> <span class=\"o\">:=</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span><span class=\"err\">₀</span> <span class=\"n\">R</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">free</span> <span class=\"n\">R</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">has_coe_to_fun</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">module</span>\n\n<span class=\"kn\">notation</span> <span class=\"n\">R</span> <span class=\"bp\">`</span> <span class=\"bp\">^</span><span class=\"err\">⊕</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">40</span> <span class=\"n\">ι</span><span class=\"o\">:</span><span class=\"mi\">66</span>  <span class=\"o\">:=</span> <span class=\"n\">module</span><span class=\"bp\">.</span><span class=\"n\">free</span> <span class=\"n\">R</span> <span class=\"n\">ι</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">free</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">R</span><span class=\"bp\">^</span><span class=\"err\">⊕</span><span class=\"n\">ι</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">add_comm_group</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">R</span><span class=\"bp\">^</span><span class=\"err\">⊕</span><span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"bp\">..@</span><span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">module</span> <span class=\"n\">ι</span> <span class=\"n\">R</span> <span class=\"n\">R</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">equiv_of_bijection</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"err\">≃</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"bp\">^</span><span class=\"err\">⊕</span><span class=\"n\">ι</span> <span class=\"err\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">R</span><span class=\"bp\">^</span><span class=\"err\">⊕</span><span class=\"n\">μ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">map_domain</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span><span class=\"o\">,</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">map_domain_add</span><span class=\"o\">,</span>\n  <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">map_domain_smul</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">comap_domain</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">tidy</span><span class=\"o\">),</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">map_domain_comap_domain</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">tidy</span><span class=\"o\">)</span>\n              <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"o\">{</span><span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">surjective</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">tidy</span><span class=\"o\">})</span>\n              <span class=\"c1\">-- (by {have := equiv.surjective h, tauto})</span>\n              <span class=\"o\">}</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">equiv_of_bijection</span> <span class=\"n\">right_inv</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">free</span>\n</code></pre></div>",
        "id": 199886512,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1591368341
    },
    {
        "content": "<p>what's the state when <code>tidy</code> gives up?</p>",
        "id": 199886743,
        "sender_full_name": "Reid Barton",
        "timestamp": 1591368417
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"mi\">1</span> <span class=\"n\">goal</span>\n<span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">,</span>\n<span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">,</span>\n<span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"err\">≃</span> <span class=\"n\">μ</span><span class=\"o\">,</span>\n<span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">^</span><span class=\"err\">⊕</span> <span class=\"n\">μ</span><span class=\"o\">,</span>\n<span class=\"n\">this</span> <span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">surjective</span> <span class=\"err\">⇑</span><span class=\"n\">h</span>\n<span class=\"err\">⊢</span> <span class=\"err\">↑</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"o\">)</span> <span class=\"err\">⊆</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span>\n</code></pre></div>",
        "id": 199886807,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1591368439
    },
    {
        "content": "<p>of course I was also a bit surprised I had to help with <code>have := equiv.surjective h</code></p>",
        "id": 199887170,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1591368594
    },
    {
        "content": "<p>What happens if you <code>squeeze_simp</code>?</p>",
        "id": 199911588,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1591379552
    },
    {
        "content": "<p>I think that some simp lemma is missing</p>",
        "id": 199911664,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1591379600
    },
    {
        "content": "<p>How do I see what  <code>simp</code> tried when it fails to simplify? The only trick I know is <code>set_option trace.simplify.rewrite true</code> but that doesn't yield an information trace when <code>simp</code> fails AFAICT.</p>",
        "id": 199996920,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1591484356
    },
    {
        "content": "<p><code>set_option trace.simplify true</code>.  It's mentioned near the top of <a href=\"https://leanprover-community.github.io/extras/simp.html\">this page on <code>simp</code></a>.</p>",
        "id": 199997057,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1591484573
    },
    {
        "content": "<p>Yeah, so I think tracing <code>simp</code> is not so useful for diagnosing <code>tidy</code>'s timeout here -- it just shows a gazillion rewrites that <code>simp</code> tried but that don't work. This isn't surprising since to close the goal you do need to use the surjectivity of <code>h</code> here, which isn't just a term rewrite.</p>",
        "id": 199997351,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1591485045
    }
]
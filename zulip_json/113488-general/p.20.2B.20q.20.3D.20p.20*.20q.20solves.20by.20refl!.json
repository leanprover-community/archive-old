[
    {
        "content": "<p>Something seems wrong either with the pretty-printer or with type-class resolution here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">multiplicative</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">*</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">has_add.add</span> <span class=\"o\">(</span><span class=\"n\">multiplicative</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_semigroup.to_has_add</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">add_monoid.to_add_semigroup</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n             <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  p q : multiplicative G</span>\n<span class=\"cm\">  ⊢ p * q = p + q</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n\n<p>Obviously the RHS of my lemma is contrived, but it's what <code>extract_goal</code> produced mid-proof</p>",
        "id": 212218929,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601810844
    },
    {
        "content": "<p>This lets me make a rather strange <code>(multiplicative G) ≃+ G</code> object</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.algebra.basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bad_add</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">multiplicative</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_semigroup.to_has_add</span> <span class=\"o\">(</span><span class=\"n\">multiplicative</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_monoid.to_add_semigroup</span> <span class=\"o\">(</span><span class=\"n\">multiplicative</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">_inst_1</span><span class=\"o\">))</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bad_map_add</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">multiplicative</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"kd\">by</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">bad_add</span> <span class=\"n\">G</span><span class=\"bp\">;</span> <span class=\"n\">exact</span>\n    <span class=\"n\">multiplicative.to_add</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">multiplicative.to_add</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">multiplicative.to_add</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bad_to_add</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"kd\">by</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">bad_add</span><span class=\"bp\">;</span> <span class=\"n\">exact</span>\n    <span class=\"o\">(</span><span class=\"n\">multiplicative</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">≃+</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">add_equiv.</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">equiv.to_fun_as_coe</span><span class=\"o\">,</span> <span class=\"n\">bad_map_add</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">]},</span>\n  <span class=\"bp\">..@</span><span class=\"n\">multiplicative.to_add</span> <span class=\"n\">G</span>\n<span class=\"o\">}</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">bad_to_add</span>\n</code></pre></div>",
        "id": 212220403,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601813300
    },
    {
        "content": "<p>This is expected behavior</p>",
        "id": 212220420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601813364
    },
    {
        "content": "<p>Would <code>bad_to_add</code> make sense in mathlib then?</p>",
        "id": 212220473,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601813415
    },
    {
        "content": "<p>With a better name, obviously</p>",
        "id": 212220476,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601813421
    },
    {
        "content": "<p>absolutely not</p>",
        "id": 212220477,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601813422
    },
    {
        "content": "<p>Perhaps some more context - I'm trying to implement <code>add_monoid_algebra k G ≃+* monoid_algebra k (multiplicative G)</code></p>",
        "id": 212220484,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601813443
    },
    {
        "content": "<p>it is pretty obviously not a desirable instance</p>",
        "id": 212220486,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601813449
    },
    {
        "content": "<p>You can locally override instances, as you are doing in these examples</p>",
        "id": 212220495,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601813470
    },
    {
        "content": "<p>but they cause problems down the line so you should keep it to a minimum</p>",
        "id": 212220498,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601813485
    },
    {
        "content": "<p>Sorry, I'm not suggesting <code>bad_add</code> should be a global instance</p>",
        "id": 212220501,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601813500
    },
    {
        "content": "<p>I don't see how that equiv makes sense</p>",
        "id": 212220504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601813516
    },
    {
        "content": "<p>are those both rings?</p>",
        "id": 212220543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601813526
    },
    {
        "content": "<p>Perhaps I need to show a longer example</p>",
        "id": 212220551,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601813541
    },
    {
        "content": "<p>I'm pretty sure <code>≃+*</code> works on rings and ringish things</p>",
        "id": 212220563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601813570
    },
    {
        "content": "<p>Both <code>add_monoid_algebra k G</code> and <code>monoid_algebra k (multiplicative G)</code> are semirings, yes</p>",
        "id": 212220572,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601813597
    },
    {
        "content": "<p>I was able to prove this lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">add_monoid_algebra.map_domain_mul</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">α₂</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α₂</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f_map_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)):</span>\n  <span class=\"o\">(</span><span class=\"n\">map_domain</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">β</span> <span class=\"n\">α₂</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"n\">map_domain</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">map_domain</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">β</span> <span class=\"n\">α₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n<p>and I can then use it to construct the ring isomorphism as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">add_monoid_algebra.to_multiplicative</span> <span class=\"o\">:</span>\n  <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"bp\">≃+*</span> <span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">multiplicative</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">finsupp.dom_congr</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">map_domain_mul</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">extract_goal</span><span class=\"o\">,</span> <span class=\"c1\">-- this is where the weird goal appears</span>\n    <span class=\"n\">intros</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">to_add_mul</span><span class=\"o\">],</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">finsupp.dom_congr</span><span class=\"o\">,</span> <span class=\"n\">map_domain_add</span><span class=\"o\">],</span>\n  <span class=\"o\">},</span>\n  <span class=\"bp\">..</span><span class=\"n\">finsupp.dom_congr</span> <span class=\"n\">multiplicative.to_add</span> <span class=\"o\">}</span>\n</code></pre></div>\n\n<p>What I'd like to do is bundle <code>f</code>and <code>f_map_mul</code> into a <code>α →+ α₂</code>. The <code>→+</code> object I need is exactly <code>bad_to_add</code>.</p>",
        "id": 212220659,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601813737
    },
    {
        "content": "<p>I'm asking a more basic question, I think. What kind of object is <code>monoid_algebra k (multiplicative G)</code>? What operations does it support?</p>",
        "id": 212220768,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601813902
    },
    {
        "content": "<p>Does it have an addition and multiplication, and do they make sense</p>",
        "id": 212220774,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601813919
    },
    {
        "content": "<p>Perhaps it helps to note that the implementation notes for <code>add_monoid_algebra</code> say</p>\n<blockquote>\n<p>Similarly, I attempted to just define <code>add_monoid_algebra k G := monoid_algebra k (multiplicative G)</code>,<br>\nbut the definitional equality <code>multiplicative G = G</code> leaks through everywhere, and<br>\nseems impossible to use.</p>\n</blockquote>",
        "id": 212220790,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601813988
    },
    {
        "content": "<p>well there you have it</p>",
        "id": 212220841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601814039
    },
    {
        "content": "<p>Right - and IMO the thing that makes it impossible to use is the absence of <code>add_monoid_algebra.to_multiplicative</code> above</p>",
        "id": 212220847,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601814065
    },
    {
        "content": "<p>With that in place I can (hopefully) replace all the <code>add_monoid_algebra</code> theorems with</p>\n<ol>\n<li>Apply the iso</li>\n<li>use the proof for <code>monoid_algebra</code></li>\n</ol>",
        "id": 212220852,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601814088
    },
    {
        "content": "<p>the problem is the defeqs are wrong</p>",
        "id": 212220860,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601814105
    },
    {
        "content": "<p>The problem with what and which defeqs?</p>",
        "id": 212220869,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601814120
    },
    {
        "content": "<p>The iso is trivial, I guess, because they are equal objects</p>",
        "id": 212220907,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601814128
    },
    {
        "content": "<p>To fix the defeqs, the definition should be changed to something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">something</span> <span class=\"n\">reasonable</span><span class=\"o\">,</span>\n  <span class=\"n\">mul</span> <span class=\"o\">:=</span> <span class=\"n\">something</span> <span class=\"n\">reasonable</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">multiplicative</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"c1\">-- use the unreasonable equalities to do the proof obligations</span>\n</code></pre></div>",
        "id": 212220959,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601814237
    },
    {
        "content": "<p>I don't quite get that example - today it's defined as <code>def add_monoid_algebra := G →₀ k</code></p>",
        "id": 212221010,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601814291
    },
    {
        "content": "<p>oh I see, it is not the definition</p>",
        "id": 212221030,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601814328
    },
    {
        "content": "<p>and you want to recover that representation</p>",
        "id": 212221034,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601814345
    },
    {
        "content": "<p>The idiomatic way to use <code>multiplicatuve</code> is to use the <code>to_add</code> function, and others like it.</p>",
        "id": 212221080,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1601814377
    },
    {
        "content": "<p>@Chris, which message is that in response to?</p>",
        "id": 212221097,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601814407
    },
    {
        "content": "<p>somewhere in your definition is an \"illegal\" unfolding of <code>multiplicative</code></p>",
        "id": 212221112,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601814450
    },
    {
        "content": "<p>you could try making <code>multiplicative</code> irreducible to see if that pinpoints the issue, but I don't have your code to test</p>",
        "id": 212221131,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601814482
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, I think what you're recommending is already what I'm planning to do:</p>\n<ul>\n<li>Keep the definition of <code>add_monoid_algebra</code></li>\n<li>Keep the definition of <code>add_monoid_algebra.has_add</code></li>\n<li>Keep the definition of <code>add_monoid_algebra.has_mul</code></li>\n<li>Transfer the ring structure of <code>add_monoid_algebra</code> over the isomorphism</li>\n</ul>",
        "id": 212221155,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601814484
    },
    {
        "content": "<p>the question is whether the isomorphism itself is well typed</p>",
        "id": 212221180,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601814514
    },
    {
        "content": "<p>There are two isomorphism here - <code>bad_add_to_add</code> and <code>monoid_algebra.to_additive</code></p>",
        "id": 212221192,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601814538
    },
    {
        "content": "<p>The former is obviously badly typed, IMO the latter is totally safe</p>",
        "id": 212221198,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601814550
    },
    {
        "content": "<p>But the former is a valuable tool for building the latter</p>",
        "id": 212221201,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601814564
    },
    {
        "content": "<p>A <code>~=+*</code> isomorphism comes with the assumption that both sides have reasonable addition/multiplication structures</p>",
        "id": 212221202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601814566
    },
    {
        "content": "<p>Any <code>to_additive</code> def will inevitably perform an <code>illegal</code> unfolding of <code>multiplicative</code></p>",
        "id": 212221247,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601814606
    },
    {
        "content": "<p>yes, but you aren't doing such a def</p>",
        "id": 212221256,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601814626
    },
    {
        "content": "<p>actually I take that back, <code>to_additive</code> does no unfolding</p>",
        "id": 212221264,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601814650
    },
    {
        "content": "<p><code>to_additive</code> does a copy paste job</p>",
        "id": 212221269,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601814662
    },
    {
        "content": "<p>so there is no leakage</p>",
        "id": 212221276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601814669
    },
    {
        "content": "<p>My claim is <code>bad_add_to_add</code> is a utility function to perform that unfolding / copy paste</p>",
        "id": 212221278,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601814674
    },
    {
        "content": "<p><code>bad_add</code> is aptly named, because <code>multiplicative G</code> isn't supposed to have an add</p>",
        "id": 212221300,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601814717
    },
    {
        "content": "<p>and anything that contains <code>bad_add</code> in its statement is also bad</p>",
        "id": 212221350,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601814751
    },
    {
        "content": "<p>I had problems with leakage when using with_zero and I fixed it by making with_zero irreducible and approaching everything in a principled way, never using definitional equality apart from when I was setting up the API</p>",
        "id": 212221365,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1601814786
    },
    {
        "content": "<p>The statement of <code>bad_add_to_add</code> is exactly an intermediate goal state in <code>add_monoid_algebra.to_multiplicative</code> (edited)</p>",
        "id": 212221366,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601814786
    },
    {
        "content": "<p>which includes <code>bad_add_to_add</code></p>",
        "id": 212221367,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601814792
    },
    {
        "content": "<p>what <code>to_additive</code> are you talking about?</p>",
        "id": 212221376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601814821
    },
    {
        "content": "<p>Ah, sorry - <code>add_monoid_algebra.to_multiplicative</code></p>",
        "id": 212221379,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601814834
    },
    {
        "content": "<p>I meant that throughout</p>",
        "id": 212221419,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601814846
    },
    {
        "content": "<p>I don't know what the statement of <code>add_monoid_algebra.to_multiplicative</code> is but it seems highly likely that some bad_add stuff is in there</p>",
        "id": 212221430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601814882
    },
    {
        "content": "<p>I pasted it above</p>",
        "id": 212221434,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601814897
    },
    {
        "content": "<p>It's my proposed isomorphism</p>",
        "id": 212221436,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601814901
    },
    {
        "content": "<p>I mean the full statement</p>",
        "id": 212221440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601814906
    },
    {
        "content": "<p><a href=\"#narrow/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!/near/212220659\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!/near/212220659</a> is the full statement?</p>",
        "id": 212221452,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601814938
    },
    {
        "content": "<p>I just don't understand how you can have a <code>add_monoid_algebra</code> on one side and a <code>monoid_algebra </code> on the other and they are the same type of object</p>",
        "id": 212221456,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601814961
    },
    {
        "content": "<p>There are maps from G to multiplicative G which could be used at all times. Does this solve the problems you have Eric? In my mind the fix for the leakage mentioned in the docs is to make <code>multiplicative</code> irreducible after the API has been set up</p>",
        "id": 212221493,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1601814965
    },
    {
        "content": "<p>There are implicit arguments</p>",
        "id": 212221494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601814975
    },
    {
        "content": "<p>and all the interesting stuff in this discussion is only visible if you look at the implicit arguments</p>",
        "id": 212221500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601815006
    },
    {
        "content": "<p>An add_monoid_algebra and a monoid_algebra are just both semirings, they can be isomorphic</p>",
        "id": 212221503,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1601815017
    },
    {
        "content": "<p>aha</p>",
        "id": 212221509,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601815028
    },
    {
        "content": "<p>so is it the <code>finsupp</code> lemmas then that are exposing the defeqs?</p>",
        "id": 212221514,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601815059
    },
    {
        "content": "<p>Perhaps the easiest way to see is:</p>\n<ul>\n<li><code>add_monoid_algebra</code>: <code>single a1 b1 * single a2 b2 = single (a1 + a2) (b2 * b2)</code></li>\n<li><code>monoid_algebra</code>: <code>single a1 b1 * single a2 b2 = single (a1 * a2) (b2 * b2)</code></li>\n</ul>",
        "id": 212221561,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601815098
    },
    {
        "content": "<p>So this is an obvious candidate for the type of map that Kevin is talking about - all I want to do is extend the existing maps to preserve additional structure</p>",
        "id": 212221571,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601815136
    },
    {
        "content": "<p>Aha:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">add_monoid_algebra.map_domain_mul</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">α₂</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α₂</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f_map_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)):</span>\n  <span class=\"o\">(</span><span class=\"n\">map_domain</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">β</span> <span class=\"n\">α₂</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"n\">map_domain</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">map_domain</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">β</span> <span class=\"n\">α₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n<p>In your definition, the function <code>f</code> is <code>multiplicative.to_add</code>, so it should not be type correct for <code>f_map_mul</code></p>",
        "id": 212221727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601815372
    },
    {
        "content": "<p>I think that if you want to relate the two structures you could go further and define a group homomorphism between an add_group and a group, give it a nice notation, prove that this induces a morphism of semirings from add_monoid_alg and monoid_alg, do things the other way, prove that isomorphisms get sent to isomorphisms etc</p>",
        "id": 212221740,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1601815410
    },
    {
        "content": "<p>We have spent two years running from the fact that we have two kinds of groups; usually it works fine because mathematicians use multiplication and addition in quite different ways, but with valuations I ran into problems because we didn't have eg any API for an infinite cyclic group. Valuations are both additive and multiplicative in the literature and lean's eccentric approach to keeping them separate has had advantages (eg the crystallisation of the monoid with 0 idea) but it also has disadvantages, and one we're seeing now is that it's difficult to pass from one world to the other.</p>",
        "id": 212221888,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1601815618
    },
    {
        "content": "<p>But I think that one reason it's difficult is that nobody cared enough to write the API yet</p>",
        "id": 212221899,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1601815648
    },
    {
        "content": "<p>I need an additive valuation on a multiplicative object to continue with discrete valuation rings and it's not there. Maybe it's time to put these things there? We've as yet seen no issues with people wanting to use ten different notations for groups and this idea not scaling.</p>",
        "id": 212221956,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1601815718
    },
    {
        "content": "<p>I think that defining the structure which is a group hom from an additive to a multiplicative object and making a proper API would be the correct way to get the morphisms you want. Or are there other problems I've not foreseen?</p>",
        "id": 212222027,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1601815817
    },
    {
        "content": "<p>We already have the group homs between additive and multiplicative objects - the case in question is dependent types <code>D X</code> and <code>D (multiplicative Y)</code>, where the <code>monoid</code> on X is used internally by <code>D X</code></p>",
        "id": 212222337,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601816396
    },
    {
        "content": "<p>Anyway, I've put the first lemma I need (<code>finsupp.dom_add_congr</code>) up as <a href=\"https://github.com/leanprover-community/mathlib/issues/4398\">#4398</a>.</p>\n<p><del>I think that alone is enough to demonstrate the issue, without complicating things with monoid_algebra.</del></p>\n<p><del>The simplified question is, given <code>monoid α</code> how do I construct the canonical isomorphism <code>finsupp α β ≃+ finsupp (additive α) β</code>? I can construct <code>finsupp α β ≃ finsupp (additive α) β</code> easily with <code>finsupp.dom_congr</code>, but I can't use <code>finsupp.dom_add_congr</code> without  the \"illegal\" <code>α ≃+ additive α</code>object discussed above.</del></p>",
        "id": 212222707,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601817015
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!/near/212221727\">said</a>:</p>\n<blockquote>\n<p>Aha: &lt;snip&gt;<br>\nIn your definition, the function <code>f</code> is <code>multiplicative.to_add</code>, so it should not be type correct for <code>f_map_mul</code></p>\n</blockquote>\n<p>Right, so I just called <code>rw</code> on that definition, and lean created the nonsense goal for me automatically</p>",
        "id": 212223390,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601818137
    },
    {
        "content": "<p>The moral is with these different instances on plain <code>def B := A</code> definitions, you really should avoid doing anything that would be ill-typed if <code>B</code> wasn't defeq to <code>A</code>. At some point, it becomes easier to just not have them be defeq in the first place.</p>",
        "id": 212225089,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601820915
    },
    {
        "content": "<p>I ended up not using <code>bad_add_to_add</code>, as I forgot that I did not need that <code>f 0 = 0</code>. <a href=\"https://github.com/leanprover-community/mathlib/issues/4402\">#4402</a> still has the nonsense intermediate goal state that started this thread.</p>",
        "id": 212226938,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601823979
    },
    {
        "content": "<p>Does mathlib have something like a monoid morphism from a multiplicative monoid to an additive monoid (or vice versa)? If not, should we add it? We can call one a <code>logarithm</code>and the other an <code>exponential</code>.</p>",
        "id": 212229849,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601828610
    },
    {
        "content": "<p>(Oh, I now see Kevin's comments about this.)</p>",
        "id": 212229963,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601828776
    },
    {
        "content": "<p>The combinatorial explosion of lemmas in all the variants sounds a bit scary, but maybe this is the logical conclusion of having <code>add_monoid</code> and <code>monoid</code> in the first place?</p>",
        "id": 212230672,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601829996
    },
    {
        "content": "<p>Also, we can call <code>to_add</code> the \"universal logarithm\" on <code>multiplicative α</code>, which sounds very sophisticated.</p>",
        "id": 212230679,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601830024
    },
    {
        "content": "<p>For notation: <code>+→*</code> for exponentials and <code>*→+</code> for logarithms?</p>",
        "id": 212230756,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601830157
    },
    {
        "content": "<p>What about this approach:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_binop</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_const</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">widget</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_binop</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_binop</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_const</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_const</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_const</span> <span class=\"o\">:</span> <span class=\"n\">to_fun</span> <span class=\"n\">has_const.const</span> <span class=\"bp\">=</span> <span class=\"n\">has_const.const</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_binop</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">has_binop.op</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">has_binop.op</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">y</span><span class=\"o\">))</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">add_to_op</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_binop</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨(</span><span class=\"bp\">+</span><span class=\"o\">)⟩</span>\n<span class=\"kd\">instance</span> <span class=\"n\">zero_to_const</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_const</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"n\">mul_to_op</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_binop</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨(</span><span class=\"bp\">*</span><span class=\"o\">)⟩</span>\n<span class=\"kd\">instance</span> <span class=\"n\">one_to_const</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_const</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n<span class=\"k\">#check</span> <span class=\"n\">widget</span> <span class=\"n\">M</span> <span class=\"n\">N</span>\n<span class=\"k\">#check</span> <span class=\"n\">widget</span> <span class=\"n\">N</span> <span class=\"n\">M</span>\n</code></pre></div>",
        "id": 212232281,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601832493
    },
    {
        "content": "<p>I guess this is a problem if <code>M</code> is a ring.</p>",
        "id": 212232287,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601832526
    },
    {
        "content": "<p>I was also wondering about the similar:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">base_monoid</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">identity</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">op</span><span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">op_identity</span> <span class=\"o\">:</span> <span class=\"bp\">...</span><span class=\"o\">)</span> <span class=\"c1\">-- etc</span>\n\n<span class=\"n\">abbreviation</span> <span class=\"n\">add_monoid</span> <span class=\"bp\">=</span> <span class=\"n\">base_monoid</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">)</span>\n\n<span class=\"n\">abbreviation</span> <span class=\"n\">monoid</span> <span class=\"bp\">=</span> <span class=\"n\">base_monoid</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 212232940,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601833377
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> check out how these things work in Agda. It's similar to what you suggest.</p>",
        "id": 212233154,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601833626
    },
    {
        "content": "<p>In the interest of avoiding combinatorial explosions, to what extent can we get away with using <code>G -&gt;* multiplicative H</code> for \"logarithmic homs\"?</p>",
        "id": 212246817,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601854367
    },
    {
        "content": "<p>I guess most things should work out if we define the the <code>has_coe_to_fun</code> correctly, no?</p>",
        "id": 212248851,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601857988
    },
    {
        "content": "<p>I think that we can't redefine <code>has_coe_to_fun</code> for this subcase.</p>",
        "id": 212250144,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1601859977
    },
    {
        "content": "<p>You use a type alias</p>",
        "id": 212250228,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601860177
    },
    {
        "content": "<p>And loose lots of lemmas.</p>",
        "id": 212250558,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1601860755
    },
    {
        "content": "<p>This is not better than adding a new type.</p>",
        "id": 212250562,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1601860766
    },
    {
        "content": "<p>Yeah, you're right.</p>",
        "id": 212250623,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601860823
    },
    {
        "content": "<p>Is there some @[derive] magic that can be used?</p>",
        "id": 212250628,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601860831
    },
    {
        "content": "<p>My suggestion is <em>not</em> to create a new type at all, just live with the fact that the codomain of the hom is <code>multiplicative H</code> and use <code>multiplicative</code> lemmas to convert the statements to things about addition in <code>H</code></p>",
        "id": 212250691,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601860957
    },
    {
        "content": "<p>How about a new type for<code>multiplicative int</code>?</p>",
        "id": 212261750,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1601878196
    },
    {
        "content": "<p>I've been using <code>multiplicative int</code> a lot lately. I just made notation for it. <code>C∞</code> for the infinite cyclic group.</p>",
        "id": 212263593,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1601880087
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!/near/212232940\">said</a>:</p>\n<blockquote>\n<p>I was also wondering about the similar: &lt;snip&gt;</p>\n</blockquote>\n<p>Turns out this is already discussed here: <a href=\"https://github.com/leanprover/lean/wiki/Refactoring-structures#encoding-the-algebraic-hierarchy-1\">https://github.com/leanprover/lean/wiki/Refactoring-structures#encoding-the-algebraic-hierarchy-1</a></p>",
        "id": 212314099,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601910972
    }
]
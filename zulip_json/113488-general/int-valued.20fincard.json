[
    {
        "content": "<p>how about <code>fincard</code> is integer-valued and all infinite sets get sent to -1?</p>",
        "id": 231043548,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616168593
    },
    {
        "content": "<p>If you want <code>fincard (A x B) = fincard A * fincard B</code>, you better send infinite sets to <code>0</code>. There are often better choices for junk values than just random choices (and most of the time the good choice is <code>0</code>, unless it is <code>37</code>).</p>",
        "id": 231044091,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1616168804
    },
    {
        "content": "<p>Aah yes in fact I already knew that :-/ Somewhere I even have a proof of <code>fincard.prod</code>, it's quite unpleasant, you need to do pretty much all nine cases empty, finite and non-empty, infinite. However maybe we don't want <code>fincard.prod</code> to apply to all sets? People will only use it when both sets are finite anyway.</p>",
        "id": 231044698,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616169028
    },
    {
        "content": "<p>I do like the -1 proposal. In my API, infinite sets go to zero, and this forces finiteness hypotheses in <strong>lots </strong>of places, such as the following: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">size_le_one_iff_mem_unique</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">size</span> <span class=\"n\">s</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"n\">f</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I could live with products being a bit of a pain in exchange for size zero really meaning empty. I would also be very happy if it could be int-valued.</p>",
        "id": 231045064,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616169172
    },
    {
        "content": "<p>Just realized that infinite sets having size -1 also breaks the above lemma, as well as the lemma that size is nonnegative. I think I still prefer it, though.</p>",
        "id": 231045397,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616169291
    },
    {
        "content": "<p>Mainly <code>int</code>-valued is what I want</p>",
        "id": 231045427,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616169308
    },
    {
        "content": "<p>Maybe one could argue that <code>int</code> fits better than <code>nat</code> with the noncomputable setting where <code>fincard, finsum</code> etc live.</p>",
        "id": 231045661,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616169390
    },
    {
        "content": "<p>I am not really clear why we can't just have a nat version and then you coerce into int yourself. This conversation should be going on elsewhere by the way.</p>",
        "id": 231045855,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616169475
    },
    {
        "content": "<p>(I've moved the int-valued size / fincard messages to this new thread).</p>",
        "id": 231047007,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1616169829
    },
    {
        "content": "<p>OK so I claim that <code>fincard</code> should be nat-valued, and that you should just be coercing it into int and using <code>push_cast</code></p>",
        "id": 231049226,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616170777
    },
    {
        "content": "<p>I can't tell how much of this is people joking, but fwiw: I'm strongly against using <code>-1</code> for infinite sets or as a substitute for <code>none</code>. What is this, C?</p>",
        "id": 231049763,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616170976
    },
    {
        "content": "<p>And size isn't negative, so using <code>int</code> is just silly. If you want int subtraction, use <code>\\u (fincard s)</code></p>",
        "id": 231049977,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616171055
    },
    {
        "content": "<p>What is the smoothest way to prove the second lemma here from the first if <code>size</code> is in <code>nat</code>? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">size_modular</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.finite</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">t.finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">size</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">size</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">size</span> <span class=\"n\">s</span> <span class=\"bp\">+</span> <span class=\"n\">size</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">size_union</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.finite</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">t.finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">size</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">size</span> <span class=\"n\">s</span> <span class=\"bp\">+</span> <span class=\"n\">size</span> <span class=\"n\">t</span> <span class=\"bp\">-</span> <span class=\"n\">size</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>If it is in <code>int</code>, then <code>linarith [size_modular s t hs ht]</code> will work.</p>",
        "id": 231051592,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616171654
    },
    {
        "content": "<p>Does <code>zify</code> do anything?</p>",
        "id": 231052119,
        "sender_full_name": "Jason KY.",
        "timestamp": 1616171869
    },
    {
        "content": "<p>It changes the goal by coercing both sides to <code>int</code>.</p>",
        "id": 231052295,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616171928
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 231052385,
        "sender_full_name": "Jason KY.",
        "timestamp": 1616171974
    },
    {
        "content": "<p>no - I don't think it can unfold the coercions.</p>",
        "id": 231052478,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616172003
    },
    {
        "content": "<p>Sorry,  I didnt see you had a subtraction in the second lemma</p>",
        "id": 231052539,
        "sender_full_name": "Jason KY.",
        "timestamp": 1616172021
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constants</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">size_modular</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">size_union</span>  <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"bp\">-</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">size_modular.symm</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 231052567,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1616172027
    },
    {
        "content": "<p>I changed it to some random nats as I couldn't work out the right imports, but something like this should work</p>",
        "id": 231052676,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1616172068
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 231053010,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616172185
    },
    {
        "content": "<p>I am now trying to refactor my matroid project to use <code>nat</code> size, to see how bad things get. My current approach uses 'linarith and forget' in lots of places, and I want to see how that pans out with <code>nat</code> and coercions. In the above example, <code>simp</code> came to the rescue, but I'm worried it won't be so easy in larger cases.</p>",
        "id": 231053353,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616172335
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 231054627,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616172838
    },
    {
        "content": "<p>Another example : I have the following goal. </p>\n<p><code>⊢ size (s ∪ t) = size (s ∪ t) - size (s ∩ t) + size (s ∩ t)</code>. </p>\n<p>This is true if size is <code>nat</code>-valued because of a fact about sets. This is true if size is <code>int</code>-valued because of a fact about <code>int</code>. In this (and many more complicated examples), I don't want to have to care about the fact about sets, or to turn the proof by <code>ring</code> into something more involved.</p>",
        "id": 231055147,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616173019
    },
    {
        "content": "<p>If you are using nats then you shouldn't be using subtraction at all. How did that subtraction end up in your goal?</p>",
        "id": 231055335,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616173086
    },
    {
        "content": "<p>Isn't it the case that the way <code>size</code> works is because of facts about sets?</p>",
        "id": 231055705,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616173232
    },
    {
        "content": "<p>Maybe I'm taking the size of the complement of something? Or the difference of the size of the set and one of its subsets? Here it's because I'm doing the latter in proving the identity <code> size (s ∪ t) = size (s \\ t) + size (t \\ s) + size (s ∩ t)</code>.</p>",
        "id": 231055753,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616173248
    },
    {
        "content": "<p><code>size</code> had better work in a reasonable way given the set-fact <code>s ∩ t ≤ s ∪ t</code></p>",
        "id": 231055868,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616173290
    },
    {
        "content": "<p>this looks to me like it should follow from size (a union b) = size a + size b if disjoint</p>",
        "id": 231055995,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616173330
    },
    {
        "content": "<p>I think there are two ways of looking at the goal you had, it is either a statement about how <code>size</code> works, given some knowledge about sets, or how <code>union</code> and <code>inter</code> work, given some knowledge about <code>size</code>.</p>",
        "id": 231056075,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616173362
    },
    {
        "content": "<p>This stuff should be in the API for size and it's not unreasonable to ask the person writing the API to struggle a bit with nats, but this certainly looks doable without too much trouble.</p>",
        "id": 231056107,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616173378
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/int-valued.20fincard/near/231055995\">said</a>:</p>\n<blockquote>\n<p>this looks to me like it should follow from size (a union b) = size a + size b if disjoint</p>\n</blockquote>\n<p>Absolutely! None of this is hard to prove - it's just that  'rearrange every calculation involving size so that all signs are +` is a constraint imposed upon me by the language that gets in the way of how I think about these things as a mathematician.</p>",
        "id": 231056427,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616173476
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/int-valued.20fincard/near/231055995\">said</a>:</p>\n<blockquote>\n<p>this looks to me like it should follow from size (a union b) = size a + size b if disjoint</p>\n</blockquote>\n<p>Right, rewrite <code>s ∪ t = (s ∩ t) ∪ (t \\ s) ∪ (s \\ t)</code> somehow and apply a lemma about size of disjoint sets.</p>",
        "id": 231056690,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616173564
    },
    {
        "content": "<p>then just coerce to int. But when you're making the actual API it must be made for nat.</p>",
        "id": 231056734,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616173582
    },
    {
        "content": "<p>Is the answer to the question 'what is the size of the difference of a set and one of its subsets?' really not that it's a subtraction of sizes?</p>",
        "id": 231056760,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616173593
    },
    {
        "content": "<p>You can do what you like with size, I'm just saying that <em>for the API</em> one has to struggle to get it all into nat.</p>",
        "id": 231056827,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616173624
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">nat.sub_add_cancel</span> <span class=\"n\">hn</span>\n</code></pre></div>",
        "id": 231056897,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616173661
    },
    {
        "content": "<p>And you know for sure that <code>s ∩ t ≤ s ∪ t</code> and <code>size.mono</code></p>",
        "id": 231056938,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616173681
    },
    {
        "content": "<p>Yes, but <code>ring</code> is easier. Of course the <code>nat</code> API can handle all this stuff- I'm just saying it makes a lot of it much uglier.</p>",
        "id": 231057141,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616173755
    },
    {
        "content": "<p>Basically the API shouldn't have any subtraction in it (and probably no subtractions even in the proofs) and then when it comes to the case of subsets then the API gives you the &lt;= and now you can choose whether to struggle more with nats or just coerce</p>",
        "id": 231057182,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616173775
    },
    {
        "content": "<p>When you say 'just coerce', do you mean 'write <code>(fincard s : int)</code> instead of <code>fincard s</code> everywhere? If so, you need an API for <code>coercions of fincard</code> or spend half your life translating back and forth.</p>",
        "id": 231057419,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616173868
    },
    {
        "content": "<p>The nat API is fine. I remember the days before <code>ring</code> and all you have to do is know (how to find) the gazillion lemmas you need. But the API writer is the one doing the struggling and that doesn't have to be you, you can just sorry stuff</p>",
        "id": 231057423,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616173871
    },
    {
        "content": "<p>The API is already there, it's just the coercion from nat to int.</p>",
        "id": 231057499,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616173907
    },
    {
        "content": "<p>Another thing is that <code>ring</code> works fine as long as you're not doing subtraction. The big mistake is to do a nat subtraction in the first place. If you want a-b and you know b&lt;=a then maybe the variable should not have been a, maybe a-b should have been the other variable</p>",
        "id": 231057734,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616174001
    },
    {
        "content": "<p>I guess my opinion on this is like Mario's opinion on fincard. Mario knows full well that everything you want to do can be done with finset.sum but because you got frustrated making it work we're trying finsum. Now similarly I think everything should be doable with nat because I spent a lot of time wrestling with nat before ring, but it's causing you hassle so I say just coerce to int if that works for you. But when we're making the API we need to stick to nat and I am confident that there will be no problems</p>",
        "id": 231058160,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616174170
    },
    {
        "content": "<p>PS I was waiting for finsum to get merged before fincard</p>",
        "id": 231058285,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616174223
    },
    {
        "content": "<p>In many cases, I really have a set, I really have one of its subsets, and I really want to look at the cardinality of the difference, and maybe do complicated things with the term it gives me, while not wanting to be keeping track of what has what type. I'm not looking at the wrong variables. The implications of doing what you are suggesting for my project are a lot of mental gymnastics to solve problems that are distinctly unmathematical, and don't currently exist just using <code>int</code>.</p>",
        "id": 231058684,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616174393
    },
    {
        "content": "<p>For reference for the types of coercions Kevin mentioned:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- one way of coercion, given an existing goal about nats</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">int.coe_nat_inj'</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"c1\">-- still needs a m ≤ n to coerce ↑(n - m) to ↑n - ↑m</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">int.coe_nat_sub</span> <span class=\"n\">hn</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- second way of coercion, make the goal about ints initially</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 231058817,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616174432
    },
    {
        "content": "<p>And I figured that about fincard - looking forward to it!</p>",
        "id": 231058851,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616174455
    },
    {
        "content": "<p>Do you have a simp lemma saying </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">size_sub</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">≤</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">size</span> <span class=\"n\">s</span> <span class=\"bp\">-</span> <span class=\"n\">size</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">size</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">\\</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 231059248,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616174583
    },
    {
        "content": "<p>Or would you prefer it be reversed in your use case?</p>",
        "id": 231059324,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616174612
    },
    {
        "content": "<p>The cardinality of the difference is precisely the variable you are missing. You don't want to express this as a-b. You want this to be the variable.</p>",
        "id": 231059452,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616174660
    },
    {
        "content": "<p>But that is the size of the set of mammals that are not elephants. I would rather look at the elephants and look at the mammals.</p>",
        "id": 231059593,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616174719
    },
    {
        "content": "<p>The point is that the difference is a thing, s\\t, and its cardinality exists, meaning that you never have to create it by doing the subtraction</p>",
        "id": 231059636,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616174739
    },
    {
        "content": "<p>Every time you do a nat subtraction you're thinking about it in the wrong way because you are implicitly making use of a hypothesis which says that something is &lt;= something else.</p>",
        "id": 231059784,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616174792
    },
    {
        "content": "<p>If you want to throw away that usage then coerce to int and use push_cast, a tactic specifically designed to deal with the coercions</p>",
        "id": 231059892,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616174853
    },
    {
        "content": "<p>I think the difference here is that Kevin is saying you do all of the rearrangements (union, inter, diff, etc) on the sets first, then talk about size, and write lemmas that push operations on <code>size</code> into operations on sets, while Peter is saying you expand out all the set rearrangements into statements about size, and talk about numbers instead.</p>",
        "id": 231059957,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616174880
    },
    {
        "content": "<p>But you have to pay somehow if you want to use subtraction. Our opinions differ as to how you should be paying</p>",
        "id": 231060011,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616174890
    },
    {
        "content": "<p>That's why I don't want to do nat subtractions. I'm working in integer-land, with many quantities that are both cardinalities of sets and other things, and I want to treat cardinalities just like the other terms they're being combined with.</p>",
        "id": 231060068,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616174913
    },
    {
        "content": "<p>If we're paying, then your way is far more expensive for me</p>",
        "id": 231060090,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616174929
    },
    {
        "content": "<p>Then just coerce to integers, never use natural subtraction, and sorry all the card results you can't be bothered to prove and I'll deal with them in the fincard PR :-)</p>",
        "id": 231060164,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616174957
    },
    {
        "content": "<p>still harder than <code>linarith</code></p>",
        "id": 231060221,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616174986
    },
    {
        "content": "<p>but I'll give it a try!</p>",
        "id": 231060390,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616175037
    },
    {
        "content": "<p>I just don't think we can justify an integer fincard</p>",
        "id": 231060435,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616175052
    },
    {
        "content": "<p>yeah, and I'm not really trying to say that one makes sense in mathlib</p>",
        "id": 231060512,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616175083
    },
    {
        "content": "<p>But I think that \"push_cast at *; linarith\" is not too much to ask</p>",
        "id": 231060554,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616175100
    },
    {
        "content": "<p>I really think it makes sense for me though - your suggestion of PRing is what put this tension in my head</p>",
        "id": 231060583,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616175105
    },
    {
        "content": "<p>What I am conflicted about here is that in some sense I know you don't need fincard and that judicious use of stuff like decidable equality will get you through. But I tired of this. And now the boot is on the other foot -- I'm claiming that all that is happening that either you don't know how to use nat.sub or you don't know how to use pushcast, however the same logic applies: there could be a string of people behind you who all want everything to be in int just because it's easier for people who didn't go through what I went through with arithmetic in 2018 when there was less automation</p>",
        "id": 231061231,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616175285
    },
    {
        "content": "<p>Yeah, it feels like something of a similar nature. Where my fight is coming from is the feeling that subtracting sizes is how I would teach certain things to someone, and being forced to never subtract is just a silly constraint imposed on me by the implementation of a proof assistant. Of course I absolutely understand that cardinality is <code>nat</code>-valued.</p>",
        "id": 231061763,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616175498
    },
    {
        "content": "<p>It is just very helpful to mentally embed <code>nat</code> in <code>int</code> when convenient. Unfortunately you have to pay for this in lean.</p>",
        "id": 231062136,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616175651
    },
    {
        "content": "<p>Whenever you use subtraction you are implicitly invoking the fact that it is \"safe\" because some set is a subset of another set. In general it's not true that size s/t is size s - size t, whether you're nat or int valued. You used that all elephants were mammals above. The question is where you want to store this information. If you use nat subtraction then basically you're saying that you have access to a proof that the thing you're subtracting is at most the thing you're subtracting it from. But if that proof is hidden away somewhere then you'll have to explicitly feed it to lemmas. I'm suggesting that in most cases your hidden proof is that you're doing a-b with b the size of a subset of the thing a is the size of, and here instead of doing the subtraction you can just use the card of the diff set</p>",
        "id": 231062582,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616175844
    },
    {
        "content": "<p>A side -note. I had played a lot with distances in Isabelle, especially with Gromov-hyperbolic stuff where you keep on subtracting distances. For this, the fact that distances are taking values in reals, and not nonnegative reals, is extremely helpful, because otherwise you would need to add coercions to reals all the time. At one point, there was a suggestion that, in mathlib, maybe we could have <code>nnreal</code>-valued distances because, hey, distances are nonnegative. I argued strongly against this because of my previous experience, and then we kept the distances to be real-valued. And I never regretted it.</p>\n<p>The situation is essentially the same here. I can't see what we gain with a nat-valued fincard compared to an int-valued fincard, but I can see what we lose.</p>",
        "id": 231062641,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1616175872
    },
    {
        "content": "<p>(The Gromov product in a metric space is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><msub><mo stretchy=\"false\">)</mo><mi>a</mi></msub><mo>=</mo><mo stretchy=\"false\">(</mo><mi>d</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>d</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo separator=\"true\">,</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>−</mo><mi>d</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">(x, y)_a = (d(x, a) + d(y, a) - d(x, y))/2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord\">2</span></span></span></span>. It looks like a crazy definition but in fact there is something deep behind it. And the subtraction always makes sense also in <code>nnreal</code> because <code>d(x, y) \\le d(x,a) + d(y, a)</code> by the triangular inequality, but if one had to fight subtraction all the time playing with this would be a nightmare).</p>",
        "id": 231062908,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1616175996
    },
    {
        "content": "<p>Well this is a very interesting counterpoint. <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> can you explain again why we're allowed to have metric spaces with a distance function taking values in the reals but we have to have fincard taking values in nat?</p>",
        "id": 231063209,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616176123
    },
    {
        "content": "<p>This is absolutely on the money! </p>\n<p>A related notion in matroid theory is the dual rank function; given a primal rank function <code>r : set T -&gt; int</code> (which is axiomatically required to be nonnegative), the dual rank function <code>r' : set T -&gt; int</code> is defined by <code>r' X = size X + r Xᶜ - r univ</code>. This, as one can prove from the other axioms, is also always nonnegative. But it includes a subtraction. On the one hand, you could say that both functions, being nonnegative, should be <code>nat</code>-valued. On the other hand, I <strong>really</strong> wouldn't appreciate having to think about that proof of nonnegativity whenever I refer to the dual rank of a set, and constantly be invoking some API lemma to make sure its definition doesn't have any subtraction overflow. So I make the rank function <code>int</code>-valued, and everything is fine!</p>",
        "id": 231063433,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616176231
    },
    {
        "content": "<p>In fact we also have the <code>nnreal</code>-valued distance, called <code>nndist</code>. But since it has essentially no advantage over the real-valued distance no-one uses it.</p>",
        "id": 231063625,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1616176317
    },
    {
        "content": "<p>For norms, we have <code>norm</code> and <code>nnnorm</code>, and people use one or the other depending on what is more convenient (with <code>norm</code>being used maybe 80% of the time and <code>nnnorm</code> 20%)</p>",
        "id": 231063798,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1616176375
    },
    {
        "content": "<p>This dual rank example is a great example.</p>",
        "id": 231063826,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616176386
    },
    {
        "content": "<p>And I think it's certainly reasonable to argue that card is some kind of norm so both versions should be available</p>",
        "id": 231063941,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616176434
    },
    {
        "content": "<p>In LTE we don't use <code>nndist</code>, but we use <code>nnnorm</code> <em>a lot</em></p>",
        "id": 231064180,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616176522
    },
    {
        "content": "<p>It's really convenient that the type system keeps track of the nonnegativity</p>",
        "id": 231064240,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616176551
    },
    {
        "content": "<p>But all we are doing is chasing around factors about how norms grow under bounded linear maps there</p>",
        "id": 231064259,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616176559
    },
    {
        "content": "<p>So <code>fincard</code> and <code>nnfincard</code>?</p>",
        "id": 231064309,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1616176566
    },
    {
        "content": "<p>I'm coming to this conclusion</p>",
        "id": 231064344,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616176580
    },
    {
        "content": "<p>Boy, do I have an API ready for you!</p>",
        "id": 231064400,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616176609
    },
    {
        "content": "<p>Lol</p>",
        "id": 231064407,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616176614
    },
    {
        "content": "<p>I agree that the parallel with nndist is worth looking at here. I think the difference is that <code>dist</code> (or <code>norm</code>) is actually a field of the structure, so for example with the Gromov product example that expression (which is obviously real and not obviously nonnegative) is going in as the definition of the distance function, so it is convenient for the distance function to be real-valued to receive such an expression. With <code>card</code> this is not the case - cardinality is an operation on sets/finsets and is not coming out of any structure, it's just an emergent property of sets. Here, it's useful to get as tight information as possible into the type system, hence it should be <code>nat</code> valued, because things like <code>\\u (card s)</code> aren't operations that cancel, it's just a term in your formula that can be manipulated with the usual tactics like <code>push_cast</code>.</p>",
        "id": 231067463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616177803
    },
    {
        "content": "<p>Plus, <code>nat</code> is a much more versatile and heavily lemma'd type than <code>nnreal</code></p>",
        "id": 231067717,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616177901
    },
    {
        "content": "<p>I want to re-emphasize Peter's example of the dual matroid: if you're just dealing with set operations and sizes, it's easy to imagine that every instance of subtraction comes from looking at a pair of nested sets, in which case you can look at the size of the set difference. In that context, nat-valued size makes sense, because being non-negative is really a syntactic property of the expressions you're looking at. But once you deal with matroids and duality, it is absolutely a theorem and not a syntactic fact that the expressions involved are non-negative.</p>",
        "id": 231069043,
        "sender_full_name": "Mathieu Guay-Paquet",
        "timestamp": 1616178444
    },
    {
        "content": "<p>Yeah - I think the case that matroid rank should be int-valued is convincing in a way that surpasses the case for int-valued size. But I am a real fan of these analogies with distance, and they do ring true in how I think about size. </p>\n<p>What are the practical advantages of set size being nat-valued? I can see that it makes induction a bit easier. But is this such a compelling argument that an API for int-valued size is inappropriate? In my mind, the practical advantages of that are obvious.</p>",
        "id": 231069525,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616178654
    },
    {
        "content": "<p>Another example; an object appearing in graphs, matroids and more is a 'connectivity function', which is a certain type of nonnegative function <code>k : set T -&gt; int</code>. There is quite a nice theory of these objects. One way to get one is to take the function defined by <code>k X := M.r X + M.r' X - size X</code>, where the <code>r</code> and <code>r'</code> are the primal and dual rank functions of a matroid <code>M</code>. Like in contexts before, this is nonnegative, but this is a theorem one needs to prove. </p>\n<p>Of course one could define this as a coercion, but no mathematician would look at this formula and ask 'why are you subtracting size?'. And taking the approach that 'nonnegative things should be nat' would lead one to conclude that the LHS and three terms on the RHS all should be <code>nat</code> - so what is the subtraction doing? </p>\n<p>It seems obvious to me that, in contexts like the above, everything is <code>int</code>.</p>",
        "id": 231071631,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616179551
    },
    {
        "content": "<p>By the way, I didn't mention it explicitly but I think that the argument for having <code>int</code> valued matrix rank analogously to the distance function does work, because in that case the rank is a member of the structure so you are dealing with both sides of the equation. I don't see that for the cardinality function, as I said.</p>",
        "id": 231074079,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616180566
    },
    {
        "content": "<p>Rank doesn't have to be a member of the matroid structure - in most definitions, it isn't. It's something you derive.</p>",
        "id": 231074376,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616180669
    },
    {
        "content": "<p>I think it could be nat too; I'm still trying to figure out what you find to be the downside of that though</p>",
        "id": 231074458,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616180706
    },
    {
        "content": "<p>equations can be in <code>int</code> even if the definitions are in <code>nat</code></p>",
        "id": 231074497,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616180723
    },
    {
        "content": "<p>See my example on the dual rank function. In that, we subtract a rank function to get it, but it always has a nonnegative value. It would be a nightmare (in the same way as the Gromov product above) to constantly have to remember the exact reason it's nonnegative, when you're proving a lemma involving dual rank whose statement doesn't care about the nonnegativity.</p>",
        "id": 231074675,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616180793
    },
    {
        "content": "<p>I don't see why you need to do any of that</p>",
        "id": 231074735,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616180821
    },
    {
        "content": "<p>If you're in the weeds proving something, you add and subtract ranks all over the place</p>",
        "id": 231074742,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616180824
    },
    {
        "content": "<p>Okay, so do so</p>",
        "id": 231074755,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616180830
    },
    {
        "content": "<p>work over <code>int</code></p>",
        "id": 231074772,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616180836
    },
    {
        "content": "<p>that doesn't mean the definitions have to be in <code>int</code> too</p>",
        "id": 231074790,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616180846
    },
    {
        "content": "<p>if you need to subtract, use int.sub</p>",
        "id": 231074879,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616180880
    },
    {
        "content": "<p>It's possible to be quite fine grained about where and why to add nonnegativity assumptions and assertions using <code>nat</code> and <code>int</code></p>",
        "id": 231075116,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616180951
    },
    {
        "content": "<p>But why should I be fine-grained when it is easier not to be?</p>",
        "id": 231075167,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616180974
    },
    {
        "content": "<p>Well you said nonnegativity comes up so I guess you need it at some point</p>",
        "id": 231075357,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616181039
    },
    {
        "content": "<p>Coercions are one of the most confusing parts of the learning curve for people getting into this stuff. For most parts of the language they are necessary- in this situation they aren't.</p>",
        "id": 231075380,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616181044
    },
    {
        "content": "<p>Okay? I'm trying to find the best way to express this, which might use features that newbies don't know. Maybe this will be a reason to learn the feature</p>",
        "id": 231075600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616181139
    },
    {
        "content": "<p>yes, I use <code>size_nonneg</code> and <code>rank_nonneg</code> frequently - it is clear in calculations exactly where they're needed. Refactoring to make size (or rank!) <code>nat</code>-valued involves solving a tricky little coercion puzzle in a ton of places.</p>",
        "id": 231075604,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616181141
    },
    {
        "content": "<p>I really don't see how it changes anything to replace all occurrences of <code>size_int x</code> with <code>\\u (size x)</code></p>",
        "id": 231075660,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616181176
    },
    {
        "content": "<p>I don't agree with some of Kevin's comments earlier about removing all references to <code>-</code> by rearranging equations</p>",
        "id": 231075822,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616181246
    },
    {
        "content": "<p>it means using <code>push_cast</code> in a lot of places - I'd rather those are all pushed back into an API</p>",
        "id": 231075849,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616181265
    },
    {
        "content": "<p>It shouldn't</p>",
        "id": 231075877,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616181280
    },
    {
        "content": "<p>Since <code>\\u</code> is always appearing on an atomic function, namely <code>size x</code>, there is nothing for <code>push_cast</code> to do</p>",
        "id": 231075974,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616181323
    },
    {
        "content": "<p><code>\\u size (A U B) = \\u (size A + size B)</code> etc</p>",
        "id": 231076103,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616181366
    },
    {
        "content": "<p>Then state and prove the theorem <code>\\u size (A U B) = \\u (size A) + \\u (size B)</code></p>",
        "id": 231076146,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616181384
    },
    {
        "content": "<p>that's what you would have done with the int-based size API anyway</p>",
        "id": 231076167,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616181402
    },
    {
        "content": "<p>ok, and that's what I've done - a whole API worth of it!</p>",
        "id": 231076174,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616181406
    },
    {
        "content": "<p>so where do all those theorems go?</p>",
        "id": 231076194,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616181415
    },
    {
        "content": "<p>I've just done this with notation for <code>\\u size</code></p>",
        "id": 231076225,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616181434
    },
    {
        "content": "<p>right, that's the question. We were proposing mathlib, maybe Mario is suggesting that it's your problem?</p>",
        "id": 231076226,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616181435
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/int-valued.20fincard/near/231058285\">said</a>:</p>\n<blockquote>\n<p>PS I was waiting for finsum to get merged before fincard</p>\n</blockquote>\n<p>It's here already: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.card\">docs#nat.card</a> (although with a minimal API)</p>",
        "id": 231076425,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616181524
    },
    {
        "content": "<p>A theorem like that can be stated for most <code>nat</code> functions though, it kind of reeks of duplication. Maybe it is good to have for certain functions where it comes up a lot, maybe <code>fincard</code> is such a function, but for mathlib I would try and see if using <code>simp</code> isn't good enough already (since <code>simp</code> will already normalize <code>\\u (size A + size B)</code> to <code>\\u (size A) + \\u (size B)</code>)</p>",
        "id": 231076500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616181566
    },
    {
        "content": "<p>yeah - <code>simp</code> will do some stuff - I was looking into this when refactoring. It is really just seamless to have <code>size</code> be <code>int</code>, though, and the approaches being suggested do all at least involve very frequently manipulating coercions in a way that can be very distracting. It absolutely is duplication that I'm talking about.</p>",
        "id": 231076956,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616181777
    },
    {
        "content": "<p>Is <code>simp</code>, <code>linarith</code> really idiomatic?</p>",
        "id": 231076997,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616181794
    },
    {
        "content": "<p>because there'd be a lot of that (not a fan of the <code>simp only [100+ characters]</code> alternative either)</p>",
        "id": 231077078,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616181836
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> does it make sense to have it in the <code>nat</code> namespace? If it's in the <code>set</code> namespace then you can write <code>s.card</code>. Or is <code>set.card</code> already taken by some crazy cardinal thing? :-/</p>",
        "id": 231077256,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616181913
    },
    {
        "content": "<p>I suppose <code>push_cast at *, linarith</code> as Kevin suggested earlier is cleaner.</p>",
        "id": 231077284,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616181927
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/int-valued.20fincard/near/231077256\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span> does it make sense to have it in the <code>nat</code> namespace? If it's in the <code>set</code> namespace then you can write <code>s.card</code>. Or is <code>set.card</code> already taken by some crazy cardinal thing? :-/</p>\n</blockquote>\n<p>There's <code>nat.card</code> and <code>enat.card</code></p>",
        "id": 231077398,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616181971
    },
    {
        "content": "<p>But I never want to write <code>n.card</code>, so I'm asking why we've put it in the <code>nat</code> namespace.</p>",
        "id": 231077450,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616182006
    },
    {
        "content": "<p>Yakov has turned me on to the power of dot notation.</p>",
        "id": 231077483,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616182024
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/int-valued.20fincard/near/231076500\">said</a>:</p>\n<blockquote>\n<p>A theorem like that can be stated for most <code>nat</code> functions though, it kind of reeks of duplication. Maybe it is good to have for certain functions where it comes up a lot, maybe <code>fincard</code> is such a function, but for mathlib I would try and see if using <code>simp</code> isn't good enough already (since <code>simp</code> will already normalize <code>\\u (size A + size B)</code> to <code>\\u (size A) + \\u (size B)</code>)</p>\n</blockquote>\n<p>But simp <strong>won't</strong> normalize <code>\\u (size A - size B)</code>, even if you give it the proper proof of the inequality:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.int.cast</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(((</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">success_if_fail</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">success_if_fail</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hn</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"n\">success_if_fail</span> <span class=\"o\">{</span> <span class=\"n\">push_cast</span> <span class=\"o\">},</span>\n  <span class=\"n\">push_cast</span> <span class=\"o\">[</span><span class=\"n\">hn</span><span class=\"o\">],</span>\n  <span class=\"n\">simp</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 231078466,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616182466
    },
    {
        "content": "<p>If this isn't useful or true ignore me, but I <em>think</em> the whole reason <code>size</code> is coming up is because it's the (one and only) key dependency for <a href=\"https://github.com/e45lee/lean-matroids/blob/master/src/matroid/axioms.lean\">https://github.com/e45lee/lean-matroids/blob/master/src/matroid/axioms.lean</a> (i.e. for the core different definitions of matroids) right? So if anything perhaps an alternate way to have this conversation is for someone to show Peter a good/minimal set of changes that make that file easily addable?</p>",
        "id": 231079958,
        "sender_full_name": "Julian Berman",
        "timestamp": 1616183211
    },
    {
        "content": "<blockquote>\n<p>But simp won't normalize \\u (size A - size B), even if you give it the proper proof of the inequality:</p>\n</blockquote>\n<p>No, you should never be writing nat.sub here</p>",
        "id": 231080780,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616183620
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321696\">Julian Berman</span> <a href=\"#narrow/stream/113488-general/topic/int-valued.20fincard/near/231079958\">said</a>:</p>\n<blockquote>\n<p>If this isn't useful or true ignore me, but I <em>think</em> the whole reason <code>size</code> is coming up is because it's the (one and only) key dependency for <a href=\"https://github.com/e45lee/lean-matroids/blob/master/src/matroid/axioms.lean\">https://github.com/e45lee/lean-matroids/blob/master/src/matroid/axioms.lean</a> (i.e. for the core different definitions of matroids) right? So if anything perhaps an alternate way to have this conversation is for someone to show Peter a good/minimal set of changes that make that file easily addable?</p>\n</blockquote>\n<p>In a way that's the problem, but I can certainly figure out how to make that file addable myself - I'm working on a branch in which size is <code>nat</code>. The real problem is that every change I make in refactoring makes simple things more complicated, so I'm not convinced that <code>nat</code> size is actually a sound design decision. Some suggestions that have been made make the changes easier, but things are still shaking out to be more complex than they were.</p>",
        "id": 231080928,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616183678
    },
    {
        "content": "<p>I guess the theorem about size of a difference would be something like <code>B \\sub A -&gt; \\u (size (A \\ B)) = \\u (size A) - \\u (size B)</code></p>",
        "id": 231080950,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616183688
    },
    {
        "content": "<p>Yes - that's the exact kind of API lemma I have; I just want to go all-in and give <code>\\u size</code> a name.</p>",
        "id": 231081046,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616183730
    },
    {
        "content": "<p>most of the time you don't even need to acknowledge the presence of the <code>\\u</code></p>",
        "id": 231081083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616183756
    },
    {
        "content": "<p>If you want to name that combination for the specific use of matroids, that's fine, that's your business. I just don't think this is an argument for general fincard</p>",
        "id": 231081260,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616183844
    },
    {
        "content": "<p>What is the argument, in practical terms, that fincard should be nat?</p>",
        "id": 231081830,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616184077
    },
    {
        "content": "<p>I tend to think that generally for extremal combinatorics, it wants to be int.</p>",
        "id": 231082354,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616184340
    },
    {
        "content": "<p>Would your argument also say that for doing probability we'll want the cardinality to be in <code>rat</code>?</p>",
        "id": 231082697,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1616184507
    },
    {
        "content": "<p>that's a good point</p>",
        "id": 231082772,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616184543
    },
    {
        "content": "<p>In practice what I want is <code>ring</code>/<code>linarith</code>, and to throw sizes of sets around without worrying about casts.</p>",
        "id": 231083349,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616184805
    },
    {
        "content": "<p>I'm not sure which way we should go, honestly. From your experience are there some lemmas which are much more painful with <code>nat</code> than with <code>int</code> or is it just the accumulation of boilerplate which is a drag?</p>",
        "id": 231083471,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1616184850
    },
    {
        "content": "<p>It's hard to say definitively because I'm used to the way I've done things, but I just can't see how things are nicer with <code>nat</code>. Having <code>ring</code> and <code>linarith</code> make so many things easy that I want to do (and I think most researchers in combinatorics will want to do) when <code>size</code> is <code>int</code>. Using <code>nat</code> just requires more effort (albeit small) in a lot of places. This is nonzero effort being compared to zero effort. </p>\n<p>And I am not sure of the advantages of <code>nat</code> size in practice. It is more theoretically precise in a sense that I can appreciate, and sometimes having nonnegativity for free might be useful, but what makes it so obviously the right way to do things? Induction on cardinality is a mess with <code>fincard</code> anyway because sets with <code>fincard</code> zero might be infinite, so the slight extra mess from <code>int</code> is no big deal. </p>\n<p>As Mario says, cardinality is a function and not a field, but so is the function that squares an integer  - should it map <code>int</code> to <code>nat</code>?</p>",
        "id": 231085153,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616185623
    },
    {
        "content": "<p>I'd also be curious to hear the arguments in favor of a <code>nat</code>-valued fincard, other than \"it's the right thing\". We know that excluding division by zero would be \"the right thing\", but since it is less practical all theorem provers went the other direction -- it's just a question of being pragmatic. Here, I can see the advantages of an <code>int</code>-valued fincard, so I'd like to see also the advantages of a <code>nat</code>-valued fincard before weighing the ones again the others and making an informed choice.</p>",
        "id": 231085649,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1616185871
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/int-valued.20fincard/near/231077450\">said</a>:</p>\n<blockquote>\n<p>But I never want to write <code>n.card</code>, so I'm asking why we've put it in the <code>nat</code> namespace.</p>\n</blockquote>\n<p>My thinking was that one could type <code>open nat</code> or <code>open enat</code> to unlock their preferred cardinality function.</p>",
        "id": 231094103,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616190379
    },
    {
        "content": "<p>I didn't provide much API so I'm not very attached to these names. It still seemed better to me than <code>fincard</code> and <code>efincard</code> or something.</p>",
        "id": 231094310,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616190489
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> The obvious advantage is that you can use <code>size</code> in <code>nat</code> contexts without needing <code>to_nat</code> and a way to supply the proof of nonnegativity</p>",
        "id": 231095348,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616191103
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/stream/113488-general/topic/int-valued.20fincard/near/231080928\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"321696\">Julian Berman</span> <a href=\"#narrow/stream/113488-general/topic/int-valued.20fincard/near/231079958\">said</a>:</p>\n<blockquote>\n<p>If this isn't useful or true ignore me, but I <em>think</em> the whole reason <code>size</code> is coming up is because it's the (one and only) key dependency for <a href=\"https://github.com/e45lee/lean-matroids/blob/master/src/matroid/axioms.lean\">https://github.com/e45lee/lean-matroids/blob/master/src/matroid/axioms.lean</a> (i.e. for the core different definitions of matroids) right? So if anything perhaps an alternate way to have this conversation is for someone to show Peter a good/minimal set of changes that make that file easily addable?</p>\n</blockquote>\n<p>In a way that's the problem, but I can certainly figure out how to make that file addable myself - I'm working on a branch in which size is <code>nat</code>. The real problem is that every change I make in refactoring makes simple things more complicated, so I'm not convinced that <code>nat</code> size is actually a sound design decision. Some suggestions that have been made make the changes easier, but things are still shaking out to be more complex than they were.</p>\n</blockquote>\n<p>It looks to me like <code>size</code> is enforcing finiteness in this definition, by forcing the rank of any infinite set to be 0. If you want matroids to have to be finite, that's fine (although I'd eventually want to make an infinite version), but that axiom shouldn't be encoded in your <code>size</code> function</p>",
        "id": 231095679,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616191278
    },
    {
        "content": "<p>for example, monoid powers take a <code>nat</code> argument, would you use <code>to_nat</code> in that position?</p>",
        "id": 231095682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616191281
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> I think the question about what to do about infinite sets is a separate one; we have <code>cardinal</code> if you really want to handle the infinite case correctly but the <code>nat</code> case is common enough to warrant special support</p>",
        "id": 231095932,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616191410
    },
    {
        "content": "<p>It is worth pointing out though that <code>enat</code> and <code>int</code> don't play well together</p>",
        "id": 231095952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616191426
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/int-valued.20fincard/near/231095682\">said</a>:</p>\n<blockquote>\n<p>for example, monoid powers take a <code>nat</code> argument, would you use <code>to_nat</code> in that position?</p>\n</blockquote>\n<p>I've come across this already, and the answer is yes. It's rare that I want the size of the set up in an exponent.</p>",
        "id": 231096129,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616191517
    },
    {
        "content": "<p>I totally agree that there should be a <code>nat</code>- or <code>int</code>-valued cardinality function, that comment is perhaps too specific to the <code>matroid</code> context.</p>",
        "id": 231096250,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616191575
    },
    {
        "content": "<p>Would it make sense to go all the way to <code>rat</code> then for use in probability?</p>",
        "id": 231096635,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1616191820
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span> <a href=\"#narrow/stream/113488-general/topic/int-valued.20fincard/near/231095679\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/stream/113488-general/topic/int-valued.20fincard/near/231080928\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"321696\">Julian Berman</span> <a href=\"#narrow/stream/113488-general/topic/int-valued.20fincard/near/231079958\">said</a>:</p>\n<blockquote>\n<p>If this isn't useful or true ignore me, but I <em>think</em> the whole reason <code>size</code> is coming up is because it's the (one and only) key dependency for <a href=\"https://github.com/e45lee/lean-matroids/blob/master/src/matroid/axioms.lean\">https://github.com/e45lee/lean-matroids/blob/master/src/matroid/axioms.lean</a> (i.e. for the core different definitions of matroids) right? So if anything perhaps an alternate way to have this conversation is for someone to show Peter a good/minimal set of changes that make that file easily addable?</p>\n</blockquote>\n<p>In a way that's the problem, but I can certainly figure out how to make that file addable myself - I'm working on a branch in which size is <code>nat</code>. The real problem is that every change I make in refactoring makes simple things more complicated, so I'm not convinced that <code>nat</code> size is actually a sound design decision. Some suggestions that have been made make the changes easier, but things are still shaking out to be more complex than they were.</p>\n</blockquote>\n<p>It looks to me like <code>size</code> is enforcing finiteness in this definition, by forcing the rank of any infinite set to be 0. If you want matroids to have to be finite, that's fine (although I'd eventually want to make an infinite version), but that axiom shouldn't be encoded in your <code>size</code> function</p>\n</blockquote>\n<p>I've had infinite matroids in the back of my mind for a while - it wouldn't be a major refactor to have them. One could define matroids in terms of an axiom set other than the rank function, then derive the rank axioms for the finite case. The reason I haven't done this already is that you need an annoying extra axiom to define infinite matroids correctly, and I don't care about infinite matroids myself  (finite matroids are much more well-studied, to the extend that 'matroid' means 'finite matroid', while infinite matroids get the non-default name 'B-matroid'). </p>\n<p>This isn't really related to my issue with <code>size</code>, though. Doing this refactor now would certainly allow me to get the axioms file into mathlib, but not any interesting lemmas. The file <code>rankfun.lean</code>, which is really the basic api for matroids, uses <code>size</code> extensively, so it would just be pushing the problems down the road.</p>",
        "id": 231096733,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616191909
    },
    {
        "content": "<p>From what I'm hearing, I really think that this int-valued size thing is specific to the matroid context</p>",
        "id": 231097007,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616192059
    },
    {
        "content": "<p>What do the matroid axioms look like in the infinite case?</p>",
        "id": 231097073,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616192110
    },
    {
        "content": "<p>specifically, what does \"size\" mean?</p>",
        "id": 231097111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616192124
    },
    {
        "content": "<p>It’s not just matroids - that’s just what I’m doing. All the problems I’m talking about will show up when doing extremal combinatorics more generally. </p>\n<p>Infinite matroids don’t deal with sizes of sets. It’s quite a different world, and most of the theory matroid theorists are interested in just fails in the infinite setting. It’s a red herring here.</p>",
        "id": 231097865,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616192635
    },
    {
        "content": "<p>but it seems like this int size thing might not even be the right abstraction then. As for extremal combinatorics, that still sounds domain specific to me; I don't think we have anything like that in mathlib</p>",
        "id": 231098003,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616192738
    },
    {
        "content": "<p>Would you like to?</p>",
        "id": 231098120,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616192820
    },
    {
        "content": "<p>Again, infinite matroids have almost no relationship to any notion of size. Finite matroids (matroids) are what care about sizes of sets.</p>",
        "id": 231098229,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616192886
    },
    {
        "content": "<p>I don't see why not, but that doesn't mean that things that are good for the abstractions in extremal combinatorics are also good everywhere. In particular, if it's a choice between using <code>size A</code> and <code>\\u (size A)</code> or <code>to_nat (size A)</code> and <code>size A</code>, I'll pick the former every time; <code>\\u</code> has much nicer theorems about it than <code>to_nat</code></p>",
        "id": 231098254,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616192907
    },
    {
        "content": "<p>Right - why can’t it be a choice others can make differently?</p>",
        "id": 231098317,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616192968
    },
    {
        "content": "<p>And <code>size A</code> and <code>int_size A</code> would mean duplicating a lot of API theorems</p>",
        "id": 231098323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616192976
    },
    {
        "content": "<p>Yup</p>",
        "id": 231098330,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616192983
    },
    {
        "content": "<p>Is there a concrete problem that needs fixing here? We've been talking in abstracts for a while now</p>",
        "id": 231098434,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616193039
    },
    {
        "content": "<p>Yes - I’d like to PR matroids, and this requires either mathlib being ok with an int size api, or me to systematically refractor my code in a way that makes it more complicated.</p>",
        "id": 231098617,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616193168
    },
    {
        "content": "<p>Maybe you should put matroids on a branch and we can look at variations in the review process</p>",
        "id": 231098760,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616193244
    },
    {
        "content": "<p>We would be able to quantitatively answer this question by refactoring it to use nat and seeing how many lines are added/removed by the process</p>",
        "id": 231098861,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616193305
    },
    {
        "content": "<p>I don't know why the CS people are so anti code duplication. What's wrong with two definitions? We can watch and see which one is more useful.</p>",
        "id": 231109523,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616201417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/stream/113488-general/topic/int-valued.20fincard/near/231097865\">said</a>:</p>\n<blockquote>\n<p>It’s not just matroids - that’s just what I’m doing. All the problems I’m talking about will show up when doing extremal combinatorics more generally. </p>\n</blockquote>\n<p>Do you have any reason for claiming this? I've done a good amount of extremal combinatorics in Lean and I haven't had any problems with the things you're talking about: specifically I've had no desire to work with int-valued fincard</p>",
        "id": 231120134,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1616213641
    },
    {
        "content": "<p>Ah, I’m happy to hear that. I’m ok to be told I’m doing it wrong by someone that is working on the same type of math - I just get the impression that what I’m doing is smoother working over the integers and I’m not convinced that changing to nat will make the code better. (I can certainly change to nat - it’s never been a question of whether it’s possible). </p>\n<p>Again, this is because when doing calculations with sizes of sets, subtraction is a normal part of the world,  and the calculations that come up are easier to do if you know you’re in a ring. </p>\n<p>I think coercions are a (small) mental barrier that doesn’t need to be intruding here at all - once you have an api for int size, it’s a tradeoff between zero effort and nonzero.</p>",
        "id": 231146316,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1616246594
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/int-valued.20fincard/near/231109523\">said</a>:</p>\n<blockquote>\n<p>I don't know why the CS people are so anti code duplication. What's wrong with two definitions? We can watch and see which one is more useful.</p>\n</blockquote>\n<p>That's actually what I'm suggesting - try it both ways and see which is better. I think it's been pretty firmly established that this is a feasible task, but we're all just hypothesizing and we need data to make an objective statement</p>",
        "id": 231148650,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616249377
    },
    {
        "content": "<p>Peter's <a href=\"https://github.com/e45lee/lean-matroids\">matroids repo</a> currently shows how things look with an <code>int</code>-valued <code>size</code>. I think he said he was working on a branch swapping things over to <code>nat</code>, so when that gets pushed there should be plenty of examples to compare.</p>",
        "id": 231148792,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1616249530
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/int-valued.20fincard/near/231077483\">said</a>:</p>\n<blockquote>\n<p>Yakov has turned me on to the power of dot notation.</p>\n</blockquote>\n<p>I have seen that in some Discord session Yacov has provided a lesson on dot notation. Has this session been recorded, and if yes, do you have a link to it? Thanks!</p>",
        "id": 233689442,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1617901278
    },
    {
        "content": "<p>No, he just carefully explained to me how to use it in the context of set.finite. For example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.finite</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">finite</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">finite</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finite</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">hs.union</span> <span class=\"n\">ht</span>\n</code></pre></div>\n<p>The idea is that <code>set.union</code> creates the union of the sets, and <code>set.finite.union</code> is the proof that the union of two finite sets is finite. Using dot notation makes it look very natural.</p>",
        "id": 233690668,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617901631
    },
    {
        "content": "<p>Some boring person made <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_union.union\">docs#has_union.union</a> only work in <code>Type u</code> not <code>Sort u</code>, so we can't write things like <code>hs ∪ ht</code></p>",
        "id": 233690997,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617901730
    },
    {
        "content": "<p>It's almost like they thought that would be a bad idea</p>",
        "id": 233691049,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617901749
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/stream/113488-general/topic/int-valued.20fincard/near/231148792\">said</a>:</p>\n<blockquote>\n<p>Peter's <a href=\"https://github.com/e45lee/lean-matroids\">matroids repo</a> currently shows how things look with an <code>int</code>-valued <code>size</code>. I think he said he was working on a branch swapping things over to <code>nat</code>, so when that gets pushed there should be plenty of examples to compare.</p>\n</blockquote>\n<p>Coming back to the original topic, it looks like the branch with a <code>nat</code>-valued <code>size</code> is now <a href=\"https://github.com/e45lee/lean-matroids/tree/nat_size\">here</a>.</p>",
        "id": 233691906,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1617902041
    },
    {
        "content": "<p>Yes the branch is there, but currently broken.</p>",
        "id": 233741157,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1617921248
    },
    {
        "content": "<p>The fact that <code>finsum</code> is now in mathlib will mean it needs a bit of a refactor</p>",
        "id": 233741220,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1617921275
    }
]
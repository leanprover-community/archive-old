[
    {
        "content": "<p>What's the best way to structure the statement and proof when I want to prove (1), (2), and (3) are equivalent by showing (1) =&gt; (2) =&gt; (3) =&gt; (1)?</p>",
        "id": 133533223,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536349974
    },
    {
        "content": "<p>Let's say (1) is the definition of something, and (2) and (3) are alternate definitions and I'd like to end up with (1) &lt;=&gt; (2) and (1) &lt;=&gt; (3).<br>\nI could just do something very straightforward (prove (1) =&gt; (2), (2) =&gt; (3), (3) =&gt; (1) as separate top-level lemmas, then conclude (1) &lt;=&gt; (2) and (1) &lt;=&gt; (3) manually) but maybe there is a better idea.</p>",
        "id": 133533668,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536350470
    },
    {
        "content": "<p>it'd be cool if there was a tactic for this</p>",
        "id": 133552573,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1536378433
    },
    {
        "content": "<p>I'm not sure how a tactic could help. The problem is the proof structuring, you don't want all three major parts to be in one big proof</p>",
        "id": 133552679,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536378682
    },
    {
        "content": "<p>It is easy enough to encode the idea of a cycle in a preorder, and deduce equivalence of all parts, which you could prove once and for all and apply as a theorem for your 11-part theorem</p>",
        "id": 133552721,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536378762
    },
    {
        "content": "<p>For the case of 2 or 3 statements, it's easier just to use the lemmas as given</p>",
        "id": 133552726,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536378798
    },
    {
        "content": "<p>I'm not sure I've ever had a case of 4+ statements proven in cyclic order where I actually care about all 4 equivalences</p>",
        "id": 133552773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536378849
    },
    {
        "content": "<p>I was just thinking of a tactic which turns a single goal \"a iff b iff c iff d iff ...\" into a cyclic set of goals \"a=&gt;b\", \"b=&gt;c\", etc. Probably itd be too yuck for anything big?</p>",
        "id": 133553769,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1536380804
    },
    {
        "content": "<p>There are two problems with that: (1) the goals might be big - if they aren't there isn't really a need for this (2) The output is <code>a iff b iff c</code> - what is that? If it is a big conjunction then there is still work to be done to make a usable lemma</p>",
        "id": 133553893,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536381008
    },
    {
        "content": "<p>yep ok sure</p>",
        "id": 133553898,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1536381050
    },
    {
        "content": "<blockquote>\n<p>(2) The output is <code>a iff b iff c</code> - what is that? If it is a big conjunction then there is still work to be done to make a usable lemma</p>\n</blockquote>\n<p>Yeah, this is where I really got stuck</p>",
        "id": 133559919,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536394910
    },
    {
        "content": "<p>Also <code>a iff b iff c</code> is not the same as <code>a iff b and b iff c</code></p>",
        "id": 133561811,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1536399173
    },
    {
        "content": "<p>I guess one out-there idea is to define</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">the_following_are_equivalent</span> <span class=\"o\">(</span><span class=\"n\">ps</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"err\">∈</span> <span class=\"n\">ps</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">↔</span> <span class=\"n\">q</span>\n</pre></div>\n\n\n<p>and then a helper function which extracts for a given pair of indices implication (or bi-implication) between the corresponding Props</p>",
        "id": 133562136,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536399908
    },
    {
        "content": "<p>Mario I do agree that when the list is really long, typically some of the equivalent statements are not included for later use, but rather to elucidate the structure of the argument. Or to say: here is a variant definition of something and you might wonder whether it is equivalent to the official one; it is (and now we never need to talk about it again).</p>",
        "id": 133562550,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536400720
    },
    {
        "content": "<p>I could imagine a presentation like:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">my_interesting_equivalences</span> <span class=\"o\">:</span>\n   <span class=\"n\">the_following_are_equivalent</span>\n    <span class=\"o\">[</span> <span class=\"n\">formula1</span><span class=\"o\">,</span>\n      <span class=\"n\">formula2</span><span class=\"o\">,</span>\n      <span class=\"n\">formula3</span> <span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">circular_implication</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"c\">/-</span><span class=\"cm\"> proof1 -/</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"c\">/-</span><span class=\"cm\"> proof2 -/</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"c\">/-</span><span class=\"cm\"> proof3 -/</span> <span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>and have <code>circular_implication</code> extract the two by two equivalences as separate lemmas: <code>my_interesting_equivalences_1_2</code>, my_interesting_equivalences_1_3<code>, my_interesting_equivalences_2_3</code>.</p>",
        "id": 133586841,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1536450865
    },
    {
        "content": "<p>Or, even better:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">my_interesting_equivalences</span> <span class=\"o\">:</span>\n   <span class=\"n\">the_following_are_equivalent</span>\n    <span class=\"o\">[</span> <span class=\"n\">Reids_defn</span> <span class=\"bp\">::=</span> <span class=\"n\">formula1</span><span class=\"o\">,</span>\n      <span class=\"n\">Simons_defn</span> <span class=\"bp\">::=</span> <span class=\"n\">formula2</span><span class=\"o\">,</span>\n      <span class=\"n\">Marios_defn</span> <span class=\"bp\">::=</span> <span class=\"n\">formula3</span> <span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">circular_implication</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"c\">/-</span><span class=\"cm\"> proof1 -/</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"c\">/-</span><span class=\"cm\"> proof2 -/</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"c\">/-</span><span class=\"cm\"> proof3 -/</span> <span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>and then have <code>my_interesting_equivalences_Reids_defn_iff_Simons_defn</code> etc and make <code>Reids_defn</code>, <code>Simons_defn</code> and <code>Marios_defn</code> into stand alone definitions.</p>",
        "id": 133586909,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1536450997
    },
    {
        "content": "<p>This won't work inside a theorem, you can't make new definitions</p>",
        "id": 133587038,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536451282
    },
    {
        "content": "<p>Also, that's a quadratic number of generated lemmas</p>",
        "id": 133587079,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536451325
    },
    {
        "content": "<blockquote>\n<p>This won't work inside a theorem, you can't make new definitions</p>\n</blockquote>\n<p>I'm fairly sure that you can.</p>",
        "id": 133587184,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1536451587
    },
    {
        "content": "<blockquote>\n<p>Also, that's a quadratic number of generated lemmas</p>\n</blockquote>\n<p>Yes it is but that's what you're trying to prove if you use this approach, no? You could also state only consecutive equivalences but I think that would make the use of those lemmas harder.</p>",
        "id": 133587234,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1536451685
    },
    {
        "content": "<p>I know there's a tactic that can generate iff statements for any inductive type</p>",
        "id": 133587455,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536452211
    },
    {
        "content": "<p>Here's how I think you can do it with just definitions:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">list</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">last&#39;</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">[]</span>     <span class=\"o\">:=</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">::</span><span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">last&#39;</span> <span class=\"n\">b</span> <span class=\"n\">l</span>\n\n<span class=\"n\">def</span> <span class=\"n\">TFAE</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">y</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">TFAE_of_cycle</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">chain</span> <span class=\"o\">(</span><span class=\"bp\">→</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">::</span><span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">last&#39;</span> <span class=\"n\">b</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">TFAE</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">::</span><span class=\"n\">b</span><span class=\"bp\">::</span><span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n\n<span class=\"n\">def</span> <span class=\"n\">TFAE</span><span class=\"bp\">.</span><span class=\"n\">out</span> <span class=\"o\">{</span><span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">TFAE</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n₁</span> <span class=\"n\">n₂</span><span class=\"o\">)</span>\n <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">n₁</span> <span class=\"bp\">&lt;</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"n\">l</span> <span class=\"bp\">.</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">exact_dec_trivial</span><span class=\"o\">)</span>\n <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">n₂</span> <span class=\"bp\">&lt;</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"n\">l</span> <span class=\"bp\">.</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">exact_dec_trivial</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">nth_le</span> <span class=\"n\">l</span> <span class=\"n\">n₁</span> <span class=\"n\">h₁</span> <span class=\"bp\">↔</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">nth_le</span> <span class=\"n\">l</span> <span class=\"n\">n₂</span> <span class=\"n\">h₂</span> <span class=\"o\">:=</span>\n<span class=\"n\">h</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">nth_le_mem</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">nth_le_mem</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">TFAE_test</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TFAE</span> <span class=\"o\">[</span><span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"n\">TFAE_of_cycle</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">trivial</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">TFAE_test</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">out</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">list</span>\n</pre></div>",
        "id": 133587500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536452293
    },
    {
        "content": "<p>A tactic could be used to unfold the definitions involved in <code>TFAE_of_cycle</code></p>",
        "id": 133587508,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536452366
    },
    {
        "content": "<p>then again, <code>simp</code> already does that</p>",
        "id": 133587509,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536452374
    },
    {
        "content": "<p>wow that's so magical</p>",
        "id": 133587554,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536452460
    },
    {
        "content": "<p>Another option besides <code>TFAE.out</code> is to use</p>\n<div class=\"codehilite\"><pre><span></span>theorem TFAE_iff_iff {a l} : TFAE (a::l) ↔ ∀ b ∈ l, a ↔ b := sorry\n</pre></div>\n\n\n<p>as a simp lemma, that way you can simplify a <code>TFAE</code> into a bunch of iffs with the first thing in the list (which is usually what you will want to have as the output theorems)</p>",
        "id": 133587995,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536453430
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110172\">@Assia Mahboubi</span> pointed this thread to me. It is funny because I was considering adding such a feature to mathcomp: <a href=\"https://github.com/math-comp/math-comp/commit/0d41046cff37af7b85da0e771e3d25a4c640edbf\" target=\"_blank\" title=\"https://github.com/math-comp/math-comp/commit/0d41046cff37af7b85da0e771e3d25a4c640edbf\">https://github.com/math-comp/math-comp/commit/0d41046cff37af7b85da0e771e3d25a4c640edbf</a></p>",
        "id": 133745529,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1536685162
    },
    {
        "content": "<p>What is the interface you chose then? It's hard to tell from the link  without knowing Coq</p>",
        "id": 133748935,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1536688530
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> I chose something like: <code>[↔ P0; ...; Pn] := (all_iff P0 [P1; ...; Pn]) := ((P0 → P1) ∧ (P1 → P2) ∧ ... ∧ (Pn → P0))</code> (pseudo syntax)<br>\nAnd the main theorem <code>all_iffLR</code> says roughly that <code>[↔ P0; ...; Pn] → ∀i j, Pi → Pj</code> (pseudo syntax again), and is a coercion to a function, so that a lemma <code>mylemma : [↔ P0; ...; Pn]</code> can be applied to natural numbers to give <code>mylemma i j</code>, a proof of <code>Pi → Pj</code>.</p>",
        "id": 133792495,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1536751389
    },
    {
        "content": "<p>That looks like a really nice way to attack this.</p>",
        "id": 133792868,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536751856
    },
    {
        "content": "<p>As a mathematician I wonder if we could use tactics to allow for even more general ways of proving an <code>all_iff</code> instead of only cycles.</p>",
        "id": 133792930,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536751956
    },
    {
        "content": "<p>One of the improvements I have in mind is to provide a graph. And have the computational part of the system check it is strongly connected, then ask to prove only the edges. (so no deep tactic involved, just reflexion)</p>",
        "id": 133792958,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1536752033
    },
    {
        "content": "<p>Right.</p>",
        "id": 133793003,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536752050
    },
    {
        "content": "<p>But it would allow for more convenience.</p>",
        "id": 133793006,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536752060
    },
    {
        "content": "<p>Yes</p>",
        "id": 133793017,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1536752092
    },
    {
        "content": "<p>The interactive version would first ask the user to supply a graph. Then the system does the connectedness check (or asks the user for a proof). And then the tactic goes on to supply you all the edges 1-by-1</p>",
        "id": 133793019,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536752102
    },
    {
        "content": "<p>I mean, check this out: <a href=\"https://stacks.math.columbia.edu/tag/04GG\" target=\"_blank\" title=\"https://stacks.math.columbia.edu/tag/04GG\">https://stacks.math.columbia.edu/tag/04GG</a></p>",
        "id": 133793042,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536752134
    },
    {
        "content": "<p>Too bad we don't have a lot about graphs in Lean.</p>",
        "id": 133793116,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536752268
    },
    {
        "content": "<p>I would start my proof by applying the lemma <code>all_iff_from [(2,1);(5,3)...]</code>(implicit arguments + unification would do the job of checking the connectedness of the graph, and a split would ask for all the implications, that is why I see no need for a tactic...</p>",
        "id": 133793117,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1536752273
    },
    {
        "content": "<p>And since we have graphs in coq with math-comp, I am really eager to try :)</p>",
        "id": 133793166,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1536752304
    },
    {
        "content": "<p>But do you have henselian local rings?</p>",
        "id": 133793173,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536752321
    },
    {
        "content": "<p>Just kidding...</p>",
        "id": 133793175,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536752328
    },
    {
        "content": "<p>I would love to have this kind of stuff in Lean!</p>",
        "id": 133793184,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536752358
    },
    {
        "content": "<p>How hard is the connectedness check? I guess that shouldn't be too hard, right?</p>",
        "id": 133793189,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536752393
    },
    {
        "content": "<p>it is just a dfs</p>",
        "id": 133793241,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1536752425
    },
    {
        "content": "<p>/me walks over to his copy of TAOCP</p>",
        "id": 133793242,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536752425
    },
    {
        "content": "<p>Right, and you need to generate a proof along the way.</p>",
        "id": 133793250,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536752439
    },
    {
        "content": "<p>(I've never really written tactics before... so I'm just thinking out loud.)</p>",
        "id": 133793266,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536752466
    },
    {
        "content": "<p>Hmmm... but most of this isn't even <code>meta</code>.</p>",
        "id": 133793352,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536752565
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110193\">@Cyril Cohen</span> Two questions: (1) Do you have any experience in Lean? (2) Where can we find your coq implementation?</p>",
        "id": 133793369,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536752618
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> (1) I only saw <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> and <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> in action, I have no more experience than that. (2) my current coq implementation does not support graphs yet, only what I described in the message you replied to and it is here: <a href=\"https://github.com/math-comp/math-comp/commit/0d41046cff37af7b85da0e771e3d25a4c640edbf\" target=\"_blank\" title=\"https://github.com/math-comp/math-comp/commit/0d41046cff37af7b85da0e771e3d25a4c640edbf\">https://github.com/math-comp/math-comp/commit/0d41046cff37af7b85da0e771e3d25a4c640edbf</a> (waiting patiently to be cleaned and merged since august)</p>",
        "id": 133793540,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1536752830
    },
    {
        "content": "<p>Ok, understood <span class=\"emoji emoji-1f44d\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 133793720,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536753037
    },
    {
        "content": "<p>Nice! So the current implementation in Coq is about using a chain of equivalences, not proving it. But clearly both ways are useful. I'm sure we'll soon have this in Lean</p>",
        "id": 133793964,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1536753356
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> it's also about proving it, but only from circular implications <code>P0 -&gt; ... -&gt; Pn -&gt; P0</code> (no arbitrary strongly connected graph)</p>",
        "id": 133794023,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1536753447
    },
    {
        "content": "<p>ok, nice</p>",
        "id": 133794539,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1536754213
    },
    {
        "content": "<p>I guess it already covers most use cases, you only need to list the conditions in the order you intend to prove the chain of implications, and then you can use any implication</p>",
        "id": 133794566,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1536754267
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">vector</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">pattern</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pr</span> <span class=\"o\">:</span> <span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">pr</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">all_iff</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">vector</span> <span class=\"kt\">Prop</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"n\">Ps</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span>     <span class=\"n\">Ps</span> <span class=\"o\">:=</span> <span class=\"n\">Ps</span><span class=\"bp\">.</span><span class=\"n\">head</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">Ps</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Ps</span><span class=\"bp\">.</span><span class=\"n\">head</span> <span class=\"bp\">→</span> <span class=\"n\">Ps</span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">all_iff</span> <span class=\"n\">Ps</span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"o\">)</span>\n\n<span class=\"n\">local</span> <span class=\"kn\">notation</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"bp\">↔`</span> <span class=\"n\">l</span><span class=\"o\">:(</span><span class=\"n\">foldr</span> <span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">h</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"bp\">`</span><span class=\"o\">]</span><span class=\"bp\">`</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">all_iff</span> <span class=\"o\">(</span><span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">l</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"bp\">↔</span> <span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">false</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"n\">def</span> <span class=\"n\">all_iff_LR</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Ps</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"kt\">Prop</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">all_iff</span> <span class=\"n\">Ps</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">Ps</span><span class=\"bp\">.</span><span class=\"n\">nth</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">Ps</span><span class=\"bp\">.</span><span class=\"n\">nth</span> <span class=\"n\">j</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 133794674,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536754407
    },
    {
        "content": "<p>Oops, there is a bug. I'm not closing the cycle.</p>",
        "id": 133794856,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536754572
    },
    {
        "content": "<p>Somewhere on Twitch there is now a video of me having proved 1 =&gt; 2 and 2 =&gt; 3 and 3 =&gt; 1 and then taking several minutes to figure out how to prove 2 &lt;=&gt; 1 and 3 &lt;=&gt; 1 and then later being unable to remember whether I had proved 2 &lt;=&gt; 1 or 1 &lt;=&gt; 2. So I guess there is some real non-zero value to this.</p>",
        "id": 133795209,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536755056
    },
    {
        "content": "<p>This is better:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">interactive</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">vector</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">pattern</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pr</span> <span class=\"o\">:</span> <span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">pr</span><span class=\"bp\">⟩</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">reducible</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">all_iff&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"kt\">Prop</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">P₀</span> <span class=\"o\">[]</span>               <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"n\">P₀</span> <span class=\"o\">(</span><span class=\"n\">P₁</span> <span class=\"bp\">::</span> <span class=\"o\">[])</span>       <span class=\"o\">:=</span> <span class=\"n\">P₁</span> <span class=\"bp\">→</span> <span class=\"n\">P₀</span>\n<span class=\"bp\">|</span> <span class=\"n\">P₀</span> <span class=\"o\">(</span><span class=\"n\">P₁</span> <span class=\"bp\">::</span> <span class=\"n\">P₂</span> <span class=\"bp\">::</span> <span class=\"n\">Ps</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">P₁</span> <span class=\"bp\">→</span> <span class=\"n\">P₂</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">all_iff&#39;</span> <span class=\"n\">P₀</span> <span class=\"o\">(</span><span class=\"n\">P₂</span> <span class=\"bp\">::</span> <span class=\"n\">Ps</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">all_iff</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"kt\">Prop</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"bp\">⟨</span><span class=\"o\">[],</span>             <span class=\"n\">h</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"bp\">⟨</span><span class=\"n\">P</span> <span class=\"bp\">::</span> <span class=\"o\">[],</span>        <span class=\"n\">h</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"bp\">⟨</span><span class=\"n\">P₀</span> <span class=\"bp\">::</span> <span class=\"n\">P₁</span> <span class=\"bp\">::</span> <span class=\"n\">Ps</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">P₀</span> <span class=\"bp\">→</span> <span class=\"n\">P₁</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">all_iff&#39;</span> <span class=\"n\">P₀</span> <span class=\"o\">(</span><span class=\"n\">P₁</span> <span class=\"bp\">::</span> <span class=\"n\">Ps</span><span class=\"o\">)</span>\n\n<span class=\"n\">local</span> <span class=\"kn\">notation</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"bp\">↔`</span> <span class=\"n\">l</span><span class=\"o\">:(</span><span class=\"n\">foldr</span> <span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">h</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"bp\">`</span><span class=\"o\">]</span><span class=\"bp\">`</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">all_iff</span> <span class=\"o\">(</span><span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">l</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"bp\">↔</span> <span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">tauto</span><span class=\"o\">,</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">all_iff&#39;</span><span class=\"o\">],</span> <span class=\"n\">tauto</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 133796095,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536756141
    },
    {
        "content": "<p>I would like to not have the <code>dsimp [all_iff']</code> in the example. I marked the definition <code>reducible</code>, but that didn't help.</p>",
        "id": 133796112,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536756175
    },
    {
        "content": "<p>I don't know whether this matters here, but when I was playing around with this stuff I found you can also do</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">local</span> <span class=\"kn\">notation</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"bp\">↔`</span> <span class=\"n\">p0</span> <span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span> <span class=\"n\">l</span><span class=\"o\">:(</span><span class=\"n\">foldr</span> <span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">h</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"bp\">`</span><span class=\"o\">]</span><span class=\"bp\">`</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">all_iff</span> <span class=\"o\">(</span><span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">p0</span> <span class=\"bp\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 133796235,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536756315
    },
    {
        "content": "<p>which lets you guarantee that the list is nonempty</p>",
        "id": 133796240,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536756321
    },
    {
        "content": "<p>I'm not sure if we want that guarantee... for interaction sure. But maybe this code will also be used in automation or something. And then it would be nice if <code>[]</code> is not a problem.</p>",
        "id": 133796412,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536756513
    },
    {
        "content": "<p>If you <code>dsimp only [all_iff, all_iff', vector.mk]</code> first then you get a conjunction of the 3 iffs</p>",
        "id": 133796518,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536756647
    },
    {
        "content": "<p>I thought it might be more likely that allowing <code>[]</code> is a problem for automation than that disallowing it is a problem. But I'm not sure either, just thought I would mention the possibility.</p>",
        "id": 133796551,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536756711
    },
    {
        "content": "<p>I think a very simple tactic which turns an <code>all_iff</code> goal with list of length N into N subgoals (or possibly a conjunction of N implications) will probably be useful. Otherwise, I think it will be hard to avoid making the intermediate goals confusing.</p>",
        "id": 133796744,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536756935
    },
    {
        "content": "<p>True, something like that is necessary.</p>",
        "id": 133796811,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536757018
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110193\">@Cyril Cohen</span> I am very bad at reading coq code, apparently...</p>",
        "id": 133797157,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536757456
    },
    {
        "content": "<p>I'm trying to prove <code>all_iff_LR</code> in Lean. I'm exploding into different cases. Is there a good strategy to prove this by induction?</p>",
        "id": 133797191,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536757513
    },
    {
        "content": "<p>Do you case on <code>i &lt; j</code> or something similar?</p>",
        "id": 133797194,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536757523
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  I am using a lemma saying (roughly) that a function <code>f : nat -&gt; T</code> respects the order (<code>&lt;</code> for nat, and an arbitrary order on <code>T</code> (<code>-&gt;</code> on <code>Prop</code> in our case)) if one can prove that <code>f i  &lt; f (i + 1)</code> (or <code>f i -&gt; f (i + 1)</code> in our case). Only then, I do an induction.</p>",
        "id": 133797383,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1536757747
    },
    {
        "content": "<p>Hmm, I see. That seems smart.</p>",
        "id": 133797460,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536757813
    },
    {
        "content": "<p>So now I need to find that lemma in mathlib. <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> Do you know the function that Cyril is talking about?</p>",
        "id": 133797517,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536757901
    },
    {
        "content": "<p>is it even in mathlib?</p>",
        "id": 133797578,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536757933
    },
    {
        "content": "<p>I'd just use induction to prove it</p>",
        "id": 133797582,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536757939
    },
    {
        "content": "<p>Dunno.</p>",
        "id": 133797584,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536757940
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">foobar</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">monotone</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">le_succ</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">monotone</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">le_trans</span> <span class=\"n\">ih</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n  <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 133798133,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536758560
    },
    {
        "content": "<p>It still needs a name and golfing (-;</p>",
        "id": 133798146,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536758577
    },
    {
        "content": "<p>Ok, I'm making slow progress. I'll try to post something later tonight.</p>",
        "id": 133802962,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536763076
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110524\">@Scott Morrison</span> <span class=\"user-mention\" data-user-id=\"110111\">@Keeley Hoek</span>  I think I found a missing feature in <code>tidy</code>. It doesn't split <code>\\iff</code> in the assumptions into two implications. If it did, I guess it could have solved more of my goals.</p>",
        "id": 133803540,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536763585
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Could you give me an example? In the (admittedly baby) example</p>\n<div class=\"codehilite\"><pre><span></span>constants a b : Prop\n\ndef lol : iff a b := begin\n  tidy,\n  admit\nend\n</pre></div>\n\n\n<p><code>tidy</code> does do what you're saying, I think.</p>",
        "id": 133804789,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1536764868
    },
    {
        "content": "<p>Or are you talking about <code>tidy</code> not converting <code>iff</code> hypotheses into a pair of <code>implies</code> hypotheses? Maybe it should do that...</p>",
        "id": 133804897,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1536764948
    },
    {
        "content": "<p>For the latter, give <a href=\"https://github.com/leanprover/mathlib/pull/344\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/pull/344\">https://github.com/leanprover/mathlib/pull/344</a> (i.e. <a href=\"https://github.com/leanprover-community/mathlib/tree/auto-cases-iff\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/tree/auto-cases-iff\">https://github.com/leanprover-community/mathlib/tree/auto-cases-iff</a>) a try.</p>",
        "id": 133805759,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1536765724
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110111\">@Keeley Hoek</span> Cool! That kills of another goal (-;</p>",
        "id": 133811896,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536771204
    },
    {
        "content": "<p>What was wrong with the sketch I gave earlier for <code>TFAE_of_cycle</code>? It should be isomorphic to cyril's definition</p>",
        "id": 133812980,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536772487
    },
    {
        "content": "<p>that <code>list.chain</code> syntax is sick Mario</p>",
        "id": 133813298,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1536772868
    },
    {
        "content": "<p>Here's the whole proof:</p>\n<div class=\"codehilite\"><pre><span></span>namespace list\n\n@[simp] def last&#39; {α} : α → list α → α\n| a []     := a\n| a (b::l) := last&#39; b l\n\ntheorem last&#39;_mem {α} : ∀ a l, @last&#39; α a l ∈ a :: l\n| a []     := or.inl rfl\n| a (b::l) := or.inr (last&#39;_mem b l)\n\ndef TFAE (l : list Prop) : Prop := ∀ x ∈ l, ∀ y ∈ l, x ↔ y\n\ntheorem TFAE_nil : TFAE [] := forall_mem_nil _\ntheorem TFAE_singleton (p) : TFAE [p] := by simp [TFAE]\n\ntheorem TFAE_cons_of_mem {a b} {l : list Prop} (h : b ∈ l) :\n  TFAE (a::l) ↔ (a ↔ b) ∧ TFAE l :=\n⟨λ H, ⟨H a (by simp) b (or.inr h), λ p hp q hq, H _ (or.inr hp) _ (or.inr hq)⟩,\n begin\n   rintro ⟨ab, H⟩ p (rfl | hp) q (rfl | hq),\n   { refl },\n   { exact ab.trans (H _ h _ hq) },\n   { exact (ab.trans (H _ h _ hp)).symm },\n   { exact H _ hp _ hq }\n end⟩\n\ntheorem TFAE_cons_cons {a b} {l : list Prop} : TFAE (a::b::l) ↔ (a ↔ b) ∧ TFAE (b::l) :=\nTFAE_cons_of_mem (or.inl rfl)\n\ntheorem TFAE_of_cycle {a b} {l : list Prop} :\n  list.chain (→) a (b::l) → (last&#39; b l → a) → TFAE (a::b::l) :=\nbegin\n  induction l with c l IH generalizing a b; simp [TFAE_cons_cons, TFAE_singleton] at *,\n  { exact iff.intro },\n  intros ab bc ch la,\n  have := IH bc ch (ab ∘ la),\n  exact ⟨⟨ab, la ∘ (this.2 c (or.inl rfl) _ (last&#39;_mem _ _)).1 ∘ bc⟩, this⟩\nend\n\ntheorem TFAE.out {l} (h : TFAE l) (n₁ n₂)\n (h₁ : n₁ &lt; list.length l . tactic.exact_dec_trivial)\n (h₂ : n₂ &lt; list.length l . tactic.exact_dec_trivial) :\n  list.nth_le l n₁ h₁ ↔ list.nth_le l n₂ h₂ :=\nh _ (list.nth_le_mem _ _ _) _ (list.nth_le_mem _ _ _)\n\ntheorem TFAE_test (x y : ℕ) : TFAE [true, x = x, y = y] :=\nTFAE_of_cycle (by simp) (λ _, trivial)\n\nexample (x y : ℕ) : x = x ↔ y = y := (TFAE_test x y).out 1 2\n\nend list\n</pre></div>",
        "id": 133814801,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536774377
    },
    {
        "content": "<p>There is a theorem that says that you can put a <code>list.chain</code> together over a transitive relation, but I had to prove the rest by induction anyway so it wasn't necessary</p>",
        "id": 133814995,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536774578
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I think the only thing that was wrong with it was that I didn't understand what you were doing...</p>",
        "id": 133815251,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536774823
    },
    {
        "content": "<p><code>list.chain</code> says that you have forward implications along the list, <code>last l -&gt; a</code> gives the final backward arrow</p>",
        "id": 133815331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536774882
    },
    {
        "content": "<p>and they are both defined naturally by recursion making the proofs easy</p>",
        "id": 133815344,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536774906
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Ok, so I was almost done with a slightly clunkier implementation. <span class=\"emoji emoji-1f606\" title=\"lol\">:lol:</span></p>",
        "id": 133815437,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536774993
    },
    {
        "content": "<p>Would you mind pushing your stuff to a <code>tfae</code> branch on community?</p>",
        "id": 133815453,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536775017
    },
    {
        "content": "<p>I think we should put everything into a <code>tfae</code> namespace.</p>",
        "id": 133815472,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536775060
    },
    {
        "content": "<p>I would just put it all in <code>list.basic</code></p>",
        "id": 133815506,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536775082
    },
    {
        "content": "<p>and in the <code>list</code> namespace, as you can see</p>",
        "id": 133815535,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536775101
    },
    {
        "content": "<p>Ok, fine with me.</p>",
        "id": 133815542,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536775110
    },
    {
        "content": "<p>Do you want to capitalise TFAE?</p>",
        "id": 133815556,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536775129
    },
    {
        "content": "<p>dunno, seemed nicer that way</p>",
        "id": 133815569,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536775143
    },
    {
        "content": "<p><code>tfae</code> could be misread?</p>",
        "id": 133815582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536775154
    },
    {
        "content": "<p>Maybe. <code>TFAE</code> feels like shouting.</p>",
        "id": 133815591,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536775175
    },
    {
        "content": "<p>I wouldn't mind having <code>tfae</code>.</p>",
        "id": 133815594,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536775188
    },
    {
        "content": "<p>it's always the way I see it on the blackboard</p>",
        "id": 133815600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536775190
    },
    {
        "content": "<p>That is true. But on the blackboard I also see <code>Lemma</code> and <code>Thm</code>...</p>",
        "id": 133815668,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536775216
    },
    {
        "content": "<p>I would also not have any notation. for me <code>tfae [p, q, r]</code> is sufficient</p>",
        "id": 133815706,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536775276
    },
    {
        "content": "<p><code>[&lt;-&gt; p, q, r]</code> doesn't seem to buy much</p>",
        "id": 133815719,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536775300
    },
    {
        "content": "<p>Right, I also came to that conclusion</p>",
        "id": 133815762,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536775325
    },
    {
        "content": "<p>It is even easier to read.</p>",
        "id": 133815778,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536775341
    },
    {
        "content": "<p>(none of this is to cast aspersions on Cyril's work; the style and design decisions are different there)</p>",
        "id": 133815782,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536775345
    },
    {
        "content": "<p>If you push your stuff, I would like to see if I can do anything with <code>tfae_of_graph</code>.</p>",
        "id": 133815809,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536775386
    },
    {
        "content": "<p>Some how you need to show that the transitive closure of the relation that is your graph is everything. Would an <code>auto_param</code> be able to do that?</p>",
        "id": 133815842,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536775438
    },
    {
        "content": "<p>you are talking about Cyril's extension? I wouldn't want to try that without using a tactic to guide the whole process</p>",
        "id": 133816149,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536775754
    },
    {
        "content": "<p>Why not?</p>",
        "id": 133816223,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536775819
    },
    {
        "content": "<p>because the number of goals is very nonuniform</p>",
        "id": 133816232,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536775834
    },
    {
        "content": "<p>the types are too complicated to get much help from lean</p>",
        "id": 133816246,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536775854
    },
    {
        "content": "<p>again, this reflects a difference in design from Coq. It's easier to do strongly connected checking in the kernel in Coq</p>",
        "id": 133816275,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536775909
    },
    {
        "content": "<p>in lean we would do it with a tactic</p>",
        "id": 133816318,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536775926
    },
    {
        "content": "<p>Pseudo-code:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">tfae_of_graph</span> <span class=\"o\">(</span><span class=\"n\">Ps</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"n\">x</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">proof_that_G_generates_everything</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">proofs</span> <span class=\"o\">:</span> <span class=\"err\">\\</span><span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">\\</span><span class=\"k\">in</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">Ps</span> <span class=\"n\">i</span> <span class=\"err\">\\</span><span class=\"n\">implies</span> <span class=\"n\">Ps</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tfae</span> <span class=\"n\">Ps</span>\n</pre></div>",
        "id": 133816459,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536776106
    },
    {
        "content": "<p>Ok, I agree that maybe the Lean way is to use tactics</p>",
        "id": 133816476,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536776134
    },
    {
        "content": "<p>You would have to supply <code>proofs</code> manually which is not nice</p>",
        "id": 133816547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536776176
    },
    {
        "content": "<p>I don't know anything about <code>auto_param</code>s but I would definitely want <code>H</code> to be automated by some tactic.</p>",
        "id": 133816551,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536776188
    },
    {
        "content": "<p>Right, so <code>proofs</code> better be a list of <code>mvar</code>s, is that what you mean?</p>",
        "id": 133816571,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536776227
    },
    {
        "content": "<p>this would not be interactive because of the proofs parameter</p>",
        "id": 133816572,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1536776228
    },
    {
        "content": "<p>Well, if you <code>apply</code> it, you would then be left with a goal that asks for <code>proofs</code>.</p>",
        "id": 133816600,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536776260
    },
    {
        "content": "<p>Here's a conjecture: Given any SC graph on 1...n, there is a way to connect 1-2, 2-3, ..., n-1 by disjoint paths in the graph</p>",
        "id": 133816605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536776265
    },
    {
        "content": "<p>And you would want to split that into a bunch of goals.</p>",
        "id": 133816612,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536776273
    },
    {
        "content": "<p>What is SC?</p>",
        "id": 133816675,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536776306
    },
    {
        "content": "<p>strongly connected</p>",
        "id": 133816691,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536776323
    },
    {
        "content": "<p>I see.</p>",
        "id": 133816707,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536776343
    },
    {
        "content": "<p>if true, the generalization is always redundant</p>",
        "id": 133816728,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536776371
    },
    {
        "content": "<p>if you supply 1&lt;-&gt;2 and 2&lt;-&gt;3 then you have four proofs, and you could have just composed the proofs 3-&gt;2 and 2-&gt;1 to get a result in the form for <code>tfae_of_cycle</code></p>",
        "id": 133816808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536776428
    },
    {
        "content": "<p>Here is a graph: <code>1 -&gt; 3 -&gt; 2 -&gt; 1</code></p>",
        "id": 133816824,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536776443
    },
    {
        "content": "<p>of course</p>",
        "id": 133816848,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536776484
    },
    {
        "content": "<p>Did I misunderstand your conjecture?</p>",
        "id": 133816862,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536776498
    },
    {
        "content": "<p>so I guess we need a theorem about permuting the graph</p>",
        "id": 133816867,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536776504
    },
    {
        "content": "<p>no, that's a counterexample</p>",
        "id": 133816870,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536776508
    },
    {
        "content": "<p>I'dd just do a <code>meta</code> dfs</p>",
        "id": 133816918,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536776534
    },
    {
        "content": "<p>new conjecture: there is a way to permute the vertices so that the first conjecture holds</p>",
        "id": 133834471,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536776550
    },
    {
        "content": "<p>That is trivial</p>",
        "id": 133834478,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536776562
    },
    {
        "content": "<p>is it?</p>",
        "id": 133834483,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536776570
    },
    {
        "content": "<p>Hmm, maybe not.</p>",
        "id": 133834484,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536776573
    },
    {
        "content": "<p>But, why do you not want to reuse edges?</p>",
        "id": 133834580,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536776684
    },
    {
        "content": "<p>because that way you can achieve the same with a straight line proof where you inline the relevant parts in each subproof</p>",
        "id": 133834619,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536776731
    },
    {
        "content": "<p>i.e. the proof 3-&gt;2 only appears as part of the proof 3-&gt;1 in my example</p>",
        "id": 133834636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536776757
    },
    {
        "content": "<p>so it doesn't need to be stored and reused</p>",
        "id": 133834680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536776769
    },
    {
        "content": "<p>Here is another graph: <code>1 -&gt; 2 -&gt; 3 -&gt; 1;   2 -&gt; 4 -&gt; 1;   2 -&gt; 5 -&gt; 1</code></p>",
        "id": 133834686,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536776778
    },
    {
        "content": "<p>foiled again</p>",
        "id": 133834726,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536776859
    },
    {
        "content": "<p>Hmm, you don't even need vertex <code>5</code>.</p>",
        "id": 133834833,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536776961
    },
    {
        "content": "<p>okay so we definitely need a tactic to manage this kind of structure</p>",
        "id": 133834839,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536776973
    },
    {
        "content": "<p>So the tactic takes a graph as input, and then proves that it is SC, and generates a list of goals, right?</p>",
        "id": 133834952,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536777050
    },
    {
        "content": "<p>yes</p>",
        "id": 133834966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536777065
    },
    {
        "content": "<p>it might be worth considering the aforementioned <a href=\"https://stacks.math.columbia.edu/tag/04GG\" target=\"_blank\" title=\"https://stacks.math.columbia.edu/tag/04GG\">https://stacks.math.columbia.edu/tag/04GG</a> when imagining what the UI might look like</p>",
        "id": 133834999,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536777110
    },
    {
        "content": "<p>Do we really want the tactic to decide on a list of implications to prove? Sometimes there will be several solutions, some easier than others</p>",
        "id": 133835001,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1536777112
    },
    {
        "content": "<p>No, you provide a list of edges.</p>",
        "id": 133835061,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536777131
    },
    {
        "content": "<p>You get to prove those. And the tactic shows that this is enough.</p>",
        "id": 133835070,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536777150
    },
    {
        "content": "<p>ok, I prefer that</p>",
        "id": 133835078,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1536777165
    },
    {
        "content": "<p>for example, listing all the edges and then, separately, all the proofs might be less nice than being able to interleave them</p>",
        "id": 133835080,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536777168
    },
    {
        "content": "<p>My suggestion: suppose the goal is <code>tfae [p1, p2, p3, p4, p5]</code>, then you can call <code>tfae [1 -&gt; 2, 2 -&gt; 3, 3 -&gt; 1, 2 -&gt; 4, 4 -&gt; 1, 1 &lt;-&gt; 5]</code> and get six goals like <code>|- p1 -&gt; p2</code> and <code>|- p1 &lt;-&gt; p5</code></p>",
        "id": 133835110,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536777207
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>  Hmmm... but then it feels like you'll need a separate mode, like <code>conv</code> and <code>calc</code>.</p>",
        "id": 133835123,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536777236
    },
    {
        "content": "<p>ooh, should it be zero-based indexing?</p>",
        "id": 133835191,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536777273
    },
    {
        "content": "<p>In principal that is fine, but in practice we see that <code>conv</code> is limited by the fact that not all tactics that we'dd like to be there actually work.</p>",
        "id": 133835197,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536777279
    },
    {
        "content": "<p>I guess <code>0</code>-based is easier to implement. But I don't know if it is user friendly.</p>",
        "id": 133835221,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536777304
    },
    {
        "content": "<p>1 based is probably more user friendly, but I'm sure it will surprise someone either way</p>",
        "id": 133835257,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536777342
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Do you think Reid's idea can be implemented in usual tactic mode?</p>",
        "id": 133835270,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536777362
    },
    {
        "content": "<p>maybe rather than a plain list in tfae we should use an association list indexed by<br>\n<code>inductive roman_number | i | ii | iii | iv | ...</code></p>",
        "id": 133835323,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536777382
    },
    {
        "content": "<p>and how long does that <code>...</code> go? :P</p>",
        "id": 133835342,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536777408
    },
    {
        "content": "<p>at least till <code>xiii</code></p>",
        "id": 133835351,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536777420
    },
    {
        "content": "<p>anyway it's not an actual type, it's just an input format</p>",
        "id": 133835362,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536777430
    },
    {
        "content": "<p><code>1 -&gt; 2</code> isn't well typed</p>",
        "id": 133835398,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536777462
    },
    {
        "content": "<p>What I really mean though is if you actually had 13 things to prove equivalent, you wouldn't really want to have to count them whether you use 0-based or 1-based indexing</p>",
        "id": 133835403,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536777466
    },
    {
        "content": "<p>neither is <code>i -&gt; ii</code></p>",
        "id": 133835410,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536777470
    },
    {
        "content": "<p>I don't see an alternative</p>",
        "id": 133835478,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536777503
    },
    {
        "content": "<p>lean can try to give you help in filling out the tactic arguments, but that's it</p>",
        "id": 133835493,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536777528
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> Do you have an idea for an \"interleaving UI\"?</p>",
        "id": 133835504,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536777542
    },
    {
        "content": "<p>syntax, I mean</p>",
        "id": 133835523,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536777552
    },
    {
        "content": "<p>What would you like to write?</p>",
        "id": 133835532,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536777564
    },
    {
        "content": "<p>it sounds like what <code>case</code> does, but in that case you already know what the goals are</p>",
        "id": 133835541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536777581
    },
    {
        "content": "<p>something like <code>case</code> in terms of syntax, yeah</p>",
        "id": 133835603,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536777610
    },
    {
        "content": "<p><code>have : i -&gt; ii := bla</code></p>",
        "id": 133835610,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536777615
    },
    {
        "content": "<p><code>tfae</code> could take an <code>itactic</code> argument, I'm not sure if the parsing will work but then you could have one huge tactic with subblocks like:</p>\n<div class=\"codehilite\"><pre><span></span>tfae:\n1 -&gt; 2 {\n  ...\n}\n2 -&gt; 1 {\n  ...\n},\n</pre></div>",
        "id": 133835657,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536777681
    },
    {
        "content": "<p>And then, somehow Lean should keep track of them. And once you think you are done, you type <code>tfae_done</code>, and it checks that your graph is SC.</p>",
        "id": 133835674,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536777704
    },
    {
        "content": "<p>in my example it's just one tactic invocation (note lack of comma)</p>",
        "id": 133835723,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536777730
    },
    {
        "content": "<p>I see. And inside the <code>{ ... }</code> you would be in regular tactic mode?</p>",
        "id": 133835740,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536777756
    },
    {
        "content": "<p>yes</p>",
        "id": 133835743,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536777759
    },
    {
        "content": "<p>Then I think that syntax is really cool!</p>",
        "id": 133835752,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536777770
    },
    {
        "content": "<p>I don't know if I can make it work though</p>",
        "id": 133835762,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536777780
    },
    {
        "content": "<p><code>itactic</code> isn't a parser</p>",
        "id": 133835777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536777789
    },
    {
        "content": "<p>I know that I can't</p>",
        "id": 133835780,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536777791
    },
    {
        "content": "<p>I think I would call the tactic <code>tfae_cases</code></p>",
        "id": 133835811,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536777834
    },
    {
        "content": "<p>I would stick to my original proposal though, these syntaxes are crazy</p>",
        "id": 133835929,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536777958
    },
    {
        "content": "<p>you can put the numbers in comments if you forgot which is which</p>",
        "id": 133835982,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536777975
    },
    {
        "content": "<p>Ok, too bad.</p>",
        "id": 133835987,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536777979
    },
    {
        "content": "<p>But, if you think it is really hard to do, then I won't even try thinking about it (-;</p>",
        "id": 133836020,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536778024
    },
    {
        "content": "<p>also you could have <code>tfae?</code> which would just print out a numbered list of the elements of the <code>tfae</code> for referral</p>",
        "id": 133836027,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536778028
    },
    {
        "content": "<p>It should be a hole command (-;</p>",
        "id": 133836058,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536778081
    },
    {
        "content": "<p>And fill out those comments!</p>",
        "id": 133836111,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536778106
    },
    {
        "content": "<p>I want more \"implicit\" hole commands (without the <code>{!!}</code> markers), but alas</p>",
        "id": 133836117,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536778114
    },
    {
        "content": "<p>Mario, could we have <code>have : tfae_case i ii := ...</code></p>",
        "id": 133836226,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536778211
    },
    {
        "content": "<p>and then a finishing tactic <code>tfae_done</code></p>",
        "id": 133836245,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536778228
    },
    {
        "content": "<p>Oh, <code>have</code> is a better analogy. I would certainly be happy with <code>have_tfae 1 -&gt; 3, blah, have_tfae ..., ..., tfae_finish</code></p>",
        "id": 133836275,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536778256
    },
    {
        "content": "<p>sorry, that's not well typed. The best you can do is <code>have : p1 -&gt; p2</code> and have <code>tfae_done</code> figure it out</p>",
        "id": 133836289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536778271
    },
    {
        "content": "<p>But it's just notation, like before...</p>",
        "id": 133836317,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536778309
    },
    {
        "content": "<p>Ok, my example won't work.</p>",
        "id": 133836325,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536778321
    },
    {
        "content": "<p>But Reid's could, not?</p>",
        "id": 133836366,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536778327
    },
    {
        "content": "<p>It would need to refer to the goal</p>",
        "id": 133836369,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536778334
    },
    {
        "content": "<p>Yours I mean</p>",
        "id": 133836372,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536778339
    },
    {
        "content": "<p>Actually <code>have_tfae 1 -&gt; 3</code> might make sense: if the goal is <code>tfae [p1, ..., p5]</code> then it is just the same as <code>have : p1 -&gt; p3</code></p>",
        "id": 133836377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536778350
    },
    {
        "content": "<p>Exactly. (And can we make it <code>tfae_have</code>?)</p>",
        "id": 133836402,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536778370
    },
    {
        "content": "<p>It should also support &lt;-&gt; btw</p>",
        "id": 133836445,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536778436
    },
    {
        "content": "<p>So the <code>tfae_have</code> should generate a new goal, and record an edge in some graph. And then <code>tfae_finish</code> checks that the graph is SC.</p>",
        "id": 133836448,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536778439
    },
    {
        "content": "<p>naturally</p>",
        "id": 133836450,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536778441
    },
    {
        "content": "<p>I really like where this is going!</p>",
        "id": 133836501,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536778454
    },
    {
        "content": "<p><code>tfae_have</code> doesn't need to do anything</p>",
        "id": 133836507,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536778464
    },
    {
        "content": "<p><code>tfae_finish</code> could almost just be <code>solve_by_elim</code> it seems</p>",
        "id": 133836510,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536778467
    },
    {
        "content": "<p>A smart <code>tfae_finish</code> could suggest a list of edges that still needs to be done...</p>",
        "id": 133836546,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536778510
    },
    {
        "content": "<p><code>tfae_finish</code> has to apply <code>tfae_of_cycle</code>, reduce the subproofs to implications of the given stuff, and then use the existing implications</p>",
        "id": 133836571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536778543
    },
    {
        "content": "<p>and produce any unproven parts as subgoals</p>",
        "id": 133836620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536778586
    },
    {
        "content": "<p>that way you can use <code>tfae</code> either forwards or backwards</p>",
        "id": 133836630,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536778610
    },
    {
        "content": "<p>What would those unproven parts look like?</p>",
        "id": 133836644,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536778631
    },
    {
        "content": "<p>Just unproven edges in the default cycle?</p>",
        "id": 133836660,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536778654
    },
    {
        "content": "<p>yes</p>",
        "id": 133836666,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536778658
    },
    {
        "content": "<p>Ok, so by default <code>tfae_finish</code> generates <code>n</code> goals.</p>",
        "id": 133836684,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536778678
    },
    {
        "content": "<p>(I would just call this one <code>tfae</code> btw)</p>",
        "id": 133836737,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536778704
    },
    {
        "content": "<p>If you want to use it both forwards and backward, that makes sense.</p>",
        "id": 133836752,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536778726
    },
    {
        "content": "<p>Semantically I don't like <code>tfae</code>, but short names are useful.</p>",
        "id": 133836773,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536778765
    },
    {
        "content": "<p><code>tfae</code> can still take a list of edges, and it would just add to this the list of edges that have already been <code>have</code>'d</p>",
        "id": 133836787,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536778789
    },
    {
        "content": "<p>Ok, once this tactic is there, we need to make sure <code>obviously</code> in fact tackles the first nine cases of the Hensel's lemma TFAE proof.</p>",
        "id": 133837161,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536779075
    },
    {
        "content": "<p>tpwe = the preceding were equivalent for the finisher</p>",
        "id": 133837469,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536779349
    },
    {
        "content": "<blockquote>\n<p>you can put the numbers in comments if you forgot which is which</p>\n</blockquote>\n<p>That's what I do</p>",
        "id": 133866415,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1536822022
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> is there a version of <code>chain</code> which lets me apply a function to each pair?</p>",
        "id": 133872603,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1536831199
    },
    {
        "content": "<p>What do you mean, <span class=\"user-mention\" data-user-id=\"110111\">@Keeley Hoek</span>?</p>",
        "id": 133872777,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536831378
    },
    {
        "content": "<p>id like to apply an <code>α → α → β</code> function to pairs of adjacent elements of a <code>list α</code>, and get a <code>list β</code>. It feels a bit like <code>chain</code> but not just for <code>Prop</code>s</p>",
        "id": 133873151,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1536831858
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Are you working on this tactic? Or do you think this could be a good exercise for me trying to learn how to write tactics?</p>",
        "id": 133898963,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536858461
    },
    {
        "content": "<p>I'm not working on it right now. If you would like to try your hand at it, go ahead</p>",
        "id": 133899025,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536858497
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110111\">@Keeley Hoek</span> I would suggest defining an element of <code>α × β</code> using <code>list.foldl</code></p>",
        "id": 133899046,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536858534
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> <span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> and me have worked on this a bit. There is now a PR: <a href=\"https://github.com/leanprover/mathlib/pull/373\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/pull/373\">https://github.com/leanprover/mathlib/pull/373</a></p>",
        "id": 134684999,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537977163
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span>  <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Is there anything blocking this PR? I've been hitting a couple of \"the following are equivalent\" lemmas recently, and I wouldn't mind using this machinery.</p>",
        "id": 135159468,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538641999
    },
    {
        "content": "<p>Looks good for me. I'm fine with merging it.</p>",
        "id": 135159627,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1538642220
    },
    {
        "content": "<p>I don't know if Mario still has some concerns?</p>",
        "id": 135159652,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1538642243
    },
    {
        "content": "<p>no, I have just been busy with school. Go ahead and merge it if you have looked it over.</p>",
        "id": 135176877,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538658153
    },
    {
        "content": "<p>okay I merged it</p>",
        "id": 135178091,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1538658512
    }
]
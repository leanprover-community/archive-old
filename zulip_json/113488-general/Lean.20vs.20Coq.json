[
    {
        "content": "<p>Is Lean slow because a VM is used for computations?</p>",
        "id": 184801623,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578140171
    },
    {
        "content": "<p>This is a vague statement without a reference for comparison, but the short answer is yes. When you evaluate a lean tactic or lean function using <code>#eval</code>, it executes a bytecode in a similar way to Python, leading to the same order of speed (it's certainly not as well optimized as python though).</p>",
        "id": 184801982,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578140866
    },
    {
        "content": "<p>One of the biggest changes with Lean 4 is an overhaul of this system. Lean code will now be transpiled to C and then compiled and run, so you are likely to see performance similar to Haskell (although again, optimization is an infinitely deep rabbit-hole)</p>",
        "id": 184802050,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578140979
    },
    {
        "content": "<p>I see, that's good to hear. I was comparing the compile speeds of mathlib and math-comp, which are comparable in size.</p>",
        "id": 184802160,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578141136
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256543\">@Ramkumar Ramachandra</span> You made a similar claim on coq-club regarding speed of Coq over lean for everyday elaboration. My personal experience is the opposite, so if you could clarify what kind of benchmark you are thinking of that would be helpful</p>",
        "id": 184802166,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578141162
    },
    {
        "content": "<p>How fast does math-comp compile? Is the material comparable? Does this include the coq standard library?</p>",
        "id": 184802173,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578141198
    },
    {
        "content": "<p>Just plain wall-clock time. Run <code>make</code> on mathlib or math-comp. math-comp takes about 10 mins to build, and the loc-count is similar.</p>",
        "id": 184802176,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578141238
    },
    {
        "content": "<p>It doesn't include the standard library, and I think the material is comparable, but I'm a beginner.</p>",
        "id": 184802219,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578141280
    },
    {
        "content": "<p>I think the Coq standard library is much bigger than the lean core lib</p>",
        "id": 184802220,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578141300
    },
    {
        "content": "<p>Also, I suspect that math-comp is much more low level in its tactic usage, leading to faster run times. I could be wrong but Gonthier has some opinions in this area that are not shared elsewhere in the coq ecosystem</p>",
        "id": 184802289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578141404
    },
    {
        "content": "<p>lean's stdlib is 18k loc, while coq's is 122k. Coq's stdlib is indeed much larger.</p>",
        "id": 184802303,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578141448
    },
    {
        "content": "<p>I think mathlib is closer to coq stdlib + math-comp</p>",
        "id": 184802308,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578141479
    },
    {
        "content": "<p>but this is still a very vague equivalence because the details are all different</p>",
        "id": 184802351,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578141512
    },
    {
        "content": "<p>That would be incorrect. math-comp uses ssreflect heavily.</p>",
        "id": 184802352,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578141515
    },
    {
        "content": "<p>Right, that's what I mean</p>",
        "id": 184802356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578141523
    },
    {
        "content": "<p>ssreflect is a very direct imperative tactic style</p>",
        "id": 184802364,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578141539
    },
    {
        "content": "<p>it's fast to work with that</p>",
        "id": 184802373,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578141547
    },
    {
        "content": "<p>Ah; I wouldn't know.</p>",
        "id": 184802374,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578141563
    },
    {
        "content": "<p>Yes, Gonthier and his team are extremely proud of using almost no automation.</p>",
        "id": 184802378,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1578141584
    },
    {
        "content": "<p>A representative of the opposite camp would be isabelle, which uses lots of automated proof searching and \"blast\", \"auto\", \"sledgehammer\" type tactics</p>",
        "id": 184802379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578141587
    },
    {
        "content": "<p>Yes. I believe they're also starting to play with ML-based proof search.</p>",
        "id": 184802425,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578141625
    },
    {
        "content": "<p>I'm pretty sure this split is the number 1 aspect that contributes to overall proof checking time of entire libraries</p>",
        "id": 184802435,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578141646
    },
    {
        "content": "<p>... okay, but lean is similar enough to coq to compare on an loc-basis, no?</p>",
        "id": 184802451,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578141696
    },
    {
        "content": "<p>Roughly, yes. I think lean is a bit more terse in general from my impressions</p>",
        "id": 184802493,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578141732
    },
    {
        "content": "<p>Do you have an answer to my question about formalizing ∞-categories, by the way?</p>",
        "id": 184802496,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578141770
    },
    {
        "content": "<p>I've been wanting to see how infinity cats are formalized for a long time, because I don't understand the math and will continue not to until someone actually writes a formal definition down instead of vague words</p>",
        "id": 184802512,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578141827
    },
    {
        "content": "<p>There is nothing in principle stopping anyone from writing it down assuming they actually know what they want</p>",
        "id": 184802553,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578141859
    },
    {
        "content": "<p>I will say that I think it is ludicrous to consider changing your foundations (kernel) in order to accomodate X mathematics. If you need to do so you've already lost</p>",
        "id": 184802621,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578141958
    },
    {
        "content": "<p>I've just started working on formalizing ∞-categories in Coq. The textbook-definition is the most straightforward way to think about it, and you kind of have to bend over backwards in the Coq formalization -- it's quite ugly.</p>",
        "id": 184802666,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578141979
    },
    {
        "content": "<p>Do you have a link?</p>",
        "id": 184802672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578141996
    },
    {
        "content": "<p>I think the lean way wouldn't be so different from that, so I'm interested to know what bending you have to do</p>",
        "id": 184802687,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578142037
    },
    {
        "content": "<p>See <a href=\"https://gist.github.com/artagnon/18c5b8ef22704ef5e92a2111da627692\" target=\"_blank\" title=\"https://gist.github.com/artagnon/18c5b8ef22704ef5e92a2111da627692\">https://gist.github.com/artagnon/18c5b8ef22704ef5e92a2111da627692</a> -- I haven't made much progress though.</p>",
        "id": 184802745,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578142152
    },
    {
        "content": "<p>I couldn't write a currified version: it became too complicated.</p>",
        "id": 184802831,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578142293
    },
    {
        "content": "<blockquote>\n<p>I will say that I think it is ludicrous to consider changing your foundations (kernel) in order to accomodate X mathematics. If you need to do so you've already lost</p>\n</blockquote>\n<p>I would disagree with this, because HoTT is quite a deep change.</p>",
        "id": 184803228,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578143030
    },
    {
        "content": "<p>I'm saying that if you want to be a theorem prover for general mathematics, you can't be playing games with the foundations all the time. Yes, this is throwing HoTT and Cubical type theories under the bus</p>",
        "id": 184803416,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578143307
    },
    {
        "content": "<p>That definition, at least, would go through in lean with only syntactic changes</p>",
        "id": 184803487,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578143431
    },
    {
        "content": "<p>You would have to define it as a pair like you did, though; they are mutually recursive so you need them both</p>",
        "id": 184803499,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578143469
    },
    {
        "content": "<p>It's more complicated than garden-variety mutually-recursive types: the second definition takes the type of the first definition as an argument.</p>",
        "id": 184803553,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578143542
    },
    {
        "content": "<p>I did indeed try with mutually-recusive types, before I hit this limitation.</p>",
        "id": 184803559,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578143562
    },
    {
        "content": "<p>right, it's an inductive-recursive definition</p>",
        "id": 184803560,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578143564
    },
    {
        "content": "<p>If you didn't have the index <code>n</code> this would be impossible to define in lean</p>",
        "id": 184803572,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578143583
    },
    {
        "content": "<p>Indeed; I thought so too.</p>",
        "id": 184803579,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578143618
    },
    {
        "content": "<p>but as it stands this is just a regular recursive function on nat</p>",
        "id": 184803620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578143644
    },
    {
        "content": "<blockquote>\n<p>I'm saying that if you want to be a theorem prover for general mathematics, you can't be playing games with the foundations all the time. Yes, this is throwing HoTT and Cubical type theories under the bus</p>\n</blockquote>\n<p>That's a valid viewpoint, but Coq is a full-fledged programming language + proof assistant. They do play games with TT and PLT.</p>",
        "id": 184803711,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578143803
    },
    {
        "content": "<p>I know. And I don't trust their metatheory at all</p>",
        "id": 184803722,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578143840
    },
    {
        "content": "<p>Why so? \"Coq Coq Correct!\" is quite an accessible exposition.</p>",
        "id": 184803731,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578143865
    },
    {
        "content": "<p>I would sympathize with the viewpoint that you don't care about good type theoretic properties because a VM \"works in practice\", but the trust in the metatheory is quite high.</p>",
        "id": 184803781,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578143925
    },
    {
        "content": "<p>Note that Coq has been used to build CompCert, which was (and still is) an engineering marvel.</p>",
        "id": 184803796,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578143970
    },
    {
        "content": "<p>Lean doesn't try to be a general-purpose programming language for building verified software stacks. It has a narrower focus: a big step-up for pure mathematicians, who are currently on mathematica and sage.</p>",
        "id": 184803870,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578144105
    },
    {
        "content": "<p>I have not read \"Coq Coq Correct\" yet, but skimming it it looks to be a step in the right direction. But It is still a subset of Coq. I won't be satisfied until the entire kernel is covered</p>",
        "id": 184803917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578144125
    },
    {
        "content": "<p>Being able to build things in a proof assistant doesn't mean it doesn't have a bug in it</p>",
        "id": 184803924,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578144155
    },
    {
        "content": "<p>That is only half of the equation</p>",
        "id": 184803930,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578144167
    },
    {
        "content": "<p>Indeed, and work is in progress. Coq Coq Correct! already covers a very large subset, by the way.</p>",
        "id": 184803949,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578144208
    },
    {
        "content": "<p>I wrote the paper on Lean's Type Theory because I didn't want Lean to make the same mistake. That paper covers <em>everything</em> the kernel is capable of doing (and some things it can't), so that soundness means something</p>",
        "id": 184804004,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578144249
    },
    {
        "content": "<p>In practice, too, very few serious bugs have been reported in Coq, over the last twenty years.</p>",
        "id": 184804006,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578144252
    },
    {
        "content": "<p>Right; although how much of your paper is mechanized in Lean? :)</p>",
        "id": 184804036,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578144320
    },
    {
        "content": "<p>Furthermore, my view is that <em>both</em> of these systems are far overcomplicated and you can get by with a much much simpler metatheory (see metamath zero)</p>",
        "id": 184804037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578144328
    },
    {
        "content": "<p>MM0 is interesting, yes.</p>",
        "id": 184804047,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578144359
    },
    {
        "content": "<p>That's where I'm really putting my money where my mouth is - it's a theorem prover that proves its own implementation</p>",
        "id": 184804090,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578144368
    },
    {
        "content": "<p>Perhaps you missed it, but Coq Coq Correct! formalizes a large subset of the Coq engine in Coq.</p>",
        "id": 184804092,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578144399
    },
    {
        "content": "<p>I didn't miss it - that's actually the best reference I've seen yet as to how to implement a coq kernel</p>",
        "id": 184804109,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578144434
    },
    {
        "content": "<p>There is of course a huge front end too though</p>",
        "id": 184804118,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578144467
    },
    {
        "content": "<p>and I don't hold much hope that this be diversified to other front ends</p>",
        "id": 184804162,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578144497
    },
    {
        "content": "<p>For reimplementing a kernel, it's not necessary that the metatheory work actually be formalized, as long as it is mathematically precise and complete. Coq papers have historically had difficulty with the \"complete\" part</p>",
        "id": 184804235,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578144611
    },
    {
        "content": "<p>Formalizing it is the next level, but it helps to have an informal version too</p>",
        "id": 184804255,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578144675
    },
    {
        "content": "<p>Agreed. Keep in mind that Coq is twenty years old, and has accumulated quite a lot of features in that time.</p>",
        "id": 184804361,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578144872
    },
    {
        "content": "<p>The solution to that problem is to not cultivate a community where problems are solved by extending the kernel</p>",
        "id": 184804380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578144907
    },
    {
        "content": "<p>which is why I said \"don't play games with the foundations\" above</p>",
        "id": 184804397,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578144960
    },
    {
        "content": "<p>a large and complex kernel is the inevitable consequence</p>",
        "id": 184804444,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578145003
    },
    {
        "content": "<p>Well, no so much \"extending\" as \"rethinking foundational design choices\". I do agree that extending the kernel makes it hard to trust the metatheory.</p>",
        "id": 184804445,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578145004
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256543\">@Ramkumar Ramachandra</span> Coq is older than you think it is...</p>",
        "id": 184804509,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1578145101
    },
    {
        "content": "<p>or time is further along</p>",
        "id": 184804512,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578145119
    },
    {
        "content": "<p>Or this is nat subtraction hell again.</p>",
        "id": 184804515,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1578145132
    },
    {
        "content": "<p>Who knows what to expect of natural numbers subtraction?</p>",
        "id": 184804524,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1578145156
    },
    {
        "content": "<p>Preserving good type theoretic properties are important to the Coq community, so rethinking foundations is inevitable. They'd never be okay with a VM, I think.</p>",
        "id": 184804577,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578145236
    },
    {
        "content": "<p>Indeed, Coq is thirty years old, not twenty.</p>",
        "id": 184804599,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578145302
    },
    {
        "content": "<p>There are several definitions of infinity category in the literature. My instinct would be to formalise the book by Riehl and Verity</p>",
        "id": 184804601,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1578145313
    },
    {
        "content": "<p>Thirty years means you count only from the first official release, right?</p>",
        "id": 184804645,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1578145338
    },
    {
        "content": "<p>I think the first version is from 1984.</p>",
        "id": 184804649,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1578145379
    },
    {
        "content": "<p><a href=\"http://www.math.jhu.edu/~eriehl/elements.pdf\" target=\"_blank\" title=\"http://www.math.jhu.edu/~eriehl/elements.pdf\">http://www.math.jhu.edu/~eriehl/elements.pdf</a></p>",
        "id": 184804663,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1578145416
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Why don't you publish your paper on Lean's type theory at POPL or ICFP? It currently has very low visibility.</p>",
        "id": 184804797,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578145626
    },
    {
        "content": "<p>Maybe I should... It was my masters thesis so publication was not a prerequisite</p>",
        "id": 184804803,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578145670
    },
    {
        "content": "<p>From Riehl §1.2:</p>\n<blockquote>\n<p>In §1.1, we presented “analytic” proofs of a few of the basic facts about quasi-categories.  The category theory of quasi-categories can be developed in a similar style, but we aim instead to develop the “synthetic” theory of infinite-dimensional categories, so that our results will apply to many models at once. To achieve this, our strategy is not to axiomatize what these infinite-dimensional categories <em>are</em>, but rather axiomatize the “universe” in which they <em>live</em>.</p>\n</blockquote>\n<p>I'm getting a bad feeling about this...</p>",
        "id": 184804985,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578145956
    },
    {
        "content": "<p>Doesn't it sound a bit Mochizuki-like?</p>",
        "id": 184805004,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1578146032
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Thanks; it's a good book, with emphasis on homotopy coherent theory.</p>",
        "id": 184805064,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578146155
    },
    {
        "content": "<p>I'm working through Lurie's Higher Topos Theory from 2009, but it's a tad bit too advanced for me at this point.</p>",
        "id": 184805128,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578146253
    },
    {
        "content": "<p>Different people mean different things by infinity category. <span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> and Verity are attempting to axiomatise the things everyone believes about them so their proofs will apply to all definitions. At least this is my understanding of it.</p>",
        "id": 184805177,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1578146307
    },
    {
        "content": "<blockquote>\n<p>While synthetic, our work is not schematic or hand-wavy, with the details of how to make things fully precise left to “the experts” and turtles all the way down.[2] Rather, we prove our theorems starting from a short list of clearly-enumerated axioms, and our conclusions are valid in any model of∞-categories satisfying these axioms.<br>\n...<br>\n[2] A less rigorous “model-independent” presentation of ∞-category theory might confront a problem of infinite regress,since infinite-dimensional categories are themselves the objects of an ambient infinite-dimensional category, and in developing the theory of the former one is tempted to use the theory of the latter. We avoid this problem by using a very concrete model for the ambient (∞,2)-category of ∞-categories that arises frequently in practice and is designed to facilitate relatively simple proofs. While the theory of (∞,2)-categories remains in its infancy, we are content to cut the Gordian knot in this way.</p>\n</blockquote>\n<p>I don't know if I should be reassured by this</p>",
        "id": 184805238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578146420
    },
    {
        "content": "<p>They didn't define what \"enriched over quasi-categories\" means so I question their claim</p>",
        "id": 184805242,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578146459
    },
    {
        "content": "<p>I guess they are still drawing on a large unspecified amount of background material</p>",
        "id": 184805253,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578146488
    },
    {
        "content": "<p>oh wait, they have it in an appendix</p>",
        "id": 184805317,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578146614
    },
    {
        "content": "<p>I think their work is formalisable. Just like there is a category of all sets and a 2-category of all categories, there's an infinity-2 category of all infinity categories</p>",
        "id": 184805374,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1578146697
    },
    {
        "content": "<p>I'm just trying to figure out if I can trace through all the definitions leading to infinity cosmos without leaving the book</p>",
        "id": 184805430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578146763
    },
    {
        "content": "<p>I think this stuff is going to be important in modern mathematics, for example Scholze's new preprint on ArXiv proves results about cohomology of schemes using infinity categories</p>",
        "id": 184805434,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1578146777
    },
    {
        "content": "<p>Notice  the book is unfinished.</p>",
        "id": 184805436,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1578146800
    },
    {
        "content": "<p>I should hope that this at least is done! (A book on infinity cats should define what is an infinity cat)</p>",
        "id": 184805452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578146861
    },
    {
        "content": "<p>certainly once you've got 700 pages in you should have a good answer to the question</p>",
        "id": 184805495,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578146891
    },
    {
        "content": "<p>Not necessarily, they could decide to change something after seeing that page 690 is more painful than it should be.</p>",
        "id": 184805506,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1578146928
    },
    {
        "content": "<p>I know nothing about all this though.  Maybe it's already completely defined.</p>",
        "id": 184805526,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1578146967
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  What I mean by ∞-categories are the (∞, 1)-categories formalized in HTT; I think that is the generally-accepted definition now. The general approach is to a type theoretic interpretation is to start with simplicial sets, build ∞-groupoids, and work out the coherence constraints that come with interpreting the model category. Indeed, Voevodsky started the HoTT line of work by defining types to be ∞-groupoids, and Shulman's [2013, 2019] work does solve the coherence problem, by which ∞-topoi can be strictified into Quillen Model Categories. I get the impression that he's not too fond of the ongoing cubical work, because he wants even stronger foundations.</p>\n<p>[Please take my comments with a pinch of salt, since I'm a beginner]</p>",
        "id": 184805537,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578146978
    },
    {
        "content": "<p>HoTT doesn't formalize (∞, 1)-categories at all AFAIK; they are the metatheory of HoTT</p>",
        "id": 184805609,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578147040
    },
    {
        "content": "<p>Yes, that's what I meant.</p>",
        "id": 184805620,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578147069
    },
    {
        "content": "<p>It's a very pleasant and elegant metatheory.</p>",
        "id": 184805622,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578147082
    },
    {
        "content": "<p>But are they Luries infinity categories?</p>",
        "id": 184805627,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1578147100
    },
    {
        "content": "<blockquote>\n<p>I think this stuff is going to be important in modern mathematics, for example Scholze's new preprint on ArXiv proves results about cohomology of schemes using infinity categories</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  could you link to that paper?</p>",
        "id": 184805656,
        "sender_full_name": "Koundinya Vajjha",
        "timestamp": 1578147122
    },
    {
        "content": "<blockquote>\n<p>HoTT doesn't formalize (∞, 1)-categories at all AFAIK; they are the metatheory of HoTT</p>\n</blockquote>\n<p>HTT: Higher Topos Theory.</p>",
        "id": 184805694,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578147170
    },
    {
        "content": "<blockquote>\n<p>But are they Luries infinity categories?</p>\n</blockquote>\n<p>I can't say for sure, but Shulman's [2013, 2019] work should have the answer. I'm still working through them.</p>",
        "id": 184805712,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578147227
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"233147\">@Ulrik Buchholtz</span> You are our local expert on this stuff... maybe you can enlighten us</p>",
        "id": 184805762,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578147290
    },
    {
        "content": "<p>I have always been frustrated reading material in that area that assumes everyone knows what an infinity cat is as if it were a single well understood concept. If you just assume that a thing exists that has the properties you want (i.e. HoTT) then it's easy, but building up the theory formally has apparently never been done</p>",
        "id": 184805765,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578147296
    },
    {
        "content": "<p>Kevin probably means <a href=\"https://arxiv.org/abs/1912.10932\" target=\"_blank\" title=\"https://arxiv.org/abs/1912.10932\">https://arxiv.org/abs/1912.10932</a></p>",
        "id": 184805772,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1578147311
    },
    {
        "content": "<p>Yes -- sorry -- doing ten things at once. Cesnavicius-Scholze.</p>",
        "id": 184806019,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1578147734
    },
    {
        "content": "<p>I wouldn't call myself an expert on the model-theory of HoTT, but here's my understanding of where we are: From <a href=\"http://www.andrew.cmu.edu/user/avigad/meetings/fomm2020/program.html\" target=\"_blank\" title=\"http://www.andrew.cmu.edu/user/avigad/meetings/fomm2020/program.html\">Shulman</a>, we know that any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> (\\infty,1) </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-topos (with Lurie's definition) can be presented by a super-nice model category that in turn can be strictified to a model of HoTT. I think it's still not quite what we want: what if we take different presentations, do we get different results (we shouldn't, up to homotopy/identification).</p>",
        "id": 184806223,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578148169
    },
    {
        "content": "<p>And it's true we don't know whether HoTT (meaning here MLTT+Univalence+HITs) can define the correct type of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> (\\infty,1) </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-categories, etc. (A majority conjecture that it's impossible without some extension to the theory, I'm agnostic)</p>",
        "id": 184806299,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578148272
    },
    {
        "content": "<p>So until we either figure out how to do it, or find an acceptable extension (one proposal is two-level type theory with Reedy limits), HoTT is not strong enough to do it's own model theory <strong>in the correct way</strong> – of course, quasicategories can be formalized but that's not adequate from the univalent point of view: it's not the correct type.</p>",
        "id": 184806368,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578148434
    },
    {
        "content": "<p>What I don't really understand here is the following. Maths is about lots of things, including infinity categories and lots of other stuff which is completely unrelated to infinity categories. It seems to be that something like UniMath starts with an infinity category of types and then says \"that's it\". But I want other infinity categories, and I want a gazillion things that aren't infinity categories. So it seems to me that I want to define infinity categories, like I would do in lean, rather than being stuck with them and nothing else</p>",
        "id": 184806411,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1578148447
    },
    {
        "content": "<p>Absolutely, HoTT is currently inadequate to properly talk about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> (\\infty,1) </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-categories! But only HoTT has a chance of even doing so univalently, all other foundations must rely on models.</p>",
        "id": 184806428,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578148521
    },
    {
        "content": "<p>I'll say something about all this in my talk on Monday, BTW</p>",
        "id": 184806440,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578148553
    },
    {
        "content": "<p>what's wrong with models?</p>",
        "id": 184806441,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578148557
    },
    {
        "content": "<p>somehow I'm missing the added value here</p>",
        "id": 184806481,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578148594
    },
    {
        "content": "<p>With models you have to always prove that constructions are independent of representations: it's like doing group theory only with group presentations and no actual groups.</p>",
        "id": 184806482,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578148601
    },
    {
        "content": "<p>But we have a definition of what a group is</p>",
        "id": 184806492,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578148632
    },
    {
        "content": "<p>Apparently we can't decide what the definition of an infinity cat is, but at least Riehl &amp; Verity have a definition of what a definition of an infinity cat is</p>",
        "id": 184806543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578148706
    },
    {
        "content": "<p>Right, but the type of groups in 0-truncated foundations is, well, 0-truncated, so you have to prove that all group-constructions respect isomorphism by hand. The issue with higher structures is similar, just more complicated.</p>",
        "id": 184806546,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578148716
    },
    {
        "content": "<p>that is an issue of automation not foundations</p>",
        "id": 184806555,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578148760
    },
    {
        "content": "<p>There are many models for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> (\\infty,1) </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-categories, but they are all equivalent: quasicategories with categorical equivalences, complete Segal spaces with equivalences etc</p>",
        "id": 184806556,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578148765
    },
    {
        "content": "<p>it seems to me like there has been a change of terminology in calling those things \"models\"</p>",
        "id": 184806620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578148849
    },
    {
        "content": "<blockquote>\n<p>that is an issue of automation not foundations</p>\n</blockquote>\n<p>Depends on your point of view, I think. I think it's conceptually very appealing to be able to work with the types of mathematical objects themselves, and not just with models of them.</p>",
        "id": 184806631,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578148870
    },
    {
        "content": "<p>Well, “model” means a billion things in math. Here, it's like “presentation” in group presentations.</p>",
        "id": 184806633,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578148904
    },
    {
        "content": "<p>those are not (particular) infinity cats</p>",
        "id": 184806640,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578148917
    },
    {
        "content": "<p>I though you wanted a definition of infty cats. Did I misunderstand your question?</p>",
        "id": 184806681,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578148948
    },
    {
        "content": "<p>those are candidates for how you might enumerate all infinity cats</p>",
        "id": 184806682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578148949
    },
    {
        "content": "<p>I get why you call them models, but it's not like the situation with group presentations because in that case \"models\" would be individual groups</p>",
        "id": 184806704,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578149032
    },
    {
        "content": "<p>I don't think that these are models in the sense you're expecting: a single category is a model of (essentially algebraic) theory. This 'model' is more like a presentation of CAT itself. Though <span class=\"user-mention\" data-user-id=\"233147\">@Ulrik Buchholtz</span> might correct me on this</p>",
        "id": 184806752,
        "sender_full_name": "Daniel Gratzer",
        "timestamp": 1578149085
    },
    {
        "content": "<p>Right</p>",
        "id": 184806756,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578149099
    },
    {
        "content": "<p>In the case of group presentations and groups, they're like the presentations. They are different presentations of the same type: that of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> (\\infty,1) </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-categories.</p>",
        "id": 184806769,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578149125
    },
    {
        "content": "<p>Just like the Lean-type (or any 0-truncated type) of groups, together with the data of group isomorphisms present the 1-type of groups.</p>",
        "id": 184806827,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578149196
    },
    {
        "content": "<p>So there shouldn't be any problem with just picking one of the \"presentations\" and proving all others equivalent?</p>",
        "id": 184806894,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578149297
    },
    {
        "content": "<p>The data of (quasicategories, categorical equivalences) is a presentation of the homotopy type of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> (\\infty,1) </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-categories. (With structure making it a large <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> (\\infty,1) </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-category itself.)</p>",
        "id": 184806895,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578149298
    },
    {
        "content": "<p>Absolutely, which is what people have been doing</p>",
        "id": 184806896,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578149314
    },
    {
        "content": "<p>sounds like a plan</p>",
        "id": 184806900,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578149341
    },
    {
        "content": "<p>Go for it :)</p>",
        "id": 184806906,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578149347
    },
    {
        "content": "<p>in particular, nothing stops us from doing this in lean</p>",
        "id": 184806908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578149368
    },
    {
        "content": "<p>Absolutely, because people are doing it in informal set-theoretic math, and Lean captures that quite well</p>",
        "id": 184806914,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578149392
    },
    {
        "content": "<p>We could also do it that way in univalent type theories, but there the level of ambition is higher: we'd want the presented type itself.</p>",
        "id": 184806969,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578149435
    },
    {
        "content": "<p>and the reservations of your HoTT colleagues are about some kind of ambiguity preserving definition</p>",
        "id": 184806970,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578149447
    },
    {
        "content": "<p>where by \"the type itself\" you mean that in the metatheory you can prove that this is equivalent to the... real... definition?</p>",
        "id": 184807026,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578149552
    },
    {
        "content": "<p>it's not clear to me what the set theoretic definition is losing out on here. You still have the language to say what equivalences matter, and show that you have the right definition up to such and such kind of equivalence</p>",
        "id": 184807098,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578149666
    },
    {
        "content": "<p>That's one thing: that metatheoretically we could show that in an infinity-topos it externalizes to the stack of infinity-categories. Or just internally that it's a type with the correct identity type (meaning categorical equivalences)</p>",
        "id": 184807103,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578149691
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> A group is a subset of <code>matrix R n n</code> (for some ring <code>R</code>) such that it is closed under multiplication, and inverses, and contains the unit matrix.</p>",
        "id": 184807178,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578149784
    },
    {
        "content": "<p>For the rock-bottom foundation, I don't think you lose out. But we want to use HoTT to talk about other infty-toposes than infty-groupods (animated sets!?), and there it matters:</p>",
        "id": 184807179,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578149785
    },
    {
        "content": "<p>Is that a satisfactory definition of groups?</p>",
        "id": 184807180,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578149793
    },
    {
        "content": "<p>sure</p>",
        "id": 184807181,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578149803
    },
    {
        "content": "<p>I mean, it's not what I find on wikipedia, so that's a black mark</p>",
        "id": 184807184,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578149818
    },
    {
        "content": "<p>Well, some people would argue that it's not a very elegant definition. It doesn't really capture what we want.</p>",
        "id": 184807197,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578149838
    },
    {
        "content": "<p>Something similar is the problem with inftycats</p>",
        "id": 184807200,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578149849
    },
    {
        "content": "<p>It does capture what we want though, assuming we got the definition of \"what we want\" right</p>",
        "id": 184807206,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578149878
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> that's a good point: there's some hope that an eventual HoTT (or HoTT+extension) definition of infty-cats would be nicer/easier to work with than via quasicats</p>",
        "id": 184807247,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578149895
    },
    {
        "content": "<p>As for finding an elegant definition, that's a process we can work on</p>",
        "id": 184807251,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578149907
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I think that working with Lurie's quasi-categories in a prover like Lean will be very painful.</p>",
        "id": 184807267,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578149933
    },
    {
        "content": "<p>Usually community consensus works pretty well to find this though (e.g. matching wikipedia)</p>",
        "id": 184807276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578149956
    },
    {
        "content": "<p>A synthetic definition would probably remove a lot of proof obligations, and lots \"keeping-track of an infinite stack of homotopy-data\"</p>",
        "id": 184807280,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578149974
    },
    {
        "content": "<p>There is nothing stopping you from modeling the synthetic definition in the form of theorems that are crafted to make the proof obligations trivial</p>",
        "id": 184807335,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578150009
    },
    {
        "content": "<p>BTW, we already have a <a href=\"https://arxiv.org/abs/1705.07442\" target=\"_blank\" title=\"https://arxiv.org/abs/1705.07442\">synthetic definition</a> by working in the infty-topos of simplicial spaces: there we can synthetically define complete Segal spaces.</p>",
        "id": 184807340,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578150034
    },
    {
        "content": "<p>If doing something stupid results in a syntax error, instead of \"hey, you've struggled for 37 minutes, maybe you just can't supply all the infinite amount of proof obligations, because you did something silly on the previous line\"</p>",
        "id": 184807353,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578150055
    },
    {
        "content": "<p>If we could internalize this model, we could use it to prove facts about infty-cats at the ambient level</p>",
        "id": 184807363,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578150068
    },
    {
        "content": "<p>there is no infinite amount of proof obligations, there never has been</p>",
        "id": 184807364,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578150077
    },
    {
        "content": "<p>That depends on how you count</p>",
        "id": 184807371,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578150098
    },
    {
        "content": "<p>to the extent that HoTT makes sense at all, it's bookkeeping all this information. So it's not infinite</p>",
        "id": 184807374,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578150116
    },
    {
        "content": "<p>Of course the infinite amount can be supplied with finitely many keystrokes</p>",
        "id": 184807375,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578150116
    },
    {
        "content": "<p>Sure, but we don't do HoTT here</p>",
        "id": 184807415,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578150132
    },
    {
        "content": "<p>It's infinite in the same sense that there are an infinite number of proof obligations to show + on nat is commutative</p>",
        "id": 184807420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578150159
    },
    {
        "content": "<p>If we can model HoTT, we can do HoTT in lean/set theory with epsilon overhead</p>",
        "id": 184807429,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578150199
    },
    {
        "content": "<p>That would actually be great: if you could formalize infty-toposes a la Lurie and prove Shulman's strictification and model result</p>",
        "id": 184807478,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578150244
    },
    {
        "content": "<blockquote>\n<p>If we can model HoTT, we can do HoTT in lean/set theory with epsilon overhead</p>\n</blockquote>\n<p>How would that work?</p>",
        "id": 184807482,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578150273
    },
    {
        "content": "<p>But how nice is it to do proofs in an object logic/type theory? Is it really <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ε</mi></mrow><annotation encoding=\"application/x-tex\"> \\varepsilon </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">ε</span></span></span></span> overhead?!</p>",
        "id": 184807486,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578150297
    },
    {
        "content": "<p>I mean... we can <em>define</em> simplicial sets. I've done that. Working with them is another matter</p>",
        "id": 184807493,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578150305
    },
    {
        "content": "<p>To make it epsilon overhead, you need a good set of theorems (this is a finite amount of work, to define what HoTT foundations are) and a theorem prover that is prepared to produce theorems in this embedded logic</p>",
        "id": 184807542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578150371
    },
    {
        "content": "<p>that's a UI problem, but it's completely feasible if you think it is possible to build native-HoTT theorem provers</p>",
        "id": 184807549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578150403
    },
    {
        "content": "<p>Ideally, I'd like my foundations to make it super-easy and convenient to do proofs in embedded DSLs (domain-specific logics!)</p>",
        "id": 184807559,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578150429
    },
    {
        "content": "<p>And to be able to externalize via model constructions and interpretations!</p>",
        "id": 184807567,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578150459
    },
    {
        "content": "<p>And then, once you are committed to this DSL style approach, you realize that the foundations don't have to be type theory at all, and they can be something super simple like string rewriting :)</p>",
        "id": 184807572,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578150480
    },
    {
        "content": "<p>Yes, yes, I know where this is going (-; <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 184807616,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578150504
    },
    {
        "content": "<p>How does MM0 handle interpretations between DSLs?</p>",
        "id": 184807619,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578150528
    },
    {
        "content": "<p>There are two parts to any such work: the one-time cost of proving relative consistency of one language to another, and the cost of translating individual target theorems to the other language (which requires changing syntax and stuff and so is O(n))</p>",
        "id": 184807702,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578150632
    },
    {
        "content": "<p>You can prove the one time cost as a theorem, and the O(n) work is a suite of theorems that are applied in a syntax directed way by tactics</p>",
        "id": 184807712,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578150665
    },
    {
        "content": "<p>This lets you model arbitrarily complicated syntactic theories like HoTT or anything else as long as you have a grasp on the metatheory (which tells you how to prove the translation theorems)</p>",
        "id": 184807765,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578150753
    },
    {
        "content": "<p>If I want to know that relative to some base theory (say of primitive recursive or polynomial time strength) that theory S interprets theory T, are you thinking of MM0 as the base theory, or should I fix another base theory to talk about the syntaxes of S and T?</p>",
        "id": 184807887,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578150975
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I wonder if the following is a down to earth test case: at some point someone (probably <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span>) defined <em>continuous linear maps</em> and showed that identity and composition of such maps are again such maps. Tada, we have a category. Can some tactics now automatically PR <a href=\"https://github.com/leanprover-community/mathlib/blob/8e820e28bf4e1e1eb091608b1d5a5c2f4d8650f2/src/topology/algebra/module.lean#L368L446\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/8e820e28bf4e1e1eb091608b1d5a5c2f4d8650f2/src/topology/algebra/module.lean#L368L446\">https://github.com/leanprover-community/mathlib/blob/8e820e28bf4e1e1eb091608b1d5a5c2f4d8650f2/src/topology/algebra/module.lean#L368L446</a></p>",
        "id": 184807891,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578150996
    },
    {
        "content": "<p>Because that seems to be related to what you are suggesting</p>",
        "id": 184807896,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578151017
    },
    {
        "content": "<p>MM0 is the theorem prover, you have to supply your own theory, but it can be something like PA or ZFC for a reasonable math foundation. This is viewed as a fixed background where you are doing \"all of math\". So you have theory S and T and you want to interpret one in the other, so you define both in ZFC in MM0 and then the mapping function is explicitly definable in the logic, and you can prove properties about it; and it is also computable (in the sense that you can figure out what it does on any given term), so you can \"run\" it using tactics.</p>",
        "id": 184808029,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578151222
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Doesn't lean <em>already</em> have tactics to very nearly automate all of this? It's really not a leap to think that we could do so if we cared enough</p>",
        "id": 184808099,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578151336
    },
    {
        "content": "<p>We have a constructor, not a tactic.</p>",
        "id": 184808108,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1578151379
    },
    {
        "content": "<p>(I mean, a constructor for concrete categories)</p>",
        "id": 184808127,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1578151420
    },
    {
        "content": "<p>Lean 3 is limited in the kinds of definitions you can write by automation, but it already generates lots of theorems for inductive types. You could have a <code>#eval make_category continuous_linear_map</code> that just produces all these theorems, adds attributes, notations, etc, if it is sufficiently boilerplate</p>",
        "id": 184808200,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578151518
    },
    {
        "content": "<p>Well, by now we have 25 different kinds of equivs</p>",
        "id": 184808273,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578151637
    },
    {
        "content": "<p>I would say it is sufficiently boilerplate</p>",
        "id": 184808277,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578151649
    },
    {
        "content": "<p>25?</p>",
        "id": 184808280,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578151660
    },
    {
        "content": "<p>They all follow the same pattern</p>",
        "id": 184808281,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578151666
    },
    {
        "content": "<p>Ooh, maybe its 13, maybe 37</p>",
        "id": 184808282,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578151674
    },
    {
        "content": "<p>equiv, add_equiv, mul_equiv, ring_equiv, linear_equiv, continuous_linear_equiv, continuous_equiv (or homeo, maybe)</p>",
        "id": 184808338,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578151731
    },
    {
        "content": "<p>And there's probably more that I haven't thought of immediately</p>",
        "id": 184808343,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578151743
    },
    {
        "content": "<p>Keep in mind also that there is a tradeoff between when you want to switch to an explicit model of the commonalities (i.e. a theory of categories) that becomes more reasonable the more examples you have</p>",
        "id": 184808351,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578151760
    },
    {
        "content": "<p>The reason we have all the duplication is because we actually care about the consequences in all of these disparate cases</p>",
        "id": 184808369,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578151797
    },
    {
        "content": "<p>i.e. we want to have a way to say \"compose these two linear equivs\" which doesn't involve the overhead of category theory</p>",
        "id": 184808433,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578151849
    },
    {
        "content": "<p>Apparently...</p>",
        "id": 184808448,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578151895
    },
    {
        "content": "<p>Anyway, I guess we could make an attempt at defining quasi-categories à la Lurie</p>",
        "id": 184808495,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578151945
    },
    {
        "content": "<p>And then maybe some tactic writers can make them work nicely</p>",
        "id": 184808496,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578151963
    },
    {
        "content": "<p>In the largest scale, if we have 50 of these categories, but they are all highly used in their own domains, we want the full product of theorems (composition of linear equivs is an equiv, an invertible group hom is an equiv, etc) but these theorems can be proven using a category theory</p>",
        "id": 184808502,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578151971
    },
    {
        "content": "<p>I find it funny that you think of using DSLs as having <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ε</mi></mrow><annotation encoding=\"application/x-tex\"> \\varepsilon </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">ε</span></span></span></span> overhead, but common organizational abstractions such as categories as overhead to be avoided? <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 184808517,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578152012
    },
    {
        "content": "<p>Category theory is itself a kind of DSL</p>",
        "id": 184808523,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578152038
    },
    {
        "content": "<p>It's a tradeoff. There is overhead to use the abstraction, vs overhead to state the specific variant (and prove using the abstraction)</p>",
        "id": 184808569,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578152075
    },
    {
        "content": "<p>I agree, but I want to know the value of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ε</mi></mrow><annotation encoding=\"application/x-tex\"> \\varepsilon </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">ε</span></span></span></span>, that's all <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 184808584,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578152118
    },
    {
        "content": "<p>You are absolutely correct that category theory is a DSL. The epsilon overhead only happens after you put in the (possibly large) O(1) overhead of proving all the base theorems for the target category</p>",
        "id": 184808645,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578152190
    },
    {
        "content": "<p>But these are typically theorems you want anyway.</p>",
        "id": 184808661,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578152243
    },
    {
        "content": "<p>right</p>",
        "id": 184808663,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578152248
    },
    {
        "content": "<p>In Johan's example, you want that full product of theorems in any case</p>",
        "id": 184808671,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578152279
    },
    {
        "content": "<p>so there isn't much point optimizing anything except a boilerplate generating tactic</p>",
        "id": 184808721,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578152303
    },
    {
        "content": "<p>but my impression has been that the benefits of category theory in this area are pretty shallow. Proving that the composition of equivs is an equiv assuming that an equiv is a hom with an inverse is not a very large term</p>",
        "id": 184808803,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578152412
    },
    {
        "content": "<p>And I don't see much demand for more complicated categorical facts (are there any interesting theorems about general categories? Yoneda seems like the pinnacle but it's still not that complicated)</p>",
        "id": 184808837,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578152511
    },
    {
        "content": "<p>all the real theorems require tons of additional assumptions beyond just being a category</p>",
        "id": 184808882,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578152535
    },
    {
        "content": "<p>I don't know what differentiates a “real” theorem from other theorems. You're right that category theory proofs are short (many would consider this a virtue, but from a proof size point-of-view it means they can be inlined). I think for abelian categories and toposes, the “inlinings” would start to get longer.</p>",
        "id": 184808991,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578152745
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> You goal is golfing <code>pp.all</code> output. My goal is golfing the number of keystrokes that I type.</p>",
        "id": 184809038,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578152764
    },
    {
        "content": "<p>Right, there's a difference between the original tactic entered by the user, and the storage of a proof, and the various other ways we'd want to re-display and re-check a proof after it's been completed. I think all systems could improve in these matters.</p>",
        "id": 184809136,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578152931
    },
    {
        "content": "<p>As for what the value of epsilon is, in the best case you are looking at a single extra universal quantifier. So that means each generalized theorem application gets an extra argument pointing to the fact \"X is a category and C is the objects, H is the homs\" or however that needs to be stored. In lean's case this would usually be a typeclass arg so the visible overhead goes to zero, while the pp.all overhead is something like 5% or less (since most steps will not be these generalized theorems they make up a small proportion of the proof anyway)</p>",
        "id": 184809146,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578152950
    },
    {
        "content": "<p>Even if we're measuring total keystrokes, there is still a tradeoff between how much work is needed to define the tactic that saves the work</p>",
        "id": 184809221,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578153042
    },
    {
        "content": "<p>I think I want to know the snake lemma in an arbitrary abelian category. That proof is much much longer than Yoneda and is used in the real world</p>",
        "id": 184809229,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1578153059
    },
    {
        "content": "<p>if you are thinking \"well that's not my problem\" then that's just an externalized cost model</p>",
        "id": 184809236,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578153066
    },
    {
        "content": "<p>has the snake lemma been done formally before?</p>",
        "id": 184809258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578153112
    },
    {
        "content": "<p>I'm not actually sure that it's true that the proof is long, formally</p>",
        "id": 184809299,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578153134
    },
    {
        "content": "<p>The fact is that mathematicians like abstractions, both shallow and deep, and like to use them, so we should make it convenient to do so. That means making it easy to write the necessary tactics, too</p>",
        "id": 184809300,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1578153138
    },
    {
        "content": "<p>Right, there is always the argument that category theory et al is innately interesting, rather than my operational interest metric</p>",
        "id": 184809321,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578153201
    },
    {
        "content": "<blockquote>\n<p>has the snake lemma been done formally before?</p>\n</blockquote>\n<p>It probably has been done somewhere. (Note that formally we'll need the snake <em>definition</em> before stating the snake <em>lemma</em>. I.e., the connecting homomorphism is a definition that is usually sn(e)aked into a lemma.)</p>",
        "id": 184809385,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578153284
    },
    {
        "content": "<p>Fun fact: the Snake Lemma is one of the few lemmas that has \"proof by imdb\"</p>",
        "id": 184809469,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578153439
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">snake</span> <span class=\"o\">:</span> <span class=\"n\">bla</span> <span class=\"n\">bla</span> <span class=\"n\">bla</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">imdb</span>\n</pre></div>",
        "id": 184809476,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578153462
    },
    {
        "content": "<p>I'm not sure all the details were given there though. I think this is a bad reference and the only reason it's so common is because it's funny.</p>",
        "id": 184809740,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1578153946
    },
    {
        "content": "<p>I think there's a proof in kashiwara-schapiro? Of course anyone who cares could work out a proof by themselves...</p>",
        "id": 184809789,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1578153986
    },
    {
        "content": "<p>Aluffi has some quote about it being 'bad manners to prove the snake lemma in public' I think...</p>",
        "id": 184809865,
        "sender_full_name": "Daniel Gratzer",
        "timestamp": 1578154104
    },
    {
        "content": "<p>The opposite of an abelian category is an abelian category. That allows you to cut the proof in half (plus epsilon, of course)</p>",
        "id": 184809870,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578154109
    },
    {
        "content": "<p>I think that may count as an application of category theory (<span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>), since the category of modules over a ring does not have an opposite category equivalent to modules over a ring.</p>",
        "id": 184809961,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578154236
    },
    {
        "content": "<p>It's hard to guess what the relative difficulty would be. You certainly give up some things by going to categories, e.g. you can't reason about points and defining functions pointwise anymore</p>",
        "id": 184810059,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578154429
    },
    {
        "content": "<p>Ooh, and you need to define abelian categories (-;</p>",
        "id": 184810179,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578154589
    },
    {
        "content": "<p>And there are multiple definitions, so you have to make a choice</p>",
        "id": 184810182,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578154605
    },
    {
        "content": "<p>I'm just going to assume that an abelian category is a category where every diagram commutes</p>",
        "id": 184810237,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578154718
    },
    {
        "content": "<blockquote>\n<p>The opposite of an abelian category is an abelian category.</p>\n</blockquote>\n<p>just category theory things</p>",
        "id": 184811140,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1578156424
    },
    {
        "content": "<p>this might be a good excuse to do the mitchell embedding theorem (the diagram chasing proof of the snake lemma is less annoying than the purely diagrammatic proof)</p>",
        "id": 184811262,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1578156677
    },
    {
        "content": "<p>A summary of the discussion: <a href=\"https://artagnon.com/articles/leancoq\" target=\"_blank\" title=\"https://artagnon.com/articles/leancoq\">https://artagnon.com/articles/leancoq</a></p>",
        "id": 184813256,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578160260
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256543\">@Ramkumar Ramachandra</span> Concerning the speed comparison at the end. You missed Mario's point that Lean uses a lot more automation (notably type class inference).</p>",
        "id": 184813446,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578160622
    },
    {
        "content": "<p>Besides that: thanks for this write-up!</p>",
        "id": 184813452,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578160642
    },
    {
        "content": "<blockquote>\n<p>Lean has much lower startup-cost for pure mathematicians, since its built-in features and math library are great for doing undergraduate-level group theory &amp; topology, masters-level commutative algebra &amp; category theory, but it plateaus quickly thereafter. </p>\n</blockquote>\n<p>I might have missed something but is there really a sense that working with mathlib \"plateaus quickly\" in some areas?</p>",
        "id": 184813507,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1578160751
    },
    {
        "content": "<p>Well, we still don't have sheaves and/or abelian categories. Even though we've been discussing them for &gt;18 months</p>",
        "id": 184813633,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578160953
    },
    {
        "content": "<p>That's just lack of person-power though. It's hard to do things right.</p>",
        "id": 184814273,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1578162198
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256543\">@Ramkumar Ramachandra</span> That was fast! Minor nitpick: Lean 4 is written mostly in Lean, not C (at least as soon as we delete the old C++ frontend)</p>",
        "id": 184814369,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1578162364
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> Thanks; fixed.</p>",
        "id": 184814500,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578162698
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Thanks, but I'm not sure I understand how to phrase it.</p>",
        "id": 184814549,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578162758
    },
    {
        "content": "<p>I did say that it uses a VM; doesn't that cover \"automation\"?</p>",
        "id": 184814559,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578162798
    },
    {
        "content": "<p>Not really. In Lean, you can do the following: say <code>X</code> and <code>Y</code> are types. We can assume that they are endowed with a topology, by writing <code>[topological_space X]</code> and <code>[topological_space Y]</code>. If you later on write <code>X × Y</code>, and treat it as topological space, then Lean will figure out on its own that there is some piece of maths in the library that explains that it should use the product topology.</p>",
        "id": 184814620,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578162941
    },
    {
        "content": "<p>In other systems, you explicitly flag \"Hey, I'm using the product of <code>X</code> and <code>Y</code>, and remember, it has the product topology\"</p>",
        "id": 184814662,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578162969
    },
    {
        "content": "<p>So, summary: Lean is constantly figuring out a boatload of trivialities under the hood. The result is that statements in Lean can get pretty close to what it looks like in ordinary maths. (But this still varies a lot per subject. The current manifold code is not really recognisable to outsiders.)</p>",
        "id": 184814682,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578163062
    },
    {
        "content": "<blockquote>\n<p>I guess they are still drawing on a large unspecified amount of background material</p>\n</blockquote>\n<p>Hi <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>. I'd contend our work isn't Mochizuki-like because the background material we rely upon is known (to a certain community of mathematicians at least). Someone who is familiar with what it's like to work with a simplicial model category could start right away in Chapter 1 (and not read any of the appendices) and understand precisely what we mean right away. On that same point, the material in Appendices A-D is all in the literature somewhere; by contrast Appendices E-F contain technical results about ∞-cosmoi and so are things we proved to support this work. So someone who knows a fair amount of categorical homotopy theory could read the book without ever looking at those appendices and would have a pretty easy go of it, at least for Parts I, III, and IV; II and V are somewhat more technical. </p>\n<p>About to board a flight so I'll leave it here for now. Thanks for your interest!</p>",
        "id": 184815576,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1578164729
    },
    {
        "content": "<p>I wasn't intending to throw shade on the work at all; I'm obviously not the target audience but for formalization being able to find the definitions of everything without a stack of background is important for getting started. In any case, with the appendices I managed to find all the definitions that are needed for that first definition, so I think it passes the test :)</p>",
        "id": 184815837,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578165184
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Thanks; I've updated the post to use your example.</p>",
        "id": 184832188,
        "sender_full_name": "Ramkumar Ramachandra",
        "timestamp": 1578196743
    },
    {
        "content": "<p>Regarding quasicategories, I posted a definition on the maths stream a while ago. On mobile and don't know how to link to it, but searching for QCat should find it.</p>",
        "id": 185014578,
        "sender_full_name": "Reid Barton",
        "timestamp": 1578407070
    },
    {
        "content": "<p>By itself it's not good for much, of course.</p>",
        "id": 185014672,
        "sender_full_name": "Reid Barton",
        "timestamp": 1578407137
    },
    {
        "content": "<p>Voila: <a href=\"#narrow/stream/116395-maths/topic/quasicategories/near/165386120\" title=\"#narrow/stream/116395-maths/topic/quasicategories/near/165386120\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quasicategories/near/165386120</a></p>",
        "id": 185015225,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1578407463
    }
]
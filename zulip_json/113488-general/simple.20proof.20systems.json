[
    {
        "content": "<p>Sorry in advance for a rather vague question, hopefully I can make it clear what I'm looking for.<br>\nSuppose I wanted to \"compile\" Lean formulas and proof terms to some other logical system. How \"simple\" could the target logical system be?</p>",
        "id": 135758238,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539484254
    },
    {
        "content": "<p>hm, it is a bit vague</p>",
        "id": 135758249,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539484306
    },
    {
        "content": "<p>I want a human-verifiable procedure for taking a theorem statement and turning it into a formula in some other system, and also a procedure for turning the Lean proof into a valid proof in the other system</p>",
        "id": 135758299,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539484338
    },
    {
        "content": "<p>you can go pretty simple for almost any system, by appropriate encoding in the language of PA</p>",
        "id": 135758300,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539484339
    },
    {
        "content": "<p>So one kind of simplicity which I would like is if the formulas of the target system could be described by an inductive type, and provability could be described by an inductive proposition</p>",
        "id": 135758308,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539484376
    },
    {
        "content": "<p>Is the encoding you have in mind sort of how like I could simulate a checker for any language by a universal Turing machine?</p>",
        "id": 135758325,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539484441
    },
    {
        "content": "<p>yes</p>",
        "id": 135758366,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539484446
    },
    {
        "content": "<p>I get the sense that misses your point though</p>",
        "id": 135758372,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539484491
    },
    {
        "content": "<p>I see.</p>",
        "id": 135758373,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539484492
    },
    {
        "content": "<p>I was hoping for a system more like: if I have a proof of P and a proof of P -&gt; Q, then I get a proof of Q. Plus a bunch of axioms. I'm pretty sure that I need additional rules to deal with quantifiers though.</p>",
        "id": 135758390,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539484523
    },
    {
        "content": "<p>like ZFC style?</p>",
        "id": 135758395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539484548
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow></mrow><annotation encoding=\"application/x-tex\"> </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0em;\"></span><span class=\"strut bottom\" style=\"height:0em;vertical-align:0em;\"></span><span class=\"base\"></span></span></span> + FOL</p>",
        "id": 135758404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539484556
    },
    {
        "content": "<p>I think so but then I think I have to deal with substitution and that seems a little bit more complicated than I would like</p>",
        "id": 135758465,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539484602
    },
    {
        "content": "<p>Is metamath based on something like this?</p>",
        "id": 135758479,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539484632
    },
    {
        "content": "<p>I was about to suggest metamath indeed</p>",
        "id": 135758487,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539484642
    },
    {
        "content": "<p>it doesn't have proper substitution</p>",
        "id": 135758494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539484650
    },
    {
        "content": "<p>just direct substitution</p>",
        "id": 135758500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539484655
    },
    {
        "content": "<p>I guess another way to frame the question is: Suppose you wanted to be as sure as possible that you had correctly implemented a proof checker which only accepts theorems provable in ZFC+U (or whatever).</p>",
        "id": 135758502,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539484667
    },
    {
        "content": "<p>The universal turing machine idea doesn't help you here, because you still need to write the \"actual machine\" (it is just part of the specification of what constitutes a proof, rather than being the checker itself)</p>",
        "id": 135758544,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539484721
    },
    {
        "content": "<p>I think you can avoid proper substitution in the axioms and what not by having it be an explicit judgment in the system</p>",
        "id": 135758553,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539484759
    },
    {
        "content": "<p>what's not \"proper\" about direct substitution? Something about not renaming bound variables?</p>",
        "id": 135758554,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539484762
    },
    {
        "content": "<p>yes</p>",
        "id": 135758555,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539484774
    },
    {
        "content": "<p>metamath has a notion of text substitution a la grep</p>",
        "id": 135758557,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539484787
    },
    {
        "content": "<p>I think I've heard phrases like \"proof calculus with explicit substitution\", is that relevant?</p>",
        "id": 135758558,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539484788
    },
    {
        "content": "<p>that's about having terms in the language that are a sort of \"deferred substitution\"</p>",
        "id": 135758598,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539484808
    },
    {
        "content": "<p>but you still have to do the substitution at some point</p>",
        "id": 135758603,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539484829
    },
    {
        "content": "<p>although you can build it into the steps of actual proof, which is basically what metamath does</p>",
        "id": 135758608,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539484849
    },
    {
        "content": "<p>but does that mean I can push the work of substitution into the proof itself</p>",
        "id": 135758616,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539484879
    },
    {
        "content": "<p>yes</p>",
        "id": 135758617,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539484882
    },
    {
        "content": "<p>that way all your substitutions are direct</p>",
        "id": 135758619,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539484900
    },
    {
        "content": "<p>and if I were to target one of these systems then is there some kind of bound on how large the proofs would become in terms of the size of the original Lean proof term?</p>",
        "id": 135758662,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539484927
    },
    {
        "content": "<p>like, a useful bound</p>",
        "id": 135758665,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539484935
    },
    {
        "content": "<p>no, but the problem in that case is not substitution</p>",
        "id": 135758681,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539484952
    },
    {
        "content": "<p>it is reduction</p>",
        "id": 135758682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539484957
    },
    {
        "content": "<p>oh right</p>",
        "id": 135758684,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539484961
    },
    {
        "content": "<p>you can prove ridiculous theorems by <code>rfl</code> in lean</p>",
        "id": 135758687,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539484971
    },
    {
        "content": "<p>If you deduplicate the proof I think substitution is a \"modest\" overhead, maybe linear in the proof</p>",
        "id": 135758714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539485034
    },
    {
        "content": "<p>how about something like linear in the size of the term plus the total number of reduction steps Lean has to do (if that makes sense)</p>",
        "id": 135758715,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539485035
    },
    {
        "content": "<p>My favorite characterization is \"linear in the run time of the lean checker\"</p>",
        "id": 135758756,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539485067
    },
    {
        "content": "<p>Sure</p>",
        "id": 135758757,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539485073
    },
    {
        "content": "<p>You need substitution of some kind built in to your system so that you can express a proof schema like \"|- P and |- P -&gt; Q implies |- Q`</p>",
        "id": 135758815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539485194
    },
    {
        "content": "<p>but direct substitution is good enough</p>",
        "id": 135758818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539485208
    },
    {
        "content": "<p>Okay this was going to be exactly my next question: do I need some kind of substitution</p>",
        "id": 135758819,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539485214
    },
    {
        "content": "<p>Actually metamath also has a primitive notion of \"disjoint variables\" used in substitution</p>",
        "id": 135758823,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539485224
    },
    {
        "content": "<p>Well</p>",
        "id": 135758824,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539485225
    },
    {
        "content": "<p>meaning that you can say \"P can be substituted for any expression not containing x\"</p>",
        "id": 135758829,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539485257
    },
    {
        "content": "<p>again, this is grep style, so no provisos like \"no free x\", just \"no x at all\"</p>",
        "id": 135758872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539485293
    },
    {
        "content": "<p>but that is good enough since you can build the rest into the proof system</p>",
        "id": 135758875,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539485310
    },
    {
        "content": "<p>this particular example though is substituting into a fixed formula, right? I could imagine representing it by a constructor of an inductive type</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">|</span> <span class=\"n\">mp</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">formula</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"k\">proof</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pq</span> <span class=\"o\">:</span> <span class=\"k\">proof</span> <span class=\"o\">(</span><span class=\"n\">formula</span><span class=\"bp\">.</span><span class=\"n\">imp</span> <span class=\"n\">P</span> <span class=\"n\">Q</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"k\">proof</span> <span class=\"n\">Q</span>\n</pre></div>",
        "id": 135758885,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539485318
    },
    {
        "content": "<p>yes, here you have lifted the substitution to the beta rule of the metatheory (which is lean, I guess)</p>",
        "id": 135758910,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539485382
    },
    {
        "content": "<p>which is just a built-in part of the syntax of proofs</p>",
        "id": 135758912,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539485386
    },
    {
        "content": "<p>But then, I don't know how to deal with \"forall elim\" without invoking substitution in a more serious way</p>",
        "id": 135758952,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539485404
    },
    {
        "content": "<p>right, you need a true substitution there... but you can get around it with some different axiomatizations</p>",
        "id": 135758958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539485438
    },
    {
        "content": "<p>I think the safest/easiest way to do this while still being transparent about it is to have a judgment <code>P(x |-&gt; y) is Q</code></p>",
        "id": 135758967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539485495
    },
    {
        "content": "<p>although when you get to the bottom you have to deal with <code>z(x |-&gt; y)</code> which depends on a disjointness requirement</p>",
        "id": 135759010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539485541
    },
    {
        "content": "<p>which can be equality if you have decidable equality on the variables</p>",
        "id": 135759014,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539485557
    },
    {
        "content": "<p>metamath takes a more abstract approach and just axiomatizes what this \"disjointness\" should satisfy</p>",
        "id": 135759020,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539485586
    },
    {
        "content": "<p>Yes that's fine. This looks interesting.</p>",
        "id": 135759023,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539485591
    },
    {
        "content": "<p>So I have a rule of inference that takes <code>forall x, P x</code> and <code>y</code> and <code>P(x |-&gt; y) is Q</code> and concludes <code>Q</code></p>",
        "id": 135759034,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539485632
    },
    {
        "content": "<p>right</p>",
        "id": 135759039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539485638
    },
    {
        "content": "<p>and <code>P(x |-&gt; y) is Q</code> is also defined by some other induction</p>",
        "id": 135759082,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539485645
    },
    {
        "content": "<p>right</p>",
        "id": 135759085,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539485650
    },
    {
        "content": "<p>I like this.<br>\nIs this likely to mess up the \"size of proof is linear in the Lean kernel runtime\" property?</p>",
        "id": 135759092,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539485677
    },
    {
        "content": "<p>no</p>",
        "id": 135759094,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539485684
    },
    {
        "content": "<p>because lean has to do this too</p>",
        "id": 135759096,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539485693
    },
    {
        "content": "<p>oh, I see!</p>",
        "id": 135759101,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539485703
    },
    {
        "content": "<p>You can have a similar induction rule for deducing <code>x is free in P</code> for the elim rules</p>",
        "id": 135759173,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539485841
    },
    {
        "content": "<p>By the way metamath <a href=\"http://us.metamath.org/mpeuni/mmset.html#pcaxioms\" target=\"_blank\" title=\"http://us.metamath.org/mpeuni/mmset.html#pcaxioms\">doesn't do it this way</a>, instead it uses a slightly tricky axiom system for pred calc that allows us to deduce these judgments without building them in directly, and lets the forall rule be the simple <code>|- (forall x, P) -&gt; P</code></p>",
        "id": 135759369,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539486216
    },
    {
        "content": "<p>But I think this is something like the difference between listing 20 obvious axioms for boolean algebras vs listing 3 incomprehensible ones and proving they are equivalent</p>",
        "id": 135759489,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539486377
    },
    {
        "content": "<p>So here is one reason why I have this question.<br>\nCryptography people tell me (not in this language of course, and I hope I am not mistranslating anything) that if I have some fancy indexed inductive type <code>proof P</code>, I can design some functions f, g and h with the following properties.</p>\n<ul>\n<li>f is a predicate on short strings (~300 bytes) which can be evaluated quickly (~20ms).</li>\n<li>g is some even cheaper function on such strings, and h(P) is just a recursive hash of the contents of P.</li>\n<li>Given a term of type <code>proof P</code> I can calculate a string x with f(x) = true and g(x) = h(P).</li>\n<li>(Subject to some trusted setup and cryptographic hardness assumptions,) the only way to construct such an x is as above: I have to really know a term of type <code>proof P</code>, though I can also use other pairs (Q, y) which have been published as certificates of other statements as inputs to my term.</li>\n</ul>\n<p>The catch is that the third item is somewhat ridiculously expensive, though in the future it may become less ridiculously expensive.</p>",
        "id": 135759619,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539486634
    },
    {
        "content": "<p>As a ballpark estimate for ridiculously expensive, assume 1 constructor costs 1 second to compute</p>",
        "id": 135759630,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539486701
    },
    {
        "content": "<p>so I guess x is a \"proof hash\" of some sort, f means \"this is a proof of something\" and g means \"this is the statement that is being proved\"?</p>",
        "id": 135759688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539486814
    },
    {
        "content": "<p>Right</p>",
        "id": 135759689,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539486824
    },
    {
        "content": "<p>Probably it is a bit better to think that the \"proof hash\" is a statement like \"this is a proof of some statement which hashes to H\"</p>",
        "id": 135759757,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539486915
    },
    {
        "content": "<p>I'm surprised the function g is easy</p>",
        "id": 135759809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539486963
    },
    {
        "content": "<p>it's not even that easy to calculate the statement of a proof sometimes</p>",
        "id": 135759818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539486996
    },
    {
        "content": "<p>I think that g can just be extracting some of the bits from the string though I confess I have not thought much about this particular aspect yet</p>",
        "id": 135759821,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539487008
    },
    {
        "content": "<p>I guess you can do something like that</p>",
        "id": 135759828,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539487026
    },
    {
        "content": "<p>I think the idea is that it was the job of the person producing the proof to include the information of what is being proved</p>",
        "id": 135759830,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539487041
    },
    {
        "content": "<p>This is really at a super early stage of \"is it even conceivable that one could use this for theorem proving\"--I'm trying to get a sense of what the minimal demands on the theorem proving side are</p>",
        "id": 135759883,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539487134
    },
    {
        "content": "<p>What I find to be really remarkable about these setups is that the cost to verify a proof is independent of the size of the proof</p>",
        "id": 135759891,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539487166
    },
    {
        "content": "<p>that's a good point. I wonder whether it can be used as a trusted alternative to caching</p>",
        "id": 135759944,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539487231
    },
    {
        "content": "<p>So, ignoring some inconvenient details like the ~1000000x slowdown, you could use it as part of a \"distributed theorem verification system\", without requiring trusted provers</p>",
        "id": 135759954,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539487257
    },
    {
        "content": "<p>(Concretely, you could imagine some kind of database to which anyone can upload proof certificates, with the amazing property that in order to verify the correctness of any proof, you only need to check <em>that certificate</em> and not the proofs of any of the results which the proof relies on)</p>",
        "id": 135760023,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539487383
    },
    {
        "content": "<p>Unless they decided to modify <code>logic.basic</code> :)</p>",
        "id": 135760029,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539487441
    },
    {
        "content": "<p>In some sense we already have this, the difference is that you can do this check without even precomputing the proofs of earlier parts, or even knowing what the proofs are (e.g. proprietary proofs)</p>",
        "id": 135760085,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539487552
    },
    {
        "content": "<p>I think what we have is like a non-distributed version of this, where I trust the Lean kernel on my machine to only record as theorems the facts which it has checked. Or do you mean something else?</p>",
        "id": 135760134,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539487621
    },
    {
        "content": "<p>Solving the recompilation problem is somehow close to but not exactly the same as the problem this solves, I think.</p>",
        "id": 135760191,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539487698
    },
    {
        "content": "<p>That's true, but I'm pointing out that if you have mathlib, say, fully compiled, then you are currently in the state of trusting all the results in it, and if a new proof comes along that depends on these facts you only have to check <em>that proof</em> and not the rest of the library</p>",
        "id": 135760192,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539487704
    },
    {
        "content": "<p>In this crypto setup compilation is being replaced by certificate generation</p>",
        "id": 135760197,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539487751
    },
    {
        "content": "<p>where the difference is that if I send you a certificate you can have the same trust as if you created it yourself, while if I send you my compiled files then you don't know that I haven't tampered with them</p>",
        "id": 135760251,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539487820
    },
    {
        "content": "<p>Yes exactly</p>",
        "id": 135760254,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539487848
    },
    {
        "content": "<p>And if we had some massive proof of say FLT, then maybe it would be quite expensive for everyone to verify the whole proof, whether or not they do it incrementally over time. If the certificates can be computed by someone just once, then you can save total work (assuming there are &gt; 1000000 people who want to verify the proof)</p>",
        "id": 135760271,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539487918
    },
    {
        "content": "<p>I think this isn't a realistic threat model though</p>",
        "id": 135760330,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539488017
    },
    {
        "content": "<p>Anyways, I think that today we're not really anywhere close to wanting something like this, and the technology is also not really that feasible yet</p>",
        "id": 135760331,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539488022
    },
    {
        "content": "<p>Which part is not realistic?</p>",
        "id": 135760372,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539488058
    },
    {
        "content": "<p>I think when people get mathlib they usually don't do it because they want additional assurance that the theorems in it are true</p>",
        "id": 135760373,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539488063
    },
    {
        "content": "<p>Well not for mathlib</p>",
        "id": 135760374,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539488073
    },
    {
        "content": "<p>I am pretty sure that feit thompson is true because Gonthier checked it, and my running it on my machine did not increase my confidence in the theorem as much as it increased my confidence that I had installed Coq correctly</p>",
        "id": 135760385,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539488147
    },
    {
        "content": "<p>In some distant future world, you could imagine that instead of posting papers to arXiv, we publish formal proofs to some other service. I guess your claim is that in that scenario, you are not too worried about people claiming to publish proofs which are in fact bogus.</p>",
        "id": 135760427,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539488190
    },
    {
        "content": "<p>Especially given that anyone <em>could</em> verify the proof and everything underneath it, it would just be quite expensive for everybody to do so.</p>",
        "id": 135760434,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539488229
    },
    {
        "content": "<p>I would want the service to be spending effort on checking for bogus proofs</p>",
        "id": 135760438,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539488243
    },
    {
        "content": "<p>that's not my responsibility</p>",
        "id": 135760443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539488255
    },
    {
        "content": "<p>Right, you could delegate to the service to check correctness which seems quite reasonable</p>",
        "id": 135760447,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539488276
    },
    {
        "content": "<p>I would be responsible for convincing myself that the service is doing its job to my satisfaction</p>",
        "id": 135760487,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539488290
    },
    {
        "content": "<p>meaning that this service should be easily checkable (i.e. small trusted kernel)</p>",
        "id": 135760492,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539488327
    },
    {
        "content": "<p>Plus you have to trust the people who operate the service to actually verify the proofs</p>",
        "id": 135760508,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539488391
    },
    {
        "content": "<p>I think there is room for some crypto cross checks at this point</p>",
        "id": 135760567,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539488450
    },
    {
        "content": "<p>i.e. the process of verification by the service also produces a certificate that I can check quickly</p>",
        "id": 135760577,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539488475
    },
    {
        "content": "<p>In general the way to produce a certificate that a computation was done correctly is the same process that I am talking about for generating proof certificates.</p>",
        "id": 135760625,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539488533
    },
    {
        "content": "<p>Although nowadays this check is replaced with me being able to download and check the proof myself if I want</p>",
        "id": 135760636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539488577
    },
    {
        "content": "<p>(Namely, SNARKs and applications like TinyRAM)</p>",
        "id": 135760637,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539488579
    },
    {
        "content": "<p>Right so in actual crypto applications, there is the far more important property that the person producing the certificate doesn't have to give you the proof.</p>",
        "id": 135760645,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539488609
    },
    {
        "content": "<p>As I mentioned, this stuff is currently quite impractical for large applications.<br>\nProbably a far more practical question would be: could Lean have a mode where it checks a given olean file against lean source, and is this faster than trying to recompute the proof from scratch.</p>",
        "id": 135760711,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539488745
    },
    {
        "content": "<p>Or more generally, what information could Lean write out to an .olean or other external certificate file which would make verifying the validity of a theorem more efficient</p>",
        "id": 135760762,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539488807
    },
    {
        "content": "<p>In principle lean should be able to check an olean file without reference to a lean file at all</p>",
        "id": 135760873,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539489042
    },
    {
        "content": "<p>and if you wanted you could view this as a \"compiled file\" same as the compiled binaries of any other program</p>",
        "id": 135760883,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539489072
    },
    {
        "content": "<p>in particular, it would be difficult to reverse engineer the sources from this</p>",
        "id": 135760886,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539489091
    },
    {
        "content": "<p>... I think. I need to write an olean viewer to be sure</p>",
        "id": 135760890,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539489121
    },
    {
        "content": "<p>Do .olean files and the export textual format and what <code>#print foo</code> produces all contain roughly the same information?</p>",
        "id": 135760994,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539489323
    },
    {
        "content": "<p>looking at the export format it seems not to include all information about notation, which must be in .olean files, but aside from minor details like that</p>",
        "id": 135761081,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539489492
    },
    {
        "content": "<p>I think so</p>",
        "id": 135761088,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539489553
    },
    {
        "content": "<p>It should have the information necessary to construct an <code>environment</code> object from the imported environments</p>",
        "id": 135761089,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539489583
    },
    {
        "content": "<p>I wonder whether there is a way today to convince Lean to export an .olean file to textual format</p>",
        "id": 135761091,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539489588
    },
    {
        "content": "<p>That would be nice... I probably wouldn't even write such an exporter in lean</p>",
        "id": 135761139,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539489625
    },
    {
        "content": "<p>(that is, there is no particular advantage to writing it in lean)</p>",
        "id": 135761151,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539489659
    },
    {
        "content": "<p>I guess you could import the module for which you had the .olean from a new module, and then run it through <code>lean --export</code></p>",
        "id": 135761215,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539489798
    },
    {
        "content": "<p>it seems to work</p>",
        "id": 135761310,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539489969
    },
    {
        "content": "<p>though I wouldn't be 100% confident that lean importing an arbitrary .olean file and then exporting its contents and checking them in an external checker means lean is actually in a valid state after reading the .olean file</p>",
        "id": 135761322,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539490027
    },
    {
        "content": "<p>why? The checker doesn't matter for that</p>",
        "id": 135761702,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539490851
    },
    {
        "content": "<p>Lean itself will complain if the olean is bad</p>",
        "id": 135761703,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539490862
    },
    {
        "content": "<p>although I'm not sure how you can induce that without writing the olean bits manually, since lean won't produce olean files for errored files</p>",
        "id": 135761709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539490893
    },
    {
        "content": "<blockquote>\n<p>I want a human-verifiable procedure for taking a theorem statement and turning it into a formula in some other system, and also a procedure for turning the Lean proof into a valid proof in the other system</p>\n</blockquote>\n<p>My understanding (which may be wrong) is: Computer scientists want (and occasionally some claim that they have built) a procedure for translating code written in one common language to code written in another common language, and the reason none of these procedures are ever used in practice is that in practice they are typically not very good at all.</p>\n<blockquote>\n<p>I am pretty sure that feit thompson is true because Gonthier checked it, and my running it on my machine did not increase my confidence in the theorem as much as it increased my confidence that I had installed Coq correctly</p>\n</blockquote>\n<p>My understanding (which is much more likely to be correct this time) is that Feit Thompson is true because the pure mathematics community did an <em>extremely</em> good job of checking it in the 1960s, decided it was correct, and awarded Thompson the Fields Medal as a consequence. This is exactly why pure mathematicians are not excited by Gonthier et al's verification. Checking 400 pages of lemmas about finite groups and undergraduate/MSc level representation theory and number theoy is not difficult for a team of humans to do, it can be broken down into manageable sub-jobs etc.</p>",
        "id": 135771923,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539512577
    },
    {
        "content": "<p>Yeah, but I didn't understand what Thompson did at all, I at least have some idea of how Gonthier did it</p>",
        "id": 135772552,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539513629
    },
    {
        "content": "<p>I think you should not forget that one of the applications of formal mathematics is that at least in principle you can pick it up and read it from <em>zero</em> prior knowledge of the field</p>",
        "id": 135772564,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539513709
    },
    {
        "content": "<p>And I know several people who did exactly that, including myself</p>",
        "id": 135772607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539513739
    },
    {
        "content": "<p>(Note that that quote was about my subjective perception of the truth of the theorem, not the mathematics community at large.) The whole point of this crypto stuff is that just because <em>you</em> trust X body of knowledge / institution / person doesn't mean <em>I</em> do, and the problem is to figure out how to reliably transfer your trust to me</p>",
        "id": 135772725,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539514010
    },
    {
        "content": "<p>Aah I see! So this is a perfect analogy. I say \"I am a mathematician and my tribe can guarantee that Feit-Thompson is proved\" and you reply \"I am a computer scientist and I require a different kind of justification than just assurances from your tribe\".</p>",
        "id": 135776718,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539522024
    },
    {
        "content": "<blockquote>\n<p>I think you should not forget that one of the applications of formal mathematics is that at least in principle you can pick it up and read it from <em>zero</em> prior knowledge of the field</p>\n</blockquote>\n<p>I thought mathlib didn't care about human readability?</p>",
        "id": 135776739,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1539522090
    },
    {
        "content": "<p>I'm talking about formal proof in general. Certainly it's more true of metamath than mathlib, because there are fewer skipped steps</p>",
        "id": 135776942,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539522369
    },
    {
        "content": "<p>The point is that it doesn't matter if it's been written to be human readable in the mathematician's sense. In fact, it's better if it doesn't make too much use of tactics that do what Kevin wants (i.e. trivial for a mathematician steps omitted)</p>",
        "id": 135776974,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539522466
    },
    {
        "content": "<p>because that way you can follow what's happening even if you aren't a mathematician</p>",
        "id": 135777021,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539522496
    },
    {
        "content": "<p>the worst kind of proof for people who want to learn like this are the big complicated statement proven by some blasty tactic. It's like the movie ends just as it's setting up for the climax, you feel robbed</p>",
        "id": 135777103,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539522697
    },
    {
        "content": "<p>luckily lean doesn't have too many blasty tactics yet, so it is still feasible to read a proof and get the details</p>",
        "id": 135777177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539522807
    },
    {
        "content": "<p>I have been telling my maths students to never read any proofs in mathlib because they are all unreadable, and if they want to know why some theorem is true then to look it up on Wikipedia, which is written for humans. I am the anti-Paulson. I believe that proofs generated by computers in the future will inevitably be unreadable, and that anyone who attempts to make them readable will in some sense be holding the area back. I was always struck by something Johannes said to me months ago when I asked him why he'd changed my 10 line tactic proof into an incomprehensible two-line term proof, and he replied that he liked the challenge of finding a short efficient proof of something which was easy in maths. While he might not want to extrapolate this comment himself to longer proofs, I don't mind doing so.</p>",
        "id": 135777934,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539523920
    },
    {
        "content": "<p>My view is that there is a kind of readability that can't be harmed by \"unreadable\" proof style</p>",
        "id": 135778173,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539524254
    },
    {
        "content": "<p>because the information is still there to be given to the computer</p>",
        "id": 135778177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539524276
    },
    {
        "content": "<p>and there are some enterprising kids that actually prefer this kind of exactitude to the \"aimed for human level\" style that is traditional in maths</p>",
        "id": 135778228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539524332
    },
    {
        "content": "<p>This is where stuff like <code>#explode</code> is useful, when you just want to see EVERYTHING and make your own choices about what is important</p>",
        "id": 135778285,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539524416
    },
    {
        "content": "<p>rather than whatever the author thought was important or trivial</p>",
        "id": 135778292,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539524439
    },
    {
        "content": "<blockquote>\n<p>I have been telling my maths students to never read any proofs in mathlib because they are all unreadable, and if they want to know why some theorem is true then to look it up on Wikipedia, which is written for humans.</p>\n</blockquote>\n<p>I just did the exercise of reading the Wikipedia page on <a href=\"https://en.wikipedia.org/wiki/Topological_ring\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Topological_ring\">topological rings</a>. It's full of plain wrong statements...</p>",
        "id": 135780253,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1539527887
    },
    {
        "content": "<p>You have a clear choice then :-) Human efforts with wrong statements, or <code>topological_structures.lean</code> written by Johannes and never meant to be read by a mathematician :-) Pure maths is two things and you are lucky enough to be able to choose which one you like best.</p>",
        "id": 135786040,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539537782
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> I find this topic of cryptographic proof certificates really interesting! Do you know if anything like this has been implemented for some theorem prover? I've thought about this on and off (basically as an amateur) and I couldn't find anything written about it. Are there references that go beyond speculating how nice it would be to have this? From Reid's description it is still quite a leap to an actual (fast) implementation.</p>",
        "id": 135797803,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539560133
    }
]
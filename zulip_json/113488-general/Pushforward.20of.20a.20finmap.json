[
    {
        "content": "<p>A message was moved here from <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general/topic/.E2.84.95.20.E2.89.A0.20.E2.84.A4\">#general &gt; ℕ ≠ ℤ</a> by <span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span>.</p>",
        "id": 318927518,
        "sender_full_name": "Notification Bot",
        "timestamp": 1672628096
    },
    {
        "content": "<p><del>docs#finsupp.map_domain or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finsupp.emb_domain\">docs#finsupp.emb_domain</a>?</del></p>",
        "id": 318954814,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1672649924
    },
    {
        "content": "<p>Feels like this useful function is missing from the library:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">finmap.equiv_finset_fun</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">finmap</span> <span class=\"n\">F</span> <span class=\"bp\">≃</span> <span class=\"bp\">Σ'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">F</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 318957516,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1672651298
    },
    {
        "content": "<p>I tried implementing that but ran into a problem: when transforming the <code>finset α</code>, I have no way to generate the proof that <code>x ∈ s</code>. I think the fundamental issue is that when I use <code>quot.lift</code>, while I am perfectly able to generate a proof that <code>x ∈ l</code> for some inner value <code>l</code>, there doesn’t appear to be a way to convert that to an <code>x ∈ s</code>, because <code>l</code> and <code>s</code> are totally unrelated in the type system.</p>",
        "id": 319082564,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1672685993
    },
    {
        "content": "<p>Here was my code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">finmap.equiv_finset_fun</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">finmap</span> <span class=\"n\">F</span> <span class=\"bp\">≃</span> <span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">F</span> <span class=\"n\">x</span>\n<span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">map</span><span class=\"o\">,</span> <span class=\"o\">{</span>\n    <span class=\"n\">fst</span> <span class=\"o\">:=</span> <span class=\"n\">map.keys</span><span class=\"o\">,</span>\n    <span class=\"n\">snd</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">x_mem</span><span class=\"o\">,</span> <span class=\"n\">option.get</span> <span class=\"o\">(</span><span class=\"n\">finmap.lookup_is_some.mpr</span> <span class=\"n\">x_mem</span><span class=\"o\">),</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">pair</span><span class=\"o\">,</span> <span class=\"o\">{</span>\n    <span class=\"n\">entries</span> <span class=\"o\">:=</span> <span class=\"n\">pair.fst.val.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">pair.snd</span> <span class=\"n\">key</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩),</span>\n    <span class=\"c1\">--                                                     ^^^^^</span>\n    <span class=\"c1\">--                                        Have to show that key ∈ pair.fst</span>\n    <span class=\"n\">nodupkeys</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n      <span class=\"gr\">sorry</span>\n    <span class=\"kd\">end</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 319082757,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1672686081
    },
    {
        "content": "<p><code>multiset.map</code> wants to eat a map defined on all of the domain so perhaps that's not an appropriate thing to use here in your definition of <code>entries</code>.</p>",
        "id": 319083475,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672686464
    },
    {
        "content": "<p>I did try also to make my own <code>map</code> that gives an <code>elem ∈ s</code> guarantee, but ran into the same problem pretty much:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">list.map_mem</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">elem</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">β</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"n\">mapper</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">head</span> <span class=\"o\">::</span> <span class=\"n\">tail</span><span class=\"o\">)</span> <span class=\"n\">mapper</span> <span class=\"o\">:=</span> <span class=\"n\">mapper</span> <span class=\"n\">head</span> <span class=\"o\">(</span><span class=\"n\">list.mem_cons_self</span> <span class=\"n\">head</span> <span class=\"n\">tail</span><span class=\"o\">)</span>\n  <span class=\"o\">::</span> <span class=\"n\">list.map_mem</span> <span class=\"n\">tail</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">elem</span> <span class=\"n\">mem</span><span class=\"o\">,</span> <span class=\"n\">mapper</span> <span class=\"n\">elem</span> <span class=\"o\">(</span><span class=\"n\">list.mem_cons_of_mem</span> <span class=\"n\">head</span> <span class=\"n\">mem</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">multiset.map_mem</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mapper</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">elem</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">β</span>\n<span class=\"o\">:=</span> <span class=\"n\">quot.lift_on</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">l.map_mem</span> <span class=\"n\">mapper</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n<span class=\"c1\">--                                          ^^^^^^</span>\n<span class=\"c1\">-- Type error here: somehow, I need to convert the mapper that accepts `elem ∈ s` into a mapper that</span>\n<span class=\"c1\">-- accepts `elem ∈ l`.</span>\n</code></pre></div>",
        "id": 319083746,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1672686650
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"n\">entries</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">classical</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">finset.image</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">pair.1</span><span class=\"o\">),</span> <span class=\"o\">(⟨</span><span class=\"n\">x.1</span><span class=\"o\">,</span> <span class=\"n\">pair.2</span> <span class=\"n\">_</span> <span class=\"n\">x.2</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">sigma</span> <span class=\"n\">F</span><span class=\"o\">))</span> <span class=\"n\">finset.univ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span><span class=\"c1\">--{ σ : sigma F | ∃ (a : α) (ha : a ∈ pair.1), σ.fst = a ∧ σ.snd == pair.2 a ha},</span>\n</code></pre></div>\n<p>but it assumes decidable equality on <code>sigma F</code>. Another approach would be to prove that the map from pair.1 (promoted to a type, which is what I'm doing here to avoid the problem you're seeing) to sigma F coming from pair.2 is injective and then you can use <a href=\"http://finset.map\">finset.map</a> and perhaps get computability back if it's important to you.</p>",
        "id": 319084948,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672687374
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"574896\">Sabrina Jewson</span> <a href=\"#narrow/stream/113488-general/topic/Pushforward.20of.20a.20finmap/near/319082564\">said</a>:</p>\n<blockquote>\n<p>I tried implementing that but ran into a problem: when transforming the <code>finset α</code>, I have no way to generate the proof that <code>x ∈ s</code>.</p>\n</blockquote>\n<p>Does <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.attach\">docs#finset.attach</a> help?</p>",
        "id": 319088144,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1672689284
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/Pushforward.20of.20a.20finmap/near/319088144\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"574896\">Sabrina Jewson</span> <a href=\"#narrow/stream/113488-general/topic/Pushforward.20of.20a.20finmap/near/319082564\">said</a>:</p>\n<blockquote>\n<p>I tried implementing that but ran into a problem: when transforming the <code>finset α</code>, I have no way to generate the proof that <code>x ∈ s</code>.</p>\n</blockquote>\n<p>Does <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.attach\">docs#finset.attach</a> help?</p>\n</blockquote>\n<p>Through that link I was able to discover <a href=\"https://leanprover-community.github.io/mathlib_docs/find/multiset.pmap\">docs#multiset.pmap</a> which seems to be basically exactly what I want:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">entries</span> <span class=\"o\">:=</span> <span class=\"n\">pair.1.val.pmap</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">elem</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">elem_mem</span> <span class=\"o\">:</span> <span class=\"n\">elem</span> <span class=\"bp\">∈</span> <span class=\"n\">pair.1.val</span><span class=\"o\">),</span> <span class=\"o\">⟨</span><span class=\"n\">elem</span><span class=\"o\">,</span> <span class=\"n\">pair.2</span> <span class=\"n\">elem</span> <span class=\"n\">elem_mem</span><span class=\"o\">⟩)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">elem</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"o\">),</span>\n</code></pre></div>\n<p>Thanks a lot :D! And thanks Kevin too, that’s a really elegant solution.</p>",
        "id": 319089885,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1672690304
    }
]
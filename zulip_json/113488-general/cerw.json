[
    {
        "content": "<p>I am a complete newbie when it comes to tactic writing. Here is a request for a tactic, and I have no idea how realistic it is. Suppose I have an isomorphism <code>h : X ≅ Y</code> in some category <code>C</code>. And suppose I have some other term <code>foo : bar X</code>, then I would like to have a tactic <code>cerw</code> (category-<code>erw</code>) that tries to figure out if <code>bar</code> is some sort of <code>category_theory.functor.obj</code> and if so, replaces <code>X</code> with <code>Y</code>.<br>\nI realise this request is a bit vague. I would be happy to flesh out the details.</p>",
        "id": 147925618,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1542565380
    },
    {
        "content": "<p>HI Johan,</p>",
        "id": 147929231,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542572011
    },
    {
        "content": "<p>I started writing this, as <code>iso_induction</code>.</p>",
        "id": 147929239,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542572021
    },
    {
        "content": "<p>This is intended as my start of an answer to all our questions about transport of structure.</p>",
        "id": 147929248,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542572041
    },
    {
        "content": "<p>It is not at all done, but it is certainly doable, and I would love to do it!</p>",
        "id": 147929296,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542572058
    },
    {
        "content": "<p>Have a look at <a href=\"https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/iso_induction.lean\" target=\"_blank\" title=\"https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/iso_induction.lean\">https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/iso_induction.lean</a></p>",
        "id": 147929420,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542572278
    },
    {
        "content": "<p>for the idea</p>",
        "id": 147929421,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542572280
    },
    {
        "content": "<p>It is not quite that same as <code>iso_rw</code>, but the same tooling would be required to make that work.</p>",
        "id": 147929468,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542572333
    },
    {
        "content": "<p><code>iso_induction</code> takes a hypotheses <code>X \\iso Y</code>, and tries to replace all appearances of <code>X</code> with <code>Y</code>, by writing everything in a form where <code>X</code> appears as the argument of a functor.</p>",
        "id": 147929531,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542572404
    },
    {
        "content": "<p>Cool. That's going to be very useful!</p>",
        "id": 147946598,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1542606056
    },
    {
        "content": "<p>I am afraid that <code>monoid.ext</code> will be considered intollerable abuse of the type class system.</p>",
        "id": 147946650,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1542606182
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>, what's wrong with <code>monoid.ext</code>?</p>\n<div class=\"codehilite\"><pre><span></span>@[extensionality] lemma monoid.ext {α : Type u} (m n : monoid α)\n  (mul : ∀ x y : α, (by haveI := m; exact x * y) = (by haveI := n; exact x * y)) : m = n :=\n</pre></div>",
        "id": 147951652,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542615448
    },
    {
        "content": "<p>looks good to me</p>",
        "id": 147951699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1542615491
    },
    {
        "content": "<p>Is it the two different uses of <code>haveI</code> that you're worried about?</p>",
        "id": 147951701,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542615497
    },
    {
        "content": "<p>Aah, wait. You aren't actually asking that there are two instances of <code>monoid α</code></p>",
        "id": 147951704,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1542615506
    },
    {
        "content": "<p>I read to fast.</p>",
        "id": 147951707,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1542615513
    },
    {
        "content": "<p>No, no square brackets for this lemma!</p>",
        "id": 147951709,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542615519
    },
    {
        "content": "<p>do you have groupoids? that's an obvious thing to prove about <code>isos</code></p>",
        "id": 147951792,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1542615671
    },
    {
        "content": "<p>also it's not clear to me why <code>monoid_transport</code> isn't proven directly and it becomes the map part of <code>monoid_type_constructor</code></p>",
        "id": 147951911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1542615850
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>, resuming an old thread about transport of structure along isomorphisms, I wonder if you could have a look at <a href=\"https://github.com/leanprover-community/mathlib/blob/a3d685fd6b12f86ac4e31b344d6405e30268e4f4/test/iso_induction.lean\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/a3d685fd6b12f86ac4e31b344d6405e30268e4f4/test/iso_induction.lean\">tests/iso_induction.lean</a> on the <code>iso_induction</code> branch. In particular, my idea is that it may be possible to synthesise things like <code>submodule_functor</code>, <code>ideal_functor</code>, and <code>is_local_functor</code>, stubbed out in the file, completely automatically.</p>\n<p>If that's the case, then being able to prove <code>is_local_ring S</code> given hypotheses <code>h : is_local_ring R</code> and <code>f : R \\iso S</code> should be pretty doable via tactics that look like <code>iso_subst f; exact h</code>.</p>\n<p>Really the question becomes --- if you look in the partial proofs of <code>submodule_functor</code> I've been writing, can you write down _exactly_ why every mathematician knows exactly what to do at every step? :-) This is the sort of thing <code>tidy</code> is aimed at, but it's not up to the task quite yet.</p>",
        "id": 161111092,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1552957382
    },
    {
        "content": "<p>Did you see Mario's effort on this question? My lean time has been 100% taken up with perfectoids recently so I didn't look at it</p>",
        "id": 161111356,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552957702
    },
    {
        "content": "<p>No, maybe I didn't... <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, could you give me a pointer?</p>",
        "id": 161111388,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1552957762
    },
    {
        "content": "<p>(Have to disappear for a few hours, but I'll read up afterwards.)</p>",
        "id": 161111397,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1552957788
    },
    {
        "content": "<p><a href=\"#narrow/stream/116395-maths/topic/Perfectoid.20spaces/near/159808751\" title=\"#narrow/stream/116395-maths/topic/Perfectoid.20spaces/near/159808751\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfectoid.20spaces/near/159808751</a></p>",
        "id": 161111484,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552957859
    },
    {
        "content": "<p>Okay, that is cool. :-)</p>",
        "id": 161111781,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1552958203
    },
    {
        "content": "<p>A lot of automation is going to be needed still, before the mathematicians can cope with this. :-)</p>",
        "id": 161111805,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1552958232
    },
    {
        "content": "<p>right, this was really an exercise in finding out what major infrastructure components were missing in the automation we all expect</p>",
        "id": 161111915,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552958352
    },
    {
        "content": "<p><code>equiv.rel</code> in particular turned out to be important</p>",
        "id": 161111924,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552958371
    },
    {
        "content": "<p>eventually, <code>transfer</code> should be able to do the job of proving the last few theorems, although stuff about transferring ideals and other things will all need to be explicitly stated, at least, and marked for use with <code>transfer</code></p>",
        "id": 161111996,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552958427
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I'll try to write up the kind of proofs that I expect <code>tidy</code> to generate</p>",
        "id": 161126312,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552979398
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>, maybe it's not worth doing any now. The functoriality argument for <code>submodule</code> needs to rely on deeper layers of functoriality, anyway. May I should try writing the actual <code>iso_subst</code> and <code>iso_rw</code>tactic, because they'll in turn be used by the <code>[derive]</code> handler for functoriality and iso_functoriality instances...</p>",
        "id": 161130454,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1552984279
    },
    {
        "content": "<p>Also, I need to understand Mario's approach properly. I haven't understood yet how general it will be. (I'm initially a little worried taking about ring equivalences, and monoid equivalences, and .... all separately, rather than building the machinery abstractly at the level of isomorphisms in some category, but maybe I don't know what I'm talking about here. :-)</p>",
        "id": 161130529,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1552984366
    },
    {
        "content": "<p>I wanted to do some linear_ordered_comm_group equivalences for the perfectoid project and I've been slowly but surely writing <code>monoid_equiv</code>, <code>group_equiv</code>, <code>le_equiv</code>, <code>mul_equiv</code>, <code>add_group_equiv</code>, ...</p>",
        "id": 161134135,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552987972
    },
    {
        "content": "<p>Hmmm... use bundled objects, bundled morphisms, set up the category instances, and get for free uniform notation and lemmas for all these notions of equivalence. I'm not really sure how plausible it is, but it seems a desirable goal.</p>",
        "id": 161136269,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1552990076
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I've documented my attempt in a copy of your file. Pushed to the branch.</p>",
        "id": 161136889,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552990634
    },
    {
        "content": "<p>It stops halfway because things got annoying.</p>",
        "id": 161136898,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552990646
    },
    {
        "content": "<p>And because you said that I maybe shouldn't do it anyway <span aria-label=\"lol\" class=\"emoji emoji-1f606\" role=\"img\" title=\"lol\">:lol:</span></p>",
        "id": 161136906,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552990665
    },
    {
        "content": "<p>...<code>has_zero_equiv</code>, <code>has_one_equiv</code>, ...</p>",
        "id": 161138152,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552991697
    },
    {
        "content": "<p>I had an issue with transferring information along an isomorphism which took me two days of hard work to solve. During this time I learnt what I think might be a valuable lesson, so I'll just document it here.</p>\n<p>If <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">G</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.08125em;\">H</span></span></span></span> are isomorphic groups, and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">J</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span></span></span></span> is a normal subgroup of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">G</span></span></span></span> with corresponding normal subgroups <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07153em;\">K</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.08125em;\">H</span></span></span></span>, then <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi><mi mathvariant=\"normal\">/</mi><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">G/J</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">G</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>H</mi><mi mathvariant=\"normal\">/</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">H/K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.07153em;\">K</span></span></span></span> are isomorphic. </p>\n<p>I proved this in Lean. I set up <code>group_equiv</code> and proved, amongst other things, <code>group_equiv.trans</code>. I then proved that if <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi>G</mi><mo>→</mo><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">\\phi:G\\to H</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\">ϕ</span><span class=\"mrel\">:</span><span class=\"mord mathit\">G</span><span class=\"mrel\">→</span><span class=\"mord mathit\" style=\"margin-right:0.08125em;\">H</span></span></span></span> was a group isomorphism and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07153em;\">K</span></span></span></span> was a normal subgroup of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.08125em;\">H</span></span></span></span> then <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi><mi mathvariant=\"normal\">/</mi><msup><mi>ϕ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>K</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">G/\\phi^{-1}(K)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">G</span><span class=\"mord mathrm\">/</span><span class=\"mord\"><span class=\"mord mathit\">ϕ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mathrm mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">)</span></span></span></span> was isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>H</mi><mi mathvariant=\"normal\">/</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">H/K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.07153em;\">K</span></span></span></span>. This seemed to me like a good idea at the time, but in retrospect I think it was my mistake. I then proved the moronic theorem that if <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">G</span></span></span></span> was a group and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>J</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">J_1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>J</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">J_2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> were two subgroups which were equal, then <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi><mi mathvariant=\"normal\">/</mi><msub><mi>J</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">G/J_1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">G</span><span class=\"mord mathrm\">/</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> was isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi><mi mathvariant=\"normal\">/</mi><msub><mi>J</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">G/J_2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">G</span><span class=\"mord mathrm\">/</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span>. I proved this theorem because I know that ridiculous theorems of this form are sometimes what needs to be done. I then used transitivity to prove the <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi><mi mathvariant=\"normal\">/</mi><mi>J</mi><mo>≅</mo><mi>H</mi><mi mathvariant=\"normal\">/</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">G/J\\cong H/K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">G</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span><span class=\"mrel\">≅</span><span class=\"mord mathit\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.07153em;\">K</span></span></span></span> result and things were fine, until I wanted to start transporting things along the corresponding isomorphism and nothing seemed to unfold nicely and it was a nightmare. </p>\n<p>Independently of working on this quotient issue we were working on another isomorphism issue -- if two integral domains are isomorphic then their fields of fractions are isomorphic. In fact Johan was working on this a couple of weeks ago, and he wrote <a href=\"https://github.com/leanprover-community/mathlib/blob/098c2cb1d1dab5f42260a6fe999abc252ceba313/src/ring_theory/localization.lean#L335\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/098c2cb1d1dab5f42260a6fe999abc252ceba313/src/ring_theory/localization.lean#L335\">equiv_of_equiv</a>. This is a much better approach! This does the entire job in one go -- he has a hypothesis the analogue of which would be <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>ϕ</mi><mo>(</mo><mi>J</mi><mo>)</mo><mo>=</mo><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">\\phi(J)=K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">ϕ</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.07153em;\">K</span></span></span></span>. But preimages are slightly easier to work with than images, because image involves an existence statement which is not there with preimage. In summary then, I think this is the sort of theorem one should prove (and indeed I have proved in the perfectoid project):</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">group_equiv</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">he</span> <span class=\"o\">:</span> <span class=\"n\">group_equiv</span> <span class=\"n\">G</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">normal_subgroup</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">normal_subgroup</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">he</span><span class=\"bp\">.</span><span class=\"n\">to_equiv</span> <span class=\"bp\">⁻¹</span><span class=\"err\">&#39;</span> <span class=\"n\">K</span> <span class=\"bp\">=</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">group_equiv</span> <span class=\"o\">(</span><span class=\"n\">quotient_group</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">quotient_group</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</pre></div>\n\n\n<p>It's interesting to note that all these thoughts about exactly what statements should be proved here are perhaps evidence for mathematicians that things are not quite as simple as they might seem when it comes to <code>transfer</code> or <code>cerw</code> or whatever we're calling it now. \"If <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">G</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.08125em;\">H</span></span></span></span> are isomorphic, with normal subgroups <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">J</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07153em;\">K</span></span></span></span> identified with each other, then <em>obviously</em> <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi><mi mathvariant=\"normal\">/</mi><mi>J</mi><mo>=</mo><mi>H</mi><mi mathvariant=\"normal\">/</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">G/J=H/K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">G</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.07153em;\">K</span></span></span></span>\". Yeah but I've just found out the hard way that formalising this statement and proof the wrong way can cause a lot of pain later down the line.</p>",
        "id": 161336619,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553168062
    },
    {
        "content": "<p>I actually suggest neither preimages nor images, but rather a relation <code>equiv.rel(phi) J K</code></p>",
        "id": 161336748,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1553168207
    },
    {
        "content": "<p>it can be defined to be the preimage equality though</p>",
        "id": 161336800,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1553168266
    },
    {
        "content": "<p>or rather, it is the <code>equiv.rel</code> of the map <code>set J -&gt; set K</code> induced by <code>phi</code></p>",
        "id": 161336873,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1553168325
    },
    {
        "content": "<p>In practice the thing which was crucial for me was that the actual map can be defined \"all in one go\" using <code>lift</code>, rather than the way I had built it. This opens the door to things unfolding nicely.</p>",
        "id": 161336915,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553168380
    },
    {
        "content": "<p>The advantage of the relation is you get something more symmetric, which you can prove theorems about swaps and such</p>",
        "id": 161336918,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1553168388
    },
    {
        "content": "<p>and it will fold nicely into future work on getting <code>transfer</code> to automate this stuff</p>",
        "id": 161336980,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1553168420
    },
    {
        "content": "<p>Right -- this is why I'm posting this in the cerw thread. I'd like to have a transfer thread really.</p>",
        "id": 161336991,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553168440
    },
    {
        "content": "<p>Writing the perfectoid project has really taught me a lot about Lean's type theory, it has been a wonderful experience; I am now finally beginning to understand, and sometimes even solve myself, issues where what I want is trivial in maths but Lean won't buy it. These are, to me at least, the most frustrating things about using Lean.</p>",
        "id": 161337046,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553168514
    },
    {
        "content": "<p>In particular I am beginning to understand more about the difficulties of transferring the things which transfer so naturally in mathematics, like this statement that if R and S are isomorphic rings and R is local then S is.</p>",
        "id": 161337131,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553168557
    },
    {
        "content": "<p>Do you follow the general strategy I tried to outline in that earlier stuff with <code>is_maximal_ideal</code>? For types, you want to define an equiv mapping (i.e. <code>A ~=r B</code> implies <code>ideal A ~= ideal B</code>), and for predicates you want to prove stuff about preserving <code>equiv.rel</code> on the component types</p>",
        "id": 161337178,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1553168604
    },
    {
        "content": "<p>If done correctly these should be compositional, in that if you have some complicated definition and you have the appropriate transfer lemmas for all the pieces of the definition then there is a straightforward way to put them all together to get the analogous transfer lemma for your definition</p>",
        "id": 161337309,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1553168705
    },
    {
        "content": "<p>You have the right idea with that lemma but to fit the mold <code>h2</code> should have the type <code>(equiv_set he).rel J K</code> where <code>equiv_set : A ~= B -&gt; set A ~= set B</code></p>",
        "id": 161337470,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1553168841
    },
    {
        "content": "<p>No I still did not sit down and look at the <code>is_maximal_ideal</code> stuff. Maybe this was an error. I am just highly focussed on the perfectoid project at the minute and am being ruthless. We're nearly there -- I can see the light at the end of the tunnel and the incentive to just keep working on it is very strong. I was up until 3am last night working on it and then up again at 7am doing more.</p>",
        "id": 161337565,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553168929
    },
    {
        "content": "<p>no problem, indeed if you have already proven your version of the statement then that's great. I'm thinking more in terms of how to link it up into a general theory, where you don't need any creativity to put the lemmas together</p>",
        "id": 161337680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1553169030
    },
    {
        "content": "<p>because we can't write a tactic to do the work for us until it's an utterly routine exercise</p>",
        "id": 161337712,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1553169071
    },
    {
        "content": "<p>I'm looking at it now.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"err\">≃</span><span class=\"n\">r</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ_</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"bp\">λ</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">to_equiv</span><span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p>I did not put coe_to_fun instances for group_equiv and monoid_equiv and preorder_equiv and mul_equiv and add_equiv and all the other equivs, because there was not one for ring_equiv. Now I see you've put one in. Shall I put coercions in for all the other ones?</p>",
        "id": 161337741,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553169105
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/789\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/issues/789\">#789</a></p>",
        "id": 161337798,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553169129
    },
    {
        "content": "<p><a href=\"#narrow/stream/144837-PR-reviews/topic/.23789.20extensions.20of.20equiv\" title=\"#narrow/stream/144837-PR-reviews/topic/.23789.20extensions.20of.20equiv\">https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/.23789.20extensions.20of.20equiv</a></p>",
        "id": 161337805,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553169142
    },
    {
        "content": "<p>Fancy a review of what I've PR'ed so far? ;-)</p>",
        "id": 161337871,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553169234
    },
    {
        "content": "<blockquote>\n<p>I actually suggest neither preimages nor images, but rather a relation <code>equiv.rel(phi) J K</code></p>\n</blockquote>\n<p>If we take this idea seriously (which is I guess the main claim of \"Theorems for free\") should we then also define <code>add_equiv</code> in terms of <code>equiv.rel (has_add.add A) (has_add.add B)</code>?</p>",
        "id": 161422525,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553233919
    },
    {
        "content": "<p>After all, the <code>equiv.rel</code> between <code>A</code> and <code>B</code> induces an <code>equiv.rel</code> between <code>A → A → A</code> and <code>B → B → B</code>.</p>",
        "id": 161422596,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553234023
    },
    {
        "content": "<p>you don't need to define this specifically, it is <code>f.rel =&gt; f.rel =&gt; f.rel</code> if <code>f : A ~= B</code></p>",
        "id": 161423159,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1553234923
    },
    {
        "content": "<p>Sure... my question is: should we use those facts in the definition of <code>add_equiv</code>, <code>mul_equiv</code>, <code>le_equiv</code>, etc...</p>",
        "id": 161424480,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553237131
    },
    {
        "content": "<p>If we use <code>rel</code> in their definitions, does that help down the line with inferring equivs, or transporting stuff?</p>",
        "id": 161424537,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553237183
    },
    {
        "content": "<p>the definition of add_equiv et al doesn't use any of this</p>",
        "id": 161424917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1553237801
    },
    {
        "content": "<p>rather, add_equiv et al are used to define the relations at the base case</p>",
        "id": 161424939,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1553237848
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 162359060,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1554228296
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"110172\">@Assia Mahboubi</span> . A commutative ring is called _local_ if it has a unique maximal ideal. If you find a mathematician and ask them the following question: \"if <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span> are isomorphic rings, and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is local, is <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span> local?\", then I think they will struggle to say anything useful other than \"the answer is obviously yes\". This is because \"local\", like every other predicate on rings that a mathematician uses, is constant on isomorphism classes. Unfortunately it turns out that there are completely valid predicates which no mathematician cares about but which do not have this property (e.g. <code>P X := X = R</code>). If you had to prove this statement about local rings in Coq, how would it go? Can you get it for free, or cheaply? The people here are trying to make a tactic which does it, and progress is being made, but I think we're not there yet.</p>",
        "id": 162629834,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554475825
    }
]
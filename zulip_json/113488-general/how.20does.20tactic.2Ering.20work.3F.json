[
    {
        "content": "<p>I have read through programming in Lean a couple of times and now wonder if it's time I started reading something else. I decided to read the ring tactic (not least because it failed to prove something relatively simple the last time I tried to use it and I'd rather fix it myself than pester Mario, not that I have any idea about how far I need to go before I am anywhere close to being able to fix it).</p>",
        "id": 127888870,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528705688
    },
    {
        "content": "<p>Anyway, I started to read it:</p>",
        "id": 127888871,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528705697
    },
    {
        "content": "<p><a href=\"https://github.com/kbuzzard/mathlib/blob/tactic_doc/docs/ring_tactic.rst\" target=\"_blank\" title=\"https://github.com/kbuzzard/mathlib/blob/tactic_doc/docs/ring_tactic.rst\">https://github.com/kbuzzard/mathlib/blob/tactic_doc/docs/ring_tactic.rst</a></p>",
        "id": 127888874,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528705708
    },
    {
        "content": "<p>There are my comments on the first 30 or so lines, plus a long intro summarising programming in lean</p>",
        "id": 127888882,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528705734
    },
    {
        "content": "<p>There's a link to programming in lean: <a href=\"https://leanprover.github.io/programming_in_lean/programming_in_lean.pdf\" target=\"_blank\" title=\"https://leanprover.github.io/programming_in_lean/programming_in_lean.pdf\">https://leanprover.github.io/programming_in_lean/programming_in_lean.pdf</a></p>",
        "id": 127888901,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528705778
    },
    {
        "content": "<p>Here's Patrick's secret gem: <a href=\"https://hanoifabs.files.wordpress.com/2018/05/slides.pdf\" target=\"_blank\" title=\"https://hanoifabs.files.wordpress.com/2018/05/slides.pdf\">https://hanoifabs.files.wordpress.com/2018/05/slides.pdf</a> (thanks Johannes)</p>",
        "id": 127888951,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528705811
    },
    {
        "content": "<p>and that is pretty much every online resource for Lean tactics. Here's the file I want to understand:</p>",
        "id": 127888964,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528705852
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/mathlib/blob/master/tactic/ring.lean\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/master/tactic/ring.lean\">https://github.com/leanprover/mathlib/blob/master/tactic/ring.lean</a></p>",
        "id": 127888974,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528705868
    },
    {
        "content": "<p>if anyone wants to help me understand it, they're welcome to edit the rst file. Note: I wrote <code>ring_ractic.rst</code> in sphinx not markdown. It's still human-readable and pretty easy to pick up.</p>",
        "id": 127888989,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528705914
    },
    {
        "content": "<p>Typo: \"especially if one does it within Lean (thus gaining the ability to hover over or click on functions and see their type, definition and so on).\" &lt;-- you mean VScode instead of Lean, right?<br>\nAnother typo: \"Note that evem though\" &lt;-- s/evem/even/</p>",
        "id": 127893407,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528713769
    },
    {
        "content": "<p>Thanks. I had a look through all of tactic.ring and really it doesn't look too bad. I'm currently reading <a href=\"http://www.cs.ru.nl/~freek/courses/tt-2014/read/10.1.1.61.3041.pdf\" target=\"_blank\" title=\"http://www.cs.ru.nl/~freek/courses/tt-2014/read/10.1.1.61.3041.pdf\">http://www.cs.ru.nl/~freek/courses/tt-2014/read/10.1.1.61.3041.pdf</a> Assia's take on the matter (which I think was Mario's source for his code)</p>",
        "id": 127896619,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528719313
    },
    {
        "content": "<p>in fact I know it was Mario's source for the code because I've just noticed that it says this in the comments at the top.</p>",
        "id": 127907285,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528734326
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">ring</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">))))</span> <span class=\"bp\">=</span>\n  <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">ring</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- goal now (b * a + (2 * b * a + 3 * b ^ 2)) * a + b ^ 3 = (3 * b * a + 3 * b ^ 2) * a + b ^ 3</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- goal now (b * a + (2 * b * a + 3 * b ^ 2)) * a = (3 * b * a + 3 * b ^ 2) * a</span>\n  <span class=\"n\">ring</span> <span class=\"c1\">-- works</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 127945351,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796473
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>elaboration: tactic execution took 2.23s\nnum. allocated objects:  8522\nnum. allocated closures: 2163\n 2229ms   100.0%   scope_trace\n 2229ms   100.0%   tactic.istep._lambda_1\n 2229ms   100.0%   tactic.istep\n 2229ms   100.0%   tactic.step\n 2229ms   100.0%   _interaction._lambda_2\n 1987ms    89.1%   interaction_monad_orelse\n 1929ms    86.5%   tactic.ring.eval\n 1156ms    51.9%   tactic.interactive.ring1\n 1156ms    51.9%   tactic.interactive.ring._lambda_1\n 1156ms    51.9%   tactic.interactive.ring\n 1057ms    47.4%   tactic.ring.eval_mul\n</pre></div>",
        "id": 127945353,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796479
    },
    {
        "content": "<p>etc etc</p>",
        "id": 127945354,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796480
    },
    {
        "content": "<p>This tactic doesn't quite work yet as far as I can see.</p>",
        "id": 127945358,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796502
    },
    {
        "content": "<p>(noticable pause in <code>ring</code> whilst it's failing to prove it the first time)</p>",
        "id": 127945366,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796520
    },
    {
        "content": "<p>But I want to fix it.</p>",
        "id": 127945407,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796527
    },
    {
        "content": "<p>I re-read the \"rings done right\" paper and I understood _much_ more of it this time around.</p>",
        "id": 127945415,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796545
    },
    {
        "content": "<p>One insight which dawned on me is that there are two completely different issues involved with writing a ring tactic. Maybe everyone else is aware of this.</p>",
        "id": 127945427,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796587
    },
    {
        "content": "<p>Let me explain my understanding of what the ring tactic does.</p>",
        "id": 127945430,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796601
    },
    {
        "content": "<p>Let's say <code>d : int</code> and we want to prove <code>d^2 + 2*d + 1 = (d+1)^2</code></p>",
        "id": 127945444,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796616
    },
    {
        "content": "<p>If we want to prove this using <code>ring</code> then we are saying \"this is not true because of something specific to int, this is a general fact about rings\"</p>",
        "id": 127945497,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796655
    },
    {
        "content": "<p>So what we actually want to do is to prove that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>X</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>X</mi><mo>+</mo><mn>1</mn><mo>=</mo><mo>(</mo><mi>X</mi><mo>+</mo><mn>1</mn><msup><mo>)</mo><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">X^2+2X+1=(X+1)^2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span></span></span></span></span><span class=\"mbin\">+</span><span class=\"mord mathrm\">2</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mbin\">+</span><span class=\"mord mathrm\">1</span><span class=\"mrel\">=</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mbin\">+</span><span class=\"mord mathrm\">1</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span></span></span></span></span></span></span></span> in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><mo>[</mo><mi>X</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}[X]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span></span></span></span></p>",
        "id": 127945501,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796690
    },
    {
        "content": "<p>and then deduce our goal by specialising to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi><mo>=</mo><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">X=d</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mrel\">=</span><span class=\"mord mathit\">d</span></span></span></span></p>",
        "id": 127945513,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796720
    },
    {
        "content": "<p>This makes it clear what we have to do here.</p>",
        "id": 127945521,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796741
    },
    {
        "content": "<p>First we need to build a new type in Lean corresponding to polynomials in one variable</p>",
        "id": 127945565,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796769
    },
    {
        "content": "<p>or more generally, if we want to prove stuff like <code>(a+b)^2=a^2+2*a*b+b^2</code> for ints a,b</p>",
        "id": 127945572,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796787
    },
    {
        "content": "<p>we will need polynomials in a finite set of variables.</p>",
        "id": 127945576,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796800
    },
    {
        "content": "<p>Of course Lean has these.</p>",
        "id": 127945580,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796806
    },
    {
        "content": "<p>Once we have this new type, we need to prove an \"evaluation theorem\", saying that if <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>X</mi><mo>)</mo><mo>=</mo><mi>g</mi><mo>(</mo><mi>X</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f(X)=g(X)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span> in our polynomial ring</p>",
        "id": 127945588,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796854
    },
    {
        "content": "<p>then <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>d</mi><mo>)</mo><mo>=</mo><mi>g</mi><mo>(</mo><mi>d</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f(d)=g(d)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">d</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathit\">d</span><span class=\"mclose\">)</span></span></span></span> in int</p>",
        "id": 127945589,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796861
    },
    {
        "content": "<p>Along the way it would be natural to prove things like <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>d</mi><mo>)</mo><mo>+</mo><mi>g</mi><mo>(</mo><mi>d</mi><mo>)</mo><mo>=</mo><mo>(</mo><mi>f</mi><mo>+</mo><mi>g</mi><mo>)</mo><mo>(</mo><mi>d</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f(d)+g(d)=(f+g)(d)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">d</span><span class=\"mclose\">)</span><span class=\"mbin\">+</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathit\">d</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mbin\">+</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathit\">d</span><span class=\"mclose\">)</span></span></span></span> and so on</p>",
        "id": 127945634,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796915
    },
    {
        "content": "<p>So we define our new polynomial type, define evaluation, prove nice properties about the evaluation map</p>",
        "id": 127945646,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796946
    },
    {
        "content": "<p>and now all that's left is the following problem:</p>",
        "id": 127945648,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796961
    },
    {
        "content": "<p>given <code>d^2+2*d+1</code> with <code>d : int</code></p>",
        "id": 127945650,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796974
    },
    {
        "content": "<p>we need to manufacture <code>X^2+2*X+1</code> in our polynomial ring type.</p>",
        "id": 127945653,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528796993
    },
    {
        "content": "<p>And for this we really need to take apart <code>d^2+2*d+1</code> and see how it is built from <code>d</code> and stuff that has analogues in the polynomial ring.</p>",
        "id": 127945714,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528797041
    },
    {
        "content": "<p>(+,^,2,1)</p>",
        "id": 127945719,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528797059
    },
    {
        "content": "<p>and I think that it's at this point that the non-tactic-user gets stuck.</p>",
        "id": 127945734,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528797082
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> Assume Lean has a working polynomial ring type <code>ZX</code> (there are some kicking around, but perhaps none in mathlib) representing polynomials with integer coefficients in one variable <code>X</code>.  Am I right in thinking that it doesn't even make sense to ask for a function (in Lean's sense) which sends <code>d^2+2*d+1</code> to <code>X^2+2*X+1</code> where <code>d : int</code> is some variable? I can't even imagine what the domain of such a function would be. On the other hand, would I be able to write a tactic which took the expression <code>d^2+2*d+1</code> as an input and spat out <code>X^2+2*X+1</code>?</p>",
        "id": 127945904,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528797393
    },
    {
        "content": "<p>Or is life not even that easy?</p>",
        "id": 127945920,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528797442
    },
    {
        "content": "<p>certainly given <code>d^2+2*d+1</code> as an <code>expr</code> (and let's say <code>d</code> is also given, as an <code>expr</code>), in meta land we can construct <code>X^2+2*X+1</code>.</p>",
        "id": 127947136,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528799647
    },
    {
        "content": "<p>(Mario's implementation does clever things, including a representation of sparse polynomials, but if you just want the stupid version I could probably manage that function.)</p>",
        "id": 127947142,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528799700
    },
    {
        "content": "<p>Is this simply renaming variables in the goal?</p>",
        "id": 127950108,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1528805061
    },
    {
        "content": "<p>Sorry, the example wasn't very helpful: I just meant, determine if some expression is in fact a polynomial in some other expr, and if so, present it as such in some form (list of coefficients, map of coefficients, etc).</p>",
        "id": 127950557,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528805815
    },
    {
        "content": "<blockquote>\n<p>Is this simply renaming variables in the goal?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> No I think it's more. X is a genuine polynomial variable, we have a type <code>ZX</code> with an inclusion from int into ZX and also some element <code>X : ZX</code> which is not in the image of <code>int</code>, it's an abstract polynomial variable</p>",
        "id": 127951731,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528807631
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> do we _have_ to do this in meta-land?</p>",
        "id": 127951740,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528807656
    },
    {
        "content": "<p>ah! i see. So a kind of parser.</p>",
        "id": 127951793,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1528807693
    },
    {
        "content": "<p>I can see that Mario's implementation uses \"Horner form\" of a polynomial, so sparse polys are handled better.</p>",
        "id": 127951794,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528807695
    },
    {
        "content": "<p>Yes, I was interested in building the stupid version of tactic.ring</p>",
        "id": 127951798,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528807707
    },
    {
        "content": "<p>Yes, I think it has to be in meta because you need access to the <code>expr</code> syntax tree</p>",
        "id": 127951805,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1528807718
    },
    {
        "content": "<p>What I see in Mario's file seems to me to be a construction of an abstract polynomial ring but completely in meta-land</p>",
        "id": 127951812,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528807739
    },
    {
        "content": "<p>Here is a concrete question.</p>",
        "id": 127951818,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528807747
    },
    {
        "content": "<p>Would it be possible to just define the polynomial ring Z[X] in \"normal\" Lean</p>",
        "id": 127951823,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528807768
    },
    {
        "content": "<p>e.g. in a non-efficient way, using lists for coefficients</p>",
        "id": 127951830,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528807776
    },
    {
        "content": "<p>I believe so</p>",
        "id": 127951837,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1528807789
    },
    {
        "content": "<p>and then write a much simpler tactic than <code>tactic/ring.lean</code></p>",
        "id": 127951841,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528807790
    },
    {
        "content": "<p>which can prove statements of the form \"forall d : int, (d+1)^3=d^3+3d^2+3d+1\"</p>",
        "id": 127951893,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528807815
    },
    {
        "content": "<p>by temporarily dipping into meta-land to construct the polynomials (X+1)^3 and X^3+3X^2+3X+1</p>",
        "id": 127951901,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528807836
    },
    {
        "content": "<p>and then checking that they're equal in Z[X]</p>",
        "id": 127951904,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528807845
    },
    {
        "content": "<p>and then evaluating at d</p>",
        "id": 127951907,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528807848
    },
    {
        "content": "<p>and deducing the result?</p>",
        "id": 127951914,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528807859
    },
    {
        "content": "<p>Or is it an essential part of the tactic.ring tactic that one builds some version of Z[X] in meta-land?</p>",
        "id": 127951927,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528807886
    },
    {
        "content": "<p>It seems to me that Mario writes <code>horner</code> in normal-land and proves some lemmas about it in normal-land</p>",
        "id": 127951988,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528807975
    },
    {
        "content": "<p>but the key facts are things like <code>eval_add</code>, which is meta</p>",
        "id": 127952002,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528808004
    },
    {
        "content": "<p><code>eval_add</code> seems to be some sort of theorem of the form \"if this expr represents f and this expr represents g, then I will return an expr plus a proof that it is the evaluation of f plus the evaluation of g\"</p>",
        "id": 127952175,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528808264
    },
    {
        "content": "<p>I was wondering whether one could instead use a non-expr version</p>",
        "id": 127952239,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528808306
    },
    {
        "content": "<p>Because <code>expr</code> is in meta land, you can't do any of that stuff in non-meta land</p>",
        "id": 127952242,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1528808308
    },
    {
        "content": "<p>right</p>",
        "id": 127952247,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528808316
    },
    {
        "content": "<p>but if I had a tactic which took d^2+2*d+1</p>",
        "id": 127952253,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528808334
    },
    {
        "content": "<p>and returned X^2+2*X+1</p>",
        "id": 127952259,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528808340
    },
    {
        "content": "<p>I see ok yes that's possible</p>",
        "id": 127952261,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1528808342
    },
    {
        "content": "<p>That's called a proof by reflection</p>",
        "id": 127952267,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1528808349
    },
    {
        "content": "<p>plus a proof that X^2+X+1 evaluated at d was d^2+2*d+1</p>",
        "id": 127952270,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528808355
    },
    {
        "content": "<p>then it seems to me that there's a chance that I can prove d^2+2*d+1=(d+1)^2 using this tactic</p>",
        "id": 127952294,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528808391
    },
    {
        "content": "<p>because I feed in both sides to the tactic</p>",
        "id": 127952373,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528808434
    },
    {
        "content": "<p>prove they're equal in <code>ZX</code></p>",
        "id": 127952376,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528808438
    },
    {
        "content": "<p>and deduce that their valuations are equal</p>",
        "id": 127952382,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528808448
    },
    {
        "content": "<p>I am trying to get as much of the proof out of meta-land as I can</p>",
        "id": 127952390,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528808458
    },
    {
        "content": "<p>Regarding lands, have you looked at the slides on metaprogramming <a href=\"https://hanoifabs.files.wordpress.com/2018/05/slides.pdf\" target=\"_blank\" title=\"https://hanoifabs.files.wordpress.com/2018/05/slides.pdf\">https://hanoifabs.files.wordpress.com/2018/05/slides.pdf</a>?</p>",
        "id": 127952404,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528808465
    },
    {
        "content": "<p>In particular page 4</p>",
        "id": 127952408,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528808474
    },
    {
        "content": "<p>This is part of the reason I'm thinking about this now</p>",
        "id": 127952433,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528808514
    },
    {
        "content": "<p>I have looked through all of tactic/ring.lean and all of a sudden it doesn't look as intimidating as it used ti</p>",
        "id": 127952485,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528808535
    },
    {
        "content": "<p>to</p>",
        "id": 127952486,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528808536
    },
    {
        "content": "<p><a href=\"https://github.com/kbuzzard/mathlib/blob/ring_tactic_comments/tactic/ring.lean\" target=\"_blank\" title=\"https://github.com/kbuzzard/mathlib/blob/ring_tactic_comments/tactic/ring.lean\">https://github.com/kbuzzard/mathlib/blob/ring_tactic_comments/tactic/ring.lean</a></p>",
        "id": 127952586,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528808679
    },
    {
        "content": "<p>If you don't need access to meta-land features like general recursion or <code>expr</code> then you can stay in normal-land; and surely the theory of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><mo>[</mo><mi>X</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}[X]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span></span></span></span> doesn't need these things. On the other hand, you may want to avoid using noncomputable things if you want your tactic to, for example, be able to decide whether two polynomials in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><mo>[</mo><mi>X</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}[X]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span></span></span></span> are equal so that it can decide whether to succeed or fail.</p>",
        "id": 127952590,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528808685
    },
    {
        "content": "<p>I am trying to write a comment about every definition and theorem in that link</p>",
        "id": 127952593,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528808694
    },
    {
        "content": "<p>So one can certainly make Z[X], indeed it's been done several times although I don't think it's in mathlib yet</p>",
        "id": 127952613,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528808735
    },
    {
        "content": "<p>The problem is the function sending d^2+2d+1 to X^2+2X+1</p>",
        "id": 127952618,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528808750
    },
    {
        "content": "<p>Right, so I guess the approach used here by <code>ring</code> is to represent a variable (which is basically something the tactic can't break down into further ring operations) by its <code>expr</code></p>",
        "id": 127952671,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528808819
    },
    {
        "content": "<p>right</p>",
        "id": 127952678,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528808835
    },
    {
        "content": "<p>Here the variable is simply <code>d</code>, but it could have been more complicated, e.g. <code>sin t</code></p>",
        "id": 127952679,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528808843
    },
    {
        "content": "<p>right</p>",
        "id": 127952681,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528808847
    },
    {
        "content": "<p>or there could be several variables</p>",
        "id": 127952683,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528808852
    },
    {
        "content": "<p>So that must be why the <code>destruct_ty</code> thing is in <code>meta</code>, though if you wanted it to be in normal-land, you could probably just parameterize it on the expression type.</p>",
        "id": 127952755,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528808947
    },
    {
        "content": "<p>BTW, <code>_ty</code> probably just stands for \"type\"</p>",
        "id": 127952758,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528808959
    },
    {
        "content": "<p>So completely independent of the ring tactic</p>",
        "id": 127952829,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809069
    },
    {
        "content": "<p>there is this horner thing</p>",
        "id": 127952830,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809072
    },
    {
        "content": "<p>and what seems to be going on there</p>",
        "id": 127952832,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809080
    },
    {
        "content": "<p>is that (and this is Assia's insight, or her joint insight with her co-author)</p>",
        "id": 127952834,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809093
    },
    {
        "content": "<p>storing polynomials as lists of coefficients might suck</p>",
        "id": 127952844,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809107
    },
    {
        "content": "<p>especially if you want to work out x^100 * x^100 without doing 10000 computations</p>",
        "id": 127952888,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809124
    },
    {
        "content": "<p>so they store e.g. x^100+3x^2+7 as (1*x^98+3)*x^2+7</p>",
        "id": 127952898,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809153
    },
    {
        "content": "<p>iterating the \"x maps to a*x^n+b\" map</p>",
        "id": 127952903,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809167
    },
    {
        "content": "<p>and so this is some sort of normal form for polynomials</p>",
        "id": 127952918,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809194
    },
    {
        "content": "<p>which we could call \"horner normal form\"</p>",
        "id": 127952922,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809201
    },
    {
        "content": "<p>and if you store polynomials in this way then it's a PITA to add or multiply them</p>",
        "id": 127952925,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809214
    },
    {
        "content": "<p>but this is OK because somehow this isn't the bottleneck</p>",
        "id": 127952929,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809232
    },
    {
        "content": "<p>I see, and <code>eval_add</code> is basically implementing addition of polynomials in this form, it looks like?</p>",
        "id": 127952978,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528809266
    },
    {
        "content": "<p>So one could envisage writing a second ring tactic which (a) was far less efficient and (b) worked in some situations where Mario's doesn't (because Mario's is currently buggy)</p>",
        "id": 127952979,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809271
    },
    {
        "content": "<p>where you just use lists for coefficients</p>",
        "id": 127952984,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809283
    },
    {
        "content": "<p>and then the resulting tactic file would have this extra obfuscating layer of difficulty removed</p>",
        "id": 127953003,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809309
    },
    {
        "content": "<p>and this was what got me into wondering whether I could even just use one of the already-existing polynomial ring Lean implementations</p>",
        "id": 127953012,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809340
    },
    {
        "content": "<p>instead of making Z[X] in meta-land</p>",
        "id": 127953016,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809350
    },
    {
        "content": "<blockquote>\n<p>I see, and <code>eval_add</code> is basically implementing addition of polynomials in this form, it looks like?</p>\n</blockquote>\n<p>Yes, it's perhaps doing something clever like not just implementing addition, it's also collecting the proofs that addition commutes with evaluation, but the five lemmas before <code>eval_add</code> are precisely the five lemmas you need to add polynomials in \"Horner form\"</p>",
        "id": 127953098,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809456
    },
    {
        "content": "<p>You add <code>ax^n+b</code> and <code>a'x^n'+b'</code></p>",
        "id": 127953111,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809481
    },
    {
        "content": "<p>where a and a' are allowed to be polynomials in horner form</p>",
        "id": 127953152,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809491
    },
    {
        "content": "<p>and you have to do the three cases n&lt;n', n=n', n&gt;n'</p>",
        "id": 127953158,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809502
    },
    {
        "content": "<p>and then also you have to add <code>ax^n+b</code> to c where c is a constant</p>",
        "id": 127953162,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809516
    },
    {
        "content": "<p>both ways around</p>",
        "id": 127953163,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809520
    },
    {
        "content": "<p>and there's some implicit inductive type horner_form</p>",
        "id": 127953168,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809535
    },
    {
        "content": "<p>which is defined by: a constant is in horner_form, and if a is in horner_form then so is a*x^n+b</p>",
        "id": 127953182,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809555
    },
    {
        "content": "<p>and then every polynomial has a canonical horner form</p>",
        "id": 127953187,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809568
    },
    {
        "content": "<p>and also perhaps some non-canonical ones</p>",
        "id": 127953198,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809582
    },
    {
        "content": "<p>I haven't got down as far as <code>normalize</code> but this might be the function which puts something in horner form into its normalised state (which you need because you need an algorithm for figuring out when two polynomials are equal)</p>",
        "id": 127953343,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528809754
    },
    {
        "content": "<blockquote>\n<p>and this was what got me into wondering whether I could even just use one of the already-existing polynomial ring Lean implementations</p>\n</blockquote>\n<p>I don't see why not. Probably you can even use the one in <code>linear_algebra.multivariate_polynomial</code></p>",
        "id": 127953437,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528809947
    },
    {
        "content": "<p>You understand that I am not looking for some sort of uber-efficient ring tactic, like the one Mario wrote. I am trying to see in some sense what the minimal amount of work would be, if I wanted to write a more inefficient ring tactic of my own</p>",
        "id": 127953586,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528810147
    },
    {
        "content": "<p>and the more I can get out of meta-land the better</p>",
        "id": 127953590,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528810164
    },
    {
        "content": "<p>Even for just equations involving one unknown, I would be interested</p>",
        "id": 127953599,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528810179
    },
    {
        "content": "<p>not least because <code>example (d : ℕ) : d^2+2*d+1=(d+1)^2 := by ring </code> currently fails and rather than pestering Mario I thought it would be an interesting exercise to try and work out why.</p>",
        "id": 127953672,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528810239
    },
    {
        "content": "<p>Yes, I think a <code>ring</code> tactic optimized for simplicity would be valuable as a demonstration of how to write similar tactics, as well.</p>",
        "id": 127953697,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528810289
    },
    {
        "content": "<p>Well maybe that's where this thread is going.</p>",
        "id": 127954108,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528811011
    },
    {
        "content": "<p>I'm not sure you can actually save that much work with a dumber <code>ring</code> tactic</p>",
        "id": 127954256,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528811257
    },
    {
        "content": "<p>Probably using dense polynomial representation is a bit easier, but I don't think proof by reflection is easier (although more of it can be verified)</p>",
        "id": 127954307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528811307
    },
    {
        "content": "<p>but precisely because more of it is verified, there is more work to do</p>",
        "id": 127954313,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528811337
    },
    {
        "content": "<p>If <code>expr</code> was not meta, almost all of the ring tactic could be non-meta</p>",
        "id": 127954331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528811399
    },
    {
        "content": "<p>Do you know if there's any plan to make <code>expr</code> non-meta?</p>",
        "id": 127954389,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1528811455
    },
    {
        "content": "<p>I have not investigated the <code>ring</code> bug, but one way to find out what is happening is to insert type checks in <code>eval_add</code> and such</p>",
        "id": 127954397,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528811475
    },
    {
        "content": "<p>By \"simple\", I really mean \"easy to understand\"</p>",
        "id": 127954407,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528811499
    },
    {
        "content": "<p>not necessarily short</p>",
        "id": 127954409,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528811505
    },
    {
        "content": "<p>There is no plan to make <code>expr</code> non-meta, and in fact I attempted such a plan and was rebuffed several months ago</p>",
        "id": 127954412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528811519
    },
    {
        "content": "<p>The likely alternative is to have a mirror copy of <code>expr</code> that is non-meta</p>",
        "id": 127954463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528811552
    },
    {
        "content": "<p>which would have to avoid certain meta things like macros</p>",
        "id": 127954469,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528811579
    },
    {
        "content": "<blockquote>\n<p>I'm not sure you can actually save that much work with a dumber <code>ring</code> tactic</p>\n</blockquote>\n<p>Yes, as Reid says, I'm not worried about work, I'm attempting to understand tactics in a way other than \"read Programming In Lean again\".</p>",
        "id": 127954787,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528812108
    },
    {
        "content": "<p>The only other way I can think of is \"read some tactic code and see if you can understand it, and see what questions arise because of it\"</p>",
        "id": 127954848,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528812141
    },
    {
        "content": "<p>and that's why I find myself in this thread</p>",
        "id": 127954852,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528812147
    },
    {
        "content": "<p>One question: which is best? Documenting ring.lean like this <a href=\"https://github.com/kbuzzard/mathlib/blob/ring_tactic_comments/tactic/ring.lean\" target=\"_blank\" title=\"https://github.com/kbuzzard/mathlib/blob/ring_tactic_comments/tactic/ring.lean\">https://github.com/kbuzzard/mathlib/blob/ring_tactic_comments/tactic/ring.lean</a></p>",
        "id": 127954862,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528812181
    },
    {
        "content": "<p>or writing a stand-alone file with comments like this <a href=\"https://github.com/kbuzzard/mathlib/blob/tactic_doc/docs/ring_tactic.rst\" target=\"_blank\" title=\"https://github.com/kbuzzard/mathlib/blob/tactic_doc/docs/ring_tactic.rst\">https://github.com/kbuzzard/mathlib/blob/tactic_doc/docs/ring_tactic.rst</a></p>",
        "id": 127954873,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528812202
    },
    {
        "content": "<p>I currently find myself doing both</p>",
        "id": 127954883,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528812219
    },
    {
        "content": "<p>As long as I get to the bottom using one method, I am sure I will have learnt a lot</p>",
        "id": 127954892,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528812239
    },
    {
        "content": "<p>Currently the \"adding comments to ring.lean\" approach is winning</p>",
        "id": 127954939,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528812255
    },
    {
        "content": "<p>but the waffle above about writing a simpler version -- which to be honest could I think turn into a great tutorial on how to write tactics, if we implement polynomials in one variable using some dumb list method or, even better, perhaps using some already-implemented method</p>",
        "id": 127954988,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528812348
    },
    {
        "content": "<p>Maybe that's the goal of this thread. To write an  as-stupid-as-possible ring tactic which attempts to have as little in meta-land as possible, and then stick it up on my blog as some sort of tactic tutorial as an alternative for people to read</p>",
        "id": 127955058,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528812417
    },
    {
        "content": "<p>Next term I'll be supervising a Masters project on how to write tactics so I'd better get my act together and learn it myself</p>",
        "id": 127955071,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528812440
    },
    {
        "content": "<p>The student in question is currently doing an internship at INRIA learning how to do it in Coq so I'm hoping that they will learn quickly and then teach me</p>",
        "id": 127955085,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528812473
    },
    {
        "content": "<p>Maybe this will help: There is an implicit inductive type <code>horner_form_expr</code> with the following definition:</p>\n<div class=\"codehilite\"><pre><span></span>meta inductive horner_form_expr : Type\n| const : expr → horner_form_expr\n| horner (a : horner_form_expr) (x : expr) (n : nat) (b : horner_form_expr) : horner_form_expr\n</pre></div>\n\n\n<p>The job of <code>eval_add</code> and the other definitions is to rewrite any <code>expr</code> into a <code>horner_form_expr</code>. However, since <code>horner_form_expr</code> can be represented as an <code>expr</code>, the actual inductive type is omitted to avoid the overhead of converting back and forth. Furthermore, there is a normal form requirement, that says that the <code>x</code> expression must be lex_lt less than any other expressions in <code>x</code> slots of the <code>b</code> subtree.</p>",
        "id": 127957753,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528815688
    },
    {
        "content": "<p><code>destruct</code> is effectively the <code>cases_on</code> for this inductive type</p>",
        "id": 127957847,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528815812
    },
    {
        "content": "<p>Right -- I had basically figured this out. But you see, in some educational blog post about this stuff you could put this type in, and furthermore make it work in a more stupid way using lists of coefficients. What I am still not clear about is whethet you can get away with making it not meta (and hence get away with not actually writing it at all, because it's already written)</p>",
        "id": 127959658,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528817927
    },
    {
        "content": "<p>Because you're in meta-land you can just not even define the type, you can <code>destruct</code> it _assuming_ that it's in this form, and if it's not then big deal, things have gone wrong, just return <code>none</code></p>",
        "id": 127959693,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528817987
    },
    {
        "content": "<p>You can't make it non-meta and still retain the <code>x</code> payloads, which have to be kept as is as exprs</p>",
        "id": 127959786,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528818055
    },
    {
        "content": "<p>My idea was to have a meta function sending d^2+2d+1 to X^2+2X+1</p>",
        "id": 127959808,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818101
    },
    {
        "content": "<p>unless maybe you write them down somewhere else and only keep pointers to them in your non-meta data structure (i.e. indexes into a list of exprs)</p>",
        "id": 127959809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528818102
    },
    {
        "content": "<p>which I guess is similar to your Z[X] suggestion</p>",
        "id": 127959864,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528818137
    },
    {
        "content": "<p>The tactic would only work for goals with one unknown</p>",
        "id": 127959867,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818142
    },
    {
        "content": "<p>but you have to remember these are multivariate polynomials</p>",
        "id": 127959874,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528818156
    },
    {
        "content": "<p>I know yours are</p>",
        "id": 127959877,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818161
    },
    {
        "content": "<p>but I am suggesting writing a simplified version</p>",
        "id": 127959881,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818171
    },
    {
        "content": "<p>I want to isolate the \"now here we have to write some meta stuff\" and make it as small as possible</p>",
        "id": 127959895,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818192
    },
    {
        "content": "<p>If you take <code>d</code> as an input, then there are lots of bad exprs now</p>",
        "id": 127959898,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528818202
    },
    {
        "content": "<p>In my approach, there aren't any bad exprs because anything it doesn't understand becomes a new atom</p>",
        "id": 127959906,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528818229
    },
    {
        "content": "<p>I know your approach is better at getting things done</p>",
        "id": 127959948,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818243
    },
    {
        "content": "<p>I am happy to let both d and Z be inputs</p>",
        "id": 127959956,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818251
    },
    {
        "content": "<p>but you want to have only one atom</p>",
        "id": 127959964,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528818259
    },
    {
        "content": "<p>right</p>",
        "id": 127959966,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818263
    },
    {
        "content": "<p>and I want to store polynomials as lists</p>",
        "id": 127959969,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818270
    },
    {
        "content": "<p>these facts are not unrelated</p>",
        "id": 127959974,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818276
    },
    {
        "content": "<p>what happens if I pass <code>d^2+x</code> to your function?</p>",
        "id": 127959987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528818299
    },
    {
        "content": "<p>my function will fail</p>",
        "id": 127960000,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818305
    },
    {
        "content": "<p>because my function is there to teach people how to write tactics</p>",
        "id": 127960005,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818313
    },
    {
        "content": "<p>not to actually be used in the wild</p>",
        "id": 127960006,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818316
    },
    {
        "content": "<p>I am writing code for a completely different reason to probably any code you ever wrote</p>",
        "id": 127960013,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818340
    },
    {
        "content": "<p>I am writing code to teach my students that tactics are not scary</p>",
        "id": 127960015,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818350
    },
    {
        "content": "<p>which is not the impression you get when reading PIL</p>",
        "id": 127960060,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818364
    },
    {
        "content": "<p>Okay, let me think about this</p>",
        "id": 127960068,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528818386
    },
    {
        "content": "<p>In the mean time, the <code>ring</code> bug has been fixed.</p>",
        "id": 127960076,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528818413
    },
    {
        "content": "<p>:D</p>",
        "id": 127960078,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818420
    },
    {
        "content": "<p>OK so forget this thread, main goal achieved ;-)</p>",
        "id": 127960086,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818430
    },
    {
        "content": "<p>The problem was in <code>horner_add_horner_lt</code> (and <code>gt</code>). Suppose we are adding <code>(a1 * x^n1 + b1) + (a2 * x^n2 + b2)</code> where <code>n1 &gt; n2</code></p>",
        "id": 127960091,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528818441
    },
    {
        "content": "<p>dammit I even looked at that function!</p>",
        "id": 127960097,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818451
    },
    {
        "content": "<p>It's funny, the theorem is not wrong</p>",
        "id": 127960099,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528818465
    },
    {
        "content": "<p>but it doesn't normalize like it should</p>",
        "id": 127960146,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528818484
    },
    {
        "content": "<p>in fact that's exactly the point I'm up to</p>",
        "id": 127960148,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818486
    },
    {
        "content": "<p><code>/-- This non-meta theorem just says a₁x^n₁+b₁+a₂x^(n₁+k)+b₂=(a₂x^k+a₁)x^n₁+(b₁+b₂) -/</code></p>",
        "id": 127960156,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818515
    },
    {
        "content": "<p>I think this is a great idea. It took me some time to understand reflection in Lean. Unfortunately, translating Chlipala's section on it (in CPDT) from Coq to Lean is quite difficult. So a \"Lean-first\" tutorial would be great.</p>",
        "id": 127960189,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1528818573
    },
    {
        "content": "<p>The current implementation normalizes <code>b1 + b2 = b'</code>, calculates <code>k</code> such that <code>n2 + k = n1</code>, and then outputs the normal form <code>(a1 * x^k + a2) * x^n2 + b'</code></p>",
        "id": 127960192,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528818580
    },
    {
        "content": "<p>yeah (modulo the fact that the (1,2) notation is switched in this thread from the conventions used in the actual code)</p>",
        "id": 127960249,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818628
    },
    {
        "content": "<p>However, <code>a1 * x^k + a2</code> is not necessarily in normal form</p>",
        "id": 127960250,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528818629
    },
    {
        "content": "<p>because x might not be lt the monomials showing up in a1?</p>",
        "id": 127960258,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818657
    },
    {
        "content": "<p>Yes. In particular, <code>x</code> might appear in <code>a2</code></p>",
        "id": 127960276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528818696
    },
    {
        "content": "<p>or a1</p>",
        "id": 127960282,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818707
    },
    {
        "content": "<p>;-)</p>",
        "id": 127960285,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818712
    },
    {
        "content": "<p>that's okay</p>",
        "id": 127960288,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528818713
    },
    {
        "content": "<p>not when you switch it so your algebra is correct ;-)</p>",
        "id": 127960331,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818725
    },
    {
        "content": "<p>[you only did half the editing job]</p>",
        "id": 127960352,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818753
    },
    {
        "content": "<p>the whole point of factorizing <code>a1 * x^k + a2</code> is that <code>a2</code> has no <code>x</code>'s and <code>a1</code> has all the high order terms</p>",
        "id": 127960365,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528818776
    },
    {
        "content": "<p>a2 * x^k + a1</p>",
        "id": 127960372,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818785
    },
    {
        "content": "<p>I think this part of the thread is now beyond saving</p>",
        "id": 127960388,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818825
    },
    {
        "content": "<p>but I think we both know what the other is saying :-)</p>",
        "id": 127960396,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528818842
    },
    {
        "content": "<p>fixed</p>",
        "id": 127960460,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528818907
    },
    {
        "content": "<p>I actually noticed the problem in <code>gt</code>, but I was translating to the symmetric version and got confused</p>",
        "id": 127960468,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528818929
    },
    {
        "content": "<p>(in this thread, that's not the bug)</p>",
        "id": 127960525,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528818972
    },
    {
        "content": "<p>[I posted my docstring for <code>lt</code>, but you are talking about <code>gt</code>, so now all is right with the world]</p>",
        "id": 127960552,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528819023
    },
    {
        "content": "<p>Right, so let's focus on <code>gt</code></p>",
        "id": 127960559,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528819048
    },
    {
        "content": "<p>the bug is that since both <code>a1</code> and <code>a2</code> can contain <code>x</code>, we have a separate subproblem now, to normalize <code>(a1 * x^k + 0) + a2 = a'</code> and then output <code>a' * x^n2+ b'</code></p>",
        "id": 127960560,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528819049
    },
    {
        "content": "<p><code>/-- This non-meta theorem just says a₁x^(n₂+k)+b₁+a₂x^n₂+b₂=(a₁x^k+a₂)x^n₂+(b₁+b₂) -/</code></p>",
        "id": 127960566,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528819058
    },
    {
        "content": "<p>so I did that and now it works</p>",
        "id": 127960611,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528819089
    },
    {
        "content": "<p>I'm compiling now, I'll post it soon</p>",
        "id": 127960615,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528819103
    },
    {
        "content": "<p>I would have liked to find this bug</p>",
        "id": 127960626,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528819129
    },
    {
        "content": "<p>Because you're in meta mode you don't have to be super-anal about making sure everything is in canonical form</p>",
        "id": 127960636,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528819152
    },
    {
        "content": "<p>you just write procedural code which is supposed to do it</p>",
        "id": 127960648,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528819169
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110025\">@Andrew Ashworth</span> I did the introductory compiler exercise in CPDT, in Lean, over the weekend.</p>",
        "id": 127960715,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528819218
    },
    {
        "content": "<p>I'll help you with a tutorial ring tactic later</p>",
        "id": 127960717,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528819223
    },
    {
        "content": "<p>But one thing to be careful about is if you do too much non-meta, you might actually end up writing a tactic that does proof by reflection which is a completely different method</p>",
        "id": 127960732,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528819267
    },
    {
        "content": "<p>reflection is _different_? I thought that it was somehow some fundamental principle which was used everywhere?</p>",
        "id": 127960757,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528819309
    },
    {
        "content": "<p><code>ring</code> is an example of how to write tactics that build proofs by induction, but it's hard to do that non-meta</p>",
        "id": 127960760,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528819313
    },
    {
        "content": "<p>One way to see the difference is in the proof: A tactic that does proofs by meta-induction produces proofs that get longer as the theorem gets harder to prove, but a proof by reflection is relatively short, with the generated proof being proportional to the <em>statement</em> in length</p>",
        "id": 127960901,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528819474
    },
    {
        "content": "<p>Proofs by reflection are characterized by a \"heavy\" <code>rfl</code> proof somewhere in the middle</p>",
        "id": 127960916,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528819505
    },
    {
        "content": "<p><code>ring</code> produces no heavy steps, every single theorem applied exactly matches the type it should have</p>",
        "id": 127960934,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528819555
    },
    {
        "content": "<p>so the kernel never has to do any definitional reduction</p>",
        "id": 127960981,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528819574
    },
    {
        "content": "<p>This is all very instructive and quite different from the PIL stuff which, inevitably,  is skewed towards CS applications</p>",
        "id": 127961459,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528820192
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Here's a toy version of <code>ring</code> that works using computational reflection:</p>\n<div class=\"codehilite\"><pre><span></span>import tactic.basic data.num.lemmas\n\nnamespace ring_tac\nopen tactic\n\n@[derive has_reflect]\ninductive ring_expr : Type\n| add : ring_expr → ring_expr → ring_expr\n| mul : ring_expr → ring_expr → ring_expr\n| const : znum → ring_expr\n| X : ring_expr\n\nmeta def reflect_expr (X : expr) : expr → option ring_expr\n| `(%%e₁ + %%e₂) := do\n  p₁ ← reflect_expr e₁,\n  p₂ ← reflect_expr e₂,\n  return (ring_expr.add p₁ p₂)\n| `(%%e₁ * %%e₂) := do\n  p₁ ← reflect_expr e₁,\n  p₂ ← reflect_expr e₂,\n  return (ring_expr.mul p₁ p₂)\n| e := if e = X then return ring_expr.X else\n  do n ← expr.to_int e,\n     return (ring_expr.const (znum.of_int&#39; n))\n\ndef poly := list znum\n\ndef poly.add : poly → poly → poly := λ _ _, []\ndef poly.mul : poly → poly → poly := λ _ _, []\ndef poly.const : znum → poly := sorry\ndef poly.X : poly := sorry\n\ndef to_poly : ring_expr → poly\n| (ring_expr.add e₁ e₂) := (to_poly e₁).add (to_poly e₂)\n| (ring_expr.mul e₁ e₂) := (to_poly e₁).mul (to_poly e₂)\n| (ring_expr.const z) := poly.const z\n| ring_expr.X := poly.X\n\ndef poly.eval {α} [comm_ring α] (X : α) : poly → α\n| [] := 0\n| (n::l) := n + X * poly.eval l\n\n@[simp] theorem poly.eval_add {α} [comm_ring α] (X : α) : ∀ p₁ p₂ : poly,\n  (p₁.add p₂).eval X = p₁.eval X + p₂.eval X := sorry\n\n@[simp] theorem poly.eval_mul {α} [comm_ring α] (X : α) : ∀ p₁ p₂ : poly,\n  (p₁.mul p₂).eval X = p₁.eval X * p₂.eval X := sorry\n\n@[simp] theorem poly.eval_const {α} [comm_ring α] (X : α) : ∀ n : znum,\n  (poly.const n).eval X = n := sorry\n\n@[simp] theorem poly.eval_X {α} [comm_ring α] (X : α) : poly.X.eval X = X := sorry\n\ndef ring_expr.eval {α} [comm_ring α] (X : α) : ring_expr → α\n| (ring_expr.add e₁ e₂) := e₁.eval + e₂.eval\n| (ring_expr.mul e₁ e₂) := e₁.eval * e₂.eval\n| (ring_expr.const z) := z\n| ring_expr.X := X\n\ntheorem to_poly_eval {α} [comm_ring α] (X : α) (e) : (to_poly e).eval X = e.eval X :=\nby induction e; simp [to_poly, ring_expr.eval, *]\n\ntheorem main_thm {α} [comm_ring α] (X : α) (e₁ e₂) {x₁ x₂}\n  (H : to_poly e₁ = to_poly e₂) (R1 : e₁.eval X = x₁) (R2 : e₂.eval X = x₂) : x₁ = x₂ :=\nby rw [← R1, ← R2, ← to_poly_eval, H, to_poly_eval]\n\nmeta def ring_tac (X : pexpr) : tactic unit := do\n  X ← to_expr X,\n  `(%%x₁ = %%x₂) ← target,\n  r₁ ← reflect_expr X x₁,\n  r₂ ← reflect_expr X x₂,\n  let e₁ : expr := reflect r₁,\n  let e₂ : expr := reflect r₂,\n  `[refine main_thm %%X %%e₁ %%e₂ rfl _ _],\n  all_goals `[simp only [ring_expr.eval,\n    znum.cast_pos, znum.cast_neg, znum.cast_zero&#39;,\n    pos_num.cast_bit0, pos_num.cast_bit1,\n    pos_num.cast_one&#39;]]\n\nexample (x : ℤ) : (x + 1) * (x + 1) = x*x+2*x+1 :=\nby do ring_tac ```(x)\n\nend ring_tac\n</pre></div>",
        "id": 127964820,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528824802
    },
    {
        "content": "<p>I have left the exercise of defining <code>poly.add</code>, <code>poly.mul</code>, <code>poly.const</code> and <code>poly.X</code>, and proving correctness of the functions in the <code>eval_*</code> theorems (all non-meta), to you.</p>",
        "id": 127964879,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528824881
    },
    {
        "content": "<p>Here the \"heavy <code>rfl</code>\" step is the <code>rfl</code> proof in <code>main_thm</code></p>",
        "id": 127964910,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528824925
    },
    {
        "content": "<p>you will need the mathlib update that just appeared</p>",
        "id": 127964970,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528824976
    },
    {
        "content": "<p>wooah many thanks Mario!</p>",
        "id": 127971021,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528832878
    },
    {
        "content": "<p><code>example (a b : int) : (a+b)^11=a^11 + 11*b*a^10 + 55*b^2*a^9 + 165*b^3*a^8 + 330*b^4*a^7 + 462*b^5*a^6 + 462*b^6*a^5 + 330*b^7*a^4 + 165*b^8*a^3 + 55*b^9*a^2 + 11*b^10*a + b^11:= by ring</code></p>",
        "id": 127972171,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528834277
    },
    {
        "content": "<p>but 12 times out :-)</p>",
        "id": 127972173,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528834284
    },
    {
        "content": "<p>[this is of course the official ring, not the one above]</p>",
        "id": 127972177,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528834292
    },
    {
        "content": "<p><code>example (a b : int) : (a+b)^12=a^12 + 12*b*a^11 + 66*b^2*a^10 + 220*b^3*a^9 + 495*b^4*a^8 + 792*b^5*a^7 + 924*b^6*a^6 + 792*b^7*a^5 + 495*b^8*a^4 + 220*b^9*a^3 + 66*b^10*a^2 + 12*b^11*a + b^12:= by ring -- deterministic timeout</code></p>",
        "id": 127972228,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528834338
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> So you need to teach <code>ring</code> about Chris's binomial theorem!</p>",
        "id": 127973037,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528835479
    },
    {
        "content": "<p>Well, I'm not sure I would use Lean to check the binomial theorem for n=12 :-)</p>",
        "id": 127977028,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528841243
    },
    {
        "content": "<p>Ironically I fired up pari-gp and computed (a+b)^12 in a gazillionth of a second and then cut and pasted the output into Lean in order to see if it could do something which I already had a much better tool for.</p>",
        "id": 127977076,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528841287
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">basic</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">num</span><span class=\"bp\">.</span><span class=\"n\">lemmas</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">real</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ring_tac</span>\n<span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n\n<span class=\"c1\">-- why this line?</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">derive</span> <span class=\"n\">has_reflect</span><span class=\"o\">]</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">ring_expr</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">ring_expr</span> <span class=\"bp\">→</span> <span class=\"n\">ring_expr</span> <span class=\"bp\">→</span> <span class=\"n\">ring_expr</span>\n<span class=\"bp\">|</span> <span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"n\">ring_expr</span> <span class=\"bp\">→</span> <span class=\"n\">ring_expr</span> <span class=\"bp\">→</span> <span class=\"n\">ring_expr</span>\n<span class=\"bp\">|</span> <span class=\"n\">const</span> <span class=\"o\">:</span> <span class=\"n\">znum</span> <span class=\"bp\">→</span> <span class=\"n\">ring_expr</span>\n<span class=\"bp\">|</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">ring_expr</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">reflect_expr</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">ring_expr</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"err\">%%</span><span class=\"n\">e₁</span> <span class=\"bp\">+</span> <span class=\"err\">%%</span><span class=\"n\">e₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">do</span>\n  <span class=\"n\">p₁</span> <span class=\"err\">←</span> <span class=\"n\">reflect_expr</span> <span class=\"n\">e₁</span><span class=\"o\">,</span>\n  <span class=\"n\">p₂</span> <span class=\"err\">←</span> <span class=\"n\">reflect_expr</span> <span class=\"n\">e₂</span><span class=\"o\">,</span>\n  <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">ring_expr</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"err\">%%</span><span class=\"n\">e₁</span> <span class=\"bp\">*</span> <span class=\"err\">%%</span><span class=\"n\">e₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">do</span>\n  <span class=\"n\">p₁</span> <span class=\"err\">←</span> <span class=\"n\">reflect_expr</span> <span class=\"n\">e₁</span><span class=\"o\">,</span>\n  <span class=\"n\">p₂</span> <span class=\"err\">←</span> <span class=\"n\">reflect_expr</span> <span class=\"n\">e₂</span><span class=\"o\">,</span>\n  <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">ring_expr</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">X</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"n\">ring_expr</span><span class=\"bp\">.</span><span class=\"n\">X</span> <span class=\"k\">else</span>\n  <span class=\"n\">do</span> <span class=\"n\">n</span> <span class=\"err\">←</span> <span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">to_int</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n     <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">ring_expr</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"o\">(</span><span class=\"n\">znum</span><span class=\"bp\">.</span><span class=\"n\">of_int&#39;</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- mathlib/data/num has znum and stuff like znum.of_int&#39; (see above)</span>\n<span class=\"n\">def</span> <span class=\"n\">poly</span> <span class=\"o\">:=</span> <span class=\"n\">list</span> <span class=\"n\">znum</span>\n<span class=\"c1\">-- but why use it?</span>\n\n<span class=\"n\">def</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">poly</span> <span class=\"bp\">→</span> <span class=\"n\">poly</span> <span class=\"bp\">→</span> <span class=\"n\">poly</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">g</span>\n<span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">f</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">::</span> <span class=\"n\">f&#39;</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">::</span> <span class=\"n\">g&#39;</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">::</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"n\">f&#39;</span> <span class=\"n\">g&#39;</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">zero_add</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">poly</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"o\">[]</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">induction</span> <span class=\"n\">p</span><span class=\"bp\">;</span><span class=\"n\">refl</span>\n\n<span class=\"n\">def</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">smul</span> <span class=\"o\">:</span> <span class=\"n\">znum</span> <span class=\"bp\">→</span> <span class=\"n\">poly</span> <span class=\"bp\">→</span> <span class=\"n\">poly</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"n\">z</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">::</span> <span class=\"n\">f&#39;</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">::</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">smul</span> <span class=\"n\">z</span> <span class=\"n\">f&#39;</span>\n\n<span class=\"n\">def</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"n\">poly</span> <span class=\"bp\">→</span> <span class=\"n\">poly</span> <span class=\"bp\">→</span> <span class=\"n\">poly</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">::</span> <span class=\"n\">f&#39;</span><span class=\"o\">)</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">smul</span> <span class=\"n\">a</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">::</span> <span class=\"o\">(</span><span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"n\">f&#39;</span> <span class=\"n\">g</span><span class=\"o\">))</span>\n\n<span class=\"n\">def</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"o\">:</span> <span class=\"n\">znum</span> <span class=\"bp\">→</span> <span class=\"n\">poly</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">[</span><span class=\"n\">z</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">poly</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">to_poly</span> <span class=\"o\">:</span> <span class=\"n\">ring_expr</span> <span class=\"bp\">→</span> <span class=\"n\">poly</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">ring_expr</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">to_poly</span> <span class=\"n\">e₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">to_poly</span> <span class=\"n\">e₂</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">ring_expr</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">to_poly</span> <span class=\"n\">e₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"o\">(</span><span class=\"n\">to_poly</span> <span class=\"n\">e₂</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">ring_expr</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"n\">z</span>\n<span class=\"bp\">|</span> <span class=\"n\">ring_expr</span><span class=\"bp\">.</span><span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">X</span>\n\n<span class=\"n\">def</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">poly</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">::</span><span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">X</span> <span class=\"bp\">*</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">l</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">eval_zero</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">X</span> <span class=\"o\">[]</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">eval_add</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span> <span class=\"o\">:</span> <span class=\"n\">poly</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">p₁</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"n\">p₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">p₁</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">X</span> <span class=\"bp\">+</span> <span class=\"n\">p₂</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">p₁</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">p₁</span> <span class=\"k\">with</span> <span class=\"n\">h₁</span> <span class=\"n\">t₁</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- base case</span>\n    <span class=\"n\">intros</span><span class=\"o\">,</span><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"kn\">eval</span><span class=\"o\">],</span>\n  <span class=\"c1\">-- inductive step</span>\n  <span class=\"n\">intro</span> <span class=\"n\">p₂</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">p₂</span> <span class=\"k\">with</span> <span class=\"n\">h₂</span> <span class=\"n\">t₂</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"o\">],</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"n\">t₂</span><span class=\"o\">),</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_add</span><span class=\"o\">]</span>\n<span class=\"kn\">end</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">eval_mul_zero</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">poly</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"n\">f</span> <span class=\"o\">[])</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">f</span> <span class=\"k\">with</span> <span class=\"n\">h</span> <span class=\"n\">t</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">smul</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"kn\">eval</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">H</span><span class=\"o\">,</span><span class=\"n\">simp</span>\n<span class=\"kn\">end</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">eval_smul</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">znum</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">poly</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">smul</span> <span class=\"n\">z</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"bp\">*</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">f</span> <span class=\"k\">with</span> <span class=\"n\">h</span> <span class=\"n\">t</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">smul</span><span class=\"o\">,</span><span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"kn\">eval</span><span class=\"o\">,</span><span class=\"n\">mul_zero</span><span class=\"o\">],</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">smul</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"kn\">eval</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_add</span><span class=\"o\">,</span><span class=\"n\">znum</span><span class=\"bp\">.</span><span class=\"n\">cast_mul</span><span class=\"o\">,</span><span class=\"n\">mul_assoc</span><span class=\"o\">,</span><span class=\"n\">mul_comm</span><span class=\"o\">]</span>\n<span class=\"kn\">end</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">eval_mul</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span> <span class=\"o\">:</span> <span class=\"n\">poly</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">p₁</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"n\">p₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">p₁</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">X</span> <span class=\"bp\">*</span> <span class=\"n\">p₂</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">p₁</span><span class=\"o\">,</span><span class=\"n\">induction</span> <span class=\"n\">p₁</span> <span class=\"k\">with</span> <span class=\"n\">h₁</span> <span class=\"n\">t₁</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">mul</span><span class=\"o\">],</span>\n  <span class=\"n\">intro</span> <span class=\"n\">p₂</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">mul</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">eval_add</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"kn\">eval</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">H</span> <span class=\"n\">p₂</span><span class=\"o\">,</span><span class=\"n\">znum</span><span class=\"bp\">.</span><span class=\"n\">cast_zero</span><span class=\"o\">,</span><span class=\"n\">zero_add</span><span class=\"o\">,</span><span class=\"n\">add_mul</span><span class=\"o\">,</span><span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">eval_smul</span><span class=\"o\">,</span><span class=\"n\">mul_assoc</span><span class=\"o\">]</span>\n<span class=\"kn\">end</span>\n\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">eval_const</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">znum</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"kn\">eval</span><span class=\"o\">,</span><span class=\"n\">simp</span>\n<span class=\"kn\">end</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">eval_X</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">X</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"kn\">eval</span><span class=\"o\">,</span><span class=\"n\">simp</span>\n<span class=\"kn\">end</span>\n\n\n<span class=\"n\">def</span> <span class=\"n\">ring_expr</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ring_expr</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">ring_expr</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">e₁</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"bp\">+</span> <span class=\"n\">e₂</span><span class=\"bp\">.</span><span class=\"kn\">eval</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">ring_expr</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">e₁</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"bp\">*</span> <span class=\"n\">e₂</span><span class=\"bp\">.</span><span class=\"kn\">eval</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">ring_expr</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">z</span>\n<span class=\"bp\">|</span> <span class=\"n\">ring_expr</span><span class=\"bp\">.</span><span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">X</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">to_poly_eval</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">to_poly</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">induction</span> <span class=\"n\">e</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">to_poly</span><span class=\"o\">,</span> <span class=\"n\">ring_expr</span><span class=\"bp\">.</span><span class=\"kn\">eval</span><span class=\"o\">,</span> <span class=\"bp\">*</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">main_thm</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e₁</span> <span class=\"n\">e₂</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x₁</span> <span class=\"n\">x₂</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">to_poly</span> <span class=\"n\">e₁</span> <span class=\"bp\">=</span> <span class=\"n\">to_poly</span> <span class=\"n\">e₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R1</span> <span class=\"o\">:</span> <span class=\"n\">e₁</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">x₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R2</span> <span class=\"o\">:</span> <span class=\"n\">e₂</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">x₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x₁</span> <span class=\"bp\">=</span> <span class=\"n\">x₂</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">R1</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">R2</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">to_poly_eval</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">to_poly_eval</span><span class=\"o\">]</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">ring_tac</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">pexpr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span> <span class=\"n\">do</span>\n  <span class=\"n\">X</span> <span class=\"err\">←</span> <span class=\"n\">to_expr</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"err\">%%</span><span class=\"n\">x₁</span> <span class=\"bp\">=</span> <span class=\"err\">%%</span><span class=\"n\">x₂</span><span class=\"o\">)</span> <span class=\"err\">←</span> <span class=\"n\">target</span><span class=\"o\">,</span>\n  <span class=\"n\">r₁</span> <span class=\"err\">←</span> <span class=\"n\">reflect_expr</span> <span class=\"n\">X</span> <span class=\"n\">x₁</span><span class=\"o\">,</span>\n  <span class=\"n\">r₂</span> <span class=\"err\">←</span> <span class=\"n\">reflect_expr</span> <span class=\"n\">X</span> <span class=\"n\">x₂</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">e₁</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span> <span class=\"n\">reflect</span> <span class=\"n\">r₁</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">e₂</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span> <span class=\"n\">reflect</span> <span class=\"n\">r₂</span><span class=\"o\">,</span>\n  <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">refine</span> <span class=\"n\">main_thm</span> <span class=\"err\">%%</span><span class=\"n\">X</span> <span class=\"err\">%%</span><span class=\"n\">e₁</span> <span class=\"err\">%%</span><span class=\"n\">e₂</span> <span class=\"n\">rfl</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">],</span>\n  <span class=\"n\">all_goals</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ring_expr</span><span class=\"bp\">.</span><span class=\"kn\">eval</span><span class=\"o\">,</span>\n    <span class=\"n\">znum</span><span class=\"bp\">.</span><span class=\"n\">cast_pos</span><span class=\"o\">,</span> <span class=\"n\">znum</span><span class=\"bp\">.</span><span class=\"n\">cast_neg</span><span class=\"o\">,</span> <span class=\"n\">znum</span><span class=\"bp\">.</span><span class=\"n\">cast_zero&#39;</span><span class=\"o\">,</span>\n    <span class=\"n\">pos_num</span><span class=\"bp\">.</span><span class=\"n\">cast_bit0</span><span class=\"o\">,</span> <span class=\"n\">pos_num</span><span class=\"bp\">.</span><span class=\"n\">cast_bit1</span><span class=\"o\">,</span>\n    <span class=\"n\">pos_num</span><span class=\"bp\">.</span><span class=\"n\">cast_one&#39;</span><span class=\"o\">]]</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">do</span> <span class=\"n\">ring_tac</span> <span class=\"bp\">```</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">axioms</span> <span class=\"n\">X</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">ring_tac</span>\n</pre></div>",
        "id": 127979328,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528844777
    },
    {
        "content": "<p>Did my homework</p>",
        "id": 127979329,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528844779
    },
    {
        "content": "<p>I feel like an UG again</p>",
        "id": 127979333,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528844814
    },
    {
        "content": "<p>Notes: I had to introduce poly.smul (scalar multiplication of poly by znum) for definition of multiplication. I really tried to make simp do most of the work in general but I still had to do a lot of unfolding before I could get it going.</p>",
        "id": 127979394,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528844902
    },
    {
        "content": "<p>did you just write a tactic?</p>",
        "id": 127979395,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1528844916
    },
    {
        "content": "<p>Not really</p>",
        "id": 127979401,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528844923
    },
    {
        "content": "<p>in the sense that no code I wrote started with <code>meta</code></p>",
        "id": 127979405,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528844932
    },
    {
        "content": "<p>but check it out</p>",
        "id": 127979408,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528844943
    },
    {
        "content": "<p>barely any code at all has <code>meta</code></p>",
        "id": 127979412,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528844950
    },
    {
        "content": "<p>Just <code>reflect_expr</code> at the very top, and <code>ring_tac</code> at the very bottom. Mario wrote both of those</p>",
        "id": 127979416,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528844996
    },
    {
        "content": "<p>Kenny here's the strat: to prove that for d : int we have (d+1)^2=d^2+2*d+1 we first prove that in a polynomial ring we have (X+1)^2=X^2+2X+1 and then deduce</p>",
        "id": 127979480,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528845035
    },
    {
        "content": "<p>The problem is that if Lean just sees (d+1)^2 it can't create (X+1)^2</p>",
        "id": 127979481,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528845053
    },
    {
        "content": "<p>so this part you have to do in meta-land</p>",
        "id": 127979489,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528845064
    },
    {
        "content": "<p>but it's only this part</p>",
        "id": 127979491,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528845074
    },
    {
        "content": "<p>unsurprisingly, this is what <code>reflect_expr</code> does</p>",
        "id": 127979496,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528845096
    },
    {
        "content": "<p>So there's a basic one-variable ring tactic with a very small amount of meta indeed, and the meta is really not hard to comprehend. I mean, it might be hard to write, but it's not at all hard to read.</p>",
        "id": 127979537,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528845133
    },
    {
        "content": "<p>I'll write a blog post explaining it but now it's bed time. Once again many thanks Mario.</p>",
        "id": 127979539,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528845154
    },
    {
        "content": "<p>Just to be clear <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> the code I posted does seem to be a fully working baby <code>ring</code></p>",
        "id": 127979604,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528845284
    },
    {
        "content": "<p>Actually it doesn't work in all cases, because there is currently no \"canonical form\" lemma. The polynomials <code>[1]</code> and <code>[1,0]</code> (=0*x+1) are different.</p>",
        "id": 128000038,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528883744
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Here are the three questions I have about this project, which basically came up when trying to write a blog post. The first two are trivial for you: what is <code>@[derive has_reflect]</code> and why <code>znum</code> rather than <code>int</code>?</p>",
        "id": 128000106,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528883831
    },
    {
        "content": "<p>The third is a bit more annoying. Because there is no algorithm to put polynomials (= lists of znums) into \"canonical form\", <code>example (x : ℤ) : (x + 1) + ((-1)*x + 1) = 2 := by do ring_tac ```(x) </code> fails</p>",
        "id": 128000111,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528883858
    },
    {
        "content": "<p>I think this is because the polynomials <code>[2,0]</code> and <code>[2]</code> are considered distinct.</p>",
        "id": 128000156,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528883891
    },
    {
        "content": "<p>Aah, I think I can fix this.</p>",
        "id": 128000158,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528883911
    },
    {
        "content": "<p>I think I write some \"canonical_form\" function</p>",
        "id": 128000161,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528883931
    },
    {
        "content": "<p>(not in meta land)</p>",
        "id": 128000162,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528883937
    },
    {
        "content": "<p>and redefine add so that it puts the polynomial into canonical form afterwards.</p>",
        "id": 128000171,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528883965
    },
    {
        "content": "<p>yeah yeah OK I think I can do this one.</p>",
        "id": 128000180,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528883987
    },
    {
        "content": "<blockquote>\n<p>Why <code>@[derive has_reflect]</code></p>\n</blockquote>\n<p>This one is easy: otherwise you don't have a <code>reflect</code> instance for <code>ring_expr</code>. This function is used explicitly in <code>ring_tac</code>; the idea is that if <code>A</code> is a reflectable type then <code>reflect (a : A)</code> is an expr that denotes the same value as <code>a</code></p>",
        "id": 128001631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528886168
    },
    {
        "content": "<p>so for example <code>list</code> has a reflect that just turns each cons into a <code>expr.app ``list.cons a l</code></p>",
        "id": 128001637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528886217
    },
    {
        "content": "<p>and <code>nat</code> has a reflect that produces <code>bit0</code> and <code>bit1</code> expressions (which when printed appear as the number being denoted)</p>",
        "id": 128001644,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528886258
    },
    {
        "content": "<p>But not all types have a reflect; in particular quotients and other things that make different expressions equal according to lean don't have a reflect, since you would have to open up the quotient to get the element to print</p>",
        "id": 128001686,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528886323
    },
    {
        "content": "<p>In this case it is needed because <code>reflect_expr</code> produces a <code>ring_expr</code>, not an <code>expr</code> denoting a <code>ring_expr</code></p>",
        "id": 128001696,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528886390
    },
    {
        "content": "<p>I think in this case you could skip the extra step and just produce an expr directly, but that would be less structured and more meta</p>",
        "id": 128001746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528886435
    },
    {
        "content": "<blockquote>\n<p>Why <code>znum</code></p>\n</blockquote>\n<p>This one is more subtle, and actually I knew you would ask this question and I used it in part to prompt the question. You can view this as an efficiency move, but when there is an exponential performance gap I think it is close enough to essential to teach directly. Whenever you use proof by reflection, it is absolutely essential that you do everything you can to make the computation simple and direct, because you will be working with a fairly heavy handicap. A big no-no is using <code>nat</code> and <code>int</code> anywhere in your computation, because (as Seul has discovered) this works in unary and there is nothing you can do to prevent this when computing in the kernel</p>",
        "id": 128001856,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528886667
    },
    {
        "content": "<p>This is in fact the raison d'etre for the <code>num</code> type - it allows for performing <em>kernel computations</em> on naturals and integers, with enough lemmas to relate them back to the more traditional <code>nat</code> type.</p>",
        "id": 128001891,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528886740
    },
    {
        "content": "<p>It's a bit of a delicate move, since <code>int</code> and <code>nat</code> are in fact the more efficient ones in VM computations, so you want to convert from <code>int</code> to <code>znum</code> when storing the numbers inside the kernel data structure (<code>ring_expr</code>), but not before</p>",
        "id": 128001947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528886866
    },
    {
        "content": "<blockquote>\n<p>The third is a bit more annoying. Because there is no algorithm to put polynomials (= lists of znums) into \"canonical form\", example (x : ℤ) : (x + 1) + ((-1)*x + 1) = 2 := by do ring_tac ```(x) fails</p>\n</blockquote>\n<p>I noticed this as well with your definition of <code>poly.add</code>. But there is actually another solution, which might be easier than applying a function that strips the high zeros after every operation. That is, define</p>\n<div class=\"codehilite\"><pre><span></span>def poly.is_eq : poly -&gt; poly -&gt; bool := sorry\n</pre></div>\n\n\n<p>so that trailing zeros are ignored in the equality test, and then replace <code>to_poly e1 = to_poly e2</code> with <code>poly.is_eq (to_poly e1) (to_poly e2)</code> in the <code>main_thm</code> and prove it with this (weaker) assumption</p>",
        "id": 128002085,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528887113
    },
    {
        "content": "<p>So, if I defined a new poly type quotiented with this equality relation, I'd have to explicitly define my denotation function? That doesn't sound so bad, I think... or would the kernel get stuck trying to reduce it?</p>",
        "id": 128005278,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1528892347
    },
    {
        "content": "<p>maybe I should just try it out with the helpful reflection template that's just been posted :)</p>",
        "id": 128005285,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1528892397
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">is_eq_aux</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">znum</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">list</span> <span class=\"n\">znum</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"bp\">::</span> <span class=\"n\">t₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">is_eq_aux</span> <span class=\"o\">[]</span> <span class=\"n\">t₂</span> <span class=\"k\">else</span> <span class=\"n\">ff</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"bp\">::</span> <span class=\"n\">t₁</span><span class=\"o\">)</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">is_eq_aux</span> <span class=\"n\">t₁</span> <span class=\"o\">[]</span> <span class=\"k\">else</span> <span class=\"n\">ff</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"bp\">::</span> <span class=\"n\">t₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"bp\">::</span> <span class=\"n\">t₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"bp\">=</span> <span class=\"n\">h₂</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">is_eq_aux</span> <span class=\"n\">t₁</span> <span class=\"n\">t₂</span> <span class=\"k\">else</span> <span class=\"n\">ff</span>\n\n<span class=\"n\">def</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">is_eq</span> <span class=\"o\">:</span> <span class=\"n\">poly</span> <span class=\"bp\">→</span> <span class=\"n\">poly</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">is_eq_aux</span>\n</pre></div>",
        "id": 128015942,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528905833
    },
    {
        "content": "<p>[recursion on poly doesn't seem to work]</p>",
        "id": 128015985,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528905851
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">eval_is_eq</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">p₁</span> <span class=\"n\">p₂</span> <span class=\"o\">:</span> <span class=\"n\">poly</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">is_eq</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span> <span class=\"bp\">→</span> <span class=\"n\">p₁</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">p₂</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">revert</span> <span class=\"n\">p₂</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">p₁</span> <span class=\"k\">with</span> <span class=\"n\">h₁</span> <span class=\"n\">t₁</span> <span class=\"n\">H₁</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">p₂</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">p₂</span> <span class=\"k\">with</span> <span class=\"n\">h₁</span> <span class=\"n\">t₁</span> <span class=\"n\">H₂</span><span class=\"o\">,</span><span class=\"n\">refl</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"kn\">eval</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">is_eq</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">is_eq_aux</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"n\">split_ifs</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span><span class=\"n\">swap</span><span class=\"o\">,</span><span class=\"n\">cases</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"err\">←</span><span class=\"n\">H₂</span> <span class=\"n\">H</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">p₂</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">p₂</span> <span class=\"k\">with</span> <span class=\"n\">h₂</span> <span class=\"n\">t₂</span> <span class=\"n\">H₂</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">unfold</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"kn\">eval</span><span class=\"o\">,</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">is_eq</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">is_eq_aux</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n      <span class=\"n\">split_ifs</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span><span class=\"n\">swap</span><span class=\"o\">,</span><span class=\"n\">cases</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"n\">H₁</span> <span class=\"n\">H</span><span class=\"o\">],</span>\n      <span class=\"n\">simp</span>\n    <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">unfold</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"kn\">eval</span><span class=\"o\">,</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">is_eq</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">is_eq_aux</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n      <span class=\"n\">split_ifs</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span><span class=\"n\">swap</span><span class=\"o\">,</span><span class=\"n\">cases</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">is_eq</span> <span class=\"n\">at</span> <span class=\"n\">H₂</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"n\">H₁</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">}</span>\n</pre></div>",
        "id": 128015998,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528905881
    },
    {
        "content": "<p>and then all we need is</p>",
        "id": 128016003,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528905888
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">main_thm</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e₁</span> <span class=\"n\">e₂</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x₁</span> <span class=\"n\">x₂</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">is_eq</span> <span class=\"o\">(</span><span class=\"n\">to_poly</span> <span class=\"n\">e₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">to_poly</span> <span class=\"n\">e₂</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">R1</span> <span class=\"o\">:</span> <span class=\"n\">e₁</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">x₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R2</span> <span class=\"o\">:</span> <span class=\"n\">e₂</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">x₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x₁</span> <span class=\"bp\">=</span> <span class=\"n\">x₂</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">R1</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">R2</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">to_poly_eval</span><span class=\"o\">,</span><span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">eval_is_eq</span> <span class=\"n\">X</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">to_poly_eval</span><span class=\"o\">]</span>\n</pre></div>",
        "id": 128016019,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528905905
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">do</span> <span class=\"n\">ring_tac</span> <span class=\"bp\">```</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">((</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">do</span> <span class=\"n\">ring_tac</span> <span class=\"bp\">```</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 128016043,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528905946
    },
    {
        "content": "<p>they both work :-)</p>",
        "id": 128016051,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528905952
    },
    {
        "content": "<p>I wouldn't recommend using a quotient, although it probably won't hurt</p>",
        "id": 128034425,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528930568
    },
    {
        "content": "<p>The VM can erase that stuff but the kernel has to deal with it all</p>",
        "id": 128034426,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528930568
    },
    {
        "content": "<p>if you keep all the functions simple and nondependent, the kernel doesn't have to carry around all the proof garbage</p>",
        "id": 128034427,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528930568
    },
    {
        "content": "<p>for the reason of \"working with a handicap\" I mentioned</p>",
        "id": 128034428,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528930568
    },
    {
        "content": "<p>Your definition didn't work on <code>poly</code> because it uses well founded recursion, which is another kernel no-no (it has to unfold the well foundedness proofs)</p>",
        "id": 128034990,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528931486
    },
    {
        "content": "<p>Try this instead:</p>\n<div class=\"codehilite\"><pre><span></span>def poly.is_zero : poly → bool\n| [] := tt\n| (h :: t) := (h = 0) &amp;&amp; poly.is_zero t\n\ndef poly.is_eq : poly → poly → bool\n| l₁ [] := poly.is_zero l₁\n| [] l₂ := poly.is_zero l₂\n| (h₁ :: t₁) (h₂ :: t₂) := if (h₁ = h₂) then poly.is_eq t₁ t₂ else ff\n</pre></div>\n\n\n<p>(sorry for all the proof obligations!)</p>",
        "id": 128034994,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528931504
    },
    {
        "content": "<p>(Alternatively, if you defined subtraction or an equivalent you could use only <code>is_zero</code> and define <code>is_eq</code> by <code>(p1 - p2).is_zero</code>)</p>",
        "id": 128035061,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528931623
    },
    {
        "content": "<p>Why bool and not Prop?</p>",
        "id": 128050689,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528960079
    },
    {
        "content": "<p>He did it on purpose to prompt this question! ;)</p>",
        "id": 128050810,
        "sender_full_name": "Moses Schönfinkel",
        "timestamp": 1528960292
    },
    {
        "content": "<p><a href=\"https://xenaproject.wordpress.com/2018/06/13/ab3/\" target=\"_blank\" title=\"https://xenaproject.wordpress.com/2018/06/13/ab3/\">https://xenaproject.wordpress.com/2018/06/13/ab3/</a></p>",
        "id": 128054279,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528966367
    },
    {
        "content": "<p>Comments welcome. That's how some baby version of tactic.ring works, at least. And of course many thanks to Mario, without whom that little project would have taken far longer to complete.</p>",
        "id": 128054290,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528966404
    },
    {
        "content": "<p>I know the post is mega-long but I am not sure I care.</p>",
        "id": 128054294,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528966429
    },
    {
        "content": "<p>This is chapter 3 of your book?</p>",
        "id": 128054577,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528966878
    },
    {
        "content": "<p>I read and enjoyed your blog post! My only comment is perhaps you might have a further reading section. It would be a good place to link <a href=\"http://adam.chlipala.net/cpdt/html/Reflection.html\" target=\"_blank\" title=\"http://adam.chlipala.net/cpdt/html/Reflection.html\">http://adam.chlipala.net/cpdt/html/Reflection.html</a> and <a href=\"https://softwarefoundations.cis.upenn.edu/vfa-current/Decide.html#lab185\" target=\"_blank\" title=\"https://softwarefoundations.cis.upenn.edu/vfa-current/Decide.html#lab185\">https://softwarefoundations.cis.upenn.edu/vfa-current/Decide.html#lab185</a> for people who are trying to seriously write a reflective tactic (although, unfortunately, you have to read Coq to understand what's going on... but I think at this stage of Lean's popularity, this is somewhat necessary regardless in the tactics game). Also, minor nitpick, but <code>znum</code> is only uber-efficient when it is used in <code>rfl</code> proofs, otherwise <code>int</code> has special fast support</p>",
        "id": 128059587,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1528975416
    },
    {
        "content": "<p>Many thanks Andrew. I am not a computer scientist as I'm sure you know and I don't really know about references. I have looked, briefly, at both of the things you mention, but I have never really substantially engaged with them -- I tend to stop reading when things get \"too CS\" because they become less relevant to what I am trying to do in Lean. Thanks for the nitpick too.</p>",
        "id": 128067635,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528986675
    },
    {
        "content": "<blockquote>\n<p>Why bool and not Prop?</p>\n</blockquote>\n<p>Because you can't compute with Props. You could get roughly the same behavior by using <code>decidable p</code> instead of <code>bool</code> (+ soundness proof), but since there are more dependency tricks there I suspect it's marginally slower than using bool (but not by any large margin).</p>",
        "id": 128067751,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528986811
    },
    {
        "content": "<p>In this case, the bool definition functions both as the relation itself and its decidability proof. If you wanted to use decidable, then, it would be two definitions and a soundness proof</p>",
        "id": 128067896,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528986963
    },
    {
        "content": "<blockquote>\n<p>This is chapter 3 of your book?</p>\n</blockquote>\n<p>I am not sure if this is book material.</p>",
        "id": 128074464,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528995829
    }
]
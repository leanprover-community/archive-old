[
    {
        "content": "<p>Are there things that are decidable but not yet proven?</p>",
        "id": 124428848,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522442470
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span></p>",
        "id": 124428850,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522442480
    },
    {
        "content": "<p>Not sure I understand the meta level of the question</p>",
        "id": 124428860,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522442514
    },
    {
        "content": "<p>that means, things that should be decidable, but nobody has proved it in Lean yet</p>",
        "id": 124428902,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522442530
    },
    {
        "content": "<p>of course</p>",
        "id": 124428905,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522442537
    },
    {
        "content": "<p>could you list some</p>",
        "id": 124428906,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522442544
    },
    {
        "content": "<p>that's like asking if there are any not yet proven theorems</p>",
        "id": 124428908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522442548
    },
    {
        "content": "<p>well there are only finitely many predicates that have been created in Lean</p>",
        "id": 124428920,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522442574
    },
    {
        "content": "<p>Hm, none comes to mind... I have a definition that I don't have on mathlib yet that is waiting for a proof of decidability</p>",
        "id": 124428942,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522442633
    },
    {
        "content": "<p>what is it</p>",
        "id": 124428945,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522442640
    },
    {
        "content": "<p>namely that level (in)equality in lean is decidable</p>",
        "id": 124428987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522442649
    },
    {
        "content": "<p>hmm...</p>",
        "id": 124428992,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522442663
    },
    {
        "content": "<p>that is, for expressions made up of <code>max</code>, <code>imax</code> and variables, you can determine if for all values of the variables in <code>nat</code>, one is &lt;= the other or not</p>",
        "id": 124429012,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522442703
    },
    {
        "content": "<p>The proof uses case splitting on any <code>imax</code> expressions that come up</p>",
        "id": 124429027,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522442742
    },
    {
        "content": "<p>oh, I should build a decidable version of <code>finsupp</code></p>",
        "id": 124429032,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522442748
    },
    {
        "content": "<p>I think Johannes had a proposal for that on here, where you use a <code>fintype</code> instead of <code>finite</code></p>",
        "id": 124429086,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522442792
    },
    {
        "content": "<p>oh wait, I don't work with finite things</p>",
        "id": 124429095,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522442803
    },
    {
        "content": "<p>lol</p>",
        "id": 124429096,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522442804
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> no examples from <code>nat</code> and <code>int</code>?</p>",
        "id": 124429371,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522443212
    },
    {
        "content": "<p>i.e. everything about them that should be decidable have been proven to be decidable?</p>",
        "id": 124429372,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522443221
    },
    {
        "content": "<p>yes, there aren't that many interesting predicate to start with</p>",
        "id": 124429446,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522443338
    },
    {
        "content": "<p>nice</p>",
        "id": 124429495,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522443364
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> out of curiousity what's up with your commutative algebra pr on mathlib</p>",
        "id": 124430652,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522445254
    },
    {
        "content": "<p>I just started reworking it a few minutes ago, what a coincidence</p>",
        "id": 124430671,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522445278
    },
    {
        "content": "<p>Kenny feel free to PR some of the comm alg stuff in stacks project. Did UMP get PR'd? That's a really important tool I see now.</p>",
        "id": 124433277,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522450033
    },
    {
        "content": "<p>I can't PR anything until mathlib builds</p>",
        "id": 124433281,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522450048
    },
    {
        "content": "<p>Oh I see.</p>",
        "id": 124433282,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522450053
    },
    {
        "content": "<p>Why don't you roll back?</p>",
        "id": 124433283,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522450061
    },
    {
        "content": "<p>I mean, the PR will have a cross</p>",
        "id": 124433324,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522450090
    },
    {
        "content": "<p>I know it's a bore. Whenever Lean head and mathlib head don't play well together you're suddenly having to look up commits.</p>",
        "id": 124433326,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522450094
    },
    {
        "content": "<p>I just never upgrade unless I have no red cross and also a thumbs up here</p>",
        "id": 124433332,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522450126
    },
    {
        "content": "<p>I think Sebastian is seriously looking at making this kind of thing easier with leanpkg.</p>",
        "id": 124433342,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522450160
    },
    {
        "content": "<p>I still don't know why the latest build fails</p>",
        "id": 124433346,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522450177
    },
    {
        "content": "<p>Hi, quick question! What tactic would allow me to show decidable equality of records? I need to show:</p>\n<div class=\"codehilite\"><pre><span></span>⊢ decidable ({o := x_o, m := x_m, τ := x_τ} = {o := y_o, m := y_m, τ := y_τ})\n</pre></div>\n\n\n<p>where I know <code>decidable(x_o = y_o)</code>, ..., <code>decidable(x_τ = y_τ)</code>.</p>",
        "id": 158128820,
        "sender_full_name": "Hans-Dieter Hiep",
        "timestamp": 1549987572
    },
    {
        "content": "<p><code>@[derive decidable_eq]</code> when you define the structure.</p>",
        "id": 158128846,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1549987602
    },
    {
        "content": "<p>Now, I get an unhelpful error message: <code>failed to find a derive handler for ...</code>. What does this mean?</p>",
        "id": 158377477,
        "sender_full_name": "Hans-Dieter Hiep",
        "timestamp": 1549997876
    },
    {
        "content": "<p>It is related to the fact that I have defined an inductive type <code>value</code>. Is that somehow a protected name?</p>",
        "id": 158377593,
        "sender_full_name": "Hans-Dieter Hiep",
        "timestamp": 1549997963
    },
    {
        "content": "<p>Is the inductive type value a field to your structure?</p>",
        "id": 158377610,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1549997983
    },
    {
        "content": "<p>What does the <code>...</code> say?</p>",
        "id": 158377615,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1549997992
    },
    {
        "content": "<p>Would be easier to say looking at the code and actual error message, but I think <code>...</code> is the class you want to derive, e.g., <code>decidable_eq</code></p>",
        "id": 158377744,
        "sender_full_name": "Reid Barton",
        "timestamp": 1549998068
    },
    {
        "content": "<p><code>failed to find a derive handler for 'choice decidable_eq value.decidable_eq'</code><br>\nHere, choice and decidable_eq are built-in, but value.decidable_eq seems to be related to the generated instance for the type <code>value</code> that I defined earlier.</p>",
        "id": 158377747,
        "sender_full_name": "Hans-Dieter Hiep",
        "timestamp": 1549998069
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>@[derive decidable_eq]\ninductive value (β : Type) [objects α β] : type α → Type 1\n| object {c : class_name α} (o : β)\n    (H : c = class_of α o) : value (ref c)\n| null (c : class_name α) : value (ref c)\n| term {γ : datatype} : γ → value (data α γ)\n</pre></div>\n\n\n<p>Now, I change the name <code>value</code> to <code>valu</code>. Then the error changes!</p>",
        "id": 158377836,
        "sender_full_name": "Hans-Dieter Hiep",
        "timestamp": 1549998124
    },
    {
        "content": "<p>Hmmm, never mind. Unable to reproduce that now. It still is: <code>failed to find a derive handler for 'choice decidable_eq valu.decidable_eq'</code></p>",
        "id": 158377933,
        "sender_full_name": "Hans-Dieter Hiep",
        "timestamp": 1549998207
    },
    {
        "content": "<p>Is it confused by something you've defined called<code> decidable_eq</code>? I replicated the error.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">namespace</span> <span class=\"n\">foo</span>\n\n<span class=\"n\">def</span> <span class=\"n\">decidable_eq</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">derive</span> <span class=\"n\">decidable_eq</span><span class=\"o\">]</span> <span class=\"kn\">structure</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">foo</span>\n</pre></div>",
        "id": 158377951,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1549998225
    },
    {
        "content": "<p>maybe a manually-written instance of <code>decidable_eq</code> got a name like that?</p>",
        "id": 158378030,
        "sender_full_name": "Reid Barton",
        "timestamp": 1549998282
    },
    {
        "content": "<p>Sure, but I have never defined any decidable_eq myself. The <code>value.decidable_eq</code> is not defined by me, but derived.</p>",
        "id": 158378069,
        "sender_full_name": "Hans-Dieter Hiep",
        "timestamp": 1549998339
    },
    {
        "content": "<p>What namespaces do you have open? Maybe the error is something you've imported.</p>",
        "id": 158378227,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1549998470
    },
    {
        "content": "<p>If I remove <code>@[derive decidable_eq]</code> from the <code>value</code> definition, the error changes into something more sensible: <code>mk_dec_eq_instance failed, failed to generate instance for\n  Π (a b : Π (p : param_name m), value β (param_type p)), decidable (a = b)</code> So it must be caused by the derived instance of <code>value</code>.</p>",
        "id": 158378302,
        "sender_full_name": "Hans-Dieter Hiep",
        "timestamp": 1549998506
    },
    {
        "content": "<p>Of course. I'm confused by <code>choice</code> in the error message. Is this <code>classical.choice</code>?</p>",
        "id": 158378497,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1549998625
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> Indeed, I have opened the namespace <code>value</code> in which the name <code>decidable_eq</code> was defined by the derivation. Thanks, stupid mistake!</p>",
        "id": 158378500,
        "sender_full_name": "Hans-Dieter Hiep",
        "timestamp": 1549998626
    },
    {
        "content": "<p>aha!<br>\nMaybe <code>choice X.foo Y.foo</code> is how Lean represents \"I haven't figured out whether you're talking about <code>X.foo</code> or <code>Y.foo</code> yet\"?</p>",
        "id": 158378712,
        "sender_full_name": "Reid Barton",
        "timestamp": 1549998795
    },
    {
        "content": "<p>I confirm that. You can see that here:</p>\n<div class=\"codehilite\"><pre><span></span>namespace foo\n\ndef value.decidable_eq : Type := sorry\nopen value\n\n@[derive decidable_eq] structure foo :=\n(bar : ℕ)\n\nend foo\n</pre></div>",
        "id": 158378829,
        "sender_full_name": "Hans-Dieter Hiep",
        "timestamp": 1549998883
    },
    {
        "content": "<p><code>open</code>ing previous inductive types when defining new ones is a totally reasonable thing to do, it's annoying that it causes this <code>derive decidable_eq</code> mechanism to break.</p>",
        "id": 158378864,
        "sender_full_name": "Reid Barton",
        "timestamp": 1549998904
    },
    {
        "content": "<p>Well, it's a totally reasonable thing to want to do, at any rate.</p>",
        "id": 158378919,
        "sender_full_name": "Reid Barton",
        "timestamp": 1549998938
    },
    {
        "content": "<p>Seems like <code>value.decidable_eq</code> should have been <code>protected</code>, then I guess this wouldn't have happened.</p>",
        "id": 158379021,
        "sender_full_name": "Reid Barton",
        "timestamp": 1549998998
    },
    {
        "content": "<p>I agree; if you add <code>protected</code> in the foo snippet above, the derive mechanism works as expected.</p>",
        "id": 158379096,
        "sender_full_name": "Hans-Dieter Hiep",
        "timestamp": 1549999061
    },
    {
        "content": "<p>I'm surprised the lack of <code>protected</code> doesn't break other things though. Seems like having open an inductive/structure type with derived <code>decidable_eq</code> would be pretty common. Maybe Lean is able to resolve the ambiguity in most other situations</p>",
        "id": 158379363,
        "sender_full_name": "Reid Barton",
        "timestamp": 1549999223
    },
    {
        "content": "<p>yes, <code>choice</code> is how lean represents an overloaded name in pexprs</p>",
        "id": 158385027,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550003521
    },
    {
        "content": "<p>what better way to represent an overloaded name than by an overloaded name</p>",
        "id": 158385214,
        "sender_full_name": "Reid Barton",
        "timestamp": 1550003663
    }
]
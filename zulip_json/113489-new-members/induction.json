[
    {
        "content": "<p>How to say this kind of induction?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">example</span>  <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">intros</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">m</span> <span class=\"bp\">-</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"c1\">-- it doesnt like this</span>\n\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 207225846,
        "sender_full_name": "Iocta",
        "timestamp": 1597730089
    },
    {
        "content": "<p>One thing you can do is prove a related statement first, where <code>m - n</code> is replaced by a variable:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">example</span>  <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">key</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">),</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">k</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"n\">h&#39;</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">k_ih</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">zero_le</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">a</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"n\">intros</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">h&#39;</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n  <span class=\"n\">convert_to</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">-</span> <span class=\"n\">n</span><span class=\"o\">)),</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">add_sub_of_le</span> <span class=\"n\">h&#39;</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">key</span><span class=\"o\">,</span>\n  <span class=\"n\">linarith</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>There's also a direct proof:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">example</span>  <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">h&#39;</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">m</span> <span class=\"n\">generalizing</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">le_zero_iff_eq</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">h&#39;</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">id</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">h&#39;&#39;</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m_n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">,</span> <span class=\"n\">rwa</span> <span class=\"n\">h&#39;&#39;</span> <span class=\"n\">at</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">m_ih</span> <span class=\"n\">n</span> <span class=\"bp\">_</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ_eq_add_one</span> <span class=\"n\">at</span> <span class=\"n\">h&#39;</span> <span class=\"n\">h&#39;&#39;</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">eq_or_lt_of_le</span> <span class=\"n\">h&#39;</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exfalso</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h&#39;&#39;</span> <span class=\"n\">h_1</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">linarith</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 207227067,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597731860
    },
    {
        "content": "<p>I see, thanks.</p>",
        "id": 207227258,
        "sender_full_name": "Iocta",
        "timestamp": 1597732151
    },
    {
        "content": "<p><code>induction h</code></p>",
        "id": 207227427,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1597732338
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p_succ_of_p</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n\n<span class=\"kn\">example</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">intros</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>How I can declare <code>p_succ_of_p</code> as a top-level variable and still refer to it inside the <code>example</code> proof?</p>",
        "id": 207227905,
        "sender_full_name": "Iocta",
        "timestamp": 1597733031
    },
    {
        "content": "<p>Assuming this is actually what you want to do, you can use <code>include</code></p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p_succ_of_p</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n<span class=\"n\">include</span> <span class=\"n\">p_succ_of_p</span>\n\n<span class=\"kn\">example</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">intros</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 207228051,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597733167
    },
    {
        "content": "<p>What is happening is that <code>variables</code> declares variables that will be auto-included if they are referred to in the statement of the lemma, definition, or example, and <code>include</code> overrides this to always include it.  You can use <code>omit</code> later to cause it to go back to the default behavior if I remember correctly.</p>",
        "id": 207228172,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597733289
    },
    {
        "content": "<p>ah that's what I was looking for</p>",
        "id": 207228247,
        "sender_full_name": "Iocta",
        "timestamp": 1597733380
    },
    {
        "content": "<p>What would be suitable to represent a formula of a sum as the following one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">sum</span> <span class=\"n\">k</span> <span class=\"n\">between</span> <span class=\"n\">k</span><span class=\"bp\">=</span><span class=\"mi\">1</span> <span class=\"n\">and</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n</code></pre></div>\n\n<p>I don't find a way, if it is possible at all to try it this way, to represent the equation's left hand side of the formula.</p>",
        "id": 211025373,
        "sender_full_name": "Claus-Peter Becke",
        "timestamp": 1600877356
    },
    {
        "content": "<p>have you seen <code>algebra.big_operators</code>?</p>",
        "id": 211026053,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1600877636
    },
    {
        "content": "<p>No, I didn't. Thank you for that hint.</p>",
        "id": 211026450,
        "sender_full_name": "Claus-Peter Becke",
        "timestamp": 1600877802
    },
    {
        "content": "<p>As far as I have seen the operator sum works on finite sets. I would like to prove by induction the assertion's validity on the infinite set of natural numbers.</p>",
        "id": 211093498,
        "sender_full_name": "Claus-Peter Becke",
        "timestamp": 1600928377
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n\n<span class=\"c1\">-- finset.range n is the set {0,1,2, ..., n-1}</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">range</span> <span class=\"mi\">5</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- So finset.range n.succ is the set {0,1,2,...,n}</span>\n<span class=\"c1\">-- In this case, the extra `0` term being summed makes no difference, since</span>\n<span class=\"c1\">--  n     n</span>\n<span class=\"c1\">--  ∑ i = ∑ i</span>\n<span class=\"c1\">--  i=0   i=1</span>\n\n<span class=\"c1\">-- Then, we can represent</span>\n<span class=\"c1\">--  n</span>\n<span class=\"c1\">--  ∑ i</span>\n<span class=\"c1\">--  i=0</span>\n<span class=\"c1\">--</span>\n<span class=\"c1\">-- as ∑ i in (range n.succ), i</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">n.succ</span><span class=\"o\">),</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 211099232,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1600934106
    },
    {
        "content": "<p>Why not cast the i in the sum to a rational, in order to get that division to be mathematical division rather than some weird rounding one?</p>",
        "id": 211103752,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600937286
    },
    {
        "content": "<p>@Shing Tag Lam: Thank you very much for your solution which is really helpful. This is a great model for me to be studied closely to become more familiar with the techniques which are needed to deal with induction.<br>\n@Kevin Buzzard: As far as I remember type-casting is used in Java writing the target type in brackets in front of the variable to be casted. Does it  work similar in Lean?</p>",
        "id": 211119394,
        "sender_full_name": "Claus-Peter Becke",
        "timestamp": 1600948072
    },
    {
        "content": "<p>@Shing Tak Lam: I'm sorry for the misspelling of your name</p>",
        "id": 211119864,
        "sender_full_name": "Claus-Peter Becke",
        "timestamp": 1600948348
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329867\">@Claus-Peter Becke</span> If you write <code>@Shi</code> then Zulip should suggest autocompletions of the name (unless you use a nonstandard zulip client).<br>\nThe benefit of those auto-completed names is that the person in question gets a notification somewhere in their interface.</p>",
        "id": 211120170,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1600948490
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329867\">Claus-Peter Becke</span> <a href=\"#narrow/stream/113489-new-members/topic/induction/near/211119394\">said</a>:</p>\n<blockquote>\n<p>@Shing Tag Lam: Thank you very much for your solution which is really helpful. This is a great model for me to be studied closely to become more familiar with the techniques which are needed to deal with induction.<br>\n@Kevin Buzzard: As far as I remember type-casting is used in Java writing the target type in brackets in front of the variable to be casted. Does it  work similar in Lean?</p>\n</blockquote>\n<p>You can use <code>(term : type)</code> to coerce the <code>i</code> to a rational number like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">n.succ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n</code></pre></div>\n\n<p>And you'll see <code>↑</code> next to the <code>n</code> in the tactic state, which is Lean coercing <code>n</code> from a <code>nat</code> to a <code>rat</code>.</p>\n<p>In this specific example, natural number division isn't an issue, since <code>n * (n + 1) / 2 = (n * (n + 1)) / 2</code> and <code>n * (n + 1)</code> is always even, but in general, flooring division may not be what you want, hence Kevin is suggesting you cast it to a rational number.</p>",
        "id": 211121711,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1600949370
    },
    {
        "content": "<p>It is an issue in the <em>proof</em>, because you want to prove this by induction, and it will be much more horrible to work in the integers with its broken division than to work in the rationals with a division that obeys much nicer properties.</p>",
        "id": 211127390,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600952574
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">n.succ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- base case true by definition</span>\n    <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- inductive step</span>\n    <span class=\"n\">rw</span> <span class=\"n\">sum_range_succ</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nat.succ_eq_add_one</span><span class=\"o\">],</span>\n    <span class=\"n\">ring</span><span class=\"o\">,</span>\n  <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n\n<p>Proof when they're rationals goes through without thinking really.</p>",
        "id": 211127736,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600952749
    },
    {
        "content": "<p>Proof when they're integers will be much more of a pain, you'll have to look up specific lemmas like <code>a/b+c=(a+c*b)/b</code> etc.</p>",
        "id": 211127857,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600952798
    },
    {
        "content": "<p>Fair enough, I used <code>nat.div_eq_of_eq_mul_right</code> in my nat proof, but I already knew that lemma (which transforms the problem from nat division to one in nat multiplication), but I can see how dealing with division can be a pain.</p>",
        "id": 211129063,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1600953366
    },
    {
        "content": "<p>I just think that this sort of argument (fighting integer division) looks bad to mathematicians (especially those who have never used computer algebra software and are totally confused by the fact that 5/2 could ever be thought of as being equal to 2 -- this never happens on a calculator).</p>",
        "id": 211129410,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600953552
    },
    {
        "content": "<p>Thank you both very much for these awesome explanations which will supply me with a lot of stuff to think about and to learn from.</p>",
        "id": 211160857,
        "sender_full_name": "Claus-Peter Becke",
        "timestamp": 1600967130
    },
    {
        "content": "<p>Up to now I stick to the following stage of development of the proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n<span class=\"kn\">open</span> <span class=\"n\">algebra</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n    <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">zero_mul</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">succ_mul</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">succ_add</span><span class=\"o\">,</span>\n    <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">succ_eq_add_one</span><span class=\"o\">},</span>\n    <span class=\"n\">rw</span> <span class=\"n\">mul_succ</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">nat.left_distrib</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">nat.div_eq_of_eq_mul_right</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n\n<p>The application of these tactics generates the following result:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">tactic</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">there</span> <span class=\"n\">are</span> <span class=\"n\">unsolved</span> <span class=\"n\">goals</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>\n<span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">I</span>\n</code></pre></div>\n\n<p>The left hand side of the goal expresses the term which I would have liked to produce: (n+1)*(n+2) which shows the sum for n+1. But I fail in finding tactics to generate a solution which produces a suitable progress. The main problem I observed is that I don't have an focussed overview about the theorems which are stored in the library and which are applicable in the different contexts. Are there any exercises which help me to become more familiar with the nat-library after having finished the Natural Number Game?</p>",
        "id": 211345914,
        "sender_full_name": "Claus-Peter Becke",
        "timestamp": 1601102676
    },
    {
        "content": "<p>One strategy is to hope that the library is thorough, and use <code>library_search</code> to obtain the names of relevant lemmas. e.g. your first task to relate a sum over <code>range (n+1)</code> to a sum over <code>range n</code> and an extra term, and surely there must be a lemma doing this.</p>",
        "id": 211346118,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601103061
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">library_search</span>\n</code></pre></div>",
        "id": 211346189,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601103219
    },
    {
        "content": "<p>This finds <code>sum_range_succ</code> for you.</p>",
        "id": 211346228,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601103249
    },
    {
        "content": "<p>Another strategy is to realise that all statements in mathlib are named using an excruciatingly boring scheme, which is so boring that often you can predict the name if you know what you're looking for!</p>",
        "id": 211346241,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601103285
    },
    {
        "content": "<p>Since this is a lemma about the <code>sum</code> over a <code>range</code> involving a <code>succ</code>, it's not crazy (and feels much less crazy as you get used to it) to just guess <code>sum_range_succ</code> might exist. (Use #print to verify, or just <code>rw</code> by it if you're bold.)</p>",
        "id": 211346257,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601103337
    },
    {
        "content": "<p>(Note also that your example wasn't quite a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> --- without an <code>open_locale</code> statement it shouldn't work.)</p>",
        "id": 211346307,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601103418
    },
    {
        "content": "<p>@Scott Morrison:<br>\nThank you very much for your very helpful explanations. Yes, I forgot to add the open_locale big_operators statement. I tried the library_search-tactic, too. But it didn't produce any results. That's weird. But anyway. The sum_range_succ-tactic is very helpful because it allows to rewrite the right hand side of the goal via application of the induction-hypothesis which finally will help to close the goal, I hope at least.</p>",
        "id": 211346636,
        "sender_full_name": "Claus-Peter Becke",
        "timestamp": 1601103998
    },
    {
        "content": "<p>Note that <code>sum_range_succ</code> is a <em>lemma</em>, not a <em>tactic</em>. It's worth making the distinction.</p>",
        "id": 211347294,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601105127
    },
    {
        "content": "<p><code>library_search</code> only solves the exact goal it's presented with. That's why I wrote it out as an <code>example</code> rather than using it inline in your proof.</p>",
        "id": 211347337,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601105163
    },
    {
        "content": "<p>(You can also use the <code>have</code> tactic to setup a temporary goal mid-proof to try <code>library_search</code> on.)</p>",
        "id": 211347342,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601105185
    },
    {
        "content": "<p>Yes, I know. That was a moment of thoughtlessness in the face of the nerve-wracking trials to solve the problems concerning the simplification of the applied induction hypothesis.</p>",
        "id": 211347453,
        "sender_full_name": "Claus-Peter Becke",
        "timestamp": 1601105402
    },
    {
        "content": "<p>You should cast everything to rationals so that the division becomes easier to work with</p>",
        "id": 211347693,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1601105845
    },
    {
        "content": "<p>I tried a new example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n\n<p>and the application of the have-tactic:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">),</span>\n</code></pre></div>\n\n<p>In both cases Lean gave the message that 'library_search' failed after having used <code>by library_search</code></p>",
        "id": 211347745,
        "sender_full_name": "Claus-Peter Becke",
        "timestamp": 1601105931
    },
    {
        "content": "<p>well, it's very unlikely that <code>library_search</code> will help with that goal --- it's only suitable when there is a lemma in the library that gives you exactly your goal (possibly after substituting arguments from local hypotheses).</p>",
        "id": 211347802,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601106042
    },
    {
        "content": "<p>And you're still using a broken division</p>",
        "id": 211347811,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1601106068
    },
    {
        "content": "<p>This stuff would probably be doable with a tactic if you switch to rationals</p>",
        "id": 211347816,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1601106110
    },
    {
        "content": "<p>In fact, you can see that this example is actually <em>false</em>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.slim_check</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">slim_check</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 211347858,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601106129
    },
    {
        "content": "<p>which prints</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">===================</span>\n<span class=\"n\">Found</span> <span class=\"n\">problems</span><span class=\"bp\">!</span>\n\n<span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"mi\">2</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span>\n<span class=\"c1\">-------------------</span>\n</code></pre></div>",
        "id": 211347862,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601106143
    },
    {
        "content": "<p>(<code>slim_check</code> is very new to mathlib)</p>",
        "id": 211347873,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601106184
    },
    {
        "content": "<p>I observed that, too, and I wondered that Lean produces and accepts such an equation after having applied rw ih.</p>",
        "id": 211348191,
        "sender_full_name": "Claus-Peter Becke",
        "timestamp": 1601106804
    },
    {
        "content": "<p>Another problem with your variant is that <code>range n</code> is the n numbers from 0 to n-1 so what you're trying to prove is false</p>",
        "id": 211348237,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1601106864
    },
    {
        "content": "<p>You're also going to run into the issue that <code>x/2*2=x</code> is not true for naturals because the division is not mathematical division</p>",
        "id": 211348248,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1601106924
    },
    {
        "content": "<p>@Kevin Buzzard: Thank you very much for your hints. I will study your solution closely and try to apply it.</p>",
        "id": 211348920,
        "sender_full_name": "Claus-Peter Becke",
        "timestamp": 1601108131
    },
    {
        "content": "<p>Another approach would be to stick with naturals but clear denominators, and prove that twice the sum is n(n+1). Remember to use range (n+1) though -- if you stay with range n then you'll have to use natural subtraction which is broken in the same way</p>",
        "id": 211349676,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1601109375
    },
    {
        "content": "<p>The next days I will try to prove some induction-tasks, first with pen and paper, afterwards in Lean. It's very helpful to have the models which you and Shing Tak Lam posted the last days. Now I have a guide which serves as an instructor that can be varied to fit in respective contexts. To know of how to deal with sums on infinite sets and to have a collection of lemmata and tactics concerning these problems is a very good point to start from.</p>",
        "id": 211407715,
        "sender_full_name": "Claus-Peter Becke",
        "timestamp": 1601199476
    },
    {
        "content": "<p>Is there any possibility to solve the following goal?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⊢</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 211513409,
        "sender_full_name": "Claus-Peter Becke",
        "timestamp": 1601309436
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hn</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">4</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">this</span> <span class=\"o\">},</span>\n    <span class=\"n\">omega</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 211513981,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1601309731
    },
    {
        "content": "<p>But in general, nat subtraction is not very nice to deal with, Since <code>2 * n - 1 + 4</code> is not always equal to <code>2 * n + 3</code> (if <code>n = 0</code> LHS is <code>4</code> and RHS is <code>3</code>). In this specific example, if <code>n = 0</code>, you're multiplying by <code>0</code> so both sides do end up being equal.</p>",
        "id": 211514297,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1601309893
    },
    {
        "content": "<p>Thank you very much. I still have some trouble with the omega expression. I'll get the message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">eval_expr</span><span class=\"o\">,</span> <span class=\"n\">expression</span> <span class=\"n\">must</span> <span class=\"n\">be</span> <span class=\"n\">closed</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">¬∑</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">*</span> <span class=\"mi\">4</span> <span class=\"bp\">-</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬¬</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">4</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span>\n</code></pre></div>",
        "id": 211514844,
        "sender_full_name": "Claus-Peter Becke",
        "timestamp": 1601310183
    },
    {
        "content": "<p>Can you post what you have so far? From my experience, <code>omega</code> can be a bit fragile and additional hypotheses can stop it from working, and <code>clear</code>ing sometimes helps</p>",
        "id": 211514994,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1601310257
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.ring</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n<span class=\"kn\">open</span> <span class=\"n\">algebra</span>\n\n<span class=\"kd\">variables</span> <span class=\"n\">k</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span> <span class=\"n\">k</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">n.succ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">-</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">sum_range_succ</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nat.succ_eq_add_one</span><span class=\"o\">],</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">mul_add</span><span class=\"o\">},</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"n\">add_mul</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mul_add</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">ring</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 211515230,
        "sender_full_name": "Claus-Peter Becke",
        "timestamp": 1601310379
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.ring</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n<span class=\"kn\">open</span> <span class=\"n\">algebra</span>\n\n<span class=\"kd\">variables</span> <span class=\"n\">k</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span> <span class=\"n\">k</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">n.succ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">-</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">sum_range_succ</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nat.succ_eq_add_one</span><span class=\"o\">],</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">mul_add</span><span class=\"o\">},</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"n\">add_mul</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mul_add</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">ring</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"c1\">---- My part below</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"c1\">-- turns out we don't need `by_cases`, just `cases` is enough</span>\n  <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n.succ</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">4</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n.succ</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">this</span> <span class=\"o\">},</span>\n    <span class=\"n\">clear</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"c1\">-- We don't need ih here, and omega doesn't seem to like it</span>\n    <span class=\"n\">omega</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 211515765,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1601310623
    },
    {
        "content": "<p>Thank you very much. That's great. I tried a longer time to close this goal. I will look at the API to get more informations about the tactics you used which are new for me.</p>",
        "id": 211516380,
        "sender_full_name": "Claus-Peter Becke",
        "timestamp": 1601310855
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266440\">@Shing Tak Lam</span> : In your very helpful explanations concerning the sum-formula in Lean you gave a description of the sums between limits i=0 or i=1 as the lower bound and i=n as the upper bound of the computation. If I understood you correctly that means that Lean doesn't distinguish with respect to the induction's base case between i=0 and i=1 but looks for a solution which contains i=0 or i=1. If the formula is satisfiable for one of these values the refl-tactic will close the base-case-goal. Is this correct?<br>\nWhat can be done to change especially the lower bound if there shall be computed inequalities which hold for example only presupposing a lower bound as 3 as in the following example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span> <span class=\"n\">k</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">n.succ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">*</span><span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">≥</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 211721947,
        "sender_full_name": "Claus-Peter Becke",
        "timestamp": 1601449006
    },
    {
        "content": "<p>Your message is very obscure to me, but you may be looking for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.two_step_induction\">docs#nat.two_step_induction</a></p>",
        "id": 211722649,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1601449581
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329867\">@Claus-Peter Becke</span> </p>\n<p>Apologies if I caused any confusion. The reason why I said it didn't matter in the previous example is that the sum of the natural numbers from 0 to n is the same as the sum of the natural numbers from 1 to n, since 0 + x = x. Therefore in that specific example, it didn't matter that the sum in question had an extra term.</p>\n<p>If you wanted a sum from i=a to i=b, you would use <code>∑ k in (range (b - a))</code> and then replace any <code>k</code> with <code>k + a</code>. I'm not sure what that inequality is supposed to be, and I haven't got too much time at the moment, but do you mean that <code>k</code> should be at least <code>3</code>? Or do you mean that <code>n</code> should be at least <code>3</code>?</p>",
        "id": 211722696,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1601449629
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266440\">@Shing Tak Lam</span> I meant k should be at least 3. Your proposal seems to be very helpful again. I will try it immediately. Your support is very worthwhile for me. So you don't have any reason to apologize. Because I'm a newbie in all these questions I'm dealing with in this context it happens that I misunderstand some informations which are given.</p>",
        "id": 211723170,
        "sender_full_name": "Claus-Peter Becke",
        "timestamp": 1601450043
    }
]
[
    {
        "content": "<p>Having just closed one help thread, I'm immediately back with another. Sorry!</p>\n<p>I'm experimenting with defining <code>findp</code> (probably a bad name) on <code>list</code>. It's a version of <code>find</code> that requires a proof that a matching item exists, and is therefore able to return <code>α</code> instead of <code>option α</code>. I'm using it to define another function <code>overlap</code>, which gives the longest common tail and prefix between two lists. This is all just for learning purposes.</p>\n<p>I've run into an issue where two lemmas that look very similar to me (<code>findp_mem</code> and <code>findp_pred</code>) seem to behave differently. One works fine with a simple <code>exact</code>, the other gives a confusing error.</p>\n<p>Apologies for the long code sample! I've stripped this down to only the relevant lemmas, and replaced irrelevant bodies with <code>sorry</code> to try to keep things reasonably compact.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.list</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">list</span>\n\n<span class=\"c1\">-- There exists some item that is in the list and matches a predicate.</span>\n<span class=\"kd\">def</span> <span class=\"n\">containsp</span>\n<span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"n\">a</span>\n\n<span class=\"c1\">-- find is some when containsp.</span>\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">find_containsp</span>\n<span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">l.containsp</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">l.find</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_some</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n\n<span class=\"c1\">-- Version of find that takes in a proof of containsp.</span>\n<span class=\"c1\">-- Avoids exposing option publicly, because we know containsp.</span>\n<span class=\"kd\">def</span> <span class=\"n\">findp</span>\n<span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">l.containsp</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">option.get</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">find</span> <span class=\"n\">p</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">find_containsp</span> <span class=\"n\">p</span> <span class=\"n\">l</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n\n\n<span class=\"c1\">-- The return value of findp is a member of the list.</span>\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">findp_mem</span>\n<span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">l.containsp</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">l.findp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- The return value of findp matches the predicate.</span>\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">findp_pred</span>\n<span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">l.containsp</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n<span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">l.findp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n\n<span class=\"c1\">-- A common tail and suffix always exist between two lists.</span>\n<span class=\"c1\">-- (Allowing [])</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">overlap_exists_aux</span>\n<span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">l₁.tails.containsp</span> <span class=\"o\">(</span><span class=\"bp\">&lt;+</span><span class=\"o\">:</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- The longest tail/suffix of l₁ that is also a prefix of l₂.</span>\n<span class=\"kd\">def</span> <span class=\"n\">overlap</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">findp</span> <span class=\"o\">(</span><span class=\"bp\">&lt;+</span><span class=\"o\">:</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"n\">l₁.tails</span> <span class=\"o\">(</span><span class=\"n\">overlap_exists_aux</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- The overlap is in l₁.tails by trivial application of findp_mem.</span>\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">overlap_tail</span>\n<span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">overlap</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">l₁.tails</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">overlap</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">findp_mem</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.proofs</span> <span class=\"n\">true</span>\n\n<span class=\"c1\">-- The overlap is a prefix of l₂ by trivial application of findp_pred.</span>\n<span class=\"c1\">-- Except that this doesn't work...</span>\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">overlap_prefix</span>\n<span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"bp\">&lt;+</span><span class=\"o\">:</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">overlap</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">overlap</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">findp_pred</span><span class=\"o\">,</span> <span class=\"c1\">-- Apparently not</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">list</span>\n</code></pre></div>\n<p>The issue is at the end, in <code>overlap_prefix</code>.</p>\n<p>The <code>exact</code> fails to match, and I don't understand why. I can sort of understand that it might be something to do with matching up the <code>q</code> proof parameter to <code>findp</code>, but I don't understand why it would work in <code>overlap_tail</code> and not in <code>overlap_prefix</code>. None of the standard auto solving tactics are getting anywhere to give me a clue here.</p>\n<p>So a multipart question: What's the explanation for these behaving differently, and what can I do to fix it?</p>\n<p>Sorry for spamming Zulip with so many questions these last few days! Lean is fun, but my debugging skills from traditional programming aren't getting me very far here yet!</p>",
        "id": 292328011,
        "sender_full_name": "Sam",
        "timestamp": 1659890269
    },
    {
        "content": "<p>It seems to need some help to be able to deduce what <code>p</code> is. That needs some higher-order unification I believe, or at least some unification that goes down the wrong path somewhere.</p>\n<p>I didn't golf the proof here, I just left it in the form where I got it to work.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">overlap_prefix</span>\n<span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"bp\">&lt;+</span><span class=\"o\">:</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">overlap</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">overlap</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">findp_pred</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">&lt;+</span><span class=\"o\">:</span> <span class=\"n\">l₂</span><span class=\"o\">),</span>\n  <span class=\"n\">apply</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 292328522,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659890913
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">overlap_prefix</span>\n<span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"bp\">&lt;+</span><span class=\"o\">:</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">overlap</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">findp_pred</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">&lt;+</span><span class=\"o\">:</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 292328538,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659890948
    },
    {
        "content": "<p>Huh. Thanks!</p>\n<p>It's cool that that works, but do we have an explanation for why that's needed for <code>findp_pred</code> and not for <code>findp_mem</code>?</p>",
        "id": 292328633,
        "sender_full_name": "Sam",
        "timestamp": 1659891112
    },
    {
        "content": "<p>I haven't dug into it, but my guess is it's the difference between a list argument appearing twice in the expression and a predicate argument.</p>",
        "id": 292328768,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659891265
    },
    {
        "content": "<p>I don't know how much this applies to Lean, but from my traditional programming background I care a lot about creating high quality APIs. It feels like I'm doing something wrong if <code>findp_pred</code> is hard to use in this way. Is there something I can change about the definition that will make the simple use (<code>exact findp_pred</code>) work? I don't like providing a lemma that <code>library_search</code> isn't even able to find for some reason.</p>",
        "id": 292328792,
        "sender_full_name": "Sam",
        "timestamp": 1659891316
    },
    {
        "content": "<p>And it seems problematic that <code>simp</code> also doesn't know how to use it.</p>",
        "id": 292328872,
        "sender_full_name": "Sam",
        "timestamp": 1659891416
    },
    {
        "content": "<p><code>simp</code> can't apply lemmas unless they have a symbolic \"head\", so for example it has to be about <code>f x y</code> where <code>f</code> is not an argument, but an actual constant</p>",
        "id": 292328987,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659891576
    },
    {
        "content": "<p>That's because it stores all its lemmas in a table indexed by the head for performance</p>",
        "id": 292329042,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659891612
    },
    {
        "content": "<p>A simple change to <code>findp_pred</code> is to make <code>p</code> be an explicit argument, and then say that <code>findp_pred</code> is a technical lemma that you apply in specific situations. I'm not sure if there's a good way to ensure Lean will solve the unification constraints correctly on its own (maybe someone has a trick though)</p>",
        "id": 292329090,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659891711
    },
    {
        "content": "<p>By the way, you can write the goal as <code>overlap l₁ l₂ &lt;+: l₂</code>, this isn't getting in the way of typechecking</p>",
        "id": 292329160,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659891763
    },
    {
        "content": "<p>Huh. So the reason <code>findp_mem</code> does work with <code>simp</code> is that <code>mem</code> is a constant head. That makes some sense.</p>",
        "id": 292329258,
        "sender_full_name": "Sam",
        "timestamp": 1659891907
    },
    {
        "content": "<p>I think generally <code>findp_pred</code> would have the <code>l.containsp p</code> argument be explicit, since in practice you probably would want it to be explicit (and a user can always supply a <code>_</code> if not)</p>",
        "id": 292329322,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659891972
    },
    {
        "content": "<p>By the way, there's a more accurate rule for simp. Simp has two levels of tables: each relation can have simp lemmas. So, for example, it needs to be <code>f x y = foo</code> with <code>f</code> a constant. There is a special case that every <code>Prop</code> simp lemma that proves <code>foo</code> turns into <code>foo = true</code> and gets added to the <code>=</code> table.</p>",
        "id": 292329388,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659892087
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/Confusing.20issue.20with.20exact/near/292329090\">said</a>:</p>\n<blockquote>\n<p>A simple change to <code>findp_pred</code> is to make <code>p</code> be an explicit argument, and then say that <code>findp_pred</code> is a technical lemma that you apply in specific situations. I'm not sure if there's a good way to ensure Lean will solve the unification constraints correctly on its own (maybe someone has a trick though)</p>\n</blockquote>\n<p>To clarify, you're not saying that this would enable <code>simp</code> and similar to use this lemma automatically, are you? I've been experimenting with making arguments explicit but it doesn't seem to have changed that behaviour.</p>",
        "id": 292329547,
        "sender_full_name": "Sam",
        "timestamp": 1659892336
    },
    {
        "content": "<p>You are correct, I'm not suggesting that <code>simp</code> would be able to handle it. It's just easier to use the lemma if it's an explicit argument.</p>",
        "id": 292329559,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659892398
    },
    {
        "content": "<p>Oh! I think maybe I've just understood something weird about the <code>find</code> (not <code>findp</code>) lemmas!</p>",
        "id": 292329636,
        "sender_full_name": "Sam",
        "timestamp": 1659892508
    },
    {
        "content": "<p>They're defined like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">list.find_some</span>\n<span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">list.find</span> <span class=\"n\">p</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">option.some</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">p</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>This implicit <code>a</code> feels weird, but is that a trick to get around this problem?</p>",
        "id": 292329647,
        "sender_full_name": "Sam",
        "timestamp": 1659892537
    },
    {
        "content": "<p>A way to think about the relationship between <code>findp_pred</code> and <code>overlap_prefix</code> is that you're instantiating a generic family of lemmas into a concrete case. (Some programming languages, like Ada, require you to instantiate generics explicitly, unlike languages like C++ or Java that try to be more automatic.)</p>",
        "id": 292329648,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659892537
    },
    {
        "content": "<p>I think you'd usually find <code>a</code> to be implicit like that in mathlib since it's determined by <code>H</code> in a straightforward way</p>",
        "id": 292329701,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659892597
    },
    {
        "content": "<p>but, depending on how you intend to use <code>find_some</code>, you might choose to make it explicit</p>",
        "id": 292329710,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659892625
    },
    {
        "content": "<p>Design consideration: do you think you'll have <code>list.find p l = option.some a</code> proofs in that form lying around? If so, then it'll be easy to use, if not, maybe make some of these arguments explicit so you can more easily provide a proof of <code>H</code> inline and have the type all set up for you, or accept that you'll write <code>(begin ... end : list.find p l = option.some a)</code> with the relevant <code>p</code>, <code>l</code>, and <code>a</code></p>",
        "id": 292329769,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659892721
    },
    {
        "content": "<p>(In Lean 4 this is less of an issue because you can write <code>list.find_some (l := [1,2,3]) my_H</code> to specify <code>l</code>)</p>",
        "id": 292329800,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659892797
    },
    {
        "content": "<p>I was wondering whether something like this was somehow better, although it looks like it would still have the same head problem.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">findp_pred2</span>\n<span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">l.containsp</span> <span class=\"n\">p</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">l.findp</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 292329861,
        "sender_full_name": "Sam",
        "timestamp": 1659892858
    },
    {
        "content": "<p>That's a useful pattern sometimes, for example if you want to <code>apply findp_pred2</code> and have it generate an equality goal for you</p>",
        "id": 292329931,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659892925
    },
    {
        "content": "<p>But I'm not sure it's better or worse. You can also use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/convert\">docs#convert</a> to generate those equality goals</p>",
        "id": 292329940,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659892967
    },
    {
        "content": "<p>Hmm, interesting.</p>",
        "id": 292330109,
        "sender_full_name": "Sam",
        "timestamp": 1659893191
    },
    {
        "content": "<p>So to summarise, probably the best thing that I can do is make <code>p</code> explicit, so that I can do <code>exact findp_pred (&lt;+: l₂),</code>.</p>\n<p>But there's nothing much I can do about <code>library_search</code>, <code>simp</code>, and other automation tactics not being able to use this automatically.</p>",
        "id": 292330131,
        "sender_full_name": "Sam",
        "timestamp": 1659893261
    },
    {
        "content": "<p>And maybe make <code>q</code> explicit too. Although so far I've not found a need to specify it explicitly, because it seems to always be inferred from <code>findp</code>.</p>",
        "id": 292330223,
        "sender_full_name": "Sam",
        "timestamp": 1659893391
    },
    {
        "content": "<p>Yeah, <code>simp</code> is impossible (though of course it will find <code>overlap_prefix</code>), and <code>library_search</code> is unlikely (since <code>exact</code>/<code>apply</code> fails, which is how it finds relevant lemmas -- it really tries to <code>apply</code> the entire library!)</p>",
        "id": 292330230,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659893398
    },
    {
        "content": "<p>The point about <code>q</code> being explicit is that you're not always going to have a goal to unify against -- you might want to create a <code>p (l.findp p q)</code> proof from scratch in the middle of a proof.</p>",
        "id": 292330313,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659893454
    },
    {
        "content": "<p>Oh. Right. I think that makes sense. So I guess I should make both <code>p</code> and <code>q</code> explicit in <code>findp_mem</code> too, right?</p>",
        "id": 292330410,
        "sender_full_name": "Sam",
        "timestamp": 1659893619
    },
    {
        "content": "<p>Yeah when I first realised how much of a blunt instrument <code>library_search</code> is that caught me by surprise! Surely there's some better way of indexing for that, but I've not given it any thought and the people who build it know far more about it than I do!</p>",
        "id": 292330464,
        "sender_full_name": "Sam",
        "timestamp": 1659893689
    },
    {
        "content": "<p>It turned out that anything you could write in Lean that could speed it up only slowed it down because then less was being done by the stuff written in C++</p>",
        "id": 292330560,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659893854
    },
    {
        "content": "<p>Somehow <code>findp_mem</code> doesn't lead the unifier down a bad path, so you might get away with just <code>q</code> explicit. I'd say, though, that you should make your decisions based on pain points in whatever you're writing. Choosing which arguments work well implicit seems to be an art, and there are no hard rules.</p>",
        "id": 292330718,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659894043
    },
    {
        "content": "<p>A good rule of thumb is that it's safe to start out making sure every implicit argument can be inferred from the explicit arguments.</p>\n<p>But this rule doesn't always hold! <a href=\"https://leanprover-community.github.io/mathlib_docs/find/inhabited.default\">docs#inhabited.default</a> uses the return type to infer its implicit argument, and that tends to work fine. But it's not trying to infer an applied function, like in your <code>findp_pred</code>, which is more difficult for Lean.</p>",
        "id": 292330822,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659894222
    },
    {
        "content": "<p>Well for learning purposes, I've been trying to develop <code>findp</code> to a standard that could be included in mathlib, so it's hard to know what other people's pain points would be. For now, I'm tempted to make it explicit in <code>findp_mem</code> too simply for symmetry with <code>findp_pred</code>, but that's probably not a smart way to decide.</p>",
        "id": 292330980,
        "sender_full_name": "Sam",
        "timestamp": 1659894425
    },
    {
        "content": "<p>Out of interest, do you think <code>findp</code> would be a useful addition to mathlib? I've (mostly) found it easier to use than dealing with the <code>option</code> result when proving things about <code>find</code>, but I'm a clueless newb so I don't know about others.</p>",
        "id": 292331037,
        "sender_full_name": "Sam",
        "timestamp": 1659894497
    },
    {
        "content": "<blockquote>\n<p>Well for learning purposes, I've been trying to develop findp to a standard that could be included in mathlib</p>\n</blockquote>\n<p>I think I'm telling you how mathlib standards come to be -- usually it's good if you have a project you're working on where these definitions and lemmas are used, you see what works and doesn't about them, they get refined through that experience, and then you contribute them to mathlib once they've proved to be useful (and then they get refined even more during code review). It's hard (or impossible) to know the right design ahead of time, and with experience you get more lucky.</p>",
        "id": 292331529,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659895197
    },
    {
        "content": "<p><code>findp</code> seems like it could be useful -- I haven't done much with <code>list.find</code> or <code>&lt;+:</code> though, so I can't say for sure.</p>\n<p>I'm surprised there's not already a <code>containsp</code>...</p>",
        "id": 292331719,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659895419
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.any\">docs#list.any</a> is close</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">list.containsp</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span>\n<span class=\"n\">l.any</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 292331781,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659895495
    },
    {
        "content": "<p>Yes, there was some reason that I didn't use <code>any</code>, but I can't remember what it was so I should probably revisit that!</p>",
        "id": 292331874,
        "sender_full_name": "Sam",
        "timestamp": 1659895614
    },
    {
        "content": "<p>Isn't it just <code>l.any p</code>? I think <code>a  ∈ l</code> is implicitly true.</p>",
        "id": 292331906,
        "sender_full_name": "Sam",
        "timestamp": 1659895681
    },
    {
        "content": "<p>There was something about it handling <code>bool</code> instead of <code>Prop</code> that I decided was awkward for some reason, but that decision was made after midnight and I'm not sure what it was based on.</p>",
        "id": 292332051,
        "sender_full_name": "Sam",
        "timestamp": 1659895848
    },
    {
        "content": "<p>I'm not sure what the right thing to do is -- a lot of times it seems like it's better to stay in the Prop world and use decidable instances -- so having a function like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">list.any'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">l.any</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>can be useful. But then you need to add an instance that this is decidable, so it's a lot of boilerplate.</p>",
        "id": 292332145,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659895985
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.list</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.bool.all_any</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"c1\">-- There exists some item that is in the list and matches a predicate.</span>\n<span class=\"kd\">def</span> <span class=\"n\">list.containsp</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">l.containsp</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">l.any</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">list.any_iff_exists</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">list.containsp</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 292332241,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659896113
    },
    {
        "content": "<p>Hmm. I don't think I fully understand the naming scheme with the apostrophe. Is there a good reason the <code>Prop</code> version of <code>any</code> would be called <code>any'</code>, or is it just a hacky way of doing an overload?</p>",
        "id": 292332476,
        "sender_full_name": "Sam",
        "timestamp": 1659896456
    },
    {
        "content": "<p>Apostrophes are occasionally used to give alternative definitions/lemmas in mathlib, but I'm not following any scheme here really. It's just meant to be a <a href=\"https://en.wikipedia.org/wiki/Prime_(symbol)\">prime symbol</a></p>",
        "id": 292332579,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659896598
    },
    {
        "content": "<p>Cool. For some reason, I'd assumed that the apostrophe versions were for internal use and should generally be avoided, so good to know it's just an alternative.</p>",
        "id": 292332637,
        "sender_full_name": "Sam",
        "timestamp": 1659896649
    }
]
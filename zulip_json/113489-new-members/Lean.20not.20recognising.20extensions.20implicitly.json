[
    {
        "content": "<p>Hi,<br>\nI'm working together with Daan van Gent on defining problems, in the computability sense (for example, SAT or 3-colorability, or somewhat simpler, is_even).<br>\nWe came up with the definition </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">computability</span><span class=\"bp\">.</span><span class=\"n\">primrec</span>\n<span class=\"kn\">import</span> <span class=\"n\">computability</span><span class=\"bp\">.</span><span class=\"n\">reduce</span>\n<span class=\"kn\">open</span> <span class=\"n\">function</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">problem</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">problem</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">primcodable</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">yesinstance</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>(I.e., we have a type \\alpha that should be nicely encodable into the natural numbers (that's what <code>primcodable</code> means), and for each <code>a : \\alpha</code> we have <code>yesinstance a</code> which says a is a yes-instance.)</p>\n<p>Then we wanted to define reductions between problems, using <code>computable</code>, and we tried</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">many_one_reducible</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">problem</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">problem</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">computable</span> <span class=\"n\">f</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">yesinstance</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">Q</span><span class=\"bp\">.</span><span class=\"n\">yesinstance</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>but this fails: <code>computable</code> needs that \\alpha and \\beta are of the class <code>primcodable</code>, but it can't synthesize the <code>primcodable</code> type class instance on \\alpha and \\beta, even though <code>problem</code> extends <code>primcodable</code>.</p>\n<p>We have the possible fix</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">many_one_reducible</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">problem</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">problem</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">computable</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">to_primcodable</span> <span class=\"n\">Q</span><span class=\"bp\">.</span><span class=\"n\">to_primcodable</span> <span class=\"n\">f</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">yesinstance</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">Q</span><span class=\"bp\">.</span><span class=\"n\">yesinstance</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>but this seems a bit ugly; shouldn't lean already know how P and Q are <code>primcodable</code>? Or if not, how should we tell Lean?</p>",
        "id": 204781253,
        "sender_full_name": "Pim Spelier",
        "timestamp": 1595500308
    },
    {
        "content": "<p>The issue is that the typeclass system doesn't know about your arguments <code>P</code> and <code>Q</code>. If you make <code>problem</code> a class and <code>P</code> and <code>Q</code> typeclass arguments, it will work (but not look as nice perhaps):</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">computability</span><span class=\"bp\">.</span><span class=\"n\">primrec</span>\n<span class=\"kn\">import</span> <span class=\"n\">computability</span><span class=\"bp\">.</span><span class=\"n\">reduce</span>\n<span class=\"kn\">open</span> <span class=\"n\">function</span>\n\n<span class=\"n\">class</span> <span class=\"n\">problem</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">primcodable</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">yesinstance</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">problem</span>\n\n<span class=\"n\">def</span> <span class=\"n\">many_one_reducible</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">problem</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">problem</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">computable</span> <span class=\"n\">f</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">yesinstance</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">yesinstance</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">problem</span>\n</code></pre></div>",
        "id": 204782353,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1595501382
    },
    {
        "content": "<p>The alternative is to change the <code>extends primcodable</code> into a typeclass argument to your structure:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">computability</span><span class=\"bp\">.</span><span class=\"n\">primrec</span>\n<span class=\"kn\">import</span> <span class=\"n\">computability</span><span class=\"bp\">.</span><span class=\"n\">reduce</span>\n<span class=\"kn\">open</span> <span class=\"n\">function</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">problem</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">problem</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">primcodable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">yesinstance</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">many_one_reducible</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">primcodable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">primcodable</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">problem</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">problem</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">computable</span> <span class=\"n\">f</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">yesinstance</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">Q</span><span class=\"bp\">.</span><span class=\"n\">yesinstance</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">problem</span>\n</code></pre></div>",
        "id": 204782459,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1595501462
    },
    {
        "content": "<p>Ah, that makes sense!<br>\nWe were already wondering whether class or structure fits best: we chose structure, as there can be many different <code>problem</code> structures on the same type, so we explicitly don't want typeclass inference. So I think we'll go for the second solution, thanks!</p>",
        "id": 204784004,
        "sender_full_name": "Pim Spelier",
        "timestamp": 1595502866
    }
]
[
    {
        "content": "<p>I would like to describe the type of continuous functions on ℝ≥0 → ℝ.  I get this far</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">continuous</span> <span class=\"n\">nnreal</span> <span class=\"n\">ℝ</span> <span class=\"n\">nnreal.topological_space</span> <span class=\"c1\">-- real.topological_space</span>\n</code></pre></div>\n<p>but there is <code>nnreal</code> but not <code>real</code> topological space.  </p>\n<p>When a mathematician say \"continuous function on reals\", is there a predefined space for that in <code>mathlib</code>?</p>",
        "id": 220538465,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608500085
    },
    {
        "content": "<p>there is certainly an instance for <code>topological_space real</code>. Try <code>#check (by apply_instance : topological_space real)</code></p>",
        "id": 220538483,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608500155
    },
    {
        "content": "<p>You should just be able to leave a <code>_</code> and lean will fill in things like <code>nnreal.topological_space</code></p>",
        "id": 220538533,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608500210
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I can get to that with <code>by_instance</code>.  With <code>nnreal</code> you can say <code>nnreal.topological_space</code> directly without the <code>by_instance</code>.  It doesn't come up in the list of instances for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/topological_space\">docs#topological_space</a>.</p>",
        "id": 220538764,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608500675
    },
    {
        "content": "<p>In general, instances require a search procedure, they are not always single terms</p>",
        "id": 220538783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608500715
    },
    {
        "content": "<p>but lean looks them up automatically, you shouldn't supply them under normal circumstances</p>",
        "id": 220538786,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608500737
    },
    {
        "content": "<p>the <code>by apply_instance</code> is only so that <em>you</em> can see what lean would look up in such a situation</p>",
        "id": 220538839,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608500779
    },
    {
        "content": "<p>normally you just write <code>continuous (f : nnreal -&gt; real)</code> and everything is taken care of automatically</p>",
        "id": 220538858,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608500820
    },
    {
        "content": "<p>I am trying to translate this text \"The space Ω of elementary events for Brownian motion is the set of all continuous real functions Ω={𝜔:ℝ≥0→ℝ}. We refer to the 𝜔(𝑡) as Brownian trajectories.\"  This typechecks and seems like a good translation into Lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">elementary_event</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">nnreal</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">continuous</span> <span class=\"n\">nnreal</span> <span class=\"n\">ℝ</span> <span class=\"n\">nnreal.topological_space</span> <span class=\"n\">_</span> <span class=\"n\">f</span>\n<span class=\"kd\">def</span> <span class=\"n\">Brownian_event_space</span> <span class=\"o\">:=</span> <span class=\"n\">set</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nnreal</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"bp\">|</span> <span class=\"n\">elementary_event</span> <span class=\"n\">f</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"n\">Brownian_event_space</span>\n</code></pre></div>",
        "id": 220539165,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608501343
    },
    {
        "content": "<p>I would suggest something more like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[derive topological_space]</span>\n<span class=\"kd\">def</span> <span class=\"n\">Brownian_event_space</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nnreal</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"bp\">//</span> <span class=\"n\">continuous</span> <span class=\"n\">f</span><span class=\"o\">}</span>\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`Ω`</span> <span class=\"o\">:=</span> <span class=\"n\">Brownian_event_space</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"n\">borel</span> <span class=\"n\">_</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">borel_space</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 220540246,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608503070
    },
    {
        "content": "<p>That may not be the correct topology though</p>",
        "id": 220540259,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608503126
    },
    {
        "content": "<p>Better, using the compact open topology:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.lebesgue_measure</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.compact_open</span>\n\n<span class=\"kd\">@[derive topological_space]</span>\n<span class=\"kd\">def</span> <span class=\"n\">Brownian_event_space</span> <span class=\"o\">:=</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">nnreal</span><span class=\"o\">,</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`Ω`</span> <span class=\"o\">:=</span> <span class=\"n\">Brownian_event_space</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"n\">borel</span> <span class=\"n\">_</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">borel_space</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 220540327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608503233
    },
    {
        "content": "<p>Also the use of <code>set</code>, the <code>{x | p x}</code> notation, and <code>variable Ω : Brownian_event_space</code> are incorrect in your example. It's important to distinguish between types and sets here, and <code>Ω</code> is the Brownian event space, it is not a member of that space</p>",
        "id": 220540500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608503492
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> .  Now I am trying to build on that to define this:</p>\n<p>\"A cylinder set of Brownian trajectories for a finite set of times 0≤𝑡1&lt;𝑡2&lt;⋯&lt;𝑡𝑛 and real intervals 𝐼𝑘=(𝑎𝑘,𝑏𝑘),1≤𝑘≤𝑛 is constructed as<br>\n𝐶(𝑡1,…,𝑡𝑛;𝐼1,…,𝐼𝑛)={𝜔∈Ω:∀1≤𝑘≤𝑛:𝜔(𝑡𝑘)∈𝐼𝑘}\"</p>\n<p>I can do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"kd\">variable</span> <span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">nnreal</span>\n<span class=\"kd\">variable</span> <span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span>\n<span class=\"kd\">variable</span> <span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">nnreal</span><span class=\"o\">,</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"kd\">variable</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">interval</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">set.Ioo</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">interval</span> <span class=\"n\">I</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"c1\">-- ⇑ω (t k) ∈ interval I k : Prop</span>\n<span class=\"k\">#check</span> <span class=\"o\">{</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">nnreal</span><span class=\"o\">,</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">interval</span> <span class=\"n\">I</span> <span class=\"n\">k</span><span class=\"o\">))}</span> <span class=\"c1\">-- {ω : C(nnreal, ℝ) | ∀ (k : fin n), ⇑ω (t k) ∈ interval I k} : set C(nnreal, ℝ)</span>\n</code></pre></div>\n<p>But if I replace <code>variable ω : C(nnreal, ℝ)</code> by <code>variable ω : Brownian_event_space</code>, then it doesn't check because it doesn't think <code>ω</code> is a function.</p>",
        "id": 220541657,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608505485
    },
    {
        "content": "<p>Also I'm having a problem defining the <code>cylinder_set</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">cylinder_set</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n                 <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nnreal</span><span class=\"o\">)</span>\n                 <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span> <span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">nnreal</span><span class=\"o\">,</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">interval</span> <span class=\"n\">I</span> <span class=\"n\">k</span><span class=\"o\">))}</span>\n</code></pre></div>\n<p>as there is a problem in letting <code>n</code> be a parameter, I get this error I don't know how to fix:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">interval</span> <span class=\"n\">I</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">I</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">fin</span> <span class=\"n\">_root_.n</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span>\n<span class=\"n\">types</span> <span class=\"n\">contain</span> <span class=\"n\">aliased</span> <span class=\"n\">name</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">):</span> <span class=\"n\">n</span>\n<span class=\"n\">remark</span><span class=\"o\">:</span> <span class=\"n\">the</span> <span class=\"n\">tactic</span> <span class=\"bp\">`</span><span class=\"n\">dedup</span><span class=\"bp\">`</span> <span class=\"n\">can</span> <span class=\"n\">be</span> <span class=\"n\">used</span> <span class=\"n\">to</span> <span class=\"n\">rename</span> <span class=\"n\">aliases</span>\n<span class=\"n\">brownian_mo</span>\n</code></pre></div>",
        "id": 220541877,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608505841
    },
    {
        "content": "<blockquote>\n<p>But if I replace variable ω : C(nnreal, ℝ) by variable ω : Brownian_event_space, then it doesn't check because it doesn't think ω is a function.</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[derive [topological_space, has_coe_to_fun]</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">Brownian_event_space</span> <span class=\"o\">:=</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">nnreal</span><span class=\"o\">,</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 220542160,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608506397
    },
    {
        "content": "<p>I'm not sure what you mean by <code>(constant n : N)</code> but I think simply <code>(n : N)</code> in the arguments to <code>cylinder_set</code> does what you want</p>",
        "id": 220542217,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608506444
    },
    {
        "content": "<p>Even though I have <code>def Brownian_event_space := C(nnreal, ℝ)</code> in context, if I say</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">cylinder_set</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nnreal</span><span class=\"o\">)</span>\n                 <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span> <span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">Brownian_event_space</span> <span class=\"bp\">|</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">interval</span> <span class=\"n\">I</span> <span class=\"n\">k</span><span class=\"o\">))}</span>\n</code></pre></div>\n<p>then it crashes with </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">function</span> <span class=\"n\">expected</span> <span class=\"n\">at</span>\n  <span class=\"n\">ω</span>\n<span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">nnreal</span><span class=\"o\">,</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It doesn't take the synonym.</p>",
        "id": 220542243,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608506498
    },
    {
        "content": "<p>see above</p>",
        "id": 220542286,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608506530
    },
    {
        "content": "<p>Thanks, that works! </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">--import probability_space</span>\n<span class=\"kn\">import</span> <span class=\"n\">measure_theory.lebesgue_measure</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.compact_open</span>\n\n<span class=\"kd\">@[derive [topological_space, has_coe_to_fun]</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">Brownian_event_space</span> <span class=\"o\">:=</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">nnreal</span><span class=\"o\">,</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`Ω`</span> <span class=\"o\">:=</span> <span class=\"n\">Brownian_event_space</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"n\">borel</span> <span class=\"n\">_</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">borel_space</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">interval</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">set.Ioo</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cylinder_set</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nnreal</span><span class=\"o\">)</span>\n                 <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span> <span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">Brownian_event_space</span> <span class=\"bp\">|</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">interval</span> <span class=\"n\">n</span> <span class=\"n\">I</span> <span class=\"n\">k</span><span class=\"o\">))}</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">cylinder_set</span> <span class=\"c1\">-- : Π (n : ℕ), (fin n → nnreal) → (fin n → ℝ × ℝ) → set Ω</span>\n</code></pre></div>",
        "id": 220542307,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608506627
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"364351\">Lars Ericson</span> <a href=\"#narrow/stream/113489-new-members/topic/Type.20of.20continuous.20functions.20on.20.E2.84.9D.E2.89.A50.20.E2.86.92.20.E2.84.9D/near/220538465\">said</a>:</p>\n<blockquote>\n<p>I would like to describe the type of continuous functions on ℝ≥0 → ℝ.  I get this far</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">continuous</span> <span class=\"n\">nnreal</span> <span class=\"n\">ℝ</span> <span class=\"n\">nnreal.topological_space</span> <span class=\"c1\">-- real.topological_space</span>\n</code></pre></div>\n<p>but there is <code>nnreal</code> but not <code>real</code> topological space.  </p>\n<p>When a mathematician say \"continuous function on reals\", is there a predefined space for that in <code>mathlib</code>?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"364351\">@Lars Ericson</span> you have asked many questions of this type (preorder on <code>nat</code>, etc, etc...). It would be very <em>very</em> helpful if you would take the time to read <a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">#tpil</a>, and go through the other resources out there (Natural number game, or anything else listed on <a href=\"https://leanprover-community.github.io/learn.html\">https://leanprover-community.github.io/learn.html</a>)</p>\n<p>This question suggests a fundamental lack of understanding of how Lean works, and of the content that is currently in mathlib. If you are stuck on issues like this, then it is pointless trying to formalise anything nontrivial, and it will be a waste of time. For you and for us.</p>",
        "id": 220555468,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608530160
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I have been putting my questions in \"new members\" to flag several things:</p>\n<ul>\n<li>I am new to mathematics</li>\n<li>I am new to theorem proving</li>\n<li>I am new to Lean</li>\n<li>I have no training</li>\n<li>I am naive</li>\n<li>I am curious</li>\n<li>I like this topic</li>\n<li>I need help</li>\n<li>I have lots of naive questions</li>\n</ul>\n<p>I have also, within my limited abilities, done my best to</p>\n<ul>\n<li>Play the natural number game</li>\n<li>Do every example in <a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">#tpil</a></li>\n<li>Read the Reference Manual, such as it exists (many blank chapters)</li>\n<li>Use the online search function of the <a href=\"https://leanprover-community.github.io/mathlib_docs\">#docs</a></li>\n<li>Read the <a href=\"https://github.com/leanprover-community/mathlib/tree/master/src\">source code</a></li>\n</ul>\n<p>As a newbie in that sense I think I have gone above and beyond.</p>\n<p>I ask you and the others you include in \"us\" to please ignore my questions and get on with your life and your interests.  Please do not feel compelled to respond to or address any question that I ask.  You or \"us\" or whoever is the sponsor for Zulip have created a public forum.  I am a member of the general public, asking sincere questions about a topic I am working hard on.  Please respect that.</p>",
        "id": 220578735,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608553974
    },
    {
        "content": "<p>Also I find it a bit ironic that you would proudly wind up <a href=\"https://math.commelin.net/files/poplws20cpp_perfectoid.pdf\">an article on Lean </a> by saying \"part of the experiment was to see whether a team holding no degree in logic or computer science could formalize something substantial\", and then dump on me in a public forum for trying to do exactly that.   Which lack of experience do you find more meritorious to make such an endeavor, a lack of experience in mathematics, or a lack of experience in logic and computer science?  Or are you just boasting that mathematicians can do anything in logic and computer science, even without any specific training?</p>",
        "id": 220580944,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608555726
    },
    {
        "content": "<p>One key difference is that Johan knew the maths of perfectoid spaces well before he formalised a line of Lean code. You are trying to learn the maths and the Lean at the same time, and my experience with undergraduates indicates that this is a very inefficient way of doing things. I am quite excited to be spending next term teaching a Lean course to PhD students, where I will be covering mathematics which they know back to front (we will start with undergraduate stuff) and showing them how to do it in Lean. I think that this is the way to do things. You are trying to do it the other way around and this is like swimming against the tide.</p>",
        "id": 220583545,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608557562
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"364351\">@Lars Ericson</span> My apologies if that came across as hurtful. It's totally fine to be new to Lean/maths/etc. It's totally fine to be naive/curious or to need help. Everybody asks naive questions. That's fine too.</p>\n<p>What I'm trying to point out is that you seem to try to do 37 things at once. As the Dutch say, you might be putting \"too much hay on your pitchfork\". Hence my suggestion of focusing on the basics first, before diving into the formalisation of a piece of nontrivial maths.<br>\nAll I'm saying is that if you do not know how to get the topology on the real numbers in Lean, then whatever you want to do in measure theory/probability theory in Lean is going to be very frustrating.</p>\n<p>There is nothing wrong with not knowing how to get the topology on the reals in Lean. Most of us have gone through that phase. I'm just pointing out that you should focus on that level of questions first. In particular because we've answered very similar questions before, so the hope is that you learn from the techniques that we are teaching. But if those lessons get lost because you are trying to jump ahead to more difficult problems, then that is no good.</p>",
        "id": 220583690,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608557654
    },
    {
        "content": "<p>To add to what Kevin said: one of our hopes/dreams/goals is that interactive theorem provers will also be a valuable tool for learning new maths. At the moment, this is very rarely the case.</p>",
        "id": 220583791,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608557741
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"364351\">@Lars Ericson</span> FWIW I feel I'm in a similar boat (of \"I wish I knew more math\" and \"I wish I knew more lean\" and \"I still feel like doing 30 things at once, so so long as it doesn't bother others too much so be it for now\") -- just mentioning that I sympathize  -- and if anything, folks here seem to be extremely patient with folks like us.</p>",
        "id": 220602158,
        "sender_full_name": "Julian Berman",
        "timestamp": 1608568196
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  and <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  and <span class=\"user-mention\" data-user-id=\"321696\">@Julian Berman</span>  thank you for your kind response.  I am interested in learning how to efficiently discretize weak and strong approximations to solutions of stochastic differential equations.  I have <a href=\"https://www.springer.com/gp/book/9783540570745\">a book</a>  I bought in 1994 which has been sitting on my desk unread until about 3 years ago, when I decided to try to teach myself the subject. This resulted in a number of questions that I posted on Stack Exchange:</p>\n<ul>\n<li><a href=\"https://math.stackexchange.com/questions/3437229/construction-of-the-probability-space-of-the-wiener-process/3810696#3810696\">Construction of the probability space of the Wiener process</a></li>\n<li><a href=\"https://math.stackexchange.com/questions/3760724/what-is-the-probability-space-of-typical-real-univariate-probability-distributio/3763773#3763773\">What is the probability space of typical real univariate probability distributions?</a></li>\n<li><a href=\"https://math.stackexchange.com/questions/3780089/extending-the-concept-of-distribution-function-to-any-totally-or-partially-order/3782009#3782009\">Extending the concept of distribution function to any totally or partially ordered measurable space</a></li>\n</ul>\n<p>I found that there was a giant confusing stack of types to get right in the subject.   This feeling is not unique.  Tai-Danae Bradley describes a similar feeling in <a href=\"https://www.math3ma.com/about\">her blog</a>:<br>\n   \"This website was originally created in 2015 as tool to help me transition from undergraduate to graduate level mathematics. Quite often, I'd find that the ideas of math are hidden behind a dense fog of formalities and technical jargon. Much of my transition process was learning how to fight through this fog in order to clearly see the ideas, concepts, and notions which lie beneath. Throughout this process I learned that writing —and drawing —helps immensely.\"</p>\n<p>Instead of writing and drawing, I attempted, using <code>sympy</code> and newly added Python type facilities, to organize my reading on the topic.  These questions were related to that effort:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/63342423/how-do-i-extend-sympy-pretty-printing-for-new-structures-in-jupyter-notebook/63359376#63359376\">How do I extend SymPy pretty printing for new structures in Jupyter notebook?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/63343360/dynamic-checking-of-type-hints-in-python-3-5/63344681#63344681\">Dynamic checking of type hints in Python 3.5+</a></li>\n</ul>\n<p>I learned that the notion of types in more advanced mathematics is a shifting pile of sand, because there are 5 equivalent but differently founded definitions for every advanced concept.  In Lean, what at first glance look like types are really different ways of structuring a formal proof based on going at the topic at hand based on one or another equivalent definition.   You can see this kind of divergence very clearly in <a href=\"#narrow/stream/113489-new-members/topic/If.20X.20is.20a.20Borel.20space.20then.20it.20is.20measurable.20iso.20to.20R/near/220564552\">this discussion</a> of what is a Polish space.</p>\n<p>One of the sub-goals of my book club effort is to understand how to formally describe concepts like Ito integral, Ito differential and similarly for Stratonovich.  A sub-goal of that sub-goal is to formally describe the probability space of stochastic processes.  The clearest description of that which I have found is <a href=\"http://www.springer.com/cda/content/document/cda_downloaddocument/9781441916044-c1.pdf?SGWID=0-0-45-855433-p173940722\">this one</a> by <a href=\"https://www.biologie.ens.fr/bcsmcbs/IMG/pdf/ZEEVS-SCHUSS2018-3F-Bob3dh.pdf\">Zeev Schuss</a>.  If you go searching for definitions of \"Brownian motion probability space\", you will find 5 or 6 more or less specific constructions, but none as clear or relatively constructive as Schuss.</p>\n<p>For underlying measure theory, I found <a href=\"https://www.ma.utexas.edu/users/gordanz/notes/measurable_spaces.pdf\">these notes by Gordan Zitkovic</a> to be most clear, especially regarding the cylinder sets used in the construction described by Schuss.</p>\n<p>I mentioned in another thread <a href=\"https://dl.acm.org/doi/10.1023/A%3A1026553731272\">Wilfrid Kendall's implementation of stochastic differential</a> in Reduce, Mathematica, Axiom and maybe Maple.  The Axiom implementation represents a more informed attempt to \"get the types right\" and provide a facility for symbolic computing with SDEs.  Lean is another way to help organize thinking (get the types right or get the proof structure right) which has been, in spite and because of my ignorance in measure theory and topology, a helpful learning experience.  Implementing a well-typed (but otherwise not \"proven\") symbolic computation facility is a different task than automatically verifying a proof about an idea in the same topic.  It took a little bit of doing Lean to really understand that it was not a programming language and was not intended to be used that way.  It is a system for organizing and checking proofs.</p>\n<p>Part of my learn-through-programming approach comes from an early experience.  In 1976 I enrolled in the MIT High School Studies Program (HSSP), a free after-school activity.  I spent my time at the LOGO Lab, a project by \"educationalists\" to each children mathematics by making them write computer graphics programs.  This program was called <a href=\"https://mitpress.mit.edu/books/turtle-geometry\">turtle geometry</a>.  However it wasn't limited to math, they imprinted students with the idea that you could only know a topic by \"operationalizing\" it.   This obviously goes against the grain of 99% of all graduate-level mathematics education (witness the large absence of core math on EdX and Coursera). </p>\n<p>From LOGO my friends from HSSP and I moved onto the MIT AI Lab, in particular the <a href=\"https://www.sciencedirect.com/science/article/pii/S0747717110001483\">Macsyma</a> group.  I learned Lisp and a bit of Macsyma.  Later on, I worked for a year for <a href=\"https://dl.acm.org/doi/10.1145/1464013.1464034\">Carl Engelman</a>, who wrote Mathlab 68, the precursor to Macsyma.  Using Macsyma for integration and differentiation of expressions and meeting these people also gave me the idea that learning by doing might be a good strategy.</p>\n<p>As an undergrad one of my jobs was to help Dana Scott maintain the Franz Lisp implementation of Edinburgh LCF.   I took a course from him on Domain Theory in which I learned absolutely nothing but got an A for attendance, as one of the 3 people signing up for the course.  This was one of my first experiences in what it means not to have real training or maybe aptitude in topology.  I got no organized feedback from anybody in college regarding what I didn't know that I didn't know, in particular no kind of systematic testing to assess my skill level and gaps in the relevant underlying mathematics.  Still, CMU was happy to print me a BS in Math and send me off to Courant Institute, maybe the worst place in the world to be for someone ignorant about math.</p>\n<p>At Courant I went from one thesis topic to another.   The first was, for Chee Yap, to implement real algebraic number arithmetic in CAML (I met Gerard Huet at the 1987 Texas summer school on Functional Programming and through that ended up at INRIA for a year, where I did the CAML implementation), then Maple (I spent a month in Cantabria with Tomas Recio, where Maple was popular), then Mathematica (it's kind of nice), to support \"topologically correct graphical editing\".  The grand goal of this effort is never to confuse left with right.  It's hard.  I had to implement things like Grobner bases and resultant calculations, without really knowing what I was doing.  For this effort I earned some mockery from Bruno Buchberger when I gave a talk on the work in Linz.  Eventually I moved onto a different topic.  Chee forged on to successfully carried out his <a href=\"https://cs.nyu.edu/exact/intro/\">Exact Geometric Computation</a> program to fruition with many other people.</p>\n<p>My next thesis topic was for Jack Schwartz.  He wanted me to implement the idea of <a href=\"https://www.osti.gov/biblio/5293478\">Correct Program Technology</a> in SETL.  Basically, from preconditions on programs written as set-theoretic expressions, derive algorithms in the SETL programming language.  I worked on this for a while. There was only one buggy SETL compiler and I found that every decision procedure he wanted me to implement was of use for at most one variable due to hyper-exponential complexity.  I listed a few of these papers in another thread.   I told Jack I wanted to move to Mathematica and focus on possible heuristics and <a href=\"https://cs.nyu.edu/media/publications/TR1995-711.pdf\">average case complexity.</a>  He wasn't interested in anything not done in SETL (his language) and was not particularly interested in average case complexity (maybe he guessed that quantum computers would come along and rescue his line of decision procedures).  So I finished that up with Bud Mishra and Jim Cox as thesis advisors and promptly dropped out of academia.</p>\n<p>Life is short and I had it on my bucket list to finally learn this particular book by Kloden.  I've gone at it a number of different ways.  Lean has been an exciting and helpful entree into the guts of the math, which gets largely elided in somewhat \"popular\" presentations like the Kloeden book.   I'm not good at doing proofs by hand.   I can sometimes follow them if they are formally presented, as in Lean.  So it's been working for me, even though it doesn't look like it to you, as you view the sequence of my questions.  You may doubt that I'm getting anything out of this, but I really feel like I'm getting something.  Every time I say \"DONE\" in a thread about a particular topic, I feel like I've moved along a little bit.</p>",
        "id": 220605181,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608569974
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"364351\">@Lars Ericson</span>  Formalizing math is not the same as doing math in a mathematics department. There are specific tricks and techniques you have to learn, and just because it works well on paper doesn't mean it will translate well to the proof assistant. And this isn't even because the paper version was imprecise or suboptimal in some sense (although it may be); it is because mathematician authors are communicating to a different audience: human readers. Some things that are easy for a human are not easy for lean, and vice versa.</p>\n<p>My advice is to put your grand formalization ideas on hold, and work through some basic material, and once you have done that, try to pick an area of mathlib that needs some filling out and contribute something. The first few things you contribute should be proofs; writing definitions is hard and unless you know what you are doing you will end up with definitions that are not suitable for mathlib. So far I have seen exceedingly little in the way of proofs in your posts; I've already stressed the importance of this for learning.</p>\n<p>Once you have that out of the way, you will be in a position to ask much higher quality questions, and then perhaps we can get to laying the foundations for things like the Ito integral, stochastic differential equations and so on. Understand that most of this is miles out of the way at the moment though, and you first have to train before you can run a marathon.</p>",
        "id": 220618843,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608577852
    },
    {
        "content": "<p>PS On my StackExchange quest described above I left out two links on the concept of randomness of a sequence.  To me a probability space is a way of counting a population.  There is nothing random about it.  We talk about random variables but they are deterministic functions of the sample space.  For a sequence of choices to be random is a different concept.   I had a few posts about that in StackExchange:</p>\n<ul>\n<li><a href=\"https://math.stackexchange.com/questions/3442248/formal-statement-of-property-of-randomness-of-a-sequence\">Formal statement of property of randomness of a sequence</a></li>\n<li><a href=\"https://math.stackexchange.com/questions/3772131/is-compressibility-a-good-test-for-randomness-of-a-pseudorandom-sequence\">Is compressibility a good test for randomness of a pseudorandom sequence?</a></li>\n</ul>\n<p>One possible criterion is compressibility. The StackExchange response was No to that. However, <a href=\"https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=903151\">NIST</a> likes compressibility as a test.</p>",
        "id": 220621688,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608579519
    },
    {
        "content": "<p>See that sounds like a mathematics question to me, which should be figured out on math.SE or similar. Come here once it's \"dead math\" and you just want to formalize it</p>",
        "id": 220622366,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608579893
    },
    {
        "content": "<p>If the mathematics itself is muddled, formalizing becomes much harder, and while it can be useful for crystallizing your thoughts on a problem, you probably need some proficiency with the proof assistant before that will be more than just pain on both fronts</p>",
        "id": 220622555,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608579989
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I will follow your advice to practice proofs.   I will try only to ask proof questions while doing this and only if I really really have to.  Here is my (grand) practice plan, in order, to proof check in Lean:</p>\n<ul>\n<li>Every exercise and theorem in <a href=\"https://www.scribd.com/doc/235654370/Saunders-Mac-Lane-Garret-Birkhoff-Algebra-1999\">Algebra by Mac Lane and Birkhoff</a></li>\n<li>Every exercise and theorem in <a href=\"https://www.maths.ed.ac.uk/~v1ranick/papers/maclanecat.pdf\">Categories for the working mathematician</a></li>\n<li>The theorems in <a href=\"http://www.mathnet.ru/php/getFirstPage.phtml?jrnid=tvp&amp;paperid=5278&amp;option_lang=rus\">NEW CHECKABLE CONDITIONS FOR MOMENT DETERMINACY OF PROBABILITY DISTRIBUTIONS</a></li>\n<li>The theorems in <a href=\"https://arxiv.org/pdf/1901.04029.pdf\">NON-CONVENTIONAL LIMITS OF RANDOM SEQUENCES RELATED TO PARTITIONS OF INTEGERS</a></li>\n<li>The theorems in <a href=\"https://link.springer.com/chapter/10.1007/978-1-4419-1605-1_2\">The Probability Space of Brownian Motion</a></li>\n</ul>",
        "id": 220653830,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608605107
    },
    {
        "content": "<p>So far so good</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.ring.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"c1\">-- Garrett Birkhoff and Saunders Mac Lane: A survey of modern algebra, 4th ed</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ch1_rule_1</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span> <span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"n\">c</span><span class=\"bp\">=</span><span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">c</span><span class=\"bp\">+</span><span class=\"n\">b</span><span class=\"bp\">*</span><span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">add_mul</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ch1_rule_2_plus</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span> <span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">zero_add</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ch1_rule_2_times</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span> <span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">one_mul</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ch1_rule_3</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span> <span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"n\">h1</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">add_left_eq_self.mp</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">has_add.add</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">has_add.add</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"n\">z</span><span class=\"o\">))),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ch1_rule_4</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span> <span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"bp\">=</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">add_right_inj</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ch1_rule_5</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span> <span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">x₁</span> <span class=\"n\">x₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">x₁</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∧</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">x₂</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">x₁</span> <span class=\"bp\">=</span> <span class=\"n\">x₂</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"n\">h1.1</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:=</span> <span class=\"n\">h1.2</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">neg_unique</span> <span class=\"n\">h2</span> <span class=\"n\">h3</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ch1_rule_6</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span> <span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x₁</span> <span class=\"n\">x₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">x₁</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">x₂</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">x₁</span> <span class=\"bp\">=</span> <span class=\"n\">x₂</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"n\">h1.1</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:=</span> <span class=\"n\">h1.2</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">h2</span> <span class=\"n\">at</span> <span class=\"n\">h3</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">ch1_rule_4</span> <span class=\"n\">α</span> <span class=\"n\">a</span> <span class=\"n\">x₁</span> <span class=\"n\">x₂</span> <span class=\"o\">(</span><span class=\"n\">eq.symm</span> <span class=\"n\">h3</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ch1_rule_7a</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span> <span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">mul_zero</span> <span class=\"n\">a</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ch1_rule_7b</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span> <span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">zero_mul</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 220763130,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608702509
    },
    {
        "content": "<p>Since all of these are just copies of theorems from mathlib, you should take note of the way that your theorem differs, because those indicate probably-meaningful style differences. For example, you should use <code>{}</code> brackets around alpha (and the variables <code>a b c</code> when they can be inferred from hypotheses), you should not have a space before a close brace, and you should use <code>hyp1 -&gt; hyp2 -&gt; conclusion</code> instead of <code>hyp1 /\\ hyp2 -&gt; conclusion</code></p>",
        "id": 220763839,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608703774
    },
    {
        "content": "<p>Revised:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.ring.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"c1\">-- Garrett Birkhoff and Saunders Mac Lane: A survey of modern algebra, 4th ed</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ch1_rule_1</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"n\">c</span><span class=\"bp\">=</span><span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">c</span><span class=\"bp\">+</span><span class=\"n\">b</span><span class=\"bp\">*</span><span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">add_mul</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ch1_rule_2_plus</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">zero_add</span> <span class=\"n\">a</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ch1_rule_2_times</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">one_mul</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ch1_rule_3</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"n\">h1</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">add_left_eq_self.mp</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">has_add.add</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">has_add.add</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"n\">z</span><span class=\"o\">))),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ch1_rule_4</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">add_right_inj</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ch1_rule_5</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">x₁</span> <span class=\"n\">x₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">x₁</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">x₂</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">x₁</span> <span class=\"bp\">=</span> <span class=\"n\">x₂</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"n\">h1.1</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:=</span> <span class=\"n\">h1.2</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">neg_unique</span> <span class=\"n\">h2</span> <span class=\"n\">h3</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ch1_rule_6</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x₁</span> <span class=\"n\">x₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">x₁</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">x₂</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">x₁</span> <span class=\"bp\">=</span> <span class=\"n\">x₂</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"n\">h1.1</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:=</span> <span class=\"n\">h1.2</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">h2</span> <span class=\"n\">at</span> <span class=\"n\">h3</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">ch1_rule_4</span> <span class=\"n\">α</span> <span class=\"n\">a</span> <span class=\"n\">x₁</span> <span class=\"n\">x₂</span> <span class=\"o\">(</span><span class=\"n\">eq.symm</span> <span class=\"n\">h3</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ch1_rule_7a</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">mul_zero</span> <span class=\"n\">a</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ch1_rule_7b</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">zero_mul</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ch1_rule_8</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">u</span><span class=\"bp\">=</span><span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n  <span class=\"n\">suggest</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 220798128,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608737185
    },
    {
        "content": "<p>You can even change the <code>variable</code> line to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span>  <span class=\"n\">α</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>to reduce repetition down the file (and use <code>b</code>, <code>c</code> for non-<code>a</code> variables).</p>",
        "id": 220800264,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1608738802
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> .  I wanted to put the <code>[comm_ring ]</code> in the variable line but I was having trouble getting the syntax right.   Also I overused <code>{a: }</code> in foralls above in proof statement.  Using <code>{</code> on a forall makes it harder to instantiate the forall with a specific case.   Here is revised proof plus one more rule and I also added <code>namespace</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.ring.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"c1\">-- Garrett Birkhoff and Saunders Mac Lane: A survey of modern algebra, 4th ed</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ch1</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">z</span> <span class=\"n\">x₁</span> <span class=\"n\">x₂</span> <span class=\"o\">:</span>  <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">rule_1</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"n\">c</span><span class=\"bp\">=</span><span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">c</span><span class=\"bp\">+</span><span class=\"n\">b</span><span class=\"bp\">*</span><span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">add_mul</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">rule_2_plus</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">zero_add</span> <span class=\"n\">a</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">rule_2_times</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">one_mul</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">rule_3</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"n\">h1</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">add_left_eq_self.mp</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">has_add.add</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">has_add.add</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"n\">z</span><span class=\"o\">))),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">rule_4</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">add_right_inj</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">rule_5</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">x₁</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">x₂</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">x₁</span> <span class=\"bp\">=</span> <span class=\"n\">x₂</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">neg_unique</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">rule_6</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">x₁</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">x₂</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">x₁</span> <span class=\"bp\">=</span> <span class=\"n\">x₂</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">h1</span> <span class=\"n\">at</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">rule_4</span> <span class=\"o\">(</span><span class=\"n\">eq.symm</span> <span class=\"n\">h2</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">rule_7a</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">mul_zero</span> <span class=\"n\">a</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">rule_7b</span>  <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">zero_mul</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">rule_8</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">eq_one_iff_eq_one_of_mul_eq_one</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">ch1</span>\n</code></pre></div>",
        "id": 220815383,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608748609
    }
]
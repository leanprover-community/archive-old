[
    {
        "content": "<p>As my another exercise, I decided to implement Quicksort in Lean.</p>\n<p>I started by copying my straightforward Haskell code implementing Quicksort. Soon I realized that I have to provide a proof of well-founded recursion.  It took me a long time to create the proof.<br>\n<a href=\"https://github.com/madvorak/Lean-first-steps/blob/main/src/Quicksort.lean\">https://github.com/madvorak/Lean-first-steps/blob/main/src/Quicksort.lean</a></p>\n<p>The difficult part was <code>lemma size_cap</code>. I think it could be proved without <code>by_cases</code> which is what makes my proof too long. I suppose the proof could be completed without specifying whether <code>only_those</code> outputs <code>head :: only_those cond pivot tail</code> or just <code>only_those cond pivot tail</code> because either way it is short enough. How can I avoid this specificity, please?</p>\n<p>My original idea (which didn't work) was something like omitting the lines 22–32 and then finishing the proof by:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">calc</span> <span class=\"o\">(</span><span class=\"n\">only_those</span> <span class=\"n\">cond</span> <span class=\"n\">pivot</span> <span class=\"o\">(</span><span class=\"n\">head</span> <span class=\"o\">::</span> <span class=\"n\">tail</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">sizeof</span>\n         <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">sizeof</span> <span class=\"n\">head</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">only_those</span> <span class=\"n\">cond</span> <span class=\"n\">pivot</span> <span class=\"n\">tail</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sizeof</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>     <span class=\"c1\">-- how ???</span>\n    <span class=\"bp\">...</span>  <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">sizeof</span> <span class=\"n\">head</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">pivot</span> <span class=\"o\">::</span> <span class=\"n\">tail</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sizeof</span>              <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span>  <span class=\"c1\">-- uses `ih` and `add_le_add` afaik</span>\n    <span class=\"bp\">...</span>  <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">sizeof</span> <span class=\"n\">head</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">sizeof</span> <span class=\"n\">pivot</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">tail.sizeof</span><span class=\"o\">)</span>  <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">,</span> <span class=\"c1\">-- uses `siz`</span>\n</code></pre></div>",
        "id": 251048345,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1630148886
    },
    {
        "content": "<p>Isn't your <code>only_those cond pivot l</code> just <code>l.filter (λ x, cond x pivot)</code> (aka <code>l.filter (flip cond pivot)</code>)?</p>",
        "id": 251048789,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1630149416
    },
    {
        "content": "<p>Yes, it is.</p>",
        "id": 251048798,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1630149430
    },
    {
        "content": "<p>I didn't search for the libraries. Since my goal was to implement something so rudimentary, it made sense to me to write it nearly from scratch.</p>",
        "id": 251048823,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1630149472
    },
    {
        "content": "<p>(<a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.sizeof\">docs#list.sizeof</a> for reference, since I didn't know it existed)</p>",
        "id": 251049020,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1630149699
    },
    {
        "content": "<p>Your link gives me <code>404 Not Found</code>.</p>",
        "id": 251049029,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1630149719
    },
    {
        "content": "<p>Oh, I guess it's generated by the inductive type compiler, so has no docs or src...</p>",
        "id": 251049086,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1630149759
    },
    {
        "content": "<p>To be honest, I don't know what is the conceptual difference between <code>list.length</code> and <code>list.sizeof</code>. It is just that the compiler didn't accept my proof of well-founded recursion when I wrote it with <code>length</code>.</p>",
        "id": 251049106,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1630149795
    },
    {
        "content": "<p>Please, let me know if there is an easy way how to implement it using <code>list.length</code>. It might be a bit easier to work with.</p>",
        "id": 251049195,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1630149878
    },
    {
        "content": "<p>Sizeof is some internal function for the equation compiler which end users shouldn't be using.</p>",
        "id": 251051469,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630152324
    },
    {
        "content": "<p><code>length</code> has an API</p>",
        "id": 251051480,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630152340
    },
    {
        "content": "<p>Interestingly the built-in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.qsort\">docs#list.qsort</a> is too early in the import graph to use the equation compiler, so we can't learn from that example</p>",
        "id": 251051595,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1630152443
    },
    {
        "content": "<p>you can a bit, the proof is more or less what you would do with the equation compiler except the <code>using_well_founded</code> relation is provided in <code>qsort</code> and the main definition is in <code>qsort.F</code></p>",
        "id": 251051786,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630152607
    },
    {
        "content": "<p>note in particular that it is using <code>inv_image.wf length nat.lt_wf</code> as the relation, aka induction on <code>length</code>, not <code>sizeof</code></p>",
        "id": 251051840,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630152673
    }
]
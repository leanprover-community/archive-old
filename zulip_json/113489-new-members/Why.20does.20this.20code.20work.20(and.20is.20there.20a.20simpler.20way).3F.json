[
    {
        "content": "<p>Working through Theorem Proving in Lean via the exercises, and doing <code>or_assoc</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">or_assoc_right_pq</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">assume</span> <span class=\"n\">hpq</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n    <span class=\"k\">show</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"n\">hpq.elim</span>\n      <span class=\"o\">(</span> <span class=\"k\">assume</span> <span class=\"n\">hp</span><span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n        <span class=\"k\">show</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"n\">or.intro_left</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">hp</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span> <span class=\"k\">assume</span> <span class=\"n\">hq</span><span class=\"o\">:</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"n\">hqr</span><span class=\"o\">:</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">or.intro_left</span> <span class=\"n\">r</span> <span class=\"n\">hq</span><span class=\"o\">,</span>\n        <span class=\"k\">show</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"n\">or.intro_right</span> <span class=\"n\">p</span> <span class=\"n\">hqr</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">or_assoc_right_r</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span><span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">assume</span> <span class=\"n\">hr</span><span class=\"o\">:</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hqr</span><span class=\"o\">:</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">or.intro_right</span> <span class=\"n\">q</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n    <span class=\"k\">show</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"n\">or.intro_right</span> <span class=\"n\">p</span> <span class=\"n\">hqr</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">or_assoc_right</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">assume</span> <span class=\"n\">hpqr</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n  <span class=\"k\">show</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"n\">or.elim</span> <span class=\"n\">hpqr</span>\n    <span class=\"o\">(</span><span class=\"n\">or_assoc_right_pq</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">or_assoc_right_r</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(As an aside, I'm not sure if I'm using \"<code>right</code>\" in an Leanly way -- using it here to state that in a mutual implication, I'm going to the right).</p>\n<p>Why doesn't <code>or_assoc_right_pq</code> need any parameters? It's somehow picking everything up from context.... I'd have expected I'd need to <code>assume</code> the starting point first....</p>\n<p>My informal mental proof for associativity is each side of the double implication \"p \\or q \\or r\" implies at least one of the props, QED -- is there a simpler proof structure that gets more to the heart of the proof here rather than tediously going through each of the subcases in each direction of the double implication?</p>",
        "id": 299815672,
        "sender_full_name": "Arien Malec",
        "timestamp": 1663696451
    },
    {
        "content": "<p>There are tactics which solve all of these goals in one line, if that's what you're asking. TPIL is just giving you practice writing low-level proofs.</p>",
        "id": 299820233,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1663698000
    },
    {
        "content": "<blockquote>\n<p>Why doesn't <code>or_assoc_right_pq</code> need any parameters? It's somehow picking everything up from context.... I'd have expected I'd need to assume the starting point first....  </p>\n</blockquote>\n<p>The place you're using <code>or_assoc_right_pq</code> requires a proof of <code>p ∨ q → p ∨ (q ∨ r)</code>. The statement basically says <em>\"If we assume <code>p ∨ q</code>, we have <code>p ∨ (q ∨ r)</code>\"</em>. You don't need to assume anything, because the statement of <code>or_assoc_right_pq</code> already says that for any <code>p q r : Prop</code>, if we assume <code>p ∨ q</code>, we have <code>p ∨ (q ∨ r)</code>. Since <code>p q r</code> are implicit in <code>or_assoc_right_pq</code>, we don't need to provide them either. That's why <code>or_assoc_right_pq</code> is enough. If you deliberately want to assume <code>p ∨ q</code> (for whatever reason), it will be <code>(assume h : p ∨ q, or_assoc_right_pq h)</code>, but it eta-reduces to <code>or_assoc_right_pq</code> anyway.</p>\n<blockquote>\n<p>My informal mental proof for associativity is each side of the double implication <code>p ∨ q ∨ r</code> implies at least one of the props, QED -- is there a simpler proof structure that gets more to the heart of the proof here rather than tediously going through each of the subcases in each direction of the double implication?</p>\n</blockquote>\n<p>What \"double implication\" are you referring to? Do you mean that because both <code>(p ∨ q) ∨ r</code> and <code>p ∨ (q ∨ r)</code> implies that at least one of <code>p q r</code> is true means that <code>(p ∨ q) ∨ r ↔ p ∨ (q ∨ r)</code>? If so, then that's not a valid inference rule. For example, both <code>p ∧ q</code> and <code>p ∨ q</code> implies that at least one of <code>p q</code> is true, but <code>p ∧ q ↔ p ∨ q</code> is not true for all <code>p q</code>. Or did you mean something else?</p>\n<p>Note that the problem with the statement <em>\"at least one of the props is true\"</em> is that in order to formalize it, you need to somehow represent the set of propositions <code>p</code>, <code>q</code> and <code>r</code>, and state that at least one of the propositions in that set is true. However, in order to construct the set, you need to iterate over propositions <code>p q r</code>, and the way you're constructing the set affects the proof. At the end, you'll end up doing the same thing as in your original proof, but more complicated.</p>",
        "id": 299830514,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1663701253
    },
    {
        "content": "<p>Nope, understand this is <code>simp</code> and friends, ultimately. Just wondering (a) why my <code>or_assoc _right_pq</code> works without parameters, and (b) whether there's a more intuitive way of doing this proof that maps to intuition.</p>",
        "id": 299838257,
        "sender_full_name": "Arien Malec",
        "timestamp": 1663704002
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456794\">Patrick Johnson</span> <a href=\"#narrow/stream/113489-new-members/topic/Why.20does.20this.20code.20work.20.28and.20is.20there.20a.20simpler.20way.29.3F/near/299830514\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Why doesn't <code>or_assoc_right_pq</code> need any parameters? It's somehow picking everything up from context.... I'd have expected I'd need to assume the starting point first....  </p>\n</blockquote>\n<p>The place you're using <code>or_assoc_right_pq</code> requires a proof of <code>p ∨ q → p ∨ (q ∨ r)</code>. The statement basically says <em>\"If we assume <code>p ∨ q</code>, we have <code>p ∨ (q ∨ r)</code>\"</em>. You don't need to assume anything, because the statement of <code>or_assoc_right_pq</code> already says that for any <code>p q r : Prop</code>, if we assume <code>p ∨ q</code>, we have <code>p ∨ (q ∨ r)</code>. Since <code>p q r</code> are implicit in <code>or_assoc_right_pq</code>, we don't need to provide them either. That's why <code>or_assoc_right_pq</code> is enough. If you deliberately want to assume <code>p ∨ q</code> (for whatever reason), it will be <code>(assume h : p ∨ q, or_assoc_right_pq h)</code>, but it eta-reduces to <code>or_assoc_right_pq</code> anyway.</p>\n<p>Cool! IIRC, in Haskell, I can define functions pointsfree, but not <em>call</em> them that way, so that's a new trick to me. </p>\n<p>My informal mental proof for associativity is each side of the double implication <code>p ∨ q ∨ r</code> implies at least one of the props, QED -- is there a simpler proof structure that gets more to the heart of the proof here rather than tediously going through each of the subcases in each direction of the double implication?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">What</span> <span class=\"s2\">\"double implication\"</span> <span class=\"n\">are</span> <span class=\"n\">you</span> <span class=\"n\">referring</span> <span class=\"n\">to</span><span class=\"bp\">?</span> <span class=\"n\">Do</span> <span class=\"n\">you</span> <span class=\"n\">mean</span> <span class=\"n\">that</span> <span class=\"n\">because</span> <span class=\"n\">both</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"bp\">`</span> <span class=\"n\">and</span> <span class=\"bp\">`</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">`</span> <span class=\"n\">implies</span> <span class=\"n\">that</span> <span class=\"n\">at</span> <span class=\"n\">least</span> <span class=\"n\">one</span> <span class=\"n\">of</span> <span class=\"bp\">`</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span><span class=\"bp\">`</span> <span class=\"n\">is</span> <span class=\"n\">true</span> <span class=\"n\">means</span> <span class=\"n\">that</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">`?</span> <span class=\"n\">If</span> <span class=\"n\">so</span><span class=\"o\">,</span> <span class=\"k\">then</span> <span class=\"n\">that's</span> <span class=\"n\">not</span> <span class=\"n\">a</span> <span class=\"n\">valid</span> <span class=\"n\">inference</span> <span class=\"n\">rule.</span> <span class=\"n\">For</span> <span class=\"kd\">example</span><span class=\"o\">,</span> <span class=\"n\">both</span> <span class=\"bp\">`</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"bp\">`</span> <span class=\"n\">and</span> <span class=\"bp\">`</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"bp\">`</span> <span class=\"n\">implies</span> <span class=\"n\">that</span> <span class=\"n\">at</span> <span class=\"n\">least</span> <span class=\"n\">one</span> <span class=\"n\">of</span> <span class=\"bp\">`</span><span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"bp\">`</span> <span class=\"n\">is</span> <span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">but</span> <span class=\"bp\">`</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"bp\">`</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">true</span> <span class=\"n\">for</span> <span class=\"n\">all</span> <span class=\"bp\">`</span><span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"bp\">`.</span> <span class=\"n\">Or</span> <span class=\"n\">did</span> <span class=\"n\">you</span> <span class=\"n\">mean</span> <span class=\"n\">something</span> <span class=\"k\">else</span><span class=\"bp\">?</span>\n</code></pre></div>\n<p>I think I'm in mental logic trap where I'm assuming associativity to prove associativity, and when I want to say it rigorously, I'm down to the logic I proposed. (p ∨ q) ∨ r, so if the right side is true, so is q ∨ r and then so is… Just getting my feet wet with both Lean and formal theorem proving, so trying to test all my confusion.</p>\n<p>Thanks!</p>\n</blockquote>",
        "id": 299848412,
        "sender_full_name": "Arien Malec",
        "timestamp": 1663708042
    },
    {
        "content": "<blockquote>\n<p>Cool! IIRC, in Haskell, I can define functions pointsfree, but not call them that way, so that's a new trick to me.</p>\n</blockquote>\n<p>You're just passing one function (implication) as an argument to another... I'd be surprised if you haven't encountered that in Haskell!</p>",
        "id": 299850640,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1663709242
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/stream/113489-new-members/topic/Why.20does.20this.20code.20work.20.28and.20is.20there.20a.20simpler.20way.29.3F/near/299850640\">said</a>:</p>\n<blockquote>\n<p>You're just passing one function (implication) as an argument to another... I'd be surprised if you haven't encountered that in Haskell!</p>\n</blockquote>\n<p>If I'm reasoning through this, the signature of <code>iff.intro</code> is <code>(a → b) → (b → a) → (a ↔  b)</code> so in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">iff.intro</span> <span class=\"n\">or_assoc_right</span> <span class=\"n\">or_assoc_left</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I'm just passing functions, and everything typechecks, and…typechecking is proof? I've never called anything, there's no entry point to my program, but because it complies I've typechecked against <code>(p ∨ q) ∨ r ↔ p ∨ (q ∨ r)</code>?</p>",
        "id": 299878463,
        "sender_full_name": "Arien Malec",
        "timestamp": 1663730296
    },
    {
        "content": "<p>Here is your proof transliterated to Haskell. As you can see, it typechecks.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Proof in Haskell</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">Or</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">L</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">R</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"></span>\n\n<span class=\"nf\">intro_left</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Or</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"></span>\n<span class=\"nf\">intro_left</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">L</span><span class=\"w\"></span>\n\n<span class=\"nf\">intro_right</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Or</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"></span>\n<span class=\"nf\">intro_right</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">R</span><span class=\"w\"></span>\n\n<span class=\"nf\">elim</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">Or</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"></span>\n<span class=\"nf\">elim</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">L</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"></span>\n<span class=\"nf\">elim</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">R</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"></span>\n\n<span class=\"nf\">or_assoc_right_pq</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">Or</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Or</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Or</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"nf\">or_assoc_right_pq</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"nf\">\\</span><span class=\"n\">hpq</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"n\">hpq</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">intro_left</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"n\">hq</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"n\">hqr</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">intro_left</span><span class=\"w\"> </span><span class=\"n\">hq</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kr\">in</span><span class=\"w\"> </span><span class=\"n\">intro_right</span><span class=\"w\"> </span><span class=\"n\">hqr</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n<span class=\"nf\">or_assoc_right_r</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Or</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Or</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"nf\">or_assoc_right_r</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"nf\">\\</span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"n\">hqr</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">intro_right</span><span class=\"w\"> </span><span class=\"n\">hr</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kr\">in</span><span class=\"w\"> </span><span class=\"n\">intro_right</span><span class=\"w\"> </span><span class=\"n\">hqr</span><span class=\"w\"></span>\n\n<span class=\"nf\">or_assoc_right</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">Or</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Or</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Or</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Or</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"nf\">or_assoc_right</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"nf\">\\</span><span class=\"n\">hpqr</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"n\">hpqr</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"n\">or_assoc_right_pq</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"n\">or_assoc_right_r</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n</div></div>\n<p>I guess you mean that in Haskell you can't have implicit arguments, like you can in Lean (regarding <code>p q r : Prop</code>)? Actually, <code>p q r</code> <strong>are</strong> implicit in Haskell. You can enable the <code>forall</code> syntax with <code>{-# LANGUAGE RankNTypes #-}</code>. Also, you can make them explicit with <code>{-# LANGUAGE ScopedTypeVariables TypeApplications #-}</code> and the syntax would be:</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"nf\">or_assoc_right</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"n\">forall</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">.</span><span class=\"w\"> </span><span class=\"kt\">Or</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Or</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Or</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Or</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"nf\">or_assoc_right</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"nf\">\\</span><span class=\"n\">hpqr</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"n\">hpqr</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"n\">or_assoc_right_pq</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"n\">r</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"n\">or_assoc_right_r</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 299878646,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1663730512
    },
    {
        "content": "<blockquote>\n<p>typechecking is proof?</p>\n</blockquote>\n<p>basically... at least when your return type is a proposition and your lemma returns a term of it</p>",
        "id": 299878809,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1663730682
    },
    {
        "content": "<p>it can be a bit strange, coming from the programming side of things</p>",
        "id": 299878837,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1663730743
    },
    {
        "content": "<p>I'm deeply in \"Typechecking the Technical Interview\" land now!</p>\n<p>Thanks so much -- I'm learning a great deal...</p>",
        "id": 299881008,
        "sender_full_name": "Arien Malec",
        "timestamp": 1663733010
    },
    {
        "content": "<p>Yeah one reason I like lean is that I was always lousy at writing algorithms, but lean proofs don't run! As long as they typecheck you've proved the theorem!</p>",
        "id": 299881314,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1663733335
    }
]
[
    {
        "content": "<p>I have state </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">K</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">_inst_1</span><span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"n\">K</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">coyoneda.obj</span> <span class=\"o\">(</span><span class=\"n\">opposite.op</span> <span class=\"o\">(</span><span class=\"n\">Algebra.of</span> <span class=\"n\">K</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]))</span> <span class=\"bp\">⟶</span> <span class=\"n\">forget</span> <span class=\"o\">(</span><span class=\"n\">Algebra</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>in my proof. What should my next line be? I tried </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">hom</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">app</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"n\">naturality'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n</code></pre></div>\n<p>but getting <code>invalid 'begin-end' expression, ',' expected</code>. <br>\nHere is the full code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- https://leanprover-community.github.io/mathlib_docs/category_theory/functor/hom.html</span>\n<span class=\"c1\">-- THE PLAN IS TO DEFINE AN AFFINE GROUP SCHEME AS A REPRESENTABLE FUNCTOR FROM K-ALGEBRAS TO GROUPS, AND PROVE THAT G_a := Hom(K[X], _) IS AN AFFINE GROUP SCHEME</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.types</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.category.Algebra.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.category.Group.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.polynomial.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.polynomial.algebra_map</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.over</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">polynomial</span>\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"c1\">-- variables (K_alg : Type*) [category K_alg] [category_theory.under K] -- category of commutative K-algebras. But how to use it...</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">affine_scheme</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">scheme</span> <span class=\"o\">:</span> <span class=\"n\">Algebra</span> <span class=\"n\">K</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">corepresentable</span> <span class=\"o\">:</span> <span class=\"n\">scheme.corepresentable</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">affine_group_scheme</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">scheme</span> <span class=\"o\">:</span> <span class=\"n\">Algebra</span> <span class=\"n\">K</span> <span class=\"bp\">⥤</span> <span class=\"n\">Group</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">corepresentable</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">scheme</span> <span class=\"bp\">⋙</span> <span class=\"n\">forget</span> <span class=\"n\">Group</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">corepresentable</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- DEFINING G_a</span>\n<span class=\"kd\">instance</span> <span class=\"n\">G_a</span> <span class=\"o\">:</span> <span class=\"n\">affine_scheme</span> <span class=\"n\">K</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">scheme</span> <span class=\"o\">:=</span> <span class=\"n\">forget</span> <span class=\"o\">(</span><span class=\"n\">Algebra</span> <span class=\"n\">K</span><span class=\"o\">),</span>\n  <span class=\"n\">corepresentable</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">refine</span> <span class=\"o\">{</span><span class=\"n\">has_corepresentation</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">},</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">opposite.op</span> <span class=\"o\">(</span><span class=\"n\">Algebra.of</span> <span class=\"n\">K</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]),</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"c1\">-- ∃ (f : coyoneda.obj (opposite.op (Algebra.of K K[X])) ⟶ forget (Algebra K)), is_iso f</span>\n    <span class=\"n\">refine</span> <span class=\"n\">exists.intro</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">hom</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">app</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"n\">naturality'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n    <span class=\"c1\">-- need to contruct a natural tranformation Hom(K[X], _) ⟶ forget (Algebra K)</span>\n    <span class=\"c1\">-- see for an example of defining a natural transformation https://leanprover-community.github.io/mathlib_docs/category_theory/yoneda.html#category_theory.yoneda_lemma</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 283008365,
        "sender_full_name": "Vasily Ilin",
        "timestamp": 1653005221
    },
    {
        "content": "<p>I would avoid constructing the corepresentable term in tactic mode.</p>",
        "id": 283008906,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653005706
    },
    {
        "content": "<p>Also, I think you're misunderstanding what typeclasses are for. Certainly defining <code>G_a : affine_scheme K</code> makes no sense if you want <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">G</mi><mi mathvariant=\"double-struck\">a</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{G_a}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 283009185,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653005974
    },
    {
        "content": "<p>But if you ignore those issues, here is something to get you started</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">G_a</span> <span class=\"o\">:</span> <span class=\"n\">affine_scheme</span> <span class=\"n\">K</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">scheme</span> <span class=\"o\">:=</span> <span class=\"n\">forget</span> <span class=\"o\">(</span><span class=\"n\">Algebra</span> <span class=\"n\">K</span><span class=\"o\">),</span>\n  <span class=\"n\">corepresentable</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">refine</span> <span class=\"o\">{</span><span class=\"n\">has_corepresentation</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">},</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">opposite.op</span> <span class=\"o\">(</span><span class=\"n\">Algebra.of</span> <span class=\"n\">K</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]),</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"c1\">-- ∃ (f : coyoneda.obj (opposite.op (Algebra.of K K[X])) ⟶ forget (Algebra K)), is_iso f</span>\n    <span class=\"n\">refine</span> <span class=\"n\">exists.intro</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span> <span class=\"n\">intros</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">f</span> <span class=\"n\">X</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">tidy</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply_with</span> <span class=\"n\">nat_iso.is_iso_of_is_iso_app</span> <span class=\"o\">{</span> <span class=\"n\">instances</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span> <span class=\"o\">},</span>\n      <span class=\"n\">intros</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">is_iso_iff_bijective</span><span class=\"o\">,</span>\n      <span class=\"gr\">sorry</span>\n    <span class=\"o\">}</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 283009500,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653006305
    },
    {
        "content": "<p>The solution here is to make <code>G_a</code> a <code>def</code> instead of an <code>instance</code></p>",
        "id": 283009693,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653006532
    },
    {
        "content": "<p>An <code>instance</code> is some theorem or construction that you want to always make available on some type. For instance, there is an instance <code>field ℝ</code> that builds a field structure on <code>ℝ</code>, which you have available every time some theorem calls for a field.</p>",
        "id": 283009785,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653006624
    },
    {
        "content": "<p>Here, you just want to build some specific object, nothing canonical. So you should have a <code>def</code> instead.</p>",
        "id": 283009786,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653006624
    },
    {
        "content": "<p>And <code>affine_scheme</code> and <code>affine_group_scheme</code> should be <code>structure</code>s</p>",
        "id": 283016834,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653013615
    },
    {
        "content": "<p>Note that we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebraic_geometry.is_affine\">docs#algebraic_geometry.is_affine</a></p>",
        "id": 283019729,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1653016476
    }
]
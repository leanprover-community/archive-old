[
    {
        "content": "<p>I was reading through a Representation Theory textbook and a question came to my mind: Have the theory been implemented in any LEAN library?</p>",
        "id": 178343253,
        "sender_full_name": "Jineon Baek",
        "timestamp": 1571276342
    },
    {
        "content": "<p>No, there's essentially no representation theory at this point (although there is some commutative algebra).</p>",
        "id": 178344006,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1571277587
    },
    {
        "content": "<p>Thank you for answering. If so, how much it will be worth (for this community) to implement the theory in a library? It's a classical theory, but the fact that it is not yet implemented seems to somewhat imply that there are more urgent needs for other theories now. I want to know the context if any exists.</p>",
        "id": 178345476,
        "sender_full_name": "Jineon Baek",
        "timestamp": 1571279772
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"242240\">@Jineon Baek</span> It only somewhat implies that we don't have enough people power. It's a relatively small group of contributors, and they just hack on whatever they think is fun.</p>",
        "id": 178345702,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1571280156
    },
    {
        "content": "<p>There are several people on this chat that think that representation theory is extremely important. But we just haven't got round to doing anything so far.</p>",
        "id": 178345714,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1571280198
    },
    {
        "content": "<p>At some point <span class=\"user-mention\" data-user-id=\"220718\">@Ben McDonnell</span> started working on some rep.theory. Maybe he can share what he's got so far somewhere.</p>",
        "id": 178345726,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1571280238
    },
    {
        "content": "<p>Yes, I'd love to see some! A lot depends on what generality you want to do things in, and often for mathlib the answer is \"a lot of generality\".</p>",
        "id": 178346393,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1571281376
    },
    {
        "content": "<p>The theory of abelian categories is on the horizon, and might be useful to have in place, so if someone wants to work on that I'd be happy to provide some pointers (and get around to doing some of the things I promised to do).</p>",
        "id": 178346406,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1571281424
    },
    {
        "content": "<p>But generally --- pick a (good) book, and have a go. :-)</p>",
        "id": 178346410,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1571281441
    },
    {
        "content": "<p>I'd love to see someone start on Etingof's Representation Theory: <a href=\"http://www-math.mit.edu/~etingof/repb.pdf\" target=\"_blank\" title=\"http://www-math.mit.edu/~etingof/repb.pdf\">http://www-math.mit.edu/~etingof/repb.pdf</a></p>",
        "id": 178346477,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1571281532
    },
    {
        "content": "<p>Thanks for the input everyone! I'm a newbie both in this lean game and representation theory, so I'm thinking of learning both by implementing theorems in a textbook as I learn them like the 'intro to proof' course project.</p>",
        "id": 178348965,
        "sender_full_name": "Jineon Baek",
        "timestamp": 1571285735
    },
    {
        "content": "<p>Full generality is definitely what standard library should aim for though. If my own little project works out well I'll share. Would happy to hear pointers for a starting point. I'm wondering if I should give it a try for finite group rep. with finite dimensional vector space first, or in a bit more generality.</p>",
        "id": 178349170,
        "sender_full_name": "Jineon Baek",
        "timestamp": 1571286006
    },
    {
        "content": "<p>Why not try to prove the first interesting thing about finite group representations: averaging over the group is the projection onto the trivial isotypic component?</p>",
        "id": 178349357,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1571286244
    },
    {
        "content": "<ol>\n<li>define the operator 1/|G| \\Sigma_g g</li>\n<li>prove that it is idempotent</li>\n<li>prove that anything in its image is fixed by the group</li>\n<li>prove that if you are fixed by every group element you are fixed by this operator</li>\n</ol>",
        "id": 178349402,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1571286345
    },
    {
        "content": "<p>You'll need to see how to work with linear operators, and use <code>finset.sum</code> to handle the summations.</p>",
        "id": 178349473,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1571286441
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"242241\">@Seewoo Lee</span></p>",
        "id": 178349554,
        "sender_full_name": "Jineon Baek",
        "timestamp": 1571286592
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"242240\">@Jineon Baek</span> But certainly you will make your Lean life a lot easier by not putting those finiteness assumptions in your definition</p>",
        "id": 178352673,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1571291403
    },
    {
        "content": "<ol start=\"5\">\n<li>prove that the subset of elements fixed by the group is a sub-vectorspace.</li>\n</ol>",
        "id": 178352690,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1571291456
    },
    {
        "content": "<p>Representation theory is one of the many things on my list of stuff we need to get done at some point. It's a beautiful theory, and essentially self-contained. The first part of Serre's book would be the kind of goal we'd need</p>",
        "id": 178354918,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1571294764
    },
    {
        "content": "<p>inb4 it's a special case of L^2(G) and Peter--Weyl theorem</p>",
        "id": 178359160,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1571299469
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  When we developed Axiom at IBM Research there was an effort made to invite and actively support people who worked in areas where we needed implementations, for example, in finite fields. It might be interesting to \"talent search\" among mathematicians and actively recruit their participation. Perhaps Microsoft could be convinced to do a \"Microsoft Summer of Code\", providing a summer support program for mathematicians with proposals for lean development.</p>",
        "id": 178416100,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571342381
    },
    {
        "content": "<p>I don't think we need a \"person who works in representation theory\" -- all we need is an intelligent undergraduate who is trained in type theory and is interested, and I'm sure I'll find one in the end.</p>",
        "id": 178451453,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1571385005
    },
    {
        "content": "<p>I've collected together some of the bits and pieces of mathlib that I will require to define linear representations, but I'm still too new to be able to assemble them into a definition. I think the following is all the component parts, but it's just a heap of nonsense at the moment. Would some kind soul be able to align them into something I can start expressing lemmas about? (I'll probably only need a few of this kind of really basic question before I can answer such trivia myself.)</p>\n<p>One particular question I don't know the answer to: should I be expressing \"linear representation\" as a typeclass or merely a record? </p>\n<p>Alternatively, is there some kind of Lean walkthrough of how to assemble a definition like this?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">field</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">finite_dimensional</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">x</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">field</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Definition. Let V be a finite-dimensional vector space over F. A (linear) repre-</span>\n<span class=\"c1\">-- sentation of G on V is a homomorphism ρ = ρ_V : G → GL(V).</span>\n\n<span class=\"c1\">--def general_linear_group := units (M →ₗ[R] M)</span>\n<span class=\"c1\">--class is_group_hom [group α] [group β] (f : α → β) extends is_mul_hom f : Prop</span>\n</pre></div>",
        "id": 190638253,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584264123
    },
    {
        "content": "<p>The variables are quite right. The variables are the underlying types, and the structures are anonymous typeclass variables. Like so:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n</pre></div>",
        "id": 190638449,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584264525
    },
    {
        "content": "<p>Similarly, <code>G</code> is a group means <code>variables {G : Type*} [group G]</code></p>",
        "id": 190638461,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584264564
    },
    {
        "content": "<p>and then a linear representation would be an element of <code>G -&gt;* units (V -&gt;l[F] V)</code></p>",
        "id": 190638536,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584264622
    },
    {
        "content": "<p>Thanks. The way I had previously expected this to look was something like <code>def linear_representation (p : G -&gt; general_linear_group F (n -&gt; F)) := is_monoid_hom p</code>, but I suspect my mental model is wrong in a way that I don't understand (that line certainly doesn't compile). Is it clear to you what I've misunderstood?</p>",
        "id": 190639239,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584265629
    },
    {
        "content": "<p>to be clear, I currently have:</p>\n<div class=\"codehilite\"><pre><span></span>import algebra.field\nimport linear_algebra.finite_dimensional\nimport linear_algebra.basic\nimport algebra.module\n\nopen linear_map\n\nuniverses u v\nvariables {F : Type u} {V : Type v}\nvariables [discrete_field F]\nvariables (n : Type u) [fintype n] [decidable_eq n]\nvariables [field F]\nvariables {G : Type*} [add_comm_group G]\nvariables [vector_space F G]\n\ndef linear_representation (p : G -&gt; general_linear_group F (n -&gt; F)) := is_monoid_hom p\n</pre></div>",
        "id": 190639427,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584265859
    },
    {
        "content": "<p>You have two instances on <code>F</code>, one a <code>field</code> and one a <code>discrete_field</code>, that's definitely wrong. That is saying that <code>F</code> has two independent field structures. (In the latest version of lean/mathlib <code>discrete_field</code> has been renamed to <code>field</code>, replacing the original <code>field</code>.)</p>",
        "id": 190640530,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584267504
    },
    {
        "content": "<p>It's true that I didn't say anything about the finite dimensionality in the version I gave. That could be a predicate on <code>V</code>, something like <code>dim V &lt; omega</code>, although perhaps there's a typeclass for this now</p>",
        "id": 190640544,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584267579
    },
    {
        "content": "<p>But in your version, <code>vector_space F G</code> means that <code>G</code> is the <code>F</code>-vector space</p>",
        "id": 190640597,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584267645
    },
    {
        "content": "<p>which could be what you mean but doesn't match the math text in the comment</p>",
        "id": 190640604,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584267706
    },
    {
        "content": "<p>The way you have set up <code>linear_representation p</code> is as a predicate on functions from G asserting that they are a linear representation, whereas the approach I gave takes linear representations to be the entire type <code>G -&gt;* units (V -&gt;l[F] V)</code>, which bundles together the function with the proof that it is a group hom</p>",
        "id": 190640656,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584267829
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190640604\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190640604\">said</a>:</p>\n<blockquote>\n<p>which could be what you mean but doesn't match the math text in the comment</p>\n</blockquote>\n<p>Ah, you're quite right - I don't know how I could have made that mistake :P</p>",
        "id": 190640695,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584267852
    },
    {
        "content": "<p>mathlib is slowly moving away from unbundled homs like <code>is_monoid_hom</code> in favor of bundled homs like <code>G -&gt;+ H</code></p>",
        "id": 190640704,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584267879
    },
    {
        "content": "<p>OK, that makes sense - thanks</p>",
        "id": 190640707,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584267890
    },
    {
        "content": "<p>The flood of my questions should decay exponentially, but in the meantime: the following doesn't compile because \"type expected at <code>linear_representation</code>\" in the last line. How can I pass a linear representation into the function <code>dimension</code>?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">field</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">finite_dimensional</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">module</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">linear_map</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">discrete_field</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">n</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">linear_representation</span> <span class=\"o\">:=</span> <span class=\"n\">monoid_hom</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">general_linear_group</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">F</span><span class=\"o\">))</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">dimension</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">linear_representation</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">vector_space</span><span class=\"bp\">.</span><span class=\"n\">dim</span> <span class=\"n\">V</span>\n</pre></div>",
        "id": 190641233,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584268874
    },
    {
        "content": "<p>Have a look at <code>#check linear_representation</code></p>",
        "id": 190641409,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584269139
    },
    {
        "content": "<p>Maybe you don't quite understand how <code>variable</code> works yet.</p>",
        "id": 190641447,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584269163
    },
    {
        "content": "<p>Also try <code>#check @linear_representation</code>, and try to think about what is <code>V</code> at the very end of your code, and how it relates to <code>p</code>.</p>",
        "id": 190641510,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584269306
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190641447\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190641447\">said</a>:</p>\n<blockquote>\n<p>Maybe you don't quite understand how <code>variable</code> works yet.</p>\n</blockquote>\n<p>Ah right - again, I've been misled by Agda, which tends to do this via parameterised modules</p>",
        "id": 190641511,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584269315
    },
    {
        "content": "<p>There is also a problem which is completely independent of language differences.</p>",
        "id": 190641522,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584269373
    },
    {
        "content": "<p>Your <code>V</code> in the body of the definition has no relation whatsoever with <code>p</code>.</p>",
        "id": 190641531,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584269395
    },
    {
        "content": "<p>Your <code>p</code> obviously has dimension <code>n</code> by definition.</p>",
        "id": 190641589,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584269425
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190641589\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190641589\">said</a>:</p>\n<blockquote>\n<p>Your <code>p</code> obviously has dimension <code>n</code> by definition.</p>\n</blockquote>\n<p>You're right, I actually want the <code>n</code> from the body of <code>linear_representation</code> - but I am happy to leave questions like \"have I got the definition correct\" for the moment (I'll discover they're wrong as soon as I come to formulate any theorems) while I learn how to use Lean</p>",
        "id": 190641647,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584269529
    },
    {
        "content": "<p>You have <code>V</code> and also <code>n -&gt; F</code> as vector spaces. Which do you want?</p>",
        "id": 190641660,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584269585
    },
    {
        "content": "<p>In case this isn't clear: Mario's question is about the same topic as mine.</p>",
        "id": 190641666,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584269607
    },
    {
        "content": "<p><code>linear_representation</code> has too many implicit variables</p>",
        "id": 190641667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584269618
    },
    {
        "content": "<p><code>n -&gt; F</code> - but I can almost certainly work out how to do that by myself, once I've correctly passed a linear representation into <code>dimension</code>. I'll rejig it so that the right variables are explicit and then it'll probably all just fall out</p>",
        "id": 190641671,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584269641
    },
    {
        "content": "<p>Thanks</p>",
        "id": 190641673,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584269642
    },
    {
        "content": "<p>you need to make the type variables explicit, and then write e.g. <code>p : linear_representation F G V</code></p>",
        "id": 190641711,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584269653
    },
    {
        "content": "<p>or <code>linear_representation F G n</code> if you want that version</p>",
        "id": 190641720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584269689
    },
    {
        "content": "<p>That's why I wrote a bunch of <code>#check</code></p>",
        "id": 190641729,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584269757
    },
    {
        "content": "<p>If the definition has the form <code>linear_representation F G n</code>, then the dimension is <code>n</code>, and there is no need for a definition <code>dimension</code>. This is what patrick is saying</p>",
        "id": 190641768,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584269765
    },
    {
        "content": "<p>Because in this situation Lean will typically complain it cannot synthesize a term of type<code>Type u</code> without telling which implicit variable it wasn't able to synthesize and this is not easy to debug without <code>#check</code></p>",
        "id": 190641776,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584269817
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"117987\">@Patrick Stevens</span> <code>field</code> means different things in Lean 3.4.2 (the officially sanctioned version of Lean, which is frozen, as is mathlib support) and 3.6.1 (the community version, which current mathlib compiles with). I guess I'd recommend you use 3.6.1 but I just wanted to flag this now.</p>",
        "id": 190643018,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584272218
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"c1\">-- working with Lean 3.6.1 and current mathlib</span>\n<span class=\"c1\">-- don&#39;t need all of these imports for group_module</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">field</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">finite_dimensional</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">module</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n\n<span class=\"n\">class</span> <span class=\"n\">group_module</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"kn\">extends</span>  <span class=\"n\">has_scalar</span> <span class=\"n\">G</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">one_smul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"err\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">smul_smul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"err\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"err\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">smul_add</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">one_smul</span> <span class=\"n\">smul_smul</span> <span class=\"n\">smul_add</span> <span class=\"c1\">-- I think?</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">group_module</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">group_module</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">smul_neg</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">smul_zero</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">smul_sub</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">-</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"n\">m</span> <span class=\"bp\">-</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">group_module</span>\n\n<span class=\"c1\">-- new file with more imports</span>\n\n<span class=\"n\">class</span> <span class=\"n\">group_representation</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">group_module</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">smul_comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"err\">•</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">μ</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">group_representation</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">group_module</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">dim</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">group_representation</span> <span class=\"n\">G</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">vector_space</span><span class=\"bp\">.</span><span class=\"n\">dim</span> <span class=\"n\">V</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">group_representation</span>\n</pre></div>\n\n\n<p>There's my effort, but definitions are not my strong point.</p>",
        "id": 190643511,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584273206
    },
    {
        "content": "<p>There should really be a bunch of lemmas about <code>group_module</code> first, because this is a simpler object (no field involved)</p>",
        "id": 190643519,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584273238
    },
    {
        "content": "<p>furthermore the definitions should be in two different files really, because someone interested in group cohomology might not want to import the representation theory stuff.</p>",
        "id": 190643565,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584273280
    },
    {
        "content": "<p>The following doesn't compile because \"maximum class-instance resolution depth has been reached\" on the last line for <code>monoid_hom</code>; presumably that means Lean can't figure out that I've specified a homomorphism, so I need to supply an instance of <code>is_monoid_hom</code> to go with the lambda-term. </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">field</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">finite_dimensional</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">module</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">linear_map</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">discrete_field</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">linear_representation</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">n</span><span class=\"o\">]</span>\n  <span class=\"o\">:=</span>\n  <span class=\"n\">monoid_hom</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">general_linear_group</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">F</span><span class=\"o\">))</span>\n\n<span class=\"n\">def</span> <span class=\"n\">trivial_representation</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">linear_representation</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">monoid_hom</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">general_linear_group</span><span class=\"bp\">.</span><span class=\"n\">of_linear_equiv</span> <span class=\"o\">(</span><span class=\"n\">linear_equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">1</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">F</span><span class=\"o\">)))</span>\n</pre></div>\n\n\n<p>But my best attempt at that instance is the following, which doesn't compile (\"don't know how to synthesize placeholder\" on <code>general_linear_group</code>):</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">identity_is_hom</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_monoid_hom</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">general_linear_group</span><span class=\"bp\">.</span><span class=\"n\">of_linear_equiv</span> <span class=\"o\">(</span><span class=\"n\">linear_equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">1</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">F</span><span class=\"o\">))</span>\n<span class=\"k\">by</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>This problem persists even if I supply <code>F</code> as well (i.e. prepend the arguments <code>(F : Type*) [discrete_field F]</code> to <code>identity_is_hom</code>). It's not clear to me that I can supply any more information to Lean here; what have I missed?</p>",
        "id": 190643691,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584273520
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643519\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643519\">said</a>:</p>\n<blockquote>\n<p>There should really be a bunch of lemmas about <code>group_module</code> first, because this is a simpler object (no field involved)</p>\n</blockquote>\n<p>Fair enough - I'm using this more as a \"learn Lean\" exercise than a \"produce something to go into mathlib\" at the moment, so am happy just playing around with the definitions at the moment</p>",
        "id": 190643708,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584273593
    },
    {
        "content": "<p>OK I'll take a look at your version.</p>",
        "id": 190643758,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584273636
    },
    {
        "content": "<p>Which version of Lean are you using?</p>",
        "id": 190643826,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584273772
    },
    {
        "content": "<p>Your def of <code>linear_representation</code> has a V as an input which is never used</p>",
        "id": 190643894,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584273914
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643826\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643826\">said</a>:</p>\n<blockquote>\n<p>Which version of Lean are you using?</p>\n</blockquote>\n<p>leanprover-community/lean:3.5.1, according to my <code>leanpkg.toml</code></p>",
        "id": 190643899,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584273930
    },
    {
        "content": "<p>You should probably upgrade because I just noticed that it's a pain to look at your code because of all this deprecated <code>discrete_field</code> stuff. There will be a painless way to do it with <code>leanproject</code> I suspect.</p>",
        "id": 190643945,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584273978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643945\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643945\">said</a>:</p>\n<blockquote>\n<p>You should probably upgrade because I just noticed that it's a pain to look at your code because of all this deprecated <code>discrete_field</code> stuff. There will be a painless way to do it with <code>leanproject</code> I suspect.</p>\n</blockquote>\n<p>OK, thanks - I'll do that before anything else</p>",
        "id": 190643949,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584274000
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> what do you think of my version by the way? Once we have the definitions right the lemmas should be fun, but the definitions are a minefield.</p>",
        "id": 190643952,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274014
    },
    {
        "content": "<p>I think it should be a monoid rather than a group</p>",
        "id": 190644083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274261
    },
    {
        "content": "<p>it also looks suspiciously like a group action</p>",
        "id": 190644089,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274285
    },
    {
        "content": "<p>It <em>is</em> a group action</p>",
        "id": 190644090,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584274300
    },
    {
        "content": "<p>A group module is a group action by module homs</p>",
        "id": 190644091,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274300
    },
    {
        "content": "<p>Mario is pointing out that it could extend group actions</p>",
        "id": 190644096,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274316
    },
    {
        "content": "<p>(then you get a bunch of theorems for free)</p>",
        "id": 190644135,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274328
    },
    {
        "content": "<p>You also get a bunch of theorems for free if you don't define this at all and use the high level characterization instead</p>",
        "id": 190644157,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274406
    },
    {
        "content": "<p>I'm not sure what you mean, but whatever you mean I suspect people will want this in practice.</p>",
        "id": 190644259,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274464
    },
    {
        "content": "<p>Don't you get all this if you just say <code>linear_representation := G -&gt;* units (V -&gt;l[F] V)</code>?</p>",
        "id": 190644262,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274473
    },
    {
        "content": "<p>Yes absolutely</p>",
        "id": 190644267,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274489
    },
    {
        "content": "<p>it's not clear to me what the tradeoffs are here</p>",
        "id": 190644304,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274538
    },
    {
        "content": "<p>Is that a high-level characterisation? There is another one -- there's a ring <code>G -&gt;_0 F</code> called the group ring, and a group representation is the same thing as a module over that ring</p>",
        "id": 190644305,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274547
    },
    {
        "content": "<p>sure, any of those sound good to me</p>",
        "id": 190644342,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274563
    },
    {
        "content": "<p>they are already very compact</p>",
        "id": 190644344,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274570
    },
    {
        "content": "<p>You're a computer scientist so can see advantages in the compactness</p>",
        "id": 190644351,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274593
    },
    {
        "content": "<p>It's less clear to me</p>",
        "id": 190644353,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274600
    },
    {
        "content": "<p>Isn't this usually how the mathematicians do it?</p>",
        "id": 190644401,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274612
    },
    {
        "content": "<p>I would prefer clarity</p>",
        "id": 190644403,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274614
    },
    {
        "content": "<p>I feel like we've swapped sides of this argument</p>",
        "id": 190644418,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274626
    },
    {
        "content": "<p>If you define it as a module over the group ring then all of a sudden you don't have <code>g \\bub v</code> you have <code>\\u g \\bub v</code> etc</p>",
        "id": 190644421,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274656
    },
    {
        "content": "<p>and these invisible functions can cause confusion, make rewriting harder etc</p>",
        "id": 190644424,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274678
    },
    {
        "content": "<p>remind me who is playing the role of the CS guy again</p>",
        "id": 190644466,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274713
    },
    {
        "content": "<p>With your approach there are coercions to fun etc, whereas sometimes <code>g \\bub v</code> is just the thing you want.</p>",
        "id": 190644471,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274726
    },
    {
        "content": "<p>My understanding here is that there is no perfect solution.</p>",
        "id": 190644476,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274749
    },
    {
        "content": "<p>That's certainly going to be the case</p>",
        "id": 190644478,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274767
    },
    {
        "content": "<p>how about you CS guys make the system we want then ;-)</p>",
        "id": 190644480,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274784
    },
    {
        "content": "<p>Like I said, there is a tradeoff here and I don't have a good grasp of it</p>",
        "id": 190644484,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274789
    },
    {
        "content": "<p>because you don't know what mathematicians actually use group representations for. This is why we need the area to get bigger, we need people who are experts at everything at once.</p>",
        "id": 190644530,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274823
    },
    {
        "content": "<p>Mathematicians just invoke the invisible function machine and pass seamlessly from one concept to the other</p>",
        "id": 190644594,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274866
    },
    {
        "content": "<p>I have already argued that DTT is the problem but you're already bought in so ¯\\_(ツ)_/¯</p>",
        "id": 190644595,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274874
    },
    {
        "content": "<p>and we don't check the diagrams commute because this is trivial</p>",
        "id": 190644596,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274879
    },
    {
        "content": "<p>in set theory it really is that easy to pass between representations</p>",
        "id": 190644604,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274892
    },
    {
        "content": "<p>I'm not going back to assembly language now</p>",
        "id": 190644653,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274911
    },
    {
        "content": "<p>to use a rust analogy, I don't want assembly language, I want <code>unsafe</code> blocks</p>",
        "id": 190644718,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274961
    },
    {
        "content": "<p>You lost me :-/ but I'm happy to hear more.</p>",
        "id": 190644770,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275043
    },
    {
        "content": "<p>I want the ability to get around the type system without it getting mad at me forever</p>",
        "id": 190644781,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584275064
    },
    {
        "content": "<p>In set theory if <code>x \\in A</code> and <code>A = B</code> then <code>x \\in B</code></p>",
        "id": 190644786,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584275091
    },
    {
        "content": "<p>in type theory this will cause the proof assistant to hate you forever</p>",
        "id": 190644792,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584275108
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"117987\">@Patrick Stevens</span> the problem with your code, I guess, is that you've defined a function <code>j</code> from G to <code>general_linear_group F (fin 1 → F)</code> but Lean has no particular reason to know that this function has the property that <code>j(g*h)=j(g)*j(h)</code>.</p>",
        "id": 190644805,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275134
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190644792\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190644792\">said</a>:</p>\n<blockquote>\n<p>in type theory this will cause the proof assistant to hate you forever</p>\n</blockquote>\n<p>In type theory we have to insert an invisible coercion from A to B and then coerce x over.</p>",
        "id": 190644875,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275187
    },
    {
        "content": "<p>it's not invisible</p>",
        "id": 190644909,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584275207
    },
    {
        "content": "<p>I wish it was</p>",
        "id": 190644912,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584275217
    },
    {
        "content": "<p>we try very hard to make it not too annoying with mixed success</p>",
        "id": 190644918,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584275238
    },
    {
        "content": "<p>Sure -- I just meant \"invisible to mathematicians\"</p>",
        "id": 190644922,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275244
    },
    {
        "content": "<p>and we have a rather liberal notion of <code>=</code></p>",
        "id": 190644973,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275259
    },
    {
        "content": "<p>I think that lean is a great system, probably the best among all systems I know at the user experience. I also think that this property has almost nothing to do with the fact that it implements DTT</p>",
        "id": 190645022,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584275319
    },
    {
        "content": "<p>We understand the concept of an equivalence of categories, but all these structures on one vector space V (a linear action of a group, a group hom to the automorphisms, a module for the group ring) are all equal because they are simply different ways of packing up precisely the same information. They are a tedious implementation issue which we cunningly avoid by seamlessly changing our implementation decisions mid-proof.</p>",
        "id": 190645030,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275357
    },
    {
        "content": "<p>in lean, we can do this with equivs of various kinds, and maybe this will eventually be packed into some category machinery</p>",
        "id": 190645106,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584275452
    },
    {
        "content": "<p>but I do think it is essential to be able to do concrete work in any of those representations</p>",
        "id": 190645116,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584275486
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"bp\">@</span><span class=\"n\">monoid_hom</span><span class=\"bp\">.</span><span class=\"n\">of</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">monoid_hom.of :</span>\n<span class=\"cm\">  Π {M : Type u_3} {N : Type u_4} [mM : monoid M] [mN : monoid N] (f : M → N) [h : is_monoid_hom f], M →* N</span>\n<span class=\"cm\">-/</span>\n</pre></div>\n\n\n<p>Patrick -- this definition of <code>monoid_hom.of</code> says \"you give me a map <code>f</code> and I will then use type class inference to find a term <code>h</code> of type <code>is_monoid_hom f</code>. Once I've found it I'll give you back a monoid homomorphism (which is essentially the pair consisting of f and h).</p>",
        "id": 190645117,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275487
    },
    {
        "content": "<p>Yep, I'd got that far - I'm struggling to construct that term though</p>",
        "id": 190645122,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584275516
    },
    {
        "content": "<p>The type class inference system is a bunch of lemmas of the form \"a ring homomorphism is a monoid homomorphism\" etc.</p>",
        "id": 190645123,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275518
    },
    {
        "content": "<p>The following doesn't compile, for example, because \"don't know how to synthesize placeholder\" at <code>general_linear_group</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">identity_is_hom</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">discrete_field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_monoid_hom</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">general_linear_group</span><span class=\"bp\">.</span><span class=\"n\">of_linear_equiv</span> <span class=\"o\">(</span><span class=\"n\">linear_equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">1</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">F</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 190645216,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584275557
    },
    {
        "content": "<p>It will probably know that <code>general_linear_group X Y</code> is a group and hence a monoid but it won't know that your map is a monoid hom.</p>",
        "id": 190645267,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275648
    },
    {
        "content": "<p>The issue with the synthesizing placeholder will be that Lean can't figure out which ring you're working over.</p>",
        "id": 190645273,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275676
    },
    {
        "content": "<p>I was hoping to tell it this was a hom, in the bit where I currently have <code>sorry</code></p>",
        "id": 190645276,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584275685
    },
    {
        "content": "<p>Before the sorry Lean is failing to elaborate the term.</p>",
        "id": 190645288,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275712
    },
    {
        "content": "<p>It can't figure out the type of <code>linear_equiv.refl (fin 1 -&gt; F)</code></p>",
        "id": 190645290,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275723
    },
    {
        "content": "<p>The type is that <code>(fin 1 -&gt; F)</code> is isomorphic to itself as a module over...some metavariable.</p>",
        "id": 190645334,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275775
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">identity_is_hom</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">discrete_field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_monoid_hom</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">general_linear_group</span><span class=\"bp\">.</span><span class=\"n\">of_linear_equiv</span> <span class=\"n\">F</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">linear_equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">1</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">F</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 190645345,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275833
    },
    {
        "content": "<p>The variable inputs in <code>{}</code> brackets are ones which are supposed to be inferred by unification, but we're claiming that the identity map <code>fin 1 -&gt; F</code> is R-linear where R is a ring acting on <code>fin 1 -&gt; F</code> and we give no indication as to what this ring is. Whatever R is, this theorem is still true. My gut feeling is that your problem has come from a possibly questionable design decision to make the R input implicit.</p>",
        "id": 190645454,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275951
    },
    {
        "content": "<p>Ooh, yuck - thanks; in Agda you can supply any particular implicit variable, like <code>f {A = B} arg1 {C = C} arg2</code> where <code>A</code> and <code>C</code> were implicit args. It looks like in Lean you can only \"make all args explicit\"?</p>",
        "id": 190645461,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584275963
    },
    {
        "content": "<p>PS I am now talking to you as if you were an expert. Let me know if I'm going over your head.</p>",
        "id": 190645464,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275968
    },
    {
        "content": "<p>Yes, you can make all args explicit or none of them! That is a really cool agda thing, I wish we had that in Lean.</p>",
        "id": 190645496,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276002
    },
    {
        "content": "<p>Yep, I see what you mean</p>",
        "id": 190645512,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584276010
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> can you just pop that into 3.7.2 for us?</p>",
        "id": 190645513,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276019
    },
    {
        "content": "<p>there is a concrete syntax for this in lean 4 but I forget what it is</p>",
        "id": 190645533,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276073
    },
    {
        "content": "<p>if we used that notation it would get confused with passing a singleton of an equality to <code>f</code></p>",
        "id": 190645582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276132
    },
    {
        "content": "<p>MS should employ an intern who gets an email whenever an issue like this comes up, and solves it manually</p>",
        "id": 190645587,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276181
    },
    {
        "content": "<p>Oh here's a better idea -- just use a new kind of bracket.</p>",
        "id": 190645593,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276201
    },
    {
        "content": "<p>Even if it did exist, the name of the argument could only possibly be the name of the binder, and typeclass args always have ugly names like <code>_inst_1</code></p>",
        "id": 190645602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276221
    },
    {
        "content": "<p>Why are we using <code>{}</code> for both implicit variable and set notation anyway?</p>",
        "id": 190645603,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276224
    },
    {
        "content": "<p>Here we were missing <code>R</code> not some typeclass thing. The issue here was with unification failing, not type class inference.</p>",
        "id": 190645697,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276263
    },
    {
        "content": "<p>Binders are always distinguishable because they come after binding notation tokens</p>",
        "id": 190645699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276265
    },
    {
        "content": "<p>but implicit function args are just in regular expression position</p>",
        "id": 190645707,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276289
    },
    {
        "content": "<p>Mathematicians got <code>{}</code> first for sets, you just need some wacky unicode for your implicit instances and then we're all set.</p>",
        "id": 190645731,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276324
    },
    {
        "content": "<p>there is no problem with binders because they only come after <code>\\lam</code> and stuff</p>",
        "id": 190645782,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276368
    },
    {
        "content": "<p><code>\\lam {x | x &gt; 0}</code> doesn't make any sense</p>",
        "id": 190645785,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276383
    },
    {
        "content": "<p>I don't know what a binder is. I thought that was forall etc.</p>",
        "id": 190645788,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276392
    },
    {
        "content": "<p>yes</p>",
        "id": 190645790,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276395
    },
    {
        "content": "<p><code>\\Pi</code>, <code>\\forall</code>, <code>\\lam</code>, <code>\\sum</code>, etc</p>",
        "id": 190645795,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276410
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">linear_equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_4</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_5</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">],</span> <span class=\"n\">M</span> <span class=\"err\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span>\n</pre></div>\n\n\n<p>Should R be explicit here?</p>",
        "id": 190645796,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276413
    },
    {
        "content": "<p>I think so</p>",
        "id": 190645801,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276425
    },
    {
        "content": "<p>I am confused about what binders have to do with the fact that I just had to write <code>@foo F _ _ _ _</code></p>",
        "id": 190645802,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276431
    },
    {
        "content": "<p>There are no binders involved in the expression <code>@foo F _ _ _ _</code></p>",
        "id": 190645807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276463
    },
    {
        "content": "<p>whereas I wanted to write <code>foo {R = F}</code></p>",
        "id": 190645809,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276465
    },
    {
        "content": "<p>but <code>{R = F}</code> is actually a valid expression, of type <code>set Prop</code></p>",
        "id": 190645855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276488
    },
    {
        "content": "<p>and that's why I'm saying you should keep your grubby implicit variable hands off our set notation and come up with some different bracket system.</p>",
        "id": 190645860,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276515
    },
    {
        "content": "<p>which is kind of nonsense, but <code>foo</code> might nevertheless have type <code>set Prop -&gt; T</code> and then <code>foo {R = F}</code> is valid</p>",
        "id": 190645861,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276522
    },
    {
        "content": "<p>Oh, if the notation is something other than <code>@foo {R = F}</code> then we're fine probably</p>",
        "id": 190645869,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276561
    },
    {
        "content": "<p>or treat us like dirt, like you usually do, and make us use different weird brackets so as to confuse the regular mathematicians</p>",
        "id": 190645870,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276562
    },
    {
        "content": "<p>I mean we already have those funny unicode brackets that are a pain to type for semi implicit</p>",
        "id": 190645876,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276593
    },
    {
        "content": "<p>You wouldn't believe how many times I've been asked why <code>2 | 4</code> throw up wacky errors</p>",
        "id": 190645881,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276597
    },
    {
        "content": "<p>when it works in LaTeX</p>",
        "id": 190645966,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276611
    },
    {
        "content": "<p><code>2 \\mid 4</code> is the way to do it in latex</p>",
        "id": 190645971,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276630
    },
    {
        "content": "<p>(actually it doesn't even work in LaTeX, the glue is incorrect and the user should use <code>\\mid</code> ;-) )</p>",
        "id": 190645973,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276635
    },
    {
        "content": "<p>Because of the possibility of conflict, it seems pretty sensitive what notation is used for passing implicit arguments like this. I should see what lean 4 picked</p>",
        "id": 190646000,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276705
    },
    {
        "content": "<p>but yes, if it's some <code>foo {&lt;&lt;R = F&gt;&gt;}</code> thing then we're fine</p>",
        "id": 190646045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276736
    },
    {
        "content": "<p>then again, typing that may become annoying</p>",
        "id": 190646053,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276777
    },
    {
        "content": "<p>syntax is hard</p>",
        "id": 190646056,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276791
    },
    {
        "content": "<p>You all seem to be happy with all that &gt;=-+ monad stuff</p>",
        "id": 190646061,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276816
    },
    {
        "content": "<p>This is a feature that isn't meant to be used very often</p>",
        "id": 190646062,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584276819
    },
    {
        "content": "<p>So what you're saying is that instead of all this bracket banter I should just be making a PR changing {R} to (R)? :-)</p>",
        "id": 190646108,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276876
    },
    {
        "content": "<p>unfortuately it won't work for 3.4.2 ;-)</p>",
        "id": 190646110,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276893
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">identity_is_hom</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">discrete_field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_monoid_hom</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">general_linear_group</span><span class=\"bp\">.</span><span class=\"n\">of_linear_equiv</span> <span class=\"n\">F</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">linear_equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">1</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">F</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map_mul</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">map_one</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n</pre></div>\n\n\n<p>is how to make the instance, in case you didn't know Lean syntax</p>",
        "id": 190646177,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276973
    },
    {
        "content": "<p>I got this in VS Code by writing <code>... := {! !}</code> and then clicking on the little lightbulb which appeared and selecting \"create a skeleton\"</p>",
        "id": 190646191,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584277048
    },
    {
        "content": "<p>It's really hard to Google for the <code>example</code> keyword :P is it possible for me to name an example, or do I have to make it a <code>def</code> if I want to refer to it? Currently I have a definition which works, and now I want to run it through <code>#check</code> but I can't work out how to refer to it.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">-- Trivial representation</span>\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">linear_representation</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">general_linear_group</span><span class=\"bp\">.</span><span class=\"n\">of_linear_equiv</span> <span class=\"o\">(</span><span class=\"n\">linear_equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">map_one&#39;</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">map_mul&#39;</span> <span class=\"o\">:=</span> <span class=\"k\">by</span>\n    <span class=\"k\">begin</span>\n      <span class=\"n\">intros</span> <span class=\"n\">g</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"kn\">end</span>\n  <span class=\"o\">}</span>\n</pre></div>",
        "id": 190661151,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584297880
    },
    {
        "content": "<p>You can try giving it a name, like so: <code>def even (n : ℤ) := 2 ∣ n</code></p>",
        "id": 190661478,
        "sender_full_name": "Daniel Keys",
        "timestamp": 1584298280
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"259186\">Daniel Keys</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190661478\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190661478\">said</a>:</p>\n<blockquote>\n<p>You can try giving it a name, like so: <code>def even (n : ℤ) := 2 ∣ n</code></p>\n</blockquote>\n<p>Sure, I was just wondering if I could use the <code>example</code> syntax to name an example, or whether I was forced to use <code>def</code></p>",
        "id": 190661482,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584298303
    },
    {
        "content": "<p>I think you need to make it a lemma or theorem in order to give it a name.</p>",
        "id": 190661543,
        "sender_full_name": "Daniel Keys",
        "timestamp": 1584298361
    },
    {
        "content": "<p>Here's a stupid question: I've defined some stuff, and I want to #eval it to see whether it looks right (before I start going to the effort of proving things about it). For example, I've defined the dimension of a representation, and I want to check that the dimension of a certain representation is in fact 2 when I expect it to be. But for the life of me I can't find any actual examples of groups in mathlib (and so I have nothing to pass into #eval): the cyclic groups seem not to have been defined, Q and R appear not to have been endowed with group structures, etc. Are there actually any groups anywhere? And how should I be trying to find them in mathlib?</p>",
        "id": 191337769,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584784321
    },
    {
        "content": "<p>Hmm... such examples are certain there.</p>",
        "id": 191337883,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784460
    },
    {
        "content": "<p>Q and R are both endowed with the structure of a linearly ordered field, so in particular they are additive groups</p>",
        "id": 191337890,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784498
    },
    {
        "content": "<p>But <code>#eval</code> cannot compute a dimension for you</p>",
        "id": 191337898,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784516
    },
    {
        "content": "<p>(It would have to cook up a basis, etc...)</p>",
        "id": 191337915,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784531
    },
    {
        "content": "<p>My current problem is simply an inability to synthesise a typeclass instance for <code>group R</code>, for example</p>",
        "id": 191337917,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584784547
    },
    {
        "content": "<p>On the other hand, there is certainly a theorem in mathlib saying that <code>K^n</code> has dimension <code>n</code> over <code>K</code>.</p>",
        "id": 191337919,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784553
    },
    {
        "content": "<p>Because it's not a group. It's an <code>add_group</code>.</p>",
        "id": 191337958,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784566
    },
    {
        "content": "<p>This is very unfortunate.</p>",
        "id": 191337962,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784572
    },
    {
        "content": "<p>Oh, that's very upsetting</p>",
        "id": 191337971,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584784599
    },
    {
        "content": "<p>But in the current setup, we need to duplicate groups to distinguish between multiplicative and additive groups</p>",
        "id": 191337973,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784603
    },
    {
        "content": "<p>If we don't do that, we cannot have nice notation.</p>",
        "id": 191337976,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784613
    },
    {
        "content": "<p>On the other hand, this is mostly done completely automatically. You prove things for multiplicative groups, and you are done.</p>",
        "id": 191337985,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784637
    },
    {
        "content": "<p>So you get <code>monoid R</code> and <code>add_group R</code> in your case.</p>",
        "id": 191337988,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784647
    },
    {
        "content": "<p>So it's just a matter of taste whether you want to use <code>add_group</code> or <code>group</code> in a particular theory?</p>",
        "id": 191337994,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584784672
    },
    {
        "content": "<p>Well, mostly yes.</p>",
        "id": 191338048,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784771
    },
    {
        "content": "<p>But the machinery can turn generate an additive version of a multiplicative definition/theorem, but not the other way round.</p>",
        "id": 191338057,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784800
    },
    {
        "content": "<p>So all the generalities are developed using multiplicative notation.</p>",
        "id": 191338100,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784811
    },
    {
        "content": "<p>But stuff like modules and representations assumes additive groups</p>",
        "id": 191338110,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784825
    },
    {
        "content": "<p>Was that a mistake? Should they not use the phrasing that affords more generality, i.e. multiplicative?</p>",
        "id": 191338131,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584784892
    },
    {
        "content": "<p>No, because of the notation.</p>",
        "id": 191338362,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584785238
    },
    {
        "content": "<p>If M is an R-module, you want to me able to write <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo>⋅</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">r \\cdot (x + y)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.44445em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span> for <code>r : R</code> and <code>x y : M</code></p>",
        "id": 191338371,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584785277
    },
    {
        "content": "<p>I agree that it's confusing. (The mathematician in me is still unhappy about it.) But in practice it works quite well.</p>",
        "id": 191338411,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584785307
    },
    {
        "content": "<p>So, the magic command to make a multiplicative theorem additive is</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">to_additive</span><span class=\"o\">]</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">my_multiplicative_thm</span> <span class=\"bp\">...</span>\n</pre></div>",
        "id": 191338424,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584785353
    },
    {
        "content": "<p>Besides that, if <code>G</code> is a <code>group</code>, then <code>additive G</code> is an <code>add_group</code>. (The only thing this does is switch notation.)<br>\nAnalogously <code>multiplicative A</code> turns an additive group into a multiplicative one.</p>",
        "id": 191338432,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584785398
    },
    {
        "content": "<p>Together, this gives a system that's quite flexible, and has nice notation.</p>",
        "id": 191338476,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584785412
    },
    {
        "content": "<p>The following code doesn't compile because I haven't defined a relation: the type is not X -&gt; X -&gt; Prop because the type of <code>is_isomorphic</code> here is <code>linear_representation _ _ V1 -&gt; linear_representation _ _ V2 -&gt; Prop</code>. I could solve this by splitting the definition into two: <code>linear_representation_over_a_specific_vector_space</code> (name TBD), and convert <code>linear_representation</code> to being instead a dependent pair of (vector space, representation on that vector space), but this seems a little sad. Can anyone see anything nicer I could do?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">field</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">finite_dimensional</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">module</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">linear_map</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">linear_representation</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">:=</span>\n  <span class=\"n\">monoid_hom</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">general_linear_group</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- is_intertwining_map is the same as &quot;being a G-homomorphism&quot;</span>\n<span class=\"n\">def</span> <span class=\"n\">is_intertwining_map</span>\n  <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">V1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V1</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V1</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">V2</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V2</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V2</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">p1</span> <span class=\"o\">:</span> <span class=\"n\">linear_representation</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">V1</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">p2</span> <span class=\"o\">:</span> <span class=\"n\">linear_representation</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">V2</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">linear_map</span> <span class=\"n\">F</span> <span class=\"n\">V1</span> <span class=\"n\">V2</span><span class=\"o\">)</span>\n  <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">V1</span><span class=\"o\">),</span>\n    <span class=\"n\">linear_map</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">φ</span> <span class=\"o\">(</span><span class=\"n\">units</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">(</span><span class=\"n\">monoid_hom</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">p1</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">units</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">(</span><span class=\"n\">monoid_hom</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">p2</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">linear_map</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">φ</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_isomorphism</span>\n  <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">V1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V1</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V1</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">V2</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V2</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V2</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">p1</span> <span class=\"o\">:</span> <span class=\"n\">linear_representation</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">V1</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">p2</span> <span class=\"o\">:</span> <span class=\"n\">linear_representation</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">V2</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">linear_map</span> <span class=\"n\">F</span> <span class=\"n\">V1</span> <span class=\"n\">V2</span><span class=\"o\">)</span>\n  <span class=\"o\">:=</span>\n  <span class=\"n\">is_intertwining_map</span> <span class=\"n\">F</span> <span class=\"n\">p1</span> <span class=\"n\">p2</span> <span class=\"n\">φ</span> <span class=\"bp\">∧</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">bijective</span> <span class=\"o\">(</span><span class=\"n\">linear_map</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">φ</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_isomorphic</span>\n  <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">V1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V1</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V1</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">V2</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V2</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V2</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">p1</span> <span class=\"o\">:</span> <span class=\"n\">linear_representation</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">V1</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">p2</span> <span class=\"o\">:</span> <span class=\"n\">linear_representation</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">V2</span><span class=\"o\">)</span>\n  <span class=\"o\">:=</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">φ</span><span class=\"o\">,</span> <span class=\"n\">is_isomorphism</span> <span class=\"n\">F</span> <span class=\"n\">p1</span> <span class=\"n\">p2</span> <span class=\"n\">φ</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">isomorphism_rel_is_reflexive</span>\n  <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">V1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V1</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V1</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">V2</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V2</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V2</span><span class=\"o\">]</span>\n  <span class=\"o\">:</span> <span class=\"n\">reflexive</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">is_isomorphic</span> <span class=\"n\">F</span> <span class=\"bp\">_</span> <span class=\"n\">G</span> <span class=\"bp\">_</span> <span class=\"n\">V1</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">V2</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"c1\">-- doesn&#39;t compile</span>\n  <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 191340607,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584788946
    },
    {
        "content": "<p>I restructured in that way and it does work, of course, although it's a bit gross</p>",
        "id": 191342638,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584792386
    },
    {
        "content": "<p>An example of an actual <code>group</code> in mathlib would be <code>units</code>. For example <code>units (zmod 42)</code> is an interesting, nontrivial and computable finite multiplicative group</p>",
        "id": 191345620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584797188
    },
    {
        "content": "<p>The way this would be usually done in mathlib is that first you define a bunded <code>intertwining_map</code>, and then you would define the identity intertwining map, and a composition of intertwining maps, and you would define an isomorphism to be an intertwining map with an inverse. I don't think I understand your question about reflexive. Surely the assertion that the relation is reflexive is that V1 is isomorphic to V1, I don't see the role of V2.</p>",
        "id": 191345780,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584797514
    },
    {
        "content": "<p>But here you don't really want to use equivalence relations anyway, because they lose track of data. A mathematician would say \"if V1 is isomorphic to V2 then V2 is isomorphic to V1\" but this is less than what they mean. They <em>mean</em> \"if you have an isomorphism V1 -&gt; V2 then I can give you an isomorphism V2 -&gt; V1, namely its inverse\", and you would to well to capture this stronger statement.</p>",
        "id": 191345843,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584797604
    },
    {
        "content": "<p>You should look at how it is set up for modules. Because a group representation is just a module for the group ring, you are just re-doing that theory anyway. <a href=\"https://github.com/leanprover-community/mathlib/blob/dd85db0cc7b5d0849f6f75535e109fa3d6f7ac56/src/algebra/module.lean#L165\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/dd85db0cc7b5d0849f6f75535e109fa3d6f7ac56/src/algebra/module.lean#L165\">Here are module homomorphisms in mathlib</a>. Instead of making the predicate on a homomorphism of additive abelian groups, they bundle everything up in a structure and then define <code>id</code> and <code>comp</code> -- these are the fundamental things you need to make everything into a category.</p>",
        "id": 191346036,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584797908
    },
    {
        "content": "<p>The reason that you don't see statements such as isomorphism being reflexive, symmetric etc is that everything like that is already done in some huge generality in <a href=\"https://github.com/leanprover-community/mathlib/blob/dd85db0cc7b5d0849f6f75535e109fa3d6f7ac56/src/data/equiv/mul_add.lean#L73\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/dd85db0cc7b5d0849f6f75535e109fa3d6f7ac56/src/data/equiv/mul_add.lean#L73\">files like this</a>. This is a definition, not a theorem, it's the construction of the identity map and the proof that it preserves multiplication on any type with a multiplication. This is some abstract theory of \"mul-equiv\"s, which means bijections between two sets X and Y with multiplication, such that the bijection preserves the multiplication. Things like that get set up in huge generality and then the idea is that it will apply to your situation if you need it.</p>",
        "id": 191346259,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584798252
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191345843\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191345843\">said</a>:</p>\n<blockquote>\n<p>But here you don't really want to use equivalence relations anyway, because they lose track of data. A mathematician would say \"if V1 is isomorphic to V2 then V2 is isomorphic to V1\" but this is less than what they mean. They <em>mean</em> \"if you have an isomorphism V1 -&gt; V2 then I can give you an isomorphism V2 -&gt; V1, namely its inverse\", and you would to well to capture this stronger statement.</p>\n</blockquote>\n<p>Ah, again this is a habit imported from Agda, where to say that A is iso to B is to exhibit an isomorphism</p>",
        "id": 191346602,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584798721
    },
    {
        "content": "<p>There is an <em>awful</em> lot to unlearn here :P</p>",
        "id": 191346649,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584798754
    },
    {
        "content": "<p>In Lean, you say that A and B are <code>equiv</code>, which is also an explicit iso.</p>",
        "id": 191346687,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584798828
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"117987\">@Patrick Stevens</span> your definition of <code>is_isomorphism</code> is a <code>Prop</code>, so when you prove  the isomorphism you'll have to exhibit the map, but the moment the proof has compiled the map will be forgotten, because Lean's Prop is...umm..I think it's called impredicative.</p>",
        "id": 191347345,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584799704
    },
    {
        "content": "<p>Fair enough - I just need to get much more clear about what is constructive and what isn't</p>",
        "id": 191347512,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584799957
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191347345\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191347345\">said</a>:</p>\n<blockquote>\n<p>because Lean's Prop is...umm..I think it's called impredicative.</p>\n</blockquote>\n<p>No, that's not what impredicative means. <a href=\"https://en.wikipedia.org/wiki/Impredicativity\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Impredicativity\">https://en.wikipedia.org/wiki/Impredicativity</a></p>",
        "id": 191348417,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584801215
    },
    {
        "content": "<p>well, Lean's prop is forgetful</p>",
        "id": 191348469,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801246
    },
    {
        "content": "<p>that would be proof irrelevance</p>",
        "id": 191348483,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584801272
    },
    {
        "content": "<blockquote>\n<p>There is no generally accepted precise definition of what it means to be predicative or impredicative</p>\n</blockquote>",
        "id": 191348486,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801278
    },
    {
        "content": "<p>that's the last time I'm using that word. It's as bad as canonical.</p>",
        "id": 191348489,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801289
    },
    {
        "content": "<p>we can say that Prop is a proof irrelevant universe</p>",
        "id": 191348491,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584801293
    },
    {
        "content": "<p>I don't think I agree with the wikipedia statement. The meaning of impredicativity is context dependent but precise in most places where it appears</p>",
        "id": 191348559,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584801383
    },
    {
        "content": "<p>Almost all the uses you are likely to have seen are using the same meaning. Alternate meanings are mostly historical and philosophical uses like avoiding self reference in the liar's paradox</p>",
        "id": 191348594,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584801462
    },
    {
        "content": "<p>And this meaning is somehow orthogonal to proof irrelevance, right?</p>",
        "id": 191348668,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584801554
    },
    {
        "content": "<p>they are related by a paradox that makes one of the possible permutations inconsistent</p>",
        "id": 191348749,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584801655
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"117987\">@Patrick Stevens</span> , could you have a look at <a href=\"https://github.com/leanprover-community/mathlib/issues/2121\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/issues/2121\">#2121</a>, as a \"rather bundled\" suggestion for the basics of representation theory?</p>",
        "id": 191361408,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584817848
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191345620\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191345620\">said</a>:</p>\n<blockquote>\n<p>An example of an actual <code>group</code> in mathlib would be <code>units</code>. For example <code>units (zmod 42)</code> is an interesting, nontrivial and computable finite multiplicative group</p>\n</blockquote>\n<p>You can also do <code>units</code> of a general linear group to get some fun non-abelian computable groups.</p>",
        "id": 191375384,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1584842895
    },
    {
        "content": "<p>I'm planning to do some representation theory with <span class=\"user-mention\" data-user-id=\"201575\">@Michael R Douglas</span>. Do you think that is helpful, or are we then stepping on someone's toes? (<span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> and <span class=\"user-mention\" data-user-id=\"117987\">@Patrick Stevens</span> might be working on the same or similar stuff)?</p>",
        "id": 193803142,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1586802149
    },
    {
        "content": "<p>The basic definitions will be the same as for group cohomology. <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> and some of his students have done a bunch there.</p>",
        "id": 193803299,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1586802271
    },
    {
        "content": "<p>The reason this never gets done is the usual (see graphs, or Cauchy's integral formula, or ...): people haven't yet decided on what the definition should be.</p>",
        "id": 193806239,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586803873
    },
    {
        "content": "<p>Should one just define a representation of a group to be, by definition, a module over the group ring? Or should one make a new class of a vector space (or more generally module -- please set it up over modules over a commutative ring rather than vector spaces over a field) equipped with an action of G?</p>",
        "id": 193806389,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586803938
    },
    {
        "content": "<p><a href=\"https://github.com/Shenyang1995/M4R/blob/66f1450f206dc05c3093bc4eaa1361309bf8633b/src/G_module/basic.lean#L10-L14\" title=\"https://github.com/Shenyang1995/M4R/blob/66f1450f206dc05c3093bc4eaa1361309bf8633b/src/G_module/basic.lean#L10-L14\">https://github.com/Shenyang1995/M4R/blob/66f1450f206dc05c3093bc4eaa1361309bf8633b/src/G_module/basic.lean#L10-L14</a> I need advice about whether this is the best idea. I don't have enough experience to know. Mario and I talked about this a week or two ago, I'll find the link. I'm not sure we came to any conclusions though, just like when we talk about what generality to define a contour integral in...</p>",
        "id": 193806654,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586804043
    },
    {
        "content": "<p>(oh, it's just earlier in this thread)</p>",
        "id": 193807039,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586804230
    },
    {
        "content": "<p>I did do a little, but got distracted trying to fix up <code>monoid_algebra</code> and its associated theorems. There's a lot still missing there.</p>",
        "id": 193840291,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1586825434
    },
    {
        "content": "<p>I think it's best to have separate notions for a group acting on something, and for a module for the group ring.</p>",
        "id": 193840322,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1586825479
    },
    {
        "content": "<p>You really need both points of view, and the ability to move between them.</p>",
        "id": 193840328,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1586825491
    },
    {
        "content": "<p>I started proving this equivalence in my <code>GroupModule_2</code> (rather experimental!) branch: <a href=\"https://github.com/leanprover-community/mathlib/blob/519a49d74154cee3d23dc45978a4a0e9e5274f37/src/group_theory/Rep.lean#L118\" title=\"https://github.com/leanprover-community/mathlib/blob/519a49d74154cee3d23dc45978a4a0e9e5274f37/src/group_theory/Rep.lean#L118\">https://github.com/leanprover-community/mathlib/blob/519a49d74154cee3d23dc45978a4a0e9e5274f37/src/group_theory/Rep.lean#L118</a></p>",
        "id": 193843542,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1586829420
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/193803142\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/193803142\">said</a>:</p>\n<blockquote>\n<p>I'm planning to do some representation theory with <span class=\"user-mention silent\" data-user-id=\"201575\">Michael R Douglas</span>. Do you think that is helpful, or are we then stepping on someone's toes? (<span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> and <span class=\"user-mention silent\" data-user-id=\"117987\">Patrick Stevens</span> might be working on the same or similar stuff)?</p>\n</blockquote>\n<p>I am certainly not devoting that much effort to it - I'm a complete Lean noob and can't really spare the time to become good at the moment!</p>",
        "id": 193854919,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1586846064
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> I think this would be a good time to experiment with the <a href=\"https://github.com/leanprover-community/mathlib/projects\" title=\"https://github.com/leanprover-community/mathlib/projects\">github projects feature</a>. There is a clear path with the basic theory: (1) definition of a representation of a group on an R-module (2) Maschke's theorem (G finite, order invertible in R) (3) Uniqueness of decomposition into irreducible factors (R a field, V fin dim), Schur's Lemma etc (4) [from now on G is finite of order invertible in the alg closed field k and V is fin dim] character of a representation (5) orthonormality of irred chars, and the fact that a rep is determined by its character (6) characters are a basis for the class functions (7) induction and restriction, Frobenius reciprocity. </p>\n<p>I think we should use projects more. People come along and say \"I am an undergrad mathematician, this all looks interesting, what can I do?\" and if we can show them 5 undergraduate-level projects they might find a place to drop in.</p>",
        "id": 193906443,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586874834
    },
    {
        "content": "<p>Representation theory is one of these areas where every few months someone pops up and asks if it's done, and with a project we can indicate its current state.</p>",
        "id": 193906697,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586874913
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  :   a little maths question :  perhaps we can take  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><mtext>Card</mtext><mo stretchy=\"false\">(</mo><mi>G</mi><msup><mo stretchy=\"false\">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">⟨</mo><msub><mi mathvariant=\"normal\">Φ</mi><mrow><mtext>Card</mtext><mo stretchy=\"false\">(</mo><mi>G</mi><mo stretchy=\"false\">)</mo></mrow></msub><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\"> R[\\text{Card}(G)^{-1}] [X ] / \\langle \\Phi_{\\text{Card}(G)} (X) \\rangle  </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1693079999999998em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord text\"><span class=\"mord\">Card</span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">G</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span><span class=\"mord\">/</span><span class=\"mopen\">⟨</span><span class=\"mord\"><span class=\"mord\">Φ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord text mtight\"><span class=\"mord mtight\">Card</span></span><span class=\"mopen mtight\">(</span><span class=\"mord mathdefault mtight\">G</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mclose\">⟩</span></span></span></span> as  \" algebraic closed field \" , with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Φ</mi></mrow><annotation encoding=\"application/x-tex\"> \\Phi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Φ</span></span></span></span> the cyclotomic polynomial,    <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span></p>",
        "id": 193913534,
        "sender_full_name": "orlando",
        "timestamp": 1586877611
    },
    {
        "content": "<p>Maybe :-)</p>",
        "id": 193913570,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586877630
    },
    {
        "content": "<p>But maybe you can only prove that after you have set up the theory? :-/</p>",
        "id": 193913618,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586877655
    },
    {
        "content": "<p>That is a nice overview Kevin. It has been too long since I studied representation theory myself to remember the order to build up the theory, but I made a project by putting everything you said on a card.</p>",
        "id": 193970006,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1586907964
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> ! I'd like to contribute to this if it's convenient: it seems like someone's already started defining a representation but happy to do Maschke's theorem, or character theory/class functions etc, so should I wait until the file with the definition has been uploaded to start writing code?</p>",
        "id": 194247617,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1586999325
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"235423\">Ashwin Iyengar</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/194247617\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/194247617\">said</a>:</p>\n<blockquote>\n<p>Hi <span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> ! I'd like to contribute to this if it's convenient: it seems like someone's already started defining a representation but happy to do Maschke's theorem, or character theory/class functions etc, so should I wait until the file with the definition has been uploaded to start writing code?</p>\n</blockquote>\n<p>On the other hand, if I'm treading on your toes let me know and I'll find something else to work on!</p>",
        "id": 194247936,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1586999691
    },
    {
        "content": "<p>Ashvni wants to start working on local fields :-)</p>",
        "id": 194248020,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586999777
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"235423\">@Ashwin Iyengar</span>: yes, you can join. I made a very small start here: <a href=\"https://github.com/fpvandoorn/group-representations\" title=\"https://github.com/fpvandoorn/group-representations\">https://github.com/fpvandoorn/group-representations</a><br>\nWhat is your Github username, then I can give you write access.</p>",
        "id": 194261377,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1587017952
    },
    {
        "content": "<p>It seems that there are 4 interesting definitions:</p>\n<ol>\n<li><code>G →* general_linear_group R M</code></li>\n<li><code>group_module (G : Type*) [group G] (M : Type*) [add_comm_group M] extends has_scalar G M :=</code></li>\n<li><code>linear_group_module</code> like above, but with modules over <code>R</code></li>\n<li><code>module (monoid_algebra R G) M</code></li>\n</ol>\n<p>Approaches (1), (3), and (4) lead to equivalent categories, and (2) is the specialization <code>R = int</code>.<br>\nThe benefit of (3) is that it gives nice notation. It is so to speak the least bundled version.</p>",
        "id": 194265099,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587021710
    },
    {
        "content": "<p>Shouldn't (4) give the same notation  as (3) if you define something like this?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">R</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span>\n<span class=\"kn\">instance</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">R</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"n\">G</span> <span class=\"n\">M</span>\n</pre></div>",
        "id": 194268608,
        "sender_full_name": "David Wärn",
        "timestamp": 1587024102
    },
    {
        "content": "<p>Yes, I think that could work.</p>",
        "id": 194269017,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587024333
    },
    {
        "content": "<p>Ooh, maybe not... because <code>R</code> does not occur in <code>has_scalar G M</code>. So it will apply \"too often\".</p>",
        "id": 194269117,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587024373
    },
    {
        "content": "<p>Great <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> my github name is ashwiniyengar</p>",
        "id": 194273758,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1587027105
    },
    {
        "content": "<p>Oh, I've also got something. I just made a PR as <a href=\"https://github.com/leanprover-community/mathlib/issues/2431\" title=\"https://github.com/leanprover-community/mathlib/issues/2431\">#2431</a> to make it public.</p>",
        "id": 194281257,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587031444
    },
    {
        "content": "<p>I went the route of extending <code>distrib_mul_action</code>, so it gives the <code>•</code> notation (but may suffer from the problem Johan mentions; so far I haven't seen it).</p>",
        "id": 194281323,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587031490
    },
    {
        "content": "<p>My PR proves the equivalence between</p>\n<ol>\n<li><code>representation k G M</code></li>\n<li><code>G →* (M →ₗ[k] M)</code></li>\n<li><code>module (monoid_algebra k G) M</code></li>\n</ol>",
        "id": 194281363,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587031516
    },
    {
        "content": "<p>but is stacked on top of <a href=\"https://github.com/leanprover-community/mathlib/issues/2366\" title=\"https://github.com/leanprover-community/mathlib/issues/2366\">#2366</a> and <a href=\"https://github.com/leanprover-community/mathlib/issues/2417\" title=\"https://github.com/leanprover-community/mathlib/issues/2417\">#2417</a>, neither of which compile at the moment ... :-)</p>",
        "id": 194281405,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587031544
    },
    {
        "content": "<p>(I think it's minor for both.)</p>",
        "id": 194281418,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587031549
    },
    {
        "content": "<p>(hopefully all three compile now)</p>",
        "id": 194281983,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587031897
    },
    {
        "content": "<p>Yes, I'm afraid we tried enabling the <code>\\bu</code> notation before with little representation theory projects, but ran into trouble...</p>",
        "id": 194282780,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587032418
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/194268608\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/194268608\">said</a>:</p>\n<blockquote>\n<p>Shouldn't (4) give the same notation  as (3) if you define something like this?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">R</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span>\n<span class=\"kn\">instance</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">R</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"n\">G</span> <span class=\"n\">M</span>\n</pre></div>\n\n\n</blockquote>\n<p>These two instances are likely causing looping behavior. For the second one, whenever Lean needs to find <em>any</em> <code>has_scalar A B</code> instance, is now has to look for instances <code>module (monoid_algebra ?M A) B</code>, which might cause looping because of the metavariable.</p>\n<p>Option (1) and (3) both seem good. The question is really which notation we want to use: <code>ρ g x</code> or <code>g • x</code>. <br>\nThe latter notation is nicer, but also more ambiguous. I think it makes it hard to state results about two representations of the same group in the same vector space. I think those results occur quite frequently in representation theory (right?). Or maybe that's the wrong way of stating it in Lean; maybe the Lean way is to have the representations on different (but isomorphic?) vector spaces.</p>",
        "id": 194338624,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1587057750
    },
    {
        "content": "<p>I guess that for any continuous group homomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>→</mo><msup><mi mathvariant=\"double-struck\">C</mi><mo>×</mo></msup></mrow><annotation encoding=\"application/x-tex\">G\\to\\mathbb{C}^\\times</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">C</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span></span></span></span> one gets a character which traditionally would commonly be realised as a action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span> on the vector space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span></span></span></span></span>.</p>",
        "id": 194340580,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587058647
    },
    {
        "content": "<p>This whole business is going to be pretty interesting to formalise actually. One would ideally get as far as the characters of a finite group (over an alg closed field of char 0, say) as being a basis for the class functions, but I always felt like I was treating a character as \"the same as\" a representation, whereas given a character one is going to have to make some kind of choice for the representation when actually proving things about it, and perhaps if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>χ</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">\\chi(1)=n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">χ</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> the natural choice for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>k</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">k^n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span></span></span></span>? Although then there's no natural choice for the action <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>…</mo></mrow><annotation encoding=\"application/x-tex\">\\ldots</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.12em;vertical-align:0em;\"></span><span class=\"minner\">…</span></span></span></span></p>",
        "id": 194340907,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587058792
    },
    {
        "content": "<p>Characters are the decategorification of representations!</p>",
        "id": 194348267,
        "sender_full_name": "David Wärn",
        "timestamp": 1587062005
    },
    {
        "content": "<p>My standard contribution: Feit-Thompson uses representation theory so, if you are serious about formalizing it, you should at least have a look at mathcomp. Or ask <span class=\"user-mention\" data-user-id=\"110172\">@Assia Mahboubi</span> and <span class=\"user-mention\" data-user-id=\"110193\">@Cyril Cohen</span></p>",
        "id": 194353664,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1587064428
    },
    {
        "content": "<p>Hello, i do i little exercice with the file of <a href=\"https://github.com/fpvandoorn/group-representations/blob/master/src/group_theory/representation/basic.lean\" title=\"https://github.com/fpvandoorn/group-representations/blob/master/src/group_theory/representation/basic.lean\">here</a> of <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>  !  I just try to define a sub representation when a subspace is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding=\"application/x-tex\">\\rho</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">ρ</span></span></span></span>-stable !  <a href=\"https://github.com/Or7ando/lean/blob/master/.github/workflows/group_representation.lean\" title=\"https://github.com/Or7ando/lean/blob/master/.github/workflows/group_representation.lean\">here</a></p>",
        "id": 194520334,
        "sender_full_name": "orlando",
        "timestamp": 1587174996
    },
    {
        "content": "<p>Hi @orlando, it's a bit hard to comment on the whole thing at once, as many things are going on in your file.</p>",
        "id": 194522941,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587179391
    },
    {
        "content": "<p>I've also been thinking about a different approach to defining representations (and in a branch I have the outline of a proof of Maschke's theorem).</p>",
        "id": 194522998,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587179419
    },
    {
        "content": "<p>It's in the PR <a href=\"https://github.com/leanprover-community/mathlib/issues/2431\" title=\"https://github.com/leanprover-community/mathlib/issues/2431\">#2431</a>, under the branch name <code>representation</code>.</p>",
        "id": 194523013,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587179453
    },
    {
        "content": "<p>Your file has a lot of preparatory lemmas, whose purpose I'm pretty unclear on.</p>",
        "id": 194523034,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587179488
    },
    {
        "content": "<p>Hi Scott. </p>\n<p>I try to explain at the outset the definition refers to groups of units. And I would  do things by looking at linear endomophisms.  If i understand, you take endomorphism  definition ! </p>\n<p>I use the notation \\ oo for composition (and I realized that there is a notion * so <code>\\ oo</code>  is not useful I think). The preparatory lemma a just some formula to simplify a little. (and for fun <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span>). </p>\n<p>ohh ,it's cool if you have outline of Maschke Theorem !</p>\n<p>Ps : I just make : </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">new_groupe_representation</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span> <span class=\"n\">group_representation</span> <span class=\"n\">G</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span>  <span class=\"bp\">→</span>  <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">→</span><span class=\"err\">ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">ρ</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">has_coe_to</span> <span class=\"n\">ρ</span><span class=\"o\">,</span> <span class=\"n\">rmap_one</span> <span class=\"n\">ρ</span><span class=\"o\">,</span><span class=\"n\">rmap_mul</span> <span class=\"n\">ρ</span><span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p>So i thinck that glue the two definitions. But perhaps there is a quicker way to do., using <code> general_linear_equiv :  general_linear_group R M ≃* (M ≃ₗ[R] M) </code> in the  file linear algebra basic <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 194534442,
        "sender_full_name": "orlando",
        "timestamp": 1587200630
    },
    {
        "content": "<p>Hello <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>  I redo all my stuff. </p>\n<p>I have problem with conversion <code>↑ ⇑  erw  </code> etc  i think it's more clear but not perfect and it's a good project for me to learn !  I have show just the Schur lemma from Serre book and construct some stuff.  Next step use character hum hum ! </p>\n<p>If you are some comment for a better programming ? <br>\n<a href=\"https://github.com/Or7ando/group_representation\" title=\"https://github.com/Or7ando/group_representation\">here</a></p>",
        "id": 195032307,
        "sender_full_name": "orlando",
        "timestamp": 1587631425
    },
    {
        "content": "<p>The computer scientists will tell you to change <code>[group G]</code> to <code>[monoid G]</code> in the <em>definition</em>, because you do not use inverses :-)</p>",
        "id": 195041768,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587637425
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"270476\">@orlando</span> did you see <a href=\"https://github.com/leanprover-community/mathlib/projects/4\" title=\"https://github.com/leanprover-community/mathlib/projects/4\">the representation theory project</a>?</p>",
        "id": 195042867,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587638128
    },
    {
        "content": "<p>Yes Kevin, i start with the first file of <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>  but i change the definition because (conversion big problem) ! </p>\n<p>I'm happy cause i understand i little more <code>rfl </code> <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span></p>",
        "id": 195044142,
        "sender_full_name": "orlando",
        "timestamp": 1587639176
    },
    {
        "content": "<p>With this project, I feel like the hardest part is choosing the correct initial definition.</p>",
        "id": 195044240,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587639264
    },
    {
        "content": "<p>ooh, I didn't know we have a kanban board (or whatever the kids call it these days)</p>",
        "id": 195044503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587639478
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>  <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>   </p>\n<p>I don't know if you continue about representation. But a question :  do you have a version of the decomposition of representation in irreducible representation ? I have the  orthogonality of character (i have just a little problem with a formula  <code> trace rho g \\-1 = complex.conj trace rho g </code> i don't know if it's decisive for the moment). </p>\n<p>I think just a little about the decomposition for the moment ! So if you have a version tell me <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 197530309,
        "sender_full_name": "orlando",
        "timestamp": 1589449432
    },
    {
        "content": "<p>Wow the proof I know of that trace fact uses a lot</p>",
        "id": 197544673,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589459121
    },
    {
        "content": "<p>g is in a finite group so the order is finite (else it's false)</p>",
        "id": 197544757,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589459168
    },
    {
        "content": "<p>There is something called eigenvalues of a matrix</p>",
        "id": 197544797,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589459199
    },
    {
        "content": "<p>Each eigenvalue is a root of the min poly</p>",
        "id": 197544813,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589459215
    },
    {
        "content": "<p>Each eigenvalue is a root of unity</p>",
        "id": 197544851,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589459238
    },
    {
        "content": "<p>Wait</p>",
        "id": 197544869,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589459248
    },
    {
        "content": "<p>Perhaps what I'm missing is the theory of unitary matrices</p>",
        "id": 197544888,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589459264
    },
    {
        "content": "<p>Trace of inverse = trace of conjugate = conjugate of trace by <code>transport</code></p>",
        "id": 197544993,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589459319
    },
    {
        "content": "<p>So maybe prove that the image is in the unitary matrices wrt some R-structure made using the averaged inner form trick?</p>",
        "id": 197545065,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589459384
    },
    {
        "content": "<p>hum the problem is what is easy to make in <code>lean </code> for the moment ! Perhaps the root of unity it's difficult for the moment, ???  Perhaps with unitary representation !  </p>\n<p>Yes it's the average trick !  All the basic theory is the average trick  <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 197545968,
        "sender_full_name": "orlando",
        "timestamp": 1589459933
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"270476\">@orlando</span> You really need to start writing PRs <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 197563533,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589466763
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  I'm really noob with git hub, i just understand <code> git add , git commit, git push </code> <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>  so  first i finish with <code> math / lean </code> and next i try too understand   <code> PR's story </code> <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 197583321,
        "sender_full_name": "orlando",
        "timestamp": 1589474570
    },
    {
        "content": "<p>Those three commands are enough (-;</p>",
        "id": 197584761,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589475224
    },
    {
        "content": "<p>Ooh, maybe add <code>git checkout</code> for switching branches.</p>",
        "id": 197584883,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589475253
    },
    {
        "content": "<p>I really fear that otherwise you'll end up with 5000 lines of code, and it will just sit in some repo, and never get PR'd</p>",
        "id": 197584976,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589475298
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"270476\">@orlando</span> We're definitely not there yet. We're still working on Maschke's Theorem, but we're making good progress.</p>",
        "id": 197607720,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1589485418
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Can you elaborate a bit on what you mean by Maschke's theorem for an R-module (instead of a vector space)? Given a submodule of a module, there doesn't necessarily even have to exist a complementary submodule, so if Maschke's theorem guarantees an invariant complementary submodule, then it is false. I think we can prove that <em>if</em> a submodule has a complementary submodule, it also has an invariant one.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">theorem</span> <span class=\"n\">maschke2</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">group_representation</span> <span class=\"n\">G</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"n\">N&#39;</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">complementary</span> <span class=\"n\">N</span> <span class=\"n\">N&#39;</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hN</span> <span class=\"o\">:</span> <span class=\"n\">invariant_subspace</span> <span class=\"n\">ρ</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hG</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">N&#39;</span><span class=\"o\">,</span> <span class=\"n\">invariant_subspace</span> <span class=\"n\">ρ</span> <span class=\"n\">N&#39;</span> <span class=\"bp\">∧</span> <span class=\"n\">complementary</span> <span class=\"n\">N</span> <span class=\"n\">N&#39;</span>\n</code></pre></div>\n\n\n<p><a href=\"https://github.com/fpvandoorn/group-representations/blob/da8dfe6c436ec15abeefb73040e31f19d197e11b/src/group_theory/representation/basic.lean#L501\">https://github.com/fpvandoorn/group-representations/blob/da8dfe6c436ec15abeefb73040e31f19d197e11b/src/group_theory/representation/basic.lean#L501</a><br>\nIs this the statement you had in mind?</p>\n<p>Also, is there any source that does representation theory in modules (not in vector spaces)? We're kind of trying to figure out what holds for R-modules as we go, and sometimes have to reformulate results to only hold for vector spaces in the middle of a proof.</p>",
        "id": 197608701,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1589485876
    },
    {
        "content": "<p>Yes, it seems to me that you're right, I think the theorems are the following:<br>\n1) If G is finite and 1/|G| is in R, and if there exists a complementary submodule (possibly not G-invariant) to your G-invariant one, then there exists a G-invariant complementary submodule.<br>\n2) If R is a field then there always exists a complementary submodule</p>",
        "id": 197610423,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589486729
    },
    {
        "content": "<p>The FLT proof contains a whole bunch of representation theory to arbitrary rings, but it doesn't need anything like Maschke, it needs representability theorems. Here is an example of a theorem that it uses (and I'm sure <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> knows about this stuff too):</p>",
        "id": 197610582,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589486805
    },
    {
        "content": "<p>(oh, dinner time)</p>",
        "id": 197610684,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589486849
    },
    {
        "content": "<p>(universal deformation rings)</p>",
        "id": 197610709,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589486862
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/197610684\">said</a>:</p>\n<blockquote>\n<p>(oh, dinner time)</p>\n</blockquote>\n<p>Yup, I know that one.</p>",
        "id": 197610781,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589486883
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>  :</p>\n<p>I'm ok with you're theorem you have to put the hypothesis <code> h </code> for module. But perhaps in a first time we have to use field, for ring i think there is very complicated thing !</p>",
        "id": 197611126,
        "sender_full_name": "orlando",
        "timestamp": 1589487054
    },
    {
        "content": "<p>Ah good, we have already proven (2), using Zorn's Lemma. <br>\nThen we're going to finish this version of Maschke's Theorem.</p>",
        "id": 197620046,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1589491413
    },
    {
        "content": "<p>Hmm, I'm surprised that I couldn't find any kind of representation theory in Bourbaki with my google searches.</p>",
        "id": 197621747,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589492337
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>  i think it's in this volume :<a href=\"http://www.bourbaki.ens.fr/algebre8-tdm.pdf\">here</a></p>",
        "id": 197623440,
        "sender_full_name": "orlando",
        "timestamp": 1589493352
    },
    {
        "content": "<p>oh, yes! I only found Algebra I (chapters 1-3) and Algebra II (chapters 4-7)</p>",
        "id": 197623550,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589493420
    },
    {
        "content": "<p>i don't have the book <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></p>",
        "id": 197623552,
        "sender_full_name": "orlando",
        "timestamp": 1589493420
    },
    {
        "content": "<p>But there is 400 page before : <code> representation lineaire sur les nombres complexes </code>  i have to learn and read i little <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 197623689,
        "sender_full_name": "orlando",
        "timestamp": 1589493502
    },
    {
        "content": "<p>I see, so this entire book of nearly 500 pages is \"chapter 8\"</p>",
        "id": 197624191,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589493854
    },
    {
        "content": "<p>I found the page on Maschke's theorem on Google Books but I don't know what the standing assumptions on \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span></span></span></span>\" are.</p>",
        "id": 197625144,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589494478
    },
    {
        "content": "<p>I found one place that says \"if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span></span></span></span> is a field [division algebra]\" and others \"a commutative field\" though, so I assume the standing assumption is that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span></span></span></span> is just a ring...</p>",
        "id": 197625313,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589494577
    },
    {
        "content": "<p>Oh thx i don't use google book, it's good !</p>",
        "id": 197626432,
        "sender_full_name": "orlando",
        "timestamp": 1589495366
    },
    {
        "content": "<p>I will try to get back to this soon, but I have a proof of Maschke's theorem in <code>Maschke</code>.</p>",
        "id": 197639091,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1589506129
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span></p>",
        "id": 197644444,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589512858
    },
    {
        "content": "<p>I made <a href=\"https://github.com/leanprover-community/mathlib/issues/2762\">#2762</a>, with my proof of Maschke's theorem. It's still a bit messy, but all the sorries are gone!</p>",
        "id": 198212467,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1589987495
    },
    {
        "content": "<p>The thing that it is missing still is the fact that any <code>k</code>-linear inclusion has a retraction, but this is hopefully done somewhere in the existing linear algebra library, and I can plug it in. For now the final statement includes an extra hypothesis for this fact.</p>",
        "id": 198212743,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1589987584
    },
    {
        "content": "<p>I think that fact isn't done yet, but it should be trivial once Yury's PRs on complementary submodules are merged.</p>",
        "id": 198220677,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589990848
    },
    {
        "content": "<p>Great work with Maschke's theorem. It's one of those things that every self-respecting library ought to have (-;</p>",
        "id": 198220716,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589990878
    },
    {
        "content": "<p>Scott doesn't need continuous version, and <code>projection</code> PR is already merged.</p>",
        "id": 198220817,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589990915
    },
    {
        "content": "<p>What exactly do you need?</p>",
        "id": 198220911,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589990963
    },
    {
        "content": "<p>E.g., we have <code>exists_left_inverse_of_injective</code> and <code>exists_right_inverse_of_surjective</code> in <code>linear_algebra/basis.lean</code>.</p>",
        "id": 198220974,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589991000
    },
    {
        "content": "<p>Hello, That good <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> , i  have also a version of Maschke theorem.  </p>\n<p>But for me the big step is really to make the application over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span></span></span></span></span> ! </p>\n<p>For example, the decomposition of a representation in irreducible representation.</p>\n<p>I think the decomposition in irrducible part is ok for field (not algebraically closed).</p>",
        "id": 198297535,
        "sender_full_name": "orlando",
        "timestamp": 1590049880
    },
    {
        "content": "<p>Could we move this thread to the math stream?</p>",
        "id": 198307212,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1590057748
    },
    {
        "content": "<p>This topic was moved by <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> to <a class=\"stream-topic\" data-stream-id=\"116395\" href=\"/#narrow/stream/116395-maths/topic/Representation.20Theory\">#maths &gt; Representation Theory</a></p>",
        "id": 198341356,
        "sender_full_name": "Notification Bot",
        "timestamp": 1590077920
    }
]
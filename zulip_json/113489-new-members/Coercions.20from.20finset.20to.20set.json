[
    {
        "content": "<p>I'm trying to prove that the complement of each element of the set-of-sets <code>F</code>is within <code>F</code>. (This is for learning so that I can work up to more complicated proofs similar to it)<br>\nThe confusion I'm having is on how to handle coercions, I don't feel like I have a good handle on manipulating those.<br>\nIt seems like being able to tell Lean that <code>(↑{val := {0}, nodup := _})ᶜ ∈ F</code> should be turned into a <code>{(0 : fin 3)}ᶜ ∈ F</code> would simplify proving.<br>\n(Other comments on whether this is a bad way to be proving this would also be appreciated)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Minor question: is there a nicer way of writing something like this where it needs to use</span>\n<span class=\"c1\">-- some constant?</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">E</span> <span class=\"bp\">∈</span> <span class=\"o\">({</span><span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">fin.of_nat'</span> <span class=\"mi\">0</span><span class=\"o\">},</span> <span class=\"o\">{</span><span class=\"n\">fin.of_nat'</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">fin.of_nat'</span> <span class=\"mi\">2</span><span class=\"o\">},</span> <span class=\"n\">set.univ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">))),</span>\n    <span class=\"n\">E</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">∈</span> <span class=\"o\">({</span><span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">fin.of_nat'</span> <span class=\"mi\">0</span><span class=\"o\">},</span> <span class=\"o\">{</span><span class=\"n\">fin.of_nat'</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">fin.of_nat'</span> <span class=\"mi\">2</span><span class=\"o\">},</span> <span class=\"n\">set.univ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)))</span>  <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">fin.of_nat'</span> <span class=\"mi\">0</span><span class=\"o\">},</span> <span class=\"o\">{</span><span class=\"n\">fin.of_nat'</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">fin.of_nat'</span> <span class=\"mi\">2</span><span class=\"o\">},</span> <span class=\"n\">set.univ</span><span class=\"o\">},</span>\n  <span class=\"c1\">-- I have proofs for both of the below, but cutting them out for a smaller example</span>\n  <span class=\"k\">let</span> <span class=\"n\">compl0</span> <span class=\"o\">:</span> <span class=\"o\">({</span><span class=\"n\">fin.of_nat'</span> <span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">))</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">=</span> <span class=\"o\">({</span><span class=\"n\">fin.of_nat'</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">fin.of_nat'</span> <span class=\"mi\">2</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)),</span>  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">compl0_in</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">fin.of_nat'</span> <span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n\n  <span class=\"n\">intros</span> <span class=\"n\">E</span> <span class=\"n\">Einp</span><span class=\"o\">,</span>\n  <span class=\"n\">fin_cases</span> <span class=\"n\">E</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- `∅ᶜ ∈ F`</span>\n    <span class=\"c1\">-- This case is easy since it seems to turn it into a set automatically</span>\n    <span class=\"o\">{</span> <span class=\"gr\">sorry</span> <span class=\"o\">},</span>\n    <span class=\"c1\">-- `(↑{val := {0}, nodup := _})ᶜ ∈ F`</span>\n    <span class=\"o\">{</span>\n      <span class=\"n\">convert</span> <span class=\"n\">compl0_in</span><span class=\"o\">,</span>\n      <span class=\"c1\">-- simp? is how I found this coe_eq_singleton theorem, but it would have been nicer to just have it be a set in the first place</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">finset.coe_eq_singleton</span><span class=\"o\">],</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n    <span class=\"c1\">-- `(↑{val := {1}, nodup := _})ᶜ ∈ F`</span>\n    <span class=\"o\">{</span>\n      <span class=\"n\">exfalso</span><span class=\"o\">,</span>\n      <span class=\"c1\">-- use Einp to prove false, since `{1} ∉ F`</span>\n      <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n    <span class=\"c1\">-- todo, the rest of them</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 311432622,
        "sender_full_name": "MinusGix",
        "timestamp": 1669052195
    },
    {
        "content": "<p>You can write that set you have by <code>({∅, {0}, {1, 2}, set.univ} : set (set (fin 3)))</code> by the way</p>",
        "id": 311434271,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669052763
    },
    {
        "content": "<p>Regarding these <code>(↑{val := {0}, nodup := _})</code> terms, I'm not sure exactly what's happening with <code>fin_cases</code> here, but something seems like it's not working in an ideal way.</p>",
        "id": 311435109,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669053054
    },
    {
        "content": "<p>Here's how I might approach your statement:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.fin_cases</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.norm_fin</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">},</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">},</span> <span class=\"n\">set.univ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">E</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">E</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">E</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">],</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">rfl</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">ext</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">fin_cases</span> <span class=\"n\">i</span><span class=\"bp\">;</span> <span class=\"n\">norm_fin</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">ext</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">fin_cases</span> <span class=\"n\">i</span><span class=\"bp\">;</span> <span class=\"n\">norm_fin</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#rintro\">tactic#rintro</a> tactic is a way to do destructuring while doing <code>intro</code>. When you give it <code>rfl</code> then it will substitute the variable for you automatically.</p>",
        "id": 311444027,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669055932
    },
    {
        "content": "<p>Nonterminal <code>simp [F]</code> !</p>",
        "id": 311445219,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1669056376
    }
]
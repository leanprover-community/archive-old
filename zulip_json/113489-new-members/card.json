[
    {
        "content": "<p>Is there any built-in lemma that picks distinct elements of a given type such as picking three as follows? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.card</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">I</span><span class=\"o\">]</span>\n<span class=\"kn\">open</span> <span class=\"n\">fintype</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Hadamard_matrix.order_aux1</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">card</span> <span class=\"n\">I</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">card</span> <span class=\"n\">I</span> <span class=\"bp\">≠</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"bp\">∃</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span> <span class=\"bp\">∧</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">k</span> <span class=\"bp\">∧</span> <span class=\"n\">j</span> <span class=\"bp\">≠</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>My formulation might be bad btw.</p>",
        "id": 246206166,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626430784
    },
    {
        "content": "<p>I would first prove card &gt;= 3 and then dig into the definition of fintype</p>",
        "id": 246208397,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626432529
    },
    {
        "content": "<p>An easier one is perhaps</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.card</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">I</span><span class=\"o\">]</span>\n<span class=\"kn\">open</span> <span class=\"n\">fintype</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">ex2</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">card</span> <span class=\"n\">I</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"bp\">∃</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span><span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">i</span><span class=\"o\">:=</span> <span class=\"n\">classical.arbitrary</span> <span class=\"n\">I</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">I</span><span class=\"o\">,</span>\n <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 246212395,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626435740
    },
    {
        "content": "<p>A generalized one</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">ex</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">card</span> <span class=\"n\">I</span> <span class=\"bp\">≥</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">I</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">a</span> <span class=\"n\">j</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 246212716,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626435981
    },
    {
        "content": "<p>Are there any relevant or equivalent built-in lemmas to the above ones?</p>",
        "id": 246212778,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626436066
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"408694\">Alex Zhang</span> <a href=\"#narrow/stream/113489-new-members/topic/card/near/246212395\">said</a>:</p>\n<blockquote>\n<p>An easier one is perhaps</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.card</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">I</span><span class=\"o\">]</span>\n<span class=\"kn\">open</span> <span class=\"n\">fintype</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">ex2</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">card</span> <span class=\"n\">I</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"bp\">∃</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span><span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">i</span><span class=\"o\">:=</span> <span class=\"n\">classical.arbitrary</span> <span class=\"n\">I</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">I</span><span class=\"o\">,</span>\n <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I think the case where the size isn't 1 is probably quite a bit easier than the general case</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.card</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">I</span><span class=\"o\">]</span>\n<span class=\"kn\">open</span> <span class=\"n\">fintype</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">ex2</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">card</span> <span class=\"n\">I</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"bp\">∃</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span><span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">by_contra</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">push_neg</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">fintype.card</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"o\">:=</span> <span class=\"n\">classical.arbitrary</span> <span class=\"n\">I</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">I</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">finset.eq_univ_iff_forall</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">finset.mem_singleton</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">h2</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 246213320,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1626436490
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266440\">@Shing Tak Lam</span>  Do you have any idea about <code>ex3</code> and <code>ex</code>?</p>",
        "id": 246213381,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626436550
    },
    {
        "content": "<p>I will read your proof in detail after a nap.</p>",
        "id": 246213598,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626436715
    },
    {
        "content": "<p>This is quite straightforward:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.card</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">I</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">fintype</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ex1</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">card</span> <span class=\"n\">I</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span> <span class=\"bp\">∧</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">k</span> <span class=\"bp\">∧</span> <span class=\"n\">j</span> <span class=\"bp\">≠</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">equiv_fin_of_card_eq</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">f.symm</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">f.symm</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">f.symm</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n    <span class=\"n\">and.imp</span> <span class=\"n\">f.symm.injective.ne</span> <span class=\"o\">(</span><span class=\"n\">and.imp</span> <span class=\"n\">f.symm.injective.ne</span> <span class=\"n\">f.symm.injective.ne</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"gr\">sorry</span> <span class=\"c1\">-- `0 ≠ 1 ∧ 0 ≠ 2 ∧ 1 ≠ 2`, all in `fin 3`</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I don't know how to close those fin goals, but they're at least \"very obviously true\" rather than \"handwavingly true\"</p>",
        "id": 246217173,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626439117
    },
    {
        "content": "<p><code>dec_trivial</code> works for the <code>sorry</code> there</p>",
        "id": 246217516,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1626439379
    },
    {
        "content": "<p><code>equiv_fin_of_card_eq</code> is the lemma I am looking for!!</p>",
        "id": 246218915,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626440233
    },
    {
        "content": "<p>A <code>fin_embedding_of_lt_card</code> would be convenient for your use case</p>",
        "id": 246219463,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626440524
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin.cast_le_order_iso\">docs#fin.cast_le_order_iso</a> would help</p>",
        "id": 246219977,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626440838
    },
    {
        "content": "<p>Maybe something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">trunc_fin_embedding_of_card_eq</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">↪</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">trunc_equiv_fin</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">fin.cast_le</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_embedding.trans</span> <span class=\"n\">e.symm.to_embedding</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">trunc_embedding_fin_of_card_le</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">↪</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">trunc_equiv_fin</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e.to_embedding.trans</span> <span class=\"o\">(</span><span class=\"n\">fin.cast_le</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_embedding</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 246220130,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626440922
    },
    {
        "content": "<p>This is all pretty <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>. It's easier to just postulate the existence of such elements, then show the cardinality of their finset is le than the cardinality of the fintype.</p>",
        "id": 246220288,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626441020
    },
    {
        "content": "<p>Is there any version of coded lemma stating that the <code>card</code> of the unit group of a finite field <code>F</code> is exactly <code>F.card - 1</code>?<br>\nAlso not exactly sure what the definition of \"the unit group of finite field\"  in mathlib will be handy and is supposed to be used. Perhaps <code>units F</code>?</p>",
        "id": 246430058,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626684393
    },
    {
        "content": "<p>You should think about how you want to prove this and write down a step-by-step proof and then formalise it. My advice: stop using natural number subtraction, it just makes your life worse. Rewrite everything as addition.</p>",
        "id": 246430144,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626684463
    },
    {
        "content": "<p>Why not explicitly write an <code>equiv</code> between <code>F</code> and <code>option (units F)</code> and then deduce the addition version from results about card of option?</p>",
        "id": 246430242,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626684520
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"408694\">@Alex Zhang</span> Did you look at <code>src/field_theory/finite/basic.lean</code>?</p>",
        "id": 246430292,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1626684565
    },
    {
        "content": "<p>Ah, I found it! <code>finite_field.card_units</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">finite_field.card_units</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"n\">fintype.card</span> <span class=\"o\">(</span><span class=\"n\">units</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">fintype.card</span> <span class=\"n\">K</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 246430633,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626684796
    },
    {
        "content": "<p>I defined the set of quadratic residues in a finite field F, then I want to prove the card of it is half of the unit group of F, as formalised in the code.<br>\nI gave three definitions in the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> (not quite sure which one is the most convenient for proving this). Could anyone please point me a direction for proving this equality? The way I currently think of is to use some version of <br>\n<code>card (im f) * card (kernel f) = card units F</code> as f is a group hom (not sure if it is the correct or a convenient way).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.fintype.card</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">field_theory.finite.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">char_p</span> <span class=\"n\">F</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">quad_residues</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">''</span> <span class=\"o\">((</span><span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">\\</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">})</span>\n\n<span class=\"c1\">-- alternative defns</span>\n<span class=\"kd\">def</span> <span class=\"n\">quad_residues'</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">∧</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">quad_residues''</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">units</span> <span class=\"n\">F</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">quad_residues</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">quad_residues</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finset.card</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">fintype.card</span> <span class=\"n\">F</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 246482876,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626714448
    },
    {
        "content": "<p>Is it possible to construct an explicit isomorphism, even if it is noncomputable?</p>",
        "id": 246484050,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626714985
    },
    {
        "content": "<p>You could define <code>is_quad_residue</code> as a Prop, and use that in a <code>finset.filter</code> instead.</p>",
        "id": 246484309,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626715117
    },
    {
        "content": "<p>Would this def be helpful for proving the equality?</p>",
        "id": 246484529,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626715245
    },
    {
        "content": "<p>Ah, I found the defn of \"kernel\".  <a href=\"https://leanprover-community.github.io/mathlib_docs/group_theory/subgroup.html#monoid_hom.ker\">https://leanprover-community.github.io/mathlib_docs/group_theory/subgroup.html#monoid_hom.ker</a><br>\nand I will leave for dinner for now.</p>",
        "id": 246486095,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626715936
    },
    {
        "content": "<p>How about this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.fintype.card</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">field_theory.finite.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_quad_res</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">),</span> <span class=\"n\">y</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">char_p</span> <span class=\"n\">F</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"n\">is_quad_res</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"n\">fintype.card</span> <span class=\"n\">F</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 246494203,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626719634
    },
    {
        "content": "<p>Is this correct?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">sq_hom</span> <span class=\"o\">:</span> <span class=\"n\">units</span> <span class=\"n\">F</span> <span class=\"bp\">→*</span> <span class=\"n\">units</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">mul_left_comm</span><span class=\"o\">]⟩</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">F</span><span class=\"o\">}</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">sq_hom_res_iff</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">char_p</span> <span class=\"n\">F</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">units</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">sq_hom</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ker</span> <span class=\"bp\">↔</span> <span class=\"n\">is_quad_res</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 246494315,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626719662
    },
    {
        "content": "<p><code>example (h: p ≠ 2) : ((finset.univ : finset F).filter is_quad_res).card = fintype.card F - 1 :=</code><br>\nshould be <br>\n<code>example (h: p ≠ 2) : ((finset.univ : finset F).filter is_quad_res).card  * 2 = fintype.card F - 1 :=</code></p>",
        "id": 246497381,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626721040
    },
    {
        "content": "<p>No. The squaring function has a kernel and an image. The quadratic residues are the stuff in the <em>image</em>. If p&gt;2 then the kernel is +-1 which has size 2. Hence the first isomorphism theorem says that twice the size of the image equals the size of the units (Alex' version correctly adds this factor of 2)</p>",
        "id": 246497396,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626721044
    },
    {
        "content": "<p>The units of a finite field are cyclic, although this is not obvious. The quadratic residues are a subgroup, so they must hence be the kernel of the map raising a unit to the power (c-1)/2 where c is the size of the field</p>",
        "id": 246497642,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626721168
    },
    {
        "content": "<p>Yes, Kevin. I am still looking for the first iso thm in mathlib. Do you have any suggestion for proving the card equality? <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span></p>",
        "id": 246498087,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626721334
    },
    {
        "content": "<p>Yes, use the first isomorphism theorem!</p>",
        "id": 246498364,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626721452
    },
    {
        "content": "<p>Yes, sorry for the missing <code>* 2</code> typo. Thanks Kevin for the clarification, I was going through the proof using powers of <code>(p - 1)  / 2</code> and realized that I must have meant image and not kernel.</p>",
        "id": 246498983,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626721717
    },
    {
        "content": "<p>I found the first iso thm: <a href=\"https://leanprover-community.github.io/mathlib_docs/group_theory/quotient_group.html#quotient_group.quotient_ker_equiv_range\">https://leanprover-community.github.io/mathlib_docs/group_theory/quotient_group.html#quotient_group.quotient_ker_equiv_range</a></p>",
        "id": 246499308,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626721868
    },
    {
        "content": "<p>But there are still some gaps to <code>card</code>.</p>",
        "id": 246500122,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626722099
    },
    {
        "content": "<p>Ah, <a href=\"https://leanprover-community.github.io/mathlib_docs/group_theory/coset.html#subgroup.card_eq_card_quotient_mul_card_subgroup\">https://leanprover-community.github.io/mathlib_docs/group_theory/coset.html#subgroup.card_eq_card_quotient_mul_card_subgroup</a><br>\nseems to be useful</p>",
        "id": 246501179,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626722640
    },
    {
        "content": "<p>It is weird. Why can't <code>ring</code> close </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.fintype.card</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">field_theory.finite.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">char_p</span> <span class=\"n\">F</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">units</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span><span class=\"n\">units</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">ring</span><span class=\"o\">})⟩</span>\n</code></pre></div>",
        "id": 246503140,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626723479
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">sq_hom</span> <span class=\"o\">:</span> <span class=\"n\">units</span> <span class=\"n\">F</span> <span class=\"bp\">→*</span> <span class=\"n\">units</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">mul_left_comm</span><span class=\"o\">]⟩</span>\n</code></pre></div>",
        "id": 246503809,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626723767
    },
    {
        "content": "<p><code>units F</code> is not a <code>ring</code>.</p>",
        "id": 246503881,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626723803
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">sq_hom</span> <span class=\"o\">:</span> <span class=\"n\">units</span> <span class=\"n\">F</span> <span class=\"bp\">→*</span> <span class=\"n\">units</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">units.ext_iff</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">ring</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 246503939,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626723836
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.fintype.card</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">field_theory.finite.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.quotient_group</span>\n\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_quad_res</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">),</span> <span class=\"n\">y</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_quad_res.ne_zero</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_quad_res</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">mul_ne_zero</span> <span class=\"n\">hy</span> <span class=\"n\">hy</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">char_p</span> <span class=\"n\">F</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">sq_hom</span> <span class=\"o\">:</span> <span class=\"n\">units</span> <span class=\"n\">F</span> <span class=\"bp\">→*</span> <span class=\"n\">units</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">mul_left_comm</span><span class=\"o\">]⟩</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">F</span><span class=\"o\">}</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">sq_hom_res_iff</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">units</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">sq_hom</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"bp\">↔</span> <span class=\"n\">is_quad_res</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">sq_hom</span><span class=\"o\">,</span> <span class=\"n\">is_quad_res</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">monoid_hom.mem_range</span><span class=\"o\">,</span> <span class=\"n\">monoid_hom.coe_mk</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">),</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">units.ne_zero</span><span class=\"o\">,</span> <span class=\"n\">not_false_iff</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hy</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hn</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">⟩,</span>\n    <span class=\"k\">have</span> <span class=\"n\">key</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">is_unit.mk0</span> <span class=\"n\">y</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">key.unit</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">units.ext_iff</span><span class=\"o\">,</span> <span class=\"n\">key.unit_spec</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">is_quad_res</span> <span class=\"n\">F</span> <span class=\"n\">_</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">((</span><span class=\"n\">finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"n\">is_quad_res</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">fintype.card</span> <span class=\"n\">F</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">finite_field.card_units</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- probably some neater way of constructing this, but who cares</span>\n  <span class=\"k\">let</span> <span class=\"n\">iso</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"n\">is_quad_res</span> <span class=\"bp\">≃</span> <span class=\"o\">(</span><span class=\"n\">sq_hom</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">equiv.trans</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">equiv.subtype_equiv_right</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">sq_hom_res_iff</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)),</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨(</span><span class=\"n\">is_unit.mk0</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">is_quad_res.ne_zero</span> <span class=\"n\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">unit</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n      <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">y.prop</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">is_unit.unit_spec</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">y.prop</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨((</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">units</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">),</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">y.prop</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">is_unit.unit_spec</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">units.ext_iff</span><span class=\"o\">,</span> <span class=\"n\">is_unit.unit_spec</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"n\">is_quad_res</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"n\">fintype.card</span> <span class=\"o\">(</span><span class=\"n\">sq_hom</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">fintype.card_coe</span><span class=\"o\">,</span>\n    <span class=\"n\">convert</span> <span class=\"n\">fintype.card_congr</span> <span class=\"n\">iso</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">eq_comm</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">subgroup.card_eq_card_quotient_mul_card_subgroup</span> <span class=\"o\">((</span><span class=\"n\">sq_hom</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"o\">),</span>\n  <span class=\"n\">congr'</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">fintype.card_congr</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">quotient_group.quotient_ker_equiv_range</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_equiv</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- The kernel is {1, -1}, prove that elsewhere</span>\n    <span class=\"c1\">-- this is actually where the `(h : p ≠ 2)` hypothesis needs to be used</span>\n    <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 246507824,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626725614
    },
    {
        "content": "<p>Cool, Yakov! I am also getting to the final part to prove that the <code>card</code> of the kernel is 2. Do you have any idea of proving that? <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span></p>",
        "id": 246509128,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626726258
    },
    {
        "content": "<p>factor the quadratic?</p>",
        "id": 246509634,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626726555
    },
    {
        "content": "<p>Relatedly, a simpler puzzle:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">sq_hom_ker_eq_char_2</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">sq_hom</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ker</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfreezingI</span> <span class=\"o\">{</span> <span class=\"n\">subst</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n  <span class=\"n\">refine</span> <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">bot_le</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">monoid_hom.mem_ker</span><span class=\"o\">,</span> <span class=\"n\">sq_hom</span><span class=\"o\">,</span> <span class=\"n\">monoid_hom.coe_mk</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">subgroup.mem_bot</span><span class=\"o\">],</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 246509804,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626726643
    },
    {
        "content": "<p>Thanks a lot for the proof!!</p>",
        "id": 246510099,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626726808
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">sq_hom_ker_eq_char_2</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">sq_hom</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ker</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfreezingI</span> <span class=\"o\">{</span> <span class=\"n\">subst</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n  <span class=\"n\">refine</span> <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">bot_le</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">monoid_hom.mem_ker</span><span class=\"o\">,</span> <span class=\"n\">sq_hom</span><span class=\"o\">,</span> <span class=\"n\">monoid_hom.coe_mk</span><span class=\"o\">,</span> <span class=\"n\">units.ext_iff</span><span class=\"o\">,</span> <span class=\"n\">units.coe_one</span><span class=\"o\">,</span>\n             <span class=\"n\">units.coe_mul</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">pow_two</span> <span class=\"n\">at</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"n\">nat.prime</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">nat.prime_two</span><span class=\"o\">⟩,</span>\n  <span class=\"k\">let</span> <span class=\"n\">iso</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">≃+*</span> <span class=\"n\">zmod</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">zmod.ring_equiv</span> <span class=\"n\">F</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">subgroup.mem_bot</span><span class=\"o\">,</span> <span class=\"n\">units.ext_iff</span><span class=\"o\">],</span>\n  <span class=\"n\">apply</span> <span class=\"n\">iso.injective</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">iso</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">iso.to_monoid_hom</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">this</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 246512186,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626727866
    },
    {
        "content": "<p>Why is the goal at <code>sorry</code> <code>fintype.card F = 2</code>?</p>",
        "id": 246512924,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626728205
    },
    {
        "content": "<p>Are you claiming that every finite field of characteristic 2 has two elements? This is not true.</p>",
        "id": 246512929,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626728207
    },
    {
        "content": "<p>There's a field with elements 0,1,a,b with a^2=a+1=b and b^2=b+1=a. It has characteristic 2 and order 4.</p>",
        "id": 246513025,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626728272
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/card/near/246512929\">said</a>:</p>\n<blockquote>\n<p>Are you claiming that every finite field of characteristic 2 has two elements? This is not true.</p>\n</blockquote>\n<p>I feel I got back to my third year (or second year) algebra course although I have got very sleepy :)</p>",
        "id": 246513044,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626728283
    },
    {
        "content": "<p>I have not set about proving <code>card ker</code> is 2 myself as I am too sleepy now.</p>",
        "id": 246513430,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626728432
    },
    {
        "content": "<p>I see, apologies for the wrong statement! I have never actually taken algebra at that level, and have been trying to learn it myself.</p>",
        "id": 246513434,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626728433
    },
    {
        "content": "<p>You have already given many helpful answers, Yakov. Many thanks! <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span></p>",
        "id": 246513720,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626728493
    },
    {
        "content": "<p>I was not sure how to get Fermat's Little Theorem to work on arbitrary finite fields, but we have it for <code>zmod p</code>. So I faked it =/</p>",
        "id": 246514009,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626728543
    },
    {
        "content": "<p>Just like you can make the complexes by starting with the reals and throwing in a root of a real quadratic which doesn't have a real root, you can do the same with the field with two elements, throwing in a root of X^2=X+1. This polynomial mod 2 doesn't have 0 or 1 as a root, so throw a root in and you get something 2-dimensional over {0,1}.</p>",
        "id": 246514052,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626728559
    },
    {
        "content": "<p>Fermat's little theorem follows from the theorem in group theory that the order of the element divides the order of the group, applied to the unit group. This does not need the deeper fact that this group is cyclic</p>",
        "id": 246514250,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626728621
    },
    {
        "content": "<p>Ah, of course! I was just formalizing notes from Gross's class about this.</p>",
        "id": 246514434,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626728671
    },
    {
        "content": "<p>I have proved<code> the card of the ker is 2</code>, but have not sorted things out.</p>",
        "id": 246574364,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626782286
    },
    {
        "content": "<p>Did you prove it by explicitly showing that the ker is 1 and -1 for the appropriate p?</p>",
        "id": 246579977,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626785924
    },
    {
        "content": "<p>Yes, doing something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">f_0</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ker.carrier</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">ker</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">f_ker</span><span class=\"o\">,</span> <span class=\"n\">subgroup.comap</span><span class=\"o\">,</span> <span class=\"n\">set.preimage</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">],</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"n\">any_goals</span> <span class=\"o\">{</span><span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">units.ext_iff</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_sub</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">],</span> <span class=\"n\">ring</span><span class=\"o\">},</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span><span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">units.ext_iff</span><span class=\"o\">,</span> <span class=\"n\">eq_neg_of_add_eq_zero</span> <span class=\"n\">h'</span><span class=\"o\">],},</span>\n    <span class=\"o\">{</span><span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">units.ext_iff</span><span class=\"o\">,</span> <span class=\"n\">sub_eq_zero.mp</span> <span class=\"n\">h'</span><span class=\"o\">]}</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 246584221,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626788003
    },
    {
        "content": "<p>Golfed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">sq_hom_ker_eq</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">sq_hom</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ker.carrier</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">monoid_hom.mem_ker</span><span class=\"o\">,</span> <span class=\"n\">set.mem_insert_iff</span><span class=\"o\">,</span> <span class=\"n\">subgroup.mem_carrier</span><span class=\"o\">,</span> <span class=\"n\">set.mem_singleton_iff</span><span class=\"o\">,</span>\n             <span class=\"n\">sq_hom</span><span class=\"o\">,</span> <span class=\"n\">monoid_hom.coe_mk</span><span class=\"o\">,</span> <span class=\"n\">units.ext_iff</span><span class=\"o\">,</span> <span class=\"n\">units.coe_mul</span><span class=\"o\">,</span> <span class=\"n\">units.coe_one</span><span class=\"o\">,</span> <span class=\"n\">units.coe_neg</span><span class=\"o\">],</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_sub</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">],</span> <span class=\"n\">ring</span> <span class=\"o\">},</span>\n    <span class=\"n\">rw</span> <span class=\"n\">mul_eq_zero</span> <span class=\"n\">at</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h'.symm.imp</span> <span class=\"n\">eq_of_sub_eq_zero</span> <span class=\"n\">eq_neg_of_add_eq_zero</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"bp\">;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 246592453,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626790912
    },
    {
        "content": "<p>Is there a way to recycle <code>mul_self_eq_one_iff</code> more efficiently?  I feel that the proof of <code>units.sq_one</code> should be much shorter...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">monoid_hom.ker_mul_self</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">units</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">monoid_hom.ker</span> <span class=\"o\">(</span><span class=\"n\">sq_hom</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">units.sq_one</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">integral_domain</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">units</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">convert</span> <span class=\"bp\">@</span><span class=\"n\">mul_self_eq_one_iff</span> <span class=\"n\">F</span> <span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"n\">using</span> <span class=\"mi\">1</span><span class=\"bp\">;</span> <span class=\"n\">refine</span> <span class=\"n\">eq_iff_iff.mpr</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">congr_arg</span> <span class=\"n\">coe</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">units.eq_iff.mp</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span><span class=\"bp\">;</span> <span class=\"n\">rintros</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">|</span> <span class=\"n\">h</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">or.inl</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">or.inr</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">or.inl</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">or.inr</span> <span class=\"o\">(</span><span class=\"n\">units.ext</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">f_0</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">sq_hom</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ker.carrier</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">monoid_hom.ker_mul_self</span><span class=\"o\">,</span> <span class=\"n\">units.sq_one</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 246603392,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1626793422
    },
    {
        "content": "<p>Also, note that it might make sense to develop some API for the slightly more general version of <code>sq_hom</code> below.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mul_self_hom</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">→*</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">mul_mul_mul_comm</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>Your version, would be the above applied to <code>units F</code>.</p>\n<p>Possibly, even for the more general <code>nat</code>-power map</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">pow_self_hom</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">→*</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">one_pow</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">mul_pow</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 246689348,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1626853931
    },
    {
        "content": "<p>IIRC this map is already in mathlib</p>",
        "id": 246690256,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626854657
    },
    {
        "content": "<p>Or perhaps there's an old skool <code>is_monoid_hom</code> instance on the power map</p>",
        "id": 246690300,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626854697
    },
    {
        "content": "<p>Ah, in either case, it might make sense to generalize some of the lemmas above to work for this more general setting.</p>",
        "id": 246690344,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1626854732
    }
]
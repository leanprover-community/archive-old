[
    {
        "content": "<p>I'm trying to prove something by strong induction on the natural numbers and I'm having trouble with type inference. The actual example is pretty complicated, so here's the best mwe I can come up with. Here's what I'd like to prove</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">constant</span> <span class=\"n\">dimension</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span>\n<span class=\"kn\">constant</span> <span class=\"n\">shrink</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kn\">constant</span> <span class=\"n\">good</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">constant</span> <span class=\"n\">shrink_inhabited_of_inhabited</span> <span class=\"o\">:</span> <span class=\"n\">shrink</span> <span class=\"n\">α</span>\n<span class=\"n\">noncomputable</span> <span class=\"kn\">instance</span> <span class=\"n\">shrink_inhabited</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">shrink</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"n\">inhabited</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">shrink_inhabited_of_inhabited</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"kn\">axiom</span> <span class=\"n\">good_of_dimension_zero</span> <span class=\"o\">:</span> <span class=\"n\">dimension</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">good</span> <span class=\"n\">α</span>\n<span class=\"kn\">axiom</span> <span class=\"n\">shrink_decreasing</span> <span class=\"o\">:</span> <span class=\"n\">dimension</span> <span class=\"n\">α</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">dimension</span> <span class=\"o\">(</span><span class=\"n\">shrink</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">dimension</span> <span class=\"n\">α</span>\n<span class=\"kn\">axiom</span> <span class=\"n\">good_of_shrink_good</span> <span class=\"o\">:</span> <span class=\"n\">good</span> <span class=\"o\">(</span><span class=\"n\">shrink</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">good</span> <span class=\"n\">α</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">good_of_inhabited</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">dimension</span>  <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">good</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>The lemma as stated however, is not quite in the right form to do induction. You want to apply the inductive assumption to <code>shrink α</code> but the inductive assumption doesn't allow this. The obvious solution (and I haven't quite gotten to my actual question yet) is to quantify over <code>α</code> as well. Like so</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">good_of_inhabited</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">α</span> <span class=\"o\">[</span><span class=\"n\">hα</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">],</span> <span class=\"bp\">@</span><span class=\"n\">dimension</span> <span class=\"n\">α</span> <span class=\"n\">hα</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">good</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>Already, I start having some problems with type inference. I'd like to just be able to type <code>dimension α = n</code> but I can't because Lean can't figure out that <code>α</code> is <code>inhabited</code> the same way it could before. When I try to prove the lemma, this keeps coming up. E.g. I can prove it like so</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">good_of_inhabited</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">α</span> <span class=\"o\">[</span><span class=\"n\">hα</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">],</span> <span class=\"bp\">@</span><span class=\"n\">dimension</span> <span class=\"n\">α</span> <span class=\"n\">hα</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">good</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">α</span> <span class=\"n\">hα</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">good_of_dimension_zero</span> <span class=\"n\">α</span> <span class=\"n\">hα</span> <span class=\"n\">h</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">α</span> <span class=\"n\">hα</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">shrink</span> <span class=\"n\">α</span> <span class=\"n\">hα</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">dimension</span> <span class=\"n\">β</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">decreasing</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">hn</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">shrink_decreasing</span><span class=\"bp\">;</span> <span class=\"n\">linarith</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">good</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">good_of_inhabited</span> <span class=\"n\">m</span> <span class=\"n\">β</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">good_of_shrink_good</span> <span class=\"n\">α</span> <span class=\"n\">hα</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>But it's annoying to have to tell Lean how to infer types explicitly so much. And in the actual example where I want to do something like this (not this simplified mwe) it's even worse and I'm genuinely having some trouble getting Lean to do all the type inference that I want. Is there a better way to do this?</p>",
        "id": 205529286,
        "sender_full_name": "Patrick Lutz",
        "timestamp": 1596141342
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">constant</span> <span class=\"n\">dimension</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span>\n<span class=\"kn\">constant</span> <span class=\"n\">shrink</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kn\">constant</span> <span class=\"n\">good</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">constant</span> <span class=\"n\">shrink_inhabited_of_inhabited</span> <span class=\"o\">:</span> <span class=\"n\">shrink</span> <span class=\"n\">α</span>\n<span class=\"n\">noncomputable</span> <span class=\"kn\">instance</span> <span class=\"n\">shrink_inhabited</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">shrink</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"n\">inhabited</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">shrink_inhabited_of_inhabited</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"kn\">axiom</span> <span class=\"n\">good_of_dimension_zero</span> <span class=\"o\">:</span> <span class=\"n\">dimension</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">good</span> <span class=\"n\">α</span>\n<span class=\"kn\">axiom</span> <span class=\"n\">shrink_decreasing</span> <span class=\"o\">:</span> <span class=\"n\">dimension</span> <span class=\"n\">α</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">dimension</span> <span class=\"o\">(</span><span class=\"n\">shrink</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">dimension</span> <span class=\"n\">α</span>\n<span class=\"kn\">axiom</span> <span class=\"n\">good_of_shrink_good</span> <span class=\"o\">:</span> <span class=\"n\">good</span> <span class=\"o\">(</span><span class=\"n\">shrink</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">good</span> <span class=\"n\">α</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">good_of_inhabited</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">dimension</span>  <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">good</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">unfreeze_local_instances</span><span class=\"o\">,</span> <span class=\"n\">revert</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">strong_induction_on</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">k</span> <span class=\"n\">hk</span> <span class=\"n\">β</span> <span class=\"bp\">_</span> <span class=\"n\">hβ</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">good_of_dimension_zero</span><span class=\"o\">,</span> <span class=\"n\">assumption</span> <span class=\"o\">},</span>\n  <span class=\"n\">apply</span> <span class=\"n\">good_of_shrink_good</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">hk</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">hβ</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">shrink_decreasing</span><span class=\"o\">,</span> <span class=\"n\">omega</span><span class=\"o\">},</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 205544069,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596151452
    },
    {
        "content": "<p>I think I just wrote my code \"backwards\", \"like a computer scientist\", so that I didn't have to manually specify terms</p>",
        "id": 205544225,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596151655
    },
    {
        "content": "<p>Hmm, I see you're using <code>nat.strong_induction_on</code>. That is good enough for what I want, but do you know if there's a way to do something like this with pattern matching instead? E.g. in case you want to do induction on a type that doesn't have a lemma like <code>strong_induction_on</code> and you don't want to prove such a lemma? I've been pretty happy with using pattern-matching to do induction in other circumstances.</p>",
        "id": 205545143,
        "sender_full_name": "Patrick Lutz",
        "timestamp": 1596152639
    },
    {
        "content": "<p>i think you can only pattern match on the actual constructors for the inductive type</p>",
        "id": 205545457,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596152950
    },
    {
        "content": "<p>you can do <code>induction n using nat.strong_induction_on</code> if you want to use that lemma with the <code>induction</code> tactic</p>",
        "id": 205545481,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596152983
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252300\">Jalex Stark</span> <a href=\"#narrow/stream/113489-new-members/topic/Problems.20with.20induction.20and.20type.20inference/near/205545457\">said</a>:</p>\n<blockquote>\n<p>i think you can only pattern match on the actual constructors for the inductive type</p>\n</blockquote>\n<p>That's not really what I'm asking. I believe in the proof I gave above I am using pattern-matching to do induction (with the pipe notation and so on), but maybe that's not actually what it's called. In any case, I am trying to ask if you can basically do something like my original proof but without all the <code>@</code>'s everywhere</p>",
        "id": 205546812,
        "sender_full_name": "Patrick Lutz",
        "timestamp": 1596154521
    },
    {
        "content": "<p>you can use <code>letI := h\\a</code> to promote local hypothesis <code>h\\a</code> to a local instance</p>",
        "id": 205549813,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596158674
    },
    {
        "content": "<p>at the beginning of your tactic state, you don't have a local instance of inhabited \\a</p>",
        "id": 205549822,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596158706
    },
    {
        "content": "<p>Okay, I think the phrase I was looking for was \"using the equation compiler to do well-founded recursion.\" Is it possible to give a proof of the example using the equation compiler rather than <code>nat.strong_induction_on</code> without running into problems with type inference?</p>",
        "id": 205629859,
        "sender_full_name": "Patrick Lutz",
        "timestamp": 1596222719
    },
    {
        "content": "<p>my current guess is no, you'll have to be explicit in the equation compiler before you enter tactic mode</p>",
        "id": 205642296,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596230061
    }
]
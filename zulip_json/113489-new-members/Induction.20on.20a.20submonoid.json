[
    {
        "content": "<p>I'm having trouble inducting over elements of a submonoid, and assume I must be doing something wrong. The mwe is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.algebra.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">my_fun</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>  <span class=\"c1\">-- not relevant</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">my_monoid</span> <span class=\"o\">:=</span> <span class=\"n\">submonoid.closure</span> <span class=\"bp\">$</span> <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">my_fun</span> <span class=\"n\">M</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">my_fun_mem</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">my_fun</span> <span class=\"n\">M</span> <span class=\"n\">A</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">my_monoid</span> <span class=\"n\">M</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"n\">submonoid.subset_closure</span> <span class=\"bp\">$</span> <span class=\"n\">set.mem_range_self</span> <span class=\"n\">m</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">induction</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">my_monoid</span> <span class=\"n\">M</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h_one</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">submonoid.one_mem</span> <span class=\"o\">(</span><span class=\"n\">my_monoid</span> <span class=\"n\">M</span> <span class=\"n\">A</span><span class=\"o\">)⟩)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_fun</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"o\">⟨</span><span class=\"n\">my_fun</span> <span class=\"n\">M</span> <span class=\"n\">A</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">my_fun_mem</span> <span class=\"n\">M</span> <span class=\"n\">A</span> <span class=\"n\">m</span><span class=\"o\">⟩)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">my_monoid</span> <span class=\"n\">M</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">C</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">subtype.coe_eta</span> <span class=\"n\">v</span> <span class=\"n\">v.prop</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">submonoid.closure_induction</span> <span class=\"n\">v.prop</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">set.mem_range.mpr</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n      <span class=\"n\">convert</span> <span class=\"n\">h_fun</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">subtype.eq</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">})</span>\n    <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">h_one</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">subtype.eq</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ring_hom.map_one</span><span class=\"o\">]})</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n      <span class=\"n\">sorry</span><span class=\"o\">,</span>\n    <span class=\"o\">})</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Alarmingly, this gives a type error at the word <code>lemma</code>, rather than telling me which of my tactics failed.</p>\n<p>What am I missing here?</p>",
        "id": 216369226,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605112956
    },
    {
        "content": "<p>I think Lean's error reporting might have difficulty with this ~5-tuply interleaved term/tactic mode proof</p>",
        "id": 216370820,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605113724
    },
    {
        "content": "<p>but anyways, I think the real issue is that you can't apply <code>submonoid.closure_induction</code> directly because its motive <code>C</code> isn't allowed to depend on the proof of membership</p>",
        "id": 216370940,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605113768
    },
    {
        "content": "<p>I tried various levels of unweaving, and none seemed to help with the error message</p>",
        "id": 216371134,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605113863
    },
    {
        "content": "<p>Presumably I need to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submonoid.dense_induction\">docs#submonoid.dense_induction</a>, and show that under the subtype <code>my_monoid </code>, the closure of <code>set.range (my_fun M A)</code> after coercion is <code>\\top</code></p>",
        "id": 216371330,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605113936
    },
    {
        "content": "<p>Well for example, if you replace the whole <code>exact</code> tactic with <code>apply submonoid.closure_induction v.prop</code>, then you get an error message on <code>apply</code>.</p>",
        "id": 216371488,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605114004
    },
    {
        "content": "<p>Ah, that's good to know</p>",
        "id": 216371792,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605114133
    },
    {
        "content": "<p>I think I need to start by proving</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span>  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">submonoid.closure</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">submonoid.closure</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n<p>so that I have the first argument to <code>dense_induction</code></p>",
        "id": 216372130,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605114290
    },
    {
        "content": "<p>This is proving difficult:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">submonoid.closure</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">submonoid.closure</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">subtype.rec_on</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">xprop</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">submonoid.closure_induction</span> <span class=\"n\">xprop</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">ha</span> <span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp_rw</span> <span class=\"bp\">←</span><span class=\"n\">submonoid.mem_coe</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">submonoid.subset_closure</span><span class=\"o\">,</span>\n    <span class=\"n\">simp_rw</span> <span class=\"n\">set.mem_preimage</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">subtype.coe_mk</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">this</span> <span class=\"n\">at</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n    <span class=\"n\">convert</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">submonoid.one_mem</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span><span class=\"o\">,</span>\n    <span class=\"n\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- ↑⟨1, xprop⟩ = ↑1</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">submonoid.mul_mem</span> <span class=\"n\">_</span> <span class=\"n\">ha</span> <span class=\"n\">hb</span><span class=\"o\">,</span>\n    <span class=\"n\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- ⟨a * b, xprop⟩ = ⟨a, xprop⟩ * ⟨b, xprop⟩</span>\n  <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Both the remaining goals are something I'd hope to close with <code>refl</code>, but I can't and I don't know what to do next</p>",
        "id": 216377200,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605117040
    },
    {
        "content": "<p><del>If I add <code>ext</code> before the last sorry, then I get a type error at the word <code>example</code> again</del></p>\n<p>Nevermind, the type error was there anyway and I missed it</p>",
        "id": 216377370,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605117127
    },
    {
        "content": "<p><code>unfold_coes, simp</code> does the first one</p>",
        "id": 216378000,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605117488
    },
    {
        "content": "<p>as does <code>unfold_coes, refl</code></p>",
        "id": 216378038,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605117512
    },
    {
        "content": "<p>and <code>ext, unfold_coes, refl</code> does the second one</p>",
        "id": 216378150,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605117571
    },
    {
        "content": "<p>Turns out it's irrelevant, the tactic state was telling me to keep going even though a type error had already appeared</p>",
        "id": 216378160,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605117574
    },
    {
        "content": "<p>But thanks, that does indeed close the goals! (despite not fixing the type error)</p>",
        "id": 216378515,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605117732
    },
    {
        "content": "<p>In fact, I seem to run into exactly the same problem I had before</p>",
        "id": 216379241,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605118110
    },
    {
        "content": "<p>What do you think about this approach:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">induction</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">my_monoid</span> <span class=\"n\">M</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h_one</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">submonoid.one_mem</span> <span class=\"o\">(</span><span class=\"n\">my_monoid</span> <span class=\"n\">M</span> <span class=\"n\">A</span><span class=\"o\">)⟩)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_fun</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"o\">⟨</span><span class=\"n\">my_fun</span> <span class=\"n\">M</span> <span class=\"n\">A</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">my_fun_mem</span> <span class=\"n\">M</span> <span class=\"n\">A</span> <span class=\"n\">m</span><span class=\"o\">⟩)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">my_monoid</span> <span class=\"n\">M</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">C</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">set</span> <span class=\"n\">C'</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">my_monoid</span> <span class=\"n\">M</span> <span class=\"n\">A</span> <span class=\"k\">then</span> <span class=\"n\">C</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"k\">else</span> <span class=\"n\">true</span> <span class=\"k\">with</span> <span class=\"n\">hC'</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">v</span> <span class=\"k\">with</span> <span class=\"n\">v</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">C'</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">hC'</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">split_ifs</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">apply</span> <span class=\"n\">submonoid.closure_induction</span><span class=\"o\">,</span>\n<span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 216379501,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605118258
    },
    {
        "content": "<p><code>  apply submonoid.closure_induction hv,</code> might be an even better last line</p>",
        "id": 216379726,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605118384
    },
    {
        "content": "<p>Rather than <code>if then else</code>, you can probably use <code>forall</code></p>",
        "id": 216379733,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605118388
    },
    {
        "content": "<p>I get stuck trying to unfold <code>C'</code> in the goal there, from</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">this</span><span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"o\">⟨</span><span class=\"n\">my_fun</span> <span class=\"n\">M</span> <span class=\"n\">A</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">C'</span> <span class=\"o\">(</span><span class=\"n\">my_fun</span> <span class=\"n\">M</span> <span class=\"n\">A</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 216380108,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605118583
    },
    {
        "content": "<p>That's why I used <code>set</code> not <code>let</code> -- you can <code>rw hC'</code></p>",
        "id": 216380171,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605118617
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">apply</span> <span class=\"n\">submonoid.closure_induction</span> <span class=\"n\">hv</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"n\">hC'</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n    <span class=\"n\">split_ifs</span><span class=\"o\">,</span> <span class=\"n\">swap</span><span class=\"o\">,</span> <span class=\"n\">trivial</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">hx</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h_fun</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n</code></pre></div>\n<p>There's the first one</p>",
        "id": 216380335,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605118687
    },
    {
        "content": "<p>I don't understand Reid's comment</p>",
        "id": 216380346,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605118695
    },
    {
        "content": "<p>Yep, I can finish up from there</p>",
        "id": 216380348,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605118697
    },
    {
        "content": "<p>Me neither</p>",
        "id": 216380358,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605118701
    },
    {
        "content": "<p>Oh, probably \"for all proofs that it's in your submonoid...\"</p>",
        "id": 216380383,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605118717
    },
    {
        "content": "<p><code>set C' : A → Prop := λ a, \\all ha : a ∈ my_monoid M A, C ⟨a, ha⟩</code></p>",
        "id": 216380405,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605118734
    },
    {
        "content": "<p>that's nicer because you'll have those to hand and won't need the split_ifs</p>",
        "id": 216380441,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605118757
    },
    {
        "content": "<p>Does this belong in mathlib somewhere? <code>submonoid.closure_induction'</code>?</p>",
        "id": 216380452,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605118764
    },
    {
        "content": "<p>This has something to do with your two submonoids and you want to quotient out one by the other, right? My instinct when I look at your lemma is \"why not use Reid's trick to define your C and have things like a and b in <code>h_mul</code> quantify over all of A rather than just the submonoid\", but perhaps this is not convenient for you in your situation?</p>",
        "id": 216380909,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605119016
    },
    {
        "content": "<p>Quantify over proofs everywhere.</p>",
        "id": 216380940,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605119037
    },
    {
        "content": "<p>I don't think I can finish off the last part of the proof with reid's trick</p>",
        "id": 216381045,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605119082
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">induction</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">my_monoid</span> <span class=\"n\">M</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h_one</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">submonoid.one_mem</span> <span class=\"o\">(</span><span class=\"n\">my_monoid</span> <span class=\"n\">M</span> <span class=\"n\">A</span><span class=\"o\">)⟩)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_fun</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"o\">⟨</span><span class=\"n\">my_fun</span> <span class=\"n\">M</span> <span class=\"n\">A</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">my_fun_mem</span> <span class=\"n\">M</span> <span class=\"n\">A</span> <span class=\"n\">m</span><span class=\"o\">⟩)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">my_monoid</span> <span class=\"n\">M</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">C</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">set</span> <span class=\"n\">C'</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">my_monoid</span> <span class=\"n\">M</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"k\">with</span> <span class=\"n\">hC'</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">v</span> <span class=\"k\">with</span> <span class=\"n\">v</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">C'</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">hC'</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">apply</span> <span class=\"n\">submonoid.closure_induction</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">hC'</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">set.mem_range.mpr</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h_fun</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">hC'</span><span class=\"o\">,</span> <span class=\"n\">intro</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h_one</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">hC'</span><span class=\"o\">,</span> <span class=\"n\">intros</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">hC'</span> <span class=\"n\">at</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n    <span class=\"n\">sorry</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 216381134,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605119140
    },
    {
        "content": "<p>oops</p>",
        "id": 216381303,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605119241
    },
    {
        "content": "<p>Maybe my idea doesn't work.</p>",
        "id": 216381330,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605119262
    },
    {
        "content": "<p>maybe <code>\\exists</code> is better then?</p>",
        "id": 216381334,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605119264
    },
    {
        "content": "<p>Are we missing some important lemma? It seems like there should be something that says \"within a <code>submonoid.closure s</code>, the elements of <code>s</code> when embedded in the subtype are the generators of the entire subtype\"</p>",
        "id": 216381478,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605119345
    },
    {
        "content": "<p>Isn't that what we're proving?</p>",
        "id": 216381587,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605119407
    },
    {
        "content": "<p>I mean basically yes, it is</p>",
        "id": 216381629,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605119436
    },
    {
        "content": "<p>That's what my <code>submonoid.closure (coe ⁻¹' s : set (submonoid.closure s)) = ⊤</code> statement above was attempting to be - my hope was that eliminating the <code>my_fun</code> stuff would make it simpler to prove</p>",
        "id": 216381695,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605119477
    },
    {
        "content": "<p>You're using the wrong induction procedure</p>",
        "id": 216381736,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605119505
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 216381744,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605119511
    },
    {
        "content": "<p>It would be great if lemmas could be tagged with \"this is an induction procedure\" to help me find the right one</p>",
        "id": 216381834,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605119541
    },
    {
        "content": "<p>I think my C' approach is doomed to failure.</p>",
        "id": 216382089,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605119672
    },
    {
        "content": "<p>It was a nice idea</p>",
        "id": 216382123,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605119697
    },
    {
        "content": "<p>I think you should try with <code>\\exists</code> instead</p>",
        "id": 216382188,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605119729
    },
    {
        "content": "<p>that way you're proving membership and <code>C</code> at the same time</p>",
        "id": 216382208,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605119737
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">begin</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">set</span> <span class=\"n\">C'</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">my_monoid</span> <span class=\"n\">M</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"k\">with</span> <span class=\"n\">hC'</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">v</span> <span class=\"k\">with</span> <span class=\"n\">v</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">C'</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">this</span> <span class=\"k\">with</span> <span class=\"n\">m</span> <span class=\"n\">hm</span><span class=\"o\">,</span>\n    <span class=\"n\">convert</span> <span class=\"n\">hm</span> <span class=\"o\">},</span>\n  <span class=\"n\">apply</span> <span class=\"n\">submonoid.closure_induction</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n<span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 216382651,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605119944
    },
    {
        "content": "<p>I think Reid's right. This won't have the problems which mul had with my original C'</p>",
        "id": 216382814,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605120014
    },
    {
        "content": "<p>Will try that</p>",
        "id": 216382839,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605120029
    },
    {
        "content": "<p>I think my original C' was logically equivalent to Reid's forall C', but this is different. Mul works, for starters</p>",
        "id": 216382864,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605120049
    },
    {
        "content": "<p>Yep</p>",
        "id": 216383063,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605120144
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">induction</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">my_monoid</span> <span class=\"n\">M</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h_one</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">submonoid.one_mem</span> <span class=\"o\">(</span><span class=\"n\">my_monoid</span> <span class=\"n\">M</span> <span class=\"n\">A</span><span class=\"o\">)⟩)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_fun</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"o\">⟨</span><span class=\"n\">my_fun</span> <span class=\"n\">M</span> <span class=\"n\">A</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">my_fun_mem</span> <span class=\"n\">M</span> <span class=\"n\">A</span> <span class=\"n\">m</span><span class=\"o\">⟩)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">my_monoid</span> <span class=\"n\">M</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">C</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">set</span> <span class=\"n\">C'</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">my_monoid</span> <span class=\"n\">M</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"k\">with</span> <span class=\"n\">hC'</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">v</span> <span class=\"k\">with</span> <span class=\"n\">v</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">C'</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">apply</span> <span class=\"n\">submonoid.closure_induction</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">submonoid.subset_closure</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">set.mem_range.mpr</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h_fun</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">hC'</span><span class=\"o\">,</span> <span class=\"n\">use</span> <span class=\"n\">submonoid.one_mem</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h_one</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">⟨</span><span class=\"n\">hx'</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">hy'</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">use</span> <span class=\"n\">submonoid.mul_mem</span> <span class=\"n\">_</span> <span class=\"n\">hx'</span> <span class=\"n\">hy'</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h_mul</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 216383067,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605120147
    },
    {
        "content": "<p>I'll try to distil to something more generally applicable tomorrow</p>",
        "id": 216384778,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605120993
    },
    {
        "content": "<p>Golfed to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">induction'</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">submonoid.closure</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h_one</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">submonoid.closure</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">one_mem</span><span class=\"o\">⟩)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_closure</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">submonoid.subset_closure</span> <span class=\"n\">h</span><span class=\"o\">⟩)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">submonoid.closure</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">C</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"n\">subtype.rec_on</span> <span class=\"n\">v</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">hv</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">exists.elim</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">submonoid.closure</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">hv</span><span class=\"o\">⟩),</span> <span class=\"n\">hc</span><span class=\"o\">),</span>\n  <span class=\"n\">exact</span> <span class=\"n\">submonoid.closure_induction</span> <span class=\"n\">hv</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">submonoid.subset_closure</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">h_closure</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">⟩)</span>\n    <span class=\"o\">⟨</span><span class=\"n\">submonoid.one_mem</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h_one</span><span class=\"o\">⟩</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">exists.elim</span> <span class=\"n\">hx</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">hx'</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">exists.elim</span> <span class=\"n\">hy</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">hy'</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n      <span class=\"o\">⟨</span><span class=\"n\">submonoid.mul_mem</span> <span class=\"n\">_</span> <span class=\"n\">hx'</span> <span class=\"n\">hy'</span><span class=\"o\">,</span> <span class=\"n\">h_mul</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span><span class=\"o\">⟩),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 216441798,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605171117
    },
    {
        "content": "<p>And the other lemma,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">closure_coe_preimage_eq_top</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">submonoid.closure</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">submonoid.closure</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">iff_true</span><span class=\"o\">,</span> <span class=\"n\">submonoid.mem_top</span><span class=\"o\">],</span>\n  <span class=\"n\">cases</span> <span class=\"n\">v</span> <span class=\"k\">with</span> <span class=\"n\">v</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">submonoid.closure</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"o\">(⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">submonoid.closure</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">submonoid.closure</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">exact</span> <span class=\"n\">submonoid.closure_induction</span> <span class=\"n\">hv</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">submonoid.subset_closure</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">submonoid.subset_closure</span> <span class=\"bp\">$</span> <span class=\"n\">set.mem_preimage.mpr</span> <span class=\"n\">hx</span><span class=\"o\">⟩)</span>\n    <span class=\"o\">⟨</span><span class=\"n\">submonoid.one_mem</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">submonoid.one_mem</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">exists.elim</span> <span class=\"n\">hx</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">hx'</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">exists.elim</span> <span class=\"n\">hy</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">hy'</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n      <span class=\"o\">⟨</span><span class=\"n\">submonoid.mul_mem</span> <span class=\"n\">_</span> <span class=\"n\">hx'</span> <span class=\"n\">hy'</span><span class=\"o\">,</span> <span class=\"n\">submonoid.mul_mem</span> <span class=\"n\">_</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span><span class=\"o\">⟩),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 216443576,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605172332
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/4984\">#4984</a></p>",
        "id": 216445568,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605173652
    }
]
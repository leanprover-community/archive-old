[
    {
        "content": "<p>Hello! Very new to Lean and logic in general;  i'm interested in how i can find the function names that i might need for various deduction steps (e.g. <code>and.intro</code>), since the std/maths library sections of \"theorem proving in lean\" are empty <span class=\"emoji emoji-1f627\" title=\"anguished\">:anguished:</span> in particular, i want to go from <code>¬p → false</code> to <code>p</code></p>",
        "id": 133315850,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1536073354
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean/blob/master/library/init/classical.lean#L160\" target=\"_blank\" title=\"https://github.com/leanprover/lean/blob/master/library/init/classical.lean#L160\">https://github.com/leanprover/lean/blob/master/library/init/classical.lean#L160</a></p>",
        "id": 133316001,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1536073473
    },
    {
        "content": "<p>This is in directory init of the core library, so you don't have to import anything, but it's in namespace <code>classical</code> so you need either open the namespace or use the full name</p>",
        "id": 133316038,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1536073535
    },
    {
        "content": "<p>Welcome to Lean! Figuring out the names of lemmas etc is still a bit of a dark art. Most of us are learning by asking lots of questions here. So feel free to ask more <span class=\"emoji emoji-1f603\" title=\"smiley\">:smiley:</span></p>",
        "id": 133316044,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536073545
    },
    {
        "content": "<p>Yes, welcome, and don't let constructivist Kenny scare you!</p>",
        "id": 133316100,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1536073573
    },
    {
        "content": "<p>Also, don't mind about Kenny. He doesn't like the stuff in <code>classical.lean</code>. But he's a nice guy if you ignore that bit <span class=\"emoji emoji-1f923\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 133316111,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536073611
    },
    {
        "content": "<p>See also <a href=\"http://avigad.github.io/logic_and_proof/classical_reasoning.html\" target=\"_blank\" title=\"http://avigad.github.io/logic_and_proof/classical_reasoning.html\">this discussion in the book \"Logic and Proof\"</a>.</p>",
        "id": 133316199,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1536073721
    },
    {
        "content": "<p>There's a subtle difference between constructive mathematics and constructive pedagogy.</p>",
        "id": 133316422,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536073927
    },
    {
        "content": "<p>But more generally, if you're looking for theorems that follow a particular pattern, you can try the <code>#find</code> command. e.g. </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">find</span>\n<span class=\"bp\">#</span><span class=\"n\">find</span>  <span class=\"o\">(</span><span class=\"bp\">¬</span> <span class=\"bp\">_</span> <span class=\"bp\">→</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">_</span>\n</pre></div>",
        "id": 133316638,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1536074178
    },
    {
        "content": "<p>Oh, that book looks great, maybe it should also be visible in the \"Documentation\" section of <a href=\"http://leanprover.github.io\" target=\"_blank\" title=\"http://leanprover.github.io\">leanprover.github.io</a> . I'll definitely give it a go! I came across this while trying to prove de morgan both ways, and turns out classical is indeed required :) <a href=\"https://math.stackexchange.com/questions/120187/do-de-morgans-laws-hold-in-propositional-intuitionistic-logic\" target=\"_blank\" title=\"https://math.stackexchange.com/questions/120187/do-de-morgans-laws-hold-in-propositional-intuitionistic-logic\">https://math.stackexchange.com/questions/120187/do-de-morgans-laws-hold-in-propositional-intuitionistic-logic</a></p>",
        "id": 133316668,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1536074217
    },
    {
        "content": "<p>You can PR that book to the documentation of mathlib, if you want (-;</p>",
        "id": 133316690,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536074261
    },
    {
        "content": "<p>How horrible is this proof? <span class=\"emoji emoji-1f61b\" title=\"mischievous\">:mischievous:</span></p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">de_morgan_1_a</span> <span class=\"o\">(</span><span class=\"n\">hnpnq</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">q</span><span class=\"o\">):</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">assume</span> <span class=\"o\">(</span><span class=\"n\">hpq</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">),</span>\n  <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"n\">hnpnq</span>\n    <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">hnp</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">,</span>\n      <span class=\"k\">show</span> <span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">hnp</span> <span class=\"n\">hpq</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">hnq</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">q</span><span class=\"o\">,</span>\n      <span class=\"k\">show</span> <span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">hnq</span> <span class=\"n\">hpq</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- only provable within classical logic!</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">de_morgan_1_b</span> <span class=\"o\">(</span><span class=\"n\">hnpq</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)):</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">q</span> <span class=\"o\">:=</span>\n  <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">by_contradiction</span>\n    <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">not_conclusion</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">q</span><span class=\"o\">),</span>\n      <span class=\"k\">have</span> <span class=\"n\">hpq</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">and</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n        <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">by_contradiction</span>\n          <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">hnp</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">,</span>\n            <span class=\"n\">not_conclusion</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">intro_left</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">hnp</span><span class=\"o\">)))</span>\n        <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">by_contradiction</span>\n          <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">hnq</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">q</span><span class=\"o\">,</span>\n            <span class=\"n\">not_conclusion</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">intro_right</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">hnq</span><span class=\"o\">))),</span>\n      <span class=\"k\">show</span> <span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">hnpq</span> <span class=\"n\">hpq</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">de_morgan_1</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">q</span> <span class=\"o\">:=</span>\n  <span class=\"c1\">-- annpoying having to specify p and q</span>\n  <span class=\"n\">iff</span><span class=\"bp\">.</span><span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"n\">de_morgan_1_b</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">de_morgan_1_a</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 133319056,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1536076592
    },
    {
        "content": "<p>it's alright</p>",
        "id": 133319479,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536077015
    },
    {
        "content": "<p>In the last theorem, you can use underscores instead of p's and q's if you want.</p>",
        "id": 133319596,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1536077149
    },
    {
        "content": "<p>It's so much easier and nicer to do it in tactic mode if you're going to spell it all out like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">de_morgan_1_a</span> <span class=\"o\">(</span><span class=\"n\">hnpnq</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">q</span><span class=\"o\">):</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hpq</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">hnpnq</span> <span class=\"k\">with</span> <span class=\"n\">hnp</span> <span class=\"n\">hnq</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">hnp</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hpq</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">hnq</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hpq</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 133319665,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536077195
    },
    {
        "content": "<p>You can see where you're going!</p>",
        "id": 133319673,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536077205
    },
    {
        "content": "<p>If you're going to do it in term mode you may as well just do</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">de_morgan_1_a</span> <span class=\"o\">(</span><span class=\"n\">hnpnq</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">q</span><span class=\"o\">):</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">hpq</span><span class=\"o\">,</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"n\">hnpnq</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">hnp</span><span class=\"o\">,</span> <span class=\"n\">hnp</span> <span class=\"n\">hpq</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">hnq</span><span class=\"o\">,</span> <span class=\"n\">hnq</span> <span class=\"n\">hpq</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 133319764,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536077310
    },
    {
        "content": "<p>yeah but you've already known Lean for a year</p>",
        "id": 133319796,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536077359
    },
    {
        "content": "<p>Kenny can you golf <code>de_morgan_1_b</code>?</p>",
        "id": 133319938,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536077477
    },
    {
        "content": "<p>oh it will already be in mathlib I guess</p>",
        "id": 133319954,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536077496
    },
    {
        "content": "<p>Thanks for the feedback! Haven't quite grasped tactics yet, so doing things explicitly for now</p>",
        "id": 133320201,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1536077752
    },
    {
        "content": "<p>tactics are the bomb if you're a learner. I don't know why they leave them so late in TPIL.</p>",
        "id": 133320295,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536077843
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">de_morgan_1_a</span> <span class=\"o\">(</span><span class=\"n\">hnpnq</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">q</span><span class=\"o\">):</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">⟨</span><span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">hq</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"n\">hnpnq</span> <span class=\"o\">(</span><span class=\"n\">absurd</span> <span class=\"n\">hp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">absurd</span> <span class=\"n\">hq</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>Mathlib's proof.</p>",
        "id": 133320299,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536077851
    },
    {
        "content": "<p>Absolutely terrifying for beginners :-)</p>",
        "id": 133320304,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536077872
    },
    {
        "content": "<p>The theorem is supposed to be constructing a proof of false from a proof of <code>p and q</code>, so the equation compiler matches the proof of <code>p and q</code> with a proof of p and a proof of q and then it's pretty much the same as before.</p>",
        "id": 133320377,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536077943
    },
    {
        "content": "<p>re: specifying p and q. How about this?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"c1\">-- trick for making variables implicit</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">de_morgan_1_a</span> <span class=\"o\">(</span><span class=\"n\">hnpnq</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">q</span><span class=\"o\">):</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">assume</span> <span class=\"o\">(</span><span class=\"n\">hpq</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">),</span>\n  <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"n\">hnpnq</span>\n    <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">hnp</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">,</span>\n      <span class=\"k\">show</span> <span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">hnp</span> <span class=\"n\">hpq</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">hnq</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">q</span><span class=\"o\">,</span>\n      <span class=\"k\">show</span> <span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">hnq</span> <span class=\"n\">hpq</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- only provable within classical logic!</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">de_morgan_1_b</span> <span class=\"o\">(</span><span class=\"n\">hnpq</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)):</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">q</span> <span class=\"o\">:=</span>\n  <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">by_contradiction</span>\n    <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">not_conclusion</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">q</span><span class=\"o\">),</span>\n      <span class=\"k\">have</span> <span class=\"n\">hpq</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">and</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n        <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">by_contradiction</span>\n          <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">hnp</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">,</span>\n            <span class=\"n\">not_conclusion</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">intro_left</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">hnp</span><span class=\"o\">)))</span>\n        <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">by_contradiction</span>\n          <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">hnq</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">q</span><span class=\"o\">,</span>\n            <span class=\"n\">not_conclusion</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">intro_right</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">hnq</span><span class=\"o\">))),</span>\n      <span class=\"k\">show</span> <span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">hnpq</span> <span class=\"n\">hpq</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">de_morgan_1</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">q</span> <span class=\"o\">:=</span>\n  <span class=\"c1\">-- no longer annpoying</span>\n  <span class=\"n\">iff</span><span class=\"bp\">.</span><span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"n\">de_morgan_1_b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">de_morgan_1_a</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 133320508,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536078112
    },
    {
        "content": "<p>Oh, that's nice! I missed that they can be made implicit globally<br>\nre: mathlib, i'll just quote TPIL: \"Once again, you should exercise judgment as to whether such abbreviations enhance or diminish readability.\"</p>",
        "id": 133320865,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1536078543
    },
    {
        "content": "<p>Instead of assuming classical logic, mathlib (in <code>logic/basic.lean</code>) just assumes decidability of <code>p</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">de_morgan_1_b</span> <span class=\"o\">(</span><span class=\"n\">hnpq</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">decidable</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">q</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"k\">then</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"n\">hnpq</span> <span class=\"bp\">⟨</span><span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">hq</span><span class=\"bp\">⟩</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">hp</span>\n</pre></div>",
        "id": 133320883,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536078566
    },
    {
        "content": "<p>my impression is that mathlib is not meant to be readable, they are looking for speed and breadth</p>",
        "id": 133320908,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536078594
    },
    {
        "content": "<p>Hm, more noob questions, what's the difference between classical logic and \"decidable p\"? Since LEM states that p is either true or false, isn't that effectively \"p is decidable\"?</p>",
        "id": 133321554,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1536079279
    },
    {
        "content": "<p>Here's a classical proof.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">de_morgan_1_b</span> <span class=\"o\">(</span><span class=\"n\">hnpq</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">q</span> <span class=\"o\">:=</span>\n<span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">(</span><span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">em</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"n\">hnpq</span> <span class=\"bp\">⟨</span><span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">hq</span><span class=\"bp\">⟩</span><span class=\"o\">)</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inl</span>\n</pre></div>",
        "id": 133321628,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536079349
    },
    {
        "content": "<p>Not quite, em means you know p is either true or false, decidable means you know which one.</p>",
        "id": 133321649,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1536079379
    },
    {
        "content": "<p>The classical proof gives this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">axioms</span> <span class=\"n\">de_morgan_1_b</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">classical.choice</span>\n<span class=\"cm\">quot.sound</span>\n<span class=\"cm\">propext</span>\n<span class=\"cm\">-/</span>\n</pre></div>\n\n\n<p>The decidable proof uses no \"maths axioms\"</p>",
        "id": 133321663,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536079401
    },
    {
        "content": "<p>As Chris says, assuming decidability is slightly stronger.  But to a mathematician like me they're all the same.</p>",
        "id": 133321725,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536079443
    },
    {
        "content": "<p>Furthermore they're all assumable without any worries :-)</p>",
        "id": 133321740,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536079468
    },
    {
        "content": "<p>Johannes Hoelzl once argued that trying to write as small proofs as possible was a good exercise.</p>",
        "id": 133321778,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536079519
    },
    {
        "content": "<p>Hello! Is there some way to use Lean without emacs or VisualStudio? Asking for CoqIde-like editor would be probably too much, but maybe there's some way to use Notepad or command line?</p>",
        "id": 134895335,
        "sender_full_name": "zaa",
        "timestamp": 1538253334
    },
    {
        "content": "<p>Sure, you can use command line, after editing your file in any editor you like</p>",
        "id": 134895390,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538253476
    },
    {
        "content": "<p>you can always use any editor to edit the file and then <code>lean --make</code> the file, although you won't be able to interact easilier</p>",
        "id": 134895434,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1538253500
    },
    {
        "content": "<p>In case you're not familiar, the Lean reference manual recommends use with Visual Studio Code, which is actually a completely separate IDE from Visual Studio, which is cross platform, simpler, etc. I personally find the experience using Lean in VSCode similar to using CoqIde</p>",
        "id": 134895437,
        "sender_full_name": "Scott Olson",
        "timestamp": 1538253505
    },
    {
        "content": "<p>(why isn't easilier a word?)</p>",
        "id": 134895439,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1538253510
    },
    {
        "content": "<p>Ok, then I will both try  Visual Studio Code and get used to <code>lean --make</code>.<br>\nThank you!</p>",
        "id": 134895493,
        "sender_full_name": "zaa",
        "timestamp": 1538253619
    },
    {
        "content": "<p>I'm not sure lean --make will be much fun, but I could imagine it would work. Two other possibilities are the Lean Web Editor, and CoCalc; these are both web-based ways to run Lean. I use unix and am quite anti-MS software in general (and they typically don't target my platform anyway) but actually I've had a very positive experience using VS code in linux. Emacs runs in a terminal window.</p>",
        "id": 134895899,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538254579
    },
    {
        "content": "<blockquote>\n<p>Lean: Error: Command failed: lean --version 'lean' is not recognized as an internal or external command, operable program or batch file.</p>\n</blockquote>\n<p>Trying to run Lean extension in VSCode. I have added both necessary paths to PATH, but, it seems, i'm missing something else.</p>",
        "id": 134896721,
        "sender_full_name": "zaa",
        "timestamp": 1538256279
    },
    {
        "content": "<p>maybe you have a space in your path</p>",
        "id": 134896868,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1538256608
    },
    {
        "content": "<p>It's working now, yay. I just closed and reopened VSCode.</p>",
        "id": 134897137,
        "sender_full_name": "zaa",
        "timestamp": 1538257268
    },
    {
        "content": "<blockquote>\n<p>(why isn't easilier a word?)</p>\n</blockquote>\n<p>I think it's because it's an adverb not an adjective. Off the top of my head, I can't think of any English adverbs that can be suffixed with -er.</p>",
        "id": 134897811,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1538258880
    },
    {
        "content": "<p>Does Lean have a tactic similar to Omega in coq?</p>",
        "id": 134918464,
        "sender_full_name": "zaa",
        "timestamp": 1538305121
    },
    {
        "content": "<p>I believe the answer is \"not yet\". I know nothing about Coq but I've heard people talk about Omega. Can you briefly describe what it does? Another noob question :-)</p>",
        "id": 134918538,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538305315
    },
    {
        "content": "<p>We have <code>linarith</code> and <code>cc</code>.</p>",
        "id": 134918579,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538305357
    },
    {
        "content": "<p>I think omega is <code>cooper</code></p>",
        "id": 134918645,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538305522
    },
    {
        "content": "<p>It solves goals in Presburger arithmetic. Equalities containing only addition and substraction (and multiplication by constant, ofc).</p>\n<p>For example: 8n = 4m+3 -&gt; False</p>",
        "id": 134918695,
        "sender_full_name": "zaa",
        "timestamp": 1538305631
    },
    {
        "content": "<p>what do you use it for? is it just divisibility goals like that one?</p>",
        "id": 134918764,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538305795
    },
    {
        "content": "<p>Oh, it seems to work with inequalities too. Will test on Coq a bit, as I have already forgotten things.</p>",
        "id": 134918822,
        "sender_full_name": "zaa",
        "timestamp": 1538305888
    },
    {
        "content": "<p>no, my question is when do you think \"I should use omega\"</p>",
        "id": 134918871,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538306003
    },
    {
        "content": "<p>I know about presburger arithmetic but I think it's probably a bit too wide a target - I doubt people really need the crazy quantifier complexity part</p>",
        "id": 134918911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538306069
    },
    {
        "content": "<p><a href=\"https://coq.inria.fr/refman/addendum/omega.html\" target=\"_blank\" title=\"https://coq.inria.fr/refman/addendum/omega.html\">https://coq.inria.fr/refman/addendum/omega.html</a> - found the documentation.<br>\nThere's an example:<br>\nz &gt; 0 -&gt; 2 * z + 1 &gt; z</p>\n<p>As far as i can remember, I mostly used it for goals like<br>\n[inequality/equality] -&gt; [another one] -&gt; x = something<br>\nor A &lt;= x &lt;= B<br>\nor maybe False</p>",
        "id": 134918966,
        "sender_full_name": "zaa",
        "timestamp": 1538306221
    },
    {
        "content": "<p><code>cooper</code> is a tactic for presburger arithmetic written in lean by Seul Baek, but I don't think it is ready for production</p>",
        "id": 134919013,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538306329
    },
    {
        "content": "<blockquote>\n<p><a href=\"https://coq.inria.fr/refman/addendum/omega.html\" target=\"_blank\" title=\"https://coq.inria.fr/refman/addendum/omega.html\">https://coq.inria.fr/refman/addendum/omega.html</a> - found the documentation.</p>\n</blockquote>\n<p>Oh thank you! I know nothing about Coq or where to look for this stuff.</p>",
        "id": 134920434,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538309543
    },
    {
        "content": "<p>Yes, that's the website where it lives. I had fun with Coq for some time but paused it some year ago (will return to it soon, probably simultaneously to more serious lean learning).</p>",
        "id": 134936881,
        "sender_full_name": "zaa",
        "timestamp": 1538343393
    },
    {
        "content": "<p>Next noob question:<br>\nIs there some simple example/tutorial of quotient types - how to define and use them?</p>",
        "id": 134937308,
        "sender_full_name": "zaa",
        "timestamp": 1538344296
    },
    {
        "content": "<p>There is a section in TPIL: <a href=\"https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#quotients\" target=\"_blank\" title=\"https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#quotients\">https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#quotients</a></p>",
        "id": 134937617,
        "sender_full_name": "Reid Barton",
        "timestamp": 1538344886
    },
    {
        "content": "<p>For a real-world example you can take a look at <code>linear_algebra.quotient_module</code></p>",
        "id": 134937730,
        "sender_full_name": "Reid Barton",
        "timestamp": 1538345105
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 134937793,
        "sender_full_name": "zaa",
        "timestamp": 1538345203
    },
    {
        "content": "<p><a href=\"#narrow/stream/116395-maths/topic/teaching.20use.20of.20quotients.20in.20Lean\" title=\"#narrow/stream/116395-maths/topic/teaching.20use.20of.20quotients.20in.20Lean\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/teaching.20use.20of.20quotients.20in.20Lean</a></p>",
        "id": 134939308,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538348412
    },
    {
        "content": "<p>I wrote <a href=\"https://github.com/kbuzzard/xena/blob/master/xenalib/m1f/zmod37.lean\" target=\"_blank\" title=\"https://github.com/kbuzzard/xena/blob/master/xenalib/m1f/zmod37.lean\">https://github.com/kbuzzard/xena/blob/master/xenalib/m1f/zmod37.lean</a> specifically to help some of my students to learn about using quotients in Lean.</p>",
        "id": 134939327,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538348466
    },
    {
        "content": "<p>Using my old thread for more noob questions:<br>\nCan I use something like <code>cases</code> but without stating the hypothesis name? Namely, I'd like a tactic that splits conjunctions into two hypotheses and disjunctions into two goals. More generally, how does one go about searching for tactics that do something?</p>",
        "id": 136428236,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1540406441
    },
    {
        "content": "<p><code>split</code> will split goals.</p>",
        "id": 136428440,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1540406644
    },
    {
        "content": "<p>Yep, sorry I should've specified - I want to split hypotheses.</p>",
        "id": 136428479,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1540406710
    },
    {
        "content": "<p>Like <code>have h1 := h.left, have h2 := h.right</code>?</p>",
        "id": 136428496,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1540406744
    },
    {
        "content": "<p>And now you want to do that automatically for all hypotheses, recursively?</p>",
        "id": 136428503,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1540406760
    },
    {
        "content": "<p><code>cases</code> does both of those things already, so I guess you mean something that applies <code>cases</code> automatically?</p>",
        "id": 136428549,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540406770
    },
    {
        "content": "<p>Yep, that would be for ANDs, but without stating what the name is, and also do it for ORs (in which case two  or more goals would appear). Yep, automatically and recursively.</p>",
        "id": 136428563,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1540406795
    },
    {
        "content": "<p>I think the answer to the more general question is \"read through <a href=\"https://github.com/leanprover/mathlib/blob/master/docs/tactics.md\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/master/docs/tactics.md\">https://github.com/leanprover/mathlib/blob/master/docs/tactics.md</a>, and then look through <code>tactic.interactive</code> in mathlib and more generally the rest of <code>tactic.*</code> to find more things\"</p>",
        "id": 136428584,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540406821
    },
    {
        "content": "<p><code>tidy</code> does things like this; it tries a bunch of different tactics in a loop, one of which is <code>auto_cases</code></p>",
        "id": 136428667,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540406887
    },
    {
        "content": "<p>That looks about right, thanks!</p>",
        "id": 136428862,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1540407113
    },
    {
        "content": "<p><code>safe</code> will do this, and a bit more. I think it should be less aggressive than <code>tidy</code>.</p>",
        "id": 136429144,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1540407337
    },
    {
        "content": "<p>Oh damn, it just solves everything by itself O.o</p>",
        "id": 136430875,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1540409134
    },
    {
        "content": "<p>c.f. <code>auto_cases</code></p>",
        "id": 136531665,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1540540498
    },
    {
        "content": "<p>More questions!<br>\nWhat's the syntax for matching on inductive constructors by name? E.g. for list, something like <code>Nil =&gt; 0, Cons(hd, tl) =&gt; 1 + (len tl)</code> would be a Rust way to define <code>len</code> recursively</p>",
        "id": 137094276,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1541208917
    },
    {
        "content": "<p>Do you mean something like this?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">len</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">len</span> <span class=\"n\">b</span>\n</pre></div>",
        "id": 137094949,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1541210215
    },
    {
        "content": "<p>Yep that's it - thanks!</p>",
        "id": 137095066,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1541210457
    },
    {
        "content": "<p>Ignore me, mixed up my languages.</p>",
        "id": 137121205,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1541265365
    },
    {
        "content": "<p>Is there any reason why <code>fin</code> and <code>multiset</code> don't support the <code>{1, 2, 3}</code> notation that <code>set</code> does? What's the best way to construct concrete <code>finset</code>s?</p>",
        "id": 137123573,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1541270226
    },
    {
        "content": "<p>Do you want a type or a set?</p>",
        "id": 137123629,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541270301
    },
    {
        "content": "<p>You need <code>decidable_eq α</code> to use that notation for <code>finset α</code>.</p>",
        "id": 137123686,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541270406
    },
    {
        "content": "<p>For multisets this works for me without any decidability assumptions</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">}</span>\n</pre></div>",
        "id": 137123713,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541270500
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> a concrete set, say <code>{v}</code> for some given <code>v: \\a</code><br>\n<span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> ah indeed, why does <code>set</code> not require it then?</p>",
        "id": 137123720,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1541270521
    },
    {
        "content": "<p>They notation is for <code>has_insert.insert</code> <br>\nFor sets <code>insert a s := {b : α | b = a ∨ b ∈ s}</code>, and there's no decidable equality required.</p>\n<p>For finsets, there has to be an underlying list with no duplicates, so it has to check whether <code>a</code> is already in the set, which requires <code>decidable_eq</code></p>",
        "id": 137123840,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541270724
    },
    {
        "content": "<p>Then given a singleton set, how can I extract the element? I tried folding it into a list to grab the first element, but <code>fold</code> requires commutativity and <code>list.append</code> is not commutative.</p>",
        "id": 137125503,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1541273626
    },
    {
        "content": "<p>Do you have a proof that it's a singleton? I think there's a PR about finite unique computable choice.</p>",
        "id": 137125773,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541274042
    },
    {
        "content": "<p>Yeah, i'm grabbing it under the assumption that <code>card vals = 1</code>.</p>",
        "id": 137125848,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1541274147
    },
    {
        "content": "<p>do you need it to be computable? You can use <code>finset.exists_mem_of_ne_empty</code> if you don't. Do you need the fact that everything in the singleton is equal?</p>",
        "id": 137126149,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541274620
    },
    {
        "content": "<p>I think <code>exists_mem_of_ne_empty</code> will work. thx!</p>",
        "id": 137126804,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1541275794
    },
    {
        "content": "<p>So now i'm seeing a really strange error when trying to decompose the <code>Exists</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">constant</span> <span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kn\">constant</span> <span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"kn\">constant</span> <span class=\"n\">as</span><span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">as</span> <span class=\"c1\">-- Prop</span>\n<span class=\"kn\">constant</span> <span class=\"n\">ex</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">as</span>\n<span class=\"n\">def</span> <span class=\"n\">test</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">ex</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"c1\">-- induction tactic failed, recursor &#39;Exists.dcases_on&#39; can only eliminate into Prop</span>\n  <span class=\"mi\">0</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 137127553,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1541276997
    },
    {
        "content": "<p>The recursor only eliminates into prop and your goal is a type</p>",
        "id": 137128633,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541279063
    },
    {
        "content": "<p>so the recursor cannot be applied</p>",
        "id": 137128637,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541279086
    },
    {
        "content": "<p>Yep, I just realised this. Basically, i'm trying to extract a concrete value of the type <code>\\a</code> from a proof of existence. But I guess this could only work in purely constructionist logic?</p>",
        "id": 137128659,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1541279133
    },
    {
        "content": "<p>There are tools in the classical namespace which should let you do this</p>",
        "id": 137128709,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541279206
    },
    {
        "content": "<p>You shouldn't use constants by the way, you should use variables -- they work a bit better and there's less risk</p>",
        "id": 137128711,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541279221
    },
    {
        "content": "<p>Oh yeah, that was just to make the example code short</p>",
        "id": 137128760,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1541279336
    },
    {
        "content": "<p>It should be possible to define the function you want constructively, but it hasn't been done yet.</p>",
        "id": 137128774,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541279388
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finset</span>\n<span class=\"kn\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"kn\">variable</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"kn\">variable</span> <span class=\"o\">{</span><span class=\"n\">as</span><span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">as</span> <span class=\"c1\">-- Prop</span>\n<span class=\"kn\">variable</span> <span class=\"n\">ex</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">as</span>\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">ex</span>\n</pre></div>",
        "id": 137128815,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541279407
    },
    {
        "content": "<p>Right -- this noncomputable approach works for any existence statement. But I now understand that in the specific case of finsets you might be able to do better.</p>",
        "id": 137128832,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541279470
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/mathlib/pull/421\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/pull/421\">This is the relevant PR</a>, right?</p>",
        "id": 137128834,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1541279479
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finset</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">as</span><span class=\"o\">)</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">ex</span>\n</pre></div>\n\n\n<p>Shorter and no constants ;-)</p>",
        "id": 137128879,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541279547
    },
    {
        "content": "<p>Also works with <code>constants</code>, but fair enough :)<br>\nAnyhow, I need it to be computable because I want to extract concrete elements from concrete sets and do things with them</p>",
        "id": 137129014,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1541279820
    },
    {
        "content": "<p>something that almost works:</p>",
        "id": 137129717,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541281149
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finset</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm_singleton</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">~</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">])</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">generalize_hyp</span> <span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">S</span> <span class=\"n\">at</span> <span class=\"n\">H</span> <span class=\"err\">⊢</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">case</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm</span><span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm</span><span class=\"bp\">.</span><span class=\"n\">skip</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span> <span class=\"n\">H</span> <span class=\"n\">ih</span> <span class=\"o\">{</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm_nil</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">refl</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm</span><span class=\"bp\">.</span><span class=\"n\">swap</span> <span class=\"o\">{</span> <span class=\"n\">injections</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">:</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span> <span class=\"n\">L₃</span> <span class=\"n\">H12</span> <span class=\"n\">H23</span> <span class=\"n\">ih1</span> <span class=\"n\">ih2</span> <span class=\"o\">{</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">ih2</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">ih1</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">refl</span>\n  <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n\n<span class=\"n\">def</span> <span class=\"n\">extract</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">s</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">hrec_on</span> <span class=\"n\">m</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">L</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">cases_on</span> <span class=\"n\">L</span>\n      <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">hcard</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">absurd</span> <span class=\"n\">hcard</span> <span class=\"n\">dec_trivial</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">hcard</span><span class=\"o\">,</span> <span class=\"n\">hd</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span> <span class=\"n\">HL</span><span class=\"o\">,</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">hfunext</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"bp\">_</span> <span class=\"err\">$</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">sound</span> <span class=\"n\">HL</span><span class=\"o\">)</span> <span class=\"err\">$</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">hnd1</span> <span class=\"n\">hnd2</span> <span class=\"n\">hheq</span><span class=\"o\">,</span> <span class=\"k\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">L₂</span><span class=\"o\">,</span>\n  <span class=\"n\">case</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm_nil</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">HL</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">hd₂</span> <span class=\"n\">tl₂</span> <span class=\"o\">{</span>\n    <span class=\"n\">cases</span> <span class=\"n\">L₁</span><span class=\"o\">,</span>\n    <span class=\"n\">case</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm_nil</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">HL</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"n\">case</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">hd₁</span> <span class=\"n\">tl₁</span> <span class=\"o\">{</span>\n      <span class=\"n\">apply</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">hfunext</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">card_def</span><span class=\"o\">,</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"o\">],</span>\n        <span class=\"n\">rw</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">sound</span> <span class=\"n\">HL</span> <span class=\"o\">},</span>\n      <span class=\"n\">intros</span> <span class=\"n\">hcard₁</span> <span class=\"n\">hcard₂</span> <span class=\"n\">hheq</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card_eq_one</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hcard₁</span> <span class=\"k\">with</span> <span class=\"n\">x₁</span> <span class=\"n\">hx₁</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card_eq_one</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hcard₂</span> <span class=\"k\">with</span> <span class=\"n\">x₂</span> <span class=\"n\">hx₂</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm_singleton</span> <span class=\"o\">(</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">exact</span> <span class=\"n\">hx₁</span><span class=\"o\">),</span>\n      <span class=\"n\">cases</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm_singleton</span> <span class=\"o\">(</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">exact</span> <span class=\"n\">hx₂</span><span class=\"o\">),</span>\n      <span class=\"n\">cases</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm_singleton</span> <span class=\"n\">HL</span><span class=\"o\">,</span>\n      <span class=\"n\">refl</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">}</span>\n<span class=\"kn\">end</span><span class=\"o\">))</span> <span class=\"n\">hs</span>\n</pre></div>",
        "id": 137129718,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541281151
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> can you fix this?</p>",
        "id": 137129720,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541281156
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">singleton</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">rec_on_subsingleton</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">nodup</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">nodup</span> <span class=\"n\">t</span><span class=\"o\">),</span>\n    <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">{</span><span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">nodup</span> <span class=\"o\">:=</span> <span class=\"n\">nodup</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">//</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">t</span> <span class=\"n\">nodup</span> <span class=\"bp\">=</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">singleton</span> <span class=\"n\">a</span><span class=\"o\">})</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">funext</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">funext</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"err\">$</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">singleton_inj</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"err\">$</span>\n        <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">]))</span><span class=\"bp\">⟩</span><span class=\"o\">)</span> <span class=\"n\">s</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">no_confusion</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">have</span> <span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ_inj</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">eq_of_veq</span> <span class=\"err\">$</span> <span class=\"k\">by</span> <span class=\"n\">dsimp</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">length_eq_zero</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">this</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">refl</span><span class=\"bp\">⟩</span><span class=\"o\">))</span> <span class=\"o\">)</span>\n</pre></div>",
        "id": 137130012,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541281786
    },
    {
        "content": "<p>Not very pretty</p>",
        "id": 137130013,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541281801
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finset</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm_singleton</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">~</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">])</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">generalize_hyp</span> <span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">S</span> <span class=\"n\">at</span> <span class=\"n\">H</span> <span class=\"err\">⊢</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">case</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm</span><span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm</span><span class=\"bp\">.</span><span class=\"n\">skip</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span> <span class=\"n\">H</span> <span class=\"n\">ih</span> <span class=\"o\">{</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm_nil</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">refl</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm</span><span class=\"bp\">.</span><span class=\"n\">swap</span> <span class=\"o\">{</span> <span class=\"n\">injections</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">:</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span> <span class=\"n\">L₃</span> <span class=\"n\">H12</span> <span class=\"n\">H23</span> <span class=\"n\">ih1</span> <span class=\"n\">ih2</span> <span class=\"o\">{</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">ih2</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">ih1</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">refl</span>\n  <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n\n<span class=\"n\">def</span> <span class=\"n\">extract</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">s</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">m</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">L</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"k\">show</span> <span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">cases_on</span> <span class=\"n\">L</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">absurd</span> <span class=\"n\">H</span> <span class=\"n\">dec_trivial</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">hd</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span> <span class=\"n\">HL</span><span class=\"o\">,</span> <span class=\"k\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">H1</span> <span class=\"n\">H2</span><span class=\"o\">,</span> <span class=\"n\">rcases</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">length_eq_one</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">H2</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">x₂</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm_singleton</span> <span class=\"n\">HL</span><span class=\"o\">,</span> <span class=\"n\">refl</span>\n<span class=\"kn\">end</span><span class=\"o\">))</span> <span class=\"n\">hs</span>\n</pre></div>\n\n\n<p>my version</p>",
        "id": 137130057,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541281806
    },
    {
        "content": "<p>well yours is much shorter</p>",
        "id": 137130058,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541281815
    },
    {
        "content": "<p>clever use of subsingleton...</p>",
        "id": 137130070,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541281850
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">extract_mem</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">extract</span> <span class=\"n\">s</span> <span class=\"n\">hs</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">m</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">m</span> <span class=\"k\">with</span> <span class=\"n\">L</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">L</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">hs</span> <span class=\"o\">},</span>\n  <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">refl</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 137130125,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541281970
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128280\">@Wojciech Nawrocki</span> so we have 2 solutions now</p>",
        "id": 137130137,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541282009
    },
    {
        "content": "<p>(i.e. mine and Chris's solution)</p>",
        "id": 137130139,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541282016
    },
    {
        "content": "<p>Oh wow, these are quite complex! I wonder if i should have just used lists instead :P but thanks a lot</p>",
        "id": 137130206,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1541282130
    },
    {
        "content": "<p>related: <a href=\"https://github.com/leanprover/mathlib/pull/421\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/pull/421\">https://github.com/leanprover/mathlib/pull/421</a></p>",
        "id": 146838268,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541468228
    },
    {
        "content": "<p>When a goal contains a reducible definition, how can i expand it to work with the internals? Namely, in here:</p>\n<div class=\"codehilite\"><pre><span></span>  <span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">reducible</span><span class=\"o\">]</span>\n  <span class=\"n\">def</span> <span class=\"n\">compose_partial</span> <span class=\"o\">(</span><span class=\"n\">f₁</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span><span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n    <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">cases_on</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">none</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f₂</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n\n  <span class=\"kn\">notation</span> <span class=\"o\">[</span><span class=\"n\">parsing_only</span><span class=\"o\">]</span> <span class=\"n\">a</span> <span class=\"bp\">`⬝</span><span class=\"err\">ₚ</span><span class=\"bp\">`</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">compose_partial</span> <span class=\"n\">b</span> <span class=\"n\">a</span>\n\n  <span class=\"kn\">theorem</span> <span class=\"n\">compose_none</span> <span class=\"o\">(</span><span class=\"n\">f₁</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span><span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">f₁</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">none</span><span class=\"o\">)</span>\n    <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"bp\">⬝</span><span class=\"err\">ₚ</span> <span class=\"n\">f₁</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"o\">:=</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">sorry</span>\n  <span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>I would like to expand <code>compose_partial</code> to carry through the <code>none</code> and get back a <code>none</code>.</p>",
        "id": 147370525,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1541769404
    },
    {
        "content": "<p>You can use <code>unfold compose_partial</code>. <code>simp [compose_partial]</code> or <code>dsimp [compose_partial]</code> can also be useful.</p>",
        "id": 147370813,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1541769720
    },
    {
        "content": "<p>Ah, <code>unfold</code>. Thanks!</p>",
        "id": 147370896,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1541769801
    },
    {
        "content": "<p><code>@[reducible]</code> means that the typeclass system will automatically unfold it</p>",
        "id": 147375089,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541773960
    },
    {
        "content": "<p>but only the typeclass system</p>",
        "id": 147375094,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541773966
    },
    {
        "content": "<p>How can I make an instance of a dependent product <code>(x, p x)</code> where <code>p</code> is some proposition depending on <code>x</code>? Lean complains about impredicativity:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">h</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"err\">?</span><span class=\"n\">m_1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span>\n</pre></div>",
        "id": 147889775,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1542485341
    },
    {
        "content": "<p>use <code>subtype</code></p>",
        "id": 147889850,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1542485458
    },
    {
        "content": "<p>If you're using <code>prod</code>, it won't work because it's non dependent and it doesn't accept Propositions.</p>",
        "id": 147889862,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1542485492
    },
    {
        "content": "<p>Parentheses are only for <code>prod</code>, yeah</p>",
        "id": 147889863,
        "sender_full_name": "Reid Barton",
        "timestamp": 1542485503
    },
    {
        "content": "<p>Oh I see, thanks!</p>",
        "id": 147890136,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1542486059
    },
    {
        "content": "<p><code>prod</code> is non-dependent <code>sigma</code></p>",
        "id": 147890301,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1542486427
    },
    {
        "content": "<p>but if it's proposition then you're better off using <code>subtype</code> which is a sort of specialize <code>sigma</code></p>",
        "id": 147890303,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1542486454
    },
    {
        "content": "<p>Given an inductive type with some variants that take arguments, e.g.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">Foo</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Foo</span>\n<span class=\"bp\">|</span> <span class=\"n\">B</span><span class=\"o\">:</span> <span class=\"n\">Foo</span>\n</pre></div>\n\n\n<p>Is there a better way of saying that a particular <code>x: Foo</code> was constructed by <code>A</code> regardless of what the argument was than <code>\\ex n: nat, x = A n</code>?</p>",
        "id": 147932778,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1542578178
    },
    {
        "content": "<p>I don't think so. \"x was constructed by A and I don't know what the argument was\" is <em>exactly</em> <code>\\ex n: nat, x = A n</code>, right? What's wrong with this way of saying it?</p>",
        "id": 147933315,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1542579357
    },
    {
        "content": "<p>Other approaches</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"n\">B</span>     <span class=\"o\">:=</span> <span class=\"n\">false</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 147933417,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1542579594
    },
    {
        "content": "<p>That first one is a much better way :-) I don't understand the second one!</p>",
        "id": 147933471,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1542579672
    },
    {
        "content": "<p>Hm, I guess it might just be nice to have a shorthand like <code>p</code> in Chris's example for when the constructor is unwieldy, e.g. has lots of arguments. <code>p</code> would sound better as e.g. <code>is_A</code></p>",
        "id": 147933521,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1542579763
    },
    {
        "content": "<p>The second one is an inductive proposition. I think you need <code>inductive</code> instead of <code>def</code>. This seems like the \"canonical\" way to me, and you can easily prove it equivalent to one using exists.</p>",
        "id": 147933522,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1542579776
    },
    {
        "content": "<p>The inductive one gives you a nice recursor.</p>",
        "id": 147933585,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1542579950
    },
    {
        "content": "<p>Is there another typo in the second one? I'm trying to figure out how to use it and I'm getting <code>unknown identifier 'n'</code></p>",
        "id": 147934065,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1542580974
    },
    {
        "content": "<p>It should look like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Foo</span>\n<span class=\"bp\">|</span> <span class=\"n\">B</span><span class=\"o\">:</span> <span class=\"n\">Foo</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">is_A</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">of_A</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">is_A</span> <span class=\"o\">(</span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">A</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 147934438,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1542581298
    },
    {
        "content": "<p>The idea being, <code>Foo.is_A</code> is a family of propositions. For any <code>n : nat</code>, <code>Foo.is_A.of_A n</code> is a proof of <code>Foo.is_A (Foo.A n)</code>.</p>",
        "id": 147934446,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1542581347
    },
    {
        "content": "<p>Thanks! I'd tried adding <code>n</code> after <code>bar</code> and I forgot that the parentheses were necessary.</p>",
        "id": 147934510,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1542581500
    }
]
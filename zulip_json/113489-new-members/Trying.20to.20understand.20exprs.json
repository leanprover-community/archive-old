[
    {
        "content": "<p>Hi,</p>\n<p>I'm trying to develop a deeper understanding of expr. Would it be fair to say that the following expressions are equivalent?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"mi\">1</span><span class=\"o\">},</span> <span class=\"n\">α</span>\n<span class=\"k\">#check</span> <span class=\"n\">expr.lam</span> <span class=\"o\">(</span><span class=\"n\">mk_simple_name</span> <span class=\"s2\">\"α\"</span><span class=\"o\">)</span> <span class=\"n\">binder_info.implicit</span> <span class=\"o\">(</span><span class=\"n\">expr.sort</span> <span class=\"bp\">$</span> <span class=\"n\">level.succ</span> <span class=\"n\">level.zero</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">expr.var</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I'm surprised to find that they don't type check to the same thing.</p>",
        "id": 236353228,
        "sender_full_name": "Joe Palermo",
        "timestamp": 1619535771
    },
    {
        "content": "<p>An expression is a meta object in the sense that it is how Lean internally represents things.  So the second is the internal representation of the first.  They are related but not the same.  For example, the first one has type <code>Type -&gt; Type</code> (or at least a type equal to that) and the second has type <code>expr tt</code> (which is the same as <code>expr</code> since the <code>tt</code> is an optional parameter which defaults to true).  Note, you can change the first to be an<code> expr</code> with the <a href=\"https://leanprover-community.github.io/extras/tactic_writing.html#marios-backtick-cheat-sheet\">backquote trick</a>:  See here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">This</span> <span class=\"n\">has</span> <span class=\"n\">type</span> <span class=\"kt\">Type</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span>\n<span class=\"k\">#check</span> <span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"mi\">1</span><span class=\"o\">},</span> <span class=\"n\">α</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"mi\">1</span><span class=\"o\">},</span> <span class=\"n\">α</span><span class=\"o\">)</span>                 <span class=\"bp\">#</span> <span class=\"n\">this</span> <span class=\"n\">has</span> <span class=\"n\">type</span> <span class=\"bp\">`</span><span class=\"n\">reflected</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">},</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">`</span> <span class=\"n\">which</span> <span class=\"n\">can</span> <span class=\"n\">be</span> <span class=\"n\">lifted</span> <span class=\"n\">to</span> <span class=\"bp\">`</span><span class=\"n\">expr</span><span class=\"bp\">`</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"mi\">1</span><span class=\"o\">},</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span>   <span class=\"bp\">#</span> <span class=\"n\">Here</span>  <span class=\"n\">we</span> <span class=\"n\">lift</span> <span class=\"n\">it</span> <span class=\"n\">to</span> <span class=\"n\">expr</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"mi\">1</span><span class=\"o\">},</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_raw_fmt.to_string</span>   <span class=\"bp\">#</span> <span class=\"n\">we</span> <span class=\"n\">can</span> <span class=\"n\">see</span> <span class=\"n\">this</span> <span class=\"n\">is</span> <span class=\"n\">the</span> <span class=\"n\">desired</span> <span class=\"n\">expression</span>\n</code></pre></div>",
        "id": 236364884,
        "sender_full_name": "Jason Rute",
        "timestamp": 1619539542
    },
    {
        "content": "<p>Yes I would say the expr on the second line represents the way you've defined a term on the first. But the second is only a syntactic representation so the two lines don't have the same type, as the first is some thing in the type theory, whereas the second is the internal way lean builds these terms.<br>\nIndeed if you reflect the first line to an expr using <code>`(term)</code>, you can check that they are equal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">to_bool</span> <span class=\"o\">((</span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"mi\">1</span><span class=\"o\">},</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">expr.lam</span> <span class=\"o\">(</span><span class=\"n\">mk_simple_name</span> <span class=\"s2\">\"α\"</span><span class=\"o\">)</span> <span class=\"n\">binder_info.implicit</span> <span class=\"o\">(</span><span class=\"n\">expr.sort</span> <span class=\"bp\">$</span> <span class=\"n\">level.succ</span> <span class=\"n\">level.zero</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">expr.var</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 236364893,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1619539544
    },
    {
        "content": "<p>Thanks that helps <span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span></p>",
        "id": 236390099,
        "sender_full_name": "Joe Palermo",
        "timestamp": 1619549724
    },
    {
        "content": "<p>So I see now that you can take a term and convert it into an expr by reflecting and lifting it. Can you reverse this process, and turn it back into a term?</p>",
        "id": 236392316,
        "sender_full_name": "Joe Palermo",
        "timestamp": 1619550653
    },
    {
        "content": "<p><code>reflect</code> will do that for some types</p>",
        "id": 236392550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619550748
    },
    {
        "content": "<p>er, it depends on what you mean by \"term\"</p>",
        "id": 236392643,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619550792
    },
    {
        "content": "<p>for me \"term\" = expr</p>",
        "id": 236392671,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619550804
    },
    {
        "content": "<p>I guess you mean the other direction, which means evaluating an expression into a given type. This is also only possible for some types but can be done using <code>eval_expr</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.numerals</span> <span class=\"n\">false</span>\n<span class=\"k\">#eval</span> <span class=\"n\">trace</span> <span class=\"o\">(</span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"mi\">23</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">):</span><span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"c1\">-- bit1 (bit1 (bit1 (bit0 has_one.one)))</span>\n<span class=\"k\">#eval</span> <span class=\"n\">trace</span> <span class=\"o\">(</span><span class=\"n\">reflect</span> <span class=\"mi\">23</span><span class=\"o\">)</span> <span class=\"c1\">-- bit1 (bit1 (bit1 (bit0 has_one.one)))</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">do</span>\n  <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">←</span> <span class=\"n\">eval_expr</span> <span class=\"n\">ℕ</span> <span class=\"o\">(</span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"mi\">23</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">):</span><span class=\"n\">expr</span><span class=\"o\">),</span>\n  <span class=\"n\">guard</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">23</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 236393576,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619551215
    },
    {
        "content": "<p>Perhaps what I'm asking doesn't even make sense, but what I'm really asking is if one can take </p>\n<p><code>(`(λ {α : Sort 1}, α) : expr)</code></p>\n<p>and reverse the reflection + lifting to get back:</p>\n<p><code>λ {α : Sort 1}, α</code></p>",
        "id": 236399403,
        "sender_full_name": "Joe Palermo",
        "timestamp": 1619553802
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 236400227,
        "sender_full_name": "Joe Palermo",
        "timestamp": 1619554156
    },
    {
        "content": "<p>In this case, I don't think so.  First, you would have to know the type, which is <code>(Type -&gt; Type)</code> and but I don't think <code>eval_expr</code> works with abstract types like that.  Here is code which doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n<span class=\"k\">#eval</span> <span class=\"k\">do</span>\n  <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">eval_expr</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"mi\">1</span><span class=\"o\">},</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">),</span>  <span class=\"c1\">-- doesn't work</span>\n  <span class=\"n\">return</span> <span class=\"o\">()</span>\n</code></pre></div>\n<p>The problem is that <code>Type -&gt; Type</code> is not reflectable.  Without getting into the details, these are the sort of types that you can serialize into concrete data, like <code>nat</code>, or <code>list bool</code>.  An abstract type like <code>Type -&gt; Type</code> isn't going to work.</p>",
        "id": 236414759,
        "sender_full_name": "Jason Rute",
        "timestamp": 1619559439
    },
    {
        "content": "<p>Having said that, you are barking up the wrong tree.  If I can read past your questions, I think you want to take an expression which is stored in a file and check that it is a valid proof.  If that is correct, you can do that with <code>infer_type</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"mi\">1</span><span class=\"o\">},</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">),</span>\n  <span class=\"n\">tp</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">tactic.infer_type</span> <span class=\"n\">e</span><span class=\"o\">,</span>  <span class=\"c1\">-- this is valid</span>\n  <span class=\"n\">tactic.trace</span> <span class=\"n\">tp</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">expr.lam</span> <span class=\"o\">(</span><span class=\"n\">mk_simple_name</span> <span class=\"s2\">\"α\"</span><span class=\"o\">)</span> <span class=\"n\">binder_info.implicit</span> <span class=\"o\">(</span><span class=\"n\">expr.sort</span> <span class=\"bp\">$</span> <span class=\"n\">level.succ</span> <span class=\"n\">level.zero</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">expr.var</span> <span class=\"n\">tt</span> <span class=\"mi\">0</span><span class=\"o\">)),</span>\n  <span class=\"n\">tp</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">tactic.infer_type</span> <span class=\"n\">e</span><span class=\"o\">,</span>  <span class=\"c1\">-- this is valid</span>\n  <span class=\"n\">tactic.trace</span> <span class=\"n\">tp</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">expr.lam</span> <span class=\"o\">(</span><span class=\"n\">mk_simple_name</span> <span class=\"s2\">\"α\"</span><span class=\"o\">)</span> <span class=\"n\">binder_info.implicit</span> <span class=\"o\">(</span><span class=\"n\">expr.sort</span> <span class=\"bp\">$</span> <span class=\"n\">level.succ</span> <span class=\"n\">level.zero</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">expr.var</span> <span class=\"n\">tt</span> <span class=\"mi\">1</span><span class=\"o\">)),</span>\n  <span class=\"n\">tp</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">tactic.infer_type</span> <span class=\"n\">e</span><span class=\"o\">,</span>  <span class=\"c1\">-- this is not valid, so it fails at this line</span>\n  <span class=\"n\">tactic.trace</span> <span class=\"n\">tp</span>\n</code></pre></div>",
        "id": 236415634,
        "sender_full_name": "Jason Rute",
        "timestamp": 1619559929
    },
    {
        "content": "<p>I don't know how <code>#check</code> works exactly, but I'm pretty sure it uses <code>infer_type</code> or similar underneath.</p>",
        "id": 236415779,
        "sender_full_name": "Jason Rute",
        "timestamp": 1619559998
    },
    {
        "content": "<p>For your sort of projects, it is fine to work with expressions, instead of the objects they encode.</p>",
        "id": 236416042,
        "sender_full_name": "Jason Rute",
        "timestamp": 1619560146
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span>. I was asking more out of pure curiosity than anything else, but yes that's right.</p>",
        "id": 236417448,
        "sender_full_name": "Joe Palermo",
        "timestamp": 1619560966
    },
    {
        "content": "<p>Sorry, I likely jumped to the wrong conclusion then.</p>",
        "id": 236418804,
        "sender_full_name": "Jason Rute",
        "timestamp": 1619561820
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> No worries, it made me think and these examples are very helpful to see. Much appreciated.</p>",
        "id": 236522383,
        "sender_full_name": "Joe Palermo",
        "timestamp": 1619622136
    },
    {
        "content": "<p>Actually I'm wondering how make this one typecheck:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">expr.lam</span> <span class=\"o\">(</span><span class=\"n\">mk_simple_name</span> <span class=\"s2\">\"b\"</span><span class=\"o\">)</span> <span class=\"n\">binder_info.implicit</span> <span class=\"o\">(</span><span class=\"n\">expr.const</span> <span class=\"n\">bool</span> <span class=\"o\">[])</span>\n            <span class=\"o\">(</span><span class=\"n\">expr.app</span>\n              <span class=\"o\">(</span><span class=\"n\">expr.app</span>\n              <span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"o\">(</span><span class=\"n\">expr.const</span> <span class=\"n\">eq.mp</span> <span class=\"o\">[</span><span class=\"n\">level.zero</span><span class=\"o\">])</span>\n                <span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"o\">(</span><span class=\"n\">expr.const</span> <span class=\"n\">not</span> <span class=\"o\">[])</span> <span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"o\">(</span><span class=\"n\">expr.const</span> <span class=\"n\">eq</span> <span class=\"o\">[</span><span class=\"n\">level.succ</span> <span class=\"n\">level.zero</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">expr.const</span> <span class=\"n\">bool</span> <span class=\"o\">[]))</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">expr.var</span> <span class=\"n\">tt</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">expr.const</span> <span class=\"n\">bool.tt</span> <span class=\"o\">[]))))</span>\n              <span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"o\">(</span><span class=\"n\">expr.const</span> <span class=\"n\">eq</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">expr.const</span> <span class=\"n\">bool</span> <span class=\"o\">[]))</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">expr.var</span> <span class=\"n\">tt</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">expr.const</span> <span class=\"n\">bool.ff</span> <span class=\"o\">[])))</span>\n              <span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"o\">(</span><span class=\"n\">expr.const</span> <span class=\"n\">eq_ff_eq_not_eq_tt</span> <span class=\"o\">[])</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">expr.var</span> <span class=\"n\">tt</span> <span class=\"mi\">0</span><span class=\"o\">)))),</span>\n  <span class=\"n\">tp</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">tactic.infer_type</span> <span class=\"n\">e</span><span class=\"o\">,</span>  <span class=\"c1\">-- this is valid</span>\n  <span class=\"n\">tactic.trace</span> <span class=\"n\">tp</span>\n</code></pre></div>\n<p>Lean is complaining about the use of expr.const for some reason. Btw this proof corresponds to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">},</span> <span class=\"bp\">@</span><span class=\"n\">eq.mp.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">not</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">eq.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">bool</span> <span class=\"n\">b</span> <span class=\"n\">bool.tt</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">eq.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">bool</span> <span class=\"n\">b</span> <span class=\"n\">bool.ff</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq_ff_eq_not_eq_tt</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I simply printed this proof in raw_fmt, added expr prefixes and copied a few other things from the previous example (like using \"@expr.var tt 0\" instead of \"expr.var 0\") to try and get it to type check.</p>",
        "id": 236526923,
        "sender_full_name": "Joe Palermo",
        "timestamp": 1619623333
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/expr.const\">docs#expr.const</a> needs a name as input whereas you are providing the literal term, you just have to prefix everything with a backtick to make this work though</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"k\">#eval</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">expr.lam</span> <span class=\"o\">(</span><span class=\"n\">mk_simple_name</span> <span class=\"s2\">\"b\"</span><span class=\"o\">)</span> <span class=\"n\">binder_info.implicit</span> <span class=\"o\">(</span><span class=\"n\">expr.const</span> <span class=\"bp\">`</span><span class=\"n\">bool</span> <span class=\"o\">[])</span>\n            <span class=\"o\">(</span><span class=\"n\">expr.app</span>\n              <span class=\"o\">(</span><span class=\"n\">expr.app</span>\n              <span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"o\">(</span><span class=\"n\">expr.const</span> <span class=\"bp\">`</span><span class=\"n\">eq.mp</span> <span class=\"o\">[</span><span class=\"n\">level.zero</span><span class=\"o\">])</span>\n                <span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"o\">(</span><span class=\"n\">expr.const</span> <span class=\"bp\">`</span><span class=\"n\">not</span> <span class=\"o\">[])</span> <span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"o\">(</span><span class=\"n\">expr.const</span> <span class=\"bp\">`</span><span class=\"n\">eq</span> <span class=\"o\">[</span><span class=\"n\">level.succ</span> <span class=\"n\">level.zero</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">expr.const</span> <span class=\"bp\">`</span><span class=\"n\">bool</span> <span class=\"o\">[]))</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">expr.var</span> <span class=\"n\">tt</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">expr.const</span> <span class=\"bp\">`</span><span class=\"n\">bool.tt</span> <span class=\"o\">[]))))</span>\n              <span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"o\">(</span><span class=\"n\">expr.const</span> <span class=\"bp\">`</span><span class=\"n\">eq</span> <span class=\"o\">[</span><span class=\"n\">level.succ</span> <span class=\"n\">level.zero</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">expr.const</span> <span class=\"bp\">`</span><span class=\"n\">bool</span> <span class=\"o\">[]))</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">expr.var</span> <span class=\"n\">tt</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">expr.const</span> <span class=\"bp\">`</span><span class=\"n\">bool.ff</span> <span class=\"o\">[])))</span>\n              <span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"o\">(</span><span class=\"n\">expr.const</span> <span class=\"bp\">`</span><span class=\"n\">eq_ff_eq_not_eq_tt</span> <span class=\"o\">[])</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">expr.var</span> <span class=\"n\">tt</span> <span class=\"mi\">0</span><span class=\"o\">)))),</span>\n  <span class=\"n\">tp</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">tactic.infer_type</span> <span class=\"n\">e</span><span class=\"o\">,</span>  <span class=\"c1\">-- this is valid</span>\n  <span class=\"n\">tactic.trace</span> <span class=\"n\">tp</span>\n</code></pre></div>",
        "id": 236590938,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1619649332
    }
]
[
    {
        "content": "<p>I'm trying to fill out a proof that ℕ  is a preorder, using as much of ℕ  as I can:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.group_with_zero.defs</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">init.meta.tactic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nat_le_trans</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">nat.le_trans</span>\n<span class=\"k\">#check</span> <span class=\"n\">nat.le_trans</span> <span class=\"c1\">-- ?M_1 ≤ ?M_2 → ?M_2 ≤ ?M_3 → ?M_1 ≤ ?M_3</span>\n<span class=\"k\">#check</span> <span class=\"n\">nat_le_trans</span> <span class=\"c1\">-- nat_le_trans : ∀ (a b c : ℕ), a ≤ b → b ≤ c → a ≤ c</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">nat.lt_iff_le_not_le</span> <span class=\"c1\">-- ?M_1 &lt; ?M_2 ↔ ?M_1 ≤ ?M_2 ∧ ¬?M_2 ≤ ?M_1</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nat_lt_iff_le_not_le</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">.</span> <span class=\"n\">order_laws_tac</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">),</span>\n  <span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"n\">nat.le_refl</span><span class=\"o\">,</span>\n  <span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"n\">nat_le_trans</span><span class=\"o\">,</span>\n  <span class=\"n\">lt_iff_le_not_le</span> <span class=\"o\">:=</span> <span class=\"n\">nat_lt_iff_le_not_le</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>There are a few issues:</p>\n<ol>\n<li>I have to sugar <code>nat.le_trans</code> because it is not exactly in the form called for by </li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">preorder</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_lt</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lt</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lt_iff_le_not_le</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">.</span> <span class=\"n\">order_laws_tac</span><span class=\"o\">)</span>\n</code></pre></div>\n<ol start=\"2\">\n<li>I don't know what <code>. order_laws_tac</code> does in a definition.  I don't know where in TPIL to find the <code> . </code> notation for propositions.  I don't understand the definition of</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">order_laws_tac</span> <span class=\"o\">:=</span> <span class=\"n\">whnf_target</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">intros</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">to_expr</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"n\">iff.refl</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">exact</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">whnf_target</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">target</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">whnf</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">change</span>\n</code></pre></div>\n<p><code>meta</code> occurs once in section 5.5 of TPIL and in the <a href=\"https://leanprover.github.io/reference/lean_reference.pdf\">Lean reference manual</a>  it says \"see chapter 7\" which is basically a blank page.  The meta language looks like a macro language.</p>\n<p>The <a href=\"https://leanprover-community.github.io/mathlib_docs/init/algebra/order.html#preorder\">web page</a>  is not helpful because it states the axiom as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">lt_iff_le_not_le</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span><span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">.</span> <span class=\"s2\">\"order_laws_tac\"</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which clearly conveys that <code>(∀ (a b : α), a &lt; b ↔ a ≤ b ∧ ¬b ≤ a) . \"order_laws_tac\"</code> is a proposition that gets macro-expanded somehow.  But <code>order_laws_tac</code> appears to be a recipe for proving a proposition, it is not the statement of a proposition, so I am stuck.</p>\n<ol start=\"3\">\n<li>Even with the <code>sorry</code>s and what looks otherwise like correct form, the above doesn't work  It breaks at</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">nat_lt_iff_le_not_le</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">.</span> <span class=\"n\">order_laws_tac</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n<p>As always I would greatly appreciate some help on showing that ℕ  is a preorder.</p>",
        "id": 219895033,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607976321
    },
    {
        "content": "<p>Have you tried removing the <code>. order_laws_tac</code> from that lemma statement?</p>",
        "id": 219895588,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1607976677
    },
    {
        "content": "<p>Basically, you've already correctly inferred the answer to most of your questions.</p>",
        "id": 219895657,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1607976710
    },
    {
        "content": "<p><code>.</code> is a way to provide a recipe to automatically fill in the answer.</p>",
        "id": 219895721,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1607976726
    },
    {
        "content": "<p>So you can just leave out the <code>lt_iff_le_not_le</code> field completely, and move on.</p>",
        "id": 219895742,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1607976743
    },
    {
        "content": "<p>DONE</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.basic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nat_le_trans</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">nat.le_trans</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">),</span>\n  <span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"n\">nat.le_refl</span><span class=\"o\">,</span>\n  <span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"n\">nat_le_trans</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>PR for <code>preorder</code>?</p>",
        "id": 219897554,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607977689
    },
    {
        "content": "<p>Nope?</p>",
        "id": 219897620,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1607977727
    },
    {
        "content": "<p>Sorry, why do you think this is not yet in mathlib?</p>",
        "id": 219897648,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1607977743
    },
    {
        "content": "<p>I'm honestly confused.</p>",
        "id": 219897663,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1607977749
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">directed_order.to_preorder : preorder ℕ</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 219900555,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1607979305
    },
    {
        "content": "<p>What is the recommended way to express the following? It says that, for any fixed <code>n</code>, <code>fin n</code> is a partial order, in 4 different ways:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.basic</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">fin_n_partial_order</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">subtype.partial_order</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fin_n_partial_order1</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">subtype.partial_order</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fin_n_partial_order2</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">subtype.partial_order</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">,</span> <span class=\"n\">partial_order</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">subtype.partial_order</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 219906386,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607982330
    },
    {
        "content": "<p>There's already a <code>partial_order</code> instance on <code>fin n</code> for all <code>n</code>, so we would ordinarily just rely on type class inference to get this.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">apply_instance</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">partial_order</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">λ (n : ℕ), semilattice_inf.to_partial_order (fin n) : Π (n : ℕ), partial_order (fin n)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 219906858,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1607982589
    },
    {
        "content": "<p>Thanks, I didn't know I could put a quantifier in <code>apply_instance</code>, that's good to know.</p>",
        "id": 219906974,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607982637
    },
    {
        "content": "<p>Even if you couldn't, you could just use <code>\\lam _, by apply_instance</code></p>",
        "id": 219907077,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607982711
    },
    {
        "content": "<p>If you're trying to find an instance for something, my process is usually along the lines of:</p>\n<ul>\n<li>Assume you already have it (ie, just use <code>mul_add</code> and assume a <code>distrib</code> instance will be found)</li>\n<li>Use <code>by apply_instance</code> with <code>#check</code> or <code>have : distrib T :=</code> just to double check the problem isn't something else (if that succeeds, it is)</li>\n<li>Try to find the file you'd expect to find the instance in, to work out what assumption you're missing</li>\n<li>Ask zulip to help with the above, or tell you that it doesn't exist</li>\n</ul>",
        "id": 219907600,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607982970
    }
]
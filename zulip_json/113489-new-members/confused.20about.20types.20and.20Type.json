[
    {
        "content": "<p>I noticed a similarity between:</p>\n<p>(in Init/Control/State.lean)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">StateT</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">σ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and:</p>\n<p>(in Init/Prelude.lean)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n<span class=\"bp\">...</span>\n<span class=\"sd\">/-- An implementation of [ReaderT](https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html#t:ReaderT) -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">ReaderT</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">ρ</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>Based on <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html\">https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html</a>, I read <code>(α × σ)</code> to be syntax for creating an instance of <code>Prod; however, I can rewrite </code>StateT` slightly differently like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">StateT'</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">σ</span>\n  <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">p</span>\n</code></pre></div>\n<p>Can someone explain how this use of product above differs from that in <code>MonadStateOf.modifyGet</code>:</p>\n<p>(in Init/Prelude.lean)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">MonadStateOf</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> Obtain the top-most State of a Monad stack. -/</span>\n  <span class=\"n\">get</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">σ</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> Set the top-most State of a Monad stack. -/</span>\n  <span class=\"n\">set</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">PUnit</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> Map the top-most State of a Monad stack.</span>\n\n<span class=\"cm\">     Note: `modifyGet f` may be preferable to `do s &lt;- get; let (a, s) := f s; put s; pure a`</span>\n<span class=\"cm\">     because the latter does not use the State linearly (without sufficient inlining). -/</span>\n  <span class=\"n\">modifyGet</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">Prod</span> <span class=\"n\">α</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span>\n</code></pre></div>",
        "id": 290035654,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1658186393
    },
    {
        "content": "<p>Just to be clear, in the above, my brain fails to comprehend how the typechecker is OK with: <code>let p : Type u := α × σ</code></p>",
        "id": 290035821,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1658186519
    },
    {
        "content": "<p>It's ok because <code>α × σ : Type u</code>. Take a look at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Prod#doc\">docs4#Prod</a>, which says that given <code>α : Type u</code> and <code>β : Type v</code> then <code>α × β : Type (max u v)</code>. For the particular example, there's a rule that <code>Type (max u u)</code> is <code>Type u</code>.</p>",
        "id": 290036208,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658186858
    },
    {
        "content": "<p>If you're wondering about <code>Prod</code> rather than using notation, by the way, it's because notation isn't introduced until <a href=\"https://github.com/leanprover/lean4/blob/f6b6b36f47909fe8a089c16efdb87372154e7efa/src/Init/Notation.lean#L76\">here</a></p>",
        "id": 290036286,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658186916
    },
    {
        "content": "<p>When you say \"I read <code>(α × σ)</code> to be syntax for creating an instance of <code>Prod</code>\", it's not that it creating <em>a</em> <code>Prod α σ</code>, it's that it <em>is</em> <code>Prod α σ</code>. The notation to create a term of <code>Prod α σ</code> is <code>(x, y)</code>. (The word \"instance\" isn't precise here.)</p>",
        "id": 290036441,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658187041
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"362579\">Nicolas Rouquette</span> <a href=\"#narrow/stream/113489-new-members/topic/confused.20about.20types.20and.20Type/near/290035821\">said</a>:</p>\n<blockquote>\n<p>Just to be clear, in the above, my brain fails to comprehend how the typechecker is OK with: <code>let p : Type u := α × σ</code></p>\n</blockquote>\n<p>This suggests you had a different type in mind, what were you expecting it to be?</p>",
        "id": 290037483,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1658187791
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> for your cogent explanation.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris Bailey</span> <a href=\"#narrow/stream/113489-new-members/topic/confused.20about.20types.20and.20Type/near/290037483\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"362579\">Nicolas Rouquette</span> <a href=\"#narrow/stream/113489-new-members/topic/confused.20about.20types.20and.20Type/near/290035821\">said</a>:</p>\n<blockquote>\n<p>Just to be clear, in the above, my brain fails to comprehend how the typechecker is OK with: <code>let p : Type u := α × σ</code></p>\n</blockquote>\n<p>This suggests you had a different type in mind, what were you expecting it to be?</p>\n</blockquote>\n<p>Something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">StateT''</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Prod</span> <span class=\"n\">σ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">σ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This does not compute in Lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">σ</span><span class=\"o\">)</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">σ</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">σ</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n</code></pre></div>\n<p>Although I understand <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> 's explanation at a logical level, I have difficulty getting an intuitive understanding about the following:</p>\n<ul>\n<li>When different expressions that are structurally different yield the same type -- e..g. <code>(α × σ)</code> and <code>α</code> in the above have type <code>Type u</code></li>\n<li>When structurally different expressions require a correspondingly specific type -- e.g. <code>MonadStateOf.modifyGet</code> argument must be a function of type <code>σ → Prod α σ</code>; it would be quite a different API if the argument where typed <code>Prod α σ → σ</code>.</li>\n</ul>",
        "id": 290038701,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1658188861
    },
    {
        "content": "<p>Evergreen diagram: <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Prop.20.3A.3D.20Sort.200.20Motivation/near/252362723\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/.E2.9C.94.20Prop.20.3A.3D.20Sort.200.20Motivation/near/252362723</a></p>",
        "id": 290039772,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1658189965
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/confused.20about.20types.20and.20Type/near/290036208\">said</a>:</p>\n<blockquote>\n<p>It's ok because <code>α × σ : Type u</code>. Take a look at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Prod#doc\">docs4#Prod</a>, which says that given <code>α : Type u</code> and <code>β : Type v</code> then <code>α × β : Type (max u v)</code>. For the particular example, there's a rule that <code>Type (max u u)</code> is <code>Type u</code>.</p>\n</blockquote>\n<p>Where is this rule?</p>\n<p>Inspired by <span class=\"user-mention\" data-user-id=\"228466\">@Chris Bailey</span> 's suggestion, I asked Lean for the type of various terms:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"k\">#check</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n<span class=\"c1\">-- Type u → Type v : Type (max (u + 1) (v + 1))</span>\n\n<span class=\"k\">#check</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">×</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n<span class=\"c1\">-- Type u × Type u → Type v : Type (max (u + 1) (v + 1))</span>\n</code></pre></div>\n<p>Although I couldn't find this rule; I hope we can use it show that these terms have the same type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Can we prove that these two types are equivalent using the rule that Type (max u u) = Type u?</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">×</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 290139955,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1658254722
    },
    {
        "content": "<p>With <code>max u u</code>, what you need to know is that <code>u</code> stands for a universe level variable, whose value is a natural number (not a Lean <code>nat</code>, but the natural numbers as part of the underlying theory), and like usual <code>max u v</code> is just the max of these two numbers. That's why <code>max u u</code> is <code>u</code>.</p>",
        "id": 290143276,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658256323
    },
    {
        "content": "<p>The rule about <code>Type (max u u)</code> is part of the type theory, for which people usually link <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">Mario Carneiro's thesis</a> as a reference. Said rule is on page 6. Definitional equality for elements of <code>Sort</code> is by antisymmetry on their universe level.</p>\n<p>Your second example doesn't say what you think it does, it posits that <code>(Type u → Type v) = (Type u × Type u → Type v) </code>, not that their types are equal. What you're asking is basically this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"c1\">-- Type u → Type v : Type (max (u + 1) (v + 1))</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">×</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"c1\">-- Type u × Type u → Type v : Type (max (u + 1) (v + 1))</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 290143527,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1658256443
    },
    {
        "content": "<p>The statement <code>(Type u → Type v) = (Type u × Type u → Type v)</code> is not provable (so, as good as not being true), but since it typechecks it means the left-hand and right-hand sides have the exact same types.</p>",
        "id": 290143532,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658256446
    },
    {
        "content": "<p>Hum.... let me try to explain the original problem differently.</p>\n<p>In programming with Scala, it is very helpful to keep the Curry-Howard correspondence in mind: with reasonably-specified function signatures, one can focus on the types of the arguments and result to get an idea about what it can possibly do.</p>\n<p>With Scala, CH might be perhaps simpler than with Lean because Scala has only types and terms whereas Lean4 has sorts, types and terms.</p>\n<p>From this perspective, I am interested in understanding a small excerpt of functions defined in Lean's prelude and init library:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">confused</span>\n\n<span class=\"c1\">-- renamed the ρ argument to σ so as to emphasize the similarity with StateT.</span>\n<span class=\"kd\">def</span> <span class=\"n\">ReaderT</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">StateT</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">σ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">confused</span>\n</code></pre></div>\n<p>First, I was really puzzled to see that <code>ReaderT</code> and <code>StateT</code> have the same kind of arguments yet their right-hand side terms are clearly different. Since these functions are defined over sorts, not types, it seems to suggest that it is more appropriate to compare their sort-based signatures.  As <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> explained: <code>α × σ : Type u</code> so both <code>m α</code> and <code>m (α × σ)</code> have the same sort <code>Type v</code>.</p>\n<p>However, given that </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n<span class=\"c1\">-- Type u → Type v : Type (max (u + 1) (v + 1))</span>\n</code></pre></div>\n<p>I would have expected the result to have type <code>Type (max (u + 1) (v + 1))</code> instead of just <code>Type (max u v)</code>. What am I missing here?</p>\n<p>Second, it seems that it is crucial to appreciate the difference between sort and types when comparing <code>α</code> and <code>α × σ</code>.<br>\nSame sort: <code>Type u</code>; different types: <code>α</code> and <code>α × σ</code>.</p>\n<p>Third, it seems that one can further constrain arguments/results in Lean4 as evidence in the difference between <code>StateT.run</code> and <code>StateT.run'</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">confused</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">StateT</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">σ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[inline]</span> <span class=\"kd\">def</span> <span class=\"n\">StateT.run</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">StateT</span> <span class=\"n\">σ</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">x</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">@[inline]</span> <span class=\"kd\">def</span> <span class=\"n\">StateT.run'</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">StateT</span> <span class=\"n\">σ</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">x</span> <span class=\"n\">s</span>\n\n<span class=\"c1\">-- from Init/Control/Lawful.lean</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">run'_eq</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">StateT</span> <span class=\"n\">σ</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">run'</span> <span class=\"n\">x</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">run</span> <span class=\"n\">x</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">confused</span>\n</code></pre></div>\n<p>I am confused why <code>StateT.run</code> and <code>StateT.run'</code> have different types: <code>m (α × σ)</code> vs. <code>m α</code>.</p>\n<p>I tried to copy the <code>run'_eq</code> theorem in this confused sandbox but I get errors that only increase my state of confusion:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- about: run' x s</span>\n<span class=\"n\">function</span> <span class=\"n\">expected</span> <span class=\"n\">at</span>\n  <span class=\"n\">run'</span>\n<span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.512</span>\n\n<span class=\"c1\">-- about: (·.1)</span>\n<span class=\"n\">invalid</span> <span class=\"n\">field</span> <span class=\"kd\">notation</span><span class=\"o\">,</span> <span class=\"n\">type</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">form</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"bp\">...</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">C</span> <span class=\"n\">is</span> <span class=\"n\">a</span> <span class=\"kd\">constant</span>\n  <span class=\"n\">a</span><span class=\"bp\">✝</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.571</span>\n\n<span class=\"c1\">-- about: run x s</span>\n<span class=\"n\">function</span> <span class=\"n\">expected</span> <span class=\"n\">at</span>\n  <span class=\"n\">run</span>\n<span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.546</span>\n</code></pre></div>\n<p>Fourth, I managed to rewrite <code>StateT.run'</code> to make the functor explicit:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[inline]</span> <span class=\"kd\">def</span> <span class=\"n\">StateT.run''</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">:</span> <span class=\"n\">Functor</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">StateT</span> <span class=\"n\">σ</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">pair</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"n\">s</span>\n  <span class=\"n\">F.map</span> <span class=\"n\">Prod.fst</span> <span class=\"n\">pair</span>\n</code></pre></div>\n<p>I would have liked to make a variant of the <code>run'_eq</code> theorem for this but given that the mere copy/paste does not work; I am not sure how to proceed.</p>\n<p>Fifth, assuming that <code>StateT.run''</code> is equivalent to <code>StateT.run'</code>, I would like to understand how it is possible that <code>m</code> appears in two different types:</p>\n<ul>\n<li><code>m α</code></li>\n<li><code>m (α × σ)</code></li>\n</ul>\n<p>Is there a simple example of using <code>StateT.run</code> and <code>StateT.run'</code> that could help shed light on what kind of thing is <code>m</code>?</p>",
        "id": 290307128,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1658355545
    },
    {
        "content": "<blockquote>\n<p>I would have expected the result to have type Type (max (u + 1) (v + 1)) instead of just Type (max u v). What am I missing here?</p>\n</blockquote>\n<p>The definition of <code>ReaderT</code> has that <code>σ → m α : Type (max u v)</code>, and your <code>#check</code> says that <code>Type u → Type v : Type (max (u + 1) (v + 1))</code>. There's nothing inconsistent here since in the first case you have the type of functions between types, and in the second you have the type of functions between universes (what you're calling sorts). (Universes are types, too, in Lean, so it makes sense to have functions between them.)</p>",
        "id": 290307535,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658355829
    },
    {
        "content": "<p>The difference between <code>StateT.run</code> and <code>StateT.run'</code> is that <code>StateT.run'</code> does <code>fmap prod.fst (x s)</code> rather than just <code>x s</code> (if I expanded out that notation correctly).</p>",
        "id": 290307933,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658356033
    },
    {
        "content": "<blockquote>\n<p>I tried to copy the run'_eq theorem</p>\n</blockquote>\n<p>This doesn't work because the place you got it from was inside a <code>namespace</code>. Try changing <code>run'</code> and <code>run</code> to <code>StateT.run</code> and <code>StateT.run'</code>, which hopefully is enough.</p>",
        "id": 290308068,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658356127
    },
    {
        "content": "<p>If you're getting really confused about type universes, I suggest that for now you just pretend that <code>Type u</code> is <code>Type</code> everywhere. The algorithm you were looking at earlier should still work under this assumption.</p>",
        "id": 290308280,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658356259
    },
    {
        "content": "<p>I believe that if you made your own copy of <code>StateT</code> and the rest with all the type universes replaced with <code>Type</code> it should all still work.</p>\n<p>All this universe polymorphism isn't usually important when writing programs, but it's great that it's there when you need it.</p>",
        "id": 290308434,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658356354
    }
]
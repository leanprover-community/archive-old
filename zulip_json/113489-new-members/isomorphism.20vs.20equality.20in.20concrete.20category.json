[
    {
        "content": "<p>I've been trying to prove the following fact:</p>\n<p>Consider the category of Types. This has a (cartesian) monoidal structure, and thus has a left unitor <br>\n<code>λ_ A : 𝟙_ (Type u) ⊗ A ≅ A</code>. I'd like to prove that <code>(λ_ A).hom (punit.star,a) = a</code> for all <code>a : A</code>. </p>\n<p>Unfortunately, I'm running into an issue: the statement I wrote above won't type check, because the type <br>\n<code>𝟙_ (Type u) ⊗ A</code>, which is defined to be <code>𝟙_ (Type u) \\X A</code> is not definitionally equal to the cartesian product <code>𝟙_ (Type u) \\x A</code>. In fact, the one with the big X is isomorphic to the one with the little x, but they aren't definitionally equal. </p>\n<p>I can try to fix this by using <code>equiv_rw</code> to make the type checker happy. However, when I try to prove my statement about elements, I have no idea what to do. </p>\n<p>In fact, somewhere under the covers, the definition of <code>(λ_ A)</code> comes down to <code>prod.snd</code>, but this is also defined across an isomorphism--in fact, it's the same isomorphism that I'm using <code>equiv_rw</code> on. Lean doesn't seem to know this though.</p>\n<p>It feels like there should be a better approach. Can anyone give me some pointers?</p>\n<p>Here's the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.closed.cartesian</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.types</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.shapes.types</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.types</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory.limits</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory.limits.types</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory.concrete_category</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">monoidal_category</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">monoidal_of_has_finite_products</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">type_prod_iso_monoidal_prod</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⊗</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">≅</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">types.binary_product_iso</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">terminal_iso_punit</span> <span class=\"o\">:</span> <span class=\"mi\">𝟙</span><span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">≅</span> <span class=\"n\">punit</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">terminal_iso</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">lcomb_correct_type</span>\n<span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">punit</span> <span class=\"bp\">×</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">lcomb</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">_</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"o\">,</span>\n  <span class=\"n\">equiv_rw</span> <span class=\"o\">[</span><span class=\"n\">iso.to_equiv</span> <span class=\"o\">(</span><span class=\"n\">type_prod_iso_monoidal_prod</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span><span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"n\">A</span><span class=\"o\">)]</span>\n    <span class=\"n\">at</span> <span class=\"n\">lcomb</span><span class=\"o\">,</span>\n  <span class=\"n\">equiv_rw</span> <span class=\"o\">[</span><span class=\"n\">iso.to_equiv</span> <span class=\"n\">terminal_iso_punit</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">lcomb</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">lcomb</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">elementwise_lcomb</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">lcomb_correct_type</span> <span class=\"o\">(</span><span class=\"n\">punit.star</span><span class=\"o\">,</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">step</span> <span class=\"o\">:</span> <span class=\"n\">lcomb_correct_type</span> <span class=\"bp\">=</span> <span class=\"n\">prod.snd</span><span class=\"o\">,</span>\n    <span class=\"kd\">begin</span>\n      <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">--???</span>\n    <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">step</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 290974429,
        "sender_full_name": "Jack J Garzella",
        "timestamp": 1658883225
    },
    {
        "content": "<p>It seems that you defined things in a fairly non-optimal way. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.closed.cartesian</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.types</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.shapes.types</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.types</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory.limits</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory.limits.types</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory.concrete_category</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">monoidal_category</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">monoidal_of_has_finite_products</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">punit_prod_iso</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">punit</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"n\">A</span> <span class=\"bp\">≅</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">types.binary_product_iso</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">≪≫</span> <span class=\"n\">tensor_iso</span> <span class=\"n\">terminal_iso.symm</span> <span class=\"o\">(</span><span class=\"n\">iso.refl</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">≪≫</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">_</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">elementwise_lcomb</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">punit_prod_iso</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span> <span class=\"o\">(</span><span class=\"n\">punit.star</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">punit_prod_iso</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 290979602,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658888211
    }
]
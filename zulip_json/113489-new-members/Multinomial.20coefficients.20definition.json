[
    {
        "content": "<p>Below a definition for <a href=\"https://en.wikipedia.org/wiki/Multinomial_theorem#Multinomial_coefficients\">multinomial coefficients</a> with the multiplicative defintion (rather than the recursive one)</p>\n<p>A general question of \"Does this look okay?\" as well as the more specific:</p>\n<p>Is the convention to use a finsupp because any function from \\alpha would be finsupp, or is the convention to use something else (function, fun_like?), because it would automatically be finsupp?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finsupp.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>  <span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">factorial</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">*∏</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">choose</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">j</span> <span class=\"k\">in</span> <span class=\"o\">{</span><span class=\"n\">j'</span> <span class=\"bp\">∈</span> <span class=\"n\">fintype.elems</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">j'</span> <span class=\"bp\">≤</span> <span class=\"n\">i</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 292812185,
        "sender_full_name": "Pim Otte",
        "timestamp": 1660157303
    },
    {
        "content": "<p>I actually switched to function since I managed to make that work first with the defintion of the multinomial theorem I was trying to formulate. </p>\n<p>Does the following look okay? The main thing I'm kind of doubting are the explicit coercions.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finsupp.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>  <span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">factorial</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">*∏</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">choose</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">j</span> <span class=\"k\">in</span> <span class=\"o\">{</span><span class=\"n\">j'</span> <span class=\"bp\">∈</span> <span class=\"n\">fintype.elems</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">j'</span> <span class=\"bp\">≤</span> <span class=\"n\">i</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial_theorem</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)),</span> <span class=\"n\">ite</span> <span class=\"o\">((</span><span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">comm_ring.nat_cast</span> <span class=\"o\">(</span><span class=\"n\">multinomial</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">fin.coe_embedding</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">i</span><span class=\"o\">)))</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"bp\">∏</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">fin.coe_embedding</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">i</span><span class=\"o\">))))</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 292824976,
        "sender_full_name": "Pim Otte",
        "timestamp": 1660162161
    },
    {
        "content": "<p>There are several problems with this definition:</p>\n<ol>\n<li>I think <code>factorial n</code> shouldn't be there, and the argument <code>n</code> is not necessary.</li>\n<li>This definition of <code>multinomial</code> only works with <code>[linear_order α]</code>; <code>has_le</code> is insufficient. You may take <code>α</code> to be <code>fin m</code> for <code>m := fintype.card α</code>, but that's less flexible. Since the multinomial coefficient doesn't really depend on the choice of an order, I suggest you use an order-independent definition. Your definition could become a lemma and serves as a nice formula to calculate it when there's a linear order.</li>\n<li><code>fintype.elems α</code> is usually written <code>finset.univ</code>.</li>\n</ol>",
        "id": 293418203,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660494369
    },
    {
        "content": "<p>Here are three definitions I came up with, and I like the last one because it's the shortest and doesn't have the <code>fintype</code> restriction, and could be used to state a multinomial theorem in e.g. a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mv_power_series\">docs#mv_power_series</a> ring; I'm not sure what the statement should be, but at least this definition realizes the coefficients of (X1+X2+X3+...)^n as multinomial coefficients. However, we have to use <code>multiset α ≃ (α →₀ ℕ)</code> to connect it to mv_power_series and to your <code>choose</code> formula; the third definition uses finsupp instead of multiset, so it's more directly connected to mv_power_series, but <code>(finsupp.sum f $ λ _, id)</code> is slightly awkward.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finsupp.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finite.card</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">finset.univ.filter</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">nat.card</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span>\n<span class=\"c1\">-- This will be zero if `n ≠ ∑ a, f a`.</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial'</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">finset.univ.filter</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">nat.card</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial''</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat.card</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">finsupp.sum</span> <span class=\"n\">f</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">nat.card</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial'''</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat.card</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">s.card</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">nat.card</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">s.count</span> <span class=\"n\">a</span><span class=\"o\">}</span>\n<span class=\"c1\">-- notice that `multiset α ≃ (α →₀ ℕ)`; could also use `multiset.has_coe_to_sort`.</span>\n</code></pre></div>",
        "id": 293420597,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660495729
    },
    {
        "content": "<p>Thanks so much, this is extremely helpful! I'm not quite familiar with the \"//\" operator, what's it called/is there some documentation on it?</p>",
        "id": 293421188,
        "sender_full_name": "Pim Otte",
        "timestamp": 1660496052
    },
    {
        "content": "<p><code>//</code> is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subtype\">docs#subtype</a>.</p>",
        "id": 293421249,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660496093
    },
    {
        "content": "<p>Just came up to me, this def may be nicer:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">multinomial''''</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat.card</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">nat.card</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">}</span>\n<span class=\"c1\">-- This will be zero if `n ≠ finsupp.sum f $ λ _, id`, so you don't need the `ite ((∑ i, k i) = n)` to state the multinomial theorem.</span>\n</code></pre></div>",
        "id": 293421415,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660496181
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> is <code>{α}</code> equivalent to <code>{α : Type*}</code>? I wasn't aware of that shorthand, seems useful</p>",
        "id": 293435866,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1660505903
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"380294\">@Matt Diamond</span> Not writing the type means the type will get inferred as usual. In this case yes α will have type <code>Type*</code> since <code>finsupp (α : Type u_13) (M : Type u_14) [has_zero M] :</code>, but sometimes it might be <code>Sort*</code>, for example if α appears in the expression <code>psum α α</code>, because <a href=\"https://leanprover-community.github.io/mathlib_docs/find/psum\">docs#psum</a> takes arguments <code>(α : Sort u) (β : Sort v)</code>.</p>",
        "id": 293440485,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660509439
    },
    {
        "content": "<p>gotcha</p>",
        "id": 293440577,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1660509516
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span>  I've made an attempt to formulate the multinomial theorem, but I'm a little stuck on how to get the required fintype instance. (My attempts are the commented lines. The problem with the first line is that I'm not even sure restrict_support_equiv gets what I need, and if it does, I don't know how to get the fintype for the subtype introduced in that lemma. The second one doesn't work because it requires a fintype on alpha, which I don't think should be necessary.)</p>\n<p>I'm also aware of some problems: 1. It's a little messy. I played with s/k.support/casts until all the types worked out, and though I think it's semantically correct, it's kind of whacky still. 2. I didn't use the mv_power_series approach. I don't strictly need it for the result I want to prove, but I do recognize it would be nicer to formulate for that, since it is more general. I wouldn't know how to get the sum on the right though, since then the \"domain\" of the sum would no longer be finite, right? I guess you could formulate the theorem in terms of coeff (\\sum x_i)^n, but that seems kind of hacky too.</p>\n<p>If you have any pointers, it would be greatly appreciated:)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finsupp.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finite.card</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n<span class=\"kd\">noncomputable theory</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">nat.card</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">nat.card</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fintype.finsupp_on_finset</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">coe_sort</span> <span class=\"n\">s</span> <span class=\"bp\">→₀</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n   <span class=\"c1\">-- fintype.of_equiv _ ((finsupp.restrict_support_equiv (s : set α) (fin (n+1))))</span>\n   <span class=\"c1\">-- fintype.of_equiv (coe_sort s → fin (n+1)) (equiv.symm (finsupp.equiv_fun_on_fintype))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial_theorem</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n   <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→₀</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)),</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">multinomial</span> <span class=\"n\">s</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">finsupp.map_range</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))),</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"n\">k</span><span class=\"o\">))</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"bp\">∏</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">k.support</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(((</span><span class=\"n\">k</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)))</span>  <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n   <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 293608777,
        "sender_full_name": "Pim Otte",
        "timestamp": 1660592236
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"519269\">@Pim Otte</span> I've also found the question about the indexing type for the summation tricky, but I think I just found the preferred choice: <code>sym s n</code> (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/sym\">docs#sym</a>), which has a fintype instance <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sym.fintype\">docs#sym.fintype</a>, albeit a very inefficient one if you want to use it for computation, because the time complexity is like #s^n; a generalized <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.nat.antidiagonal\">docs#list.nat.antidiagonal</a> (which is the special case #s=2) would have time complexity <code>(n+#s-1).choose n</code> and be much more friendly for computation for large <code>n</code>. This would be an issue if you want to do explicit computation and have Lean enumerate all the monomials in the sum expansion for you, but it doesn't matter if you just want to prove things.</p>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/sym\">docs#sym</a> gives you <code>multiset s</code>, and you can use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/multiset.map\">docs#multiset.map</a> subtype.val to get <code>multiset α</code> and then <a href=\"https://leanprover-community.github.io/mathlib_docs/find/multiset.to_finsupp\">docs#multiset.to_finsupp</a> to get to <code>α →₀ ℕ</code>. You may also simply use <code>multiset α</code> in the definition of <code>multinomial</code> to make this conversion unnecessary. (And note that finsupp is also notoriously known to be unamenable to computation.)</p>",
        "id": 293630101,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660602286
    },
    {
        "content": "<p>Notice that there is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sym.sym'\">docs#sym.sym'</a> is a quotient of <code>vector α n</code> and has an equiv <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sym.sym_equiv_sym'\">docs#sym.sym_equiv_sym'</a>  with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sym\">docs#sym</a>, so you may define the multinomial coefficients as cardinalities of the fibers of the map <code>vector α n → sym α n</code> as well.</p>",
        "id": 293634795,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660605015
    },
    {
        "content": "<p>Of course if you don't care about computability at all you can prove your indexing set is finite and then use the noncomputable <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.finite.to_finset\">docs#set.finite.to_finset</a> to get a indexing finset.</p>",
        "id": 293635325,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660605269
    },
    {
        "content": "<p>Also mind <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sym\">docs#finset.sym</a> as a way to avoid fintype computation. I introduced it a while back precisely for multinomial coefficients.</p>",
        "id": 293635819,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660605524
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"519269\">Pim Otte</span> <a href=\"#narrow/stream/113489-new-members/topic/Multinomial.20coefficients.20definition/near/293608777\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span>  I've made an attempt to formulate the multinomial theorem, but I'm a little stuck on how to get the required fintype instance. (My attempts are the commented lines. The problem with the first line is that I'm not even sure restrict_support_equiv gets what I need, and if it does, I don't know how to get the fintype for the subtype introduced in that lemma. The second one doesn't work because it requires a fintype on alpha, which I don't think should be necessary.)</p>\n<p>I'm also aware of some problems: 1. It's a little messy. I played with s/k.support/casts until all the types worked out, and though I think it's semantically correct, it's kind of whacky still. 2. I didn't use the mv_power_series approach. I don't strictly need it for the result I want to prove, but I do recognize it would be nicer to formulate for that, since it is more general. I wouldn't know how to get the sum on the right though, since then the \"domain\" of the sum would no longer be finite, right? I guess you could formulate the theorem in terms of coeff (\\sum x_i)^n, but that seems kind of hacky too.</p>\n<p>If you have any pointers, it would be greatly appreciated:)</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finsupp.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finite.card</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n<span class=\"kd\">noncomputable theory</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">nat.card</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">nat.card</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fintype.finsupp_on_finset</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">coe_sort</span> <span class=\"n\">s</span> <span class=\"bp\">→₀</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n   <span class=\"c1\">-- fintype.of_equiv _ ((finsupp.restrict_support_equiv (s : set α) (fin (n+1))))</span>\n   <span class=\"c1\">-- fintype.of_equiv (coe_sort s → fin (n+1)) (equiv.symm (finsupp.equiv_fun_on_fintype))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial_theorem</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n   <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→₀</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)),</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">multinomial</span> <span class=\"n\">s</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">finsupp.map_range</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))),</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"n\">k</span><span class=\"o\">))</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"bp\">∏</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">k.support</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(((</span><span class=\"n\">k</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)))</span>  <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n   <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Hmm, is there a reason you aren't assuming <code>[decidable_eq α]</code>? With that, your second attempt works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fintype.finsupp_on_finset</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n   <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">coe_sort</span> <span class=\"n\">s</span> <span class=\"bp\">→₀</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n   <span class=\"n\">fintype.of_equiv</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">equiv.symm</span> <span class=\"o\">(</span><span class=\"n\">finsupp.equiv_fun_on_fintype</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 293639686,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1660607985
    },
    {
        "content": "<p>Thanks a lot, all of you! I'm going to experiment a little bit and see if I want to switch to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sym\">docs#sym</a> or stay with the current approach.</p>\n<p><span class=\"user-mention\" data-user-id=\"391579\">@Jake Levinson</span> I'm guessing this works because there's some fintype floating around that applies when you add the <code>[decidable_eq α]</code>, but how did you get to this? Is it just intuition or is there a systematic approach you took that I could apply in the future?</p>",
        "id": 293665443,
        "sender_full_name": "Pim Otte",
        "timestamp": 1660633937
    },
    {
        "content": "<p>The saga continues! </p>\n<p>I managed to formulate the theorem using <code>sym</code>, which looks kind of nice. I also managed to do it for arbitrary finsets, not just univ of a fintype. However, I used coe_sort to coerce the type s to a structure to iterate over it, which I think is correct, but in the proof I'm stuck going the other way, identifying an emptyset that's coerced to sort with an emptyset. Any pointers for this, or should I have gone another way in the definition?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finsupp.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finite.card</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.sym</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finsupp.multiset</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n<span class=\"kd\">noncomputable theory</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">nat.card</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">nat.card</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial_theorem</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">):</span>\n   <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">coe_sort</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"n\">s</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"o\">((</span><span class=\"n\">multinomial</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">k.val.to_finsupp</span><span class=\"o\">))</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"bp\">∏</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">coe_sort</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">k.val.count</span> <span class=\"n\">i</span><span class=\"o\">)))</span>  <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n   <span class=\"n\">induction</span> <span class=\"n\">s</span> <span class=\"n\">using</span> <span class=\"n\">finset.cons_induction</span> <span class=\"k\">with</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span> <span class=\"n\">h₃</span> <span class=\"n\">h₄</span><span class=\"o\">,</span>\n   <span class=\"o\">{</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">zero_pow</span> <span class=\"n\">hn</span><span class=\"o\">,</span> <span class=\"n\">finset.univ_eq_attach</span><span class=\"o\">,</span> <span class=\"n\">finset.attach_empty</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_empty</span><span class=\"o\">,</span> <span class=\"n\">subtype.val_eq_coe</span><span class=\"o\">,</span> <span class=\"n\">finset.prod_empty</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_one</span><span class=\"o\">],</span>\n      <span class=\"k\">have</span> <span class=\"n\">fact</span><span class=\"o\">:</span> <span class=\"n\">sym</span> <span class=\"o\">(</span><span class=\"n\">coe_sort</span> <span class=\"o\">(</span><span class=\"n\">finset.empty</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">finset.empty</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span>\n         <span class=\"n\">unfold</span> <span class=\"n\">finset.empty</span><span class=\"o\">,</span>\n         <span class=\"n\">rw</span> <span class=\"n\">finset.mk_zero</span><span class=\"o\">,</span>\n\n         <span class=\"n\">exact</span> <span class=\"n\">finset.sym_eq_empty.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">ne_of_gt</span> <span class=\"n\">hn</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n      <span class=\"o\">},</span>\n   <span class=\"o\">},</span>\n   <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 293752277,
        "sender_full_name": "Pim Otte",
        "timestamp": 1660667111
    },
    {
        "content": "<p>I'll take a look later if no one does; now I'd just point out that you can simply write <code>i : s</code> and Lean will parse it as <code>i : coe_sort s</code>, displayed as <code>i : ↥s</code>.</p>",
        "id": 293767579,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660671436
    },
    {
        "content": "<p>I think what you want are <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.is_empty_coe_sort\">docs#finset.is_empty_coe_sort</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sym.is_empty\">docs#sym.is_empty</a></p>",
        "id": 293767854,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660671551
    },
    {
        "content": "<p>similarly there's no need to write <code>coe_sort</code> in <code>sym (coe_sort (finset.empty : finset α)) n</code>. Since Lean expects a type/sort as the first argument of <code>sym</code>, it will automatically insert a coe_sort.<br>\nAnd you can write <code>∅ : finset α</code></p>",
        "id": 293768044,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660671632
    },
    {
        "content": "<p>The right way to sum over a finset is Sum i in s, also</p>",
        "id": 293768326,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1660671741
    },
    {
        "content": "<p>Yes, <code>∑ i in s</code> instead of <code>∑ (i : coe_sort s)</code><br>\n<code>∑ k : sym s n</code> is correct because <code>sym s n</code> is a (finite) type.</p>",
        "id": 293771880,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660673133
    },
    {
        "content": "<p>I'm still working on the other stuff, but <code>∑ i in s</code> leads to <code>i : α</code>, whereas <code>∑ i</code> leads to <code>i : ↥s</code>, which works a little better with the definition of <code>x</code>, so I'm currently rolling <code>∑ i</code>which does look a lot nicer:D</p>",
        "id": 293773437,
        "sender_full_name": "Pim Otte",
        "timestamp": 1660673651
    },
    {
        "content": "<p>Oh I see <code>x: s →₀ R</code> is also problematic. Since <code>s</code> is finite there's no need of the <code>₀</code>. Moreover, finset big operator lemmas are usually stated with <code>x : α → R</code> instead.</p>",
        "id": 293773812,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660673784
    },
    {
        "content": "<p>Some other comments:<br>\n<code>[comm_semiring R]</code> should work.<br>\nmathlib prefers <code>0 &lt; n</code> over <code>n &gt; 0</code>. The convention is to always use le/lt not ge/gt (except for epsilon in anlysis).</p>",
        "id": 293774130,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660673905
    },
    {
        "content": "<p>Attempt to reformulate with <code>x : α →₀ R</code>. Two issues: It gives  a type mismatch with the finsupp derived from the sym element.   Also, I kept the finsupp, because I have no idea how to make the sums in the infinite context (I guess that has something to do with the power_series approach you mentioned earlier?)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finsupp.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finite.card</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.sym</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finsupp.multiset</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.basic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n<span class=\"kd\">noncomputable theory</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">nat.card</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">nat.card</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial_theorem</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">):</span>\n   <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">x.support</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"n\">x.support</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"o\">((</span><span class=\"n\">multinomial</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">k.val.to_finsupp</span><span class=\"o\">))</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"bp\">∏</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">x.support</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">k.val.count</span> <span class=\"n\">i</span><span class=\"o\">)))</span>  <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 293775181,
        "sender_full_name": "Pim Otte",
        "timestamp": 1660674268
    },
    {
        "content": "<p>Sorry, this is what I mean; we still need the finset, and <code>x</code> need only be a function not finsupp:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">multinomial_theorem</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"c\">/-</span><span class=\"cm\"> or simply `s.sum x` -/</span>\n  <span class=\"bp\">∑</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">sym</span> <span class=\"n\">s</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">multinomial</span> <span class=\"n\">n</span> <span class=\"n\">k.val.to_finsupp</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">k.val.map</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∘</span> <span class=\"n\">subtype.val</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">:=</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> changed the product to use `multiset.map`and `multiset.prod` -/</span>\n</code></pre></div>",
        "id": 293776906,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660674869
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"519269\">Pim Otte</span> <a href=\"#narrow/stream/113489-new-members/topic/Multinomial.20coefficients.20definition/near/293665443\">said</a>:</p>\n<blockquote>\n<p>Thanks a lot, all of you! I'm going to experiment a little bit and see if I want to switch to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sym\">docs#sym</a> or stay with the current approach.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"391579\">Jake Levinson</span> I'm guessing this works because there's some fintype floating around that applies when you add the <code>[decidable_eq α]</code>, but how did you get to this? Is it just intuition or is there a systematic approach you took that I could apply in the future?</p>\n</blockquote>\n<p>In this case I had previously looked for the <code>fintype</code> instance for maps <code>α → β</code> when both are fintypes, and I eventually found <code>pi.fintype</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">pi.fintype</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>This is actually slightly more general since it allows dependent functions. I don't have much intuition for decidability, but I think the idea is that to enumerate all the functions <code>α → β</code>, we would enumerate through the elements <code>a : α</code> and then through the choices of where to map them. But then, to map an arbitrary term <code>a' : α</code> through a function constructed \"by cases\" this way, we have to match <code>a'</code> with one of the <code>a : α</code>'s, and that requires <code>decidable_eq α</code>.</p>",
        "id": 293779752,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1660675887
    },
    {
        "content": "<p>Yeah, I think the decidable_eq originates from the <code>ite</code>s in the recursive definition of the (dependent) functions in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/multiset.pi.cons\">docs#multiset.pi.cons</a>.</p>",
        "id": 293783237,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660677219
    },
    {
        "content": "<p>I've made some more steps, but I'm missing the final bit.</p>\n<p>I think finset.sum_of_empty should apply, and I have the is_empty on the type, but it doesn't seem to apply. What am I missing?:)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finsupp.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finite.card</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.sym</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finsupp.multiset</span>\n\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n<span class=\"kd\">noncomputable theory</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">nat.card</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">nat.card</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial_theorem</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">s.sum</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">sym</span> <span class=\"n\">s</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">multinomial</span> <span class=\"n\">n</span> <span class=\"n\">k.val.to_finsupp</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">k.val.map</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∘</span> <span class=\"n\">subtype.val</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n      <span class=\"n\">induction</span> <span class=\"n\">s</span> <span class=\"n\">using</span> <span class=\"n\">finset.cons_induction</span> <span class=\"k\">with</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span> <span class=\"n\">h₃</span> <span class=\"n\">h₄</span><span class=\"o\">,</span>\n   <span class=\"o\">{</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">zero_pow</span> <span class=\"n\">hn</span><span class=\"o\">,</span> <span class=\"n\">finset.univ_eq_attach</span><span class=\"o\">,</span> <span class=\"n\">finset.attach_empty</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_empty</span><span class=\"o\">,</span> <span class=\"n\">subtype.val_eq_coe</span><span class=\"o\">,</span> <span class=\"n\">finset.prod_empty</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_one</span><span class=\"o\">],</span>\n      <span class=\"k\">have</span> <span class=\"n\">fact</span> <span class=\"o\">:</span> <span class=\"n\">is_empty</span> <span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"o\">(</span><span class=\"bp\">∅</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">),</span>\n      <span class=\"o\">{</span>\n         <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">nat.pred_inj</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ_pos</span> <span class=\"n\">hn</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n         <span class=\"n\">apply</span> <span class=\"n\">sym.is_empty</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n         <span class=\"n\">rw</span> <span class=\"n\">finset.is_empty_coe_sort</span><span class=\"o\">,</span>\n      <span class=\"o\">},</span>\n      <span class=\"n\">rw</span> <span class=\"n\">eq_comm</span><span class=\"o\">,</span>\n\n      <span class=\"n\">apply</span> <span class=\"n\">finset.sum_of_empty</span><span class=\"o\">,</span>\n      <span class=\"c1\">-- apply (@finset.sum_of_empty R (sym (∅ : finset α) n) (λ k, multinomial n k.val.to_finsupp * (k.val.map (x ∘ subtype.val)).prod) _ fact),</span>\n      <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n   <span class=\"o\">},</span>\n   <span class=\"o\">{</span>\n   <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 293788145,
        "sender_full_name": "Pim Otte",
        "timestamp": 1660679119
    },
    {
        "content": "<p>haveI instead of have. is_empty is used as a typeclass constraint, and haveI populates it into the typeclass instance cache</p>",
        "id": 293788618,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1660679320
    },
    {
        "content": "<p>Thanks! I've corrected this, but it still fails to unify, I'm afraid</p>",
        "id": 293788935,
        "sender_full_name": "Pim Otte",
        "timestamp": 1660679468
    },
    {
        "content": "<p>Yeah Lean seems to have trouble figuring out the function <code>sym ↥∅ n → R</code> in <code>finset.sum_of_empty</code> when doing <code>apply</code> or <code>exact</code>, but this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>      <span class=\"n\">convert</span> <span class=\"n\">finset.sum_of_empty</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">fact</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 293789800,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660679831
    },
    {
        "content": "<p>By the way the theorem should hold for n=0 right? Just the proof would be different.</p>",
        "id": 293789845,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660679864
    },
    {
        "content": "<p>Curiously, if you do <code>haveI</code>, then <code>convert</code> creates the goal <code>sym ↥∅ n → R</code>. I've seen this bug elsewhere ...</p>",
        "id": 293790351,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660680041
    },
    {
        "content": "<p>Awesome, new tactic time:)</p>\n<p>With respect to <code>n=0</code>: the part that I was kind of fuzzy about is the 0^0 issue for <code>s = ∅</code>and <code>n=0</code>. I don't really know how I'd work around that.</p>",
        "id": 293790641,
        "sender_full_name": "Pim Otte",
        "timestamp": 1660680142
    },
    {
        "content": "<p><code>0^0 = 1</code> in Lean (at least with the zeroes you're dealing with now <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>)</p>",
        "id": 293791429,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660680470
    },
    {
        "content": "<p>Thanks for all the help everyone! </p>\n<p>Current roadblock for me: How to handle <code>multiset.map</code> and <code>coe default</code> (which I think represents an emptyset in the current context, but I don't really grasp what it is). It's probably a bit explicit/long too, so if people have golfing suggestions, I'm open to those:)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finsupp.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finite.card</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.sym</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finsupp.multiset</span>\n\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n<span class=\"kd\">noncomputable theory</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">nat.card</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">nat.card</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial_theorem</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">s.sum</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">sym</span> <span class=\"n\">s</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">multinomial</span> <span class=\"n\">n</span> <span class=\"n\">k.val.to_finsupp</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">k.val.map</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∘</span> <span class=\"n\">subtype.val</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n      <span class=\"n\">induction</span> <span class=\"n\">s</span> <span class=\"n\">using</span> <span class=\"n\">finset.cons_induction</span> <span class=\"k\">with</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span> <span class=\"n\">h₃</span> <span class=\"n\">h₄</span><span class=\"o\">,</span>\n   <span class=\"o\">{</span>\n      <span class=\"n\">by_cases</span> <span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span>\n         <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">zero_pow</span> <span class=\"n\">hn</span><span class=\"o\">,</span> <span class=\"n\">finset.univ_eq_attach</span><span class=\"o\">,</span> <span class=\"n\">finset.attach_empty</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_empty</span><span class=\"o\">,</span> <span class=\"n\">subtype.val_eq_coe</span><span class=\"o\">,</span> <span class=\"n\">finset.prod_empty</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_one</span><span class=\"o\">],</span>\n         <span class=\"n\">convert</span> <span class=\"n\">eq_comm.mp</span> <span class=\"n\">finset.sum_of_empty</span><span class=\"o\">,</span>\n         <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">nat.pred_inj</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ_pos</span> <span class=\"n\">hn</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n         <span class=\"n\">apply</span> <span class=\"n\">sym.is_empty</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n         <span class=\"n\">rw</span> <span class=\"n\">finset.is_empty_coe_sort</span><span class=\"o\">,</span>\n      <span class=\"o\">},</span>\n      <span class=\"o\">{</span>\n         <span class=\"k\">have</span> <span class=\"n\">fact</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n         <span class=\"o\">{</span>\n            <span class=\"n\">push_neg</span> <span class=\"n\">at</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n            <span class=\"n\">exact</span> <span class=\"n\">nat.le_zero_iff.mp</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n         <span class=\"o\">},</span>\n         <span class=\"n\">rw</span> <span class=\"n\">fact</span><span class=\"o\">,</span>\n         <span class=\"n\">rw</span> <span class=\"n\">finset.sum_empty</span><span class=\"o\">,</span>\n         <span class=\"n\">simp</span><span class=\"o\">,</span>\n         <span class=\"k\">have</span> <span class=\"n\">fact'</span><span class=\"o\">:</span> <span class=\"n\">is_empty</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"bp\">∅</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)},</span>\n         <span class=\"o\">{</span>\n            <span class=\"n\">exact</span> <span class=\"n\">set.is_empty_coe_sort.mpr</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n         <span class=\"o\">},</span>\n         <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n      <span class=\"o\">}</span>\n\n   <span class=\"o\">},</span>\n   <span class=\"o\">{</span>\n      <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n   <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 293797016,
        "sender_full_name": "Pim Otte",
        "timestamp": 1660682526
    },
    {
        "content": "<p>↑default is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/multiset.nil\">docs#multiset.nil</a> (denoted <code>0</code>) but this is missing as a simp lemma. You can <code>unfold default</code> to get <code>↑sym.nil</code> but we don't even have sym.coe_nil ...<br>\nI think you don't need induction for n = 0, i.e. you can do <code>by_cases</code> before <code>induction</code>.<br>\nI'm not even sure induction is the correct approach to prove the multinomial theorem as formulated, because <code>multinomial</code> isn't defined recursively. I think the we should rather use something like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.prod_univ_sum\">docs#finset.prod_univ_sum</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sum_sigma\">docs#finset.sum_sigma</a>, and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fintype.sum_equiv\">docs#fintype.sum_equiv</a>.</p>",
        "id": 293800089,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660683748
    },
    {
        "content": "<p>By the way I just remembered that replacing <code>x ∘ subtype.val</code> with <code>x ∘ coe</code> would be nicer. <code>coe</code> (or ↑) is the \"simp normal form\" of <code>subtype.val</code>.</p>",
        "id": 293800692,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660683985
    },
    {
        "content": "<p>For this specific goal: if you do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>         <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">mul_one</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n         <span class=\"n\">erw</span> <span class=\"n\">multiset.to_finsupp_zero</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>then the goal becomes <code>↑(multinomial 0 0) = 1</code>.</p>",
        "id": 293802106,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660684558
    },
    {
        "content": "<blockquote>\n<p>a generalized <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.nat.antidiagonal\">docs#list.nat.antidiagonal</a> (which is the special case #s=2) would have time complexity <code>(n+#s-1).choose n</code> and be much more friendly for computation for large <code>n</code>.</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.nat.antidiagonal_tuple\">docs#list.nat.antidiagonal_tuple</a></p>",
        "id": 293859833,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660727215
    },
    {
        "content": "<p>Thanks for pointing it out! There are also the multiset/finset versions and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.nat.sigma_antidiagonal_tuple_equiv_tuple\">docs#finset.nat.sigma_antidiagonal_tuple_equiv_tuple</a> seems to be made exactly for the purpose of multinomial theorem. I guess we should construct an <code>equiv</code> between the finset version and <code>sym</code> so that we can translate freely between sums over both.</p>",
        "id": 293905158,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660745734
    },
    {
        "content": "<p>I think there is some code on a branch somewhere that does that; <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> might remember</p>",
        "id": 293920915,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660750491
    },
    {
        "content": "<p>I'm not sure what \"that\" is here, but I'm remembering one multinomial-related piece of code: <a href=\"https://github.com/leanprover-community/mathlib/blob/binomial/src/data/nat/choose/multinomial.lean\">https://github.com/leanprover-community/mathlib/blob/binomial/src/data/nat/choose/multinomial.lean</a></p>\n<p>It's the multinomial coefficient is using a list, so for example <code>multinomial [a, b, c]</code>. I've thought this was nice because it gives a reasonable notation for it.</p>",
        "id": 293924672,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660751627
    },
    {
        "content": "<p>I didn't get very far, but this seems like a nice interface for the multinomial coefficient. I suggest proving the combinatorial version as a lemma (and to do this, you probably want a good number of supporting lemmas, giving equivalences for the type that parallel a recursive definition for <code>multinomial</code>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span> <span class=\"n\">nat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">!</span> <span class=\"bp\">/</span> <span class=\"bp\">∏</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">!</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">multinomial</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">]</span>\n<span class=\"c1\">-- 60</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">multinomial_eq</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">multinomial</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">nat.card</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">nat.card</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 293932639,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660754063
    },
    {
        "content": "<p>\"that\" refers to the equivalence between the n-ary antidiagonal, and <code>sym</code>, I think</p>",
        "id": 293933036,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660754171
    },
    {
        "content": "<p>A fun application:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"o\">((</span><span class=\"n\">list.nat.antidiagonal_tuple</span> <span class=\"mi\">5</span> <span class=\"mi\">20</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">multinomial</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span>\n<span class=\"c1\">-- 95367431640625</span>\n<span class=\"k\">#eval</span> <span class=\"mi\">5</span><span class=\"bp\">^</span><span class=\"mi\">20</span>\n<span class=\"c1\">-- 95367431640625</span>\n</code></pre></div>\n<p>It evaluates relatively quickly for Lean, just a second or two.</p>",
        "id": 293933692,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660754385
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/Multinomial.20coefficients.20definition/near/293932639\">said</a>:</p>\n<blockquote>\n<p>I didn't get very far, but this seems like a nice interface for the multinomial coefficient. I suggest proving the combinatorial version as a lemma (and to do this, you probably want a good number of supporting lemmas, giving equivalences for the type that parallel a recursive definition for <code>multinomial</code>)</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span> <span class=\"n\">nat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">!</span> <span class=\"bp\">/</span> <span class=\"bp\">∏</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">!</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">multinomial</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">]</span>\n<span class=\"c1\">-- 60</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">multinomial_eq</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">multinomial</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">nat.card</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">nat.card</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>The combinatorialist in me thinks that the underlying combinatorial object<br>\n<code>{k : fin (∑ i, f i) → α // ∀ a, nat.card (k ⁻¹' {a}) = f a}</code> should also be given a name, and then the various recursions can be proven bijectively instead of just by counting.</p>",
        "id": 293933926,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1660754443
    },
    {
        "content": "<p>(Though, that particular lemma should probably be proven using something like the orbit-stabilizer lemma.)</p>",
        "id": 293934072,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1660754485
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/Multinomial.20coefficients.20definition/near/293924672\">said</a>:</p>\n<blockquote>\n<p>I'm not sure what \"that\" is here, but I'm remembering one multinomial-related piece of code: <a href=\"https://github.com/leanprover-community/mathlib/blob/binomial/src/data/nat/choose/multinomial.lean\">https://github.com/leanprover-community/mathlib/blob/binomial/src/data/nat/choose/multinomial.lean</a></p>\n<p>It's the multinomial coefficient is using a list, so for example <code>multinomial [a, b, c]</code>. I've thought this was nice because it gives a reasonable notation for it.</p>\n</blockquote>\n<p>This looks pretty useful and besides the duplication between bionomial.lean/multinomial.lean, my untrained eye doesn't really spot any reason not to PR this as-is. Of course it could be extended with more lemma's and the combinatorial definition and such, but this seems like plenty  already. What would you say would need to be done before starting a PR? Would you mind if I tried my hand at bringing this branch to mathlib?</p>",
        "id": 294109706,
        "sender_full_name": "Pim Otte",
        "timestamp": 1660836385
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"519269\">@Pim Otte</span> I'm not sure why it hasn't been PR'd. I think this branch was an experiment by <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> with some additional experimentation of my own.</p>\n<p>If you wanted to take it on, I'd suggest getting things from <code>multinomial.lean</code> together for a PR, and I'd also suggest switching to the following definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">multinomial</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">!</span> <span class=\"bp\">/</span> <span class=\"bp\">∏</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">!</span>\n</code></pre></div>\n<p>That seems to be more versatile than using lists.</p>",
        "id": 294128109,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660841921
    },
    {
        "content": "<p>Sounds good:) In a comparable situation <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> recommended to base a definition on a finset instead of just univ of a fintype. I don't know if that still holds in this context, any thoughts on that?</p>",
        "id": 294129708,
        "sender_full_name": "Pim Otte",
        "timestamp": 1660842367
    },
    {
        "content": "<p>I agree with you. It still applies.</p>",
        "id": 294130346,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660842583
    },
    {
        "content": "<p>I like this one because you can write <code>multinomial ![a, b, c]</code>, which is some nice notation for free, but I haven't given it too much thought.</p>",
        "id": 294130368,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660842590
    },
    {
        "content": "<p>What is the reason? I missed this discussion.</p>",
        "id": 294130407,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660842601
    },
    {
        "content": "<p>It's much easier to add/remove an element to a finset than to a fintype.</p>",
        "id": 294130526,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660842635
    },
    {
        "content": "<p>If we add a finset, your example becomes <code>multinomial univ ![a, b, c]</code>, which I think is still quite nice?</p>",
        "id": 294130641,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660842676
    },
    {
        "content": "<p>I suppose that's reasonable, and that's a fine enough interface.</p>",
        "id": 294130867,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660842753
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"519269\">@Pim Otte</span> Then here's an amended suggestion:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The multinomial coefficient. Gives the number of strings</span>\n<span class=\"sd\">consisting of symbols from `s`, where `c ∈ s`</span>\n<span class=\"sd\">appears with multiplicity `f c`.</span>\n\n<span class=\"sd\">Example: `multinomial finset.univ ![2,2,3]` gives the number of strings</span>\n<span class=\"sd\">from the set `{0, 1, 2}` with two `0`'s, two `1`'s, and three `2`'s. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">multinomial</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">!</span> <span class=\"bp\">/</span> <span class=\"bp\">∏</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">!</span>\n</code></pre></div>",
        "id": 294132036,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660843179
    },
    {
        "content": "<p>I'm forgetting -- what's the mathlib interface to update the value of a function at a particular input? It shows up in the API for summations/products.</p>",
        "id": 294132726,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660843396
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.update\">docs#function.update</a></p>",
        "id": 294134733,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660843972
    },
    {
        "content": "<p>We can do finsupp as well:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">open_locale</span> <span class=\"n\">nat</span>\n<span class=\"kd\">def</span> <span class=\"n\">multinomial</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">f.sum</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"o\">)</span><span class=\"bp\">!</span> <span class=\"bp\">/</span> <span class=\"n\">f.prod</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"bp\">!</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 294136743,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660844564
    },
    {
        "content": "<p>One weakness with <code>finsupp</code> is that you can't tell the difference between having zero of a symbol in the string and not including the symbol at all. They give the same values, but I worried that it might make some things more awkward.</p>",
        "id": 294137617,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660844875
    },
    {
        "content": "<p>Maybe that's not a bug, but a feature?</p>",
        "id": 294137869,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660844956
    },
    {
        "content": "<p>Using the principle that it tends to be better to break apart product types into separate arguments unless the function is specifically about a particular object, maybe it's better writing <code>multinomial f.support f</code>?</p>",
        "id": 294137990,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660844995
    },
    {
        "content": "<p>A <code>finsupp</code> is not a product of a finset and a function, however.</p>",
        "id": 294139018,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660845220
    },
    {
        "content": "<p>Sure, it's a finset, a function, and a proof the finset is a support of the function</p>",
        "id": 294139615,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660845405
    },
    {
        "content": "<p>and <code>multinomial</code> doesn't make use of the third one</p>",
        "id": 294139666,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660845422
    },
    {
        "content": "<p>to be more precise, I mean \"sigma type\" (i.e., a dependent product)</p>",
        "id": 294139764,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660845455
    },
    {
        "content": "<p>crazy idea: <code>M x ∈ s, f x</code></p>",
        "id": 294140011,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660845528
    },
    {
        "content": "<p>Oh, does that make <code>M x y, f x y</code> mean the right thing?</p>",
        "id": 294141152,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660845865
    },
    {
        "content": "<p>that sounds unlikely: it works out to <code>(∑ x, (∑ y, f x y)! / ∏ y, (f x y)!)! / ∏ x, ((∑ y, f x y)! / ∏ y, (f x y)!)!</code> which doesn't look like it would be equal to <code>(∑ x y, f x y)! / ∏ x y, (f x y)!</code></p>",
        "id": 294141829,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660846096
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">multinomial</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">!</span> <span class=\"bp\">/</span> <span class=\"bp\">∏</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">!</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">multinomial</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">,</span> <span class=\"n\">multinomial</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"c1\">-- 6</span>\n<span class=\"k\">#eval</span> <span class=\"n\">multinomial</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">×</span> <span class=\"n\">bool</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"c1\">-- 24</span>\n</code></pre></div>",
        "id": 294142685,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660846413
    },
    {
        "content": "<p>Hmm, that makes me wonder whether it might be useful to have \"universal big operators\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">multinomial</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">!</span> <span class=\"bp\">/</span> <span class=\"bp\">∏</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">!</span>\n\n<span class=\"kd\">notation</span> <span class=\"bp\">`&lt;|</span> <span class=\"bp\">`</span> <span class=\"n\">g</span> <span class=\"bp\">`</span> <span class=\"bp\">|&gt;λ</span> <span class=\"bp\">`</span> <span class=\"n\">binders</span> <span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span> <span class=\"n\">r</span><span class=\"o\">:(</span><span class=\"n\">scoped</span><span class=\"o\">:</span><span class=\"mi\">67</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">r</span>\n\n<span class=\"k\">#eval</span> <span class=\"bp\">&lt;|</span><span class=\"n\">multinomial</span><span class=\"bp\">|&gt;λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">),</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>(I'm just using <code>multinomial</code> as an example; I'm not sure it's useful here.)</p>",
        "id": 294156119,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1660851271
    },
    {
        "content": "<p>I collected some of the basic results and <a href=\"https://github.com/leanprover-community/mathlib/pull/16170\">PR'd them</a> :D</p>",
        "id": 294458187,
        "sender_full_name": "Pim Otte",
        "timestamp": 1661011305
    },
    {
        "content": "<p>I've picked up trying the multinomial theorem. Below my progress (I have a separate case for n=0, if necessary)</p>\n<p>My guess is that the way forward from this point would be to prove that the term in the first sum is stable under permutation of p, rewrite the sum per \"orbit\" under permutation (don't know if orbit is the technically correct term here). However, I have no clue how to approach that formally, and I'm not even sure it's the right approach. Proving the other term stable under permutation and \"reversing\" the quotient on permutation that happens in the definition of multiset would work too, but seems harder.</p>\n<p>Any pointers?:)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.fin</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.order</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.choose.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.sym</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finsupp.multiset</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.fin.vec_notation</span>\n\n\n<span class=\"n\">open_locale</span> <span class=\"n\">nat</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">!</span> <span class=\"bp\">/</span> <span class=\"bp\">∏</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">!</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nil_coe</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">sym.nil</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">sym.nil</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">sym.mk_coe</span> <span class=\"mi\">0</span> <span class=\"n\">multiset.card_zero</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial_theorem</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">s.sum</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">sym</span> <span class=\"n\">s</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">multinomial</span> <span class=\"n\">k.val.to_finsupp.support</span> <span class=\"n\">k.val.to_finsupp</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">k.val.map</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∘</span> <span class=\"n\">coe</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">subtype.val_eq_coe</span><span class=\"o\">,</span> <span class=\"n\">function.comp_app</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finset.pow_eq_prod_const</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">fin.prod_univ_eq_prod_range</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finset.prod_univ_sum</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 295085937,
        "sender_full_name": "Pim Otte",
        "timestamp": 1661359913
    },
    {
        "content": "<p>I'm late to the party but I would proceed by using <code>finset.induction_on</code>. You'll instantly run into a bunch of easier facts about <code>multinomial</code> which you should then factor out and prove first. I don't know if this is the best approach for multinomial coefficients (I'm not implying that is isn't, I just don't know). What do they do in Isabelle/HOL?</p>",
        "id": 295569593,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661593085
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"519269\">@Pim Otte</span>  Here is a continuation of the non-inductive approach, where the sorry should be filled in by considering the action of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.perm\">docs#equiv.perm</a> on <code>fin n → α</code>(acting on the domain) which preserves the range multiset. Then we can use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_action.card_orbit_mul_card_stabilizer_eq_card_group\">docs#mul_action.card_orbit_mul_card_stabilizer_eq_card_group</a> (but mathlib doesn't even know the cardinality of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.perm\">docs#equiv.perm</a> is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.factorial\">docs#nat.factorial</a>, it seems).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.fin</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.order</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.choose.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.sym</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finsupp.multiset</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.fin.vec_notation</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">nat</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">!</span> <span class=\"bp\">/</span> <span class=\"bp\">∏</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">!</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nil_coe</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">sym.nil</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">sym.nil</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">sym.mk_coe</span> <span class=\"mi\">0</span> <span class=\"n\">multiset.card_zero</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">finsupp.multinomial</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">f.sum</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"o\">)</span><span class=\"bp\">!</span> <span class=\"bp\">/</span> <span class=\"n\">f.prod</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"bp\">!</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">finsupp.multinomial_eq</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f.multinomial</span> <span class=\"bp\">=</span> <span class=\"n\">multinomial</span> <span class=\"n\">f.support</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">multiset.multinomial</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">m.to_finsupp.multinomial</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">multiset.to_finsupp_map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">m.map</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finsupp</span> <span class=\"bp\">=</span> <span class=\"n\">m.to_finsupp.map_domain</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">conv_lhs</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">m.to_finsupp_to_multiset</span><span class=\"o\">,</span> <span class=\"n\">finsupp.to_multiset_map</span><span class=\"o\">,</span> <span class=\"n\">finsupp.to_multiset_to_finsupp</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">multiset.map_multinomial</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">↪</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">m.map</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">multinomial</span> <span class=\"bp\">=</span> <span class=\"n\">m.multinomial</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">multiset.multinomial</span><span class=\"o\">,</span> <span class=\"n\">finsupp.multinomial</span><span class=\"o\">,</span> <span class=\"n\">m.to_finsupp_map</span> <span class=\"n\">f</span><span class=\"o\">],</span>\n  <span class=\"n\">congr</span><span class=\"o\">,</span>\n  <span class=\"n\">exacts</span> <span class=\"o\">[</span><span class=\"n\">finsupp.sum_map_domain_index_inj</span> <span class=\"n\">f.inj'</span><span class=\"o\">,</span> <span class=\"n\">finsupp.prod_map_domain_index_inj</span> <span class=\"n\">f.inj'</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[simps]</span> <span class=\"kd\">def</span> <span class=\"n\">sym_finset_to_multiset</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">sym</span> <span class=\"n\">s</span> <span class=\"n\">n</span> <span class=\"bp\">↪</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.1.map</span> <span class=\"n\">coe</span><span class=\"o\">,</span>\n  <span class=\"n\">inj'</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">multiset.map_injective</span> <span class=\"n\">subtype.coe_injective</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">subtype.val_injective</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">multiset.trunc_enum_of_fin_card</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">trunc</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">s.card</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">finset.univ.val.map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient.rec_on</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">trunc.mk</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">l.nth_le</span> <span class=\"n\">i</span> <span class=\"n\">i.2</span><span class=\"o\">,</span> <span class=\"n\">congr_arg</span> <span class=\"n\">coe</span> <span class=\"n\">l.map_nth_le</span><span class=\"o\">⟩)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">subsingleton.elim</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">multinomial_theorem</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">s.sum</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">sym</span> <span class=\"n\">s</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">k.val.multinomial</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">k.val.map</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∘</span> <span class=\"n\">coe</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">subtype.val_eq_coe</span><span class=\"o\">,</span> <span class=\"n\">function.comp_app</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.pow_eq_prod_const</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">fin.prod_univ_eq_prod_range</span><span class=\"o\">,</span> <span class=\"n\">finset.prod_univ_sum</span><span class=\"o\">],</span>\n  <span class=\"n\">simp_rw</span> <span class=\"n\">finset.prod</span><span class=\"o\">,</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"n\">finset.sum_comp</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">m.map</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">finset.univ.val.map</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">using</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp_rw</span> <span class=\"n\">multiset.map_map</span> <span class=\"o\">},</span>\n  <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">finset.sum_map</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">sym_finset_to_multiset</span> <span class=\"n\">s</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">ext1</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">nsmul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">congr'</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">sym_finset_to_multiset_apply</span><span class=\"o\">,</span> <span class=\"n\">multiset.map_map</span><span class=\"o\">],</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"n\">ext1</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.mem_image</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_map</span><span class=\"o\">],</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨⟨</span><span class=\"n\">finset.univ.1.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">fintype.mem_pi_finset.1</span> <span class=\"n\">hf</span> <span class=\"n\">i</span><span class=\"o\">⟩),</span>\n      <span class=\"o\">(</span><span class=\"n\">multiset.card_map</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"bp\">$</span> <span class=\"n\">finset.card_fin</span> <span class=\"n\">n</span><span class=\"o\">⟩,</span> <span class=\"n\">finset.mem_univ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sym_finset_to_multiset_apply</span><span class=\"o\">,</span> <span class=\"n\">multiset.map_map</span><span class=\"o\">],</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">hm</span><span class=\"o\">⟩,</span> <span class=\"bp\">-</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">⟩⟩</span> <span class=\"o\">:=</span> <span class=\"n\">m.trunc_enum_of_fin_card</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">coe</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">fin_congr</span> <span class=\"n\">hm.symm</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">fintype.mem_pi_finset</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">finset.coe_mem</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">multiset.map_map</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">multiset.map_map</span> <span class=\"n\">f</span><span class=\"o\">],</span>\n    <span class=\"n\">congr</span><span class=\"o\">,</span>\n    <span class=\"n\">convert</span> <span class=\"n\">hf</span> <span class=\"n\">using</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"n\">congr</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">congr_arg</span> <span class=\"n\">finset.val</span> <span class=\"o\">(</span><span class=\"n\">finset.map_univ_equiv</span> <span class=\"bp\">$</span> <span class=\"n\">fin_congr</span> <span class=\"n\">hm.symm</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">α: Type</span>\n<span class=\"cm\">_inst_1: decidable_eq α</span>\n<span class=\"cm\">R: Type ?</span>\n<span class=\"cm\">_inst_2: comm_semiring R</span>\n<span class=\"cm\">x: α → R</span>\n<span class=\"cm\">s: finset α</span>\n<span class=\"cm\">n: ℕ</span>\n<span class=\"cm\">x_1: sym ↥s n</span>\n<span class=\"cm\">⊢ ↑x_1.multinomial =</span>\n<span class=\"cm\">  (finset.filter</span>\n<span class=\"cm\">    (λ (a : fin n → α), multiset.map a finset.univ.val = ⇑(sym_finset_to_multiset s n) x_1)</span>\n<span class=\"cm\">    (fintype.pi_finset (λ (a : fin n), s))).card</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 295633355,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661628331
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> Thanks a lot! I had made one more step in my original proof, but that sort of fell flat. I'm going to take a good look at it all and see if I get it and then try and fill in the sorry:)</p>",
        "id": 295634237,
        "sender_full_name": "Pim Otte",
        "timestamp": 1661628958
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"519269\">@Pim Otte</span>  I just discovered <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sym\">docs#finset.sym</a> which can make the statement of the multinomial theorem simpler (removes the coercion), and probably the proof as well.<br>\nI made some progress in the direction of the inductive approach suggested by <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, and it looks like it's gonna yield a shorter proof. Here's my progress so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">sym_insert_of_sigma_sym_sub</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">sym</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">sym</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">m.2.1.map</span> <span class=\"o\">(</span><span class=\"n\">set.inclusion</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_insert_of_mem</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">m.1.1</span> <span class=\"bp\">•</span> <span class=\"o\">{⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">s.mem_insert_self</span> <span class=\"n\">a</span><span class=\"o\">⟩},</span>\n  <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">multiset.card_add</span><span class=\"o\">,</span> <span class=\"n\">multiset.card_map</span><span class=\"o\">,</span> <span class=\"n\">m.2.2</span><span class=\"o\">,</span> <span class=\"n\">multiset.card_nsmul</span><span class=\"o\">,</span>\n    <span class=\"n\">multiset.card_singleton</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"n\">nat.sub_add_cancel</span> <span class=\"o\">(</span><span class=\"n\">nat.lt_succ_iff.1</span> <span class=\"n\">m.1.2</span><span class=\"o\">)</span> <span class=\"o\">}⟩</span>\n\n<span class=\"kd\">@[simps]</span> <span class=\"kd\">def</span> <span class=\"n\">sym_insert_equiv_sigma_sym_sub</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">sym</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"bp\">≃</span> <span class=\"bp\">Σ</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">sym</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"o\">⟨⟨(</span><span class=\"n\">m.1.map</span> <span class=\"n\">coe</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">count</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n    <span class=\"o\">(</span><span class=\"n\">multiset.count_le_card</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans_lt</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">multiset.card_map</span><span class=\"o\">,</span> <span class=\"n\">m.2</span><span class=\"o\">,</span> <span class=\"n\">nat.lt_succ_iff</span><span class=\"o\">]⟩,</span>\n    <span class=\"o\">(</span><span class=\"n\">m.1.filter</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x.1</span> <span class=\"bp\">≠</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">attach.map</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_of_mem_insert_of_ne</span> <span class=\"n\">x.1.2</span> <span class=\"o\">(</span><span class=\"n\">multiset.mem_filter.1</span> <span class=\"n\">x.2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">⟩),</span>\n    <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">multiset.card_map</span><span class=\"o\">,</span> <span class=\"n\">multiset.card_attach</span><span class=\"o\">,</span> <span class=\"n\">subtype.coe_mk</span><span class=\"o\">,</span> <span class=\"n\">multiset.count_map</span><span class=\"o\">],</span>\n      <span class=\"n\">convert</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">tsub_eq_of_eq_add</span> <span class=\"bp\">$</span> <span class=\"n\">multiset.card_eq_countp_add_countp</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">multiset.countp_eq_card_filter</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">m.2</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">not_ne_iff</span><span class=\"o\">,</span> <span class=\"n\">eq_comm</span><span class=\"o\">],</span> <span class=\"n\">apply</span> <span class=\"n\">multiset.countp_eq_card_filter</span> <span class=\"o\">}</span> <span class=\"o\">}⟩,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"n\">sym_insert_of_sigma_sym_sub</span> <span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">multinomial_theorem</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">s.sum</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">sym</span> <span class=\"n\">s</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">k.val.multinomial</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">k.val.map</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∘</span> <span class=\"n\">coe</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">s</span> <span class=\"n\">using</span> <span class=\"n\">finset.induction</span> <span class=\"k\">with</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"n\">ha</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">finset.sum_empty</span><span class=\"o\">,</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">pow_zero</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_unique_nonempty</span><span class=\"o\">],</span>\n      <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">one_mul</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">nat.cast_one</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">finset.univ_nonempty</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">pow_succ</span><span class=\"o\">,</span> <span class=\"n\">zero_mul</span><span class=\"o\">],</span>\n      <span class=\"n\">convert</span> <span class=\"n\">finset.sum_of_empty.symm</span><span class=\"o\">,</span>\n      <span class=\"n\">convert</span> <span class=\"n\">sym.is_empty</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">finset.is_empty_coe_sort</span><span class=\"o\">,</span>\n      <span class=\"c\">/-</span><span class=\"cm\"> extract instance: finset version of set.has_emptyc.emptyc.is_empty -/</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.sum_insert</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">add_pow</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_range</span><span class=\"o\">],</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">finset.mul_sum</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_mul</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_sigma'</span><span class=\"o\">],</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> now apply fintype.sum_equiv with `sym_insert_equiv_sigma_sym_sub` and</span>\n<span class=\"cm\">    rewrite by `multinomial_insert` in #16170;</span>\n<span class=\"cm\">    however if we switch to `finset.sym` in the statement</span>\n<span class=\"cm\">    then we would have to use `finset.sum_bij` or `sum_bij'`. -/</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 295669847,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661665304
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/Multinomial.20coefficients.20definition/near/293635819\">said</a>:</p>\n<blockquote>\n<p>Also mind <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sym\">docs#finset.sym</a> as a way to avoid fintype computation. I introduced it a while back precisely for multinomial coefficients.</p>\n</blockquote>\n<p><span aria-label=\"point up\" class=\"emoji emoji-1f446\" role=\"img\" title=\"point up\">:point_up:</span> <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 295672923,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661668571
    },
    {
        "content": "<p>Small rewrite to use finset.sym (which actually does seem to simplify the first part) and to bring the <code>(n : ℕ)</code> to the theorem statement, which I think is preferred?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">multinomial_theorem</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">):</span>\n <span class=\"o\">(</span><span class=\"n\">s.sum</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">k</span> <span class=\"k\">in</span> <span class=\"n\">finset.sym</span> <span class=\"n\">s</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">k.val.multinomial</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">k.val.map</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n <span class=\"n\">revert</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n <span class=\"n\">induction</span> <span class=\"n\">s</span> <span class=\"n\">using</span> <span class=\"n\">finset.induction</span> <span class=\"k\">with</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"n\">ha</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">finset.sum_empty</span><span class=\"o\">,</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">pow_zero</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_unique_nonempty</span><span class=\"o\">],</span>\n      <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">one_mul</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">nat.cast_one</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">finset.univ_nonempty</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">pow_succ</span><span class=\"o\">,</span> <span class=\"n\">zero_mul</span><span class=\"o\">,</span> <span class=\"n\">finset.sym_empty</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_empty</span><span class=\"o\">],</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.sum_insert</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">add_pow</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_range</span><span class=\"o\">],</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">finset.mul_sum</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_mul</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_sigma'</span><span class=\"o\">],</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> TODO: use `finset.sum_bij(')`and rewrite by `multinomial_insert` in #16170; -/</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 295714595,
        "sender_full_name": "Pim Otte",
        "timestamp": 1661695720
    },
    {
        "content": "<blockquote>\n<p>bring the (n : ℕ) to the theorem statement, which I think is preferred?</p>\n</blockquote>\n<p>All arguments before the colon is the general conventnion, but you occasionally see arguments after the colon because it makes the proof shorter, as is the case here.</p>",
        "id": 295720249,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661699057
    },
    {
        "content": "<p>I think the only \"guideline\" is make the proof shortest - <code>revert/intros</code> at the very start is always unnecessary. Still, I often see <code>revert</code> at the start, and this is also often OK, especially when the terms being reverted are part of a <code>variables</code> statement</p>",
        "id": 295723798,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1661701061
    },
    {
        "content": "<p><code>intros</code> at the beginning is not always a bad sign. For example if you want to prove that some function is injective, you will <code>intros a b hab</code></p>",
        "id": 295729082,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661703925
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"519269\">@Pim Otte</span> I now have a complete proof using the inductive approach at <a href=\"https://gist.github.com/alreadydone/f9d4444bde854a77e9771db3c9011cb1\">https://gist.github.com/alreadydone/f9d4444bde854a77e9771db3c9011cb1</a> . Indeed using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sym\">docs#finset.sym</a> makes things smoother. Have you been working on the orbit-stabilizer approach? I would be curious to know about any progress.</p>\n<p>I'm not sure if it's worth providing the original statement using <code>sym s n</code> as a version of the theorem, but I think it's definitely worth making a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.nat.antidiagonal_tuple\">docs#finset.nat.antidiagonal_tuple</a> version when <code>s</code> is <code>finset.univ</code> in <code>fin k</code>. For general <code>s</code> with a bijection to <code>fin k</code>, I think it's also worth providing the antidiagonal_tuple version, as it allows more efficient computation.</p>",
        "id": 295756871,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661720286
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> Awesome! I had not made any progress on the orbit-stabilizer approach. I don't really have an opinion one way or the other on alternative proofs, but I think for what I was working on this would be sufficient.</p>\n<p>If we move this into mathlib, would stuff like <code>finsupp.multinomial</code> go in the <code>data.nat.choose.multinomial</code> (edited), but with a <code>finsupp</code> namespace? </p>\n<p>Is it okay if I PR this with you as co-author, in a new PR, dependent  on <a href=\"https://github.com/leanprover-community/mathlib/pull/16170\">#16170</a>?</p>",
        "id": 295787890,
        "sender_full_name": "Pim Otte",
        "timestamp": 1661754794
    },
    {
        "content": "<p>Feel free to PR! I think it's most natural to include the various versions of multinomial coefficients in the multinomial file. data.nat.choose seems a weird place. For example, we can't state finsuop.multinomial_eq without the finset version. (And I think the finset version should probably be renamed finset.multinomial.)</p>",
        "id": 295789094,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661755486
    },
    {
        "content": "<p>Interestingly there is another thing that could be called <code>multiset.multinomial</code>, which comes from showing the original <code>list.multinomial</code> (which takes a list of multiplicities as input) is independent of the order of the multiplicities. (And we could also define docs$nat.partition .multinomial.) Do we want both multiset versions, and if so how should we disambiguate the names?</p>",
        "id": 295905561,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661786411
    },
    {
        "content": "<p>I don't really have the overview to see if we need the alternative version and the naming conventions. Since you can always convert the list to a finsupp easily and use that for the multinomial, I think it's fine using the current version as <code>multiset.mutinomial</code>, and worrying about an alternative name for the other version later?</p>",
        "id": 295930010,
        "sender_full_name": "Pim Otte",
        "timestamp": 1661787199
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 295941582,
        "sender_full_name": "Luis Castillo",
        "timestamp": 1661788176
    },
    {
        "content": "<p>I think <code>multiset.multinomial</code> is good for the current version; the other version could be called <code>multiset.nat_multinomial</code> or <code>multiset.nat.multinomial</code>. The latter dot notation needs a special ^ trick to work and I don't know where it's documented (I only discovered it in the last month) or if anything changed in Lean 4, but it's used for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ideal.quotient.mk\">docs#ideal.quotient.mk</a> <a href=\"https://github.com/leanprover-community/mathlib/blob/b490ab4ac99873a41a6fc5731cb548728d6df9d5/src/ring_theory/ideal/quotient.lean#L116\">here</a> for example.</p>",
        "id": 296016960,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661816971
    }
]
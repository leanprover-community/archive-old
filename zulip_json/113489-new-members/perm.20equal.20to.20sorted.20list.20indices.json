[
    {
        "content": "<p>Hi all, can someone point me in the right direction for the following proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.linarith</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mergesort_length_preserve</span> <span class=\"o\">(</span><span class=\"n\">lst</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">lt</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"n\">lt</span><span class=\"o\">]:</span> <span class=\"o\">(</span><span class=\"n\">list.merge_sort</span> <span class=\"n\">lt</span> <span class=\"n\">lst</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"n\">lst.length</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">exact</span> <span class=\"n\">list.perm.length_eq</span> <span class=\"o\">(</span><span class=\"n\">list.perm_merge_sort</span> <span class=\"n\">lt</span> <span class=\"n\">lst</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ind_in_sorted_list</span> <span class=\"o\">(</span><span class=\"n\">lst</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ind</span><span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">lst.length</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">lt</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">v1</span><span class=\"o\">,</span> <span class=\"n\">decidable_pred</span> <span class=\"o\">(</span><span class=\"n\">lt</span> <span class=\"n\">v1</span><span class=\"o\">)]:</span>\n<span class=\"bp\">↑</span><span class=\"n\">ind</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">list.merge_sort</span> <span class=\"n\">lt</span> <span class=\"n\">lst</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mergesort_length_preserve</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">fin.is_lt</span> <span class=\"n\">ind</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">exists_perm_eq_sort</span> <span class=\"o\">(</span><span class=\"n\">lst</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">lt</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">v1</span><span class=\"o\">,</span> <span class=\"n\">decidable_pred</span> <span class=\"o\">(</span><span class=\"n\">lt</span> <span class=\"n\">v1</span><span class=\"o\">)]:</span>\n<span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"o\">:</span> <span class=\"n\">equiv.perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">lst.length</span><span class=\"o\">))),</span> <span class=\"bp\">∀</span> <span class=\"n\">ind</span><span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">lst.length</span><span class=\"o\">),</span> <span class=\"n\">lst.nth_le</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"n\">ind</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin.is_lt</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">list.merge_sort</span> <span class=\"n\">lt</span> <span class=\"n\">lst</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nth_le</span> <span class=\"n\">ind</span> <span class=\"o\">(</span><span class=\"n\">ind_in_sorted_list</span> <span class=\"n\">_</span> <span class=\"n\">lst</span> <span class=\"n\">ind</span> <span class=\"n\">lt</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Namely, I'm not sure how to instantiate the <code>∃ perm</code>. My idea was to sort a modified version of the original list where each element is a pair that also contains the original list index and reconstruct the index permutation from that... is there a better way?</p>\n<p>P.S. In case it's relevant, I need something of this form because my proofs for my larger project require me to show that sorting the rows of a matrix is equivalent to some permutation of the matrix's rows.</p>",
        "id": 276951860,
        "sender_full_name": "Evan Lohn",
        "timestamp": 1648521165
    },
    {
        "content": "<p>Not sure what the best way to prove it is (we probably have something along those lines in mathlib, although I don't know what), but as an answer to your question <em>\"How to instantiate the <code>∃ perm</code>\"</em> - you can write a simple function that takes two list and some index <code>i</code> in the first list and returns the index of the same element in the second list. In case there are duplicates, you would subtract the number of equal elements previously encountered. But it would be painful to prove that it is a bijection.</p>\n<p>Another way would be to use an inductive data type to represent list permutations:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.induction</span>\n\n<span class=\"kd\">inductive</span> <span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">perm</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span>   <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"o\">[]</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span>  <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">perm</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"bp\">→</span> <span class=\"n\">perm</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">l₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">l₂</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">swap</span>  <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">perm</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">l</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">trans</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"n\">l₃</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">perm</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"bp\">→</span> <span class=\"n\">perm</span> <span class=\"n\">l₂</span> <span class=\"n\">l₃</span> <span class=\"bp\">→</span> <span class=\"n\">perm</span> <span class=\"n\">l₁</span> <span class=\"n\">l₃</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">perm_of_list_perm</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">xs</span> <span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">xs</span> <span class=\"bp\">~</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"o\">,</span> <span class=\"n\">induction'</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">perm.nil</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">perm.cons</span> <span class=\"n\">x</span> <span class=\"n\">ih</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">perm.swap</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">l</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">ih_h</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">ih_h_1</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">perm.trans</span> <span class=\"n\">ih_h</span> <span class=\"n\">ih_h_1</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Then you can obtain a prop permutation from <code>list.perm_merge_sort</code> and convert it to data using <code>perm_of_list_perm</code>. Then you can implement a function that constructs <code>equiv.perm</code> from <code>perm</code> recursively. Finally, you will need to prove that such permutation satisfies the <code>nth_le</code> relation that you need.</p>\n<p>As a side note, when using <code>nth_le</code> in a lemma statement, you don't need to actually prove the requirement in order to invoke <code>nth_le</code>. You can simply assert that a proof exists. Your lemma statement can be simplified to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">exists_perm_eq_sort</span> <span class=\"o\">(</span><span class=\"n\">lst</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">lt</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">v1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">decidable_pred</span> <span class=\"o\">(</span><span class=\"n\">lt</span> <span class=\"n\">v1</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"o\">:</span> <span class=\"n\">equiv.perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">lst.length</span><span class=\"o\">)),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">ind</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">lst.length</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n  <span class=\"n\">lst.nth_le</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"n\">ind</span><span class=\"o\">)</span> <span class=\"n\">h₁</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">list.merge_sort</span> <span class=\"n\">lt</span> <span class=\"n\">lst</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nth_le</span> <span class=\"n\">ind</span> <span class=\"n\">h₂</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 276978381,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1648545755
    },
    {
        "content": "<p>The module where <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tuple.sort\">docs#tuple.sort</a> is might be helpful</p>",
        "id": 277028831,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648570188
    },
    {
        "content": "<p>You could pass it the <code>fin</code> version of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.nth_le\">docs#list.nth_le</a> (I forget what that is, if there is one)</p>",
        "id": 277029088,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648570271
    }
]
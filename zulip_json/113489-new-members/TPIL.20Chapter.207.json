[
    {
        "content": "<ol>\n<li>I'm running into type issues with inductively defined types that Lean already has defined. For example, when I try running the code from the book below, I get an error in add_zero that n is of type N but type nat is expected. </li>\n</ol>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">nat</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">nat</span>\n<span class=\"n\">def</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">add_m_n</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">add_m_n</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">reduce</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">zero</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">zero</span><span class=\"o\">))</span>\n\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_zero</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"n\">has_zero</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">zero</span> <span class=\"c1\">--instance is explained in ch 10</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"n\">has_add</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">add</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">add_zero</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">add_succ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">--this is how we defined addition</span>\n\n\n<span class=\"kn\">theorem</span> <span class=\"n\">zero_add</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">n</span>\n  <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"k\">assume</span> <span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"k\">show</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"k\">from</span>\n      <span class=\"k\">calc</span>\n        <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">rfl</span>\n          <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">ih</span><span class=\"o\">)</span>\n\n\n<span class=\"kn\">end</span> <span class=\"n\">nat</span>\n</pre></div>\n\n\n<p>Similarly, when I define <code>bool</code>I get the same error when I do <code>bool.cases_on</code></p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">unit</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">star</span> <span class=\"o\">:</span> <span class=\"n\">unit</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">bool</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">ff</span> <span class=\"o\">:</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"n\">tt</span> <span class=\"o\">:</span> <span class=\"n\">bool</span>\n\n<span class=\"c1\">--EXERCISE: Define band bor bnot on this new bool type</span>\n\n<span class=\"n\">def</span> <span class=\"n\">band</span> <span class=\"o\">(</span><span class=\"n\">b1</span> <span class=\"n\">b2</span> <span class=\"o\">:</span> <span class=\"n\">hidden</span><span class=\"bp\">.</span><span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">hidden</span><span class=\"bp\">.</span><span class=\"n\">bool</span> <span class=\"o\">:=</span>\n<span class=\"n\">bool</span><span class=\"bp\">.</span><span class=\"n\">cases_on</span> <span class=\"n\">b1</span> <span class=\"n\">ff</span> <span class=\"n\">b2</span>\n\n<span class=\"n\">def</span> <span class=\"n\">bor</span> <span class=\"o\">(</span><span class=\"n\">b1</span> <span class=\"n\">b2</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span>\n<span class=\"n\">bool</span><span class=\"bp\">.</span><span class=\"n\">cases_on</span> <span class=\"n\">b1</span> <span class=\"n\">b2</span> <span class=\"n\">tt</span>\n\n<span class=\"n\">def</span> <span class=\"n\">bnot</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span>\n<span class=\"n\">bool</span><span class=\"bp\">.</span><span class=\"n\">cases_on</span> <span class=\"n\">b</span> <span class=\"n\">tt</span> <span class=\"n\">ff</span>\n</pre></div>\n\n\n<p>The same issue comes up when I do <code>sum</code> and <code>prod</code> from the book. I've been copying over the text from the book, and have imported <code>data.nat.basic</code> and <code>tactic</code></p>",
        "id": 190544119,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1584127201
    },
    {
        "content": "<p>Try adding <code>namespace mydefs</code> before your code and <code>end mydefs</code> after your code. That should help Lean disambiguate the names.</p>",
        "id": 190544304,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1584127294
    },
    {
        "content": "<p>Choosing different names is also a very efficient way to disambiguate.</p>",
        "id": 190544418,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584127334
    },
    {
        "content": "<p>Note that in <code>zero_add</code>, <code>ℕ</code> is notation for the built-in <code>nat</code> (<code>_root_.nat</code>), so it fails.</p>",
        "id": 190544936,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1584127654
    },
    {
        "content": "<p>Not sure why the <code>show</code> fails, but this works:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">zero_add</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">n</span>\n  <span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"k\">assume</span> <span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"k\">show</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">,</span> <span class=\"k\">from</span>\n      <span class=\"k\">calc</span>\n        <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">rfl</span>\n          <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">ih</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 190545113,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1584127745
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190544936\" title=\"#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190544936\">said</a>:</p>\n<blockquote>\n<p>Note that in <code>zero_add</code>, <code>ℕ</code> is notation for the built-in <code>nat</code> (<code>_root_.nat</code>), so it fails.</p>\n</blockquote>\n<p>Interesting, yeah I'm also getting that it fails when I use show but not when I just use <code>(rfl)</code> like you are.</p>",
        "id": 190545956,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1584128199
    },
    {
        "content": "<p>I'm also getting an error on the <code>#check</code> term at the end when I try to do </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">{}</span> <span class=\"o\">:</span> <span class=\"n\">list</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"bp\">→</span> <span class=\"n\">list</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">list</span>\n<span class=\"kn\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"kn\">notation</span> <span class=\"n\">h</span> <span class=\"bp\">::</span> <span class=\"n\">t</span>  <span class=\"o\">:=</span> <span class=\"n\">cons</span> <span class=\"n\">h</span> <span class=\"n\">t</span>\n<span class=\"n\">def</span> <span class=\"n\">append</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">l</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">s</span>\n<span class=\"kn\">notation</span> <span class=\"n\">s</span> <span class=\"bp\">++</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">append</span> <span class=\"n\">s</span> <span class=\"n\">t</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">nil_append</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nil</span> <span class=\"bp\">++</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">cons_append</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">s</span> <span class=\"bp\">++</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">++</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kn\">notation</span> <span class=\"err\">&#39;</span><span class=\"o\">[</span><span class=\"err\">&#39;</span> <span class=\"n\">l</span><span class=\"o\">:(</span><span class=\"n\">foldr</span> <span class=\"err\">&#39;</span><span class=\"o\">,</span><span class=\"err\">&#39;</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">cons</span> <span class=\"n\">h</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">nil</span><span class=\"o\">)</span> <span class=\"err\">&#39;</span><span class=\"o\">]</span><span class=\"err\">&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">l</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">([</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"c1\">--EDIT: It only happens when I open a new section like this</span>\n<span class=\"kn\">section</span>\n    <span class=\"kn\">open</span> <span class=\"n\">nat</span>\n    <span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"mi\">5</span><span class=\"o\">]</span>\n    <span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"bp\">ℤ</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 190546755,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1584128670
    },
    {
        "content": "<p>I'm very confused by the exercises suggested at the end of section 7.2. They read</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">As</span> <span class=\"n\">exercises</span><span class=\"o\">,</span> <span class=\"n\">we</span> <span class=\"n\">encourage</span> <span class=\"n\">you</span> <span class=\"n\">to</span> <span class=\"n\">develop</span> <span class=\"n\">a</span> <span class=\"n\">notion</span> <span class=\"n\">of</span> <span class=\"n\">composition</span> <span class=\"n\">for</span> <span class=\"n\">partial</span> <span class=\"n\">functions</span> <span class=\"k\">from</span> <span class=\"n\">α</span> <span class=\"n\">to</span> <span class=\"n\">β</span> <span class=\"n\">and</span> <span class=\"n\">β</span> <span class=\"n\">to</span> <span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"n\">and</span> <span class=\"k\">show</span> <span class=\"n\">that</span> <span class=\"n\">it</span> <span class=\"n\">behaves</span> <span class=\"n\">as</span> <span class=\"n\">expected</span><span class=\"bp\">.</span> <span class=\"n\">We</span> <span class=\"n\">also</span> <span class=\"n\">encourage</span> <span class=\"n\">you</span> <span class=\"n\">to</span> <span class=\"k\">show</span> <span class=\"n\">that</span> <span class=\"n\">bool</span> <span class=\"n\">and</span> <span class=\"n\">nat</span> <span class=\"n\">are</span> <span class=\"n\">inhabited</span><span class=\"o\">,</span> <span class=\"n\">that</span> <span class=\"n\">the</span> <span class=\"n\">product</span> <span class=\"n\">of</span> <span class=\"n\">two</span> <span class=\"n\">inhabited</span> <span class=\"n\">types</span> <span class=\"n\">is</span> <span class=\"n\">inhabited</span><span class=\"o\">,</span> <span class=\"n\">and</span> <span class=\"n\">that</span> <span class=\"n\">the</span> <span class=\"n\">type</span> <span class=\"n\">of</span> <span class=\"n\">functions</span> <span class=\"n\">to</span> <span class=\"n\">an</span> <span class=\"n\">inhabited</span> <span class=\"n\">type</span> <span class=\"n\">is</span> <span class=\"n\">inhabited</span><span class=\"bp\">.</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">option</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">{}</span> <span class=\"o\">:</span> <span class=\"n\">option</span>\n<span class=\"bp\">|</span> <span class=\"n\">some</span>    <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">inhabited</span>\n</pre></div>\n\n\n<p>For the inhabited type, I understand conceptually that given an example of an instance of a type, we could generate an object that says this type is inhabited. I'm at a loss for how to actually do something like <code>define inhabited_example ...</code> the we the book does for sum and prod. </p>\n<p>For option, I'm substantially more confused. It seems like option would go from a given element of the domain to either none or to a defined function, not the other way around. I feel like I'm misunderstanding something about what it means to have a recursively defined type.</p>",
        "id": 190799779,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1584408208
    },
    {
        "content": "<p><code>option A</code> is a type which has one more element than <code>A</code>. The extra element is called <code>none : option A</code>, and the function that maps <code>A</code> into <code>option A</code> is called <code>some : A -&gt; option A</code>.</p>",
        "id": 190801100,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584409853
    },
    {
        "content": "<p>Can you prove</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 190801192,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584410008
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190801192\" title=\"#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190801192\">said</a>:</p>\n<blockquote>\n<p>Can you prove</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n</blockquote>\n<p>I'm not sure... If we have proofs that A and B and inhabited, it makes sense me that <code>A x B</code> would be inhabited. My intuition is to apply <code>inhabited.mk</code> to the product of the two instances we have, but that gives me a type error (understandably). Is there a way to extract the actual instance from an <code>inhabited</code> object so we can use it to make a new one?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">inhabited</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"bp\">×</span> <span class=\"n\">h2</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 190802208,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1584411567
    },
    {
        "content": "<p>(deleted, I was using Lean's definition of inhabited, not the one given by TPiL...)</p>",
        "id": 190802713,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1584412442
    },
    {
        "content": "<p>One way is to use the <code>match ... with ... end</code> syntax:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">inhabited</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">inhabited</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">inhabited</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">⟩</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>This syntax \"pattern matches\" on <code>h1</code> and <code>h2</code> to pull out <code>a : A</code> and <code>b : B</code>.</p>\n<p>You can also use angle brackets in place of the constructors like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">b</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">⟩⟩</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 190803827,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1584414199
    },
    {
        "content": "<p>Compare also:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h1</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"bp\">⟨</span><span class=\"n\">b</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h2</span> <span class=\"k\">in</span>\n<span class=\"bp\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">⟩⟩</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">inhabited</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">b</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">⟩⟩</span>\n</pre></div>",
        "id": 190803999,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1584414445
    },
    {
        "content": "<p>Oh, pattern-matching is introduced in chapter 8, so I guess you're meant  to use <code>inhabited.cases_on</code> instead. Here's a hint:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">inhabited</span><span class=\"bp\">.</span><span class=\"n\">cases_on</span> <span class=\"n\">h1</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">inhabited</span><span class=\"bp\">.</span><span class=\"n\">cases_on</span> <span class=\"n\">h2</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">))</span>\n</pre></div>\n\n\n<p>[I was hoping this would work with dot notation (so I could write <code>h1.cases_on</code> and <code>h2.cases_on</code> instead of <code>inhabited.cases_on h1</code>, etc.) but it looks like that's too much for the elaborator...]</p>",
        "id": 190805054,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1584415755
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190805054\" title=\"#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190805054\">said</a>:</p>\n<blockquote>\n<p>Oh, pattern-matching is introduced in chapter 8, so I guess you're meant  to use <code>inhabited.cases_on</code> instead. Here's a hint:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">inhabited</span><span class=\"bp\">.</span><span class=\"n\">cases_on</span> <span class=\"n\">h1</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">inhabited</span><span class=\"bp\">.</span><span class=\"n\">cases_on</span> <span class=\"n\">h2</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">))</span>\n</pre></div>\n\n\n<p>[I was hoping this would work with dot notation (so I could write <code>h1.cases_on</code> and <code>h2.cases_on</code> instead of <code>inhabited.cases_on h1</code>, etc.) but it looks like that's too much for the elaborator...]</p>\n</blockquote>\n<p>Thanks for your detailed answer! I'm getting a \"don't know how to synthesize placeholder<br>\ncontext:\" error on the wildecard. Is there something I need to import somewhere? I'm also still a little confused conceptually by how this works but maybe that'll be cleared up after reading chapter 8.</p>",
        "id": 190939609,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1584507835
    },
    {
        "content": "<p>I think part of my confusion comes from the fact that all the solutions you gave rely on implicit notation using either brackets or wildcards. Is there an explicit way to show a type is inhabited, or is that not the way I should be thinking about this problem?</p>",
        "id": 190939723,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1584508053
    },
    {
        "content": "<blockquote>\n<p>I'm getting a \"don't know how to synthesize placeholder context:\" error on the wildecard.</p>\n</blockquote>\n<p>That's right, the underscore was left for you to fill in. <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span> </p>\n<blockquote>\n<p>Is there something I need to import somewhere?</p>\n</blockquote>\n<p>No imports necessary!</p>\n<blockquote>\n<p>Is there an explicit way to show a type is inhabited</p>\n</blockquote>\n<p>Yep, in this context, <code>⟨⟨a, b⟩⟩</code> is just shorthand for to <code>inhabited.mk (prod.mk a b)</code>.</p>",
        "id": 190939865,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1584508329
    },
    {
        "content": "<p>Oh, that makes sense haha. I thought you were intentionally leaving it as a wildcard. This is very helpful, thank you!</p>",
        "id": 190939929,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1584508447
    },
    {
        "content": "<p>Ok I'm still a little confused about how <code>option</code> works. I'm trying to define a simple function that is the identity on 0 and 1, and undefined everywhere else. I'm getting a type mismatch error on all three <code>:=</code> signs when I do the following. Any thoughts?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">partial</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"bp\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">none</span>\n</pre></div>",
        "id": 190941372,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1584511012
    },
    {
        "content": "<p>it does not give any error for me.</p>",
        "id": 190941519,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1584511304
    },
    {
        "content": "<p>Rocky's using the <code>option</code> defined in TPiL, so the full code is something like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">namespace</span> <span class=\"n\">blah</span>\n<span class=\"kn\">universe</span> <span class=\"n\">u</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">option</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">{}</span> <span class=\"o\">:</span> <span class=\"n\">option</span>\n<span class=\"bp\">|</span> <span class=\"n\">some</span>    <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span>\n\n\n<span class=\"n\">def</span> <span class=\"n\">partial</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"bp\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">none</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">blah</span>\n</pre></div>",
        "id": 190941706,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1584511576
    },
    {
        "content": "<p><del>The solution is to add <code>open option</code> before <code>def partial</code>.</del></p>\n<p>This works:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">namespace</span> <span class=\"n\">blah</span>\n<span class=\"kn\">universe</span> <span class=\"n\">u</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">option</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">{}</span> <span class=\"o\">:</span> <span class=\"n\">option</span>\n<span class=\"bp\">|</span> <span class=\"n\">some</span>    <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span>\n\n<span class=\"n\">def</span> <span class=\"n\">partial</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"bp\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">none</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">blah</span>\n</pre></div>",
        "id": 190941716,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1584511614
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span>  for catching that! Adding <code>open option</code> doesn't seem to resolve this issue. Leaving the namespace and using lean's default <code>option</code> does work though. I thought the two definitions were the same here... is that not the case?</p>",
        "id": 190941794,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1584511719
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190941716\" title=\"#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190941716\">said</a>:</p>\n<blockquote>\n<p><del>The solution is to add <code>open option</code> before <code>def partial</code>.</del></p>\n<p>This works:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">namespace</span> <span class=\"n\">blah</span>\n<span class=\"kn\">universe</span> <span class=\"n\">u</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">option</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">{}</span> <span class=\"o\">:</span> <span class=\"n\">option</span>\n<span class=\"bp\">|</span> <span class=\"n\">some</span>    <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span>\n\n<span class=\"n\">def</span> <span class=\"n\">partial</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"bp\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">none</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">blah</span>\n</pre></div>\n\n\n</blockquote>\n<p>That did the trick. Thank you!</p>",
        "id": 190941805,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1584511771
    },
    {
        "content": "<p>Yeah, it wasn't <code>open option</code> that worked but rather surrounding <code>def partial</code> with <code>namespace option</code> and <code>end option</code> (or writing the names out fully as I did above).</p>",
        "id": 190941884,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1584511910
    },
    {
        "content": "<p>The <code>option</code> provided by Lean's core library is equivalent, but you can't use it when Lean is expecting your <code>option</code>.</p>",
        "id": 190941932,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1584511959
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190941932\" title=\"#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190941932\">said</a>:</p>\n<blockquote>\n<p>The <code>option</code> provided by Lean's core library is equivalent, but you can't use it when Lean is expecting your <code>option</code>.</p>\n</blockquote>\n<p>Makes sense. This has come up before when TPIL makes you define types that are built in and I've forgotten that the interactions are a little different. Thanks!</p>",
        "id": 190941986,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1584512060
    },
    {
        "content": "<p>Another question: I'm trying to define the composite of partial functions also discussed in this section. I have this so far, and am (understandably) running into an error when I try to apply <code>g</code> to <code>(f a)</code> because it is an element of <code>option β</code> rather than <code>β</code>. Is there an easy way to convert back from an option type to the element of the regular type?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">compose_partials</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">γ</span>  <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">cases_on</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">none</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 190941987,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1584512076
    },
    {
        "content": "<p><del>I think you might need a helper function like this:</del></p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">helper</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"o\">(</span><span class=\"n\">option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">option</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span>               <span class=\"o\">:=</span> <span class=\"n\">none</span>\n</pre></div>\n\n\n<p><del>I don't think there is a way to have a function where<code>f : option a -&gt; a</code> in Lean, since <code>f none</code> would require you to be able to make a value of type <code>a</code> for all <code>a</code>.</del></p>\n<p><del>In other languages (Haskell, etc.) there is what you're looking for, but they crash on the case <code>f none</code>.</del></p>\n<p>Nevermind.</p>",
        "id": 190942392,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1584512825
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">compose_partials</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">cases_on</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">none</span> <span class=\"n\">g</span>\n</pre></div>\n\n\n<p>I think maybe you were thrown off by having <code>none</code> in the wrong slot.</p>",
        "id": 190942608,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1584513088
    },
    {
        "content": "<p>I think this is called <code>bind</code> and it's basically the proof that <code>option</code> is a monad</p>",
        "id": 190946023,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584517092
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190942608\" title=\"#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190942608\">said</a>:</p>\n<blockquote>\n<p>This works:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">compose_partials</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">cases_on</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">none</span> <span class=\"n\">g</span>\n</pre></div>\n\n\n<p>I think maybe you were thrown off by having <code>none</code> in the wrong slot.</p>\n</blockquote>\n<p>Wouldn't this just give us the function g in the case that a is in the domain of f, and not the element that g maps (f a) to? Or am I missing something?</p>",
        "id": 191068324,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1584587844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266440\">Shing Tak Lam</span> <a href=\"#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190942392\" title=\"#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190942392\">said</a>:</p>\n<blockquote>\n<p><del>I think you might need a helper function like this:</del></p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">helper</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"o\">(</span><span class=\"n\">option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">option</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span>               <span class=\"o\">:=</span> <span class=\"n\">none</span>\n</pre></div>\n\n\n<p><del>I don't think there is a way to have a function where<code>f : option a -&gt; a</code> in Lean, since <code>f none</code> would require you to be able to make a value of type <code>a</code> for all <code>a</code>.</del></p>\n<p><del>In other languages (Haskell, etc.) there is what you're looking for, but they crash on the case <code>f none</code>.</del></p>\n<p>Nevermind.</p>\n</blockquote>\n<p>That makes sense. The notation for more abstract recursive types like this still makes my head hurt a little, but I feel like that will probably get better with time.</p>",
        "id": 191068428,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1584587982
    },
    {
        "content": "<p>It might help to see the definition expanded as <code>λ a : α, option.cases_on (f a) none (λ b, g b)</code></p>",
        "id": 191068759,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584588411
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/191068759\" title=\"#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/191068759\">said</a>:</p>\n<blockquote>\n<p>It might help to see the definition expanded as <code>λ a : α, option.cases_on (f a) none (λ b, g b)</code></p>\n</blockquote>\n<p>Using a helper function and reversing the order of the arguments to <code>option (f a) _ _</code> I still get two errors. </p>\n<p>That makes sense to me. Does <code>cases_on</code> do that automatically with the notation <span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span>  gave?</p>",
        "id": 191068857,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1584588565
    },
    {
        "content": "<p>I don't understand your question. But <code>g</code> equals <code>λ b, g b</code>.</p>",
        "id": 191068929,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584588609
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/191068929\" title=\"#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/191068929\">said</a>:</p>\n<blockquote>\n<p>I don't understand your question. But <code>g</code> equals <code>λ b, g b</code>.</p>\n</blockquote>\n<p>Oh duh, yeah I was just getting a little lost in what was taking in what and going where with <code>cases_on</code>. Yeah that makes sense now. </p>\n<p><span class=\"user-mention\" data-user-id=\"266440\">@Shing Tak Lam</span>  I tried doing something like this and got rid of the return type error but I'm getting type mismatches in my helper function and at <code>option.cases_on</code></p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">helper</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">input</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">some</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">:</span> <span class=\"n\">none</span>\n\n<span class=\"n\">def</span> <span class=\"n\">compose_partials</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">γ</span>  <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">cases_on</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">none</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">helper</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 191069073,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1584588827
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260106\">@Rocky Kamen-Rubio</span> </p>\n<p>Nevermind what I said previously. I didn't look at it properly. (I never did TPIL). So I did it with <code>option.map</code> instead of <code>option.cases_on</code>.</p>\n<p>Sorry for any confusion</p>",
        "id": 191070850,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1584591946
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"261068\">@ROCKY KAMEN-RUBIO</span> your helper definition does not look good to me. What is the type of x supposed to be in some (some x)? You say you're getting type mismatches but if you just read them carefully they will tell you by themselves the errors you made</p>",
        "id": 191079092,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584604135
    },
    {
        "content": "<p>You do understand that alpha and option alpha are completely different types, right?</p>",
        "id": 191079147,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584604197
    },
    {
        "content": "<p>There is no natural helper map of the kind you're trying to define because where is none going to go? Alpha could be empty</p>",
        "id": 191079217,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584604250
    },
    {
        "content": "<p>Maybe you should take a look at learnyouahaskell? This taught me a lot about functional programming</p>",
        "id": 191079327,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584604335
    },
    {
        "content": "<p>Given the type of <code>compose_partials</code>, it looks like the right thing to put in the location of <code>helper</code> is the identity function</p>",
        "id": 191079798,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584604690
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260106\">@Rocky Kamen-Rubio</span> </p>\n<p>The <code>helper</code> function I posted is</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">helper</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"o\">(</span><span class=\"n\">option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">option</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span>               <span class=\"o\">:=</span> <span class=\"n\">none</span>\n</pre></div>\n\n\n<p>The one you posted is below</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">helper</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">input</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">some</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">:</span> <span class=\"n\">none</span>\n</pre></div>\n\n\n<p>Notice how mine is <code>option (option α) -&gt; option α</code>, while yours is <code>option α -&gt; α</code>. That is why the first case from mine <code>(some (some x)) := some x</code> doesn't apply for you, as the left hand side <code>(some (some x))</code> has the type <code>option (option α)</code>, not <code>option α</code>. Also, the parenthesis matter here, as when used to pattern match, <code>(some (some x))</code> and <code>some (some x)</code> are different.</p>\n<p>Additionally, there is a syntax error there, it should be <code>:=</code> in the cases.</p>\n<p>Also notice the types of your cases do not match, as the first one is <code>option (option α) -&gt; option α</code>, the second one is <code>option α -&gt; α</code>, the last one is <code>option α -&gt; option ???</code>. So lean complains that all of them have different types.</p>\n<p>The helper function was when I solved it with <code>option.map</code>, and <code>option.cases_on</code> expects a different function, so that's why you're getting an error there. <code>option.map</code> would produce a <code>option (option α)</code>, which is why I needed the <code>helper</code> function, as for this example, <code>some (none)</code> is pragmatically the same as <code>none</code>, so I use <code>_</code> to catch both cases.</p>\n<p>Sorry for any confusion caused</p>",
        "id": 191082205,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1584606715
    },
    {
        "content": "<p>I'm having a some issues understanding how the book's definition of natural number addition works.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">hidden</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">myNat</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">myNat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">myNat</span> <span class=\"bp\">→</span> <span class=\"n\">myNat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">myNat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">myNat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">myNat.rec_on</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">add_m_n</span><span class=\"o\">,</span> <span class=\"n\">myNat.succ</span> <span class=\"n\">add_m_n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">hidden</span>\n</code></pre></div>\n<p>My understanding of addition in peano arithmetic is the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n<span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">++</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">++</span>\n</code></pre></div>\n<p>I 'm a little confused on the mechanics of rec_on and how add_m_n is evaluated as m + n</p>",
        "id": 254179407,
        "sender_full_name": "Lucas Teixeira",
        "timestamp": 1632217142
    },
    {
        "content": "<p>Also, this type reading</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">nat.rec_on</span>\n\n<span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span>\n  <span class=\"n\">C</span> <span class=\"n\">nat.zero</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>is completely opaque to me</p>",
        "id": 254180832,
        "sender_full_name": "Lucas Teixeira",
        "timestamp": 1632217883
    },
    {
        "content": "<p>This is exactly what this definition is doing. <code>myNat.rec_on</code> takes in</p>\n<ul>\n<li>The variable to recurse on: <code>m</code></li>\n<li>The value you want to output when the variable is <code>0</code>: <code>n</code> because <code>0 + n = n</code></li>\n<li>The value you want to output when the variable is <code>succ a</code> given the value for <code>a</code>:  <code>succ (a + n)</code> because <code>succ a + n = succ (a + n)</code>.</li>\n</ul>",
        "id": 254181207,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1632218071
    },
    {
        "content": "<p>Maybe it's a bit clearer if you write it</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">myNat</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">myNat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">myNat</span> <span class=\"bp\">→</span> <span class=\"n\">myNat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">myNat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">myNat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">myNat.rec_on</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">add_a_n</span><span class=\"o\">,</span> <span class=\"n\">myNat.succ</span> <span class=\"n\">add_a_n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>to make clear those two <code>m</code> don't have the same meaning.</p>",
        "id": 254181289,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1632218119
    },
    {
        "content": "<p>The point of a recursor of an inductive type <code>α</code> is to define a function <code>α → β</code>. To define a function from <code>α</code>, you only need to define that function for every constructor of <code>α</code>. <code>nat</code> has two constructors: <code>zero</code> and<code>succ</code>, so to define <code>C : nat → Type*</code> you only need to define <code>C 0</code> and <code>C a → C (nat.succ a)</code>  for all <code>a</code>. This is exactly what <code>nat.rec_on</code> does:<br>\n<code>Π {C : nat → Type*} (n : nat), C nat.zero → (Π (a : nat), C a → C (nat.succ a)) → C n</code><br>\n(<code>Π</code> is a synonym of <code>∀</code> used when you're defining data, but they're the same in practice)<br>\n\"For all function <code>C</code> from <code>nat</code> to anything,<br>\nif I know <code>C 0</code><br>\nand if for all <code>a : nat</code> I know <code>C (succ a)</code> from <code>C a</code>,<br>\nthen I know <code>C n</code> for all <code>n : nat</code>.\"</p>",
        "id": 254182182,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1632218540
    },
    {
        "content": "<p>Note that <code>n</code> is bound earlier than in my translation. That's the (only) difference between <code>nat.rec</code> and <code>nat.rec_on</code>: the order of the arguments.</p>",
        "id": 254182293,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1632218594
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/254182182\">said</a>:</p>\n<p>So in the case of add, would <code>add_a_n</code> be the <code>C a</code> in <code>Π {C : nat → Type*} (n : nat), C nat.zero → (Π (a : nat), C a → C (nat.succ a)) → C n</code> ??</p>",
        "id": 254184030,
        "sender_full_name": "Lucas Teixeira",
        "timestamp": 1632219540
    },
    {
        "content": "<p>Exactly! It corresponds to the value you already assigned to <code>a + n</code>.</p>",
        "id": 254184466,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1632219791
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span><br>\nThis is starting to make a lot more sense now.</p>\n<p>But I'm still a little lost for when exactly I assigned the value of <code>a + n</code>. The type signature seems to take it as an assumption. </p>\n<p>I know I assigned <code>zero</code>.<br>\nAnd I know if we recurse on any <code>n ≠ zero</code> we'll eventually hit zero.  <br>\nAnd I understand that since <code>C: myNat → myNat</code> and <code>succ : myNat → myNat</code> <code>C succ</code> doesn't type check and we're required to use <code>C (nat.succ a)</code> where <code>a : myNat</code> and to define this we'd have to know <code>C a</code> for all <code>a</code>.</p>\n<p>But I don't see where the proof for <code>C a</code> is actually constructed. Is this the part of a recursive definition where we are defining something in terms of itself?</p>",
        "id": 254187515,
        "sender_full_name": "Lucas Teixeira",
        "timestamp": 1632221698
    },
    {
        "content": "<p>Your question boils down to \"Where is the <code>n</code> in <code>succ n</code> coming from?\". The answer is that <code>succ : nat → nat</code>, so you're given <code>n : nat</code> to get <code>succ n : nat</code>. With <code>C</code>, precisely the same thing happens. You're given <code>a : nat</code> and <code>C a</code> and you must produce <code>C (succ a)</code>.</p>",
        "id": 254192471,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1632224327
    },
    {
        "content": "<p>You can think of <code>h0 : C 0</code> and <code>hsucc : Π (a : nat), C a → C (succ a)</code> as <em>instructions</em> to compute <code>C</code>.  If I want to compute <code>C 3 = C (succ (succ (succ 0)))</code>, then it will be <code>hsucc 2 (hsucc 1 (hsucc 0 h0)))</code>.</p>",
        "id": 254193227,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1632224808
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span><br>\nOkay, I think I'm getting it now.</p>\n<p>So for the purposes of demonstration let's say that <code>n: nat</code> and <code>n': nat</code></p>\n<p>The <code>a</code> in <code>C a</code> in <code>(Π (a : nat), C a → C (nat.succ a))</code> by definition of <code>nat</code> is either <code>zero</code> or <code>succ n': nat</code>. This means that <code>nat.succ a</code> is either <code>nat.succ zero</code> or <code>nat.succ (nat.succ n')</code> respectively.</p>",
        "id": 254197119,
        "sender_full_name": "Lucas Teixeira",
        "timestamp": 1632226735
    },
    {
        "content": "<p>I'm not sure that observation is interesting or helpful to your confusion, but it is correct</p>",
        "id": 254197602,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632226976
    },
    {
        "content": "<p>I am trying to understand this more and more, and I am realising that the definition</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">nat.rec_on</span>\n\n<span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span>\n  <span class=\"n\">C</span> <span class=\"n\">nat.zero</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>is actually defining a <em>family</em> of types indexed by <code>nat</code>, one <code>C n : Type*</code> for each <code>n : nat</code>(actually, on my pc I see <code>C : nat  → Sort</code>, but this makes no difference for my question). Yet then when I try to understand what goes beyond the following</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"n\">nat.rec_on</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>(which I intuitively view as the constant function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> defined inductively on <code>n</code>), I am perplexed: how is it possible that Lean accepts  <code>(zero : nat)</code> for the type <code>C zero</code>? I am happy to see types as being terms of <code>Type1</code> but is it also the case that every term like <code>zero : nat </code> is a Type?</p>",
        "id": 255724474,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1633085412
    },
    {
        "content": "<p>Welcome! <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span></p>",
        "id": 255724724,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1633085570
    },
    {
        "content": "<p>In the case of usual induction <code>C n</code> is of type <code>Prop</code> everywhere. That's how I understand it.</p>",
        "id": 255724757,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1633085597
    },
    {
        "content": "<p>I think it's a bit clearer what's going on you write it out with <code>@</code>:</p>\n<p><code>def foo (n : nat) : nat := @nat.rec_on (λ _, nat) n (zero : nat) (λ n m, (zero : nat))</code></p>",
        "id": 255724792,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1633085611
    },
    {
        "content": "<p>Note that <code>(zero : nat)</code> is not <code>C 0</code>, it's a value of type <code>C 0</code>, i.e., a value of type <code>nat</code></p>",
        "id": 255724895,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1633085655
    },
    {
        "content": "<p>(This code also breaks my brain, fwiw)</p>",
        "id": 255725044,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1633085744
    },
    {
        "content": "<p>Well, but if <code>C</code> takes values in <code>Type*</code> it cannot take values in <code>nat</code>, right?</p>",
        "id": 255725327,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1633085896
    },
    {
        "content": "<p>C is the type of what you're making, so C 0 = nat</p>",
        "id": 255725357,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1633085917
    },
    {
        "content": "<p>and <code>nat : Type</code></p>",
        "id": 255725391,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1633085936
    },
    {
        "content": "<p>Do you mean <code>C</code> or the value of <code>C</code> at some <code>n : nat</code> is the type of what I am making?</p>",
        "id": 255725411,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1633085949
    },
    {
        "content": "<p><code>C</code> is a function that takes a natural number to a type (* Sort)</p>",
        "id": 255725437,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1633085968
    },
    {
        "content": "<p>So <code>C 0</code> is a type</p>",
        "id": 255725452,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1633085977
    },
    {
        "content": "<p>Ah, ok, and it is <code>nat</code>.</p>",
        "id": 255725470,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1633085990
    },
    {
        "content": "<p>Induction in this generality starts with a function C : nat -&gt; Type or C : nat -&gt; Prop, and then proceeds to construct elements of <code>C n</code> for all n from the usual 0 and succ hypotheses</p>",
        "id": 255725471,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1633085991
    },
    {
        "content": "<p>In your case, <code>C := λ n, ℕ</code>.</p>",
        "id": 255725553,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1633086011
    },
    {
        "content": "<p>Oh, yes, exactly, thanks!</p>",
        "id": 255725621,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1633086037
    },
    {
        "content": "<p>If you're constructing data, C is often constant. If you're doing induction then C is never constant, e.g. <code>C n</code> can be the <em>statement</em> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>i</mi><mo>=</mo><mi>n</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">\\sum_{i=1}^ni=n(n+1)/2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.104002em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.804292em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">/2</span></span></span></span></p>",
        "id": 255725647,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1633086056
    },
    {
        "content": "<p>You don't actually need recursion in your case. That may have obscured the situation.</p>",
        "id": 255725648,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1633086056
    },
    {
        "content": "<p>Well, no: my point was not to understand how to construct the constant function, but to understand subtleties about <code>rec_on</code>...</p>",
        "id": 255725721,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1633086102
    },
    {
        "content": "<p>A case with a non-constant <code>C</code> that I found easier to wrap my head around is <code>vector T n</code>, the lists of length <code>n</code></p>",
        "id": 255725796,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1633086127
    },
    {
        "content": "<p>What is your question, based on your revised understanding of <code>C</code>?</p>",
        "id": 255725829,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1633086152
    },
    {
        "content": "<p>Well, none any more: I was looking for a revised understanding of <code>C</code> and I got it. So I am happy. Does it count as a question?</p>",
        "id": 255725905,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1633086195
    },
    {
        "content": "<p>What makes you happy?</p>",
        "id": 255725960,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1633086226
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/255725796\">said</a>:</p>\n<blockquote>\n<p>A case with a non-constant <code>C</code> that I found easier to wrap my head around is <code>vector T n</code>, the lists of length <code>n</code></p>\n</blockquote>\n<p>Thanks, I'll think about it.</p>",
        "id": 255725967,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1633086229
    },
    {
        "content": "<p>The <code>Sort*</code> thing means \"either Prop or Type\" i.e. one function which does both induction and recursion</p>",
        "id": 255726041,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1633086255
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/255725960\">said</a>:</p>\n<blockquote>\n<p>What makes you happy?</p>\n</blockquote>\n<p>Basically that I understood my mistake, no? I had not been able to figure out that <code>C := λ n, ℕ</code>.</p>",
        "id": 255726084,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1633086278
    },
    {
        "content": "<p>I apologize if my satisfaction is a low hanging fruit... <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 255726161,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1633086332
    },
    {
        "content": "<p>I also remember being super-confused about all this</p>",
        "id": 255726270,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1633086370
    },
    {
        "content": "<p>What is happiness?</p>",
        "id": 255726340,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1633086416
    },
    {
        "content": "<p>Well, I don't know if this counts as happiness, but I have tried to insert your suggestion in the code and I got <em>very</em> happy:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">nat.rec_on</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>gives</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">nat.rec_on</span> <span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"n\">zero</span> <span class=\"bp\">→</span>\n    <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">ᾰ</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"n\">ᾰ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"n\">ᾰ.succ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 255726530,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1633086509
    },
    {
        "content": "<p>And I find it very much clear!</p>",
        "id": 255726543,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1633086517
    },
    {
        "content": "<p>No, really: I was always a bit perplexed of the syntax of the second term of an inductively defined gadget, which goes as <code>(λ n m, (zero : nat))</code> whereas I would have thought that <code>(λ m, (zero : nat))</code> to mean \"if <code>n = succ m</code>, then send it to <code>zero</code>\" would have been more reasonable. But with the above code it is clear that the lambda expression must also contain <code>n</code>.</p>",
        "id": 255726824,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1633086664
    },
    {
        "content": "<p>You can also do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">type_of</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">α</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">type_of</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">nat.rec_on</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"o\">))</span>  <span class=\"c1\">-- `ℕ → ℕ → (ℕ → ℕ → ℕ) → ℕ`</span>\n</code></pre></div>\n<p>but the problem with non-dependent binders is that you lose all the names!</p>",
        "id": 255730562,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633088842
    },
    {
        "content": "<p>Thanks! I agree that one loses all names, but it is at any rate useful to have a clear picture of what goes on. <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span></p>",
        "id": 255732469,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1633089835
    },
    {
        "content": "<p>I defined <code>len</code> of the <code>list</code> definition as follows:<br>\n<code>def len {α : Type*} (n : list2 α ) : ℕ :=\nlist2.rec_on n 0 (λ x l leni, leni+1)</code><br>\nHowever, I am not able to prove a basic statement :<br>\n<code>theorem list_len_one {α : Type*} (x : α ) (g : list2 α ) : len (x::g) = 1 + len g := </code><br>\nCan someone help me to prove this? thanks!</p>",
        "id": 280856670,
        "sender_full_name": "Ayush Agrawal",
        "timestamp": 1651487443
    },
    {
        "content": "<p>Does <code>add_comm _ _</code> work as a proof?</p>",
        "id": 280856703,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1651487481
    },
    {
        "content": "<p>Oh I see now, thanks <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> ,<br>\n<code>theorem list_len_one {α : Type*} (x : α ) (g : list2 α ) : len (x::g) = 1 + len g := \nbegin\n  rw nat.add_comm _ _,\n  apply rfl,\nend</code><br>\nthis now works!</p>",
        "id": 280857413,
        "sender_full_name": "Ayush Agrawal",
        "timestamp": 1651488048
    },
    {
        "content": "<p>Yes, because you wrote <code>leni+1</code>, not <code>1+leni</code> <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 280857456,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1651488099
    },
    {
        "content": "<p>This is very easy to do if you're coming into this area with a mathematical background, because a+b=b+a feels like it should be true by definition and before you start formalising you treat these two terms as the same.</p>",
        "id": 280857860,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1651488375
    },
    {
        "content": "<p>In maths we don't think twice about going from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∑</mo><mi>n</mi></msub><mo stretchy=\"false\">(</mo><msub><mi>a</mi><mi>n</mi></msub><mo>×</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\sum_n (a_n\\times C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.0017em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><msub><mo>∑</mo><mi>n</mi></msub><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">C\\sum_n a_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.0017em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> but in Lean this is two commuting steps: take the factor out the sum, and rearrange.</p>",
        "id": 280858017,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1651488489
    }
]
[
    {
        "content": "<p>Hello,<br>\nI'm trying to figure out how to make the following definition work(there are probably much better definitions of graphs. What I present here is my naive attempt to so.) I wonder what is the best way to make a definition whose latter part depends on the first part to be meaningful.<br>\nHere's my code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_isomorphic</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">G'</span><span class=\"o\">:</span> <span class=\"n\">finite_simple_graph</span><span class=\"o\">):</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">natural_number_less_than</span> <span class=\"o\">(</span><span class=\"n\">n_vertex</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">natural_number_less_than</span> <span class=\"o\">(</span><span class=\"n\">n_vertex</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">is_bijective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n<span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">natural_number_less_than</span> <span class=\"o\">(</span><span class=\"n\">n_vertex</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">connected</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">connected</span> <span class=\"n\">G'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">v</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>where <code>finite_simple_graph</code> is defined as naive as one might get:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">finite_simple_graph</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">n_vertex</span><span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">connected</span><span class=\"o\">:</span> <span class=\"n\">natural_number_less_than</span> <span class=\"n\">n_vertex</span> <span class=\"bp\">×</span> <span class=\"n\">natural_number_less_than</span> <span class=\"n\">n_vertex</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The predicate <code>connected G' (u, v)</code> depends on the fact that <code>G, G'</code> has the same number of vertices to even make sense, so the above code is <strong>not</strong> valid in Lean. Lean would simply tell me that <code>natural_number_less_than n_vertex G</code> and  <code>natural_number_less_than n_vertex G'</code>are different types. But they are actually the same, which is ensured by the first part of the proposition.<br>\nHow can I make this into a valid Lean proposition? What is <strong>the right way</strong> to do so in Lean?<br>\nThank you very much.</p>",
        "id": 267574997,
        "sender_full_name": "X.-M. Chu",
        "timestamp": 1641904852
    },
    {
        "content": "<p>At that point of the definition you should have access to the function <code>f</code>, which you can apply to take <code>natural_number_less_than (n_vertex G)</code> to the same <code>natural_number_less_than (n_vertex G')</code> (I think there is a typo there in the definition of <code>f</code> though).<br>\nSo defining <code>connected G (u, v) ↔ connected G' (f u, f v))</code> looks like it should work to me, does it?</p>",
        "id": 267575559,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1641905214
    },
    {
        "content": "<p>Also <code>natural_number_less_than</code> seems very similar to doc#fin, have you tried using that instead? It might make some things easier</p>",
        "id": 267575636,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1641905258
    },
    {
        "content": "<p>Are you trying to do something like <a href=\"https://tqft.net/mathlib/order/countable_dense_linear_order\">file#order/countable_dense_linear_order</a> ?</p>",
        "id": 267575943,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641905405
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/113489-new-members/topic/a.20statement.20that.20depends.20on.20itself.20to.20make.20sense/near/267575559\">said</a>:</p>\n<blockquote>\n<p>At that point of the definition you should have access to the function <code>f</code>, which you can apply to take <code>natural_number_less_than (n_vertex G)</code> to the same <code>natural_number_less_than (n_vertex G')</code> (I think there is a typo there in the definition of <code>f</code> though).<br>\nSo defining <code>connected G (u, v) ↔ connected G' (f u, f v))</code> looks like it should work to me, does it?</p>\n</blockquote>\n<p>Yes there is something wrong.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_isomorphic</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">G'</span><span class=\"o\">:</span> <span class=\"n\">finite_simple_graph</span><span class=\"o\">):</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">natural_number_less_than</span> <span class=\"o\">(</span><span class=\"n\">n_vertex</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">natural_number_less_than</span> <span class=\"o\">(</span><span class=\"n\">n_vertex</span> <span class=\"n\">G'</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">is_bijective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">natural_number_less_than</span> <span class=\"o\">(</span><span class=\"n\">n_vertex</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">connected</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">connected</span> <span class=\"n\">G'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">v</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>works.The crutial thing is to define <code>f</code> as <code>natural_number_less_than (n_vertex G) → natural_number_less_than (n_vertex G')</code>. This was not a typo but something I didn't understand well.<br>\nThank you very much.<br>\nBut I do want to know that in more general situations, can one make a definition whose second part depends one the first part even to make sense. This is omnipresent in mathematics. Is it always possible to have a work around like in my example?</p>",
        "id": 267579531,
        "sender_full_name": "X.-M. Chu",
        "timestamp": 1641907326
    },
    {
        "content": "<blockquote>\n<p>But I do want to know that in more general situations, can one make a definition whose second part depends one the first part even to make sense.</p>\n</blockquote>\n<p>That's what a <em>recursion</em> is. But I don't see any kind of a recursion in your example. I guess you got confused because the following simplified code doesn't type check:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>It doesn't type check because Lean is not convinced that <code>x</code> and <code>y</code> are terms of the same type, so <code>x = y</code> is not a valid expression. You can use heterogeneous equality in that case instead:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">==</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">use</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>But, as you have already figured out, this was not the problem in your definition.</p>",
        "id": 267586824,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1641910593
    },
    {
        "content": "<p>What does <code>==</code> mean? I couldn't find it in TPIL.</p>",
        "id": 268966389,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642870106
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/init/core.html#heq\">Here are the docs</a></p>",
        "id": 268966501,
        "sender_full_name": "Daniel Roca González",
        "timestamp": 1642870299
    },
    {
        "content": "<p>(note it means something different in lean 4)</p>",
        "id": 268968009,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1642872329
    }
]
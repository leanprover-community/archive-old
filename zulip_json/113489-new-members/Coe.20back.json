[
    {
        "content": "<p>If I have a positive integer, how do I get a natural number out of it? For more context, I need to use the floor function which outputs an integer and then do induction with this integer, with<code>let p : ℤ → Prop := λ (m : ℕ), m ≤ n → (n - m ∈ s ∨ (0 : ℤ) ∈ s), </code> (s is a set of positive integers). I basically need to prove that if n is in the set, then 0 is in the set as well,  but induction on integers won't work because I can't prove a special case.</p>",
        "id": 148320607,
        "sender_full_name": "Alexandru-Andrei Bosinta",
        "timestamp": 1543156087
    },
    {
        "content": "<p>I'm not sure I understand your situation exactly. Does <code>int.nat_abs</code> help you? <code>int.nat_abs (int.of_nat k)</code> reduces to <code>k</code>, and there are lemmas like <code>int.nat_abs_of_nonneg</code>.</p>",
        "id": 148321896,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1543158731
    },
    {
        "content": "<p>Although it's counter-intuitive to mathematicians, the way to get a nat back from a non-negative int is indeed to take the absolute value. You could think of the absolute value function as a function from int to nat which reverses the inclusion from nat to int, and returns junk for values not in the image; there are loads of such functions in Lean. Whenever a mathematician thinks they want a partial function (i.e. a function only defined on some elements of a nice set) the computer scientists tend to have defined it on all the set and either given it junk values on the other elements (e.g. log, which does some random thing to negative reals, and division, which does some random thing when you divide by 0) or observed that actually the function you want is the special case of a natural function which you might well want in general. For example the partial inverse of nat to int is called absolute value, the partial inverse of int to rat or real is called the floor function, the partial inverse of int to rat is called the numerator function. In all cases there will be a lemma which says that this function is indeed the one-sided inverse (i.e. <code>abs (n : Z) = n</code> if <code>n : nat</code> -- this is called <code>nat_abs_of_nat</code> and the proof is <code>rfl</code>), and if the image is easily classifiable (which it is for nat to int -- it's the non-negative ints) then there will be another lemma saying that the image is what you think it is it's (<code>of_nat_nonneg</code> in the nat to int case) and finally a lemma saying that if you're in the image and you go back then forward you get back to where you start ( Rob pointed out the relevant function in the nat to int case).</p>",
        "id": 148324816,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543164706
    },
    {
        "content": "<p>Thanks for the explanation! It worked, but I've been having a lot of trouble with coercions so I had to rewrite my entire proof (which is already long). Now I am in the final stage of this proof.</p>",
        "id": 148328259,
        "sender_full_name": "Alexandru-Andrei Bosinta",
        "timestamp": 1543172034
    },
    {
        "content": "<p>Coercions are really meh. Mathematicians don't know they are there. I think Lean is bad at handling them though. I would like to see Lean letting mathematicians use them as if they weren't there. Did you read my notes on cast? <a href=\"https://github.com/leanprover/mathlib/blob/master/docs/extras/casts.md\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/master/docs/extras/casts.md\">https://github.com/leanprover/mathlib/blob/master/docs/extras/casts.md</a> Maybe they help. But it should all be easier.</p>",
        "id": 148328316,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543172145
    },
    {
        "content": "<p>I occasionally think about whether one could handle all of this with typeclasses. Instead of going from int back to nat, have a typeclass <code>int.is_nat</code>on <code>int</code> which keeps track of whether something is a nat (and which nat it is). See if we can get the typeclass system to do the coersions for us, rather than <code>simp</code>.</p>\n<p>Basic idea:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">class</span> <span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">pf</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"err\">↑</span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"n\">class</span> <span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">rat</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">pf</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"err\">↑</span><span class=\"n\">q</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">rat_of_nat</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"n\">r</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">rat</span> <span class=\"n\">r</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">),</span><span class=\"k\">by</span> <span class=\"n\">simpa</span> <span class=\"kn\">using</span> <span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">pf</span><span class=\"bp\">⟩</span>\n</pre></div>",
        "id": 148328371,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543172263
    },
    {
        "content": "<p>I didn't read your notes yet. I will have a look later, but I figured out how to do it. I basically tried to avoid using the <code>↑</code> operator and just try to use the functions which give you the coercions (<code>rat.mk n 1</code> for integer <code>n</code> to rational <code>n</code> and <code>int.nat_abs</code> for naturals to integers). It was really annoying because in my first attempt I was even getting an error about metavariables and <code>calc</code> wasn't working.</p>",
        "id": 148328491,
        "sender_full_name": "Alexandru-Andrei Bosinta",
        "timestamp": 1543172425
    },
    {
        "content": "<p>Yeah, that's not how you're supposed to do it at all :-) No wonder it was a frustrating experience :-)</p>",
        "id": 148328498,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543172464
    },
    {
        "content": "<p>I just use (n : rat) to get from nat to rat</p>",
        "id": 148328507,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543172495
    },
    {
        "content": "<p>If you use the coercions then simp will do a lot of the dirty work for you. If you use the explicit functions then simp doesn't know about these so you have to do everything by hand.</p>",
        "id": 148328552,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543172543
    },
    {
        "content": "<p><code>simp</code> is a tool for proving <em>equalities</em>. Any two things which should \"obviously be equal\", like <code>\\u a + \\u b</code> and <code>\\u (a + b)</code> -- <code>simp</code> should know this. You can figure out the lemmas yourself, but it's much easier to use simp.</p>",
        "id": 148328569,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543172607
    },
    {
        "content": "<p>I started getting annoyed debugging my code, so I gave up and decided to do it my implicit functions which are way more clear to me.  It was probably not a very good way of doing my proof. I may try to fix the code later.</p>",
        "id": 148328626,
        "sender_full_name": "Alexandru-Andrei Bosinta",
        "timestamp": 1543172699
    },
    {
        "content": "<p>If you post something here I can look at it. I've had to deal with a lot of coercions from nat to int in the past, so I know some tips.</p>",
        "id": 148328642,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543172734
    },
    {
        "content": "<p>I will post it in a bit when I finish my whole proof. It shouldn't be long until I am done.</p>",
        "id": 148329229,
        "sender_full_name": "Alexandru-Andrei Bosinta",
        "timestamp": 1543173817
    },
    {
        "content": "<p>If you look at my solutions to my example sheet questions from last year you will see me in coercion hell often -- Mario used to have to drag me out of the mire. Now at least I understand the way Lean has been designed with coercions, or at least well enough to mean I don't get stuck any more. Over the summer I had some people doing number theory, and they were forever coercing from nat to int and back again, and they struggled too (and Chris would have to drag them out of the mire).</p>",
        "id": 148329360,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543174029
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>import data.rat data.set.basic order.bounds tactic.ring tactic.linarith data.nat.basic\nopen classical\nlocal attribute [instance, priority 0] classical.prop_decidable\n\nstructure Dedekind_real :=\n(carrier : set ℚ)\n(nonemp : ∃ a, a ∈ carrier)\n(nonrat : ∃ a, a ∉ carrier)\n(down : ∀ (p : ℚ), p ∈ carrier → ∀ (q : ℚ), q ≤ p → q ∈ carrier)\n(nomax : ∀ (p : ℚ), p ∈ carrier → ∃ (q : ℚ), q ∈ carrier ∧ p &lt; q)\n\nnotation `ℝ` := Dedekind_real\n\nlemma bounded_by_non_elements (α : ℝ) (x : ℚ): x ∉ α.carrier ↔ (∀ (q : ℚ), q ∈ α.carrier → q &lt; x) := sorry\n\nlemma suff_small_bound (α : ℝ) (ε : ℚ) (hε : ε &gt; 0) : ∃ (a b : ℚ), a ∈ α.carrier ∧ b ∉ α.carrier ∧ b - a &lt; ε :=\nexists.elim α.nonemp (λ a ha, exists.elim α.nonrat (λ b hb, begin\nlet n : ℤ := rat.floor ( (b-a)/ε ),\nlet s : set ℚ := {n | ∃ (a b : ℚ), a ∈ α.carrier ∧ b ∉ α.carrier ∧ ε*n ≤ b-a ∧ b-a &lt; ε*(n+1)},\nlet p : ℕ → Prop := λ m, int.of_nat m ≤ n → rat.mk (n - int.of_nat m) 1 ∈ s ∨ (0 : ℚ) ∈ s,\nhave hn : p (int.nat_abs n), from nat.case_strong_induction_on (int.nat_abs n)\n(λ hpos, or.inl ⟨a, b, ha, hb, by calc\nε * (rat.mk (n - int.of_nat 0) 1) = ε * (rat.mk (n - 0) 1) : rfl\n... = ε * (rat.mk n 1) : by rw sub_zero\n... = ε * ↑n : by rw rat.coe_int_eq_mk\n... = ε * ↑(rat.floor ( (b-a)/ε ) ) : rfl\n... ≤ ε * ( (b-a)/ε ) : (mul_le_mul_left hε).mpr (rat.floor_le ( (b-a)/ε ) )\n... = ε * (b-a)/ε : by rw mul_div_assoc\n... = b - a : by rw mul_div_cancel_left (b-a) (ne_of_gt hε),\nby calc b - a = ε * (b - a)/ε : by rw mul_div_cancel_left (b-a) (ne_of_gt hε)\n... = ε * ( (b-a)/ε ) : by rw mul_div_assoc\n... &lt; ε * ↑(int.succ (rat.floor ( (b-a)/ε ) ) ) : (mul_lt_mul_left hε).mpr (rat.lt_succ_floor ( (b-a)/ε ) )\n... = ε * (rat.mk (int.succ (rat.floor ( (b-a)/ε ) ) ) 1 ) : by rw rat.coe_int_eq_mk\n... = ε * (rat.mk (rat.floor ( (b-a)/ε ) + 1) 1 ) : rfl\n... = ε * ( (rat.mk (rat.floor ( (b-a)/ε ) ) 1 ) + (rat.mk 1 1) ) : by simp\n... = ε * ( (rat.mk n 1) + 1) : rfl\n... = ε * ( (rat.mk (n - 0) 1 ) + 1) : by rw sub_zero\n... = ε * ( (rat.mk (n - int.of_nat 0) 1) + 1) : rfl⟩ )\n(λ i hpi hpos, or.elim (hpi i (le_refl i) (trans (le_of_lt (lt_add_one i) ) hpos) )\n(λ h, exists.elim h (λ a0 hb, exists.elim hb (λ b0 hab, (em (b0 - ε ∈ α.carrier)).elim\n(λ hb0, exists.elim (α.nomax (b0-ε) hb0) (λ b1 hb1, or.inr ⟨b1, b0, hb1.left, hab.right.left, le_of_lt (by calc\nε * 0 = 0 : by rw mul_zero\n... &lt; b0 - b1 : sub_pos_of_lt ( (bounded_by_non_elements α b0).mp hab.right.left b1 hb1.left)), by calc\nb0 - b1 &lt; ε : sub_lt.mp hb1.right\n... = ε*1 : by rw mul_one\n... = ε*(1-0) : by rw sub_zero⟩ ) )\n(λ hb0, or.inl ⟨a0, b0-ε, hab.left, hb0, by calc\nε * (rat.mk (n - int.of_nat (nat.succ i) ) 1) = ε * (rat.mk (n - int.of_nat (i + 1) ) 1) : rfl\n... = ε * ( rat.mk ( n - (int.of_nat i + int.of_nat 1) ) 1 ) : rfl\n... = ε * ( rat.mk (n - (int.of_nat i + 1) ) 1) : rfl\n... = ε * ( rat.mk (n - int.of_nat i - 1) 1 ) : by rw sub_sub\n... = ε * ( rat.mk (n - int.of_nat i + -1) 1) : rfl\n... = ε * ( ( rat.mk (n - int.of_nat i) 1) + (rat.mk (-1) 1) ) : by simp\n... = ε * ( ( rat.mk (n - int.of_nat i) 1) + -1) : rfl\n... = ε * ( rat.mk (n - int.of_nat i) 1) + ε * -1 : by rw mul_add\n... = ε * ( rat.mk (n - int.of_nat i) 1) - ε : by simp\n... ≤ b0-a0-ε : sub_le_sub_right hab.right.right.left ε\n... = b0-ε-a0 : by rw sub_right_comm,\nby calc b0-ε-a0 = b0-a0-ε : by rw sub_right_comm\n... &lt; ε * (rat.mk (n - int.of_nat i) 1 + 1) - ε : sub_lt_sub_right hab.right.right.right ε\n... = ε * (rat.mk (n - int.of_nat i) 1 + 1) - ε * 1 : by rw mul_one\n... = ε * (rat.mk (n - int.of_nat i) 1 + 1 - 1) : by rw mul_sub\n... = ε * (rat.mk (n - int.of_nat i) 1) : by rw add_sub_cancel\n... = ε * (rat.mk (n - int.of_nat i) 1 - 1 + 1) : by rw sub_add_cancel\n... = ε * (rat.mk (n - int.of_nat i) 1 - rat.mk 1 1 + 1) : rfl\n... = ε * (rat.mk (n - int.of_nat i - 1) 1 + 1) : by simp\n... = ε * (rat.mk (n - (int.of_nat i + 1) ) 1 + 1) : by rw sub_sub\n... = ε * (rat.mk (n - (int.of_nat (i + 1) ) ) 1 + 1) : rfl\n... = ε * (rat.mk (n - (int.of_nat (nat.succ i) ) ) 1 + 1) : rfl\n⟩ ) ) ) ) or.inr),\nhave s0 : (0 : ℚ) ∈ s,\napply or.elim (hn (trans_rel_right int.le (by calc\nint.of_nat (int.nat_abs n) = ↑(int.nat_abs n) : rfl\n... = n : int.nat_abs_of_nonneg (trans_rel_right _ rfl (rat.le_floor.mpr\n    (trans_rel_right rat.le (eq.symm (zero_div ε) ) ( (div_le_div_right hε).mpr (le_of_lt (sub_pos.mpr (\n        (bounded_by_non_elements α b).mp hb a ha) ) ) ) ) ) ) ) (le_refl n) ) ),\n{\n    intro h0,\n    have h1 : rat.mk (n - int.of_nat (int.nat_abs n)) 1 = 0, from by calc\n    rat.mk (n - int.of_nat (int.nat_abs n)) 1 = rat.mk (n - ↑(int.nat_abs n)) 1 : rfl\n    ... = rat.mk (n - n) 1 : by rw int.nat_abs_of_nonneg (trans_rel_right _ rfl (rat.le_floor.mpr\n    (trans_rel_right rat.le (eq.symm (zero_div ε) ) ( (div_le_div_right hε).mpr (le_of_lt (sub_pos.mpr (\n        (bounded_by_non_elements α b).mp hb a ha) ) ) ) ) ) )\n    ... = rat.mk 0 1 : by rw sub_self n\n    ... = 0 : rfl,\n    rw ←h1,\n    exact h0\n},\n{\n    intro h0,\n    exact h0\n},\napply exists.elim s0,\nintros,\napply exists.elim a_2,\nintros,\nexact ⟨a_1, a_3, a_4.left, a_4.right.left, by calc a_3 - a_1 &lt; ε*(0+1) : a_4.right.right.right\n... = ε*1 : by rw zero_add\n... = ε : by rw mul_one⟩\nend ) )\n</pre></div>\n\n\n<p>The code is very long unfortunately, but it's finally done.</p>",
        "id": 148329649,
        "sender_full_name": "Alexandru-Andrei Bosinta",
        "timestamp": 1543174577
    },
    {
        "content": "<p>Oh wooah! You did the Dedekind Cuts question in Lean! Nice!</p>",
        "id": 148329938,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543175073
    },
    {
        "content": "<p>It's far from done. But I thought you already knew I was working on it.</p>",
        "id": 148331184,
        "sender_full_name": "Alexandru-Andrei Bosinta",
        "timestamp": 1543177332
    },
    {
        "content": "<p>Yeah I guess we talked about it on Thurs. I guess several people have done bits and bobs but that <code>suff_small_bound</code> is a pain!</p>",
        "id": 148333814,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543182723
    },
    {
        "content": "<p>Hm, this piqued my interest. Here's my attempt, including a missing library theorem in <code>algebra.archimedean</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">rat</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">archimedean</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">exists_pos_nat_one_div_lt</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_field</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">archimedean</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">ε</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hε</span> <span class=\"o\">:</span> <span class=\"n\">ε</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">exists_nat_gt</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">ε</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"k\">have</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"n\">lt_trans</span> <span class=\"o\">(</span><span class=\"n\">one_div_pos_of_pos</span> <span class=\"n\">hε</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">cast_pos</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">div_lt_iff</span> <span class=\"n\">this</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"err\">$</span> <span class=\"o\">(</span><span class=\"n\">div_lt_iff&#39;</span> <span class=\"n\">hε</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">suff_small_bound</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ε</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hε</span> <span class=\"o\">:</span> <span class=\"n\">ε</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">carrier</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"err\">∉</span> <span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">carrier</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">exists_pos_nat_one_div_lt</span> <span class=\"n\">hε</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n0</span><span class=\"o\">,</span> <span class=\"n\">hn</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">n0&#39;</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">cast_pos</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">n0</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">/</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"err\">∈</span> <span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">z</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">nonrat</span> <span class=\"k\">with</span> <span class=\"n\">b</span> <span class=\"n\">hb</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"bp\">⟨</span><span class=\"err\">⌈</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"err\">⌉</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span> <span class=\"n\">hz</span><span class=\"o\">,</span> <span class=\"n\">le_of_not_lt</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">_⟩</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">le_div_iff</span> <span class=\"n\">n0&#39;</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">ceil_le</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">le_of_lt</span> <span class=\"n\">h</span><span class=\"o\">)),</span>\n    <span class=\"n\">refine</span> <span class=\"n\">hb</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">down</span> <span class=\"bp\">_</span> <span class=\"n\">hz</span> <span class=\"bp\">_</span> <span class=\"n\">this</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">lo</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">/</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"err\">∈</span> <span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">carrier</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">nonemp</span> <span class=\"k\">with</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">⟨</span><span class=\"err\">⌊</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"err\">⌋</span><span class=\"o\">,</span> <span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">down</span> <span class=\"bp\">_</span> <span class=\"n\">ha</span> <span class=\"bp\">_</span> <span class=\"o\">((</span><span class=\"n\">div_le_iff</span> <span class=\"n\">n0&#39;</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">floor_le</span> <span class=\"bp\">_</span><span class=\"o\">))</span><span class=\"bp\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">dec</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">exists_greatest_of_bdd</span> <span class=\"n\">hi</span> <span class=\"n\">lo</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">hz₁</span><span class=\"o\">,</span> <span class=\"n\">hz₂</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">⟨</span><span class=\"n\">z</span> <span class=\"bp\">/</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">z</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">hz₁</span><span class=\"o\">,</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">not_le_of_lt</span> <span class=\"o\">(</span><span class=\"n\">lt_add_one</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hz₂</span> <span class=\"o\">(</span><span class=\"n\">z</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">),</span> <span class=\"bp\">_⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">sub_div</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast_sub</span><span class=\"o\">],</span> <span class=\"n\">simpa</span> <span class=\"kn\">using</span> <span class=\"n\">hn</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 148351790,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543218188
    }
]
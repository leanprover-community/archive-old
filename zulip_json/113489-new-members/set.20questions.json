[
    {
        "content": "<p>Is there a function to get all the subsets of a set? I am trying to prove that something has more subsets than elements in the set</p>",
        "id": 280570455,
        "sender_full_name": "Joseph O",
        "timestamp": 1651190075
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.powerset\">docs#set.powerset</a></p>\n<p>It's got special notation if you want to use it: <code>ùí´ s</code></p>",
        "id": 280570820,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651190407
    },
    {
        "content": "<p>Oh nice</p>",
        "id": 280571608,
        "sender_full_name": "Joseph O",
        "timestamp": 1651191030
    },
    {
        "content": "<p>How could I construct a goal saying that the number of subsets is greater than the number of elements in the set.</p>",
        "id": 280571767,
        "sender_full_name": "Joseph O",
        "timestamp": 1651191197
    },
    {
        "content": "<p>Also, how could I denote a set with infinite elements. I am trying to construct the proof for there is no biggest infinity, but I am a bit confused about how to construct the proof statement</p>",
        "id": 280571797,
        "sender_full_name": "Joseph O",
        "timestamp": 1651191241
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"467926\">Joseph O</span> <a href=\"#narrow/stream/113489-new-members/topic/set.20questions/near/280571797\">said</a>:</p>\n<blockquote>\n<p>I am trying to construct the proof for there is no biggest infinity</p>\n</blockquote>\n<p>Are you aiming at <a href=\"https://en.wikipedia.org/wiki/Aleph_number\">aleph numbers</a>?<br>\nProbably <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>, but I think you want to prove something along the lines of \"given a set of any size, there exists an even bigger set\"</p>",
        "id": 280572138,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1651191549
    },
    {
        "content": "<p>(Of course that's a guess, but I think you need to be more precise about what you mean by \"no biggest infinity\")</p>",
        "id": 280572221,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1651191612
    },
    {
        "content": "<p>In reply to <a href=\"#narrow/stream/113489-new-members/topic/set.20questions/near/280572138\">this post</a>, that's pretty much exactly what I want to do</p>",
        "id": 280572547,
        "sender_full_name": "Joseph O",
        "timestamp": 1651191921
    },
    {
        "content": "<p>And yes, the aleph numbers seem like I want</p>",
        "id": 280572641,
        "sender_full_name": "Joseph O",
        "timestamp": 1651191980
    },
    {
        "content": "<p>Does lean have lemmas and functions for the aleph numbers?</p>",
        "id": 280572710,
        "sender_full_name": "Joseph O",
        "timestamp": 1651192051
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal.aleph\">docs#cardinal.aleph</a> (I searched for \"aleph\" in the search box)</p>",
        "id": 280572827,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651192117
    },
    {
        "content": "<p>Are you wanting to work with sets specifically, or are types ok?  When <code>X</code> is a type, <code>set X</code> is the type of all subsets of <code>X</code>. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal.mk\">docs#cardinal.mk</a> gives the cardinality of a type.</p>",
        "id": 280572936,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651192213
    },
    {
        "content": "<p>Every element of <code>set X</code> can be coerced to be a type, and you can get the cardinality of that, so it's fine working sets, but I just thought I'd ask.</p>",
        "id": 280572984,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651192266
    },
    {
        "content": "<p>Yeah, the questions I asked weren't very good, sorry. I intended to pose them as somewhat contrasting goals, meaning that you probably don't want to involve aleph numbers in your proof. Although that's the concept that comes to my mind when one talks about \"bigger/smaller infinitiy\"</p>",
        "id": 280573249,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1651192526
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/set.20questions/near/280572936\">said</a>:</p>\n<blockquote>\n<p>Are you wanting to work with sets specifically, or are types ok?  When <code>X</code> is a type, <code>set X</code> is the type of all subsets of <code>X</code>. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal.mk\">docs#cardinal.mk</a> gives the cardinality of a type.</p>\n</blockquote>\n<p>Why doesnt <code>cardinal.mk</code> return a number?</p>",
        "id": 280573879,
        "sender_full_name": "Joseph O",
        "timestamp": 1651193162
    },
    {
        "content": "<p>Like I dont really get this <a href=\"/user_uploads/3121/2Lm21xeachOhcn2Buv20e6HM/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/2Lm21xeachOhcn2Buv20e6HM/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/2Lm21xeachOhcn2Buv20e6HM/image.png\"></a></div>",
        "id": 280573945,
        "sender_full_name": "Joseph O",
        "timestamp": 1651193223
    },
    {
        "content": "<p>Im blindly putting things together but this is sorta what I want (this currently has a type error)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">no_largest_inf</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">inf</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">ùí´</span> <span class=\"n\">inf</span> <span class=\"bp\">‚â•</span> <span class=\"n\">cardinal.mk</span> <span class=\"n\">inf</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 280574051,
        "sender_full_name": "Joseph O",
        "timestamp": 1651193356
    },
    {
        "content": "<p>How do I make this actually work?</p>",
        "id": 280574732,
        "sender_full_name": "Joseph O",
        "timestamp": 1651194009
    },
    {
        "content": "<p>You won't find many results about <code>‚â•</code> or <code>&gt;</code> in mathlib. The API is built with <code>&lt;</code> and <code>‚â§</code> instead</p>\n<p>If you want to prove that, for any set <code>s</code>, the cardinality of <code>s</code> is less than or equal to the cardinality of the power-set of <code>s</code>, you don't need to talk about infinite sets</p>",
        "id": 280574939,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1651194211
    },
    {
        "content": "<p>But the whole point is it being with infinite sets</p>",
        "id": 280575301,
        "sender_full_name": "Joseph O",
        "timestamp": 1651194634
    },
    {
        "content": "<p>how does this look?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">no_largest_inf</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">inf</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">cardinal.mk</span> <span class=\"n\">inf</span> <span class=\"bp\">‚â§</span> <span class=\"n\">cardinal.mk</span> <span class=\"o\">(</span><span class=\"bp\">ùí´</span> <span class=\"n\">inf</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 280576694,
        "sender_full_name": "Joseph O",
        "timestamp": 1651195987
    },
    {
        "content": "<p>Just pasting it with the import that works on my pc:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">set_theory.cardinal</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">no_largest_inf</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">inf</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">cardinal.mk</span> <span class=\"n\">inf</span> <span class=\"bp\">‚â§</span> <span class=\"n\">cardinal.mk</span> <span class=\"o\">(</span><span class=\"bp\">ùí´</span> <span class=\"n\">inf</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Notice that you calling the set <code>inf</code> doesn't make it infinite</p>",
        "id": 280576904,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1651196222
    },
    {
        "content": "<p>Yeah I was thinking that. Does this mean I have to use aleph numbers?</p>",
        "id": 280576922,
        "sender_full_name": "Joseph O",
        "timestamp": 1651196252
    },
    {
        "content": "<p>No I think you still need to formulate your problem better, mathematically</p>",
        "id": 280577004,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1651196338
    },
    {
        "content": "<p>Ok this is what I am trying to prove: Take an infinity containing a set of something; I can create a larger infinity by making an infinity that contains the subsets of the smaller infinity (oh god that was terrible, I doubt its very mathematical)</p>",
        "id": 280577179,
        "sender_full_name": "Joseph O",
        "timestamp": 1651196557
    },
    {
        "content": "<p>Do you have a link to a precise statement of this result? Maybe in some introductory material on set theory, a Wikipedia page or something like that</p>",
        "id": 280577427,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1651196880
    },
    {
        "content": "<p>Im essentially trying to prove Cantor's theorem</p>",
        "id": 280577604,
        "sender_full_name": "Joseph O",
        "timestamp": 1651197047
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/Cantor's_theorem\">https://en.wikipedia.org/wiki/Cantor's_theorem</a></p>",
        "id": 280577635,
        "sender_full_name": "Joseph O",
        "timestamp": 1651197101
    },
    {
        "content": "<p>Every set is smaller than its power set</p>",
        "id": 280577644,
        "sender_full_name": "Joseph O",
        "timestamp": 1651197112
    },
    {
        "content": "<p>Then you've stated the theorem properly already</p>",
        "id": 280577721,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1651197202
    },
    {
        "content": "<p>But it works for infinite sets?</p>",
        "id": 280577746,
        "sender_full_name": "Joseph O",
        "timestamp": 1651197242
    },
    {
        "content": "<p>Notice that the theorem stated as you did is actually more general than if you wanted to talk about infinite sets, specifically</p>",
        "id": 280577807,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1651197305
    },
    {
        "content": "<p>Maybe I could prove this theorem, and then use it for infinite sets?</p>",
        "id": 280577907,
        "sender_full_name": "Joseph O",
        "timestamp": 1651197419
    },
    {
        "content": "<p>Should I rename it to <code>cantors_theorem</code>, or <code>set_lt_powerset</code></p>",
        "id": 280577930,
        "sender_full_name": "Joseph O",
        "timestamp": 1651197473
    },
    {
        "content": "<p>As for no naming conflicts</p>",
        "id": 280577934,
        "sender_full_name": "Joseph O",
        "timestamp": 1651197481
    },
    {
        "content": "<p>Hmm there doesnt seem to be a <code>cantor_theorem</code></p>",
        "id": 280577994,
        "sender_full_name": "Joseph O",
        "timestamp": 1651197560
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.cantor_surjective\">docs#function.cantor_surjective</a></p>",
        "id": 280579226,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1651198946
    },
    {
        "content": "<p>This is the Cantor theorem you are referring to.</p>",
        "id": 280579243,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1651198988
    },
    {
        "content": "<p>Of course, there are a variety of ways to phrase it. You could take this theorem and translate it into the language of cardinality.</p>",
        "id": 280579252,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1651199031
    },
    {
        "content": "<p>I guess I will try and attempt it myself.</p>",
        "id": 280579298,
        "sender_full_name": "Joseph O",
        "timestamp": 1651199066
    },
    {
        "content": "<p>But why is it called cantor_surjective?</p>",
        "id": 280579313,
        "sender_full_name": "Joseph O",
        "timestamp": 1651199106
    },
    {
        "content": "<p>Click the link. It says there are no surjective functions from a set to it's power set (although it is phrased in terms of types: no surjective function from a type to the type of sets of that type)</p>",
        "id": 280579464,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1651199322
    },
    {
        "content": "<p>Notice that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.cantor_injective\">docs#function.cantor_injective</a> is also a variation of the Cantor theorem. We can't call them all cantor_theorem because that would be a naming conflict.</p>",
        "id": 280579524,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1651199411
    },
    {
        "content": "<p>There's also <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal.cantor'\">docs#cardinal.cantor'</a> which is specifically about cardinal numbers.</p>",
        "id": 280579697,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1651199660
    },
    {
        "content": "<p>Going off topic, I just wanted to mention the Lawvere fixed-point theorem, which I think is pretty neat. <code>cantor_surjective</code> is an easy corollary of it. (Though the theorem is more interesting in other Cartesian closed categories where the exponential object isn't just <code>Œ± ‚Üí Œ≤</code>, since due to cardinality there's not much you can do with this version except prove contradictions.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">lawvere</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">œï</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hœï</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"n\">œï</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ≤</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÉ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">œï</span> <span class=\"n\">a</span> <span class=\"n\">a</span><span class=\"o\">),</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">‚ü®</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">‚ü©</span> <span class=\"o\">:=</span> <span class=\"n\">hœï</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">œï</span> <span class=\"n\">p</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n  <span class=\"k\">calc</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">œï</span> <span class=\"n\">p</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">rfl</span>\n             <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">œï</span> <span class=\"n\">p</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">hp</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">cantor_surjective'</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">œï</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Prop</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">¬¨</span> <span class=\"n\">function.surjective</span> <span class=\"n\">œï</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hœï</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- get the fixed point of logical negation!</span>\n  <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">lawvere</span> <span class=\"n\">œï</span> <span class=\"n\">hœï</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"bp\">¬¨</span> <span class=\"n\">p</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- recall that `set Œ±` is defined to be `Œ± ‚Üí Prop`</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">cantor_surjective</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">œï</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬¨</span> <span class=\"n\">function.surjective</span> <span class=\"n\">œï</span> <span class=\"o\">:=</span>\n<span class=\"n\">cantor_surjective'</span> <span class=\"n\">œï</span>\n</code></pre></div>",
        "id": 280579986,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651200083
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"467926\">Joseph O</span> <a href=\"#narrow/stream/113489-new-members/topic/set.20questions/near/280576694\">said</a>:</p>\n<blockquote>\n<p>how does this look?</p>\n</blockquote>\n<p>Here's an easy proof of that in terms of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal.cantor\">docs#cardinal.cantor</a></p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">set_theory.cardinal.basic</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">cardinal</span>\n\n<span class=\"c1\">-- this should maybe be in mathlib: #13786</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">cardinal.mk_powerset</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">#</span><span class=\"o\">(</span><span class=\"bp\">ùí´</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"bp\">#‚Ü•</span><span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">cardinal.mk_congr</span> <span class=\"o\">(</span><span class=\"n\">equiv.set.powerset</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">cardinal.mk_set</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">cardinal.mk_le_mk_powerset</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">#</span><span class=\"n\">s</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">#</span><span class=\"o\">(</span><span class=\"bp\">ùí´</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">cardinal.mk_powerset</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">cardinal.cantor</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>\n<p>The key trick here is discovering <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.set.powerset\">docs#equiv.set.powerset</a>, which I found with <code>library_search</code>. I made a PR with an expansion of <code>#(ùí´ s)</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/13786\">#13786</a></p>",
        "id": 280607485,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651224355
    },
    {
        "content": "<p>The version of the proof I learned had to do with surjective functions, so I might try and prove the first.</p>",
        "id": 280617381,
        "sender_full_name": "Joseph O",
        "timestamp": 1651230489
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113489-new-members/topic/set.20questions/near/280579243\">said</a>:</p>\n<blockquote>\n<p>This is the Cantor theorem you are referring to.</p>\n</blockquote>\n<p>Not exact actually. That is cantor‚Äôs diagonal argument. I am trying to prove the one saying every set is smaller than its powerset</p>",
        "id": 280620590,
        "sender_full_name": "Joseph O",
        "timestamp": 1651232710
    },
    {
        "content": "<p>Yes, but that proof is much better stated in terms of <code>Œ±</code> and <code>set Œ±</code> than it is in terms of <code>‚Ü•S</code> and <code>‚Ü•(ùí´ S)</code></p>",
        "id": 280620609,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651232728
    },
    {
        "content": "<p>An important skill when using Lean is to know when the math word \"set\" means <code>set Œ±</code>, and when it means <code>Type u</code></p>",
        "id": 280620698,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651232789
    },
    {
        "content": "<p>So if I have type <code>a</code>, <code>set a</code> is all the subsets?</p>",
        "id": 280620997,
        "sender_full_name": "Joseph O",
        "timestamp": 1651233029
    },
    {
        "content": "<p><code>set a</code> is the type of sets whose elements have type <code>a</code>. There is so such a thing as \"subset of a type\", there are sets (whose elements must have the same type) and subsets of sets.</p>",
        "id": 280621256,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651233204
    },
    {
        "content": "<p>(there are subtypes)</p>",
        "id": 280621291,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651233234
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/theories/sets.html\">https://leanprover-community.github.io/theories/sets.html</a></p>",
        "id": 280621365,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651233261
    },
    {
        "content": "<p>Do they work the same way?</p>",
        "id": 280622571,
        "sender_full_name": "Joseph O",
        "timestamp": 1651233939
    },
    {
        "content": "<p>It actually seems like it,</p>",
        "id": 280622845,
        "sender_full_name": "Joseph O",
        "timestamp": 1651234089
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/set.20questions/near/280607485\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"467926\">Joseph O</span> <a href=\"#narrow/stream/113489-new-members/topic/set.20questions/near/280576694\">said</a>:</p>\n<blockquote>\n<p>how does this look?</p>\n</blockquote>\n<p>Here's an easy proof of that in terms of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal.cantor\">docs#cardinal.cantor</a></p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">set_theory.cardinal.basic</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">cardinal</span>\n\n<span class=\"c1\">-- this should maybe be in mathlib: #13786</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">cardinal.mk_powerset</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">#</span><span class=\"o\">(</span><span class=\"bp\">ùí´</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"bp\">#‚Ü•</span><span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">cardinal.mk_congr</span> <span class=\"o\">(</span><span class=\"n\">equiv.set.powerset</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">cardinal.mk_set</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">cardinal.mk_le_mk_powerset</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">#</span><span class=\"n\">s</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">#</span><span class=\"o\">(</span><span class=\"bp\">ùí´</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">cardinal.mk_powerset</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">cardinal.cantor</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>\n<p>The key trick here is discovering <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.set.powerset\">docs#equiv.set.powerset</a>, which I found with <code>library_search</code>. I made a PR with an expansion of <code>#(ùí´ s)</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/13786\">#13786</a></p>\n</blockquote>\n<p>How does that prove that a set is smaller than its powerset. I guess that makes sense, because of the <code>a &lt; 2 ^ a</code></p>",
        "id": 280623379,
        "sender_full_name": "Joseph O",
        "timestamp": 1651234409
    },
    {
        "content": "<p>I think that first of all you should decide how to state this in type theory. Your mathematical statement is that <code># s &lt; # (ùí´  s)</code> for any set <code>s</code>. I <em>think</em> that the equivalent in type theory is <code># Œ± &lt; # (set Œ±)</code>, for <code>Œ± : Type u</code>, but if you prefer you can state it for sets, it's just the the library for cardinals it is written for cardinals of types (of course if you have a set you also have a type, so at the end it doesn't matter, but you have to choose how to state your result).</p>",
        "id": 280623776,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651234666
    },
    {
        "content": "<p>Hmm for some reason my lean cant find <code>#</code>, isnt it imported from <code>set_theory.cardinal.basic</code>?</p>",
        "id": 280624150,
        "sender_full_name": "Joseph O",
        "timestamp": 1651234893
    },
    {
        "content": "<p><code>open_locale cardinal</code></p>",
        "id": 280624237,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651234925
    },
    {
        "content": "<p>It's notation for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal.mk\">docs#cardinal.mk</a></p>",
        "id": 280624253,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651234934
    },
    {
        "content": "<p>What does that do?</p>",
        "id": 280624256,
        "sender_full_name": "Joseph O",
        "timestamp": 1651234935
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/set.20questions/near/280624237\">said</a>:</p>\n<blockquote>\n<p><code>open_locale cardinal</code></p>\n</blockquote>\n<p>It runs all the commands in the locale, which are the commands that turn on the notation</p>",
        "id": 280624310,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651234961
    },
    {
        "content": "<p>Got it.</p>",
        "id": 280624369,
        "sender_full_name": "Joseph O",
        "timestamp": 1651234998
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"467926\">Joseph O</span> <a href=\"#narrow/stream/113489-new-members/topic/set.20questions/near/280620590\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113489-new-members/topic/set.20questions/near/280579243\">said</a>:</p>\n<blockquote>\n<p>This is the Cantor theorem you are referring to.</p>\n</blockquote>\n<p>Not exact actually. That is cantor‚Äôs diagonal argument. I am trying to prove the one saying every set is smaller than its powerset</p>\n</blockquote>\n<p>Cantor's proof that every set is smaller than its powerset is also a diagonal argument. You can check that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.cantor_surjective\">docs#function.cantor_surjective</a> is <strong>not</strong> about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> being non-enumerable.</p>",
        "id": 280624667,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1651235167
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/Cantor%27s_diagonal_argument#General_sets\">https://en.wikipedia.org/wiki/Cantor%27s_diagonal_argument#General_sets</a></p>",
        "id": 280624888,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1651235318
    },
    {
        "content": "<p>Aha you are right it is the diagonal argument. My original goal was essentially: If we have an infinite set, the set containing the subsets of the infinite set, essentially the powerset is larger. Using surjectivity I believe, but we didn't use a diagonal argument.</p>",
        "id": 280627137,
        "sender_full_name": "Joseph O",
        "timestamp": 1651236511
    },
    {
        "content": "<p>So this is what I want to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">cantor_theorem</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">)):</span> <span class=\"bp\">¬¨</span><span class=\"n\">function.surjective</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 280627677,
        "sender_full_name": "Joseph O",
        "timestamp": 1651236766
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 280628106,
        "sender_full_name": "Joseph O",
        "timestamp": 1651237010
    },
    {
        "content": "<p>First of all write down an extremely detailed mathematical proof. With pen and paper, not in Lean</p>",
        "id": 280628279,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651237101
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113489-new-members/topic/set.20questions/near/280621365\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/theories/sets.html\">https://leanprover-community.github.io/theories/sets.html</a></p>\n</blockquote>\n<p>Besides this link, is there a nice guide in sets that would tell me how to represent </p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mi>x</mi><mo>‚àà</mo><mi>A</mi><mi mathvariant=\"normal\">‚à£</mi><mi>x</mi><mo mathvariant=\"normal\">‚àâ</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">B = \\{ x \\in A | x \\notin f(A) \\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚àà</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord\">‚à£</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mord\"><span class=\"mrel\">‚àà</span></span><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"llap\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mord\">/</span><span class=\"mspace\" style=\"margin-right:0.0556em;\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)}</span></span></span></span></span></p>",
        "id": 280629106,
        "sender_full_name": "Joseph O",
        "timestamp": 1651237430
    },
    {
        "content": "<p><code>set B := {x | x ‚àâ range f}</code></p>",
        "id": 280629410,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1651237558
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"467926\">@Joseph O</span> Is <code>A</code> a <code>set</code> or a <code>Type</code>?</p>",
        "id": 280629517,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1651237600
    },
    {
        "content": "<p>Its a <code>Type</code></p>",
        "id": 280630415,
        "sender_full_name": "Joseph O",
        "timestamp": 1651238056
    },
    {
        "content": "<p>Ok, then <code>range f</code> is indeed what you want. Otherwise there is <code>f '' A</code>.</p>",
        "id": 280630503,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1651238112
    },
    {
        "content": "<p>How does it represent the range <code>f(A)</code>?</p>",
        "id": 280630554,
        "sender_full_name": "Joseph O",
        "timestamp": 1651238144
    },
    {
        "content": "<p>does it infer the <code>A</code>?</p>",
        "id": 280630575,
        "sender_full_name": "Joseph O",
        "timestamp": 1651238160
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Ya√´l Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/set.20questions/near/280629410\">said</a>:</p>\n<blockquote>\n<p><code>set B := {x | x ‚àâ range f}</code></p>\n</blockquote>\n<p>Also, how is that valid, as I never declared an <code>x</code></p>",
        "id": 280630676,
        "sender_full_name": "Joseph O",
        "timestamp": 1651238195
    },
    {
        "content": "<p>Aha, looking on the side, it seems that it is infered <code>B: set (set Œ±) := {x : set Œ± | x ‚àâ range f}</code></p>",
        "id": 280630731,
        "sender_full_name": "Joseph O",
        "timestamp": 1651238225
    },
    {
        "content": "<p><code>f : Œ± ‚Üí set Œ±</code> is enough for Lean to infer that <code>range f : set (set Œ±)</code>, which is enough to infer that <code>x : set Œ±</code>, which is enough to infer that <code>B : set (set Œ±)</code>.</p>",
        "id": 280630954,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1651238341
    },
    {
        "content": "<p>Unification is cool :-)</p>",
        "id": 280631157,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1651238445
    },
    {
        "content": "<p>wow</p>",
        "id": 280631380,
        "sender_full_name": "Joseph O",
        "timestamp": 1651238537
    },
    {
        "content": "<p>how come when i do <code>have Œæ : Œ±,</code> I get two goals?</p>",
        "id": 280631556,
        "sender_full_name": "Joseph O",
        "timestamp": 1651238638
    },
    {
        "content": "<p>MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">init.data.set</span>\n<span class=\"kn\">import</span> <span class=\"n\">set_theory.cardinal.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">cardinal</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">cantor_theorem</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">)):</span> <span class=\"bp\">¬¨</span><span class=\"n\">function.surjective</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">set</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">‚àâ</span> <span class=\"n\">range</span> <span class=\"n\">f</span><span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">Œæ</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 280631616,
        "sender_full_name": "Joseph O",
        "timestamp": 1651238653
    },
    {
        "content": "<p>Your first goal is the value of <code>Œæ</code></p>",
        "id": 280631809,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651238757
    },
    {
        "content": "<p>Your second goal is the original goal you started with</p>",
        "id": 280631868,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651238765
    },
    {
        "content": "<p>Why? Im trying to do this part of the proof <a href=\"/user_uploads/3121/aSfdip-gt2QCknjvq0lHtg-u/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/aSfdip-gt2QCknjvq0lHtg-u/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/aSfdip-gt2QCknjvq0lHtg-u/image.png\"></a></div>",
        "id": 280631928,
        "sender_full_name": "Joseph O",
        "timestamp": 1651238801
    },
    {
        "content": "<p>Imagine <code>Œ± = empty</code>. Then you cannot do <code>have Œæ : Œ±,</code> out of thin air.</p>",
        "id": 280632015,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1651238842
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"467926\">Joseph O</span> <a href=\"#narrow/stream/113489-new-members/topic/set.20questions/near/280631928\">said</a>:</p>\n<blockquote>\n<p>Why?</p>\n</blockquote>\n<p><code>have h : p,</code> means \"create a new goal with target <code>p</code>, and put <code>h : p</code> in the existing goal.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"467926\">Joseph O</span> <a href=\"#narrow/stream/113489-new-members/topic/set.20questions/near/280631928\">said</a>:</p>\n<blockquote>\n<p>Im trying to do this part of the proof <a href=\"/user_uploads/3121/aSfdip-gt2QCknjvq0lHtg-u/image.png\">image.png</a></p>\n</blockquote>\n<p>This isn't a proof, this is a statement. The previous or following sentence will say <em>why</em> such an Œæ exists, and you have to translate that sentence to lean too</p>",
        "id": 280632084,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651238881
    },
    {
        "content": "<p>\"there exists xi such that...\" is not <code>have xi</code>, it's <code>have h : \\exists \\xi, &lt;property that xi has&gt;</code></p>",
        "id": 280632164,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1651238899
    },
    {
        "content": "<p>So I did <code>by_contradiction</code>, which assumes <code>f</code> is surjective, which means there exists <code>‚àÉ Œæ, Œæ ‚àà Œ±</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">by_contradiction</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÉ</span> <span class=\"n\">Œæ</span><span class=\"o\">,</span> <span class=\"n\">Œæ</span> <span class=\"bp\">‚àà</span> <span class=\"n\">Œ±</span>\n</code></pre></div>\n<p>but it is failing to satisfy some sort of type class instance</p>",
        "id": 280632789,
        "sender_full_name": "Joseph O",
        "timestamp": 1651239198
    },
    {
        "content": "<p><code>Œæ ‚àà Œ±</code> is nonsense</p>",
        "id": 280633011,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651239286
    },
    {
        "content": "<p>It would be like writing <code>(n : ‚Ñï) (hn : n ‚àà ‚Ñï)</code></p>",
        "id": 280633097,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651239317
    },
    {
        "content": "<p>Is it already inferred?</p>",
        "id": 280633134,
        "sender_full_name": "Joseph O",
        "timestamp": 1651239338
    },
    {
        "content": "<p>I think <code>have Œæ : Œ±,</code> was the correct thing to write here</p>",
        "id": 280633170,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651239352
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"467926\">Joseph O</span> <a href=\"#narrow/stream/113489-new-members/topic/set.20questions/near/280633134\">said</a>:</p>\n<blockquote>\n<p>Is it already inferred?</p>\n</blockquote>\n<p>No, it's just meaningless. <code>‚àà</code> is defined on sets, <code>Œ±</code> is a type</p>",
        "id": 280633277,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651239390
    },
    {
        "content": "<p>If you insist on writing the <code>‚àà</code> symbol, you can write <code>Œæ ‚àà (set.univ : set Œ±)</code>, i.e. \"<code>Œæ</code> is in the set consisting of all possible values of <code>Œ±</code>\".</p>",
        "id": 280633330,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651239418
    },
    {
        "content": "<p>This is of course useless, because by definition everything is in <code>set.univ</code>.</p>",
        "id": 280633374,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651239440
    },
    {
        "content": "<p>Hmm but then that keeps making two goals. How would you represent this in lean?</p>",
        "id": 280633669,
        "sender_full_name": "Joseph O",
        "timestamp": 1651239581
    },
    {
        "content": "<p>Yes, it's making two goals because you have to tell lean why <code>Œæ : Œ±</code> exists</p>",
        "id": 280633799,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651239614
    },
    {
        "content": "<p>It exists if <code>f</code> is surjective</p>",
        "id": 280633827,
        "sender_full_name": "Joseph O",
        "timestamp": 1651239638
    },
    {
        "content": "<p>Great, you need to work out how to tell lean that</p>",
        "id": 280633846,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651239648
    },
    {
        "content": "<p>I would think with <code>exact</code>?</p>",
        "id": 280633904,
        "sender_full_name": "Joseph O",
        "timestamp": 1651239695
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"467926\">Joseph O</span> <a href=\"#narrow/stream/113489-new-members/topic/set.20questions/near/280633827\">said</a>:</p>\n<blockquote>\n<p>It exists if <code>f</code> is surjective</p>\n</blockquote>\n<p>What's the maths proof?</p>",
        "id": 280633941,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651239715
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/UF706x-1wffkaa8TWRVzn0ul/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/UF706x-1wffkaa8TWRVzn0ul/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/UF706x-1wffkaa8TWRVzn0ul/image.png\"></a></div>",
        "id": 280634018,
        "sender_full_name": "Joseph O",
        "timestamp": 1651239736
    },
    {
        "content": "<p>Because as hand-waved, your statement is false. <code>id : empty -&gt; empty</code> is surjective (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.surjective_id\">docs#function.surjective_id</a>), but there is no element of <code>empty</code></p>",
        "id": 280634026,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651239743
    },
    {
        "content": "<p>(double dollars <code>$$</code> for latex in Zulip - please do this instead of using an image)</p>",
        "id": 280634039,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651239751
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/Cantor%27s_theorem#Proof\">https://en.wikipedia.org/wiki/Cantor%27s_theorem#Proof</a> ?</p>",
        "id": 280634064,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1651239768
    },
    {
        "content": "<p>Suppose to the contrary that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mi>f</mi></mstyle></mrow><annotation encoding=\"application/x-tex\">{\\displaystyle f}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span> is surjective. Then there exists <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mi>Œæ</mi><mo>‚àà</mo><mi>A</mi></mstyle></mrow><annotation encoding=\"application/x-tex\">{\\displaystyle \\xi \\in A}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.04601em;\">Œæ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚àà</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mi>f</mi><mo stretchy=\"false\">(</mo><mi>Œæ</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>B</mi></mstyle></mrow><annotation encoding=\"application/x-tex\">{\\displaystyle f(\\xi )=B}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.04601em;\">Œæ</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>.</p>",
        "id": 280634244,
        "sender_full_name": "Joseph O",
        "timestamp": 1651239851
    },
    {
        "content": "<p>I suppose this with <code>by_contradiction</code></p>",
        "id": 280634333,
        "sender_full_name": "Joseph O",
        "timestamp": 1651239896
    },
    {
        "content": "<p>That proof has missed the (trivial) step between the <code>.</code> and the \"Then\", which lean wants you to spell out</p>",
        "id": 280634358,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651239903
    },
    {
        "content": "<p>Perhaps <code>rw function.surjective at h</code> will help you see what's going on?</p>",
        "id": 280634453,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651239941
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"467926\">Joseph O</span> <a href=\"#narrow/stream/113489-new-members/topic/set.20questions/near/280629106\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113489-new-members/topic/set.20questions/near/280621365\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/theories/sets.html\">https://leanprover-community.github.io/theories/sets.html</a></p>\n</blockquote>\n<p>Besides this link, is there a nice guide in sets that would tell me how to represent </p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mi>x</mi><mo>‚àà</mo><mi>A</mi><mi mathvariant=\"normal\">‚à£</mi><mi>x</mi><mo mathvariant=\"normal\">‚àâ</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">B = \\{ x \\in A | x \\notin f(A) \\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚àà</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord\">‚à£</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mord\"><span class=\"mrel\">‚àà</span></span><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"llap\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mord\">/</span><span class=\"mspace\" style=\"margin-right:0.0556em;\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)}</span></span></span></span></span><br>\n</p>\n</blockquote>\n<p>Btw, this is not the B from the wikipedia proof</p>",
        "id": 280634732,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1651240058
    },
    {
        "content": "<p>Oh wait it should have been <code>f(x)</code></p>",
        "id": 280634846,
        "sender_full_name": "Joseph O",
        "timestamp": 1651240091
    },
    {
        "content": "<p>Which is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">set</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">‚àâ</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">},</span>\n</code></pre></div>",
        "id": 280634868,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1651240104
    },
    {
        "content": "<p>That makes sense</p>",
        "id": 280634900,
        "sender_full_name": "Joseph O",
        "timestamp": 1651240127
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/set.20questions/near/280634453\">said</a>:</p>\n<blockquote>\n<p>Perhaps <code>rw function.surjective at h</code> will help you see what's going on?</p>\n</blockquote>\n<p>It seems like <code>Œæ</code> doesn't nessacerily have to exist</p>",
        "id": 280635132,
        "sender_full_name": "Joseph O",
        "timestamp": 1651240228
    },
    {
        "content": "<p>What's your goal state look like after that rewrite?</p>",
        "id": 280635175,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651240250
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Œ±</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">set</span> <span class=\"n\">Œ±</span>\n<span class=\"n\">B</span><span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">‚àâ</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">),</span> <span class=\"bp\">‚àÉ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n<span class=\"bp\">‚ä¢</span> <span class=\"n\">false</span>\n</code></pre></div>",
        "id": 280635220,
        "sender_full_name": "Joseph O",
        "timestamp": 1651240272
    },
    {
        "content": "<p>(this is without xi)</p>",
        "id": 280635240,
        "sender_full_name": "Joseph O",
        "timestamp": 1651240278
    },
    {
        "content": "<p>Your <code>h</code> says that for every <code>b</code>, there exists an <code>a</code></p>",
        "id": 280635293,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651240303
    },
    {
        "content": "<p>So if you're following the proof you pasted above, you want to set <code>b = B</code>, right?</p>",
        "id": 280635318,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651240311
    },
    {
        "content": "<p>Do you remember how to do that?</p>",
        "id": 280635343,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651240320
    },
    {
        "content": "<p>Do I use the <code>have</code> tactic?</p>",
        "id": 280635632,
        "sender_full_name": "Joseph O",
        "timestamp": 1651240432
    },
    {
        "content": "<p>Sure, that's as good a way as any</p>",
        "id": 280635739,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651240463
    },
    {
        "content": "<p>In fact, if you start with <code>have : ‚àÉ (a : Œ±), f a = B,</code>, then <code>library_search</code> will remind you how to prove that (if you don't already know)</p>",
        "id": 280635784,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651240487
    },
    {
        "content": "<p>i did this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">set</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">‚àâ</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">},</span>\n  <span class=\"n\">by_contradiction</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÉ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">B</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n</code></pre></div>\n<p>it seemed to work</p>",
        "id": 280636098,
        "sender_full_name": "Joseph O",
        "timestamp": 1651240623
    },
    {
        "content": "<p>for the second goal, the proof statement was </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Œ±</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">set</span> <span class=\"n\">Œ±</span>\n<span class=\"n\">B</span><span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">‚àâ</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"n\">f</span>\n<span class=\"n\">this</span><span class=\"o\">:</span> <span class=\"bp\">‚àÉ</span> <span class=\"o\">(</span><span class=\"n\">Œæ</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">Œæ</span> <span class=\"bp\">=</span> <span class=\"n\">B</span>\n<span class=\"bp\">‚ä¢</span> <span class=\"n\">false</span>\n</code></pre></div>",
        "id": 280636376,
        "sender_full_name": "Joseph O",
        "timestamp": 1651240764
    },
    {
        "content": "<p>And in the Wikipedia, the next this is said was </p>\n<p>But by construction, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mi>Œæ</mi><mo>‚àà</mo><mi>B</mi><mtext>‚ÄÖ‚Ää</mtext><mo>‚ü∫</mo><mtext>‚ÄÖ‚Ää</mtext><mi>Œæ</mi><mo mathvariant=\"normal\">‚àâ</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>Œæ</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>B</mi></mstyle></mrow><annotation encoding=\"application/x-tex\">{\\displaystyle \\xi \\in B\\iff \\xi \\notin f(\\xi )=B}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.04601em;\">Œæ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚àà</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚ü∫</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04601em;\">Œæ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mord\"><span class=\"mrel\">‚àà</span></span><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"llap\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mord\">/</span><span class=\"mspace\" style=\"margin-right:0.0556em;\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.04601em;\">Œæ</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>.</p>",
        "id": 280636529,
        "sender_full_name": "Joseph O",
        "timestamp": 1651240810
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 280636627,
        "sender_full_name": "Joseph O",
        "timestamp": 1651240837
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 280636722,
        "sender_full_name": "Joseph O",
        "timestamp": 1651240869
    },
    {
        "content": "<p>How can I destruct <code>this</code> to bring <code>Œæ</code> into scope?</p>",
        "id": 280637288,
        "sender_full_name": "Joseph O",
        "timestamp": 1651241125
    },
    {
        "content": "<p>Or How can I just bring it into scope in general</p>",
        "id": 280637658,
        "sender_full_name": "Joseph O",
        "timestamp": 1651241287
    },
    {
        "content": "<p>I think that <code>cases this</code> will do what you want.  Likely, <code>rcases? this</code> will give you a helpful <code>Try this: ...</code> that might also be closer that what you really want!</p>",
        "id": 280637859,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1651241397
    },
    {
        "content": "<p>thanks</p>",
        "id": 280637921,
        "sender_full_name": "Joseph O",
        "timestamp": 1651241409
    },
    {
        "content": "<p>nvm</p>",
        "id": 280638098,
        "sender_full_name": "Joseph O",
        "timestamp": 1651241502
    },
    {
        "content": "<p>What do you think of this proof?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">cantor_surjective</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"bp\">¬¨</span><span class=\"n\">function.surjective</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">set</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">‚àâ</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">},</span>\n  <span class=\"n\">by_contradiction</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÉ</span> <span class=\"o\">(</span><span class=\"n\">Œæ</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">Œæ</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">this</span> <span class=\"k\">with</span> <span class=\"o\">‚ü®</span><span class=\"n\">Œæ</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">‚ü©,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Œæ</span> <span class=\"bp\">‚àà</span> <span class=\"n\">B</span> <span class=\"bp\">‚Üî</span> <span class=\"n\">Œæ</span> <span class=\"bp\">‚àâ</span> <span class=\"n\">f</span><span class=\"o\">(</span><span class=\"n\">Œæ</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">mem_set_of</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">this_h</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">not_p_iff_not_p</span> <span class=\"n\">_</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>is it ok?</p>",
        "id": 280664625,
        "sender_full_name": "Joseph O",
        "timestamp": 1651253783
    },
    {
        "content": "<p>It definitely doesn't compete with mathlib's proof</p>",
        "id": 280664772,
        "sender_full_name": "Joseph O",
        "timestamp": 1651253865
    },
    {
        "content": "<p>If it translates your reasoning well then it's definitely a good achievement. The proofs that go to mathlib are highly golfed and sometimes hard to grasp</p>",
        "id": 280667247,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1651254644
    },
    {
        "content": "<p>A nice aspect of formalization is that if Lean says \"goals accomplished\" then the proof is OK :)</p>\n<p>It's never too late to golf a proof, but at the beginning I wouldn't bother too much</p>",
        "id": 280667291,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651254669
    },
    {
        "content": "<p>Yeah I am still very new to lean</p>",
        "id": 280667429,
        "sender_full_name": "Joseph O",
        "timestamp": 1651254747
    },
    {
        "content": "<p>can someone explain how this proof works?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">mk_le_of_injective</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">#</span><span class=\"n\">Œ±</span> <span class=\"bp\">‚â§</span> <span class=\"bp\">#</span><span class=\"n\">Œ≤</span> <span class=\"o\">:=</span> <span class=\"o\">‚ü®‚ü®</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">‚ü©‚ü©</span>\n</code></pre></div>",
        "id": 280668064,
        "sender_full_name": "Joseph O",
        "timestamp": 1651255118
    },
    {
        "content": "<p>This works because <code># Œ± ‚â§ # Œ≤</code> means <em>by definition</em> that there <code>f : Œ± ‚Üí Œ≤</code> injective.</p>",
        "id": 280668313,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651255220
    },
    {
        "content": "<p>oh but what about the nested structures. Frankly I'm confused</p>",
        "id": 280668412,
        "sender_full_name": "Joseph O",
        "timestamp": 1651255256
    },
    {
        "content": "<p>oh its bc of this, right?<br>\n<a href=\"/user_uploads/3121/J-nP3O6RNXK1xLcrJONkdVMJ/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/J-nP3O6RNXK1xLcrJONkdVMJ/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/J-nP3O6RNXK1xLcrJONkdVMJ/image.png\"></a></div>",
        "id": 280668453,
        "sender_full_name": "Joseph O",
        "timestamp": 1651255287
    },
    {
        "content": "<p>It's better if you post code so we don't have to lose sight of everything else to see what you're posting</p>",
        "id": 280668585,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1651255348
    },
    {
        "content": "<p>Well thats just from mathlib</p>",
        "id": 280668617,
        "sender_full_name": "Joseph O",
        "timestamp": 1651255364
    },
    {
        "content": "<p>Still, opening an image grays out everything else on Zulip :(</p>",
        "id": 280668726,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1651255423
    },
    {
        "content": "<p>The first  <code>‚ü®...‚ü©</code> takes care of <code>nonempty</code>. You can go in tactic mode (bewteen <code>begin</code> and <code>end</code>) and see what <code>refine ‚ü®_‚ü©</code> does.</p>",
        "id": 280668857,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651255474
    },
    {
        "content": "<p><code>refine ‚ü®_‚ü©</code> makes the goal into<code>f</code> is injective or smth, but then the last structure.... I'm still so confused</p>",
        "id": 280669144,
        "sender_full_name": "Joseph O",
        "timestamp": 1651255651
    },
    {
        "content": "<p>Basically, to prove that something is nonempty you can exhibit an element. But if you look at the precise definition of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nonempty\">docs#nonempty</a> you see that it is a structure, with only one constructor. This looks complicated, but in practice you have to write the element you've found inside <code>‚ü® ‚ü©</code>. You can also write <code>refine nonempty.intro _</code>.</p>",
        "id": 280669250,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651255698
    },
    {
        "content": "<p>Now the goal is <code>Œ± ‚Ü™ Œ≤</code>, so you have to produce an element of this type.</p>",
        "id": 280669277,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651255713
    },
    {
        "content": "<p>If you look at the definition of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.embedding\">docs#function.embedding</a>, you see that to produce an embedding you have to produce two things: a function and a proof that this function is injective.</p>",
        "id": 280669472,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651255816
    },
    {
        "content": "<p><code>‚ü®_, _‚ü©</code> allows you to give these elements once at a time.</p>",
        "id": 280669526,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651255850
    },
    {
        "content": "<p>Try refine <code>‚ü®_, _‚ü©</code>, you'll have two goals. The first will be a function, and you can close it with <code>exact f</code>.</p>",
        "id": 280669582,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651255889
    },
    {
        "content": "<p>Then you have to prove that the <code>f</code> you gave is injective, and this is <code>hf</code>.</p>",
        "id": 280669617,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651255915
    },
    {
        "content": "<p><code>‚ü®‚ü®f, hf‚ü©‚ü©</code> is just a way to compress all this stuff.</p>",
        "id": 280669731,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651255975
    },
    {
        "content": "<p>But really, mathlib proofs are not easy to read, don't spend too much time on them. You will get there anyway at some point.</p>",
        "id": 280669829,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651256039
    },
    {
        "content": "<p>Especially proofs that are mathematically irrelevant, like this one (there is literally nothing to prove) are highly compressed, using only term mode.</p>",
        "id": 280669917,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651256081
    },
    {
        "content": "<p>If your proof is accepted and is not unnecessarily long or slow, then it's fine. We trust on Lean's kernel</p>",
        "id": 280670219,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1651256275
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113489-new-members/topic/set.20questions/near/280669250\">said</a>:</p>\n<blockquote>\n<p>Basically, to prove that something is nonempty you can exhibit an element. But if you look at the precise definition of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nonempty\">docs#nonempty</a> you see that it is a structure, with only one constructor. This looks complicated, but in practice you have to write the element you've found inside <code>‚ü® ‚ü©</code>. You can also write <code>refine nonempty.intro _</code>.</p>\n</blockquote>\n<p>But what are we saying is nonempty</p>",
        "id": 280679250,
        "sender_full_name": "Joseph O",
        "timestamp": 1651261320
    },
    {
        "content": "<p>a or b?</p>",
        "id": 280679326,
        "sender_full_name": "Joseph O",
        "timestamp": 1651261346
    },
    {
        "content": "<p>We're saying the type <code>Œ± ‚Ü™ Œ≤</code> is nonempty</p>",
        "id": 280679600,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651261534
    },
    {
        "content": "<p>And why does it produce a type of function.embedding?</p>",
        "id": 280679711,
        "sender_full_name": "Joseph O",
        "timestamp": 1651261590
    },
    {
        "content": "<p>Where did that come from</p>",
        "id": 280679715,
        "sender_full_name": "Joseph O",
        "timestamp": 1651261594
    },
    {
        "content": "<p>To prove that <code>Œ± ‚Ü™ Œ≤</code> is nonempty you need to find an element of type <code>Œ± ‚Ü™ Œ≤</code>.</p>",
        "id": 280681520,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651262620
    },
    {
        "content": "<p>If <code>x : Œ± ‚Ü™ Œ≤</code> is such an element, then <code>exact nonempty.intro x</code> is a proof of <code>nonempty Œ± ‚Ü™ Œ≤</code>. This can be shortened to <code>exact ‚ü®x‚ü©</code>, or <code>‚ü®x‚ü©</code> in term mode.</p>",
        "id": 280681879,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651262805
    },
    {
        "content": "<p>Lean is asking to prove <code>nonempty (Œ± ‚Ü™ Œ≤)</code> because this is <em>the definition</em> of <code>#Œ± ‚â§ #Œ≤</code>.</p>",
        "id": 280682149,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651262953
    },
    {
        "content": "<p>(the literal definition of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal.has_le\">docs#cardinal.has_le</a> is more complicated because <code>#Œ±</code> is defined on equivalence classes of types, so one has to check that this definition makes sense)</p>",
        "id": 280682326,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651263046
    },
    {
        "content": "<p>But again, I think you are focusing too much on the Lean code instead of the actual math. What is your definition of <code>#Œ± ‚â§ #Œ≤</code> (feel free to think that <code>Œ±</code> and <code>Œ≤</code> are sets, forgetting about type theory)?</p>",
        "id": 280682423,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651263121
    },
    {
        "content": "<p>Actually I get it now. Thanks for your help!</p>",
        "id": 280701057,
        "sender_full_name": "Joseph O",
        "timestamp": 1651274439
    },
    {
        "content": "<p>I find that this proof makes the most sense for a beginner</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">mk_le_of_injective</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">#</span><span class=\"n\">Œ±</span> <span class=\"bp\">‚â§</span> <span class=\"bp\">#</span><span class=\"n\">Œ≤</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">nonempty.intro</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">‚ü®</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">‚ü©,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 280702077,
        "sender_full_name": "Joseph O",
        "timestamp": 1651275349
    },
    {
        "content": "<p>Like me</p>",
        "id": 280702078,
        "sender_full_name": "Joseph O",
        "timestamp": 1651275354
    },
    {
        "content": "<p>If you don't want to figure out the names of your constructors (like <code>nonempty.intro</code>), you can use <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#fsplit\">tactic#fsplit</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">mk_le_of_injective</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">#</span><span class=\"n\">Œ±</span> <span class=\"bp\">‚â§</span> <span class=\"bp\">#</span><span class=\"n\">Œ≤</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">fsplit</span><span class=\"o\">,</span>\n  <span class=\"n\">fsplit</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>It creates a new goal for each argument that the constructor needs. (<code>fsplit</code> is like <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#split\">tactic#split</a> but makes sure that the goals are in a useful order. <code>split</code> can be backwards.)</p>",
        "id": 280704276,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651277570
    },
    {
        "content": "<p>Or, if you don't want to prove it since you know it's just a bunch of splits and exacts, there's <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#tidy\">tactic#tidy</a>, which tries to make progress using some basic tactics.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">mk_le_of_injective</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">#</span><span class=\"n\">Œ±</span> <span class=\"bp\">‚â§</span> <span class=\"bp\">#</span><span class=\"n\">Œ≤</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">tidy</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 280704379,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651277665
    },
    {
        "content": "<p>Oh wow thanks</p>",
        "id": 280704518,
        "sender_full_name": "Joseph O",
        "timestamp": 1651277777
    },
    {
        "content": "<p>Here's a fun one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">mk_le_of_injective</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">#</span><span class=\"n\">Œ±</span> <span class=\"bp\">‚â§</span> <span class=\"bp\">#</span><span class=\"n\">Œ≤</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">fsplit</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">assumption</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 280704526,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651277784
    },
    {
        "content": "<p>That means \"repeatedly try doing <code>fsplit</code> or <code>assumption</code> until one of them fails\".</p>",
        "id": 280704543,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651277806
    },
    {
        "content": "<p><span aria-label=\"astonished\" class=\"emoji emoji-1f632\" role=\"img\" title=\"astonished\">:astonished:</span></p>",
        "id": 280704548,
        "sender_full_name": "Joseph O",
        "timestamp": 1651277815
    },
    {
        "content": "<p>will <code>assumption</code> always work?</p>",
        "id": 280704558,
        "sender_full_name": "Joseph O",
        "timestamp": 1651277830
    },
    {
        "content": "<p>Which do you reccomend to a begginer</p>",
        "id": 280704568,
        "sender_full_name": "Joseph O",
        "timestamp": 1651277848
    },
    {
        "content": "<p>It's for doing <code>exact foo</code> when <code>foo</code> is one of the hypotheses.</p>",
        "id": 280704570,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651277854
    },
    {
        "content": "<p>but you don't have to specify the hypothesis.</p>",
        "id": 280704637,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651277894
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">mk_le_of_injective</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">#</span><span class=\"n\">Œ±</span> <span class=\"bp\">‚â§</span> <span class=\"bp\">#</span><span class=\"n\">Œ≤</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">fsplit</span><span class=\"o\">,</span>\n  <span class=\"n\">fsplit</span><span class=\"o\">,</span>\n  <span class=\"n\">assumption</span><span class=\"o\">,</span>\n  <span class=\"n\">assumption</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 280704658,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651277912
    },
    {
        "content": "<p>If you want to know what <code>tidy</code> did, you can use <code>tidy?</code> and it will be shown as a (clickable) <code>Try this: ‚ãØ</code> snippet in the infoview</p>",
        "id": 280704686,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1651277945
    },
    {
        "content": "<p>I don't have a recommendation about <code>assumption</code> vs <code>exact</code>. I use both <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>\n<p>What <code>assumption</code> essentially does is try doing <code>exact</code> for each hypothesis one at a time until one succeeds. (To be completely accurate: it looks for a hypothesis where <code>exact</code> should succeed and does <code>exact</code> with it.)</p>",
        "id": 280705066,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651278302
    },
    {
        "content": "<p><code>assumption</code> is better in repeated segments of the proof where parameters may vary (for example <code>; assumption</code> or <code>repeat { assumption }</code>), but I would say that <code>exact</code> is generally better, because it's faster. Consider the following example where <code>assumption</code> fails, but <code>exact</code> works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h‚ÇÅ</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"mi\">10</span> <span class=\"bp\">^</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">10</span> <span class=\"bp\">^</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">10</span> <span class=\"bp\">^</span> <span class=\"mi\">5</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">assumption</span><span class=\"o\">,</span> <span class=\"c1\">-- fails</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h‚ÇÇ</span><span class=\"o\">,</span>   <span class=\"c1\">-- works</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 280715631,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1651292403
    },
    {
        "content": "<p>Huh, even with <code>none</code> transparency <code>assumption</code> would fail here.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">tactic</span>\n\n<span class=\"sd\">/-- `find_same_type t es` tries to find in es an expression with type definitionally equal to t -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">find_same_type'</span> <span class=\"o\">(</span><span class=\"n\">tr</span> <span class=\"o\">:</span> <span class=\"n\">transparency</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">list</span> <span class=\"n\">expr</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">tactic</span> <span class=\"n\">expr</span>\n<span class=\"bp\">|</span> <span class=\"n\">e</span> <span class=\"o\">[]</span>         <span class=\"o\">:=</span> <span class=\"n\">failed</span>\n<span class=\"bp\">|</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">::</span> <span class=\"n\">Hs</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">do</span> <span class=\"n\">t</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">infer_type</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n     <span class=\"o\">(</span><span class=\"n\">unify</span> <span class=\"n\">e</span> <span class=\"n\">t</span> <span class=\"n\">tr</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">return</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">find_same_type'</span> <span class=\"n\">e</span> <span class=\"n\">Hs</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">find_assumption'</span> <span class=\"o\">(</span><span class=\"n\">tr</span> <span class=\"o\">:</span> <span class=\"n\">transparency</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">ctx</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">local_context</span><span class=\"o\">,</span> <span class=\"n\">find_same_type'</span> <span class=\"n\">tr</span> <span class=\"n\">e</span> <span class=\"n\">ctx</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">assumption''</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"o\">{</span> <span class=\"n\">ctx</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">local_context</span><span class=\"o\">,</span>\n     <span class=\"n\">t</span>   <span class=\"bp\">‚Üê</span> <span class=\"n\">target</span><span class=\"o\">,</span>\n     <span class=\"n\">H</span>   <span class=\"bp\">‚Üê</span> <span class=\"n\">find_same_type'</span> <span class=\"n\">transparency.none</span> <span class=\"n\">t</span> <span class=\"n\">ctx</span><span class=\"o\">,</span>\n     <span class=\"n\">exact</span> <span class=\"n\">H</span> <span class=\"o\">}</span>\n<span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">fail</span> <span class=\"s2\">\"assumption tactic failed\"</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">interactive.assumption''</span> <span class=\"o\">:=</span> <span class=\"n\">tactic.assumption</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h‚ÇÅ</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"mi\">10</span> <span class=\"bp\">^</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">10</span> <span class=\"bp\">^</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">10</span> <span class=\"bp\">^</span> <span class=\"mi\">5</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">assumption''</span><span class=\"o\">,</span> <span class=\"c1\">-- fails</span>\n  <span class=\"c1\">-- deep recursion was detected at 'expression equality test'</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I wonder if that's a bug in <code>unify</code> or if this is unavoidable?</p>",
        "id": 280742995,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651334543
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/set.20questions/near/280742995\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">interactive.assumption''</span> <span class=\"o\">:=</span> <span class=\"n\">tactic.assumption</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Do you see it? :)</p>",
        "id": 280746877,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1651339775
    },
    {
        "content": "<p>I better configure <em>myself</em> to use semireducible transparency</p>",
        "id": 280747736,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651340845
    }
]
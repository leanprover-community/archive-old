[
    {
        "content": "<p>Is it a code smell if I often write <code>apply congr_arg,</code> in my proofs?</p>",
        "id": 281498046,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1651873690
    },
    {
        "content": "<p>Sometimes you might want <code>congr' 1,</code> instead. <code>refine congr_arg _ _</code> can also sometimes be more predictable</p>",
        "id": 281498309,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651873899
    },
    {
        "content": "<p>Is it a code smell if I write <code>change</code> immediately followed by <code>convert_to</code> in some places (not many) of my proofs?</p>",
        "id": 281524465,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1651906744
    },
    {
        "content": "<p>My experience with <code>change</code> is that often you are better off proving a <code>rfl</code> lemma doing the change for you.  In some cases this simple trick has spectacular proof-shortening effects.  I wish I had an example at hand, but I don't at the moment.</p>",
        "id": 281524793,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1651907264
    },
    {
        "content": "<p>You mean a lemma that \"restates\" the definition?</p>",
        "id": 281525786,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1651908773
    },
    {
        "content": "<p>Yes, just a lemma whose proof is <code>rfl</code>, guiding lean through the definition.</p>",
        "id": 281527459,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1651911468
    },
    {
        "content": "<p>Is there no better way how to tell Lean to apply / unapply definition without creating this boilerplate? Unfortunately <code>unfold</code> does not always do what I want.</p>",
        "id": 281527674,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1651911740
    },
    {
        "content": "<p>Can you give an example of a definition where <code>unfold</code> does the wrong thing?</p>",
        "id": 281527911,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651912057
    },
    {
        "content": "<p>Yes, I can. However, making MWE out of it will probably be hard.</p>",
        "id": 281527962,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1651912120
    },
    {
        "content": "<p>What's the non-mwe version? Can you link to a gist or something?</p>",
        "id": 281527986,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651912186
    },
    {
        "content": "<p>On this line:<br>\n<a href=\"https://github.com/madvorak/grammars/blob/75c5d5db4be45957bafd1d651086821af4373472/src/context_free/closure_properties/binary/CF_union_CF.lean#L326\">https://github.com/madvorak/grammars/blob/75c5d5db4be45957bafd1d651086821af4373472/src/context_free/closure_properties/binary/CF_union_CF.lean#L326</a></p>\n<p>I am unpacking this definition:<br>\n<a href=\"https://github.com/madvorak/grammars/blob/75c5d5db4be45957bafd1d651086821af4373472/src/context_free/cfg.lean#L29\">https://github.com/madvorak/grammars/blob/75c5d5db4be45957bafd1d651086821af4373472/src/context_free/cfg.lean#L29</a></p>\n<p>Unfotunately <code>unfold CF_generates,</code> does not work.</p>",
        "id": 281528140,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1651912434
    },
    {
        "content": "<p>It gives me: <code>simplify tactic failed to simplify</code></p>",
        "id": 281528202,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1651912523
    },
    {
        "content": "<p>What's the goal state at that point</p>",
        "id": 281528765,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651913202
    },
    {
        "content": "<p>I would like to obtain <code>CF_generates_str (union_grammar g₁ g₂) (list.map symbol.terminal w),</code> without stating it explicitly. My <code>change</code> only does what I supposed that <code>unfold</code> would do.</p>",
        "id": 281528837,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1651913313
    },
    {
        "content": "<p>I would say that <code>unfold</code> is a code smell indicating that there is missing boilerplate.</p>",
        "id": 281528935,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1651913470
    },
    {
        "content": "<p>Is there really no better way than repeating the definition again as a lemma? I hate how it looks.</p>",
        "id": 281529019,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1651913573
    },
    {
        "content": "<p>Does <code>rw CF_generates</code> do what you want?</p>",
        "id": 281529683,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1651914592
    },
    {
        "content": "<p>It gives me: <code>failed</code></p>",
        "id": 281529752,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1651914703
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113489-new-members/topic/Code.20smell.3F/near/281528837\">said</a>:</p>\n<blockquote>\n<p>I would like to obtain <code>CF_generates_str (union_grammar g₁ g₂) (list.map symbol.terminal w),</code> without stating it explicitly. My <code>change</code> only does what I supposed that <code>unfold</code> would do.</p>\n</blockquote>\n<p>Yes, but what was the goal state before that?</p>",
        "id": 281529895,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651914949
    },
    {
        "content": "<p>Oh sorry. It was: <code>w ∈ CF_generates (union_grammar g₁ g₂)</code></p>",
        "id": 281529967,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1651915070
    },
    {
        "content": "<p>That goal is nonsense</p>",
        "id": 281530010,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651915097
    },
    {
        "content": "<p><code>CF_generates </code> isn't a set</p>",
        "id": 281530012,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651915102
    },
    {
        "content": "<p>How did you get there?</p>",
        "id": 281530021,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651915116
    },
    {
        "content": "<p>Is <code>language</code> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/language\">docs#language</a>?</p>",
        "id": 281530037,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651915164
    },
    {
        "content": "<p>If so, these lines are wrong<br>\n<a href=\"https://github.com/madvorak/grammars/blob/75c5d5db4be45957bafd1d651086821af4373472/src/context_free/cfg.lean#L33-L34\">https://github.com/madvorak/grammars/blob/75c5d5db4be45957bafd1d651086821af4373472/src/context_free/cfg.lean#L33-L34</a></p>",
        "id": 281530040,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651915169
    },
    {
        "content": "<p>That should be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">CF_language</span> <span class=\"o\">:</span> <span class=\"n\">language</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"n\">set_of</span> <span class=\"o\">(</span><span class=\"n\">CF_generates</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 281530044,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651915186
    },
    {
        "content": "<p>Oh, thanks a lot!!</p>\n<p>So I cannot use <code>set t</code> as <code>t → Prop</code> hoping that it is definitionally equivalent?</p>",
        "id": 281530216,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1651915402
    },
    {
        "content": "<p>You'll find you have to fight with <code>change</code> all the time if you do that</p>",
        "id": 281530224,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651915421
    },
    {
        "content": "<p>Thank you very much!!! This change will eliminate <code>change</code> in so many places!!!</p>",
        "id": 281530278,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1651915457
    },
    {
        "content": "<p>They're definitionally equivalent, but to keep things in a state where lean will help you, you use <code>∈ </code> to convert a set into a function, and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set_of\">docs#set_of</a> (aka <code>{x | p x}</code>) to convert a function into a set</p>",
        "id": 281530286,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651915472
    },
    {
        "content": "<p>I don't know whether it is related but... When I have a goal in the form of <code>list.mem a L</code> existing lemmata about lists don't work. I have to <code>change</code> it to <code>a ∈ L</code> and only then they can be applied. Is there a similar trick for that?</p>",
        "id": 281530426,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1651915712
    },
    {
        "content": "<p>Same question. How did you get there?</p>",
        "id": 281530633,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1651916071
    },
    {
        "content": "<p>I had: <code>r_in : r ∈ (head :: tail)</code><br>\n<a href=\"https://github.com/madvorak/grammars/blob/75c5d5db4be45957bafd1d651086821af4373472/src/context_free/closure_properties/binary/CF_union_CF.lean#L151\">https://github.com/madvorak/grammars/blob/75c5d5db4be45957bafd1d651086821af4373472/src/context_free/closure_properties/binary/CF_union_CF.lean#L151</a><br>\nI called: <code>cases r_in,</code><br>\nThe first case was great: <code>r = head</code><br>\nThe second case was: <code>list.mem r tail</code><br>\nWhat could I have done instead to obtain <code>r ∈ tail</code> please?</p>",
        "id": 281530987,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1651916528
    },
    {
        "content": "<p>You should have looked for a lemma that matches the form of the hypothesis</p>",
        "id": 281531281,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651916919
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/contribute/naming.html\">#naming</a> suggests it would be called <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.mem_cons\">docs#list.mem_cons</a></p>",
        "id": 281531284,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651916927
    },
    {
        "content": "<p>Clicking that link reveals it's called <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.mem_cons_iff\">docs#list.mem_cons_iff</a></p>",
        "id": 281531295,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651916951
    },
    {
        "content": "<p>Either way, if you type <code>list.mem_cons</code> in vs-code, autocomplete should do the rest</p>",
        "id": 281531303,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651916967
    },
    {
        "content": "<p>Thanks a lot!!!</p>",
        "id": 281531321,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1651916987
    },
    {
        "content": "<p>Is there a general methodical mistake that I make?</p>",
        "id": 281531326,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1651917000
    },
    {
        "content": "<p>In fact, <code>cases list.eq_or_mem_of_mem_cons r_in</code> is probably what you want, where that lemma is just below the one I linked to</p>",
        "id": 281531372,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651917009
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113489-new-members/topic/Code.20smell.3F/near/281531326\">said</a>:</p>\n<blockquote>\n<p>Is there a general methodical mistake that I make?</p>\n</blockquote>\n<p>Always search for a lemma before unfolding. To some extent, <code>cases</code> does unfolding too. Use your judgement on the output of <code>cases</code> to decide if you might have unfolded too far</p>",
        "id": 281531379,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651917034
    },
    {
        "content": "<p>An easy way to search for useful lemmas is just <code>simp?</code></p>",
        "id": 281531388,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651917072
    },
    {
        "content": "<p>I learnt to use <code>squeeze_simp</code> only recently.</p>",
        "id": 281531394,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1651917102
    },
    {
        "content": "<p>Which might not get you to where you want to be, but will usually take you to a place where it's easier to find matching lemmas</p>",
        "id": 281531396,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651917103
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113489-new-members/topic/Code.20smell.3F/near/281531394\">said</a>:</p>\n<blockquote>\n<p>I learnt to use <code>squeeze_simp</code> only recently.</p>\n</blockquote>\n<p>That's better than <code>simp?</code> but a bit slower</p>",
        "id": 281531399,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651917114
    },
    {
        "content": "<p>Is it a code smell when I have the following pair of lines in my code?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"n\">some_lemma</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">some_lemma</span> <span class=\"n\">at</span> <span class=\"n\">some_assumption</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 281541722,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1651931629
    },
    {
        "content": "<p>You can write instead the shorter</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"n\">some_lemma</span> <span class=\"n\">at</span> <span class=\"n\">some_assumption</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>That last sign means the goal.</p>",
        "id": 281541804,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1651931756
    },
    {
        "content": "<p>Writing such a line is not uncommon and not a code smell in itself</p>",
        "id": 281541859,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1651931852
    },
    {
        "content": "<p>Is it idiomatic to use <code>variable</code> instead of <code>variables</code> when adding a single (implicit) argument?</p>",
        "id": 284584721,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654074413
    },
    {
        "content": "<p>I tend not to because my brain always bugs when I then add another variable to it and get a weird error.</p>",
        "id": 284584948,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1654074577
    },
    {
        "content": "<p>Yeah, I agree; the very marginal readability benefit is totally outweighed by the awkwardness to edit</p>",
        "id": 284585104,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654074644
    },
    {
        "content": "<p>It would be like having <code>[1, 2, and 3]</code> as list notation</p>",
        "id": 284585145,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654074675
    },
    {
        "content": "<p>It smells like a slightly bad design decision that both <code>variable</code> and <code>variables</code> exist.</p>",
        "id": 284585330,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654074823
    },
    {
        "content": "<p>I think it would be fine if they were functionally the same.</p>",
        "id": 284585442,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1654074906
    },
    {
        "content": "<p>However, I am pretty fine with both <code>intro</code> and <code>intros</code> because I almost never edit them.</p>",
        "id": 284585445,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654074907
    },
    {
        "content": "<p>Note that in lean 4 <code>variable</code> has been deleted and <code>variables</code> has been renamed to <code>variable</code></p>",
        "id": 284585877,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1654075195
    },
    {
        "content": "<p>I think <code>intro</code> is just as bad TBH. <code>rintro</code> is just silently identical to <code>rintros</code></p>",
        "id": 284585987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1654075252
    },
    {
        "content": "<p>Yeah, I always use <code>rintro</code> instead of <code>intro</code> and <code>intros</code> for the same reasons.</p>",
        "id": 284586034,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1654075292
    },
    {
        "content": "<p>Plural<del>s</del> were a mistake <span aria-label=\"trademark\" class=\"emoji emoji-2122\" role=\"img\" title=\"trademark\">:trademark:</span></p>",
        "id": 284586175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1654075362
    },
    {
        "content": "<p>Although, a variation on this same \"one looks different from more than one\" issue is <code>rw e</code> vs <code>rw [e1, e2]</code></p>",
        "id": 284586399,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1654075512
    },
    {
        "content": "<p>lean 4 also removed the first version, possibly for this reason</p>",
        "id": 284586424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1654075534
    },
    {
        "content": "<p>I really like <code>rw e</code> as it works in lean 3.</p>",
        "id": 284586638,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654075667
    },
    {
        "content": "<p>BTW, is it a bad style if I declare <code>variables</code> which are then used only in small portion of the stuff in the given scope?</p>",
        "id": 284588005,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654076470
    },
    {
        "content": "<p>We do it all the time in mathlib</p>",
        "id": 284588030,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1654076489
    },
    {
        "content": "<p>Is it OK even if they occupy \"expensive\" identifiers (i.e., one-letter names)?</p>",
        "id": 284588209,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654076613
    },
    {
        "content": "<p>You can always \"shadow\" expensive variable names in <code>lemma</code> statements</p>",
        "id": 284588894,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654077063
    },
    {
        "content": "<p>The two main problems you face when having too many variables are usually:</p>\n<ul>\n<li>Having a type <code>R</code> that has too many typeclasses in the <code>variables</code> list, and not being able to easily exclude those without declaring a brand new <code>R</code></li>\n<li>Not remembering whether the <code>variables</code> line 100 lines up the file uses <code>()</code> or <code>{}</code> to declare the variables, and getting your argument implicitness wrong as a result</li>\n</ul>",
        "id": 284589035,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654077154
    },
    {
        "content": "<p>Am I the only one who finds it confusing to use <code>variables</code> for explicit arguments <code>(a : T)</code> shared by multiple items? I have a natural tendency to expect, when I look at a declaration of a function, to see all arguments that I need to pass when calling the function.</p>\n<p>The code intellisense \"quick info\" in VSCode shows all arguments (including those written using <code>variables</code> anywhere above) but I like to look at my definition in the code. There I easily get confused by an \"invisible\" required argument.</p>",
        "id": 284789687,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654196512
    },
    {
        "content": "<p>I agree that it's confusing. Gets particularly annoying when you add a few extra theorems and suddenly the argument <code>a</code> can be made implicit in them</p>",
        "id": 284789846,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654196568
    },
    {
        "content": "<p>So, should I use <code>variables</code> only for <code>{stuff}</code> and <code>[stuff]</code> for the sake of code readability?</p>",
        "id": 284790044,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654196658
    },
    {
        "content": "<p>I mean, if you have 15 theorems in a code block and all of them need an explicit argument, I'd say using <code>variables (stuff)</code> is fine</p>",
        "id": 284790219,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654196750
    },
    {
        "content": "<p>But if it's just a handful, then it's not a great idea</p>",
        "id": 284790292,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654196769
    },
    {
        "content": "<p>I'd like to hear more opinions about this issue. It has been bugging me recently a lot.</p>",
        "id": 284791413,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654197284
    },
    {
        "content": "<p>I have the same stance as Violeta. Unless all your lemmas are gonna need the same explicit arguments, restrict <code>variables</code> declarations to implicit or instance arguments.</p>",
        "id": 284791904,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1654197496
    },
    {
        "content": "<p>And if they do, does it justify the loss of readability?</p>",
        "id": 284791998,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654197545
    },
    {
        "content": "<p>I think that in some cases, you gain a lot of readability. Writing down <code>(a : T) (b : U) (c : V)</code> over and over, particularly when the types have much longer names, and particularly when they're clear from context, is quite a chore</p>",
        "id": 284792169,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654197618
    },
    {
        "content": "<p>I think my view lies closer to Martin's here. One other case to consider; if one of your explicit arguments is a <code>Type</code>, it's a chore to repeat all its typeclasses on a lemma. Usually this is handled with <code>variables (R)</code> <code>the_lemma</code> <code>variables {R}</code></p>",
        "id": 284793044,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654198038
    },
    {
        "content": "<p>Which is still fairly readable because the explicit argument is adjacent</p>",
        "id": 284793088,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654198066
    },
    {
        "content": "<p>Is there a shortcut for the following two lines?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">rw</span> <span class=\"n\">set.mem_set_of_eq</span> <span class=\"n\">at</span> <span class=\"bp\">⊢</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">set.mem_set_of_eq</span> <span class=\"n\">at</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>I want to apply <code>set.mem_set_of_eq</code> twice to the goal and once to <code>h</code>.</p>",
        "id": 284903455,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654274615
    },
    {
        "content": "<p>Does</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_set_of_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">⊢</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>work?</p>",
        "id": 284903648,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654274704
    },
    {
        "content": "<p><code>dsimp at ⊢ h,</code>?</p>",
        "id": 284903903,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1654274845
    },
    {
        "content": "<p>Or even not doing anything?  <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 284904053,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1654274911
    },
    {
        "content": "<p>Ah yes, I didn't even had a look of what the lemma was.<br>\nTo clarify, the lemma is useful for a human being, but the LHS is defined to be the RHS, so it's possible the Lean doesn't need it at all.</p>",
        "id": 284904159,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654274978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113489-new-members/topic/Code.20smell.3F/near/284903648\">said</a>:</p>\n<blockquote>\n<p>Does</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_set_of_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">⊢</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>work?</p>\n</blockquote>\n<p>Yes, it does. However, I don't like calling <code>simp</code> for something that I know precisely how to do.</p>",
        "id": 284905520,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654275626
    },
    {
        "content": "<p>I tried <code>rw set.mem_set_of_eq at ⊢ h ⊢,</code> but was disappointed.</p>",
        "id": 284906114,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654275901
    },
    {
        "content": "<p>I don't mind that much that I have to write two nearly-identical lines. I hate that the \"three operations\" are grouped into \"two commands\" in a counter-intuitive way.</p>",
        "id": 284906314,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654275996
    },
    {
        "content": "<p>Maybe you could try <code>repeat { rw set.mem_set_of_eq, try { rw set.mem_set_of_eq at h } }</code>?</p>",
        "id": 284906677,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1654276174
    },
    {
        "content": "<p>I'm not sure what we are aiming for here, though...</p>",
        "id": 284906699,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1654276191
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/Code.20smell.3F/near/284906699\">said</a>:</p>\n<blockquote>\n<p>I'm not sure what we are aiming for here, though...</p>\n</blockquote>\n<p>I am aiming for something less awkward. If it cannot be done, I will put up with it.</p>",
        "id": 284907067,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654276386
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/Code.20smell.3F/near/284906677\">said</a>:</p>\n<blockquote>\n<p>Maybe you could try <code>repeat { rw set.mem_set_of_eq, try { rw set.mem_set_of_eq at h } }</code>?</p>\n</blockquote>\n<p>I'd rather write three lines than this.</p>",
        "id": 284907112,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654276425
    },
    {
        "content": "<p>But have you tried just skipping the rw?</p>",
        "id": 284907196,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1654276469
    },
    {
        "content": "<p>What is the next line in your proof?</p>",
        "id": 284907209,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1654276481
    },
    {
        "content": "<p>I know I can skip this <code>rw</code>. However, according to some advice I obtained here previously, I decided to define stuff with <code>set_of</code> in order to avoid the command <code>change</code>. So now, I want to take advantage of that. I am aware that <code>set.mem_set_of_eq</code> does only a definitional equality; however, it has impact on the effect of some other tactics. And I don't feel like going to <code>change</code> again.</p>",
        "id": 284907624,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654276695
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113489-new-members/topic/Code.20smell.3F/near/284905520\">said</a>:</p>\n<blockquote>\n<p>Yes, it does. However, I don't like calling <code>simp</code> for something that I know precisely how to do.</p>\n</blockquote>\n<p>I'm curious what the motivation is for this preference -- <code>simp</code> is designed for repeatedly doing rewrites like this.</p>\n<p>But if this preference is strong, you can refactor it as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">set.mem_set_of_eq</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"n\">set.mem_set_of_eq</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 284907671,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1654276726
    },
    {
        "content": "<p>Calling <code>simp</code> performs some kind of state-space search. Why would I tell the computer to perform the search every time it rebuilds my project if I can explicitly say what three substitutions lead to the desired state?</p>",
        "id": 284908501,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654277144
    },
    {
        "content": "<p>BTW, I don't like calling <code>repeat</code> for something that I want to do exactly twice. What is your preference?</p>",
        "id": 284908707,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654277232
    },
    {
        "content": "<p>Regarding your state-space search, it would be interesting to measure the time difference.  After all, <code>rw</code> also looks around the expression to find locations to perform the rewrite.  I wonder which one is faster.  It might depend on the expression itself...</p>",
        "id": 284908900,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1654277335
    },
    {
        "content": "<p>I have certainly observed <code>simp</code> producing shorter proof terms than the corresponding chain of rewrites, but not always.</p>",
        "id": 284909124,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1654277437
    },
    {
        "content": "<p>I like to use <code>simp</code> together with <code>have</code> or <code>convert</code> but not in the middle of my proof.</p>",
        "id": 284909298,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654277514
    },
    {
        "content": "<p>I know that <code>simp only</code> is pretty safe to use, but I still don't like it in non-terminal positions.</p>",
        "id": 284909426,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654277563
    },
    {
        "content": "<p>I'm also wary of non-terminal simps, so I understand your concern.</p>",
        "id": 284909459,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1654277578
    },
    {
        "content": "<p>In general, I prefer to use <code>simp</code> less often. Also my friends make fun of me: \"Look, Martin is simping for math again!\"</p>",
        "id": 284909644,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654277662
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113489-new-members/topic/Code.20smell.3F/near/284908501\">said</a>:</p>\n<blockquote>\n<p>Calling <code>simp</code> performs some kind of state-space search.</p>\n</blockquote>\n<p>How much work do you think it's doing here? It might be called \"simp\" but that doesn't mean it's looking for the simplest representation (unless the <code>simp</code> lemmas you provide cause it to enter rewrite cycles, like with <code>add_assoc</code> and <code>add_comm</code> together)</p>",
        "id": 284909914,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1654277794
    },
    {
        "content": "<p>simp only is not calling any lemmas other than the ones you provide. It still does things that rw doesn't, like beta reduction</p>",
        "id": 284910003,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1654277848
    },
    {
        "content": "<p>If you don't like <code>repeat</code>, then try <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#iterate\">tactic#iterate</a> or </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">set.mem_set_of_eq</span><span class=\"o\">,</span> <span class=\"n\">set.mem_set_of_eq</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"n\">set.mem_set_of_eq</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 284910015,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1654277855
    },
    {
        "content": "<p>If you’re doing something to be PRed to mathlib then the preference is (other things being equal) for shorter solutions. So if <code>simp only</code> does the job, your personal preference for a more verbose spelling likely won’t make it through review. Of course, this isn’t an issue if you’re just writing for your own projects.</p>",
        "id": 284924791,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1654285504
    },
    {
        "content": "<p>Yes, it is a project that only I write.</p>",
        "id": 284927156,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654286952
    },
    {
        "content": "<p>Is there a more idiomatic way how to write <code>clear_except,</code> to delete everything but the goal?</p>",
        "id": 285023237,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1654414541
    },
    {
        "content": "<p>Is there a shortcut for the following construction?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">sublemma</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">...</span><span class=\"o\">),</span>\n<span class=\"o\">{</span>\n  <span class=\"o\">(</span><span class=\"bp\">...</span><span class=\"o\">)</span>\n<span class=\"o\">},</span>\n<span class=\"n\">cases</span> <span class=\"n\">sublemma</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>I repeat lines like the above very often.</p>",
        "id": 286932985,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1655826058
    },
    {
        "content": "<p>I think <code>obtain</code> is meant to be the shortcut for <code>have</code> + <code>cases</code> -- i.e. <code>obtain \\&lt;x, hx\\&gt; := stuffinyourproof</code>, with or without the explicit type if necessary</p>",
        "id": 286933610,
        "sender_full_name": "Julian Berman",
        "timestamp": 1655826274
    },
    {
        "content": "<p>I can't remember whether <code>obtain</code> suuports the <code>,</code> syntax instead of <code>:= { ... }</code> specifically, but otherwise yes</p>",
        "id": 286933736,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655826322
    },
    {
        "content": "<p>it does</p>",
        "id": 286935022,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655826793
    },
    {
        "content": "<p>you have to give the type if you want to pattern match though, <code>obtain \\&lt;x, y\\&gt;,</code> doesn't work</p>",
        "id": 286935082,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655826818
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Code.20smell.3F/near/286935082\">said</a>:</p>\n<blockquote>\n<p>you have to give the type if you want to pattern match though, <code>obtain \\&lt;x, y\\&gt;,</code> doesn't work</p>\n</blockquote>\n<p>I assume that's because the notation is ambiguous when you have nested constructors?</p>",
        "id": 286951332,
        "sender_full_name": "Bart Michels",
        "timestamp": 1655834029
    },
    {
        "content": "<p>Like  if you want to <code>obtain \\&lt;x, y, z\\&gt;</code> of type <code>(p \\and q) \\and (r \\and s)</code>.</p>",
        "id": 286951795,
        "sender_full_name": "Bart Michels",
        "timestamp": 1655834255
    },
    {
        "content": "<p>No, it's always right associative in that sense. It's because it is ambiguous what we are destructing: it could be <code>Exists.rec</code> or <code>and.rec</code> or <code>nat.rec</code></p>",
        "id": 286952919,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655834734
    },
    {
        "content": "<p>you can't pattern match on something of unknown type: <code>obtain &lt;x, y&gt; := _</code> is an error</p>",
        "id": 286953117,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655834806
    },
    {
        "content": "<p>I'm not sure if I don't get it or if I am thinking the same. Say I <code>have</code> something of type <code>(∃ n : ℕ, p n) ∧ (∃ n : ℕ, q n)</code>. How is this different from <code>((p ∧ q) ∧ r) ∧ ((s ∧ t) ∧ u)</code> (except for the fact that the <code>n</code>s can be further destructed) ?</p>",
        "id": 286955440,
        "sender_full_name": "Bart Michels",
        "timestamp": 1655835843
    },
    {
        "content": "<p>you can't use <code>exists.rec</code> to destruct an element of the second type</p>",
        "id": 286955515,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655835883
    },
    {
        "content": "<p>I mean, I agree that it's ambiguous, I am just surprised that you (seem to) say that it's not for something like <code>(p ∧ q) ∧ (s ∧ t)</code></p>",
        "id": 286955522,
        "sender_full_name": "Bart Michels",
        "timestamp": 1655835891
    },
    {
        "content": "<p>the tactic has to decide what theorem to apply, and it needs the type to do that</p>",
        "id": 286955555,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655835910
    },
    {
        "content": "<p>the brackets can be nested in different ways if you want to destruct stuff like <code>(p ∧ q) ∧ (s ∧ t)</code></p>",
        "id": 286955616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655835950
    },
    {
        "content": "<p>you would need to use <code>&lt;&lt;hp, hq&gt;, &lt;hs, ht&gt;&gt;</code> to match that</p>",
        "id": 286955689,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655835970
    },
    {
        "content": "<p>obtain doesn't try to be smart about associativity if you don't write the brackets correctly</p>",
        "id": 286955768,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655836014
    },
    {
        "content": "<p>you can also use <code>&lt;&lt;hp, hq&gt;, hs, ht&gt;</code> in that case but that's just because the angle brackets are always interpreted as right associative</p>",
        "id": 286955848,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655836059
    },
    {
        "content": "<p><code>&lt;hp, hq, &lt;hs, ht&gt;&gt;</code> would not work</p>",
        "id": 286955882,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655836079
    },
    {
        "content": "<p>But then I don't see why lean wouldn't know what to destruct. Can it not just look at the top-most symbol?</p>",
        "id": 286956267,
        "sender_full_name": "Bart Michels",
        "timestamp": 1655836279
    },
    {
        "content": "<p>When you say \"It's because it is ambiguous what we are destructing:\"</p>",
        "id": 286956276,
        "sender_full_name": "Bart Michels",
        "timestamp": 1655836286
    },
    {
        "content": "<p>because the top most symbol is <code>?m_1</code></p>",
        "id": 286956548,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655836426
    },
    {
        "content": "<p>if the type is not known</p>",
        "id": 286956557,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655836431
    },
    {
        "content": "<p>if you write <code>obtain &lt;x, y&gt;,</code> with literally no other information, how can it tell what you want to destruct?</p>",
        "id": 286956637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655836458
    },
    {
        "content": "<p>you can use <code>obtain &lt;x, y&gt; : \\exists n, P n,</code> or <code>obtain &lt;x, y&gt; := h</code>, both of which provide a way to get the type</p>",
        "id": 286956725,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655836502
    },
    {
        "content": "<p>Right, thanks. I was assuming that lean would derive the type from the <code>{}</code> block that follows.</p>",
        "id": 286956782,
        "sender_full_name": "Bart Michels",
        "timestamp": 1655836540
    },
    {
        "content": "<p>it can't use types from the future because after the <code>,</code> the tactic runs and it has to transition the tactic state to something such that the <code>{}</code> block will do something useful</p>",
        "id": 286956876,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655836582
    },
    {
        "content": "<p>Got it, makes a lot of sense.</p>",
        "id": 286956932,
        "sender_full_name": "Bart Michels",
        "timestamp": 1655836629
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 286956962,
        "sender_full_name": "Bart Michels",
        "timestamp": 1655836648
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113489-new-members/topic/Code.20smell.3F/near/285023237\">said</a>:</p>\n<blockquote>\n<p>Is there a more idiomatic way how to write <code>clear_except,</code> to delete everything but the goal?</p>\n</blockquote>\n<p>I encountered it again. Is there any idiomatic way to write it? I kinda wanna signpost that I will show that the goal is tautological.</p>",
        "id": 290901768,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1658845784
    },
    {
        "content": "<p>What should I do instead of the following two lines?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">my_inequality_</span> <span class=\"o\">:=</span> <span class=\"n\">my_inequality</span><span class=\"o\">,</span>\n<span class=\"n\">tauto</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>I want to \"load\" an existing private lemma into a local context in order to discharge the goal by <code>tauto</code> with its help?</p>",
        "id": 296065390,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1661851742
    },
    {
        "content": "<p>Seems fine to me</p>",
        "id": 296079342,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1661857941
    },
    {
        "content": "<p>I'd rather do something like <code>tauto [my_inequality]</code> or perform <code>tauto</code> with <code>library_search</code> at the same time.<br>\nOr, is there a way to do what I did without needing to name the proposition again?</p>",
        "id": 296084479,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1661860247
    },
    {
        "content": "<p>You can use <code>have := xxx</code> which will call the local assumption <code>this</code></p>",
        "id": 296084626,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1661860317
    },
    {
        "content": "<p>Is it idiomatic in Lean? I guess it is OK when I write <code>have := my_inequality,</code> on the penultimate line of the block (followed by a tactic that does not obtain <code>this</code> as an explicit argument).</p>",
        "id": 296085066,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1661860517
    },
    {
        "content": "<p>Using <code>this</code> is fairly idiomatic, and some tactics like <code>simpa using</code> have special support for it even</p>",
        "id": 296100847,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1661865859
    },
    {
        "content": "<p>In my proofs, my block often ends with something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">almost_there</span> <span class=\"o\">:=</span> <span class=\"n\">some_lemma</span> <span class=\"n\">some_parameter</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">some_transformation</span><span class=\"o\">,</span> <span class=\"n\">other_transformation</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">almost_there</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">almost_there</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>Is there a better way to write it?</p>",
        "id": 300342426,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1663933112
    },
    {
        "content": "<p><code>rwa</code> :)</p>",
        "id": 300342564,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1663933170
    },
    {
        "content": "<p>The line <code>have almost_there := some_lemma some_parameter,</code> has to stay, I guess.</p>",
        "id": 300342758,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1663933234
    },
    {
        "content": "<p><code>simpa only [some_transformation, other_transformation] using some_lemma some_parameter</code> might or might not work in your situation.</p>",
        "id": 300342844,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1663933278
    },
    {
        "content": "<p>Is there any reason <code>rwa [] using _</code> is not supported syntax?</p>",
        "id": 300342924,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1663933313
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/113489-new-members/topic/Code.20smell.3F/near/300342564\">said</a>:</p>\n<blockquote>\n<p><code>rwa</code> :)</p>\n</blockquote>\n<p>Isn't it a bit slower? I'd rather have it call <code>exact</code> [right side of <code>rwa</code>] than to walk through the local context.</p>",
        "id": 300343473,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1663933514
    },
    {
        "content": "<p>It's almost no difference, given that you will typically have less &lt; 50 assumptions in context. And note that this is also (slightly) cheaper in tactic parsing.</p>",
        "id": 300344672,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1663933972
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/Code.20smell.3F/near/300342924\">said</a>:</p>\n<blockquote>\n<p>Is there any reason <code>rwa [] using _</code> is not supported syntax?</p>\n</blockquote>\n<p>Ooh this would be really nice</p>",
        "id": 300347609,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1663935003
    },
    {
        "content": "<p>Is it bad practice to reuse argument names between different functions / lemmata and have <code>x</code> of different type in different parts of your code?</p>",
        "id": 304665750,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1666095422
    },
    {
        "content": "<p>Not necessarily. But having multiple <code>x</code>s` at the same time will be confusing.</p>",
        "id": 304666115,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1666095547
    },
    {
        "content": "<p>What about <code>dsimp only [],</code> in the middle of a proof?</p>",
        "id": 307546804,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1667401784
    },
    {
        "content": "<p>Those are fine according to mathlib standards.</p>\n<p>A small golf: <code>dsimp only</code> does the same thing as <code>dsimp only []</code></p>",
        "id": 307547313,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667401891
    },
    {
        "content": "<p>One of the reasons <code>dsimp only</code> appears is that it's able to do a number of reductions that are necessary for further rewrites.</p>",
        "id": 307547717,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667401981
    },
    {
        "content": "<p>Even <code>dsimp</code> is allowed, because theoretically it transforms something into something definitionally equivalent, so it's not so bad fixing things if the simp set changes. (I usually still go for <code>dsimp only [whatever the lemmas]</code> when possible)</p>",
        "id": 307548085,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667402072
    },
    {
        "content": "<p>But, once you're done with a proof, it's worth checking if there are any <code>dsimp</code>s (or <code>unfold</code>s) that you can remove. It can be surprising what's not necessary.</p>",
        "id": 307548263,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1667402117
    },
    {
        "content": "<p>I usually realize that <code>dsimp</code> and <code>unfold</code> cannot be removed.</p>",
        "id": 307548514,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1667402176
    },
    {
        "content": "<p>Is there a way how to replace the following two lines by a single command?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">is_it_in</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"mi\">42</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"n\">hyp</span><span class=\"o\">,</span>\n<span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"n\">at</span> <span class=\"n\">is_it_in</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>I wish there was a way to write the <code>congr_arg</code> expression in a way that will not require the beta reduction immediately after it.</p>",
        "id": 310600813,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1668688595
    },
    {
        "content": "<p>You could use <code>have is_it_in : 42 \\in a = 42 \\in b := congr_arg ..</code> (if I remembered <code>congr_arg</code> correctly)</p>",
        "id": 310601604,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1668688894
    },
    {
        "content": "<p>That's a bit too verbose but thanks.</p>",
        "id": 310602572,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1668689244
    },
    {
        "content": "<p>Oh, or maybe even <code>have is_it_in : _ \\in _ = _ \\in _ := ...</code></p>",
        "id": 310603071,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1668689425
    },
    {
        "content": "<p>You could use <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#dsimp_result\">tactic#dsimp_result</a>, for this example its still a bit verbose but it might be helpful in other cases</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.basic</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hyp</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">is_it_in</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">dsimp_result</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"mi\">42</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"n\">hyp</span><span class=\"o\">}</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 310603528,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1668689624
    },
    {
        "content": "<p>Ext lemmas are good for these too</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">set.ext_iff.mp</span> <span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">this</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 310604002,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668689836
    },
    {
        "content": "<p>For submodules you can for example use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set_like.ext_iff\">docs#set_like.ext_iff</a> since they tend to use the <code>set_like</code> interface</p>",
        "id": 310604087,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668689877
    },
    {
        "content": "<p>I have the following block, which totally looks like a code smell, on six places in my code.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">exfalso</span><span class=\"o\">,</span>\n<span class=\"o\">(</span><span class=\"bp\">...</span><span class=\"o\">)</span>\n<span class=\"n\">apply</span> <span class=\"n\">false_of_true_eq_false</span><span class=\"o\">,</span>\n<span class=\"n\">convert</span> <span class=\"n\">my_hyp.symm</span><span class=\"o\">,</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq_iff_iff</span><span class=\"o\">,</span> <span class=\"n\">true_iff</span><span class=\"o\">],</span>\n  <span class=\"o\">(</span><span class=\"bp\">...</span><span class=\"o\">)</span>\n<span class=\"o\">},</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq_iff_iff</span><span class=\"o\">,</span> <span class=\"n\">false_iff</span><span class=\"o\">],</span>\n  <span class=\"o\">(</span><span class=\"bp\">...</span><span class=\"o\">)</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>Is there a better way to write the same thing without significantly changing the decomposition?</p>",
        "id": 312160405,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1669373937
    },
    {
        "content": "<p>If I read this right, the situation is that <code>my_hyp : p = q</code>, and you have a proof of <code>p</code> and a proof of <code>¬ q</code>? I'd probably structure this as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">q</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"bp\">...</span> <span class=\"o\">},</span>\n<span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">this</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">my_hyp</span><span class=\"o\">,</span>\n<span class=\"c1\">-- Now prove `p`</span>\n<span class=\"o\">{</span> <span class=\"bp\">...</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 312163926,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1669375177
    },
    {
        "content": "<p>Another option might be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n<span class=\"o\">{</span> <span class=\"bp\">...</span> <span class=\"o\">},</span>\n<span class=\"k\">have</span> <span class=\"n\">hnq</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n<span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">my_hyp</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- Now prove `¬ q`</span>\n  <span class=\"bp\">...</span> <span class=\"o\">},</span>\n<span class=\"n\">contradiction</span>\n</code></pre></div>",
        "id": 312164156,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1669375241
    },
    {
        "content": "<p>Oh yes, thanks!<br>\nIs there also a way that doesn't require me to restate <code>p</code> and/or <code>q</code>?</p>",
        "id": 312164932,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1669375495
    },
    {
        "content": "<p>Motivation: I often work with propositions that take more than 100 characters to state. And I don't like boilerplate in my code.</p>",
        "id": 312165159,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1669375563
    },
    {
        "content": "<p>The best I can figure out is the rather cryptic <code>(mt (eq.mp my_hyp) _ _).elim</code></p>",
        "id": 312167532,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1669376355
    },
    {
        "content": "<p>Or I guess <code>absurd (eq.mp my_hyp _) _</code>?</p>",
        "id": 312167724,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1669376415
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113489-new-members/topic/Code.20smell.3F/near/312165159\">said</a>:</p>\n<blockquote>\n<p>Motivation: I often work with propositions that take more than 100 characters to state</p>\n</blockquote>\n<p>Some people would claim that this is the code smell</p>",
        "id": 312249015,
        "sender_full_name": "Reid Barton",
        "timestamp": 1669405338
    },
    {
        "content": "<p>A bit late but this directly gives what you wanted:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.basic</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hyp</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"o\">((</span><span class=\"bp\">∈</span><span class=\"o\">)</span> <span class=\"mi\">42</span><span class=\"o\">)</span> <span class=\"n\">hyp</span><span class=\"o\">,</span> <span class=\"c\">/-</span><span class=\"cm\"> this: 42 ∈ a = (42 ∈ b) -/</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 312287510,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1669432299
    }
]
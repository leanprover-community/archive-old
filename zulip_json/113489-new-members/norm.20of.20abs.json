[
    {
        "content": "<p>The first lemma is easily proved. The second should follow trivially, but Lean will not accept my proof - it says </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rewrite</span> <span class=\"n\">tactic</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">did</span> <span class=\"n\">not</span> <span class=\"n\">find</span> <span class=\"kd\">instance</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">pattern</span> <span class=\"k\">in</span> <span class=\"n\">the</span> <span class=\"n\">target</span> <span class=\"n\">expression</span>\n  <span class=\"n\">max</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>what am I doing wrong please?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.ordered</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_add_comm_group</span> <span class=\"n\">β</span><span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">norm_max_eq_norm</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∥</span><span class=\"n\">max</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">∥</span> <span class=\"bp\">=</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">le_total</span>  <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">b</span><span class=\"o\">)</span>  <span class=\"k\">with</span> <span class=\"n\">bn</span> <span class=\"n\">bp</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">max_eq_right</span> <span class=\"n\">bn</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">max_eq_left</span> <span class=\"n\">bp</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">norm_abs_eq_norm</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∥</span><span class=\"n\">abs</span> <span class=\"n\">b</span> <span class=\"bp\">∥</span> <span class=\"bp\">=</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">abs</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">le_total</span>  <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">b</span><span class=\"o\">)</span>  <span class=\"k\">with</span> <span class=\"n\">bn</span> <span class=\"n\">bp</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">max_eq_right</span> <span class=\"n\">bn</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">max_eq_left</span> <span class=\"n\">bp</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Thanks,</p>\n<p>Christopher</p>",
        "id": 226065147,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1613081270
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">norm_abs_eq_norm</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∥</span><span class=\"n\">abs</span> <span class=\"n\">b</span> <span class=\"bp\">∥</span> <span class=\"bp\">=</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">abs</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">le_total</span>  <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">b</span><span class=\"o\">)</span>  <span class=\"k\">with</span> <span class=\"n\">bn</span> <span class=\"n\">bp</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">norm_max_eq_norm</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n    <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">    linear_ordered_add_comm_group.to_add_comm_group β = normed_group.to_add_comm_group</span>\n<span class=\"cm\">    -/</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span><span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>When you write <code>[linear_ordered_add_comm_group β]</code> Lean puts the structure of a linear ordered additive group on beta; when you write <code>[normed_group β]</code> it puts a totally different structure of a normed additive group on beta. They might have different 0's, different additions etc. The goal after <code>convert</code> is the statement that the two group structures coincide -- the way you have set things up, they don't.</p>",
        "id": 226065634,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613081542
    },
    {
        "content": "<p>Unfortunately, <code>normed_group</code> is defined in <code>analysis.normed_space.basic</code> and this file does not have the magic words <code>set_option old_structure_cmd true</code> in it, so I do not know how to fix this.</p>",
        "id": 226067163,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613082300
    },
    {
        "content": "<p>Okay, thanks, that makes sense. So I can add that as an additional hypothesis and it works.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">norm_abs_eq_norm</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">linear_ordered_add_comm_group.to_add_comm_group</span> <span class=\"n\">β</span> <span class=\"bp\">=</span> <span class=\"n\">normed_group.to_add_comm_group</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∥</span><span class=\"n\">abs</span> <span class=\"n\">b</span> <span class=\"bp\">∥</span> <span class=\"bp\">=</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">abs</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"n\">norm_max_eq_norm</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 226067187,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1613082312
    },
    {
        "content": "<p>You can, but this solution will not scale. Type class inference expects there to be only one (at most) structure of add_comm_group on a type, up to definitional equality. Your solution will hence be a nightmare to use. What is even more worrying is that adding <code>set_option old_structure_cmd true</code> to <code>analysis.normed_space.basic</code> makes Lean segfault, a rather rare occurrence nowadays.</p>",
        "id": 226067485,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613082481
    },
    {
        "content": "<p>It works in the case that  β is ℝ.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.ordered</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_add_comm_group</span> <span class=\"n\">β</span><span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">norm_max_eq_norm</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∥</span><span class=\"n\">max</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">∥</span> <span class=\"bp\">=</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">le_total</span>  <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">b</span><span class=\"o\">)</span>  <span class=\"k\">with</span> <span class=\"n\">bn</span> <span class=\"n\">bp</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">max_eq_right</span> <span class=\"n\">bn</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">max_eq_left</span> <span class=\"n\">bp</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">norm_abs_eq_norm</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∥</span><span class=\"n\">abs</span> <span class=\"n\">b</span> <span class=\"bp\">∥</span> <span class=\"bp\">=</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">abs</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">norm_max_eq_norm</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 226067876,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1613082723
    },
    {
        "content": "<p>What sort of mathematical object are you trying to model by assuming a normed group whose order is linear?</p>",
        "id": 226067938,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1613082749
    },
    {
        "content": "<p>That's because the reals have been given a compatible normed group and linear ordered group structure.</p>",
        "id": 226067941,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613082752
    },
    {
        "content": "<p>Alex that's a fair question, but another fair question is whether it is possible to make such a structure in mathlib.</p>",
        "id": 226068031,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613082801
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> - I've proved that the continuous bounded real-valued functions on a topological space form a lattice under the natural ordering - I was just trying to see if the result still held if I replaced ℝ with a more abstract structure.</p>",
        "id": 226068539,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1613083120
    },
    {
        "content": "<p>See <a href=\"#narrow/stream/113488-general/topic/old.20structure.20command.20segfault/near/226068687\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/old.20structure.20command.20segfault/near/226068687</a> . I might well be missing an obvious way to do this.</p>",
        "id": 226068957,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613083357
    },
    {
        "content": "<p>You can define the class you want like this :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.ordered</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">linear_normed_group</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">linear_order</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">normed_group</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_le_add_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">a</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">linear_normed_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">linear_ordered_add_comm_group</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"bp\">..</span><span class=\"n\">h</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 226068973,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1613083369
    },
    {
        "content": "<p>This solution doesn't scale, but I agree that right now it seems like the best way to do it.</p>",
        "id": 226069072,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613083432
    },
    {
        "content": "<p>Why doesn't it scale?</p>",
        "id": 226069136,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1613083453
    },
    {
        "content": "<p>I mean, you had to add a random axiom when we have a perfectly good class (<code>linear_ordered_add_comm_group</code>) which already contained that axiom. What if it had been a normed locally ringed add_comm_topos or something?</p>",
        "id": 226069254,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613083541
    },
    {
        "content": "<p>But I've made an instance of the original class so, while there was a little bit of copy pasting to set this up it should be now invisible to the user that it was set up this way instead of the old structure command way.</p>",
        "id": 226069475,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1613083660
    },
    {
        "content": "<p>I think Leo's suggestion was that if mathlib users want to write automation in lean 4 to not have to do the copy-pasting of the axioms by hand (and therefore not break as much if someone renames one?) that should be doable.</p>",
        "id": 226069592,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1613083719
    },
    {
        "content": "<p>Fair enough, I was just envisaging a situation where you had to add a gazillion axioms but I agree it's just the structure def.</p>",
        "id": 226069604,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613083723
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"373192\">@Christopher Hoskin</span> if you add the lines</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">linear_normed_group</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">linear_order</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">normed_group</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_le_add_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">a</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">linear_normed_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">linear_ordered_add_comm_group</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"bp\">..</span><span class=\"n\">h</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>to the top of your file you should be able to replace</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_add_comm_group</span> <span class=\"n\">β</span><span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_normed_group</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>and hopefully everything should work!</p>",
        "id": 226070295,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1613084115
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/113489-new-members/topic/norm.20of.20abs/near/226067938\">said</a>:</p>\n<blockquote>\n<p>What sort of mathematical object are you trying to model by assuming a normed group whose order is linear?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> , <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  Thanks for your help. Sorry for the delay in replying, but I've been considering this question, and I think the right sort object to model for this problem is a normed lattice ordered group (like a Riesz space, but without real-valued scalar multiplication or completeness of the norm. I've defined a lattice ordered group as follows (c.f. L. Fuchs, \"Partially ordered algebraic systems\" Chapter V):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">has_abs</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`|`</span><span class=\"n\">a</span><span class=\"bp\">`|`</span> <span class=\"o\">:=</span> <span class=\"n\">has_abs.abs</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">lattice_add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"kd\">extends</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">lattice</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_le_add_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">lattice_add_comm_group_has_abs</span> <span class=\"o\">[</span><span class=\"n\">lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_abs</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"bp\">⊔-</span><span class=\"n\">a</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>I made <code>has_abs</code> a class, as there are other structures which have a notion of absolute value (e.g. certain GM-spaces  and GL-spaces).</p>\n<p>I've then proved a number of results including</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">abs_abs_eq_abs</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"bp\">|</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">|</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(proof omitted for brevity - the absence of scalar multiplication by 1/2 introduces some subtleties!)</p>\n<p>Then for the normed lattice ordered group,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"kd\">extends</span> <span class=\"n\">normed_group</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">lattice</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_abs</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_le_add_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">solid</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">≤</span> <span class=\"bp\">|</span><span class=\"n\">b</span><span class=\"bp\">|</span> <span class=\"bp\">→</span> <span class=\"bp\">∥</span><span class=\"n\">a</span><span class=\"bp\">∥</span> <span class=\"bp\">≤</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"n\">a</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">lattice_add_comm_group</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"bp\">..</span><span class=\"n\">h</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Mostly, this seems to do what I want:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"bp\">|</span><span class=\"n\">d</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"n\">d</span><span class=\"bp\">⊔</span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">has_abs.abs</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test2</span> <span class=\"o\">:</span> <span class=\"bp\">|</span><span class=\"n\">d</span><span class=\"bp\">|</span> <span class=\"bp\">=|</span> <span class=\"bp\">|</span><span class=\"n\">d</span><span class=\"bp\">|</span> <span class=\"bp\">|</span>   <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">abs_abs_eq_abs</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>However, it goes a bit wrong when I try to prove:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">max_abs_eq_norm</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∥|</span> <span class=\"n\">b</span> <span class=\"bp\">|∥</span> <span class=\"bp\">=</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">le_antisymm_iff</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">apply</span> <span class=\"n\">normed_lattice_add_comm_group.solid</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">abs_abs_eq_abs</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">apply</span> <span class=\"n\">normed_lattice_add_comm_group.solid</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">abs_abs_eq_abs</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Perhaps I am missing a coercion?</p>\n<p>Christopher</p>",
        "id": 226738816,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1613601410
    },
    {
        "content": "<p>I can't manage to put your posts together into one file -- I am getting errors with abses. Can you just post one <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ? Just to be clear -- I'm saying that I can't set things up so I can see the problem you are seeing. Thanks. PS your proof of <code>test</code> should probably be <code>refl</code>.</p>",
        "id": 226746315,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613606146
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/norm.20of.20abs/near/226746315\">said</a>:</p>\n<blockquote>\n<p>I can't manage to put your posts together into one file -- I am getting errors with abses. Can you just post one <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ? Just to be clear -- I'm saying that I can't set things up so I can see the problem you are seeing. Thanks. PS your proof of <code>test</code> should probably be <code>refl</code>.</p>\n</blockquote>\n<p>Thanks for your help. Here is a mwe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.ordered_group</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.basic</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- Notation class for absolute value of an element</span>\n<span class=\"kd\">class</span> <span class=\"n\">has_abs</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Write |a| for the absolute value of a</span>\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`|`</span><span class=\"n\">a</span><span class=\"bp\">`|`</span> <span class=\"o\">:=</span> <span class=\"n\">has_abs.abs</span> <span class=\"n\">a</span>\n\n<span class=\"c1\">-- Define a lattice ordered group</span>\n<span class=\"kd\">class</span> <span class=\"n\">lattice_add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"kd\">extends</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">lattice</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_le_add_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Define the absolute value of an element of a lattice ordered group</span>\n<span class=\"kd\">instance</span> <span class=\"n\">lattice_add_comm_group.to_has_abs</span> <span class=\"o\">[</span><span class=\"n\">lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_abs</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"bp\">⊔-</span><span class=\"n\">a</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- Every lattice additive commutative group is also an ordered additive commutative group</span>\n<span class=\"kd\">instance</span> <span class=\"n\">lattice_add_comm_group.to_ordered_add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ordered_add_comm_group</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">s.add</span><span class=\"o\">,</span> <span class=\"bp\">..</span><span class=\"n\">s</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- Absolute value is idempotent</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">abs_idempotent</span> <span class=\"o\">[</span><span class=\"n\">lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">|</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- Define a normed lattice ordered group</span>\n<span class=\"kd\">class</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"kd\">extends</span> <span class=\"n\">normed_group</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">lattice</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_abs</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_le_add_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">solid</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">≤</span> <span class=\"bp\">|</span><span class=\"n\">b</span><span class=\"bp\">|</span> <span class=\"bp\">→</span> <span class=\"bp\">∥</span><span class=\"n\">a</span><span class=\"bp\">∥</span> <span class=\"bp\">≤</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Every normed lattice ordered group is a lattice ordered group</span>\n<span class=\"kd\">instance</span> <span class=\"n\">a</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">lattice_add_comm_group</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"bp\">..</span><span class=\"n\">h</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- Let β be a normed lattice ordered group</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Lean can infer the definition of the absolute value</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">|</span><span class=\"n\">b</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"bp\">⊔</span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- Lean knows that abs_idempotent holds for normed lattice ordered group</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">test2</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">|</span> <span class=\"bp\">|</span><span class=\"n\">d</span><span class=\"bp\">|</span> <span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"bp\">|</span><span class=\"n\">d</span><span class=\"bp\">|</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">abs_idempotent</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">But `rw` fails here with:</span>\n\n<span class=\"cm\">rewrite tactic failed, did not find instance of the pattern in the target expression</span>\n<span class=\"cm\">  | |b| |</span>\n<span class=\"cm\">state:</span>\n<span class=\"cm\">β : Type u,</span>\n<span class=\"cm\">_inst_1 : normed_lattice_add_comm_group β,</span>\n<span class=\"cm\">b : β</span>\n<span class=\"cm\">⊢ | |b| | ≤ |b|</span>\n\n<span class=\"cm\">Or, with set_option pp.all true</span>\n\n<span class=\"cm\">rewrite tactic failed, did not find instance of the pattern in the target expression</span>\n<span class=\"cm\">  @has_abs.abs.{u} β (@lattice_add_comm_group.to_has_abs.{u} β (@a.{u} β _inst_1))</span>\n<span class=\"cm\">    (@has_abs.abs.{u} β (@lattice_add_comm_group.to_has_abs.{u} β (@a.{u} β _inst_1)) b)</span>\n<span class=\"cm\">state:</span>\n<span class=\"cm\">β : Type u,</span>\n<span class=\"cm\">_inst_1 : normed_lattice_add_comm_group.{u} β,</span>\n<span class=\"cm\">b : β</span>\n<span class=\"cm\">⊢ @has_le.le.{u} β</span>\n<span class=\"cm\">    (@preorder.to_has_le.{u} β</span>\n<span class=\"cm\">       (@partial_order.to_preorder.{u} β</span>\n<span class=\"cm\">          (@semilattice_inf.to_partial_order.{u} β</span>\n<span class=\"cm\">             (@lattice.to_semilattice_inf.{u} β (@normed_lattice_add_comm_group.to_lattice.{u} β _inst_1)))))</span>\n<span class=\"cm\">    (@has_abs.abs.{u} β (@normed_lattice_add_comm_group.to_has_abs.{u} β _inst_1)</span>\n<span class=\"cm\">       (@has_abs.abs.{u} β (@lattice_add_comm_group.to_has_abs.{u} β (@a.{u} β _inst_1)) b))</span>\n<span class=\"cm\">    (@has_abs.abs.{u} β (@normed_lattice_add_comm_group.to_has_abs.{u} β _inst_1) b)</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">norm_abs_eq_norm</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∥|</span> <span class=\"n\">b</span> <span class=\"bp\">|∥</span> <span class=\"bp\">=</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">le_antisymm_iff</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">apply</span> <span class=\"n\">normed_lattice_add_comm_group.solid</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">abs_idempotent</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">apply</span> <span class=\"n\">normed_lattice_add_comm_group.solid</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">abs_idempotent</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Not sure if it is better to introduce the absolute value as I have done here, or to have <code>lattice_add_comm_group</code> extend <code>has_abs</code> and introduce it that way?</p>\n<p>Christopher</p>",
        "id": 226771421,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1613630981
    },
    {
        "content": "<p>Changing <code>normed_lattice_add_comm_group</code> to extend <code>lattice_add_comm_group</code> may help</p>",
        "id": 226775633,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613635093
    },
    {
        "content": "<p>As might <code>set_option old_structure_cmd true</code></p>",
        "id": 226775661,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613635123
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"n\">apply</span> <span class=\"n\">normed_lattice_add_comm_group.solid</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">le_of_eq</span><span class=\"o\">,</span>\n    <span class=\"n\">convert</span> <span class=\"n\">abs_idempotent</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- ⊢ normed_lattice_add_comm_group.to_has_abs = lattice_add_comm_group.to_has_abs</span>\n</code></pre></div>",
        "id": 226787550,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613642481
    },
    {
        "content": "<p>Your <code>normed_lattice_add_comm_group</code> takes something with a normed group structure, a lattice structure, and an abs structure which might be completely unrelated to these other two structures, puts a second <code>abs</code> on it coming from the normed group and lattice structure, and then is complaining (correctly) that these two abs structures are unrelated to each other.</p>",
        "id": 226788248,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613642866
    },
    {
        "content": "<p>Yes, that makes sense - I was thrown off guard by the <code>test</code> and <code>test2</code> lemmas holding. I guess they work because Lean can cast everything to <code>lattice_add_comm_group</code> whereas in the <code>norm_abs_eq_norm</code> lemma the <code>solid</code> axiom is stated before Lean knows that <code>normed_lattice_add_comm_group</code> is an instance of <code>lattice_add_comm_group</code>?</p>\n<p>One way of working around this appears to be the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Define a normed lattice ordered group</span>\n<span class=\"kd\">class</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"kd\">extends</span> <span class=\"n\">normed_group</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">lattice</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_le_add_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">solid'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"bp\">⊔-</span><span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"bp\">⊔-</span><span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"bp\">∥</span><span class=\"n\">a</span><span class=\"bp\">∥</span> <span class=\"bp\">≤</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Every normed lattice ordered group is a lattice ordered group</span>\n<span class=\"kd\">instance</span> <span class=\"n\">a</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">lattice_add_comm_group</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"bp\">..</span><span class=\"n\">h</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">normed_lattice_add_comm_group.solid</span> <span class=\"o\">[</span><span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">≤</span> <span class=\"bp\">|</span><span class=\"n\">b</span><span class=\"bp\">|</span> <span class=\"bp\">→</span> <span class=\"bp\">∥</span><span class=\"n\">a</span><span class=\"bp\">∥</span> <span class=\"bp\">≤</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:=</span>\n  <span class=\"n\">normed_lattice_add_comm_group.solid'</span>\n</code></pre></div>\n<p>Unless I'm misunderstanding, I think <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> 's suggestion will get us back to my original problem of having two separate group structures defined with no relationship between them?</p>\n<p>I'm not yet sufficiently versed in classes to know if my solution is a sensible way of setting things up, but I can proceed with this approach and see how it goes, unless someone wants to make an alternative suggestion?</p>\n<p>Thanks again for your time,</p>\n<p>Christopher</p>",
        "id": 227016578,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1613763357
    },
    {
        "content": "<p>you want something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"kd\">extends</span> <span class=\"n\">normed_group</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">lattice_add_comm_group</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">solid'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"bp\">⊔-</span><span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"bp\">⊔-</span><span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"bp\">∥</span><span class=\"n\">a</span><span class=\"bp\">∥</span> <span class=\"bp\">≤</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 227018718,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613764251
    },
    {
        "content": "<p>The test examples work because Lean is choosing a random abs and happens to get the right one. If there are two instances of a class defined on a type then things get very unpredictable, I don't have much experience in knowing which one is used in various cases because if you have two instances of a class on a type then that's what needs to be fixed rather than persuading Lean to use one over the other. You have run into a genuine issue here and our current Lean 3 workaround isn't robust and is furthermore not going to work in Lean 4, so at some point somebody will write some machinery which makes all of this easier and you'll be able to do what you were doing initially, but unfortunately we're not there yet. I agree with Alex that this workaround where you extend disjoint fields and then add in the extra fields which you can't get because of clashes is right now the best way to proceed. The other approach would be to make normed_group an old structure but to be quite frank the Lean 4 porting people might tell us at some point to remove all old structure command shenannigans so I'm loathe to put any more in right now.</p>",
        "id": 227018727,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613764256
    }
]
[
    {
        "content": "<p>I'm running into a weird error message with Lean 4 that feels like it's being reported in the wrong place. </p>\n<p>I'm trying to write a function that is analogous to <code>List.enum</code> but is defined on Vectors (Lists of known length). I want to pass along the fact that the added indices are less than the length of the list. I've simplified the following example so that this function just pairs every element with 0. Here is the simplified implementation.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">l.length</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Vector.enum</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">Nat.decLt</span> <span class=\"mi\">0</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">l'</span> <span class=\"o\">:=</span> <span class=\"n\">l.val.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Fin.mk</span> <span class=\"mi\">0</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n    <span class=\"k\">let</span> <span class=\"n\">p'</span> <span class=\"o\">:</span> <span class=\"n\">List.length</span> <span class=\"n\">l'</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">induction</span> <span class=\"n\">l.property</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span>\n    <span class=\"o\">⟨</span> <span class=\"n\">l'</span><span class=\"o\">,</span> <span class=\"n\">p'</span> <span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"k\">have</span> <span class=\"n\">lprop</span> <span class=\"o\">:=</span> <span class=\"n\">l.property</span>\n      <span class=\"n\">simp_arith</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n      <span class=\"n\">subst</span> <span class=\"n\">n</span>\n      <span class=\"n\">rfl</span>\n    <span class=\"o\">⟨</span> <span class=\"o\">[],</span> <span class=\"n\">p</span> <span class=\"o\">⟩</span>\n</code></pre></div>\n<p>The language server is reporting the following error at the definition of the function <code>Vector.enum</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n   <span class=\"n\">l.val</span>\n <span class=\"n\">argument</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n   <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"bp\">✝</span>\n <span class=\"n\">but</span> <span class=\"n\">function</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n   <span class=\"o\">{</span> <span class=\"n\">l</span> <span class=\"bp\">//</span> <span class=\"n\">List.length</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>If I replace the <code>induction</code> in the <code>isTrue</code> branch with just <code>sorry</code>. Then this function is able to be defined (though obviously it yells at me that the function uses <code>sorry</code>.</p>\n<p>What is induction doing that causes this function not to type check? Why is the error message being reported at the function definition, rather than when I call <code>l.val</code>? Is there a way to make this proof go through without induction?</p>",
        "id": 316545732,
        "sender_full_name": "Samuel Thomas",
        "timestamp": 1671343270
    },
    {
        "content": "<p>I think you cannot do induction on <code>l.property</code> like this, because it would set <code>n</code> to <code>List.length l</code> but the type of <code>l</code> depends on <code>n</code>.</p>",
        "id": 316549937,
        "sender_full_name": "Reid Barton",
        "timestamp": 1671347794
    },
    {
        "content": "<p>This way works</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"k\">let</span> <span class=\"n\">p'</span> <span class=\"o\">:</span> <span class=\"n\">List.length</span> <span class=\"n\">l'</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">cases</span> <span class=\"n\">l</span>\n      <span class=\"n\">subst</span> <span class=\"n\">n</span>\n      <span class=\"n\">simp</span>\n    <span class=\"o\">⟨</span> <span class=\"n\">l'</span><span class=\"o\">,</span> <span class=\"n\">p'</span> <span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 316550107,
        "sender_full_name": "Reid Barton",
        "timestamp": 1671347967
    },
    {
        "content": "<p>Ah thank you. That makes sense and I can get the proof to go through now. Do you think that it's a bug that the error reporting is using the name of the function as the location of the error?</p>",
        "id": 316550704,
        "sender_full_name": "Samuel Thomas",
        "timestamp": 1671348576
    }
]
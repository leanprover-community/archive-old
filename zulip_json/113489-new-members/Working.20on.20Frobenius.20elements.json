[
    {
        "content": "<p>Hi, I am a PhD candidate at Radboud and currently planning to formalise Frobenius elements. Is there anyone else working on this already? Thank you.</p>",
        "id": 291021688,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1658922025
    },
    {
        "content": "<p>Frobenius elements of Galois groups, you mean?</p>",
        "id": 291021985,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1658922251
    },
    {
        "content": "<p>For finite or infinite extensions?</p>",
        "id": 291022001,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1658922270
    },
    {
        "content": "<p>Also: welcome!</p>",
        "id": 291022014,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1658922284
    },
    {
        "content": "<p>Thank you for the welcome.</p>\n<p>Yes, for finite extensions.</p>",
        "id": 291022179,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1658922419
    },
    {
        "content": "<p>I guess we would need to be able to talk about ramification as well, which we currently cannot do!</p>",
        "id": 291022230,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658922462
    },
    {
        "content": "<p>Not for Frobenius elements -- this would be precisely avoiding the ramified case! But of course in general we want to one day be able to talk about decomposition and inertia groups, which we currently cannot do.</p>",
        "id": 291024698,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1658923937
    },
    {
        "content": "<p>Well, to be able to talk about the unramified case, we need to be able to talk about the ramified case as well ;)<br>\nAnyway, what I really meant is that we need inertia/decomposition groups.</p>",
        "id": 291025025,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658924136
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"454183\">@Michail Karatarakis</span> I learnt about decomposition and inertia groups from Marcus' book \"Number fields\".</p>",
        "id": 291025186,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1658924225
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> and <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> Great, thank you.</p>",
        "id": 291025547,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1658924424
    },
    {
        "content": "<p>Welcome <span class=\"user-mention\" data-user-id=\"454183\">@Michail Karatarakis</span> ! Concerning Inertia and Ramification, consider that we have something in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ideal.ramification_idx\">docs#ideal.ramification_idx</a>   but it is still a bit incomplete. Having a look there might help, though.</p>",
        "id": 291154624,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1658997179
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span>  It definitely helps - thank you.</p>",
        "id": 291170295,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1659008460
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"454183\">@Michail Karatarakis</span> although the applications to FLT are all in the number field case, for decomposition and inertia groups one should work in more generality, although what I'm not sure about is what generality one can get away with. The maximally general (and possibly too general) situation is this: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is a commutative ring with field of fractions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> is a field extension of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> is the integral closure of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span>, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> is an ideal of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>. The <em>decomposition group</em> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> with respect to the data <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo separator=\"true\">,</mo><mi>K</mi><mo separator=\"true\">,</mo><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">R,K,L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> is the subgroup of <code>G := L \\equiv\\_a[K] L</code> (the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>-algebra isomorphisms from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span>) which is the stabiliser of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> acts on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> and the ideals of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>). The group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>D</mi><mi>P</mi></msub></mrow><annotation encoding=\"application/x-tex\">D_P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">P</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> acts on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> and hence on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mi mathvariant=\"normal\">/</mi><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">S/P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span>, and the <em>inertia subgroup</em> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>I</mi><mi>P</mi></msub></mrow><annotation encoding=\"application/x-tex\">I_P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">P</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>D</mi><mi>P</mi></msub></mrow><annotation encoding=\"application/x-tex\">D_P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">P</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is the elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>D</mi><mi>P</mi></msub></mrow><annotation encoding=\"application/x-tex\">D_P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">P</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> which fix <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mi mathvariant=\"normal\">/</mi><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">S/P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> pointwise. In this generality the definition is probably useless, but everything seems to work.</p>\n<p>Actually a variant would be the following: if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> is a valuation on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>D</mi><mi>v</mi></msub></mrow><annotation encoding=\"application/x-tex\">D_v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is the subgroup of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> which fixes the valuation (i.e. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>g</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(gx)=v(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">gx</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>) and if furthermore <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> is nonarchimedean (are all valuations nonarchimedean in mathlib??) then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>I</mi><mi>v</mi></msub></mrow><annotation encoding=\"application/x-tex\">I_v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is the subgroup of elements <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> with the property that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>≤</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">v(x)\\leq 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo>−</mo><mi>g</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">v(x-gx)&lt;1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">gx</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>. I guess you could even formalise both and prove that they're \"the same\" in situations of interest (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> the discrete valuation coming from a maximal ideal of a Dedekind domain).</p>\n<p>In practice number theorists only care about special cases of this definition, but it seems to me that the definitions can be made in huge generality.</p>",
        "id": 291231081,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1659031939
    },
    {
        "content": "<p>The most comprehensive treatment I know of regarding decomposition theory for (Krull) valuations is in Zariski-Samuel's book on commutative algebra.</p>",
        "id": 291259045,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1659046316
    },
    {
        "content": "<p>Decomposition theory certainly works (and is very important) for arbitrary valuations, not just discrete ones.</p>",
        "id": 291259151,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1659046369
    },
    {
        "content": "<p>Arguably we should even make sure that inertia/decomposition groups are defined in large enough generality that would allow us to talk about inertia/decomposition in etale fundamental groups</p>",
        "id": 291261765,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1659047958
    },
    {
        "content": "<p>Do you have to do it for rings first and then extend to schemes? If so then Michail doesn't have to worry about schemes (his aim here will be to be able to talk about Frobenius elements in Galois extensions of number fields)</p>",
        "id": 291267002,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1659051590
    },
    {
        "content": "<p>I think that defining ramification and inertia for arbitrary valuations would be the best option also for bare-hands algebraic number theory, because I think it will simplify the local-to-global (and viceversa) process. Of course, only rank-1 will be needed, but the language will be the most appropriate, no?</p>",
        "id": 291348954,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1659112285
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"454183\">@Michail Karatarakis</span> A while back I'd started working on the definition of the decomposition group, here's some of the code I wrote if you haven't written the definition yet <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"bp\">Γ₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">linear_ordered_comm_group_with_zero</span> <span class=\"bp\">Γ₀</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">L</span> <span class=\"bp\">Γ₀</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">alg_equiv.mul_eq_trans</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b.trans</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">alg_equiv.inv_eq_symm</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"n\">a.symm</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">decomposition_group</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span> <span class=\"bp\">|</span> <span class=\"n\">w</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"n\">w</span><span class=\"o\">},</span>\n  <span class=\"n\">mul_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">ha</span> <span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">set.mem_set_of_eq</span> <span class=\"n\">at</span> <span class=\"n\">ha</span> <span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">alg_equiv.mul_eq_trans</span><span class=\"o\">,</span>\n    <span class=\"n\">set.mem_set_of_eq</span><span class=\"o\">,</span> <span class=\"n\">alg_equiv.coe_trans</span><span class=\"o\">],</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">function.comp.assoc</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"n\">one_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ext</span> <span class=\"n\">x</span> <span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">alg_equiv.one_apply</span><span class=\"o\">,</span> <span class=\"n\">function.comp_app</span><span class=\"o\">],</span>\n  <span class=\"n\">inv_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">set.mem_set_of_eq</span> <span class=\"n\">at</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">conv_lhs</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">hx</span><span class=\"o\">},</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">alg_equiv.inv_eq_symm</span><span class=\"o\">,</span> <span class=\"n\">function.comp_app</span><span class=\"o\">,</span> <span class=\"n\">alg_equiv.apply_symm_apply</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 291717390,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1659450678
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"376152\">@Paul Lezeau</span>  Great! Thanks a lot for sharing <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 291720559,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1659452113
    },
    {
        "content": "<p>Note that it's probably better to take the stabilizer of the <em>equivalence class</em> of the valuation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> as opposed to the function underlying <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span>. We have a fairly good theory of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/valuation_subring\">docs#valuation_subring</a> that could be used.</p>",
        "id": 291754950,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1659467418
    },
    {
        "content": "<p>Hi, I've been looking at how to define the equivalence class of w. What's the general way of implementing equivalence classes/relations? We have that two valuations are equivalent iff they have the same valuation ring ( lemma <code>is_equiv_iff_valuation_subring</code>). Do I have to define the set of all equivalence classes as a setoid with such an equivalence relation on it, and then define the equivalence class <code>[[w]]</code> as an element of this set ? Is there a similar implementation, or an example in the library I can look at?</p>",
        "id": 292423299,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1659975153
    },
    {
        "content": "<p>Why not just use the valuation subring directly?</p>",
        "id": 292425699,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1659976287
    },
    {
        "content": "<p>There is an issue with equivalence of valuations coming from universes, because a valuation involves not just a ring, but also a totally ordered abelian group, which a priori might have a different universe level. So one has to be somewhat careful in defining the equivalence relation on valuations and ensure that the universe parameters of the ring and the value group are the same.</p>",
        "id": 292425899,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1659976362
    },
    {
        "content": "<p>If you want to get a valuation out of a valuation subring, we do have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/valuation_subring.valuation\">docs#valuation_subring.valuation</a></p>",
        "id": 292426417,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1659976631
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/292425699\">said</a>:</p>\n<blockquote>\n<p>Why not just use the valuation subring directly?</p>\n</blockquote>\n<p>Could you please clarify this further?  So, if suppose we have the set of equivalence classes of valuations of a ring, then for every valuation <code>w</code> in this set, we consider the valuation subring $A_w$ associated to <code>w</code>? Thank you</p>",
        "id": 292428332,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1659977523
    },
    {
        "content": "<p>Oh, all I'm saying is that the collection of valuations up to equivalence is \"the same\" (whatever that means) as the collection of valuation subrings of the given field. So instead of working with an equivalence class of valuations you can just work with a valuation subring</p>",
        "id": 292428783,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1659977712
    },
    {
        "content": "<p>Then if you want to talk about, say, the decomposition group of a valuation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span>, you could just define that as the decomposition group of the valuation ring associated to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span>.</p>",
        "id": 292428944,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1659977778
    },
    {
        "content": "<p>Hi,  I've changed the previous definition for the decomposition group by taking the valuation out of a valuation subring.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"bp\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">][</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">linear_ordered_comm_group_with_zero</span> <span class=\"bp\">Γ</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">alg_equiv.mul_eq_trans</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b.trans</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">alg_equiv.inv_eq_symm</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"n\">a.symm</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">decomp_group</span><span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span> <span class=\"bp\">|</span> <span class=\"n\">A.valuation</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"n\">A.valuation</span> <span class=\"o\">},</span>\n<span class=\"n\">mul_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">ha</span> <span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">set.mem_set_of_eq</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n<span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">alg_equiv.mul_eq_trans</span><span class=\"o\">,</span> <span class=\"n\">alg_equiv.coe_trans</span><span class=\"o\">],</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">function.comp.assoc</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">]},</span>\n<span class=\"n\">one_mem'</span><span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"n\">inv_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">set.mem_set_of_eq</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">conv_lhs</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">hx</span><span class=\"o\">},</span> <span class=\"n\">simp</span> <span class=\"o\">},}</span>\n</code></pre></div>\n<p>Is this what you meant by any chance?</p>",
        "id": 293157537,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1660324999
    },
    {
        "content": "<p>No, not quite. What I meant was to define an action of the Galojs group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi>a</mi><mi>l</mi><mo stretchy=\"false\">(</mo><mi>L</mi><mi mathvariant=\"normal\">∣</mi><mi>K</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Gal(L|K)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">L</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">)</span></span></span></span>  on the type of valuation subrings of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span>, and define the decomposition group as a stabilizer of this action. Presumably we can already talk about stabilizers with what's currently in mathlib.</p>",
        "id": 293164456,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660327248
    },
    {
        "content": "<p>This looks good to me! You don't need Gamma, it seems to play no role (you do need an L though, and some imports; this thread would be easier to follow if someone posts some code with full imports e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">field_theory.abel_ruffini</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.valuation.valuation_subring</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">][</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">alg_equiv.mul_eq_trans</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b.trans</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">alg_equiv.inv_eq_symm</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"n\">a.symm</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">decomp_group</span><span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span> <span class=\"bp\">|</span> <span class=\"n\">A.valuation</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"n\">A.valuation</span> <span class=\"o\">},</span>\n<span class=\"n\">mul_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">ha</span> <span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">set.mem_set_of_eq</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n<span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">alg_equiv.mul_eq_trans</span><span class=\"o\">,</span> <span class=\"n\">alg_equiv.coe_trans</span><span class=\"o\">],</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">function.comp.assoc</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">]},</span>\n<span class=\"n\">one_mem'</span><span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"n\">inv_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">set.mem_set_of_eq</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">conv_lhs</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">hx</span><span class=\"o\">},</span> <span class=\"n\">simp</span> <span class=\"o\">},}</span>\n</code></pre></div>\n<p>seems to work). </p>\n<p>It seems to me that this decomposition group contains a whole host of subgroups. Given any element i of the valuation group which is &lt;= 1, you can look at the subgroup of this decomposition group consisting of the g such that v(gx-x)&lt;i for all x in the valuation ring, or maybe v&lt;=i. Look up definitions of higher ramification groups (with the \"lower numbering\"), probably there is no reason not to define all of them at this point!</p>",
        "id": 293164776,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660327339
    },
    {
        "content": "<p>OK, so for the definition of the decomposition group as the stabiliser of the group action on the set of valuation subrings, could you point to me any references or similar constructions in the library?</p>",
        "id": 293169301,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1660328918
    },
    {
        "content": "<p>There is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_action.stabilizer\">docs#mul_action.stabilizer</a> but you'll need an action of <code>L ≃ₐ[K] L</code> on <code>valuation_subring L</code>, which you might have to make manually. I guess more generally the way to do it would be this: if L -&gt; M is a map of fields then you can pull back a valuation subring of M and get a valuation subring of L (I don't know if we have this). The pullback of the pullback is the pullback and the pullback via the identity map is the identity, and from these facts you can deduce that the pullback along an isomorphism is a bijection. I don't know if we have this stuff but it shouldn't be too hard.</p>",
        "id": 293171541,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660329737
    },
    {
        "content": "<p>Could we use <a href=\"https://leanprover-community.github.io/mathlib_docs/category_theory/limits/shapes/comm_sq.html#category_theory.is_pullback\">docs#category_theory.limits.shapes.comm_sq</a> for the pullback in this case?</p>",
        "id": 293266293,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1660391693
    },
    {
        "content": "<p>I think you''re confused about Kevin's use of the word \"pullback\". He just means to take the preimage, which would go under the name \"comap\" in mathlib, i.e. something like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.valuation.valuation_subring</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">valuation_subring.comap</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→+*</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">valuation_subring</span> <span class=\"n\">K</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mem_or_inv_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"n\">A.to_subring.comap</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 293270433,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660393744
    },
    {
        "content": "<p>Hi, so the definition above asks to prove that  <code>⊢ e k ∈ A ∨ e k⁻¹ ∈ A</code>. However, shouldn't it be <code>⊢ e k ∈ A ∨ (e k)⁻¹ ∈ A</code> from the definition of the valution subring? I am not clear about whether this a matter of notation or I am missing something. This is an example of what it's been going on : </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.valuation.valuation_subring</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">valuation_subring.comap</span>  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span>  <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→+*</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">valuation_subring</span> <span class=\"n\">K</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">mem_or_inv_mem'</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">rintro</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n<span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">valuation_subring.mem_or_inv_mem</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">k</span><span class=\"o\">),</span>\n<span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">h</span> <span class=\"n\">hinv</span><span class=\"o\">,</span>\n<span class=\"n\">left</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">right</span><span class=\"o\">,</span>\n<span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n  <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"n\">A.to_subring.comap</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 293695562,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1660648539
    },
    {
        "content": "<p><code>exact hinv,</code> works for me for that sorry. What's your question?</p>",
        "id": 293701158,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660651108
    },
    {
        "content": "<p>That's interesting - it doesn't seem to work for me: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">type</span> <span class=\"n\">ascription</span><span class=\"o\">,</span> <span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">e</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">⇑</span><span class=\"n\">e</span> <span class=\"n\">k</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span>\n</code></pre></div>",
        "id": 293701500,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1660651240
    },
    {
        "content": "<p>The non-terminal <code>simp</code> is doing a different thing on your box to mine.</p>",
        "id": 293701569,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660651269
    },
    {
        "content": "<p>Nonterminal <code>simp</code>s are a bad idea. You ran <code>simp</code> but it didn't close the goal. Thus what happened is a function of what simp lemmas are on the system at a given time.</p>",
        "id": 293701647,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660651307
    },
    {
        "content": "<p>OK, so how do I fix this?</p>",
        "id": 293701798,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1660651349
    },
    {
        "content": "<p>For the version of mathlib I was using, <code>simp</code> found <code>map_inv₀</code>. But you should remove the non-terminal <code>simp</code> anyway. Replace it with <code>squeeze_simp</code> and then the corresponding rewrite.</p>",
        "id": 293701805,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660651352
    },
    {
        "content": "<p>and then post your question again and I'll be much more likely to be in the same position as you.</p>",
        "id": 293701889,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660651387
    },
    {
        "content": "<p>On <code>master</code> <code>exact hinv</code> works for the sorry.</p>",
        "id": 293702077,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660651456
    },
    {
        "content": "<p>Where are you working? If on a branch of mathlib you could try merging master. If on a separate project you could try bumping mathlib.</p>",
        "id": 293702135,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660651481
    },
    {
        "content": "<p>So, now I am getting the same error as before whilst rewriting to : </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">valuation_subring.comap</span>  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span>  <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→+*</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">valuation_subring</span> <span class=\"n\">K</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">mem_or_inv_mem'</span> <span class=\"o\">:=</span>\n\n<span class=\"kd\">begin</span>\n<span class=\"n\">rintro</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n<span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">subring.mem_carrier</span><span class=\"o\">,</span> <span class=\"n\">subring.mem_comap</span><span class=\"o\">,</span> <span class=\"n\">valuation_subring.mem_to_subring</span><span class=\"o\">],</span>\n<span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">valuation_subring.mem_or_inv_mem</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">k</span><span class=\"o\">),</span>\n<span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">h</span> <span class=\"n\">hinv</span><span class=\"o\">,</span>\n<span class=\"n\">left</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">right</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">hinv</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n  <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"n\">A.to_subring.comap</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 293702304,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1660651550
    },
    {
        "content": "<p>I have been having some path related issues  with the imports. The only project that seemed to work at that time was the tutorials project :) I 'll try reinstalling everything.</p>",
        "id": 293702734,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1660651694
    },
    {
        "content": "<p>So now your code has no non-terminal <code>simp</code>s and it rightly doesn't work, because <code>(⇑e k)⁻¹</code> and <code>⇑e k⁻¹</code> are not definitionally equal.</p>",
        "id": 293703065,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660651830
    },
    {
        "content": "<p>So what is left of your question now?</p>",
        "id": 293703094,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660651845
    },
    {
        "content": "<p>One is <code>inv (e k)</code>, the other is <code>e (inv k)</code>.</p>",
        "id": 293703137,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660651864
    },
    {
        "content": "<p>Alright, so now the definition works with <code>map_inv₀</code> ?</p>",
        "id": 293703258,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1660651917
    },
    {
        "content": "<p>Yeah, that's the last piece of the puzzle.</p>",
        "id": 293703407,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660651977
    },
    {
        "content": "<p>I don't know why my <code>simp</code> found it and not yours.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">squeeze_simp</span><span class=\"o\">,</span>\n<span class=\"c1\">-- Try this: simp only [subring.mem_carrier, subring.mem_comap, valuation_subring.mem_to_subring, map_inv₀]</span>\n</code></pre></div>",
        "id": 293703953,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660652230
    },
    {
        "content": "<p>because it just got changed: <a href=\"https://github.com/leanprover-community/mathlib/pull/15985\">#15985</a></p>",
        "id": 293704599,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660652493
    },
    {
        "content": "<p>You probably want to merge master.</p>",
        "id": 293704639,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660652510
    },
    {
        "content": "<p>or bump mathlib, depending on where this code is</p>",
        "id": 293704709,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660652525
    },
    {
        "content": "<p>Yes, thanks. I created a new project and it's fixed now.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.valuation.valuation_subring</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">valuation_subring.comap</span>  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span>  <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→+*</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">valuation_subring</span> <span class=\"n\">K</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">mem_or_inv_mem'</span> <span class=\"o\">:=</span>\n\n<span class=\"kd\">begin</span>\n<span class=\"n\">rintro</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n<span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">subring.mem_carrier</span><span class=\"o\">,</span> <span class=\"n\">subring.mem_comap</span><span class=\"o\">,</span> <span class=\"n\">valuation_subring.mem_to_subring</span><span class=\"o\">,</span> <span class=\"n\">map_inv₀</span><span class=\"o\">],</span>\n<span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">valuation_subring.mem_or_inv_mem</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">k</span><span class=\"o\">),</span>\n<span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">h</span> <span class=\"n\">hinv</span><span class=\"o\">,</span>\n<span class=\"n\">left</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">right</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">hinv</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n  <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"n\">A.to_subring.comap</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 293704800,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1660652583
    },
    {
        "content": "<p>Do not recreate projects <span aria-label=\"scream\" class=\"emoji emoji-1f631\" role=\"img\" title=\"scream\">:scream:</span></p>",
        "id": 293704898,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660652640
    },
    {
        "content": "<p>Do <code>leanproject up</code></p>",
        "id": 293704959,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660652650
    },
    {
        "content": "<p>Regarding the action of the Galois group on <code>valuation_subring ring K</code>, do I have to define it as a new class?</p>",
        "id": 293707974,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1660653919
    },
    {
        "content": "<p>We should first golf a little bit...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.valuation.valuation_subring</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">valuation_subring.comap</span>  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span>  <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→+*</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">valuation_subring</span> <span class=\"n\">K</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mem_or_inv_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">valuation_subring.mem_or_inv_mem</span><span class=\"o\">],</span>\n  <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"n\">A.to_subring.comap</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 293722490,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660658003
    },
    {
        "content": "<p>The action of the Galois group would be an <em>instance</em> of the class <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_action\">docs#mul_action</a></p>",
        "id": 293722820,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660658103
    },
    {
        "content": "<p>BTW: Note that this is a right action</p>",
        "id": 293732896,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660661390
    },
    {
        "content": "<p>Right, so how do I define this action as a right action involving the comap?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.valuation.valuation_subring</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.defs</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">L</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">pullback_action</span><span class=\"o\">:</span>  <span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span>  <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">one_smul</span><span class=\"o\">:=</span> <span class=\"bp\">λ</span><span class=\"n\">σ</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n <span class=\"n\">mul_smul</span><span class=\"o\">:=</span> <span class=\"bp\">λ</span><span class=\"n\">σ₁</span><span class=\"o\">,</span> <span class=\"bp\">λ</span><span class=\"n\">σ₂</span><span class=\"o\">,</span> <span class=\"bp\">λ</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 293759169,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1660668558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/293171541\">said</a>:</p>\n<blockquote>\n<p>The pullback of the pullback is the pullback and the pullback via the identity map is the identity, and from these facts you can deduce that the pullback along an isomorphism is a bijection.</p>\n</blockquote>\n<p>I am not clear about how to customise this instance to involve these facts above. Would a right action suffice?</p>",
        "id": 293762570,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1660669744
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/Kr48h6KreTLRvIRiRNHptYj4/type.png\">type.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/Kr48h6KreTLRvIRiRNHptYj4/type.png\" title=\"type.png\"><img src=\"/user_uploads/3121/Kr48h6KreTLRvIRiRNHptYj4/type.png\"></a></div><p>After the line <code>refine {to_fun := _, map_one' := _, map_mul' := _},</code>, one of your goals is a Type not a Prop. This is bad. You closed the goal with <code>tauto</code>, and what this did was generated a completely random endomorphism because tauto is not expecting to run on types. Judging by the other goals it looks like <code>tauto</code> chose the identity function, so right now what you seem to have is an action of the pulled back valuation (considered as a monoid), on the K-automorphisms of L, considered as a set (or more precisely a type), and the definition of the action is that everything acts trivially.</p>",
        "id": 293794108,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660681401
    },
    {
        "content": "<p>You want to give an action of the automorphisms on the valuation subrings.</p>",
        "id": 293794282,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660681461
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">A.comap</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"c1\">-- you cannot use tactic mode for this, it's data</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"gr\">sorry</span> <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"gr\">sorry</span> <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 293794709,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660681634
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"454183\">Michail Karatarakis</span> <a href=\"#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/293762570\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/293171541\">said</a>:</p>\n<blockquote>\n<p>The pullback of the pullback is the pullback and the pullback via the identity map is the identity, and from these facts you can deduce that the pullback along an isomorphism is a bijection.</p>\n</blockquote>\n<p>I am not clear about how to customise this instance to involve these facts above or if, they are implied. Would such a right action suffice?</p>\n</blockquote>\n<p>The facts I flagged are precisely what you have to prove to create the <code>mul_action</code>.</p>",
        "id": 293794945,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660681715
    },
    {
        "content": "<p>You have defined <code>valuation_subring.comap</code>. Every definition comes with a cost. You might well find it tricky to fill in those two <code>sorry</code>s. Give them a go! But here's an interesting experiment (which you can try after): you can see that <code>valuation_subring.comap</code> is one proof and then everything else is <code>subring.comap</code>. You can jump to the definition of <code>subring.comap</code> in VS Code and observe that just after that definition is made, three theorems are proved:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_comap</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">subring</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s.comap</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_comap</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">subring</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s.comap</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">comap_comap</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">subring</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→+*</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">s.comap</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">s.comap</span> <span class=\"o\">(</span><span class=\"n\">g.comp</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Two of those lemmas are tagged <code>@[simp]</code> and if you don't prove the analogous lemmas for <code>valuation_subring.comap</code> then the simplifier won't know even the most basic stuff about <code>valuation_subring.comap</code>. You want to train the simplifier to prove simple equalities (like your two sorries) and iffs for you. So see if you can prove the analogues of those statements, and then you might find that the two sorries needed to make the <code>mul_action</code> are much easier.</p>",
        "id": 293795864,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660682068
    },
    {
        "content": "<p>Here's the lemmas proved just after <code>subgroup.comap</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp, to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">coe_comap</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">K.comap</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp, to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_comap</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">N</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"n\">N</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">K.comap</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">comap_mono</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"n\">N</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">K'</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">N</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">≤</span> <span class=\"n\">K'</span> <span class=\"bp\">→</span> <span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"n\">K</span> <span class=\"bp\">≤</span> <span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"n\">K'</span> <span class=\"o\">:=</span>\n<span class=\"n\">preimage_mono</span>\n\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">comap_comap</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→*</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">K.comap</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">K.comap</span> <span class=\"o\">(</span><span class=\"n\">g.comp</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n</code></pre></div>\n<p>and here's what's proved after <code>submonoid.comap</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp, to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">coe_comap</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">submonoid</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">S.comap</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp, to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_comap</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">submonoid</span> <span class=\"n\">N</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">S.comap</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n<span class=\"kn\">omit</span> <span class=\"n\">mc</span>\n\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">comap_comap</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">submonoid</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→*</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→*</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">S.comap</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">S.comap</span> <span class=\"o\">(</span><span class=\"n\">g.comp</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp, to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">comap_id</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">submonoid</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">S.comap</span> <span class=\"o\">(</span><span class=\"n\">monoid_hom.id</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"n\">ext</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>So those are some good suggestions for what kind of API you should make for <code>valuation_subring.comap</code>.</p>",
        "id": 293796246,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660682250
    },
    {
        "content": "<p>Wooah, the bare type comap (called <code>preimage</code>, it's a special case like an irregular verb) has all this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">preimage</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n\n<span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">⁻¹'</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">80</span> <span class=\"o\">:=</span> <span class=\"n\">preimage</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">preimage</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">preimage_empty</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"bp\">∅</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">mem_preimage</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">preimage_congr</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">congr'</span> <span class=\"k\">with</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">apply_assumption</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">preimage_mono</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"k\">assume</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">hx</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">preimage_univ</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">univ</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">subset_preimage_univ</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">univ</span> <span class=\"o\">:=</span> <span class=\"n\">subset_univ</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">preimage_inter</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">preimage_union</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">preimage_compl</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">ᶜ</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">preimage_diff</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">\\</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span> <span class=\"bp\">\\</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"o\">[</span><span class=\"n\">loads</span> <span class=\"n\">more</span> <span class=\"n\">omitted</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 293796504,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660682349
    },
    {
        "content": "<p>You could check that <code>valuation_subring.comap</code> plays well with the lattice structure on valuation subrings. Looking through the mathlib file where <code>valuation_subring</code> is defined, it appears to have <code>instance : semilattice_sup (valuation_subring K) := ...</code> which means that the valuation subrings of a field have some kind of lattice structure (infs or sups, like unions and intersections, maybe finite or infinite) and you could see if your construction preserved these things. That's what <code>preimage_inter</code> is doing above, for example (but using nonstandard <code>∩</code> instead of standard <code>⊓</code>, called <code>inf</code>)</p>",
        "id": 293797679,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660682782
    },
    {
        "content": "<p>Finally, it's really important that you move <code>[algebra K L]</code> below the definition of <code>valuation_subring.comap</code>. I've just noticed that <code>comap</code> is picking it up, and we definitely don't need it at this point.</p>",
        "id": 293798141,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660682988
    },
    {
        "content": "<p>Great, thank you very much.</p>",
        "id": 293799095,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1660683323
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/293732896\">said</a>:</p>\n<blockquote>\n<p>BTW: Note that this is a right action</p>\n</blockquote>\n<p>Oh yeah! <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> how do we do right actions in Lean? I think the code I've posted for the mul_action is not right.</p>",
        "id": 293799110,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660683330
    },
    {
        "content": "<p><code>smul := λ e A, A.comap e.symm,</code> would work but is this the idiomatic way?</p>",
        "id": 293799683,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660683593
    },
    {
        "content": "<p>One option is to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_opposite\">docs#mul_opposite</a> but <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> will probably tell us the best way to do this</p>",
        "id": 293800132,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660683768
    },
    {
        "content": "<p>With my way, to get <code>simp</code> to do the job you need</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">alg_equiv.one_symm</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">alg_equiv.mul_symm</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">=</span> <span class=\"n\">b.symm</span> <span class=\"bp\">*</span> <span class=\"n\">a.symm</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Using </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">A.comap</span> <span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">),</span>\n</code></pre></div>\n<p>I only have to make the basic API for <code>valuation_subring.comap</code> and I can get <code>ext, simp</code> to do everything.</p>",
        "id": 293801951,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660684481
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"454183\">@Michail Karatarakis</span> I hadn't noticed it was a right action. Probably the <code>ᵐᵒᵖ</code> approach is best.</p>",
        "id": 293802109,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660684558
    },
    {
        "content": "<p>OK so, this is the definition we need for the right action?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">A.comap</span> <span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">),</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"gr\">sorry</span> <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"gr\">sorry</span> <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 293803054,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1660684975
    },
    {
        "content": "<p>A good stress test for your definition is trying to show <code>smul_comm_class (L ≃ₐ[K] L) (L ≃ₐ[K] L)ᵐᵒᵖ (valuation_subring L)</code>.</p>",
        "id": 293803274,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660685063
    },
    {
        "content": "<p>Mathlib only has right <em>multiplication</em> actions, not actions on the codomain</p>",
        "id": 293805596,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660686215
    },
    {
        "content": "<p>But certainly you can use <code>mul_opposite</code> to define this comap action; you're just at risk of hitting instance diamonds</p>",
        "id": 293806055,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660686439
    },
    {
        "content": "<p><del>Is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/valuation_subring\">docs#valuation_subring</a> of the type I'd expect?</del> (edit: no) If so, then I think there's already an action via <code>map</code>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subring.pointwise_mul_action\">docs#subring.pointwise_mul_action</a></p>",
        "id": 293806230,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660686532
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/293803274\">said</a>:</p>\n<blockquote>\n<p>A good stress test for your definition is trying to show <code>smul_comm_class (L ≃ₐ[K] L) (L ≃ₐ[K] L)ᵐᵒᵖ (valuation_subring L)</code>.</p>\n</blockquote>\n<p>I can't make sense of this. What is the left action?</p>",
        "id": 293809597,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660688093
    },
    {
        "content": "<p>The one via map</p>",
        "id": 293809876,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660688219
    },
    {
        "content": "<p>That I link above for subring, but that we don't have yet for <code>valuation_subring</code></p>",
        "id": 293809899,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660688230
    },
    {
        "content": "<p>I don't think there's <code>map</code> for <code>valuation_subring</code>. The image of a valuation subring under a ring homomorphism might not be a valuation subring.</p>",
        "id": 293810671,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660688643
    },
    {
        "content": "<p>Oh -- I see -- for <code>equiv</code>s there is a <code>map</code>!</p>",
        "id": 293810700,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660688665
    },
    {
        "content": "<p>I would guess it generalizes to any group action, not just equivs</p>",
        "id": 293810759,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660688720
    },
    {
        "content": "<p>I'm confused. If you have a right action of a group on a thing, how are you getting a left action of the same group?</p>",
        "id": 293810907,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660688785
    },
    {
        "content": "<p>Just use the right action of the inverse?</p>",
        "id": 293810926,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660688798
    },
    {
        "content": "<p>I don't think these actions commute in general. I'm lost.</p>",
        "id": 293811037,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660688880
    },
    {
        "content": "<p>I can't make any sense of Yael's stress test.</p>",
        "id": 293811104,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660688898
    },
    {
        "content": "<p>I'll PR what I'm thinking of</p>",
        "id": 293811173,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660688960
    },
    {
        "content": "<p>I can't see any <code>map</code> other than <code>A.map e = A.comap e.symm</code> and these actions won't commute if the group isn't abelian.</p>",
        "id": 293811484,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660689104
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/16080\">#16080</a></p>",
        "id": 293812738,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660689917
    },
    {
        "content": "<p>Oh sorry, your point was that the actions might not commute, not that you can't think of what the left action is (which that PR provides)</p>",
        "id": 293812786,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660689952
    },
    {
        "content": "<p>I also now agree that <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>' stress test doesn't seem to make sense.</p>",
        "id": 293813542,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660690413
    },
    {
        "content": "<p>Shouldn't my stress test boil down to associativity of composition?</p>",
        "id": 293847590,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660721152
    },
    {
        "content": "<p>What are you composing?</p>",
        "id": 293849389,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660722130
    },
    {
        "content": "<p>I guess I was seeing <code>valuation_subring</code> as an <code>alg_equiv</code> <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 293851458,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660723244
    },
    {
        "content": "<p>I think the true version of the statement is that \"two actions on (valuation) subrings commute if they commute on the elements\". Currently we are missing those instances for pointwise actions on subobjects</p>",
        "id": 293858645,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660726696
    },
    {
        "content": "<p>~Shall I just work on the API for the comap for now then, until the definition of the action can be stated or look at the PR first? I am bit confused.</p>",
        "id": 293873579,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1660733575
    },
    {
        "content": "<p>I am about to go on holiday for a week so will be limited help during this time, but my honest opinion is that it would be good for you to fill in the sorries for the <code>mop</code> left action but in practice if you use it you'll just get a load of subgroups of the opposite group which will be really annoying, so I would just define the decomposition and inertia subgroups manually.</p>",
        "id": 293878234,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660735603
    },
    {
        "content": "<p>OK, just to conclude - here are the definitions we have so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.valuation.valuation_subring</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">valuation_subring.comap</span>  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span>  <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→+*</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">valuation_subring</span> <span class=\"n\">K</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mem_or_inv_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">valuation_subring.mem_or_inv_mem</span><span class=\"o\">],</span>\n  <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"n\">A.to_subring.comap</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">A.comap</span> <span class=\"o\">(</span><span class=\"n\">e.unop</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">),</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"gr\">sorry</span> <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"gr\">sorry</span> <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">decomposition_group</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"n\">mul_action.stabilizer</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">A</span>  <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Is the definition of the decomposition group above what you meant?</p>",
        "id": 293902540,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1660744898
    },
    {
        "content": "<p>Concerning the inertia group, do we define it as we 've discussed before ?:</p>\n<p>1) <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>v</mi></msub></mrow><annotation encoding=\"application/x-tex\">R_v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is the valuation ring  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>a</mi><mo>∈</mo><mi>L</mi><mi mathvariant=\"normal\">∣</mi><mi>v</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>≤</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{ a ∈ L | v(a) \\leq 1 \\} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span> ( prove that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>v</mi></msub></mrow><annotation encoding=\"application/x-tex\">R_v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is a subring of  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> ).</p>\n<p>2) Define the maximal ideal of  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>m</mi><mi>v</mi></msub><mo>=</mo><mo stretchy=\"false\">{</mo><mi>a</mi><mo>∈</mo><mi>K</mi><mo>∣</mo><mi>v</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>&lt;</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">m_v=\\{ a ∈ K \\mid v(a) &lt; 1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span>  ( prove that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>m</mi><mi>v</mi></msub></mrow><annotation encoding=\"application/x-tex\">m_v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is a subring of  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span>).</p>\n<p>3) Define the inertia group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>I</mi><mi>v</mi></msub></mrow><annotation encoding=\"application/x-tex\">I_v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> as the quotient <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>v</mi></msub><mi mathvariant=\"normal\">/</mi><msub><mi>m</mi><mi>v</mi></msub><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">R_v/m_v.</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">.</span></span></span></span></p>\n<p>Is this the best way we can define it?</p>",
        "id": 293904846,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1660745649
    },
    {
        "content": "<p>A few points</p>\n<ol>\n<li>As Kevin mentioned, it could get annoying to work with the decomposition group if defined as a stabilizer, because this is a right action, and you use <code>mop</code>, meaning that the stabilizer is a subgroup of the mul-opposite of the Galois group instead of the Galois group itself. It's possible to translate to the Galois group with this approach, but it would be easier to define it as a subgroup of the Galois group directly.</li>\n<li>\n<p>Your second declaration doesn't make sense. You're trying to define the decomposition group as a stabilizer, not obtain some element of the stabilizer. When you write <code>def decomposition_group (A : valuation_subring L) [mul_action (L ≃ₐ[K] L)ᵐᵒᵖ A] :\nmul_action.stabilizer (L ≃ₐ[K] L)ᵐᵒᵖ A  := sorry</code>, that means you're trying to obtain some element (aka \"term\") of the stabilizer.</p>\n</li>\n<li>\n<p>The inertia group is not <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mi mathvariant=\"normal\">/</mi><mi mathvariant=\"fraktur\">m</mi></mrow><annotation encoding=\"application/x-tex\">R/\\mathfrak{m}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord\">/</span><span class=\"mord mathfrak\">m</span></span></span></span>. That's the residue field. you need to show that elements of the decomposition group preserve the maximal ideal and define the inertia group as those elements in the decomposition group which act trivially on the residue field.</p>\n</li>\n</ol>",
        "id": 293907669,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660746470
    },
    {
        "content": "<p>We have a fairly robust API for valuation subrings in mathlib thanks to the work of <span class=\"user-mention\" data-user-id=\"488744\">@Jack McKoen</span> . There is no need to define <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>v</mi></msub></mrow><annotation encoding=\"application/x-tex\">R_v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and/or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"fraktur\">m</mi><mi>v</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathfrak{m}_v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6253em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathfrak\">m</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. Rather, it would be better to use (and extend) the existing API from mathlib.</p>",
        "id": 293907967,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660746560
    },
    {
        "content": "<ol>\n<li>\n<p>&amp; 2. OK, thank you for the clarification.</p>\n</li>\n<li>\n<p>Oh, yes, you are right. I meant I should define the residue field first and then proceed - defining the inertia group would have been a fourth goal. Thus, do I define it as a subgroup of the decomposition group in this case?</p>\n</li>\n</ol>",
        "id": 293910292,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1660747230
    },
    {
        "content": "<p>Re 2: I would define the inertia group as a subgroup of the Galois group and prove that it's contained in the decomposition group, using the lattice structure on the type of subgroups of a group.</p>",
        "id": 293910998,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660747413
    },
    {
        "content": "<p>Also, mathlib knows that valuation rings are local, so there is no need to define the residue field as you can use the API for local rings.</p>",
        "id": 293911162,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660747447
    },
    {
        "content": "<p>OK, clear.  I forgot to ask - the stabiliser subgroup is not in mathlib? (that's what confused me when I looked at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_action.stabilizer\">docs#mul_action.stabilizer</a>).</p>",
        "id": 293912655,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1660747849
    },
    {
        "content": "<p>What do you mean? <code>mul_action.stabilizer</code> is precisely the stabiliser subgroup.</p>",
        "id": 293913104,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660747948
    },
    {
        "content": "<p>Yeah, I was trying to understand Adam's point about the difference between obtaining a term of the stabiliser, and, the stabiliser. I thought that definition results in a subgroup and not a term. Of course my definition still doesn't make sense as it's been pointed out.</p>",
        "id": 293916305,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1660748925
    },
    {
        "content": "<p>Your mistake is like writing <code>def foo : 37 := sorry</code> instead of <code>def foo : nat := 37</code></p>",
        "id": 293920255,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660750291
    },
    {
        "content": "<p>The problem is that it's a right action so the stabiliser stuff doesn't work because that's set up for left actions</p>",
        "id": 293940798,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660756721
    },
    {
        "content": "<p>Right, I 'll try filling up the <code> sorry </code>s of the action regardless for practice. However, is there a set theoretic notation for the definition of the decomposition group that involves this action? Does the right action just play the rule of the composition <code>∘</code> as in the previous attempts ?</p>",
        "id": 293944107,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1660757776
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> , could this be an alternative definition for the inertia group? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.valuation.valuation_subring</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">][</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">inertia</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">):=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span>  <span class=\"bp\">|</span>  <span class=\"n\">A.valuation</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span><span class=\"mi\">1</span> <span class=\"o\">},</span>\n  <span class=\"n\">mul_mem'</span><span class=\"o\">:=</span><span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">one_mem'</span><span class=\"o\">:=</span><span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_mem'</span><span class=\"o\">:=</span><span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 294637754,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1661160852
    },
    {
        "content": "<p>That's not the inertia subgroup because that function takes an input x and then returns a subgroup which depends on x. You probably want a \"for all x\" somewhere instead. I'm still in a field with no access to lean but I guess the forall goes after <code>|</code> in the carrier field</p>",
        "id": 294640721,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661161974
    },
    {
        "content": "<p>I don't think <code>A : valuation_subring L</code> should be in <code>[typeclass brackets]</code>. I guess <code>(regular explicit)</code> is how it's intended to be used.</p>",
        "id": 294644889,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661163645
    },
    {
        "content": "<p><del><code>{A : valuation_subring L}</code> is the correct thing here, actually, because of the<code>(x : A)</code>.</del> That's not the case anymore if you fix the definition as Kevin says.</p>",
        "id": 294645323,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661163832
    },
    {
        "content": "<p>Right, so it should be something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.valuation.valuation_subring</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">][</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">inertia</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">):</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">):=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span>  <span class=\"bp\">|</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">A.valuation</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"o\">},</span>\n  <span class=\"n\">mul_mem'</span><span class=\"o\">:=</span><span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">one_mem'</span><span class=\"o\">:=</span><span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_mem'</span><span class=\"o\">:=</span><span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 294645906,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1661164063
    },
    {
        "content": "<p>1) Could an alternative definition for the inertia group be the following : \" the elements of the Galois group (of the decomposition group)​ which fix the residue field pointwise\" instead of saying \"the elements that act trivially on the residue field\" ? In this case, do the pointwise actions from  <a href=\"https://leanprover-community.github.io/mathlib_docs/ring_theory/valuation/valuation_subring.html#pointwise-actions\">docs#valuation_subring</a> need to be modified for this goal?</p>\n<p>2) Furthermore, understanding how actions are implemented would help me define the decomposition group too. Right now I am not clear about how to define it as a stabiliser from scratch. For example <code> mul_action.stabiliser </code> ( as it's been pointed out ) only works for left actions. It also seems that the definition is also based on other things that need to be defined from scratch for right actions too. So far, I can't see clearly where I have to start for that and how deep it gets- what we have, is this instance</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">A.comap</span> <span class=\"o\">(</span><span class=\"n\">e.unop</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">),</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"gr\">sorry</span> <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"gr\">sorry</span> <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>If I wish to define the decomposition group as </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">decomposition_group</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>how could I involve this instance in the carrier?</p>",
        "id": 294657569,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1661168684
    },
    {
        "content": "<p>Just define the stabiliser by hand as the elements of the group which fix something. As for fixing the residue field, sure you could define it like this. Did you define an action of the decomposition group on the residue field? That's an obvious prerequisite for this approach</p>",
        "id": 294664541,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661171229
    },
    {
        "content": "<p>\"Just define the stabiliser by hand as the elements of the group which fix something\" If I have a generic subgroup such as </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span>  <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">α</span> <span class=\"o\">]</span> <span class=\"o\">[</span> <span class=\"n\">group</span> <span class=\"n\">β</span> <span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">stabilizer</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">α</span>  <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span>   <span class=\"bp\">|</span>  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">b</span> <span class=\"bp\">•</span> <span class=\"n\">a</span>  <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">},</span>\n <span class=\"n\">mul_mem'</span><span class=\"o\">:=</span><span class=\"gr\">sorry</span><span class=\"o\">,</span>\n <span class=\"n\">one_mem'</span><span class=\"o\">:=</span><span class=\"gr\">sorry</span><span class=\"o\">,</span>\n <span class=\"n\">inv_mem'</span><span class=\"o\">:=</span><span class=\"gr\">sorry</span>\n  <span class=\"o\">}</span>\n</code></pre></div>\n<p>How do I to involve the <code> mul_action </code> instance from above  - i. e. how do I equip this subgroup where <code> • </code> is that right action specifically?</p>",
        "id": 294685209,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1661177734
    },
    {
        "content": "<p>That example seems to be missing <code>mul_action α β</code></p>",
        "id": 294787679,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1661214661
    },
    {
        "content": "<p>But the answer is \"choose α and β and lean will find the appropriate instance\"</p>",
        "id": 294787708,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1661214706
    },
    {
        "content": "<p>You should be able to use <code>stabilizer (L ≃ₐ[K] L)ᵐᵒᵖ (valuation_subring L)</code></p>",
        "id": 294787811,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1661214825
    },
    {
        "content": "<p>(also note that the <code>map</code> action is now merged, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/valuation_subring.pointwise_mul_action\">docs#valuation_subring.pointwise_mul_action</a>)</p>",
        "id": 294787870,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1661214862
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/294787811\">said</a>:</p>\n<blockquote>\n<p>You should be able to use <code>stabilizer (L ≃ₐ[K] L)ᵐᵒᵖ (valuation_subring L)</code></p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  Yes sure, but what it's been pointed out is that this stabilizer is set up for left actions and we need a right action. Thus, it's better if I can define a stabilizer subgroup for an arbitrary <code> mul_action </code>. That's what I am not clear about, hence that example above. Any ideas of how I could implement a stabilizer subgroup for an arbitrary action?</p>",
        "id": 295295322,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1661455182
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_action.stabilizer\">docs#mul_action.stabilizer</a> <em>is already</em> defined for an arbitrary <code>mul_action</code> (over a group), so I don't understand your question</p>",
        "id": 295295940,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1661455404
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/293940798\">said</a>:</p>\n<blockquote>\n<p>The problem is that it's a right action so the stabiliser stuff doesn't work because that's set up for left actions</p>\n</blockquote>\n<p>Right, I am referring to what <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  and Adam pointed out.</p>",
        "id": 295296540,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1661455635
    },
    {
        "content": "<p>We don't want a subgroup of <code>G^mop</code>, we want a subgroup of G.</p>\n<p>Do you know what -- maybe we don't want the decomposition subgroup to be a subgroup? Maybe we just use the left action of mop but define <code>D v</code> to be the subtype rather than the subgroup? What do you think <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> ? If <code>v</code> is a valuation not on the top field but on the bottom field, how are we going to define <code>D v</code>? I have always thought of it as a subgroup of the global Galois group but I'm wondering whether the object is sufficiently important to deserve its own <code>decomposition_group v : Type</code> rather than <code>decomposition_subgroup v : subgroup (L K-alg_iso L)</code>. </p>\n<p><span class=\"user-mention\" data-user-id=\"454183\">@Michail Karatarakis</span> there is a ton of stuff you could do here. Let's just have a one-on-one meeting at some point. I am on holiday right now unfortunately, but I will be back on Monday evening. I'll contact you offline and give you some concrete problems to think about. Right now, as sometimes happens, there seems to be several possibilities for the formalised definition of a decomposition group.</p>",
        "id": 295298241,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661456247
    },
    {
        "content": "<p>Then you can use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subgroup.unopposite\">docs#subgroup.unopposite</a>.</p>",
        "id": 295298445,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661456313
    },
    {
        "content": "<p>Damn, it doesn't exist <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span> but <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subgroup.opposite\">docs#subgroup.opposite</a> does, so it really should be there!</p>",
        "id": 295298505,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661456335
    },
    {
        "content": "<p>I guess you're meant to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subgroup.opposite_equiv\">docs#subgroup.opposite_equiv</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">decomposition_subgroup</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">subgroup.opposite_equiv.symm</span> <span class=\"bp\">$</span> <span class=\"n\">stabilizer</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 295298559,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661456364
    },
    {
        "content": "<p>Well, there is no decomposition group if you only have a valuation of the base-field -- you need to choose a prolongation.<br>\nIt's a theorem that the decomposition groups of two prolongations (which are conjugate) are conjugate in the group-theoretic sense, but that's a theorem. So you could define <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>D</mi><mi>v</mi></msub></mrow><annotation encoding=\"application/x-tex\">D_v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> as a conjugacy class when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> is a valuation of the base.</p>",
        "id": 295302577,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661457978
    },
    {
        "content": "<p>I do think it should be defined as a sungroup because the behavior of this subgroup in the lattice of subgroups of the Galois groups reflects the decomposition behavior of the valuation on the base (and if you also include the inertia, you can relate ramification to this lattice structure as well)</p>",
        "id": 295303296,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661458277
    },
    {
        "content": "<p>Oh yes of course I'm a fool, it's only a conjugacy class of subgroups, I don't know what I was thinking.</p>",
        "id": 295306818,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661459790
    },
    {
        "content": "<p>It is confusing because we like to identify \"the decomposition group of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>\" in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi>a</mi><msub><mi>l</mi><mi mathvariant=\"double-struck\">Q</mi></msub></mrow><annotation encoding=\"application/x-tex\">Gal_\\mathbb{Q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9611em;vertical-align:-0.2667em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\">a</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3322em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathbb mtight\">Q</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2667em;\"><span></span></span></span></span></span></span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi>a</mi><msub><mi>l</mi><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></msub></mrow><annotation encoding=\"application/x-tex\">Gal_{\\mathbb{Q}_p}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0418em;vertical-align:-0.3473em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\">a</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3322em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathbb mtight\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1645em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2819em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3473em;\"><span></span></span></span></span></span></span></span></span></span> all the time ;)</p>",
        "id": 295308047,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661460372
    },
    {
        "content": "<p>OK so from now on I will try to be coherent. In the example you highlight above the following phenomena occur: We have an extension L of K (Galois, in this case), a valuation v on K, (uncountably) many extensions of this valuation to L, and for any two such extensions w1 and w2, there's a K-isomorphism from L to L sending w1 to w2. Furthermore if we choose an arbitrary w in L extending v on K, then the canonical map from D_w to the K_v-isomorphisms of L_w is an isomorphism. In what generality is all that true?</p>",
        "id": 295309475,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661461054
    },
    {
        "content": "<p>If you replace completion with Henselization, then this is true for arbitrary valuations. For completions, I don't know of the top of my head.</p>",
        "id": 295310008,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661461276
    },
    {
        "content": "<p>Do we have this in mathlib?</p>",
        "id": 295310062,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661461300
    },
    {
        "content": "<p>I don't think so.</p>",
        "id": 295310110,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661461320
    },
    {
        "content": "<p>Would it be worth Michail working on this, if his ultimate goal is to start talking about things like local conditions on deformations of global Galois representations? Is it the sort of thing which one actually needs in practice, or would be helpful to have? Is it _hard_? What's a reference?</p>",
        "id": 295310398,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661461441
    },
    {
        "content": "<p>I hadn't quite realised that things could be done in such generality.</p>",
        "id": 295310474,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661461461
    },
    {
        "content": "<p>Here is the page from the stacks project <a href=\"https://stacks.math.columbia.edu/tag/0BSK\">https://stacks.math.columbia.edu/tag/0BSK</a></p>",
        "id": 295310692,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661461558
    },
    {
        "content": "<p>What sorts of local conditions are you referring to?</p>",
        "id": 295310788,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661461597
    },
    {
        "content": "<p>deformations of representations of global Galois groups which are finite flat at p, or unramified at q, or something like that. FLT stuff. Michail is a student of Freek who's formalising the statements of some of the theorems of Wiles and Taylor-Wiles.</p>",
        "id": 295310881,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661461642
    },
    {
        "content": "<p>I think most things (e.g. unramified) can be phrased (and usually are phrased) entirely in terms of the structure of the decomposition group. Once you get to more analytic conditions, like being de Rham at p, that's when the identification with the Galois group of the completion seems to be required</p>",
        "id": 295311339,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661461889
    },
    {
        "content": "<p>A 2-dimensional representation being locally an extension of one-dimensional representations is perhaps a nice example. No completions needed there I guess.</p>",
        "id": 295311534,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661461986
    },
    {
        "content": "<p>I'm teaching a graduate NT course next term. It would be great if I can show off decomposition theory in mathlib by then ;)</p>",
        "id": 295311788,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661462120
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> what do you think of the following fix for the left/right thing: we can pull back valuations along arbitrary field maps, but we can push them forward along equivs. This would give us a left action, right?</p>",
        "id": 295313111,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661462806
    },
    {
        "content": "<p>Hmmmm I think that would be confusing. For example, is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi><msub><mi>D</mi><mi>v</mi></msub><msup><mi>σ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><msub><mi>D</mi><msup><mi>v</mi><mi>σ</mi></msup></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma D_v \\sigma^{-1} = D_{v^\\sigma}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9641em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2655em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5935em;\"><span style=\"top:-2.786em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">σ</span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> or <span class=\"tex-error\">$$D_{v^{\\sigma^{-1}}$$</span>? (I never remember and always have to write out the formula when I need to figure this out, but it's written down in books always using the right action, I suppose)</p>",
        "id": 295313353,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661462938
    },
    {
        "content": "<p>I'm a bit surprised that right actions are such a problem, given that we now have things like two-sided ideals.</p>",
        "id": 295313671,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661463094
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/295313671\">said</a>:</p>\n<blockquote>\n<p>I'm a bit surprised that right actions are such a problem, given that we now have things like two-sided ideals.</p>\n</blockquote>\n<p>maybe I just made that up?</p>",
        "id": 295313817,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661463159
    },
    {
        "content": "<p>Do we want the decomposition subgroup to be a subgroup of G or of G^mop?</p>",
        "id": 295313875,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661463189
    },
    {
        "content": "<p>of G!</p>",
        "id": 295313913,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661463206
    },
    {
        "content": "<p>I guess we could pull it back along the isomorphism (do you know the name for the group iso G -&gt; G^mop?) (op(g^{-1}) or whatever)</p>",
        "id": 295313924,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661463215
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_equiv.inv'\">docs#mul_equiv.inv'</a></p>",
        "id": 295314042,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661463267
    },
    {
        "content": "<p>oh is this the point of division monoids??</p>",
        "id": 295314122,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661463312
    },
    {
        "content": "<p>That was my first encounter with <code>division_monoid</code> <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 295314280,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661463388
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> that's pretty cool :-)</p>",
        "id": 295314528,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661463523
    },
    {
        "content": "<p>We have subbimodules, implemented via tensor product: <a href=\"https://github.com/leanprover-community/mathlib/commit/58cef51f7a819e7227224461e392dee423302f2d\">https://github.com/leanprover-community/mathlib/commit/58cef51f7a819e7227224461e392dee423302f2d</a><br>\nTwo-sided ideals would involve mop (<a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/293167433\">sketch here</a>)</p>",
        "id": 295323603,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661468483
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/295314122\">said</a>:</p>\n<blockquote>\n<p>oh is this the point of division monoids??</p>\n</blockquote>\n<p>One of them!</p>",
        "id": 295345543,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661480577
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/295313924\">said</a>:</p>\n<blockquote>\n<p>I guess we could pull it back along the isomorphism (do you know the name for the group iso G -&gt; G^mop?) (op(g^{-1}) or whatever)</p>\n</blockquote>\n<p>Did you read <a href=\"#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/295298559\">my snippet above</a>? This is exactly what it does:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">decomposition_subgroup</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">subgroup.opposite_equiv.symm</span> <span class=\"bp\">$</span> <span class=\"n\">stabilizer</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 295345650,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661480664
    },
    {
        "content": "<blockquote>\n<p>This is exactly what it does:</p>\n</blockquote>\n<p>I think they differ by ⁻¹</p>",
        "id": 295345758,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661480772
    },
    {
        "content": "<p>Hmm... You're right. Why does that matter?</p>",
        "id": 295348956,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661484187
    },
    {
        "content": "<p>I think what they have in mind originally/mathematics-wise is your version, actually.</p>",
        "id": 295349590,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661485011
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> is there a general theory of higher ramification groups in this setting, indexed e.g. by elements of the value group in the range (0,1] or something?</p>",
        "id": 295592902,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661604489
    },
    {
        "content": "<p>Do you understand all that phi and psi conversion to upper numbering in the DVR setting, on a conceptual level?</p>",
        "id": 295592980,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661604530
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/295298559\">said</a>:</p>\n<blockquote>\n<p>I guess you're meant to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subgroup.opposite_equiv\">docs#subgroup.opposite_equiv</a>:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">decomposition_subgroup</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">subgroup.opposite_equiv.symm</span> <span class=\"bp\">$</span> <span class=\"n\">stabilizer</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>  Could you please explain what your code does, and include the imports?</p>",
        "id": 295593467,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1661604782
    },
    {
        "content": "<p>The imports should be the same as yours.</p>",
        "id": 295594307,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661605212
    },
    {
        "content": "<p>So <code>stabilizer (L ≃ₐ[K] L)ᵐᵒᵖ (valuation_subring L) : subgroup (L ≃ₐ[K] L)ᵐᵒᵖ</code>. But mathematically <code>(L ≃ₐ[K] L)ᵐᵒᵖ</code> is just <code>L ≃ₐ[K] L</code> again, so take the image of <code>stabilizer (L ≃ₐ[K] L)ᵐᵒᵖ (valuation_subring L)</code> under the mathematically irrelevant map <code>(L ≃ₐ[K] L)ᵐᵒᵖ → L ≃ₐ[K] L</code>.</p>",
        "id": 295594519,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661605359
    },
    {
        "content": "<p>It doesn't seem to compile. What's the issue here? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.valuation.valuation_subring</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.group.opposite</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">decomposition_subgroup</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">subgroup.opposite_equiv.symm</span> <span class=\"bp\">$</span> <span class=\"n\">mul_action.stabilizer</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 295595006,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1661605601
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/295594519\">said</a>:</p>\n<blockquote>\n<p>So <code>stabilizer (L ≃ₐ[K] L)ᵐᵒᵖ (valuation_subring L) : subgroup (L ≃ₐ[K] L)ᵐᵒᵖ</code>. But mathematically <code>(L ≃ₐ[K] L)ᵐᵒᵖ</code> is just <code>L ≃ₐ[K] L</code> again, so take the image of <code>stabilizer (L ≃ₐ[K] L)ᵐᵒᵖ (valuation_subring L)</code> under the mathematically irrelevant map <code>(L ≃ₐ[K] L)ᵐᵒᵖ → L ≃ₐ[K] L</code>.</p>\n</blockquote>\n<p>OK, thanks.</p>",
        "id": 295595075,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1661605647
    },
    {
        "content": "<p>Sorry, I wasn't done explaining!</p>",
        "id": 295595307,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661605786
    },
    {
        "content": "<p>However <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subgroup.opposite_equiv\">docs#subgroup.opposite_equiv</a> is not what I thought it was, so here's <a href=\"https://github.com/leanprover-community/mathlib/pull/16271\">#16271</a> to define that \"mathematically irrelevant map\". If you use the code from that PR, then the definition becomes</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">decomposition_subgroup</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">subgroup.opposite.symm</span> <span class=\"bp\">$</span> <span class=\"n\">stabilizer</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 295595468,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661605843
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> there is some work on this but as far as I know there is no established theory. </p>\n<p>The one thing that comes to mind is work of Abrashkin on higher ramification in higher dimensional local fields -- he even constructs analogues of the field of norms!</p>",
        "id": 295599215,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661607735
    },
    {
        "content": "<p>The wild ramification group can always be defined for any valuation (it's the unique p-Sylow subgroup of the inertia group, where p is the residue characteristic)</p>",
        "id": 295599349,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661607841
    },
    {
        "content": "<p>And the theorem that the residue Galois group acts cyclotomically on the tame inertia still holds in general</p>",
        "id": 295599437,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661607883
    },
    {
        "content": "<p>but then wild inertia has some funny filtration on it indexed by the value group (which I just discovered isn't a group! <a href=\"https://github.com/leanprover-community/mathlib/pull/16272\">#16272</a> that confused me for a bit).</p>",
        "id": 295599573,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661607962
    },
    {
        "content": "<p>I think Huber uses the phrase differently to mathlib :-(</p>",
        "id": 295599643,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661608000
    },
    {
        "content": "<p>I think even defining the filtration is subtle. There is no obvious choice. Do you take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi><mi>x</mi><mo>−</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma x - x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> to have valuation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">\\le a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span>, or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">&lt; a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span>? Maybe you want to say that it acts trivially on the valuation ring modulo some power of the maximal ideal?</p>",
        "id": 295600787,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661608682
    },
    {
        "content": "<p>Each element x of the value group on the right side of 1 (I'm assuming &lt;= 1) gives you two ideals of the valuation ring,  J_{&lt;=x} and J_x, and you can define I_{&lt;=x} and I_{&lt;x} to be the things fixing R / this ideal.</p>",
        "id": 295600990,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661608794
    },
    {
        "content": "<p>Yeah sure but not every ideal is of this form</p>",
        "id": 295601127,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661608843
    },
    {
        "content": "<p>Maybe one should index them by the ideals</p>",
        "id": 295601166,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661608860
    },
    {
        "content": "<p>Oh I see, you're saying that using ideals is even more general.</p>",
        "id": 295601170,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661608861
    },
    {
        "content": "<p>And then there's a map from nat into the ideals sending n to max^n and there's your higher ramification groups.</p>",
        "id": 295601326,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661608938
    },
    {
        "content": "<p>Now what about the upper numbering?</p>",
        "id": 295601734,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661609151
    },
    {
        "content": "<p>For me that's defined for finite extensions only, from the lower numbering, via this combinatorial voodoo, and then this miracle theorem that it's well-behaved under quotients (unlike the lower numbering, which is only well-behaved under subs), and then you can define it for arbitrary Galois extensions. OK completely dumb question: what's the relationship between the upper numbering higher ramification groups (indexed by Q) in the absolute Galois group of a p-adic field e.g. Q_p, and the filtration on inertia which we have, indexed by the ideals of Z_p-bar?</p>",
        "id": 295602358,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661609457
    },
    {
        "content": "<p>Kevin, these are the right questions, but I've exhausted what I can do on my phone while also making breakfast. I'll have to come back to this later ;)</p>",
        "id": 295603372,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1661609991
    },
    {
        "content": "<p>Hi, I have defined the decomposition subgroup as the pullback along the map <code>( L ≃ₐ[K] L) →* ( L ≃ₐ[K] L)ᵐᵒᵖ</code>(which should be an isomorphism..)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.valuation.valuation_subring</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.group.opposite</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">valuation_subring.comap</span>  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span>  <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→+*</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">valuation_subring</span> <span class=\"n\">K</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mem_or_inv_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">valuation_subring.mem_or_inv_mem</span><span class=\"o\">],</span>\n  <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"n\">A.to_subring.comap</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">A.comap</span> <span class=\"o\">(</span><span class=\"n\">e.unop</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">),</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"n\">rintro</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">ext1</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">rintro</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">rintro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">refl</span><span class=\"o\">,}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">mul_opposite</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">decomposition_group.comap</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"o\">(</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"o\">):</span>\n<span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n <span class=\"bp\">..</span> <span class=\"o\">((</span><span class=\"n\">mul_action.stabilizer</span>  <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">A</span>  <span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>Does this work? This function might need to take a valuation on L as input. Any tricks for that?</p>",
        "id": 296333024,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1661955138
    },
    {
        "content": "<p>The pullback that you should use is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subgroup.opposite\">docs#subgroup.opposite</a> (once <a href=\"https://github.com/leanprover-community/mathlib/pull/16271\">#16271</a> is in).</p>",
        "id": 296334714,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661955598
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>  Using  <a href=\"https://github.com/leanprover-community/mathlib/pull/16271\">#16271</a> we get what you wrote before (unless you have something else in mind) :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">decomposition_subgroup</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">subgroup.opposite.symm</span> <span class=\"o\">(</span> <span class=\"n\">mul_action.stabilizer</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It's using the map <code> (L ≃ₐ[K] L)ᵐᵒᵖ → L ≃ₐ[K] L </code>, whereas I am using  <code>  (L ≃ₐ[K] L)  →*  (L ≃ₐ[K] L)ᵐᵒᵖ  </code></p>\n<p>Don't we need to have a valuation on L as input ? I am not clear about what's wrong with these two definitions.</p>",
        "id": 296579861,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1662036963
    },
    {
        "content": "<p>Additionally, is there a correct way to promote the decomposition subgroup to a group?</p>",
        "id": 296580094,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1662037032
    },
    {
        "content": "<p>The input is <code>A</code>. These definitions look fine to me. You can golf your proof of <code>one_smul</code>: the <code>simp</code> doesn't do anything so you can just remove it (and it is not good style anyway because it's not a terminal <code>simp</code>) and when you see <code>rintro X, exact X</code> you should be thinking \"that's the identity map\"; indeed instead of <code>split, ...</code> you can just finish the proof with <code>refl</code> because by this point your goal is of the form X &lt;-&gt; Y with X and Y definitionally equal.</p>\n<p>The way to promote the subgroup to a group is just to start talking about it as if it were a type; when Lean is expecting a type and you provide it with a term it will look in the typeclass system to see if there are any coercions around which promote the term to a type, and it will find one and apply it; you know it's happened because you'll see one of those funny <code>↥</code> arrows, which in this case will indication an application of the function <code>set_like.has_coe_to_sort</code>.</p>",
        "id": 296589509,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1662040060
    },
    {
        "content": "<p>OK, thank you. I golfed the proof above.</p>",
        "id": 296609842,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1662045918
    },
    {
        "content": "<p>You mean that this coercion will happen automatically if I treat the decomposition subgroup as a group?</p>",
        "id": 296610084,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1662045982
    },
    {
        "content": "<p>OK, then perhaps I could experiment by defining the inertia group ( subgroup for the Galois group, and, as the pointwise stabilizer of the decomposition group acting on the residue field ? ) There is <a href=\"https://leanprover-community.github.io/mathlib_docs/ring_theory/valuation/valuation_subring.html#valuation_subring.pointwise_mul_action\">docs#valuation_subring.pointwise_mul_action</a>. Is this the action that we need?</p>",
        "id": 296619516,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1662046601
    },
    {
        "content": "<p>Using this definition,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">decomposition_group</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">subgroup.opposite.symm</span> <span class=\"o\">(</span> <span class=\"n\">mul_action.stabilizer</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>the definition: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">D</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">D</span><span class=\"o\">:</span> <span class=\"n\">decomposition_group</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"n\">local_ring.residue_field</span> <span class=\"n\">L</span><span class=\"o\">):=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>yields a (deterministic) timeout error  (if I try to remove the <code>sorry</code>)- Could someone explain what's this error about ? </p>\n<p>Furthermore, why doesn't this definition </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">D</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">D</span><span class=\"o\">:</span> <span class=\"n\">decomposition_group</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">pointwise_mul_action</span> <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"n\">local_ring.residue_field</span> <span class=\"n\">L</span><span class=\"o\">):=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>work? I am not clear about the syntax here; doesn't <code>pointwise_mul_action</code> behave like <code>mul_action</code>?</p>",
        "id": 296659938,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1662051983
    },
    {
        "content": "<p>Can you provide a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ?</p>",
        "id": 296660713,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662052253
    },
    {
        "content": "<p>Right, </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.valuation.valuation_subring</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.group.opposite</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"o\">:</span><span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">valuation_subring.comap</span>  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span>  <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→+*</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">valuation_subring</span> <span class=\"n\">K</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mem_or_inv_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">valuation_subring.mem_or_inv_mem</span><span class=\"o\">],</span>\n  <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"n\">A.to_subring.comap</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">A.comap</span> <span class=\"o\">(</span><span class=\"n\">e.unop</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">),</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext1</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">},</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">refl</span><span class=\"o\">,}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">decomposition_group</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">subgroup.opposite.symm</span> <span class=\"o\">(</span> <span class=\"n\">mul_action.stabilizer</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n\n\n<span class=\"c1\">--The following gives the timeout error</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">D</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">D</span><span class=\"o\">:</span> <span class=\"n\">decomposition_group</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"n\">local_ring.residue_field</span> <span class=\"n\">L</span><span class=\"o\">):=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">--The following doesn't compile</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">D</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">D</span><span class=\"o\">:</span> <span class=\"n\">decomposition_group</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">pointwise_mul_action</span> <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"n\">local_ring.residue_field</span> <span class=\"n\">L</span><span class=\"o\">):=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 296661573,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1662052554
    },
    {
        "content": "<p>The line </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">D</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">D</span><span class=\"o\">:</span> <span class=\"n\">decomposition_group</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"n\">local_ring.residue_field</span> <span class=\"n\">L</span><span class=\"o\">):=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>is not what you want.</p>",
        "id": 296662897,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662052997
    },
    {
        "content": "<p>It seems you're still confused about types vs terms.</p>",
        "id": 296662945,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662053009
    },
    {
        "content": "<p>What this line is saying, in words, is this: Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> be a type, and let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> be an element of <code>decomposition_group</code> (which is a function, so that doesn't make sense). Then there is a multiplicative action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> (but which one? there are two D's introduced) on the residue field of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span>.</p>",
        "id": 296663155,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662053078
    },
    {
        "content": "<p>Besides those issues, there is also no valuation mentioned whatsoever -- you're taking the residue field of the field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span>, which is a local ring since it has a unique maximal ideal (the trivial ideal). The residue field in this case is isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> itself.</p>",
        "id": 296663318,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662053141
    },
    {
        "content": "<p>There is also an issue that your valuation ring variable is in square brackets. Those brackets are reserved for typeclass parameters whereas <code>valuation_subring L</code> is the type of (bundled) valuation subrings of the field L.</p>",
        "id": 296663683,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662053248
    },
    {
        "content": "<p>I don't know what this <code>pointwise_mul_action</code> is supposed to accomplish, but in any case, here is some code to get you started:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.valuation.valuation_subring</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.group.opposite</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">valuation_subring.comap</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span>  <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→+*</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">valuation_subring</span> <span class=\"n\">K</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mem_or_inv_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">valuation_subring.mem_or_inv_mem</span><span class=\"o\">],</span>\n  <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"n\">A.to_subring.comap</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">A.comap</span> <span class=\"o\">(</span><span class=\"n\">e.unop</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">),</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext1</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">},</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">refl</span><span class=\"o\">,}</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">K</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">valuation_subring.decomposition_group</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">subgroup.opposite.symm</span> <span class=\"o\">(</span> <span class=\"n\">mul_action.stabilizer</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">K</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">):</span>\n  <span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">A.decomposition_group</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">local_ring.residue_field</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 296664355,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662053454
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/296662897\">said</a>:</p>\n<blockquote>\n<p>The line </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">D</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">D</span><span class=\"o\">:</span> <span class=\"n\">decomposition_group</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"n\">local_ring.residue_field</span> <span class=\"n\">L</span><span class=\"o\">):=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>is not what you want.</p>\n</blockquote>\n<p>Sure, I just haven't encountered that timeout error before and I was wondering what it's about.</p>",
        "id": 296664455,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1662053494
    },
    {
        "content": "<p>If Lean is expecting X and you give it Y, then it might put some effort into figuring out how Y's can be interpreted as X's. If you give it junk and Y can't be coerced into X then Lean might spend forever trying to do something impossible.</p>",
        "id": 296672489,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1662055879
    },
    {
        "content": "<p>Hi, I have this MWE so far </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.valuation.valuation_subring</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.group.opposite</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">valuation_subring.comap</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span>  <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→+*</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">valuation_subring</span> <span class=\"n\">K</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mem_or_inv_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">valuation_subring.mem_or_inv_mem</span><span class=\"o\">],</span>\n  <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"n\">A.to_subring.comap</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">A.comap</span> <span class=\"o\">(</span><span class=\"n\">e.unop</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">),</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">ext1</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">},</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">refl</span><span class=\"o\">,}</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">K</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">valuation_subring.decomposition_group</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">subgroup.opposite.symm</span> <span class=\"o\">(</span> <span class=\"n\">mul_action.stabilizer</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">K</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">):</span>\n<span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">A.decomposition_group</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">local_ring.residue_field</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span><span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n  <span class=\"n\">one_smul</span><span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span><span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">refl</span><span class=\"o\">,}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">valuation_subring.inertia_group</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span>\n   <span class=\"c1\">-- ..((mul_action.stabilizer (A.decomposition_group K) (local_ring.residue_field A) ) )</span>\n  <span class=\"o\">}</span>\n</code></pre></div>\n<p>The goal is to complete the definition of the inertia group as the stabilizer of the action of the decomposition group on the residue field.</p>\n<p>Is this the correct way to define it ? -  I am confused about how to complete this carrier. Removing the comment indicates that the carrier has type <code>set ↥(valuation_subring.decomposition_group K A)</code> but is expected to have type  <code>set (L ≃ₐ[K] L)</code> What could be the right syntax, or, what could I use from the library to complete this coercion?</p>",
        "id": 296794654,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1662116449
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_action.stabilizer\">docs#mul_action.stabilizer</a> is the stabilizer of a single point of a group acting on a Type, so you would really want the intersection of all the stabilizers of all points I guess, I don't know if we have this definition as a thing already in mathlib</p>",
        "id": 296798606,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1662117983
    },
    {
        "content": "<p>Probably you could use the kernel of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_action.to_perm_hom\">docs#mul_action.to_perm_hom</a> for this</p>",
        "id": 296799749,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1662118418
    },
    {
        "content": "<p>You defined the action on the residue field to be trivial. That's not the correct action.</p>",
        "id": 296800331,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662118636
    },
    {
        "content": "<p>And the whole point of doing it this way around is that the subgroup you'll get is a subgroup of the decomposition group, not of the full Galois group.</p>",
        "id": 296800798,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1662118803
    },
    {
        "content": "<p>I think thats the type error above, even Lean wants to define a subgroup of the decomposition group! I couldn't work out how to get a subgroup of a subgroup into a subgroup the original group though, do we have that somewhere?</p>",
        "id": 296801014,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1662118885
    },
    {
        "content": "<p>Just push it forward along the homomorphism with <code>map</code>.</p>",
        "id": 296801085,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1662118914
    },
    {
        "content": "<p>Yeah idk why I was just expecting a name for that, but that makes total sense.</p>",
        "id": 296801326,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1662118999
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/296801014\">said</a>:</p>\n<blockquote>\n<p>I think thats the type error above, even Lean wants to define a subgroup of the decomposition group! I couldn't work out how to get a subgroup of a subgroup into a subgroup the original group though, do we have that somewhere?</p>\n</blockquote>\n<p>Yeah, that's what I got stuck on. The plan was to define the inertia as a subgroup of the Galois group and then to prove perhaps a theorem that says that it's a subgroup of the decomposition group. I thought there would be a coercion somewhere in that definition.</p>",
        "id": 296801499,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1662119063
    },
    {
        "content": "<p>So what could I do to fix it?</p>",
        "id": 296802306,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1662119378
    },
    {
        "content": "<p>What confused me was that, that theorem was being \"asked for\" in the definition.</p>",
        "id": 296803002,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1662119624
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/296800331\">said</a>:</p>\n<blockquote>\n<p>You defined the action on the residue field to be trivial. That's not the correct action.</p>\n</blockquote>\n<p>Right, what action do we need for this? All I know is that the decomposition group acts pointwise on the residue field.</p>",
        "id": 296827760,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1662127636
    },
    {
        "content": "<p>You need to define a <code>sub_mul_action (A.decomposition_group K) L</code> with <code>carrier := A</code> (I'm not sure if the <code>mul_action</code> is already inferred by instance search). Then you sort of want to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_action.quotient_action\">docs#add_action.quotient_action</a> with <code>H := local_ring.maximal_ideal A</code>, but we have a <code>mul_action</code> not <code>add_action</code>; the best way out of this is to consider the action on <code>multiplicative L</code>, I think. Another thing to beware of is that you should only be able to define a (left) mul_action of the mul_opposite <code>(A.decomposition_group K)ᵐᵒᵖ</code>.</p>",
        "id": 296862869,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662139041
    },
    {
        "content": "<p>Thanks for the clarification. But how can I combine this with what <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> already defined below ? - This is a different action.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">):</span>\n<span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">A.decomposition_group</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">local_ring.residue_field</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 296864341,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1662139560
    },
    {
        "content": "<p>Right, you first need to define an action of the decomposition group by ring isomorphisms on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> itself, then use the fact that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> is local to descend this action to an action on the residue field.</p>",
        "id": 296866218,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662140220
    },
    {
        "content": "<p>Yeah I was just pointing out some intermediate defs you need to get to the end goal, and that the end goal should involve the mul_opposite of (A.decomposition_group K).</p>",
        "id": 296868940,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662141224
    },
    {
        "content": "<p>Well, the decomposition group should be a subgroup of the Galois group, so it should just be a regular left action on <code>A</code>.</p>",
        "id": 296869374,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662141381
    },
    {
        "content": "<p>Michail already converted from the stabilizer (which is a subgroup of the opposite group) to a subgroup of the Galois group using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subgroup.opposite\">docs#subgroup.opposite</a></p>",
        "id": 296869485,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662141423
    },
    {
        "content": "<p>Note that we do have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/distrib_mul_action\">docs#distrib_mul_action</a> which includes compatibility with addition. But the action on the ring is really by ring automorphisms, and as far as I know we don't have a way to speak nicely about actions by ring automorphisms.</p>",
        "id": 296869944,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662141600
    },
    {
        "content": "<p>Notice that if you use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_action.quotient_action\">docs#mul_action.quotient_action</a> with H := <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_subgroup.to_subgroup\">docs#add_subgroup.to_subgroup</a> (local_ring.maximal_ideal A), then <code>inv_mul_mem</code> boils down to <code>a' - a ∈ H → b • a' - b • a ∈ H</code>, so you just need distrib_mul_action + a little bit.</p>",
        "id": 296873772,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662142979
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/subgroup.opposite\">docs#subgroup.opposite</a> doesn't turn an action by mul_opposite (i.e. a right action) to an action by the original group (i.e. a left action) because it's simply the identity; <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_equiv.inv'\">docs#mul_equiv.inv'</a> could do that because it inserts an inverse. So <code>mul_action.stabilizer (L ≃ₐ[K] L)ᵐᵒᵖ A</code> inherits the mul_action from (L ≃ₐ[K] L)ᵐᵒᵖ (probably by typeclass inference), but when you convert it to a subgroup of <code>(L ≃ₐ[K] L)</code> using subgroup.opposite.symm, it no longer has a mul_action. So I think it's better to consider the action of <code>mul_action.stabilizer (L ≃ₐ[K] L)ᵐᵒᵖ A</code> and get an the inertia subgroup as a subgroup of it instead of <code>A.decomposition_group K</code>, and only convert it to a subgroup of <code>(L ≃ₐ[K] L)</code> in the end if you really want to do that.</p>",
        "id": 296877642,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662144539
    },
    {
        "content": "<p>But there is no mul action of <code>mul_action.stabilizer (L ≃ₐ[K] L)ᵐᵒᵖ A</code>. It's a stabilizer! The action is trivial (on A as a <em>set</em>).</p>",
        "id": 296881586,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662146164
    },
    {
        "content": "<p>Since it stabilizes A as a set, the mul action induced by that of the Galois group on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> restricts to an action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>.</p>",
        "id": 296881629,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662146182
    },
    {
        "content": "<p>What we DO have is a mul_action of a subgroup of the Galois group of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mi mathvariant=\"normal\">∣</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">L|K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span>. That should be called <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subgroup.mul_action\">docs#subgroup.mul_action</a> maybe?</p>",
        "id": 296881771,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662146247
    },
    {
        "content": "<p>What Michail now needs to prove is that this mul_action of the decomposition group, when acting on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span>, restricts to an action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>.</p>",
        "id": 296881957,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662146325
    },
    {
        "content": "<p>Here's a bit more code... once those sorries are done, it would be a good exercise to obtain the action on the residue field by showing that the action on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> preserves the maximal ideal.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.valuation.valuation_subring</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.group.opposite</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">valuation_subring.comap</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span>  <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→+*</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">valuation_subring</span> <span class=\"n\">K</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mem_or_inv_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">valuation_subring.mem_or_inv_mem</span><span class=\"o\">],</span>\n  <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"n\">A.to_subring.comap</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">A.comap</span> <span class=\"o\">(</span><span class=\"n\">e.unop</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">),</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext1</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">},</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">refl</span><span class=\"o\">,}</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">K</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">valuation_subring.decomposition_group</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">subgroup.opposite.symm</span> <span class=\"o\">(</span><span class=\"n\">mul_action.stabilizer</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">A.decomposition_group</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n<span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">valuation_subring.sub_mul_action</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">sub_mul_action</span> <span class=\"o\">(</span><span class=\"n\">A.decomposition_group</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">decomposition_group.mul_action</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">distrib_mul_action</span> <span class=\"o\">(</span><span class=\"n\">A.decomposition_group</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul_add</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_zero</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"n\">sub_mul_action.mul_action</span> <span class=\"o\">(</span><span class=\"n\">A.sub_mul_action</span> <span class=\"n\">K</span><span class=\"o\">))</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 296882258,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662146472
    },
    {
        "content": "<p>Oh yeah I was confused. I agree that you should be able to do <code>sub_mul_action (A.decomposition_group K) L</code> with carrier <code>A</code>. The reason is that the action on valuation subrings is via comap, which implicitly introduces an inverse relative to the action on elements: with the definition of <code>mul_action (L ≃ₐ[K] L)ᵐᵒᵖ (valuation_subring L)</code> it holds that <code>a ∈ A → e⁻¹ • a ∈ e • A</code>, i.e. to make the two actions compatible you need an inverse. Without using inverse, this can be written <code>e • a ∈ A → a ∈ e • A</code>, i.e. the two actions are not compatible but \"adjoint\".</p>",
        "id": 296893463,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662151832
    },
    {
        "content": "<p>Isn't <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_semiring_action\">docs#mul_semiring_action</a> the tool to talk about actions by ring automorphisms, <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>?</p>",
        "id": 296946488,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662186140
    },
    {
        "content": "<p>I think we're missing the instance for ring automorphisms because we're also missing the monoid structure (by composition) of ring automorphisms</p>",
        "id": 296946558,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662186230
    },
    {
        "content": "<p>But we have the version for <code>alg_equiv</code></p>",
        "id": 296946609,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662186247
    },
    {
        "content": "<p>Also, can't you just define the decomposition group in terms of the existing <a href=\"https://leanprover-community.github.io/mathlib_docs/find/valuation_subring.pointwise_mul_action\">docs#valuation_subring.pointwise_mul_action</a> instead of making a new mul_action instance (defined via map instead of comap)? After all, <code>comap</code>ing by <code>e</code> is just mapping by <code>e⁻¹</code>?</p>",
        "id": 296946869,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662186539
    },
    {
        "content": "<p>Ah! Great! I didn't know this pointwise mul action existed!</p>",
        "id": 297052422,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662259359
    },
    {
        "content": "<p>BTW the docstring for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subring.pointwise_mul_action\">docs#subring.pointwise_mul_action</a> sounds wrong to me (similarly for the valuation one).</p>",
        "id": 297052690,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662259726
    },
    {
        "content": "<p>It's not the action on <em>a</em> subring, but rather the action on the type of all subrings.</p>",
        "id": 297052706,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662259774
    },
    {
        "content": "<p>I guess we should add the following class/instances?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.quotient</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.ideal.quotient</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">mul_action.add_quotient_action</span> <span class=\"o\">[</span><span class=\"n\">add_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">neg_add_mem</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"bp\">-</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">a'</span> <span class=\"bp\">∈</span> <span class=\"n\">H</span> <span class=\"bp\">→</span> <span class=\"bp\">-</span><span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">•</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">•</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span><span class=\"cm\"> `inv_mul_mem` in docs#add_action.quotient_action should also be called `neg_add_mem`. -/</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">mul_action.add_quotient</span> <span class=\"o\">[</span><span class=\"n\">add_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">mul_action.add_quotient_action</span> <span class=\"n\">β</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⧸</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"c\">/-</span><span class=\"cm\"> The above are analogous to docs#mul_action.quotient_action, docs#mul_action.quotient -/</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">distrib_mul_action.add_quotient</span> <span class=\"o\">[</span><span class=\"n\">add_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">mul_action.add_quotient_action</span> <span class=\"n\">β</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">H.normal</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">distrib_mul_action</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⧸</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">mul_distrib_mul_action.add_quotient</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_distrib_mul_action</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">mul_action.add_quotient_action</span> <span class=\"n\">β</span> <span class=\"n\">I.to_add_subgroup</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">mul_distrib_mul_action</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⧸</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">mul_semiring_action.add_quotient</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_semiring_action</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">mul_action.add_quotient_action</span> <span class=\"n\">β</span> <span class=\"n\">I.to_add_subgroup</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">mul_semiring_action</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⧸</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 297062933,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662271339
    },
    {
        "content": "<p>And we probably also want the following, but the current algebra hierarchy doesn't yet allow us to state them properly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">submodule.distrib_mul_action</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">distrib_mul_action</span> <span class=\"n\">β</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"c\">/-</span><span class=\"cm\"> Analogous to docs#sub_mul_action.mul_action.</span>\n<span class=\"cm\">  We want p to be both a sub_mul_action and a submonoid, i.e. a submodule, but the current</span>\n<span class=\"cm\">  typeclass requirement for submodule is too strong. Relax it? -/</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">submonoid'.mul_distrib_mul_action</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_distrib_mul_action</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">submonoid</span> <span class=\"n\">α</span> <span class=\"c\">/-</span><span class=\"cm\"> + smul_mem -/</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mul_distrib_mul_action</span> <span class=\"n\">β</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">subsemiring'.mul_semiring_action</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_semiring_action</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">subsemiring</span> <span class=\"n\">α</span> <span class=\"c\">/-</span><span class=\"cm\"> + smul_mem -/</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mul_semiring_action</span> <span class=\"n\">β</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 297066036,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662275050
    },
    {
        "content": "<p>I already tried relaxing the typeclass requirements for <code>submodule</code> sometime last year, but ran into timeouts</p>",
        "id": 297067912,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662276787
    },
    {
        "content": "<p>Hi, I have the following MWE :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.valuation.valuation_subring</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.group.opposite</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">valuation_subring.comap</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span>  <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→+*</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">valuation_subring</span> <span class=\"n\">K</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mem_or_inv_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">valuation_subring.mem_or_inv_mem</span><span class=\"o\">],</span>\n  <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"n\">A.to_subring.comap</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">A.comap</span> <span class=\"o\">(</span><span class=\"n\">e.unop</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">),</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext1</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">},</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">refl</span><span class=\"o\">,}</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">K</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">valuation_subring.decomposition_group</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">subgroup.opposite.symm</span> <span class=\"o\">(</span><span class=\"n\">mul_action.stabilizer</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">A.decomposition_group</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">valuation_subring.sub_mul_action</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">sub_mul_action</span> <span class=\"o\">(</span><span class=\"n\">A.decomposition_group</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">rintros</span> <span class=\"n\">d</span> <span class=\"n\">l</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span>\n   <span class=\"o\">}</span>\n</code></pre></div>\n<p>It looks simple enough but I keep missing something. Is there anything in the library I could use, or any specific lemmata I shall define first?</p>\n<p>However, concerning the previous conversation: </p>\n<p>~Do we need to define the decomposition group in terms of that pointwise mul action instead?</p>",
        "id": 298163091,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1662831596
    },
    {
        "content": "<p>So your <code>d</code> has type <code>↥(valuation_subring.decomposition_group K A)</code>, which means \"subgroup (a term), promoted to a group (a type)\". If you could get your hands on what was _actually_ going on, i.e. an element of the full Galois group <code>L ≃ₐ[K] L</code> and a proof that it's in the subgroup (and in particular if you could get rid of the <code>↥</code> coercion) then probably you could make more progress. The way to do this is literally to take <code>d</code> apart. To give a term of type <code>↥(valuation_subring.decomposition_group K A)</code> <em>is</em> to give a pair consisting of an element of <code>L ≃ₐ[K] L</code> and a proof that it's in the subgroup. So you could continue with <code>cases d with g hg</code> for example. Or you could just do everything in one go with <code>rintros ⟨g, hg⟩ l h,</code>.</p>",
        "id": 298163853,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1662832192
    },
    {
        "content": "<blockquote>\n<p>Do we need to define the decomposition group in terms of that pointwise mul action instead?</p>\n</blockquote>\n<p>You don't _need_ to do anything. I don't quite understand the question.</p>",
        "id": 298163925,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1662832223
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/298163925\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Do we need to define the decomposition group in terms of that pointwise mul action instead?</p>\n</blockquote>\n<p>You don't _need_ to do anything. I don't quite understand the question.</p>\n</blockquote>\n<p>Right, I am referring to : <a href=\"#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/296946869\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/296946869</a></p>",
        "id": 298165511,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1662833253
    },
    {
        "content": "<p>Thank you for the hint - Using <code>cases</code> with <code>simp </code> does remove the coercions, and I end up with the following: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.valuation.valuation_subring</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.group.opposite</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">valuation_subring.comap</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span>  <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→+*</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">valuation_subring</span> <span class=\"n\">K</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mem_or_inv_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">valuation_subring.mem_or_inv_mem</span><span class=\"o\">],</span>\n  <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"n\">A.to_subring.comap</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">A.comap</span> <span class=\"o\">(</span><span class=\"n\">e.unop</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">),</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext1</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">},</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">refl</span><span class=\"o\">,}</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">K</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">valuation_subring.decomposition_group</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">subgroup.opposite.symm</span> <span class=\"o\">(</span><span class=\"n\">mul_action.stabilizer</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">A.decomposition_group</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">valuation_subring.sub_mul_action</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">sub_mul_action</span> <span class=\"o\">(</span><span class=\"n\">A.decomposition_group</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">⟩</span> <span class=\"n\">l</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>which I find a bit confusing: I am looking for a proof involving an action of a tuple <code> ⟨g, hg⟩ • l ∈ A </code> instead, where <code>g : L ≃ₐ[K] L</code> and <code> hg : g ∈ valuation_subring.decomposition_group K A </code>. Is there anything more I could do from here?<br>\nFurthermore, <code>library_search</code> curiously gives several errors concerning the types instead of the usual timeout or indicating that it hasn't found something.</p>",
        "id": 298167783,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1662834953
    },
    {
        "content": "<p>Are you claiming that <code>simp at *</code> closes the goal? It doesn't for me. If I do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">⟩</span> <span class=\"n\">l</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">l</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>(this works because <code>⟨g, hg⟩ • l ∈ A</code> is definitionally equal to <code>g • l ∈ A</code>) then we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">∈</span> <span class=\"n\">valuation_subring.decomposition_group</span> <span class=\"n\">K</span> <span class=\"n\">A</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">l</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span>\n</code></pre></div>\n<p>Mathematically this is trivial: it says \"if g is in the subgroup which stabilises A, then it sends something in A to something in A\". Well, if something is mathematically trivial like this but is causing problems in Lean then it should probably be a lemma! Indeed if I look at your code then I see a red flag: every definition in Lean comes with a cost, and the cost is that you need to make an API for that definition (i.e. a list of basic theorems about that definition). You define <code>valuation_subring.decomposition_group</code> and prove 0 theorems about it and then go on to make another definition, and now you're in the middle of a proof about this second definition but you find that you need a fact about the first definition. The thing to think now is not \"how do I continue in this proof in the second definition\", it's \"let's go back and make the API for the first definition\". It's important to make this API because all of this left action / right action nonsense means that it's not really as easy as one would like to close the goal from here (assuming that your code didn't clear it -- it didn't for me).</p>",
        "id": 298176021,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1662841680
    },
    {
        "content": "<p>Arguably there is no point in having <code>valuation_subring.decomposition_group</code> at all, as it is a longer spelling and has less API than the equal <code>mul_action.stabilizer (L ≃ₐ[K] L) A</code></p>",
        "id": 298183534,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662849097
    },
    {
        "content": "<p>Here's a proof of the above without any real definitions, which also follows my earlier suggestion to throw out all the <code>mul_opposite</code> stuff that isn't necessary</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.valuation.valuation_subring</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">K</span><span class=\"o\">)</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">pointwise</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">valuation_subring.decomposition_group</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">mul_action.stabilizer</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"n\">A</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">valuation_subring.sub_mul_action</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">sub_mul_action</span> <span class=\"o\">(</span><span class=\"n\">A.decomposition_group</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">l</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">convert</span> <span class=\"n\">set.smul_mem_smul_set</span> <span class=\"n\">h</span> <span class=\"n\">using</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">congr_arg</span> <span class=\"n\">coe</span> <span class=\"n\">g.prop.symm</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 298183618,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662849180
    },
    {
        "content": "<p>It also generalizes to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">valuation_subring.sub_mul_action</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">mul_semiring_action</span> <span class=\"n\">G</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">sub_mul_action</span> <span class=\"o\">(</span><span class=\"n\">mul_action.stabilizer</span> <span class=\"n\">G</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">l</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">set.mem_of_mem_of_subset</span> <span class=\"o\">(</span><span class=\"n\">set.smul_mem_smul_set</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">g.prop.le</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 298184386,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662849858
    },
    {
        "content": "<p>Or even more generally</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Any set is stable under its stabilizer. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">set.to_stabilizer_sub_mul_action</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">G</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">sub_mul_action</span> <span class=\"o\">(</span><span class=\"n\">mul_action.stabilizer</span> <span class=\"n\">G</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">l</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">set.mem_of_mem_of_subset</span> <span class=\"o\">(</span><span class=\"n\">set.smul_mem_smul_set</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">g.prop.le</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 298184591,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662850106
    },
    {
        "content": "<p>I think that <code>decomposition_group</code> needs a definition of some kind because it's a fundamental object in number theory. Here is my proposed development:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">valuation_subring</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">decomposition_group</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">subgroup.opposite.symm</span> <span class=\"o\">(</span><span class=\"n\">mul_action.stabilizer</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_decomposition_group'</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">∈</span> <span class=\"n\">A.decomposition_group</span> <span class=\"n\">K</span> <span class=\"bp\">↔</span>\n    <span class=\"n\">mul_opposite.op</span> <span class=\"n\">g</span> <span class=\"bp\">∈</span> <span class=\"n\">mul_action.stabilizer</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_decomposition_group</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">g</span> <span class=\"bp\">∈</span> <span class=\"n\">A.decomposition_group</span> <span class=\"n\">K</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sub_mul_action</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">valuation_subring</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">sub_mul_action</span> <span class=\"o\">(</span><span class=\"n\">A.decomposition_group</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">⟩</span> <span class=\"n\">l</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">l</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">valuation_subring</span>\n</code></pre></div>\n<p>Eric: Michail is my new PhD student and he's learning Lean right now. Don't give too many spoilers! He's supposed to be learning Lean this way! Michail: perhaps we should stop having these conversations in public, although I think Eric's idea of an <code>abbreviation</code> is probably better than mine.</p>",
        "id": 298185654,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1662851269
    },
    {
        "content": "<p>Ah, if the goal is to learn lean, it might be a useful exercise to prove that <code>mul_action.stabilizer (L ≃ₐ[K] L) A</code> is equal to the more complicated <code>subgroup.opposite.symm (mul_action.stabilizer (L ≃ₐ[K] L)ᵐᵒᵖ A)</code>, so that dropping the latter in favor of the former feels justified!</p>",
        "id": 298185763,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662851389
    },
    {
        "content": "<p>One thing I see in Eric's code is that we now have a left action of G on the valuation subrings?</p>",
        "id": 298185819,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1662851415
    },
    {
        "content": "<p>Yes, that's mentioned higher up in this thread (<a href=\"#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/294787870\">here</a>)</p>",
        "id": 298185841,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662851431
    }
]
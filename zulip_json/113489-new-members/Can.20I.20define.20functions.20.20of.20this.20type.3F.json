[
    {
        "content": "<p>I need to reason about partially defined functions. I'm using  sub<br>\ntypes to represent domains. I can quite happily pass<br>\naround proofs that you have elements in the subtype to show that the<br>\nfunction applications make sense. </p>\n<p>I have a structure representing families of partial assignments indexed by a<br>\nType <code>S</code>. The thing that makes this harder/more interesting is that<br>\nthe codomain of assign depends on the type S and the function<br>\n<code>carrier</code> that maps elements of <code>S</code> into some type.</p>\n<p>Essentially it looks like this :-</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">variable</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">variable</span> <span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">assignment</span>   <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">domain</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">assign</span>  <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span>    <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span>    <span class=\"bp\">//</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">domain</span> <span class=\"o\">}</span> <span class=\"bp\">→</span>  <span class=\"o\">(</span><span class=\"n\">carrier</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">)</span>\n</code></pre></div>\n<p>Abstractly it seems to do the job that I want and I can even produce<br>\nsome of the proofs that I need, but I was trying to do some testing<br>\nand work on some concrete instances when I got stuck. My question is<br>\nthis, using Lean can I actually define concrete functions (using<br>\n<code>def</code>) of type <code>(assign (s:S) : {v : V // (v,s) ∈ domain } → (carrier\ns) )</code>?</p>\n<p>I suppose the real question is: Is there a better way of doing this?</p>",
        "id": 250351192,
        "sender_full_name": "Justin Pearson",
        "timestamp": 1629725334
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">assign</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">//</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">domain</span> <span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">carrier</span>\n<span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>is such a function</p>",
        "id": 250352400,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1629725875
    },
    {
        "content": "<p>Of course if <code>carrier s = empty</code> and <code>domain = set.univ</code> then the <code>sorry</code> is impossible to fill out, but in a concrete case you would presumably be thinking of a particular compatible pair of domain and carrier</p>",
        "id": 250352601,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1629725973
    },
    {
        "content": "<p>Even when <code>V</code> and <code>S</code> are inductive types with a finite number of elements, I'm at a lose on how to define more useful functions that the <code>sorry</code> case. I just don't understand enough of lean's syntax to define a specific function.</p>",
        "id": 250353453,
        "sender_full_name": "Justin Pearson",
        "timestamp": 1629726354
    },
    {
        "content": "<p>I am no expert, but as far as I understand the standard wisdom regarding design is that in many cases it is better to not use hypotheses on arguments (e.g. in the form of subtypes) in the types of functions, but rather defining functions to be total and return some junk values on wrong arguments and only require the hypotheses in lemmas about the functions. For example, division by zero is defined in Lean, and the divisor is only required to be nonzero in lemmas</p>",
        "id": 250354428,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1629726773
    },
    {
        "content": "<p>Another alternative is using <code>option</code> valued functions to represent partial functions</p>",
        "id": 250354521,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1629726833
    },
    {
        "content": "<p>That may or may not work for you, I think in any case it would be worth it to give some more specific examples of what kind of partial functions you want to express</p>",
        "id": 250354879,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1629727002
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/part\">docs#part</a> is intended for this kind of use. So <code>def assignment := Π (s : S), V → part (carrier s)</code>.</p>",
        "id": 250355653,
        "sender_full_name": "Reid Barton",
        "timestamp": 1629727323
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/option\">docs#option</a> is also possible, but if you are happy to pass proofs of definedness around then you will probably prefer part.</p>",
        "id": 250355917,
        "sender_full_name": "Reid Barton",
        "timestamp": 1629727432
    },
    {
        "content": "<p>Cool.  It seems to do what I want. I'll take a look at the documentation.  There even seems to be some theorems about going back and forward to option types.  I might even be able to define concrete functions when I need them.</p>",
        "id": 250356082,
        "sender_full_name": "Justin Pearson",
        "timestamp": 1629727494
    },
    {
        "content": "<p>I think it would help if you had a concrete function in mind</p>",
        "id": 250367139,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1629732182
    },
    {
        "content": "<p>I understand how option types give you partial functions. I've been writing Haskell code for more years than I care to remember. I was trying to avoid using option types, and instead carry around a proof that the values are in your domain. In terms of option types, I wanted to carry around a proof that  you are not going to produce none values to avoid lifting. Abstractly it all seems to work, and it turns out that I'm reinventing part. </p>\n<p>The computer scientist part of me, is not happy with my lean code just type checking. I wanted to do some concrete instantiations and use <code>#reduce</code> to see what is going on.  My question is partly syntactical.  Suppose that I have two finite  types </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">S</span>\n <span class=\"bp\">|</span> <span class=\"n\">s</span>\n <span class=\"bp\">|</span> <span class=\"n\">t</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">V</span>\n <span class=\"bp\">|</span> <span class=\"n\">x</span>\n <span class=\"bp\">|</span> <span class=\"n\">y</span>\n <span class=\"bp\">|</span> <span class=\"n\">z</span>\n</code></pre></div>\n<p>Suppose I want to turn the partial function :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">o_assign</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span>  <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">ℕ</span>\n <span class=\"bp\">|</span> <span class=\"n\">S.s</span> <span class=\"n\">V.x</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"mi\">1</span>\n <span class=\"bp\">|</span> <span class=\"n\">S.s</span> <span class=\"n\">V.y</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"mi\">2</span>\n <span class=\"bp\">|</span> <span class=\"n\">S.t</span> <span class=\"n\">V.z</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"mi\">2</span>\n <span class=\"bp\">|</span> <span class=\"n\">_</span>   <span class=\"n\">_</span>   <span class=\"o\">:=</span> <span class=\"n\">none</span>\n</code></pre></div>\n<p>into an instance of my above scheme : </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span>  <span class=\"n\">domain</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">S</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"o\">(</span> <span class=\"n\">V.x</span> <span class=\"o\">,</span> <span class=\"n\">S.s</span><span class=\"o\">)</span> <span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">V.y</span> <span class=\"o\">,</span> <span class=\"n\">S.s</span><span class=\"o\">)</span> <span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">V.z</span> <span class=\"o\">,</span> <span class=\"n\">S.t</span><span class=\"o\">)</span>   <span class=\"o\">}</span>\n<span class=\"kd\">def</span>  <span class=\"n\">assign</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span>    <span class=\"bp\">//</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">domain</span> <span class=\"o\">}</span>  <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Syntactically how do I write the function <code>assign</code>?  The documentation for part is a bit brief, but if I turned each subtype into an instance of <code>part set (V \\times S)</code> how would I write this? </p>\n<p>On reflection it might be easier to use option types. Instead of carrying around a proof that your elements come from your domain, I will have to have extra proof cases that when you get things of type none it was because you applied it to values not in your domain. I suppose that's what monads are for. Even so, being stubborn and I I would like to know how to use <code>part</code> in the future, I would still like to understand what is going on.</p>",
        "id": 250447271,
        "sender_full_name": "Justin Pearson",
        "timestamp": 1629787013
    },
    {
        "content": "<p>I'd expect you can use something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">assign</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">//</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">domain</span> <span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"n\">S.s</span> <span class=\"o\">⟨</span><span class=\"n\">V.x</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">S.s</span> <span class=\"o\">⟨</span><span class=\"n\">V.y</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"bp\">|</span> <span class=\"n\">S.t</span> <span class=\"o\">⟨</span><span class=\"n\">V.z</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">false.elim</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Although you might have to add more than one <code>false.elim</code> case:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">assign</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">//</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">domain</span> <span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"n\">S.s</span> <span class=\"o\">⟨</span><span class=\"n\">V.x</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">S.s</span> <span class=\"o\">⟨</span><span class=\"n\">V.y</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"bp\">|</span> <span class=\"n\">S.s</span> <span class=\"o\">⟨</span><span class=\"n\">V.z</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">false.elim</span> <span class=\"gr\">sorry</span>\n<span class=\"bp\">|</span> <span class=\"n\">S.t</span> <span class=\"o\">⟨</span><span class=\"n\">V.x</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">false.elim</span> <span class=\"gr\">sorry</span>\n<span class=\"bp\">|</span> <span class=\"n\">S.t</span> <span class=\"o\">⟨</span><span class=\"n\">V.y</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">false.elim</span> <span class=\"gr\">sorry</span>\n<span class=\"bp\">|</span> <span class=\"n\">S.t</span> <span class=\"o\">⟨</span><span class=\"n\">V.z</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n</code></pre></div>",
        "id": 250449038,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1629788658
    },
    {
        "content": "<p>That is; the equation compiler may or may not be smart enough to eliminate the impossible cases for you, so it's up to you to do so</p>",
        "id": 250449069,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1629788708
    },
    {
        "content": "<p>Having said that, this defines a provably equal function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">assign</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">//</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">domain</span> <span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"n\">S.s</span> <span class=\"o\">⟨</span><span class=\"n\">V.x</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">S.s</span> <span class=\"o\">⟨</span><span class=\"n\">V.y</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"bp\">|</span> <span class=\"n\">S.t</span> <span class=\"o\">⟨</span><span class=\"n\">V.z</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"mi\">37</span>\n</code></pre></div>",
        "id": 250451036,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1629790150
    }
]
[
    {
        "content": "<p>I am trying to prove the IMO problem 2009-6. It is basically a combinatorial problem about permuting a list of positive integers. I would like to do it according to my informal solution here <a href=\"http://www.olsak.net/mirek/grasshopper-informal\" title=\"http://www.olsak.net/mirek/grasshopper-informal\">http://www.olsak.net/mirek/grasshopper-informal</a>. I think I managed to at least formulate the problem:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">part_sums</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span>      <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">::</span><span class=\"n\">as</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"bp\">::</span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">part_sums</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">+</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">grasshopper</span> <span class=\"o\">:</span>\n  <span class=\"k\">forall</span> <span class=\"n\">jumps</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">size</span> <span class=\"o\">:=</span> <span class=\"n\">jumps</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"k\">in</span>\n  <span class=\"k\">forall</span> <span class=\"n\">mines</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span> <span class=\"n\">jumps</span><span class=\"bp\">.</span><span class=\"n\">nodup</span> <span class=\"bp\">∧</span> <span class=\"n\">mines</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">&lt;</span> <span class=\"n\">jumps</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">∧</span>\n    <span class=\"o\">(</span><span class=\"k\">forall</span> <span class=\"n\">mine</span> <span class=\"err\">∈</span> <span class=\"n\">mines</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">mine</span> <span class=\"bp\">∧</span> <span class=\"n\">mine</span> <span class=\"bp\">&lt;</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n    <span class=\"o\">(</span><span class=\"k\">forall</span> <span class=\"n\">jump</span> <span class=\"err\">∈</span> <span class=\"n\">jumps</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">jump</span><span class=\"o\">))</span>\n  <span class=\"bp\">→</span>\n  <span class=\"n\">exists</span> <span class=\"n\">jumps_l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span>\n  <span class=\"n\">jumps</span> <span class=\"bp\">~</span> <span class=\"n\">jumps_l</span> <span class=\"bp\">∧</span>\n  <span class=\"k\">forall</span> <span class=\"n\">jump</span> <span class=\"err\">∈</span> <span class=\"n\">jumps_l</span><span class=\"bp\">.</span><span class=\"n\">part_sums</span><span class=\"o\">,</span> <span class=\"k\">forall</span> <span class=\"n\">mine</span> <span class=\"err\">∈</span> <span class=\"n\">mines</span><span class=\"o\">,</span> <span class=\"n\">jump</span> <span class=\"bp\">≠</span> <span class=\"n\">mine</span>\n<span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>I tried to start writing a proof but it is in very early stages: <a href=\"http://www.olsak.net/mirek/grasshopper.lean\" title=\"http://www.olsak.net/mirek/grasshopper.lean\">http://www.olsak.net/mirek/grasshopper.lean</a>, I am just running into difficulties...<br>\nIn particular:</p>\n<ul>\n<li>One of the key steps in the proof is taking the maximum jump and keeping the rest of jumps without the maximum jump. But how to do it so that the following is as obvious as it should be:<ul>\n<li>the remaining list (set) of jumps is one smaller than the original list of jumps</li>\n<li>all the jumps in the remaining list (set) of jumps are still different.</li>\n<li>after joining the biggest jump and a permutation of remaining jumps, we get a permutation of the original jumps.</li>\n</ul>\n</li>\n<li>In the linked file I was thinking about resolving this issue by sorting the jumps first, and then just taking them from the beginning. But I don't like the approach very much, it resolves the \"taking maximum\" issue but I must keep track on sortedness.</li>\n<li>I guess there will be similar issues with taking the minimal mine in step B1 of the informal proof.</li>\n<li>I guess I will need to know that the sum does not depend on the permutation. Is it known by the library? I am not sure how to prove facts about permutations in general.</li>\n<li>Would it be better to work with integers rather than natural numbers? After all, I could get negative numbers in step 4 of the informal proof. This could be circumvented but is it worth the cost?</li>\n<li>Would it be better to define prefix sum directly as the sum of a prefix (I have done it inductively now)? Well, I use the fact that a prefix sum is a sum of a prefix in the informal proof in step B6.</li>\n</ul>\n<p>Sorry for not progressing much, I just feel lost and I would like to do it in the right way. Perhaps it would help me to see a part of the proof with some hints about how to search in Lean library for the appropriate lemmata / tactics.</p>",
        "id": 192117067,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585392106
    },
    {
        "content": "<p>Is your finite set of jumps allowed to have repeats? Looking at informal question</p>",
        "id": 192117704,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585393207
    },
    {
        "content": "<p>Can you put a link to the official version of the question?</p>",
        "id": 192117708,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585393232
    },
    {
        "content": "<p>There is a whole bunch of facts about permutations of lists in something like data.list.perm</p>",
        "id": 192117872,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585393528
    },
    {
        "content": "<p>A multiset is a list up to permutation, so the definition of the sum of a multiset will somewhere have in it the fact that sum is constant over permutations</p>",
        "id": 192117923,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585393585
    },
    {
        "content": "<p>I'm thinking, you could prove that the maximum jump is an element of the list, then use a theorem to prove <code>jumps = l1 ++ maxjump :: l2</code> and use list perm theorems to swap <code>maxjump</code> to the front</p>",
        "id": 192117931,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585393618
    },
    {
        "content": "<p>Why not just sort the list? It's not as if you'll ever run the code</p>",
        "id": 192117945,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585393676
    },
    {
        "content": "<p>It might be easier to work with multisets if you don't care about messing up the order of the remaining elements of the list</p>",
        "id": 192117997,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585393724
    },
    {
        "content": "<p>because in that case the membership implies <code>jumps = maxjump :: otherjumps</code> and so it's already at the front, the rest is one less in size and so on</p>",
        "id": 192118013,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585393777
    },
    {
        "content": "<p>I think they might even be finsets.</p>",
        "id": 192118281,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585394250
    },
    {
        "content": "<p>Thank you for the responses.<br>\nSets are for me (by definition) without repetition.<br>\nLink to original question: <a href=\"http://imo-official.org/problems/IMO2009SL.pdf\" title=\"http://imo-official.org/problems/IMO2009SL.pdf\">http://imo-official.org/problems/IMO2009SL.pdf</a>, problem C7, variant 2.<br>\nFinsets sound reasonable, where can I find how to use finsets? How to express the fact that a list is an arrangement of a finset?</p>",
        "id": 192118328,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585394306
    },
    {
        "content": "<p><a href=\"http://michaelnielsen.org/polymath1/index.php?title=Imo_2009_q6\" title=\"http://michaelnielsen.org/polymath1/index.php?title=Imo_2009_q6\">http://michaelnielsen.org/polymath1/index.php?title=Imo_2009_q6</a></p>",
        "id": 192118336,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585394360
    },
    {
        "content": "<p>Is there a module docstring in data/finset.lean?</p>",
        "id": 192118390,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585394415
    },
    {
        "content": "<p>Finset just means finite set. The jumps are distinct so a finset would work</p>",
        "id": 192118400,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585394468
    },
    {
        "content": "<p>if <code>s : finset A</code> and <code>l : list A</code>, then <code>s.1 = l</code>says that the underlying multiset of <code>s</code> agrees with <code>l</code></p>",
        "id": 192118525,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585394709
    },
    {
        "content": "<p>I'm not sure finsets are better than multisets here, though</p>",
        "id": 192118528,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585394731
    },
    {
        "content": "<p>Maybe it jumps should be sets and mines multisets?</p>",
        "id": 192118571,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585394778
    },
    {
        "content": "<p>Even if they are without duplicates, if this isn't important or not easily true by definition there will be extra functions in the way erasing duplicates and such</p>",
        "id": 192118572,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585394778
    },
    {
        "content": "<p>looks like that will work, given your statement</p>",
        "id": 192118631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585394909
    },
    {
        "content": "<p>OK, I will try to rewrite the problem with finsets / multisets, by the way, what about the prefixes, is there a simple way for quantification over prefixes of a list?</p>",
        "id": 192118641,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585394956
    },
    {
        "content": "<p>You can write it as a sum of a prefix like you said, but I'm not sure it's that much better</p>",
        "id": 192118690,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585395004
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">inits</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">])</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"c1\">-- [0,1,3,6]</span>\n</pre></div>",
        "id": 192118703,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585395073
    },
    {
        "content": "<p>Second formulation, I will try the proving later.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">grasshopper</span> <span class=\"o\">:</span>\n  <span class=\"k\">forall</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span>\n  <span class=\"k\">forall</span> <span class=\"n\">jumps</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"bp\">ℤ</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"k\">forall</span> <span class=\"n\">jump</span> <span class=\"err\">∈</span> <span class=\"n\">jumps</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">jump</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">jumps</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"k\">let</span> <span class=\"n\">size</span> <span class=\"o\">:=</span> <span class=\"n\">jumps</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"k\">in</span>\n  <span class=\"k\">forall</span> <span class=\"n\">mines</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"bp\">ℤ</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">mines</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"k\">forall</span> <span class=\"n\">mine</span> <span class=\"err\">∈</span> <span class=\"n\">mines</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">mine</span> <span class=\"bp\">∧</span> <span class=\"n\">mine</span> <span class=\"bp\">&lt;</span> <span class=\"n\">size</span><span class=\"o\">)</span>\n  <span class=\"bp\">→</span>\n  <span class=\"n\">exists</span> <span class=\"n\">jumps_l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"bp\">ℤ</span><span class=\"o\">,</span>\n  <span class=\"n\">jumps</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">jumps_l</span> <span class=\"bp\">∧</span>\n  <span class=\"k\">forall</span> <span class=\"n\">jumps_pref</span> <span class=\"err\">∈</span> <span class=\"n\">jumps_l</span><span class=\"bp\">.</span><span class=\"n\">inits</span><span class=\"o\">,</span>\n  <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"n\">jumps_pref</span> <span class=\"err\">∉</span> <span class=\"n\">mines</span>\n</pre></div>",
        "id": 192120382,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585397772
    },
    {
        "content": "<p>What is the way for retrieving maximum from a finset / multiset?</p>",
        "id": 192131379,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585413985
    },
    {
        "content": "<p><code>finset.max</code></p>",
        "id": 192139690,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1585426527
    },
    {
        "content": "<p>And then taking the set of remaining elements?</p>",
        "id": 192141193,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585428961
    },
    {
        "content": "<p>Sorry for stupid questions, is there a documentation that I could use instead of asking about every particular command?</p>",
        "id": 192141244,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585429051
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/grasshopper.20problem/near/192118013\" title=\"#narrow/stream/113489-new-members/topic/grasshopper.20problem/near/192118013\">said</a>:</p>\n<blockquote>\n<p>because in that case the membership implies <code>jumps = maxjump :: otherjumps</code> and so it's already at the front, the rest is one less in size and so on</p>\n</blockquote>\n<p>I think this should be the answer but I don't understand how to obtain the otherjumps from it. How to write something like</p>\n<div class=\"codehilite\"><pre><span></span>let maxjump := jumps.max in\nlet otherjumps := SUCH THAT jumps = maxjump :: otherjumps in\n...\n</pre></div>",
        "id": 192141471,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585429433
    },
    {
        "content": "<p>No problem, this chat is for asking questions! So don't worry about it.<br>\nThe doc for finset is here <a href=\"https://leanprover-community.github.io/mathlib_docs/data/finset.html\" title=\"https://leanprover-community.github.io/mathlib_docs/data/finset.html\">https://leanprover-community.github.io/mathlib_docs/data/finset.html</a> .</p>",
        "id": 192141666,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1585429748
    },
    {
        "content": "<p>As for the remaining elements you could use <code>finset.erase</code></p>",
        "id": 192141809,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1585429942
    },
    {
        "content": "<p>If you want to learn how to use blah's in lean then you kind of want to hope that blah.lean has got some documentation at the beginning. If it hasn't then you can do worse than just going through the file reading the definitions and theorem statements (but not the proofs)</p>",
        "id": 192144414,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585434293
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133339\">@Miroslav Olšák</span> The theorem I was talking about was <code>multiset.exists_cons_of_mem</code>, which you can destruct to get <code>otherjumps</code></p>",
        "id": 192144652,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585434705
    },
    {
        "content": "<p>Hm... I am just running into problems. </p>\n<ul>\n<li><code>jumps.max </code> is an option type, and I need to convince Lean that the maxjump really exist (because <code>finset.card jumps = nat.succ n</code>)</li>\n<li>When looking at how to prove that it actually exists, I noticed a slight difference between the mathlib version in the documentation and the version I have on my computer. In particular, I don't have the predicate finset.nonempty, and there is used just <code>s ≠ ∅</code> instead. I tried to run mathlib-update but without effect. The update looks unnecessary for now but I would preffer to have an up to date library. After trying the update-mathlib script a few times (without effect), it is complaining about \"Github API rate limit exceeded.\" :-/</li>\n<li>I will need to know that <code>maxjump ∈ jumps</code>. This should be possible to accomplish using finset.mem_of_max but how to translate it to the fact that <code>maxjump ∈ jumps.1</code> to use <code>multiset.exists_cons_of_mem</code>?</li>\n</ul>\n<p>By the way, I know I can read the sources, which I usually do, I just hoped for a better way. However, the documentation does not seem much different from the sources after all.</p>",
        "id": 192146402,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585437560
    },
    {
        "content": "<p>The update-mathlib script has been superceded by <code>leanproject</code></p>",
        "id": 192146793,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585438221
    },
    {
        "content": "<p><code>maxjump ∈ jumps</code> and <code>maxjump ∈ jumps.1</code> should be defeq</p>",
        "id": 192146818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585438273
    },
    {
        "content": "<p>You can prove <code>jumps ≠ ∅</code> (or <code>jumps.nonempty</code>) by contradiction: if <code>jumps = ∅</code> then <code>finset.card jumps = 0</code></p>",
        "id": 192146910,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585438417
    },
    {
        "content": "<p>you can also use <code>finset.card_pos</code></p>",
        "id": 192146954,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585438472
    },
    {
        "content": "<p>I still don't get how to prove <code>maxjump ∈ jumps.1</code> from <code>maxjump ∈ jumps</code> (<code>maxjump_in_ms</code> from <code>maxjump_in</code>). I managed to get the maximum in the end, but I am not sure if it is the standard way. Here is my testing code.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">:</span>\n  <span class=\"k\">forall</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span>\n  <span class=\"k\">forall</span> <span class=\"n\">jumps</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"bp\">ℤ</span><span class=\"o\">,</span>\n  <span class=\"n\">jumps</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"bp\">→</span>\n  <span class=\"n\">jumps</span> <span class=\"bp\">=</span> <span class=\"n\">jumps</span> <span class=\"c1\">-- irrelevant corollary, just for testing</span>\n<span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intros</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">jumps</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">],</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">jumps</span><span class=\"bp\">.</span><span class=\"n\">nonempty</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">exact</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">card_pos</span><span class=\"bp\">.</span><span class=\"n\">elim_left</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">max_of_nonempty</span> <span class=\"n\">this</span> <span class=\"k\">with</span> <span class=\"n\">maxjump</span> <span class=\"n\">maxjump_ex</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">maxjump_in</span> <span class=\"o\">:</span> <span class=\"n\">maxjump</span> <span class=\"err\">∈</span> <span class=\"n\">jumps</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">exact</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_of_max</span> <span class=\"n\">maxjump_ex</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">maxjump_in_ms</span> <span class=\"o\">:</span> <span class=\"n\">maxjump</span> <span class=\"err\">∈</span> <span class=\"n\">jumps</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">exists_cons_of_mem</span> <span class=\"n\">maxjump_in_ms</span> <span class=\"k\">with</span> <span class=\"n\">otherjumps</span> <span class=\"n\">otherjumps_ex</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span> <span class=\"c1\">-- proving the irrelevant corollary</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 192181393,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585497924
    },
    {
        "content": "<p>Can you post a mwe?</p>",
        "id": 192181468,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585498046
    },
    {
        "content": "<p>mwe?</p>",
        "id": 192181613,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585498212
    },
    {
        "content": "<p>what does it mean?</p>",
        "id": 192181645,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585498306
    },
    {
        "content": "<p>MWE = minimal working example. Basically, include all the parts of your file needed (imports, other definitions) so that we can copy+paste it into our editors and see the same thing as you.</p>",
        "id": 192181752,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1585498455
    },
    {
        "content": "<p>Minimum working example so I can just cut and paste and see your problem on my computer</p>",
        "id": 192181754,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585498462
    },
    {
        "content": "<p>OK, above the code I pasted is just</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finset</span>\n</pre></div>",
        "id": 192181770,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585498502
    },
    {
        "content": "<p>I want to replace the <code>sorry</code> by something else</p>",
        "id": 192181804,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585498536
    },
    {
        "content": "<p>I could make it more minimal, I guess, if it will help.</p>",
        "id": 192181887,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585498636
    },
    {
        "content": "<p>Simply <code>by exact maxjump_in,</code></p>",
        "id": 192182051,
        "sender_full_name": "Reid Barton",
        "timestamp": 1585498835
    },
    {
        "content": "<p>It works... Hm, I really thought I tried that.</p>",
        "id": 192182167,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585498959
    },
    {
        "content": "<p>By the way, would it be possible to somehow use it directly in <code>multiset.exists_cons_of_mem</code>?</p>",
        "id": 192182287,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585499154
    },
    {
        "content": "<p>And I have one more debugging question. Sometimes, I would like to check a type of an expression in the current context but <code>#check</code> appears to not have access to the proving context. Is there another way?</p>",
        "id": 192182354,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585499273
    },
    {
        "content": "<p>something like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n<span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">n</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 192182413,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585499359
    },
    {
        "content": "<p><code>#check</code> is a top-level command. You could try something like <code>have temp := n</code>, then look at the tactic state for the type of <code>temp</code></p>",
        "id": 192182514,
        "sender_full_name": "Reid Barton",
        "timestamp": 1585499520
    },
    {
        "content": "<p>We should have a tactic to do that, this is a very reasonable question.</p>",
        "id": 192182666,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1585499691
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>  recently added <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#show_term\" title=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#show_term\"><code>show_term</code></a>, so maybe we should add <code>show_type</code>.</p>",
        "id": 192182975,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1585500115
    },
    {
        "content": "<p>I was going to suggest the name <code>check</code></p>",
        "id": 192183057,
        "sender_full_name": "Reid Barton",
        "timestamp": 1585500216
    },
    {
        "content": "<p>Oh, then we could rename <code>show_term</code> to <code>print</code>, which surprisingly isn't taken.</p>",
        "id": 192183113,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1585500264
    },
    {
        "content": "<p>These are great ideas. I know tricks now but when I was a beginner I was always wanting these kinds of things</p>",
        "id": 192183132,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585500302
    },
    {
        "content": "<p>I even wanted this today but just put pp.all on and read what I wanted from the output. Imagine trying to tell a beginner to do that</p>",
        "id": 192183163,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585500354
    },
    {
        "content": "<p><code>show_term</code> doesn't really align with <code>print</code> in quite the same way, though.</p>",
        "id": 192183257,
        "sender_full_name": "Reid Barton",
        "timestamp": 1585500396
    },
    {
        "content": "<p>Now I wonder, is it possible to run <code>set_option</code> from inside a tactic?</p>",
        "id": 192183270,
        "sender_full_name": "Reid Barton",
        "timestamp": 1585500420
    },
    {
        "content": "<p>I believe this isn't possible currently</p>",
        "id": 192183277,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585500435
    },
    {
        "content": "<p>I'm pretty sure I've tried it before</p>",
        "id": 192183289,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585500447
    },
    {
        "content": "<p>Kevin, Reid means \"from inside a tactic\", not \"from a tactic block\"</p>",
        "id": 192183303,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1585500467
    },
    {
        "content": "<p>In which case I retract my assertion about having tried it before</p>",
        "id": 192183361,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585500506
    },
    {
        "content": "<p>That's what I thought...</p>",
        "id": 192183369,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1585500539
    },
    {
        "content": "<p>Right, I mean can we write a tactic which is a substitute for the top-level command <code>set_option</code> (and presumably would set an option only for the remainder of the current definition... I'm not really sure how much sense this idea makes).</p>",
        "id": 192183376,
        "sender_full_name": "Reid Barton",
        "timestamp": 1585500555
    },
    {
        "content": "<p>If the only goal is to set <code>pp</code> options then I'm sure the meta function can take relevant arguments, without going through the set_option machinery</p>",
        "id": 192183430,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1585500605
    },
    {
        "content": "<p>I think there is; look for uses of the <code>options</code> structure</p>",
        "id": 192195798,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585518554
    },
    {
        "content": "<p>What am I doing wrong?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finset</span>\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"n\">finset</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"bp\">ℤ</span><span class=\"o\">),</span> <span class=\"n\">x</span><span class=\"bp\">-</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">:</span><span class=\"bp\">ℤ</span><span class=\"o\">)))</span> <span class=\"n\">X</span>\n</pre></div>\n\n\n<p>Gives error</p>\n<div class=\"codehilite\"><pre><span></span>type mismatch at application\n  finset.map (λ (x : ℤ), x - 5)\nterm\n  λ (x : ℤ), x - 5\nhas type\n  ℤ → ℤ : Type\nbut is expected to have type\n  ?m_1 ↪ ?m_2 : Type (max ? ?)\n</pre></div>\n\n\n<p>Note that with multisets it works just fine.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"n\">multiset</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">multiset</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"bp\">ℤ</span><span class=\"o\">),</span> <span class=\"n\">x</span><span class=\"bp\">-</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">:</span><span class=\"bp\">ℤ</span><span class=\"o\">))</span> <span class=\"n\">X</span>\n</pre></div>",
        "id": 192220431,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585553925
    },
    {
        "content": "<p><code>finset.map</code> takes an <code>embedding</code>, which is an injective function</p>",
        "id": 192220715,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585554103
    },
    {
        "content": "<p>if you don't care about having to deduplicate the list afterward, possibly changing the size of the set, then use <code>finset.image</code> instead</p>",
        "id": 192220775,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585554135
    },
    {
        "content": "<p>(notice that the arrow in the error message is hooked, that's not a regular arrow)</p>",
        "id": 192220803,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585554172
    },
    {
        "content": "<p>I see</p>",
        "id": 192220868,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585554229
    },
    {
        "content": "<p>well, it is a bijection, but I think <code>finset.image</code> will be simpler here</p>",
        "id": 192221025,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585554324
    },
    {
        "content": "<p>Now, I want to split a finset (<code>mines</code>) into two parts according to whether the element is smaller than <code>maxjump</code> or not. I am thinking of constructing them using <code>finset.filter</code>, proving that the parts are disjoint, that their union is the original <code>mines</code>, and finaly proving that the sum of the sizes of the two parts is equal to <code>mines.card</code> using <code>finset.card_union_add_card_inter</code>. Is there a more straightforward way for partitioning a finset (and keeping track on its size)?</p>",
        "id": 192222059,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585555065
    },
    {
        "content": "<p>I think these should have you covered:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">filter_union_filter_neg_eq</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"n\">p</span> <span class=\"err\">∪</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">filter_not</span><span class=\"o\">,</span> <span class=\"n\">union_sdiff_of_subset</span> <span class=\"o\">(</span><span class=\"n\">filter_subset</span> <span class=\"n\">s</span><span class=\"o\">)]</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">filter_inter_filter_neg_eq</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"n\">p</span> <span class=\"err\">∩</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"err\">∅</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">filter_not</span><span class=\"o\">,</span> <span class=\"n\">inter_sdiff_self</span><span class=\"o\">]</span>\n</pre></div>",
        "id": 192223932,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585556177
    },
    {
        "content": "<p>Now, I am trying to prove a basic fact about the remaining jumps. However, I am not sure how to relate the fact <code>jumps.val = maxjump :: jumps_res.val</code> to the sum of a multiset. Actually, I don't even understand where the <code>multiset.sum</code> comes from and how to handle setoids. MWE:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">maxjump</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">,</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">jumps</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"bp\">ℤ</span><span class=\"o\">,</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">jumps_res</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"bp\">ℤ</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">size</span> <span class=\"o\">:=</span> <span class=\"n\">jumps</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"k\">in</span>\n  <span class=\"k\">let</span> <span class=\"n\">size_res</span> <span class=\"o\">:=</span> <span class=\"n\">jumps_res</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"k\">in</span>\n  <span class=\"n\">jumps</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"n\">maxjump</span> <span class=\"bp\">::</span> <span class=\"n\">jumps_res</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">→</span>\n  <span class=\"n\">size_res</span> <span class=\"bp\">=</span> <span class=\"n\">size</span> <span class=\"bp\">-</span> <span class=\"n\">maxjump</span>\n<span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intros</span><span class=\"o\">,</span>\n  <span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 192288234,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585588789
    },
    {
        "content": "<p>You are going to need a lemma which says <code>multiset.sum (a :: L) = a + multiset.sum L</code></p>",
        "id": 192299298,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585593491
    },
    {
        "content": "<p>and you should be able to find that in <code>multiset.lean</code>, soon after <code>sum</code> is defined.</p>",
        "id": 192299337,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585593515
    },
    {
        "content": "<p>and it will be called something like <code>multiset.sum_cons</code> if it's there</p>",
        "id": 192299362,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585593528
    },
    {
        "content": "<p>These <code>let</code>s are really hard to work with :-(</p>",
        "id": 192299413,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585593562
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finset</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">maxjump</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">,</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">jumps</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"bp\">ℤ</span><span class=\"o\">,</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">jumps_res</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"bp\">ℤ</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">size</span> <span class=\"o\">:=</span> <span class=\"n\">jumps</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"k\">in</span>\n  <span class=\"k\">let</span> <span class=\"n\">size_res</span> <span class=\"o\">:=</span> <span class=\"n\">jumps_res</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"k\">in</span>\n  <span class=\"n\">jumps</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"n\">maxjump</span> <span class=\"bp\">::</span> <span class=\"n\">jumps_res</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">→</span>\n  <span class=\"n\">size_res</span> <span class=\"bp\">=</span> <span class=\"n\">size</span> <span class=\"bp\">-</span> <span class=\"n\">maxjump</span>\n<span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intros</span><span class=\"o\">,</span>\n  <span class=\"k\">show</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"n\">jumps_res</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"n\">jumps</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">-</span> <span class=\"n\">maxjump</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">sum_cons</span><span class=\"o\">,</span>\n  <span class=\"n\">ring</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 192299600,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585593660
    },
    {
        "content": "<p>Note that I guessed the name of the lemma you wanted without knowing anything about multisets.</p>",
        "id": 192299629,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585593682
    },
    {
        "content": "<p>Well, it was tricky because multiset.sum_cons is not directly defined in multiset.lean. Then one have to just guess a name and hope...</p>",
        "id": 192301144,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585594379
    },
    {
        "content": "<p>Its actually <code>prod_cons</code> with a <code>to_additive</code> tag.</p>",
        "id": 192301968,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1585594705
    },
    {
        "content": "<p>Which automatically turns lemmas about multiplicative things into additive versions.</p>",
        "id": 192302046,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1585594742
    },
    {
        "content": "<p>Ah, it is \"hidden\" in the source code but listed in the docs. I guess, I should use the docs more :-).</p>",
        "id": 192302942,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585595151
    },
    {
        "content": "<p>If you are working with <code>multiset</code> then you should look at every definition of the form <code>multiset.X</code> and read the statement of every theorem of the form <code>multiset.X</code>. Then you will have a feeling for how to use multisets.</p>",
        "id": 192304407,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585595933
    },
    {
        "content": "<p>Don't worry about reading the proofs though. The proofs are irrelevant -- in fact every theorem you see will be of a trivial nature and you will be able to prove it in your head.</p>",
        "id": 192304480,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585595975
    },
    {
        "content": "<p>The idea is that you should prove harder theorems about multisets using the basic results supplied to you by the library.</p>",
        "id": 192304519,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585595999
    },
    {
        "content": "<p>My instinct is that you should start by looking through <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/data/multiset.lean\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/data/multiset.lean\"><code>multiset.lean</code></a> and then skim through the docs.</p>",
        "id": 192304951,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585596234
    },
    {
        "content": "<p>This is currently the canonical way to learn multisets. I actually printed out multiset.lean when I was learning, and used to browse through it from time to time. Don't worry about the proofs though.</p>",
        "id": 192305057,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585596273
    },
    {
        "content": "<p>Yes, however looking at <code>multiset.lean</code> was not much helpful in this case (which is basically why I struggled with it). Just later I realized that the docs could help (although they originally seemed to me almost identical to the source code).</p>",
        "id": 192305425,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585596445
    },
    {
        "content": "<p>I was just looking through the lean file again. I agree it's very difficult to read. There are a whole bunch of trivial things which are set up which just look confusing and are mathematically irrelevant. Maybe the docs are easier to read?</p>",
        "id": 192305569,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585596504
    },
    {
        "content": "<p>As I'm sure you realise, <code>multiset.card</code> is the definition, and then <code>multiset.card_join</code> etc are the theorems.</p>",
        "id": 192305653,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585596545
    },
    {
        "content": "<p>Having looked at the docs I think the most sensible approach to learn how to use multisets is to read all the definitions and then just glance through some of the theorems to get an idea of what is there. An interesting game which would teach you something would be to read the definition then take a look at some of the theorem names and guess what the statement of the theorem is</p>",
        "id": 192307078,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585597176
    },
    {
        "content": "<p>And then click to find out</p>",
        "id": 192307100,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585597189
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/grasshopper.20problem/near/192220775\" title=\"#narrow/stream/113489-new-members/topic/grasshopper.20problem/near/192220775\">said</a>:</p>\n<blockquote>\n<p>if you don't care about having to deduplicate the list afterward, possibly changing the size of the set, then use <code>finset.image</code> instead</p>\n</blockquote>\n<p>I don't care about possible shrinking of the set, however, I cannot find even a lemma for inequality:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">card_image_le</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">image</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">≤</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">card</span>\n</pre></div>\n\n\n<p>Is there something like that? If not, proving injectivity will be probably easier.</p>",
        "id": 192321095,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585604541
    },
    {
        "content": "<p>Is it called finset.card_image or image_card?</p>",
        "id": 192325064,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585606930
    },
    {
        "content": "<p>It seems like the sort of thing which would be in the library</p>",
        "id": 192325104,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585606962
    },
    {
        "content": "<p>Yeah you're right, I can't find it in the docs. You should change int to a general type alpha and post in #maths with a title such as finset.card_image_le and see if you can get someone to fill it in</p>",
        "id": 192325636,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585607363
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> could probably tell us. I guess it could be proved using <code>multiset.card_le_of_le</code> and <code>multiset.erase_dup_le</code> but it is not worth it in my case since equality can be handled more easily, and my f is just a subtraction of a constant.</p>",
        "id": 192326476,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585607993
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finset</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">multiset</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">to_finset_card_le</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">≤</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">:=</span>\n<span class=\"n\">card_le_of_le</span> <span class=\"o\">(</span><span class=\"n\">erase_dup_le</span> <span class=\"bp\">_</span><span class=\"o\">)</span>\n<span class=\"kn\">end</span> <span class=\"n\">multiset</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">finset</span>\n<span class=\"kn\">open</span> <span class=\"n\">multiset</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">card_image_le</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">card</span> <span class=\"o\">(</span><span class=\"n\">image</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">card</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card_map</span><span class=\"o\">]</span> <span class=\"kn\">using</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finset_card_le</span>\n<span class=\"kn\">end</span> <span class=\"n\">finset</span>\n</pre></div>",
        "id": 192337011,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585617875
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/2295\" title=\"https://github.com/leanprover-community/mathlib/issues/2295\">#2295</a></p>",
        "id": 192338237,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585619348
    },
    {
        "content": "<p>Isn't it amazing how these people can get the proofs onto one line?</p>",
        "id": 192353003,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585639717
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133339\">@Miroslav Olšák</span> this has now been merged so if you update your project with <code>leanproject up</code> then you will have access to <code>finset.card_image_le</code>.</p>",
        "id": 192443768,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585685793
    },
    {
        "content": "<p>So I have written the \"trivial case\" of the Grasshopper problem:  <a href=\"https://github.com/mirefek/my-lean-experiments/blob/master/grasshopper.lean\" title=\"https://github.com/mirefek/my-lean-experiments/blob/master/grasshopper.lean\">https://github.com/mirefek/my-lean-experiments/blob/master/grasshopper.lean</a>. Suggestions are welcomed.</p>",
        "id": 192649079,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585825195
    },
    {
        "content": "<p>Now, I tried a different IMO problem, and I think I have some issues with \"decidability\". Universal quantivifacion on arrays seems not to have the <code>decidable</code> type class, while it works with lists... Is there a reason for that, or is it some sort of bug?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">seq</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">l</span> <span class=\"err\">∈</span> <span class=\"n\">seq</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- works</span>\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">seq</span> <span class=\"o\">:</span> <span class=\"n\">array</span> <span class=\"mi\">5</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">l</span> <span class=\"err\">∈</span> <span class=\"n\">seq</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- error</span>\n</pre></div>\n\n\n<p>And by the way, could I just tell Lean that I don't care about decidability because I work in classical logic, so that it will not miss any <code>decidable</code> predicate anywhere?</p>",
        "id": 192859017,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585945322
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Miroslav Olšák</span> <a href=\"#narrow/stream/113489-new-members/topic/grasshopper.20problem/near/192859017\" title=\"#narrow/stream/113489-new-members/topic/grasshopper.20problem/near/192859017\">said</a>:</p>\n<blockquote>\n<p>Now, I tried a different IMO problem, and I think I have some issues with \"decidability\". Universal quantivifacion on arrays seems not to have the <code>decidable</code> type class, while it works with lists... Is there a reason for that, or is it some sort of bug?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">seq</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">l</span> <span class=\"err\">∈</span> <span class=\"n\">seq</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- works</span>\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">seq</span> <span class=\"o\">:</span> <span class=\"n\">array</span> <span class=\"mi\">5</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">l</span> <span class=\"err\">∈</span> <span class=\"n\">seq</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- error</span>\n</pre></div>\n\n\n<p>And by the way, could I just tell Lean that I don't care about decidability because I work in classical logic, so that it will not miss any <code>decidable</code> predicate anywhere?</p>\n</blockquote>\n<p>What you want is <code>local attribute [instance] classical.prop_decidable</code> I believe in your file.</p>",
        "id": 192859328,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1585945494
    },
    {
        "content": "<p>It'll enable decidability for all propositions.</p>",
        "id": 192859344,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1585945504
    },
    {
        "content": "<p>The modern way of saying that is <code>open_locale classical</code></p>",
        "id": 192860818,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1585946285
    },
    {
        "content": "<p>(Beware this cannot be written right after the import because the parser doesn't know <code>open_locale</code> is not the name of a file to import)</p>",
        "id": 192860862,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1585946322
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Miroslav Olšák</span> <a href=\"#narrow/stream/113489-new-members/topic/grasshopper.20problem/near/192649079\" title=\"#narrow/stream/113489-new-members/topic/grasshopper.20problem/near/192649079\">said</a>:</p>\n<blockquote>\n<p>So I have written the \"trivial case\" of the Grasshopper problem:  <a href=\"https://github.com/mirefek/my-lean-experiments/blob/master/grasshopper.lean\" title=\"https://github.com/mirefek/my-lean-experiments/blob/master/grasshopper.lean\">https://github.com/mirefek/my-lean-experiments/blob/master/grasshopper.lean</a>. Suggestions are welcomed.</p>\n</blockquote>\n<p>Your</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">lt_of_le_ne</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>-- you are thinking about things the wrong way. This is a standard fact, therefore it's in the library, but you are a newcomer so you don't know all the naming conventions. So how do you find it? Answer: <code>:= by library_search</code>, which tells you that this is already there, and is called <code>lt_of_le_of_ne</code> (note the naming convention :-) )</p>",
        "id": 192862626,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585947294
    },
    {
        "content": "<p>Can I also get rid of the warnings that I am using classical logic? By the way, <code>open_locale classical</code> works better because it puts the warning only where it actually needs classical. The other option, <code>local attribute [instance] classical.prop_decidable</code>, puts these warnings almost everywhere.</p>",
        "id": 192862702,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585947322
    },
    {
        "content": "<p>Just put</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">noncomputable</span> <span class=\"n\">theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n</pre></div>\n\n\n<p>at the top of your file and you should never get any warnings about constructive or computable issues.</p>",
        "id": 192862875,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585947368
    },
    {
        "content": "<p>Oh, library_search is interesting, no idea how it works. It told me that injectivity of subtraction can be proved <code>from λ {b c_1 : ℤ}, (add_right_inj (-c)).mp</code></p>",
        "id": 192863831,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585947884
    },
    {
        "content": "<p>Its amazing, definitely my most used non-core tactic. But sometimes the terms are ... interesting</p>",
        "id": 192864059,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1585948023
    },
    {
        "content": "<p>There is an option to view several suggestions I believe, so that maybe the second or third is better</p>",
        "id": 192864108,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1585948057
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">finset_rest</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"bp\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x_in_s</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"bp\">ℤ</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n<span class=\"o\">:=</span>\n</pre></div>\n\n\n<p>My guess is that you should not be proving this lemma. We already have the function you want -- and better, it's not some abstract existence statement, it's concrete. It's called <code>finset.erase s x</code>, and just after its definition there are 19 theorems proved about it. You are breaking the interface by starting to talk about multisets -- as a mathematician you should not really need to look at <code>s.val</code> for <code>s</code> a finset.</p>",
        "id": 192864607,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585948369
    },
    {
        "content": "<p>Maybe now this is the <code>suggest</code> tactic instead of an option for library search im thinking of.</p>",
        "id": 192864660,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1585948407
    },
    {
        "content": "<p>Similarly do you really need <code>finset_cons_subset</code>? Why is <code>finset.subset_insert</code> not enough for you? This is the version of the lemma you want within the finset interface.</p>",
        "id": 192864885,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585948528
    },
    {
        "content": "<p>Indeed running <code>def aa (a b c :ℤ ) (h : a -b = c -b): a = c := by suggest 50</code> the second result is the one you would probably have wanted <code>sub_right_inj.mp h</code></p>",
        "id": 192864996,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1585948584
    },
    {
        "content": "<p>hm, my <code>prefix_eq_head</code> seems to not be findable by library search even in a more basic form, even though it is kind of dual to existing <code>list.prefix_cons_inj</code></p>",
        "id": 192865083,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585948647
    },
    {
        "content": "<p>I cannot really avoid multisets entirely, <code>jumps.1 = jumps_l</code> does not work wthout the <code>.1</code>.<br>\nUsing <code>multiset.exists_cons_of_mem</code> was suggested by <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> for the task of being aware that when I order the smaller set to a list, and append the erased element, the result will be an ordering of the original finset.</p>",
        "id": 192865629,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585948977
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">theorem</span><span class=\"w\"> </span><span class=\"n\">sum_filter_split</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"err\">ℤ</span><span class=\"w\"> </span><span class=\"err\">→</span><span class=\"w\"> </span><span class=\"nc\">Prop</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">decidable_pred</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">finset</span><span class=\"w\"> </span><span class=\"err\">ℤ</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"err\">λ</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"err\">¬</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">card</span><span class=\"w\"></span>\n<span class=\"o\">:=</span><span class=\"w\"></span>\n<span class=\"n\">begin</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"err\">λ</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"err\">¬</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">have</span><span class=\"w\"> </span><span class=\"n\">inter_empty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"err\">∩</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"err\">∅</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">finset</span><span class=\"o\">.</span><span class=\"n\">filter_inter_filter_neg_eq</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">have</span><span class=\"w\"> </span><span class=\"n\">union_full</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"err\">∪</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">finset</span><span class=\"o\">.</span><span class=\"n\">filter_union_filter_neg_eq</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"err\">∪</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"err\">∩</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"o\">.</span><span class=\"n\">card</span><span class=\"p\">,</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>let let have have have. You are thinking forwards. Lean's proofs come out much better if you write them backwards. All the lemmas you need to prove <code>sum_filter_split</code> are already in mathlib.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">open</span> <span class=\"n\">finset</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">sum_filter_split</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span>\n<span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">card_union_add_card_inter</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">filter_union_filter_neg_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">filter_inter_filter_neg_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">card_empty</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">add_zero</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 192866039,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585949229
    },
    {
        "content": "<p>Those last two lemmas are tagged with <code>simp</code> so</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">sum_filter_split</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span>\n<span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span><span class=\"n\">card_union_add_card_inter</span><span class=\"o\">,</span> <span class=\"n\">filter_union_filter_neg_eq</span><span class=\"o\">,</span> <span class=\"n\">filter_inter_filter_neg_eq</span><span class=\"o\">],</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 192866216,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585949352
    },
    {
        "content": "<p>and then finally</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">sum_filter_split</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span>\n<span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"err\">←</span><span class=\"n\">card_union_add_card_inter</span><span class=\"o\">,</span> <span class=\"n\">filter_union_filter_neg_eq</span><span class=\"o\">,</span> <span class=\"n\">filter_inter_filter_neg_eq</span><span class=\"o\">]</span>\n</pre></div>",
        "id": 192866392,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585949443
    },
    {
        "content": "<p><code>cons_prefix</code> is <code>list.prefix_append</code></p>",
        "id": 192866575,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585949539
    },
    {
        "content": "<p>How do you do it that you don't write the <code>finset.</code> prefixes? <code>open finset</code>?</p>",
        "id": 192866763,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585949665
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>lemma l_nonneg_sum {l : list ℤ} (h1 : ∀ x ∈ l, (0:ℤ) &lt; x)\n  : l.sum ≥ 0\n</pre></div>\n\n\n<p>The data type with all the juicy lemmas about sums is <code>finset</code>. Do you really need sums of lists? Note that this lemma is suboptimal in the sense that <code>h1</code> should demand <code>0 \\le x</code> not <code>0 &lt; x</code>.</p>",
        "id": 192866940,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585949783
    },
    {
        "content": "<p>Note that we already have <code>finset.sum_nonneg</code>. Given that you don't care about the order of summation it feels to me that you could/should be using multisets or finsets here.</p>",
        "id": 192867038,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585949861
    },
    {
        "content": "<p>The lemma <code>l_nonneg_sum</code> is carefully chosen to suit <code>pref_nonneg_sum</code>, which I need later. It is mostly about lists, although it originates from a finset at the beginning. And yes, it is something I found rather annoying, I would like Lean to realize it somewhat automatically but I am not sure if it is possible.</p>",
        "id": 192867433,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585950141
    },
    {
        "content": "<p>And in some sense the most important comment: I <em>definitely</em> would not start formalising <code>grasshopper</code> like that on line 150 or so, and just launching into some huge proof. Look at the development of <code>finset.lean</code>. 99% of the proofs are just a couple of lines long. That's the style you should be aiming for. Those earlier lemmas in your file -- there are sometimes better proofs but at least your proofs are short. If you start writing some huge proof then when you get to the heart of the matter you will find that you have to wait 5 seconds after every keystroke while Lean recompiles your entire lemma again.  </p>\n<p>However this slowdown might not have happened to you yet, and it's a very \"mathematician\" thing to do -- launch into the proof and just start dealing with the issues as they arise rather than factoring them out -- so if you think it's the best way to get you to a proof then go for it :-)</p>",
        "id": 192867440,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585950144
    },
    {
        "content": "<p>Your first <code>sorry</code> has as a goal </p>\n<div class=\"codehilite\"><pre><span></span>⊢ ∃ (jumps_l : list ℤ),\n    jumps.val = ↑jumps_l ∧\n      ∀ (jumps_pref : list ℤ), jumps_pref ∈ list.inits jumps_l → list.sum jumps_pref ∉ mines\n</pre></div>\n\n\n<p>I see -- you are using lists to order the finsets. Maybe you do have to work with lists too. But there are a lot of lemmas about lists :-)</p>",
        "id": 192867643,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585950298
    },
    {
        "content": "<p>You are right, I am running into issues with speed which is annoying and slowing me down.</p>",
        "id": 192867661,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585950317
    },
    {
        "content": "<p>It is a very common issue I see at the Xena project.</p>",
        "id": 192867678,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585950338
    },
    {
        "content": "<p>But you cannot disect every proof into small lemmas.</p>",
        "id": 192867743,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585950367
    },
    {
        "content": "<p>In some sense this is formally false</p>",
        "id": 192867762,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585950379
    },
    {
        "content": "<p>Not every proof is \"Theory building\"</p>",
        "id": 192867772,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585950389
    },
    {
        "content": "<p>because every <code>have</code> you write in your proof can be factored out as a sublemma.</p>",
        "id": 192867792,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585950398
    },
    {
        "content": "<p>I'm not saying the lemmas have to be interesting. They can have names like <code>grasshoper_aux_3</code></p>",
        "id": 192867815,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585950424
    },
    {
        "content": "<p>But I have to pass all the assumptions to it.</p>",
        "id": 192867818,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585950425
    },
    {
        "content": "<p>yup</p>",
        "id": 192867824,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585950431
    },
    {
        "content": "<p>but I have seen students proving the same thing three times because they cannot be bothered to factor out a lemma.</p>",
        "id": 192867857,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585950454
    },
    {
        "content": "<p>Alright, I can try to do it this way.</p>",
        "id": 192867867,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585950467
    },
    {
        "content": "<p>In fact you don't have to pass <em>all</em> the assumptions to it, just all the ones you use.</p>",
        "id": 192867878,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585950473
    },
    {
        "content": "<p>This way it becomes easier to analyse what is going on. People don't like reading large proofs either, they are hard to follow, especially if they don't have any comments like yours don't.</p>",
        "id": 192867987,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585950523
    },
    {
        "content": "<p>Why not write the maths proof in the comments?</p>",
        "id": 192867993,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585950532
    },
    {
        "content": "<p>Here is an <a href=\"https://github.com/ImperialCollegeLondon/M4P33/blob/master/src/for_mathlib/commutative_algebra/Zariski_lemma.lean\" title=\"https://github.com/ImperialCollegeLondon/M4P33/blob/master/src/for_mathlib/commutative_algebra/Zariski_lemma.lean\">unfinished proof of Zariski's lemma</a></p>",
        "id": 192868049,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585950582
    },
    {
        "content": "<p>I am in the middle of writing it, but I am writing comments everywhere so it reads just like a maths proof.</p>",
        "id": 192868115,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585950609
    },
    {
        "content": "<p>I am used to try to avoid repetition from programming, at least when it seems reasonable. But it still felt better to prove the lemmata inside the proving context since I have access to objects which stay mostly constant during the proof.</p>",
        "id": 192869359,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585951432
    },
    {
        "content": "<p>If you have a lot of objects which stay constant during a big proof then <code>parameters</code> is useful.</p>",
        "id": 192869514,
        "sender_full_name": "Reid Barton",
        "timestamp": 1585951525
    },
    {
        "content": "<p>You don't see it in mathlib because mathlib mostly doesn't contain big proofs.</p>",
        "id": 192869541,
        "sender_full_name": "Reid Barton",
        "timestamp": 1585951545
    },
    {
        "content": "<p>Or just use <code>variables</code>. I prefer that to parameters, mostly. You still have to pass the arguments when calling functions, but you don't need to write the arguments as hypotheses of lemmas (which is the more verbose part, as you'd need to write the types). I think it's a feature that you still need to pass the arguments, as it keeps me from getting confused about what depends on what.</p>",
        "id": 192885647,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1585968468
    },
    {
        "content": "<p>It can easily be like 5x as verbose to pass the arguments though. I guess one thing that could help would be to pack everything into a structure.</p>",
        "id": 192885781,
        "sender_full_name": "Reid Barton",
        "timestamp": 1585968662
    },
    {
        "content": "<p>I don't know how I would have done something like <a href=\"https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.2/src/homotopy_theory/topological_spaces/pushout_lemmas.lean#L163\" title=\"https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.2/src/homotopy_theory/topological_spaces/pushout_lemmas.lean#L163\">https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.2/src/homotopy_theory/topological_spaces/pushout_lemmas.lean#L163</a> without parameters.</p>",
        "id": 192885833,
        "sender_full_name": "Reid Barton",
        "timestamp": 1585968729
    },
    {
        "content": "<p>... on the subject of that repository ...?</p>",
        "id": 192886076,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1585969199
    }
]
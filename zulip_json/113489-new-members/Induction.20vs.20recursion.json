[
    {
        "content": "<p>I'm still struggling to get my head around how to perform proofs by induction, sadly. I've defined the set {0..n} and am trying to prove that it's an interval in N. In Agda this is extremely easy because I can perform recursive calls, but in Lean I haven't yet been able to find a proof of the following:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">list</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">prime</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">def</span> <span class=\"n\">range</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">singleton</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">insert</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">range_closed</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">aIn</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vLess</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">range</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">range</span> <span class=\"n\">at</span> <span class=\"n\">aIn</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">aIn</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">linarith</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">range</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">range</span> <span class=\"n\">at</span> <span class=\"n\">aIn</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">aIn</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">aIn</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>\n    <span class=\"c1\">-- but the inductive hypothesis doesn&#39;t apply!</span>\n    <span class=\"n\">sorry</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">right</span><span class=\"o\">,</span>\n  <span class=\"n\">cc</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>In Agda, this is very easy; you just let it normalise your definitions, and whenever it gets stuck, you pattern-match on whatever it's stuck on, and eventually it bottoms out at a single lemma \"n is in {0..n}\" and a recursive call to <code>range_closed</code>; I can define the entire thing in 92 lines with no standard library and no thought required (<a href=\"https://gist.github.com/Smaug123/b5b2407176328756189d5f5e8918f03a\" title=\"https://gist.github.com/Smaug123/b5b2407176328756189d5f5e8918f03a\">https://gist.github.com/Smaug123/b5b2407176328756189d5f5e8918f03a</a>, actual content is lines 69 through 92), though admittedly my definition of \"finite set\" leaves much to be desired.</p>\n<p>Presumably it is similarly easy in Lean, but it doesn't match my intuition at all. I know in theory there's a way to replace my desired recursive call with an appeal to an appropriately-constructed inductive hypothesis, and I can probably find the general method if I think hard for an hour, but what's stopping Lean from doing these structurally-decreasing recursive calls itself?</p>",
        "id": 196985536,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589021459
    },
    {
        "content": "<p>can you give some hint about Agda <code>with</code>?</p>",
        "id": 196986657,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589023128
    },
    {
        "content": "<p>Is this <code>match ... with ...</code>?</p>",
        "id": 196986670,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589023161
    },
    {
        "content": "<p>Everything in your Agda code was easy to read until the last definition, where things got really weird. Maybe this is related to your problem <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 196986678,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589023188
    },
    {
        "content": "<p>What happened to <code>range_contains</code>?</p>",
        "id": 196986998,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589023619
    },
    {
        "content": "<p>I assume <code>record {}</code> is the proof of <code>True</code>?</p>",
        "id": 196987085,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589023770
    },
    {
        "content": "<p>Things are obviously going to be somewhat harder because the definition of <code>contains</code> for an actual finite set won't compute the way it does in your code, I think</p>",
        "id": 196987144,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589023827
    },
    {
        "content": "<p>Or much harder</p>",
        "id": 196987430,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589024220
    },
    {
        "content": "<p>I thought for a while your Agda proof was not correct.</p>",
        "id": 196987435,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589024228
    },
    {
        "content": "<p>The more I read it, the less I understand...</p>",
        "id": 196987495,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589024311
    },
    {
        "content": "<p>On line 86, we know <code>n</code> is <code>0</code>, <code>a</code> is not <code>0</code>, <code>v</code> is not <code>0</code>. How can we use <code>cont</code> as the proof?</p>",
        "id": 196987587,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589024452
    },
    {
        "content": "<p>Anyways, the tactic proof can be repaired by starting with</p>\n<div class=\"codehilite\"><pre><span></span><code>  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">IH</span> <span class=\"n\">generalizing</span> <span class=\"n\">a</span> <span class=\"n\">aIn</span> <span class=\"n\">v</span> <span class=\"n\">vLess</span><span class=\"o\">,</span>\n</code></pre></div>\n\n\n<p>(<code>with n IH</code> just gives better names to the new variables)</p>",
        "id": 196987907,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589024896
    },
    {
        "content": "<p><code>generalizing ...</code> means basically <code>revert</code> all the variables, apply <code>induction</code>, then re-<code>intros</code> them in all the cases. That way you get an induction hypothesis that can be applied to any <code>a</code>, ....</p>",
        "id": 196987935,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589024963
    },
    {
        "content": "<p>Also, I guess as a high-level comment, surely it's better strategy to just prove that <code>a ∈ range n</code> is equivalent to <code>a &lt;= n</code> first, rather than embark on an inductive proof of this statement that involves three variables directly</p>",
        "id": 196988189,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589025296
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196987587\" title=\"#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196987587\">said</a>:</p>\n<blockquote>\n<p>On line 86, we know <code>n</code> is <code>0</code>, <code>a</code> is not <code>0</code>, <code>v</code> is not <code>0</code>. How can we use <code>cont</code> as the proof?</p>\n</blockquote>\n<p>Aren't <code>n</code>, <code>a</code> and <code>v</code> all <code>0</code> at that point?</p>",
        "id": 196988308,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589025437
    },
    {
        "content": "<p>it might be my inability to read this syntax, but I thought that line 84 is the counterpart to line 82, depending on the outcome of a=0</p>",
        "id": 196988442,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589025644
    },
    {
        "content": "<p>I think the structure is:</p>\n<ul>\n<li>split on a = 0 (not by pattern matching but with the <code>ℕDecideEquality</code> thing--but somehow Agda also decides that <code>a=0</code>, maybe this is what I missed later)<ul>\n<li>when <code>a=0</code>, split on the proof of <code>v&lt;=a</code></li>\n<li>when <code>a!=0</code>, split on <code>ℕDecideEquality v 0</code></li>\n</ul>\n</li>\n</ul>",
        "id": 196988585,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589025844
    },
    {
        "content": "<p>Well, this is the <code>n=0</code> case</p>",
        "id": 196988603,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589025906
    },
    {
        "content": "<p>Like I think the <code>...</code> on line 85 corresponds to the <code>... | inr a!=0</code> on line 84, otherwise I can't make sense of it</p>",
        "id": 196988616,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589025947
    },
    {
        "content": "<p>I get this for the translation of 79-86 to lean syntax</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">rangeClosed</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">contains</span> <span class=\"bp\">ℕ</span><span class=\"n\">DecideEquality</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">contains</span> <span class=\"bp\">ℕ</span><span class=\"n\">DecideEquality</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">v</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"n\">a</span> <span class=\"n\">cont</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">cont</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">ℕ</span><span class=\"n\">DecideEquality</span> <span class=\"n\">a</span> <span class=\"mi\">0</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"n\">cont</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">v</span><span class=\"bp\">&lt;</span><span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"n\">inl</span> <span class=\"n\">rfl</span> <span class=\"o\">:=</span> <span class=\"n\">exFalso</span> <span class=\"o\">(</span><span class=\"n\">notLessZero</span> <span class=\"n\">v</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"n\">cont</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">inr</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">inl</span> <span class=\"n\">rfl</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨⟩</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">cont</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">inr</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">inr</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">cont</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">ℕ</span><span class=\"n\">DecideEquality</span> <span class=\"n\">v</span> <span class=\"mi\">0</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">cont</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨⟩</span>\n    <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">cont</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">inr</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">cont</span>\n    <span class=\"kn\">end</span>\n  <span class=\"kn\">end</span>\n<span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 196988795,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589026275
    },
    {
        "content": "<p>Does it work?</p>",
        "id": 196988959,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589026495
    },
    {
        "content": "<p>Or did you manage to type all this without feedback from lean?</p>",
        "id": 196988966,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589026528
    },
    {
        "content": "<p>The only way I can imagine <code>cont : contains ℕDecideEquality (range n) a</code> has type <code>contains ℕDecideEquality (range n) v</code> here is that Agda actually decided this case is impossible</p>",
        "id": 196989020,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589026600
    },
    {
        "content": "<p>or I guess that it reduced both of these types to <code>False</code>... that is more plausible</p>",
        "id": 196989029,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589026628
    },
    {
        "content": "<p>No feedback</p>",
        "id": 196989038,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589026647
    },
    {
        "content": "<p>I still don't understand how it could do that though</p>",
        "id": 196989041,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589026652
    },
    {
        "content": "<p>I'm working on a compiling version</p>",
        "id": 196989046,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589026676
    },
    {
        "content": "<p>but the lean definitions are different in a few places, unless I replicate the whole definition from nothing as was done in the original</p>",
        "id": 196989097,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589026710
    },
    {
        "content": "<p>I guess I don't know how matching on <code>ℕDecideEquality a 0</code> actually works. It seems like for the Agda code to work, it needs to have already unfolded the definition of the type of <code>cont</code> to see that it contains <code>ℕDecideEquality a 0</code>, so that it can be replaced by a constructor in the branches</p>",
        "id": 196989169,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589026855
    },
    {
        "content": "<p>I'm pretty sure that it's just like <code>obtain rfl | h := decidable.em (a = 0)</code></p>",
        "id": 196989186,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589026912
    },
    {
        "content": "<p>But in that case, in your Lean translation, <code>    | a, cont, v, h, inr (h₂ : v ≠ 0) := cont</code> is clearly a type error right?</p>",
        "id": 196989258,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589026991
    },
    {
        "content": "<p>Oh, actually it might not be, if that's simultaneously matching on the <code>ℕDecideEquality a 0</code> inside the definition of <code>contains</code></p>",
        "id": 196989311,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589027060
    },
    {
        "content": "<p>in lean you would have to <code>unfold contains</code> first</p>",
        "id": 196989318,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589027076
    },
    {
        "content": "<p>I think that must be what is happening but I don't know how Agda knows to do that</p>",
        "id": 196989319,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589027085
    },
    {
        "content": "<p>I mean it cannot unfold everything in scope as far as possible before matching on anything, right? Or can it?</p>",
        "id": 196989344,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589027132
    },
    {
        "content": "<p>\"The user said it typechecks, so by golly I'll make it typecheck\"</p>",
        "id": 196989393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589027172
    },
    {
        "content": "<p>Here is how I might prove the original lemma:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">le_succ_iff</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">of_le_succ</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">le_succ_of_le</span> <span class=\"n\">le_of_eq</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">mem_range_iff_le</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">IH</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">range</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">range</span><span class=\"o\">,</span> <span class=\"n\">IH</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">le_succ_iff</span><span class=\"o\">,</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">comm</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">range_closed</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">aIn</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vLess</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mem_range_iff_le</span> <span class=\"n\">at</span> <span class=\"err\">⊢</span> <span class=\"n\">aIn</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">le_trans</span> <span class=\"n\">vLess</span> <span class=\"n\">aIn</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 196990462,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589028874
    },
    {
        "content": "<p>obviously I relied a bit on the standard library, but not heavily</p>",
        "id": 196990467,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589028888
    },
    {
        "content": "<p>I don't mind the use or not of the standard library - I'm not trying to whinge or anything, and the point wasn't \"oh look I've been coding for two years in Agda after spending months getting used to it, why am I finding Lean less intuitive waaaah\"</p>",
        "id": 196992350,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589031934
    },
    {
        "content": "<p>I'm aware that Agda, like all theorem proving environments, is completely unreadable :P Agda by default automatically unfolds everything as far as possible before presenting it to you, although you don't have to fill \"unfolded\" holes with \"unfolded\" terms - you can fill a hole that Agda is showing to you as fully unfolded, using a nice compact term</p>",
        "id": 196992515,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589032180
    },
    {
        "content": "<p>Well, I don't totally agree with the first statement. I think the proof I wrote above is a lot easier to understand, even putting concrete syntax aside--simply because it follows the correct conceptual strategy for a human</p>",
        "id": 196992575,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589032226
    },
    {
        "content": "<p>I believe you when you say your proof was easy to write without thinking (I know the Agda emacs mode has some fancy auto refine/hole filling stuff), but it resulted in something quite difficult to understand</p>",
        "id": 196992592,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589032260
    },
    {
        "content": "<p>It goes to show that machines producing proofs that humans cannot understand is not some science fiction thing.</p>",
        "id": 196992603,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589032288
    },
    {
        "content": "<p>(Random aside: can it really be true that <code>le_total</code> has the most useful type signature? Surely, surely <code>a &lt;= b</code> or <code>b &lt; a</code> is a more useful phrasing?)</p>",
        "id": 196992952,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589032812
    },
    {
        "content": "<p>Honestly I struggle to see that there's anything to prove here at all - I wouldn't say there's a \"correct strategy for a human\" beyond saying \"induction, the rest is trivial\", so I don't feel particularly moved by \"it follows the correct conceptual strategy for a human\". It may very well be that Lean makes for better-structured proofs on actual real problems, but then to me the structure of a formally-checked proof is dictated more by the lemmas which are chained together than by the internal structure of any particular theorem's proof. Possibly that's just my Agda heritage talking.</p>",
        "id": 196993054,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589033040
    },
    {
        "content": "<p>But my Agda proof has a structure that is fairly clear when you get past the syntax: \"induct on n; clear the base case. Check if v = n; if so, we're done straight away. If not, induct down, although booo fiddly edge case if a = n already.\"</p>",
        "id": 196993158,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589033158
    },
    {
        "content": "<p>I disagree rather thoroughly with all this, but I'm not sure there is anything constructive to say. It looks like \"alien mathematics\" again.</p>",
        "id": 196993220,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589033242
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"117987\">Patrick Stevens</span> <a href=\"#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196992952\" title=\"#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196992952\">said</a>:</p>\n<blockquote>\n<p>(Random aside: can it really be true that <code>le_total</code> has the most useful type signature? Surely, surely <code>a &lt;= b</code> or <code>b &lt; a</code> is a more useful phrasing?)</p>\n</blockquote>\n<p>All of the variations on these statements exist: <code>le_or_lt</code>, <code>lt_or_le</code>, <code>lt_trichotomy</code>, etc</p>",
        "id": 196993223,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589033248
    },
    {
        "content": "<p>I think I see where you are speaking from, it reminds me of how most list lemmas are proven. But once you have a decent nontrivial equality relation it becomes easier to prove things by <code>rw</code> and <code>simp</code> instead rather than using induction for everything</p>",
        "id": 196993314,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589033385
    },
    {
        "content": "<p><code>data.list.basic</code> is quite large, exactly because it should be easy to pick up and use without having to resort to induction all the time</p>",
        "id": 196993382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589033454
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196993223\" title=\"#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196993223\">said</a>:</p>\n<blockquote>\n<p>All of the variations on these statements exist: <code>le_or_lt</code>, <code>lt_or_le</code>, <code>lt_trichotomy</code>, etc</p>\n</blockquote>\n<p>Is there a way I can find those other than by a) intuiting their names, or b) writing their type signatures and proving them with <code>library_search</code>?</p>",
        "id": 196993388,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589033481
    },
    {
        "content": "<p>those both sound like pretty good methods to me</p>",
        "id": 196993393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589033500
    },
    {
        "content": "<p><code>#find</code></p>",
        "id": 196993426,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1589033523
    },
    {
        "content": "<p>another method is to write <code>#print le_total</code>, ctrl-click on <code>le_total</code> to go to its definition, and then browse around from there; I bet <code>le_or_lt</code> is within 3 statements of it</p>",
        "id": 196993447,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589033549
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196993447\" title=\"#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196993447\">said</a>:</p>\n<blockquote>\n<p>another method is to write <code>#print le_total</code>, ctrl-click on <code>le_total</code> to go to its definition, and then browse around from there; I bet <code>le_or_lt</code> is within 3 statements of it</p>\n</blockquote>\n<p>That one I did try - but actually they're in different files from <code>le_total</code></p>",
        "id": 196993521,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589033653
    },
    {
        "content": "<p>checking... oh, I missed, <code>le_or_gt</code> is about 20 theorems later</p>",
        "id": 196993540,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589033667
    },
    {
        "content": "<p><code>le_or_lt</code> is in the mathlib addendum to that file</p>",
        "id": 196993550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589033698
    },
    {
        "content": "<p>I guess I'll just say this: as a human, what led you to come up with the statement <code>rangeClosed</code> in the first place, or why did you believe that it would be true before you tried to prove it in Agda? Wasn't it the fact that <code>range n</code> contains the numbers 0 through n, that is, those <code>a</code> that are <code>&lt;= n</code>, and if <code>a &lt;= n</code> and <code>v &lt;= a</code>, then <code>v &lt;= n</code>? Or did you imagine this inductive proof with five or six case distinctions in it?</p>",
        "id": 196993740,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589033949
    },
    {
        "content": "<p>If the question is just \"why can't the system prove this for me automatically\" then I agree that any decent system ought to be able to do it, and I think there are some that can.</p>",
        "id": 196993828,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589034030
    },
    {
        "content": "<p>By the way, \"intuiting the name\" is not unreasonable because of lean's fairly strict <a href=\"https://github.com/leanprover-community/mathlib/blob/master/docs/contribute/naming.md\" title=\"https://github.com/leanprover-community/mathlib/blob/master/docs/contribute/naming.md\">naming conventions</a></p>",
        "id": 196993840,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589034048
    },
    {
        "content": "<p>for a good number of basic theorems you can just stick name segments together and guess the name exactly with high probability</p>",
        "id": 196993869,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589034091
    },
    {
        "content": "<p>An important variation of intuiting the name is guessing most of the name and using autocompletion</p>",
        "id": 196993937,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589034155
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196993840\" title=\"#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196993840\">said</a>:</p>\n<blockquote>\n<p>By the way, \"intuiting the name\" is not unreasonable because of lean's fairly strict <a href=\"https://github.com/leanprover-community/mathlib/blob/master/docs/contribute/naming.md\" title=\"https://github.com/leanprover-community/mathlib/blob/master/docs/contribute/naming.md\">naming conventions</a></p>\n</blockquote>\n<p>A month ago i thought guessing the name was wizard magic, and then I read that file and started guessing and it was fine</p>",
        "id": 196993952,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589034180
    },
    {
        "content": "<p>In Lean, I came up with <code>rangeClosed</code> as follows. 1) Attempt to formulate in Lean a certain lemma in the proof of Bertrand's postulate: namely, \"the product of the primes less than or equal to n, is less than 4^n\". 2) Realise I need to define the collection of primes less than or equal to n, and decide to go by filtering the collection of naturals less than or equal to n. 3) Begin to induct on n to prove that lemma, discover that I need to show that something is in the range at all.</p>\n<p>I think by this point I had been flapping my hands at the keyboard for a while and that was a term which would fill a hole I had in scope, so I started trying to prove it. But I already knew it would be true because \"look, it's obvious\" (no further reason at all, not even the justification you gave above); if you'd asked me to prove it, I'd have said \"induction on n\" (because that's the only thing it makes sense to induct on, because that's where the definition of <code>range</code> varies), and without pencil and paper I'd have been a bit stumped if you'd asked me for further justification. With pencil and paper I could probably have written out something like what you said.</p>",
        "id": 196994131,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589034413
    },
    {
        "content": "<blockquote>\n<p>Realise I need to define the collection of primes less than or equal to n, and decide to go by filtering the collection of naturals less than or equal to n. 3) Begin to induct on n to prove that lemma, discover that I need to show that something is in the range at all.</p>\n</blockquote>\n<p>It seems to me from this description that you already believed that <code>range n</code> is the set of numbers less or equal to <code>n</code></p>",
        "id": 196994202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589034508
    },
    {
        "content": "<p>so to my mind that indicates that this should be the first thing you prove about the definition, and hopefully the filter through which all other theorems follow</p>",
        "id": 196994223,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589034555
    },
    {
        "content": "<p>Yes, that is precisely why I constructed <code>range n</code> - to be the object which had that property</p>",
        "id": 196994288,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589034654
    },
    {
        "content": "<p>So then, surely, the first thing you should prove about it is that it <em>does</em> have that property</p>",
        "id": 196994305,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589034695
    },
    {
        "content": "<p>I guess if I'd been less lazy and had been working with my software engineer's hat on, I'd have done that straight away - no code without its unit test</p>",
        "id": 196994307,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589034699
    },
    {
        "content": "<p>Oh, Mario already said this.</p>",
        "id": 196994354,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589034736
    },
    {
        "content": "<p>In mathlib this is set up as a simp lemma, so that by the time you are actually thinking about the problem the <code>range</code>s are gone</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">range</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">range_closed</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">aIn</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vLess</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">lt_of_le_of_lt</span> <span class=\"n\">vLess</span> <span class=\"n\">aIn</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 196994497,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589034923
    },
    {
        "content": "<p>Oh, I didn't even realise there was a <code>list.range</code>, I assumed it would be a finset sort of thing</p>",
        "id": 196994550,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589034967
    },
    {
        "content": "<p>the finset is of course defined using the list</p>",
        "id": 196994564,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589035012
    },
    {
        "content": "<p>Anyways, <span class=\"user-mention\" data-user-id=\"117987\">@Patrick Stevens</span>, I'm not sure if in all the other noise, you missed the answer using <code>generalizing</code> (or equivalently <code>revert</code>).</p>",
        "id": 196995950,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589036831
    },
    {
        "content": "<p>Ah, I missed that - thanks</p>",
        "id": 196996025,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589036942
    }
]
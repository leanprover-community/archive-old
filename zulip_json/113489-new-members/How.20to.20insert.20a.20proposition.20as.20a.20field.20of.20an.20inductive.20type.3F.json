[
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">rat</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">list</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">vector</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">InfosetedGame</span> <span class=\"o\">(</span><span class=\"n\">players</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">infoset_count</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">infoset_sizes</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">nat</span> <span class=\"n\">infoset_count</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Terminal</span> <span class=\"o\">(</span><span class=\"n\">player</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"bp\">//</span> <span class=\"n\">i</span> <span class=\"err\">∈</span> <span class=\"n\">players</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">reward</span> <span class=\"o\">:</span> <span class=\"n\">rat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">InfosetedGame</span>\n<span class=\"bp\">|</span> <span class=\"n\">Response</span>\n    <span class=\"o\">(</span><span class=\"n\">player</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"bp\">//</span> <span class=\"n\">i</span> <span class=\"err\">∈</span> <span class=\"n\">players</span><span class=\"o\">})</span>\n    <span class=\"o\">(</span><span class=\"n\">subnodes</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">InfosetedGame</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">infoset_id</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">infoset_count</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">wf</span> <span class=\"o\">:</span> <span class=\"n\">infoset_sizes</span><span class=\"bp\">.</span><span class=\"n\">nth</span> <span class=\"n\">infoset_id</span> <span class=\"bp\">=</span> <span class=\"n\">subnodes</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span>\n    <span class=\"o\">:</span> <span class=\"n\">InfosetedGame</span>\n<span class=\"bp\">|</span> <span class=\"n\">Chance</span> <span class=\"o\">(</span><span class=\"n\">player</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"bp\">//</span> <span class=\"n\">i</span> <span class=\"err\">∈</span> <span class=\"n\">players</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">subnodes</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">InfosetedGame</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">InfosetedGame</span>\n</pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span>nested occurrence &#39;eq.{1} nat (vector.nth.{0} nat infoset_count infoset_sizes infoset_id) (list.length.{0} InfosetedGame subnodes)&#39; lives in universe &#39;0&#39; but must live in resultant universe &#39;1&#39;\n</pre></div>\n\n\n<p>The problem here is <code>(wf : infoset_sizes.nth infoset_id = subnodes.length)</code>. This kind of code would work in Coq and Agda, though I do remember running into issues with propositions and types being two different things in Coq as well. In addition to the above problem, I've run into problems with not being able to return equalities in tuples and such.  I find that quite annoying.</p>\n<p>What should I do here?</p>",
        "id": 179176959,
        "sender_full_name": "Marko Grdinić",
        "timestamp": 1572193148
    },
    {
        "content": "<p>The easiest thing to do would be to use a function <code>fin n -&gt; A</code> in place of <code>{l : list A // length l = n}</code></p>",
        "id": 179177169,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572193453
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> </p>\n<p>I do not follow. What do you mean by that?</p>",
        "id": 179177239,
        "sender_full_name": "Marko Grdinić",
        "timestamp": 1572193601
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">rat</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">InfosetedGame</span> <span class=\"o\">(</span><span class=\"n\">players</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">string</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">infoset_count</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">infoset_sizes</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">infoset_count</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Terminal</span> <span class=\"o\">(</span><span class=\"n\">player</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"bp\">//</span> <span class=\"n\">i</span> <span class=\"err\">∈</span> <span class=\"n\">players</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">reward</span> <span class=\"o\">:</span> <span class=\"n\">rat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">InfosetedGame</span>\n<span class=\"bp\">|</span> <span class=\"n\">Response</span>\n    <span class=\"o\">(</span><span class=\"n\">player</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"bp\">//</span> <span class=\"n\">i</span> <span class=\"err\">∈</span> <span class=\"n\">players</span><span class=\"o\">})</span>\n    <span class=\"o\">(</span><span class=\"n\">infoset_id</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">infoset_count</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">subnodes</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">infoset_sizes</span> <span class=\"n\">infoset_id</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">InfosetedGame</span><span class=\"o\">)</span>\n    <span class=\"o\">:</span> <span class=\"n\">InfosetedGame</span>\n<span class=\"bp\">|</span> <span class=\"n\">Chance</span> <span class=\"o\">(</span><span class=\"n\">player</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"bp\">//</span> <span class=\"n\">i</span> <span class=\"err\">∈</span> <span class=\"n\">players</span><span class=\"o\">})</span>\n    <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">subnodes</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">InfosetedGame</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">InfosetedGame</span>\n</pre></div>",
        "id": 179177255,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572193627
    },
    {
        "content": "<p>This is an interesting way of doing this. It is quite nice.</p>\n<p>Still, why is putting that equality into a field a problem?</p>",
        "id": 179177394,
        "sender_full_name": "Marko Grdinić",
        "timestamp": 1572193878
    },
    {
        "content": "<p>Recursive arguments are not allowed to be dependent</p>",
        "id": 179177398,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572193917
    },
    {
        "content": "<p>Plus, you used <code>list T -&gt; T</code>  so it's actually a nested inductive, and these are not built in, lean simulates them, and not that well</p>",
        "id": 179177459,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572194002
    },
    {
        "content": "<p>What do you mean by dependent? What do you mean by not simulating lists inside other types well? Would it be possible to do it by wrapping the proposition in a type?</p>\n<p><code>(wf : {i : unit // infoset_sizes.nth infoset_id = subnodes.length})</code></p>\n<div class=\"codehilite\"><pre><span></span>nested inductive type compiled to invalid inductive type\nnested exception message:\ninductive type being declared can only be nested inside the parameters of other inductive types\n</pre></div>\n\n\n<p>It seems not. This does seem like a limitation Lean has that I haven't seen in other provers. Is this restriction going to be removed in Lean 4 maybe?</p>",
        "id": 179177625,
        "sender_full_name": "Marko Grdinić",
        "timestamp": 1572194323
    },
    {
        "content": "<p>You can't make reference to the name <code>subnodes</code> at all in the type of another argument</p>",
        "id": 179177884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572194842
    },
    {
        "content": "<p>I see. Thank you for the help.</p>",
        "id": 179178442,
        "sender_full_name": "Marko Grdinić",
        "timestamp": 1572195765
    },
    {
        "content": "<p>I was curious so I decided to check. As it turns out, I was wrong Coq allowing that kind of definition.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">Require</span> <span class=\"kn\">Import</span> <span class=\"n\">Vector</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Inductive</span> <span class=\"n\">InfosetedGame</span> <span class=\"o\">(</span><span class=\"n\">infoset_count</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">infoset_sizes</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"n\">nat</span> <span class=\"n\">infoset_count</span><span class=\"o\">):</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n<span class=\"o\">|</span> <span class=\"n\">Response</span> <span class=\"o\">:</span>\n  <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">subnodes</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">InfosetedGame</span> <span class=\"n\">infoset_count</span> <span class=\"n\">infoset_sizes</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">infoset_id</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span><span class=\"o\">.</span><span class=\"n\">t</span> <span class=\"n\">infoset_count</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">wf</span> <span class=\"o\">:</span> <span class=\"n\">nth</span> <span class=\"n\">infoset_sizes</span> <span class=\"n\">infoset_id</span> <span class=\"o\">=</span> <span class=\"n\">length</span> <span class=\"n\">subnodes</span><span class=\"o\">),</span>\n  <span class=\"n\">InfosetedGame</span> <span class=\"n\">infoset_count</span> <span class=\"n\">infoset_sizes</span><span class=\"o\">.</span>\n</pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span>Non strictly positive occurrence of &quot;InfosetedGame&quot; in\n &quot;forall (subnodes : list (InfosetedGame infoset_count infoset_sizes))\n    (infoset_id : Fin.t infoset_count),\n  nth infoset_sizes infoset_id = length subnodes -&gt;\n  InfosetedGame infoset_count infoset_sizes&quot;.\n</pre></div>\n\n\n<p>I was right about Agda though.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kr\">open</span> <span class=\"kr\">import</span> <span class=\"n\">Data.List</span>\n<span class=\"kr\">open</span> <span class=\"kr\">import</span> <span class=\"n\">Data.Vec</span>\n<span class=\"kr\">open</span> <span class=\"kr\">import</span> <span class=\"n\">Data.Nat</span>\n<span class=\"kr\">open</span> <span class=\"kr\">import</span> <span class=\"n\">Data.Fin</span>\n<span class=\"kr\">open</span> <span class=\"kr\">import</span> <span class=\"n\">Relation.Binary.PropositionalEquality</span> <span class=\"kr\">using</span> <span class=\"o\">(</span>_≡_; refl<span class=\"o\">)</span>\n\n<span class=\"kr\">data</span> InfosetedGame <span class=\"o\">(</span>infoset-count <span class=\"ow\">:</span> ℕ<span class=\"o\">)</span> <span class=\"o\">(</span>infoset-sizes <span class=\"ow\">:</span> Vec ℕ infoset-count<span class=\"o\">)</span> <span class=\"ow\">:</span> <span class=\"kt\">Set</span> <span class=\"kr\">where</span>\n  <span class=\"nf\">Response</span> <span class=\"ow\">:</span>\n    <span class=\"o\">(</span>subnodes <span class=\"ow\">:</span> List <span class=\"o\">(</span>InfosetedGame infoset-count infoset-sizes<span class=\"o\">))</span>\n    <span class=\"ow\">→</span> <span class=\"o\">(</span>infoset-id <span class=\"ow\">:</span> Fin infoset-count<span class=\"o\">)</span>\n    <span class=\"ow\">→</span> <span class=\"o\">(</span>wf <span class=\"ow\">:</span> Data.Vec.lookup infoset-sizes infoset-id ≡ length subnodes<span class=\"o\">)</span>\n    <span class=\"ow\">→</span> InfosetedGame infoset-count infoset-sizes\n</pre></div>\n\n\n<p>I am not sure if this particular issue is related to Prop vs Type split that Lean inherited from Coq, or whether it is purely a matter of termination checking which Agda seems to excel at.</p>",
        "id": 179225441,
        "sender_full_name": "Marko Grdinić",
        "timestamp": 1572265361
    },
    {
        "content": "<p>I think it has more to do with accepting exotic inductive types. Lean has a well defined schema for inductive types, based on a paper by Dybjer. Coq and Agda have extended the kernel many times to support any inductive construction which isn't obviously inconsistent. AFAIK no one has proved that what is available is actually consistent though.</p>",
        "id": 179226492,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572266402
    },
    {
        "content": "<p>Coq and Agda also both have \"termination checkers\", where lean does not - it uses only recursors and the equation compiler is a compiler that turns equations into definitions using the recursor.</p>",
        "id": 179226629,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572266498
    },
    {
        "content": "<p>I think this was a good move on Lean's part; the \"termination checker\" approach makes the slope a bit more slippery when it comes to adding features that are <a href=\"https://sympa.inria.fr/sympa/arc/coq-club/2013-12/msg00119.html\" target=\"_blank\" title=\"https://sympa.inria.fr/sympa/arc/coq-club/2013-12/msg00119.html\">inconsistent for non-obvious reasons</a>.</p>",
        "id": 179226874,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572266751
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">Vec</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">Vec</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Vec</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Vec</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">GameTree&#39;</span> <span class=\"o\">(</span><span class=\"n\">infoset_sizes</span> <span class=\"o\">:</span> <span class=\"n\">Infoset</span> <span class=\"bp\">→</span> <span class=\"n\">Size</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Terminal</span> <span class=\"o\">(</span><span class=\"n\">reward</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">GameTree&#39;</span>\n<span class=\"bp\">|</span> <span class=\"n\">Response</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"n\">Infoset</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">subnodes</span> <span class=\"o\">:</span> <span class=\"n\">Vec</span> <span class=\"n\">GameTree&#39;</span> <span class=\"o\">(</span><span class=\"n\">infoset_sizes</span> <span class=\"n\">id</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">GameTree&#39;</span>\n</pre></div>\n\n\n<p>As it turns out it is possible to make this work in Lean. It seems it is just the <code>Prop</code>s that cause trouble in inductive types. The above does not work with the standard library's vector though.</p>",
        "id": 179511386,
        "sender_full_name": "Marko Grdinić",
        "timestamp": 1572511530
    },
    {
        "content": "<p>Yes, you can also write the mutual inductive yourself:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">mutual</span> <span class=\"kn\">inductive</span> <span class=\"n\">GameTree&#39;&#39;</span><span class=\"o\">,</span> <span class=\"n\">GameTree_vec</span> <span class=\"o\">(</span><span class=\"n\">infoset_sizes</span> <span class=\"o\">:</span> <span class=\"n\">Infoset</span> <span class=\"bp\">→</span> <span class=\"n\">Size</span><span class=\"o\">)</span>\n<span class=\"k\">with</span> <span class=\"n\">GameTree&#39;&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">Terminal</span> <span class=\"o\">(</span><span class=\"n\">reward</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">GameTree&#39;&#39;</span>\n<span class=\"bp\">|</span> <span class=\"n\">Response</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"n\">Infoset</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">GameTree_vec</span> <span class=\"o\">(</span><span class=\"n\">infoset_sizes</span> <span class=\"n\">id</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">GameTree&#39;&#39;</span>\n<span class=\"k\">with</span> <span class=\"n\">GameTree_vec</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">GameTree_vec</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">GameTree&#39;&#39;</span> <span class=\"bp\">→</span> <span class=\"n\">GameTree_vec</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">GameTree_vec</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>or even the resulting plain inductive:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">GameTree_mut</span> <span class=\"o\">(</span><span class=\"n\">infoset_sizes</span> <span class=\"o\">:</span> <span class=\"n\">Infoset</span> <span class=\"bp\">→</span> <span class=\"n\">Size</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">Terminal</span> <span class=\"o\">(</span><span class=\"n\">reward</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">GameTree_mut</span> <span class=\"n\">none</span>\n<span class=\"bp\">|</span> <span class=\"n\">Response</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"n\">Infoset</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">GameTree_mut</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">infoset_sizes</span> <span class=\"n\">id</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">GameTree_mut</span> <span class=\"n\">none</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">GameTree_mut</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">GameTree_mut</span> <span class=\"n\">none</span> <span class=\"bp\">→</span> <span class=\"n\">GameTree_mut</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">GameTree_mut</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 179511643,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572511871
    },
    {
        "content": "<p>It is important to recognize that whenever you use a nested or mutual inductive, what lean <em>actually</em> builds is the latter plain inductive, plus an interpretation layer. This matters because defeq sometimes matters, as I indicated in the other thread</p>",
        "id": 179511704,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572511947
    }
]
[
    {
        "content": "<p>How would you prove this lemma?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.list.indexes</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.list.nodup</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">l.find_indexes</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nodup</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">list.find_indexes_eq_map_indexes_values</span><span class=\"o\">,</span>\n  <span class=\"k\">suffices</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">list.indexes_values</span> <span class=\"n\">p</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nodup</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">list.nodup_map</span> <span class=\"gr\">sorry</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">list.indexes_values_eq_filter_enum</span><span class=\"o\">,</span>\n  <span class=\"k\">suffices</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l.enum.nodup</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">list.nodup_filter</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- ...?</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I've been able to reduce it to showing that <code>l.enum.nodup</code>, but I don't know how to continue from here. And also I feel like there must be some easier way to show this result.<br>\nIs there anything I'm missing?<br>\nThanks</p>",
        "id": 224658275,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1612118505
    },
    {
        "content": "<p>Why is this true? If the list has duplicates and <code>p</code> is always true...</p>",
        "id": 224658519,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1612118817
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">find_indexes</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"c1\">-- [0, 1, 2, 3]</span>\n</code></pre></div>",
        "id": 224658610,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612118910
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113489-new-members/topic/Nodup.20Indices/near/224658519\">said</a>:</p>\n<blockquote>\n<p>Why is this true? If the list has duplicates and <code>p</code> is always true...</p>\n</blockquote>\n<p>I was assuming that <code>list.find_indexes</code> would return the indices of all those elements in the list that satisfy some predicate. So any given index would show up at most once, making the list <code>nodup</code>.</p>",
        "id": 224658635,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1612118965
    },
    {
        "content": "<p>Ah sure, it finds the <em>indexes</em>, not the elements! Sorry, my fault</p>",
        "id": 224658708,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1612119078
    },
    {
        "content": "<p>I would prove that the list this function produces is strictly increasing as a separate lemma, and go from there.</p>",
        "id": 224658874,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1612119304
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/Nodup.20Indices/near/224658874\">said</a>:</p>\n<blockquote>\n<p>I would prove that the list this function produces is strictly increasing as a separate lemma, and go from there.</p>\n</blockquote>\n<p>I've separated this subproof out into its own lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">list.enum_cons_mem</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">tl</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">:</span>\n  <span class=\"n\">l.enum</span> <span class=\"bp\">=</span> <span class=\"n\">hd</span> <span class=\"o\">::</span> <span class=\"n\">tl</span> <span class=\"bp\">→</span> <span class=\"n\">hd</span> <span class=\"bp\">∉</span> <span class=\"n\">tl</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span>\n</code></pre></div>\n<p>But I'm failing at actually applying it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">list.find_indexes_nodup</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">l.find_indexes</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nodup</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">rw</span> <span class=\"n\">list.find_indexes_eq_map_indexes_values</span><span class=\"o\">,</span>\n    <span class=\"k\">suffices</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">list.indexes_values</span> <span class=\"n\">p</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nodup</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">list.nodup_map</span> <span class=\"gr\">sorry</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">list.indexes_values_eq_filter_enum</span><span class=\"o\">,</span>\n    <span class=\"k\">suffices</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l.enum.nodup</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">list.nodup_filter</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">l.enum</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n      <span class=\"n\">case</span> <span class=\"n\">list.nil</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n      <span class=\"n\">case</span> <span class=\"n\">list.cons</span> <span class=\"o\">{</span>\n        <span class=\"n\">apply</span> <span class=\"n\">list.nodup_cons.mpr</span><span class=\"o\">,</span>\n        <span class=\"k\">suffices</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">hd</span> <span class=\"bp\">∉</span> <span class=\"n\">tl</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">and.intro</span> <span class=\"n\">h</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l.enum</span> <span class=\"bp\">=</span> <span class=\"n\">hd</span> <span class=\"o\">::</span> <span class=\"n\">tl</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">list.enum_cons_mem</span> <span class=\"n\">h</span>\n      <span class=\"o\">}</span>\n  <span class=\"kd\">end</span>\n</code></pre></div>\n<p>I don't know how to fix the second <code>sorry</code>. I thought a <code>refl</code> would work, but it seems that the fact that <code>l.enum = hd :: tl</code> isn't being propagated into the induction.</p>",
        "id": 224660503,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1612121592
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"372804\">@Marcus Rossel</span> What I had in mind is splitting up as follows. <br>\nI bet mathlib already has something like this <code>to_func</code> thing...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.list.indexes</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.list.nodup</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">list.to_func</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">l.length</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">l.nth_le</span> <span class=\"n\">i.1</span> <span class=\"n\">i.2</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">strict_mono</span> <span class=\"o\">(</span><span class=\"n\">l.find_indexes</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_func</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bar</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">strict_mono</span> <span class=\"n\">l.to_func</span> <span class=\"bp\">→</span> <span class=\"n\">l.nodup</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">l.find_indexes</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nodup</span> <span class=\"o\">:=</span> <span class=\"n\">bar</span> <span class=\"bp\">$</span> <span class=\"n\">foo</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 224661412,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1612123009
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"372804\">Marcus Rossel</span> <a href=\"#narrow/stream/113489-new-members/topic/Nodup.20Indices/near/224660503\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/Nodup.20Indices/near/224658874\">said</a>:</p>\n<blockquote>\n<p>I would prove that the list this function produces is strictly increasing as a separate lemma, and go from there.</p>\n</blockquote>\n<p>I've separated this subproof out into its own lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">list.enum_cons_mem</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">tl</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">:</span>\n  <span class=\"n\">l.enum</span> <span class=\"bp\">=</span> <span class=\"n\">hd</span> <span class=\"o\">::</span> <span class=\"n\">tl</span> <span class=\"bp\">→</span> <span class=\"n\">hd</span> <span class=\"bp\">∉</span> <span class=\"n\">tl</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span>\n</code></pre></div>\n<p>But I'm failing at actually applying it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">list.find_indexes_nodup</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">l.find_indexes</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nodup</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">rw</span> <span class=\"n\">list.find_indexes_eq_map_indexes_values</span><span class=\"o\">,</span>\n    <span class=\"k\">suffices</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">list.indexes_values</span> <span class=\"n\">p</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nodup</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">list.nodup_map</span> <span class=\"gr\">sorry</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">list.indexes_values_eq_filter_enum</span><span class=\"o\">,</span>\n    <span class=\"k\">suffices</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l.enum.nodup</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">list.nodup_filter</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">l.enum</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n      <span class=\"n\">case</span> <span class=\"n\">list.nil</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n      <span class=\"n\">case</span> <span class=\"n\">list.cons</span> <span class=\"o\">{</span>\n        <span class=\"n\">apply</span> <span class=\"n\">list.nodup_cons.mpr</span><span class=\"o\">,</span>\n        <span class=\"k\">suffices</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">hd</span> <span class=\"bp\">∉</span> <span class=\"n\">tl</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">and.intro</span> <span class=\"n\">h</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l.enum</span> <span class=\"bp\">=</span> <span class=\"n\">hd</span> <span class=\"o\">::</span> <span class=\"n\">tl</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">list.enum_cons_mem</span> <span class=\"n\">h</span>\n      <span class=\"o\">}</span>\n  <span class=\"kd\">end</span>\n</code></pre></div>\n<p>I don't know how to fix the second <code>sorry</code>. I thought a <code>refl</code> would work, but it seems that the fact that <code>l.enum = hd :: tl</code> isn't being propagated into the induction.</p>\n</blockquote>\n<p>It looks like to me you're trying to prove something false in the induction</p>",
        "id": 224661731,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612123408
    },
    {
        "content": "<p>Maybe I may be wrong but doing induction on <code>l.enum</code> is like: take an arbitrary list and prove what I want I think</p>",
        "id": 224661743,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612123434
    },
    {
        "content": "<p>If you do it on <code>l</code>, it might work, as you will prove <code>(0, hd) notin enum_from 1 tl and (enum_from 1 tl).nodup</code></p>",
        "id": 224661805,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612123497
    },
    {
        "content": "<p>And the first is provable because you can show the first component of <code>enum_from 1 tl</code> is greater or equal than 1, thus <code>(0, something)</code> cannot be there, and the second is just the fact that applying an injective function to a nodup list won't change its nodup property, and you just translate the first component of the induction hypothesis, there might be a lot better way to do it though</p>",
        "id": 224661902,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612123607
    },
    {
        "content": "<p>Though, indeed, this is a bit strange</p>",
        "id": 224662398,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1612124171
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">nodup_zip_of_left</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nodup</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">nodup</span> <span class=\"o\">(</span><span class=\"n\">l.zip</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">hl</span> <span class=\"n\">generalizing</span> <span class=\"n\">l'</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">l'</span> <span class=\"k\">with</span> <span class=\"n\">hd'</span> <span class=\"n\">tl'</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nodup_cons</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">zip_cons_cons</span><span class=\"o\">,</span> <span class=\"n\">nodup_cons</span><span class=\"o\">],</span>\n      <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">h.left</span> <span class=\"o\">(</span><span class=\"n\">mem_zip</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">hl</span> <span class=\"n\">h.right</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nodup_zip_of_right</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nodup</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">nodup</span> <span class=\"o\">(</span><span class=\"n\">l.zip</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l'</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">hl</span> <span class=\"n\">generalizing</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">hd'</span> <span class=\"n\">tl'</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nodup_cons</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">zip_cons_cons</span><span class=\"o\">,</span> <span class=\"n\">nodup_cons</span><span class=\"o\">],</span>\n      <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">h.left</span> <span class=\"o\">(</span><span class=\"n\">mem_zip</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">hl</span> <span class=\"n\">_</span> <span class=\"n\">h.right</span><span class=\"o\">⟩</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">nodup_enum</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">nodup</span> <span class=\"n\">l.enum</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">enum_eq_zip_range</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">nodup_zip_of_left</span> <span class=\"o\">(</span><span class=\"n\">nodup_range</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 224669319,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1612131502
    },
    {
        "content": "<p>You said you needed <code>l.enum.nodup</code> -- there you go.</p>",
        "id": 224669325,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1612131513
    },
    {
        "content": "<p>That's after <code>import list.range</code></p>",
        "id": 224669328,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1612131520
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"372804\">@Marcus Rossel</span></p>",
        "id": 224669345,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1612131556
    },
    {
        "content": "<p>Wow, thanks! <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> <br>\nI feel like some of this should make its way into Mathlib, since IMHO <code>find_indexes</code> being <code>nodup</code> should be easily available and not require 4 lemmata. Does anyone know how I could get the ball rolling on that?</p>",
        "id": 224703719,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1612172684
    },
    {
        "content": "<p>If you have a github account then announce what it is and ask the maintainers for push access to non-master branches of mathlib, and then put the lemmas in an appropriate place on a branch of mathlib and then make a PR</p>",
        "id": 224704492,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612173182
    },
    {
        "content": "<p>The initial premise that <code>find_indexes</code> is <code>nodup</code> is faulty (using your proof strategy), as you can tell by the fact that you have to <code>sorry</code> the proof that <code>prod.fst</code> is injective. Because it isn't.</p>",
        "id": 224728956,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1612187987
    },
    {
        "content": "<p>Here you go:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.list.indexes</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.list.range</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">list</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">δ</span> <span class=\"n\">ε</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">foldr_with_index_nil</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">foldr_with_index</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"n\">nil</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">foldr_with_index_singleton</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">foldr_with_index</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">function.uncurry_comp_prod_map_id_left</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">function.uncurry</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">prod.map</span> <span class=\"n\">g</span> <span class=\"n\">id</span> <span class=\"bp\">=</span> <span class=\"n\">function.uncurry</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">⟩,</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">foldr_with_index_cons</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">foldr_with_index</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">foldr_with_index</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">nat.succ</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">foldr_with_index_eq_foldr_enum</span><span class=\"o\">,</span> <span class=\"n\">enum_eq_zip_range</span><span class=\"o\">,</span> <span class=\"n\">range_succ_eq_map</span><span class=\"o\">,</span> <span class=\"n\">zip_map_left</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">find_indexes_nil</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">find_indexes</span> <span class=\"n\">p</span> <span class=\"n\">nil</span> <span class=\"bp\">=</span> <span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">find_indexes_cons_true</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">find_indexes</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">find_indexes</span> <span class=\"n\">p</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">nat.succ</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">prod.fst</span> <span class=\"bp\">∘</span> <span class=\"n\">prod.map</span> <span class=\"n\">nat.succ</span> <span class=\"n\">id</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">((</span><span class=\"n\">p</span> <span class=\"bp\">∘</span> <span class=\"n\">prod.snd</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">prod.map</span> <span class=\"n\">nat.succ</span> <span class=\"n\">id</span><span class=\"o\">)</span>\n    <span class=\"o\">((</span><span class=\"n\">range</span> <span class=\"n\">l.length</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">zip</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"bp\">∘</span> <span class=\"n\">prod.fst</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∘</span> <span class=\"n\">prod.snd</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">range</span> <span class=\"n\">l.length</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">zip</span> <span class=\"n\">l</span><span class=\"o\">)),</span>\n    <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">find_indexes_eq_map_indexes_values</span><span class=\"o\">,</span> <span class=\"n\">indexes_values_eq_filter_enum</span><span class=\"o\">,</span> <span class=\"n\">enum_eq_zip_range</span><span class=\"o\">,</span>\n             <span class=\"n\">range_succ_eq_map</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">filter</span><span class=\"o\">,</span> <span class=\"n\">zip_map_left</span><span class=\"o\">,</span> <span class=\"n\">filter_of_map</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"n\">congr</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">find_indexes_cons_false</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">find_indexes</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">find_indexes</span> <span class=\"n\">p</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">nat.succ</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">prod.fst</span> <span class=\"bp\">∘</span> <span class=\"n\">prod.map</span> <span class=\"n\">nat.succ</span> <span class=\"n\">id</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">((</span><span class=\"n\">p</span> <span class=\"bp\">∘</span> <span class=\"n\">prod.snd</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">prod.map</span> <span class=\"n\">nat.succ</span> <span class=\"n\">id</span><span class=\"o\">)</span>\n    <span class=\"o\">((</span><span class=\"n\">range</span> <span class=\"n\">l.length</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">zip</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"bp\">∘</span> <span class=\"n\">prod.fst</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∘</span> <span class=\"n\">prod.snd</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">range</span> <span class=\"n\">l.length</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">zip</span> <span class=\"n\">l</span><span class=\"o\">)),</span>\n    <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">find_indexes_eq_map_indexes_values</span><span class=\"o\">,</span> <span class=\"n\">indexes_values_eq_filter_enum</span><span class=\"o\">,</span> <span class=\"n\">enum_eq_zip_range</span><span class=\"o\">,</span>\n             <span class=\"n\">range_succ_eq_map</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">filter</span><span class=\"o\">,</span> <span class=\"n\">zip_map_left</span><span class=\"o\">,</span> <span class=\"n\">filter_of_map</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"n\">congr</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">nodup_find_indexes</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">l.find_indexes</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nodup</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">hl</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">hd</span><span class=\"bp\">;</span>\n    <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">nat.succ_ne_zero</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">nodup_map</span> <span class=\"n\">nat.succ_injective</span> <span class=\"n\">hl</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 224749989,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1612196190
    }
]
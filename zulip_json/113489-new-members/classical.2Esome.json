[
    {
        "content": "<p>Hi! I've been working on writing a theorem for the Chinese Remainder Theorem ring isomorphism.  I already have a theorem that gives the existence of a solution to a pair of congruences and want to use that to define one of the isomorphism maps. When proving that this map and the projection are inverses for the ring isomorphism, I ran into `classical.some _'  in my goal and am not sure how to work with this, i.e. access the properties that it has. I looked at the docs for classical.some and classical.some_spec but since I didn't create the classical.some (it seems to have been generated by the function.inverse goal on simplification), I'm not sure how to use these. Here is a snap shot of the code: </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">theorem</span> <span class=\"n\">CRTwith2</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"n\">coprime</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">npos</span><span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mpos</span><span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span>  <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">*</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"err\">≃</span><span class=\"bp\">+*</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span> <span class=\"bp\">×</span> <span class=\"n\">zmod</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"c1\">--define maps</span>\n    <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">)),</span>\n    <span class=\"n\">intro</span> <span class=\"n\">xy</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">CRT</span> <span class=\"o\">:=</span> <span class=\"n\">CRTwith2exist</span> <span class=\"n\">xy</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">xy</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">npos</span> <span class=\"n\">mpos</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"c\">/-</span><span class=\"cm\">theorem CRTwith2exist (a1 a2 M1 M2 : ℕ ) (M1pos : 0 &lt; M1) (M2pos : 0 &lt; M2) (H : coprime M1 M2) :</span>\n<span class=\"cm\">                         ∃ x : ℕ , modeq M1 x a1 ∧ modeq M2 x a2 -/</span>\n    <span class=\"n\">choose</span> <span class=\"n\">x</span> <span class=\"n\">Hx</span> <span class=\"kn\">using</span> <span class=\"n\">CRT</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n\n    <span class=\"c1\">-- show inverses (needs classical.some)</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">intro</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n        <span class=\"n\">simp</span><span class=\"o\">,</span>\n        <span class=\"c1\">-- Goal here: ⊢ ↑(classical.some _) = y</span>\n    <span class=\"o\">},</span>\n    <span class=\"c1\">--show other proprties...</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>Clicking on 'classical.some _' in Lean Infoview yields this <a href=\"/user_uploads/3121/hiStRoybtS6IK3-eI3Wbv3ui/image.png\">picture</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/hiStRoybtS6IK3-eI3Wbv3ui/image.png\" title=\"picture\"><img src=\"/user_uploads/3121/hiStRoybtS6IK3-eI3Wbv3ui/image.png\"></a></div>",
        "id": 204970949,
        "sender_full_name": "Anya Michaelsen",
        "timestamp": 1595627796
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306595\">@Anya Michaelsen</span> can you post complete working code (i.e. include all imports)?</p>",
        "id": 204972463,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595629107
    },
    {
        "content": "<p>You might like the definition</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\">-</span>\n<span class=\"cm\">A convenience method for extracting the property satisfied by a term which is merely equal to</span>\n<span class=\"cm\">`classical.some _`.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">spec_of_eq_some</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">subst</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>that Johan and I recently wanted while working on sheaves, to deal with something just like this.</p>",
        "id": 204975932,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595632763
    },
    {
        "content": "<p>(It will eventually be PR'd to mathlib, but you can copy and paste it and use already.)</p>",
        "id": 204975948,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595632797
    },
    {
        "content": "<p>Here the full code for this file. The other version of <code>CRTwith2exists</code> is in a file CRT.lean (the first import) </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">CRT</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">modeq</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">gcd</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">zmod</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">ring</span>\n<span class=\"n\">noncomputable</span> <span class=\"n\">theory</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">nat</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">modeq</span> <span class=\"n\">zmod</span> <span class=\"n\">CRT</span>\n\n<span class=\"c1\">-------------------------ISOMORPHISM VERSION--------------------------</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">CRTwith2</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"n\">coprime</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">npos</span><span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mpos</span><span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span>  <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">*</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"err\">≃</span><span class=\"bp\">+*</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span> <span class=\"bp\">×</span> <span class=\"n\">zmod</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"c1\">--define maps</span>\n    <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">)),</span>\n    <span class=\"n\">intro</span> <span class=\"n\">xy</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">CRT</span> <span class=\"o\">:=</span> <span class=\"n\">CRTwith2exist</span> <span class=\"n\">xy</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">xy</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">npos</span> <span class=\"n\">mpos</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"c\">/-</span><span class=\"cm\">theorem CRTwith2exist (a1 a2 M1 M2 : ℕ ) (M1pos : 0 &lt; M1) (M2pos : 0 &lt; M2) (H : coprime M1 M2) :</span>\n<span class=\"cm\">                         ∃ x : ℕ , modeq M1 x a1 ∧ modeq M2 x a2 -/</span>\n    <span class=\"n\">choose</span> <span class=\"n\">x</span> <span class=\"n\">Hx</span> <span class=\"kn\">using</span> <span class=\"n\">CRT</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n\n    <span class=\"c1\">-- show inverses (needs classical.some)</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">intro</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n        <span class=\"n\">simp</span><span class=\"o\">,</span>\n        <span class=\"c1\">-- Goal here: ⊢ ↑(classical.some _) = y</span>\n    <span class=\"o\">},</span>\n    <span class=\"c1\">--show other proprties...</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 204977959,
        "sender_full_name": "Anya Michaelsen",
        "timestamp": 1595635246
    },
    {
        "content": "<p>Unfortunately this doesn't help us as a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>.</p>",
        "id": 204979432,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595637117
    },
    {
        "content": "<p>The point is to give us a chunk of code to copy and paste into VSCode, so we can play with it.</p>",
        "id": 204979481,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595637137
    },
    {
        "content": "<p>This is difficult partly because you're using tactics to create data. In fact <code>CRTwith2</code> should be a <code>def</code>, not a <code>theorem</code>.</p>",
        "id": 204979679,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595637439
    },
    {
        "content": "<p>is there a way to construct <code>≃+*</code> where you only give the forward map?</p>",
        "id": 204979738,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595637491
    },
    {
        "content": "<p>this pattern (product a ring isomorphism by giving a ring map that's bijective) ought to be in the library already</p>",
        "id": 204979815,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595637611
    },
    {
        "content": "<p>So there's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.of_bijective\">docs#equiv.of_bijective</a> and the extra fields of <code>ring_hom</code> only pertain to the forward map, so this should work. I suggest defining a plain <code>equiv</code> using <code>equiv.of_bijective</code> first and then extending it to a <code>ring_hom</code>.</p>",
        "id": 204980279,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595638359
    },
    {
        "content": "<p>I recently constructed a <code>≃+*</code> using the antipattern <code>{ ..f, ..e}</code>, where <code>f</code> was a <code>ring_hom</code> and <code>e</code> an <code>equiv</code>. I'd also be happy to have a named constructor for this, or to learn where it is.</p>",
        "id": 204980388,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595638536
    },
    {
        "content": "<p>why is that an antipattern? It's actually doing something you can't achieve with a named constructor, namely verifying a defeq</p>",
        "id": 204980590,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595638792
    },
    {
        "content": "<p>does it actually verify a defeq, or does it just check that the <code>ring_hom</code> proofs also type check against the <code>equiv</code> fields (or vice versa?)</p>",
        "id": 204981093,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595639521
    },
    {
        "content": "<p>But yeah, since <code>ring_hom</code> only has extra <code>Prop</code> fields, it would make sense to have a constructor from <code>equiv</code> and <code>ring_hom</code> plus a hypothesis of <code>=</code></p>",
        "id": 204981159,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595639609
    },
    {
        "content": "<p>Hmm, okay, I see it's not so bad.</p>",
        "id": 204982284,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595641509
    },
    {
        "content": "<p>Maybe we should switch to <code>is_ring_hom</code>? Oh wait...</p>",
        "id": 204995277,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595667016
    },
    {
        "content": "<p>Well, the issue was never really <code>is_ring_hom</code> existing, it was being a class</p>",
        "id": 205001886,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595679693
    }
]
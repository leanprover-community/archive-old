[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"488648\">Xavier Roblot</span> has marked this topic as unresolved.</p>",
        "id": 286769806,
        "sender_full_name": "Notification Bot",
        "timestamp": 1655717166
    },
    {
        "content": "<p>I am following up on this question since I have a hard time proving that <code>multiset.card P.roots  = fintype.card σ</code> when I define <code>σ  =  {x // x ∈ P.roots}</code>. That is the following result:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.splitting_field</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"n\">polynomial</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">):</span>\n  <span class=\"n\">multiset.card</span> <span class=\"n\">P.roots</span> <span class=\"bp\">=</span> <span class=\"n\">fintype.card</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">P.roots</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 286773724,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1655719662
    },
    {
        "content": "<p>Oh, sorry, I misunderstood what you were asking initially and gave you a type that enumerates the unique elements of the multiset (without duplicates).</p>",
        "id": 286773927,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1655719797
    },
    {
        "content": "<p>Oh, that explained why I had a hard time proving it <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 286774439,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1655720106
    },
    {
        "content": "<p>Still, I would be very grateful if somebody could help me with my original question...</p>",
        "id": 286775654,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1655720934
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"488648\">@Xavier Roblot</span> It seems like there's not a way to turn a multiset into a Type with the same number of elements already. Here's a go at it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.card</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_sort</span> <span class=\"o\">(</span><span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">m.to_finset</span><span class=\"o\">),</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">m.count</span> <span class=\"n\">x</span><span class=\"o\">)⟩</span>\n\n<span class=\"c1\">-- Just to check that this instance works:</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">multiset.card_coe</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">fintype.card</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m.card</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold_coes</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">transitivity</span> <span class=\"bp\">∑</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">m.to_finset</span><span class=\"o\">,</span> <span class=\"n\">multiset.count</span> <span class=\"n\">x</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"n\">finset.sum_coe_sort</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">m.count</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 286819701,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1655744472
    },
    {
        "content": "<p>This adds a coercion from multiset to Type where elements are ordered pairs (x, i), with i indexing which x this is in the multiset.</p>",
        "id": 286819827,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1655744549
    },
    {
        "content": "<p>Thanks! That’s great. Maybe it should be in mathlib?</p>",
        "id": 286820083,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1655744739
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"488648\">@Xavier Roblot</span> This might be better to define first:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.card</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators</span>\n\n<span class=\"sd\">/-- Construct a finset whose elements enumerate the elements of the multiset `m`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">multiset.to_enum_finset</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">m.to_finset.bUnion</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">finset.range</span> <span class=\"o\">(</span><span class=\"n\">m.count</span> <span class=\"n\">x</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">⟨</span><span class=\"n\">prod.mk</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">prod.mk.inj_left</span> <span class=\"n\">x</span><span class=\"o\">⟩)</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">multiset.mem_to_enum_finset</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">m.to_enum_finset</span> <span class=\"bp\">↔</span> <span class=\"n\">p.1</span> <span class=\"bp\">∈</span> <span class=\"n\">m</span> <span class=\"bp\">∧</span> <span class=\"n\">p.2</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m.count</span> <span class=\"n\">p.1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">multiset.to_enum_finset</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_bUnion</span><span class=\"o\">,</span> <span class=\"n\">multiset.mem_to_finset</span><span class=\"o\">,</span>\n    <span class=\"n\">finset.mem_map</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_range</span><span class=\"o\">,</span> <span class=\"n\">function.embedding.coe_fn_mk</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">p.1</span><span class=\"o\">,</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">p.2</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"n\">prod.mk.eta</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">multiset.coe_to_enum_finset</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">m.to_enum_finset</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"bp\">|</span> <span class=\"n\">p.1</span> <span class=\"bp\">∈</span> <span class=\"n\">m</span> <span class=\"bp\">∧</span> <span class=\"n\">p.2</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m.count</span> <span class=\"n\">p.1</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[mono]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">multiset.to_enum_finset_mono</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">m₁</span> <span class=\"n\">m₂</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m₁</span> <span class=\"bp\">≤</span> <span class=\"n\">m₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m₁.to_enum_finset</span> <span class=\"bp\">⊆</span> <span class=\"n\">m₂.to_enum_finset</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">multiset.mem_to_enum_finset</span><span class=\"o\">,</span> <span class=\"n\">and_imp</span><span class=\"o\">],</span>\n  <span class=\"n\">intros</span> <span class=\"n\">hx</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">multiset.mem_of_le</span> <span class=\"n\">h</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"k\">calc</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">multiset.count</span> <span class=\"n\">x</span> <span class=\"n\">m₁</span> <span class=\"o\">:</span> <span class=\"n\">hi</span>\n     <span class=\"bp\">...</span> <span class=\"bp\">≤</span> <span class=\"n\">multiset.count</span> <span class=\"n\">x</span> <span class=\"n\">m₂</span> <span class=\"o\">:</span> <span class=\"n\">multiset.le_iff_count.mp</span> <span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">multiset.card_to_enum_finset</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">m.to_enum_finset.card</span> <span class=\"bp\">=</span> <span class=\"n\">m.card</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">multiset.to_enum_finset</span><span class=\"o\">,</span> <span class=\"n\">finset.card_bUnion</span><span class=\"o\">],</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">multiset.mem_to_finset</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">],</span>\n    <span class=\"n\">rintros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"n\">y</span> <span class=\"n\">hy</span> <span class=\"n\">hxy</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">finset.inf_eq_inter</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_inter</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_map</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_range</span><span class=\"o\">,</span>\n      <span class=\"n\">function.embedding.coe_fn_mk</span><span class=\"o\">,</span> <span class=\"n\">prod.mk.inj_iff</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">,</span> <span class=\"n\">exists_eq_right_right</span><span class=\"o\">,</span>\n      <span class=\"n\">finset.bot_eq_empty</span><span class=\"o\">,</span> <span class=\"n\">finset.not_mem_empty</span><span class=\"o\">,</span> <span class=\"n\">and_imp</span><span class=\"o\">],</span>\n    <span class=\"n\">rintros</span> <span class=\"bp\">-</span> <span class=\"n\">rfl</span> <span class=\"bp\">-</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">contradiction</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 286826672,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1655749536
    },
    {
        "content": "<p>That way we have <code>finset</code>s that satisfy some order properties (like the <code>to_enum_finset_mono</code> lemma), and there are fewer dependent types.</p>",
        "id": 286826760,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1655749605
    },
    {
        "content": "<p>I'm not sure what the right name for this is. <code>multiset.to_enum_finset</code> makes it seem like it's enumerating all the elements in some order, but it's only enumerating repeats (so for example the multiset with 1,2,2,3 would give the finset {(1,0), (2,0), (2,1), (3,0)}).</p>",
        "id": 286826901,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1655749728
    },
    {
        "content": "<p>from collections import Counter <span aria-label=\"snake\" class=\"emoji emoji-1f40d\" role=\"img\" title=\"snake\">:snake:</span></p>",
        "id": 286861879,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1655783026
    },
    {
        "content": "<p>Probably defined via a list fold then into the quotient with a proof that the fold commutes, no longer N^2 construction</p>",
        "id": 286861989,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1655783114
    },
    {
        "content": "<p>Unless my fold is hiding N^2 due to the cons</p>",
        "id": 286862051,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1655783168
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset/near/286826901\">said</a>:</p>\n<blockquote>\n<p>I'm not sure what the right name for this is. <code>multiset.to_enum_finset</code> makes it seem like it's enumerating all the elements in some order, but it's only enumerating repeats (so for example the multiset with 1,2,2,3 would give the finset {(1,0), (2,0), (2,1), (3,0)}).</p>\n</blockquote>\n<p>Yes, basically, you are making a <code>finset</code> from a <code>multiset</code> without deleting duplicates.  Something <code>multiset.to_finset_with_dup</code> could work maybe</p>",
        "id": 286877149,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1655797574
    },
    {
        "content": "<p>Is there an XY problem here where using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/multiset.prod\">docs#multiset.prod</a> instead of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.prod\">docs#finset.prod</a> would avoid the problem?</p>",
        "id": 286882212,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1655800644
    },
    {
        "content": "<p>Well, I guess I could change the statement of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mv_polynomial.prod_X_add_C_coeff\">docs#mv_polynomial.prod_X_add_C_coeff</a>  and other results in <code>vieta</code> to use <code>multiset</code> instead of <code>finset</code>...</p>",
        "id": 286884640,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1655801925
    },
    {
        "content": "<p>You might want to make a <code>def</code> for the n-th symmetric polynomial of the roots of a polynomial, and give expressions in terms of <code>finset.prod</code> and <code>multiset.prod</code></p>",
        "id": 286885581,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655802415
    },
    {
        "content": "<p>(if I understand the problem correctly)</p>",
        "id": 286885591,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655802422
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"488648\">Xavier Roblot</span> <a href=\"#narrow/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset/near/286884640\">said</a>:</p>\n<blockquote>\n<p>Well, I guess I could change the statement of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mv_polynomial.prod_X_add_C_coeff\">docs#mv_polynomial.prod_X_add_C_coeff</a>  and other results in <code>vieta</code> to use <code>multiset</code> instead of <code>finset</code>...</p>\n</blockquote>\n<p>I think this is the way to go. It's a lot easier to derive finset results from multiset results than it is to go the other way around</p>",
        "id": 286885666,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1655802472
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset/near/286885581\">said</a>:</p>\n<blockquote>\n<p>You might want to make a <code>def</code> for the n-th symmetric polynomial of the roots of a polynomial, and give expressions in terms of <code>finset.prod</code> and <code>multiset.prod</code></p>\n</blockquote>\n<p>These results exist already more or less in <code>ring_theory.polynomial.vieta</code> but there are not used anywhere else...</p>\n<p>Oh, I see. I think I misunderstood what you meant...</p>",
        "id": 286885849,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1655802576
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset/near/286885666\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"488648\">Xavier Roblot</span> <a href=\"#narrow/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset/near/286884640\">said</a>:</p>\n<blockquote>\n<p>Well, I guess I could change the statement of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mv_polynomial.prod_X_add_C_coeff\">docs#mv_polynomial.prod_X_add_C_coeff</a>  and other results in <code>vieta</code> to use <code>multiset</code> instead of <code>finset</code>...</p>\n</blockquote>\n<p>I think this is the way to go. It's a lot easier to derive finset results from multiset results than it is to go the other way around</p>\n</blockquote>\n<p>Ok. I'll PR that. I still think that the code of Kyle might be useful at some point in the future.</p>",
        "id": 286886040,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1655802695
    },
    {
        "content": "<p>Ok, after spending some time thinking about it and trying several options, I do not think that replacing <code>fintype</code> with <code>multiset</code> in <code>ring_theory.polynomial.vieta</code> and, for consistency,<code>ring_theory.polynomial.symmetric</code> is the way go. I mean it is certainly possible, although probably quite messy, but even from a mathematical point of view I do not think it makes sense: in this file, we work with polynomials whose coefficients are in some ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><msub><mi>X</mi><mi>i</mi></msub><msub><mo stretchy=\"false\">]</mo><mrow><mi>i</mi><mo>∈</mo><mi>σ</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">R[X_i]_{i \\in \\sigma}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">σ</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1774em;\"><span></span></span></span></span></span></span></span></span></span> with the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">X_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>'s some indeterminates indexed by a type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span></span></span></span>. It does make sense here to have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span></span></span></span> being a multiset. </p>\n<p>It is only when we want to evaluate the indeterminates <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">X_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> to some value <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo>∈</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">r_i \\in R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6891em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, that it makes sense to have the possibility to repeat values. At the moment, this evaluation is done by providing a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma \\to R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> where <code>σ</code> is a <code>fintype</code>. So the missing link is a way to construct such a function when we want its image be a <code>multiset</code>. I don't know how to that. Kyle is providing a solution above by creating a <code>fintype</code> that enumerates the elements of a <code>multiset</code>, but there might be other solutions.</p>",
        "id": 286912084,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1655817760
    },
    {
        "content": "<p>(I had a look too, and did some cleanup in <a href=\"https://github.com/leanprover-community/mathlib/pull/14866\">#14866</a>)</p>",
        "id": 286924389,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1655822861
    },
    {
        "content": "<p>Ok, I have found a short solution. I'll still have to see if I can make it work all the way: I lift the <code>multiset s</code> to a <code>list L</code> and then enumerate the elements of <code>L</code> using <code>finset.range L.length</code>. The result is not very pretty...</p>",
        "id": 286937106,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1655827616
    },
    {
        "content": "<p>Here is a way of using <code>fin s.card</code> as the indexing type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.multiset.basic</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">multiset.of_fin_card</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">s.card</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">s.to_list.nth_le</span> <span class=\"n\">n.1</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">n.2</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">multiset.coe_card</span><span class=\"o\">,</span> <span class=\"n\">multiset.coe_to_list</span><span class=\"o\">]</span> <span class=\"o\">})</span>\n</code></pre></div>\n<p>Not sure if it's simpler or more complicated than your short solution.</p>",
        "id": 287009785,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1655878893
    },
    {
        "content": "<p>By the way, if your goal is <a href=\"https://github.com/leanprover-community/mathlib/pull/11523\">#11523</a>, I don't think you need to invoke mathlib's Vieta theorem. <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span>'s post says:</p>\n<blockquote>\n<p>Let <code>R</code> be an integrally closed domain with fraction field <code>K</code> and let <code>f : polynomial R</code> be monic. If <code>f = g * h</code> over <code>K</code>, then <code>g</code> and <code>h</code> have coefficients in <code>R</code>. Indeed, we can assume that <code>g</code> and <code>h</code> are monic (by factoring out the leading coefficients). If <code>L</code> is a splitting field of <code>f</code>, then writing <code>f</code> as a product of linear factors over <code>L</code> we see that both <code>g</code> and <code>h</code> are product of factors of the form <code>X - a</code>, where <code>a</code> ranges over a subset of the roos of <code>f</code>, that are algebraic over <code>R</code> by assumption. By Vieta, the coefficients of <code>g</code> and <code>h</code> are also algebraic over <code>R</code>, but lie <code>K</code> and so they are in <code>R</code>.</p>\n</blockquote>\n<p>But in fact you just need that <code>g.map (K -&gt; L)</code> is <code>g'.map (integral_closure of R in L -&gt; L)</code> for some <code>g'</code>, and this <code>g'</code> can be defined to be the multiset product of <code>X - C a</code> over roots <code>a</code> of <code>g.map (K -&gt; L)</code>. Although <code>(g.map (K -&gt; L)).roots : multiset L</code>, the roots of <code>g.map (K -&gt; L)</code> are also roots of <code>f.map (R -&gt; L)</code> so they lie in the integral closure, and you can use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/multiset.attach\">docs#multiset.attach</a> combined with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/multiset.map\">docs#multiset.map</a> to get the desired <code>multiset (integral closure)</code> of roots. <code>g'</code> is then a polynomial over the integral closure and automatically has coefficients in the integral closure.</p>",
        "id": 287013015,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1655881554
    },
    {
        "content": "<p>Thanks for your answer. So far, things seem nicer with your <code>def</code> than with what I had so far. My end goal here is a formula to bound the coefficients of a polynomial in terms of bounds on its roots. This is needed for the <code>FLT regular</code> project to prove Kronecker's theorem : an algebraic integer whose conjugates are all of absolute value 1 is a root of unity. Now, I know I can get this result with what's already in <code>ring_theory.polynomial.vieta</code> but I thought it would be nice to prove along the way the classical formula between the roots and coefficients of a polynomial. In fact, Alex J. Best already had a proof of that result that we use to prove Kronecker's theorem in the <code>FLT regular</code> project, but it is done from scratch and is quite intricate.  Since we want to PR Kronecker's theorem in <code>mathlib</code>, I wanted to redo the proof using what's already in <code>ring_theory.polynomial.vieta</code>.</p>",
        "id": 287017701,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1655884733
    },
    {
        "content": "<p>Yes, any polynomial will do the trick, it is unrelated to being symmetric or whatever</p>",
        "id": 287023674,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655888203
    },
    {
        "content": "<p>The multiset version of the theorem <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mv_polynomial.prod_X_add_C_coeff\">docs#mv_polynomial.prod_X_add_C_coeff</a> in the original post is the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">multiset_prod_X_add_C_coeff</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">s.card</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">s.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">polynomial.C</span> <span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">polynomial.X</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">prod.coeff</span> <span class=\"n\">k</span> <span class=\"bp\">=</span>\n  <span class=\"o\">((</span><span class=\"n\">s.powerset_len</span> <span class=\"o\">(</span><span class=\"n\">card</span> <span class=\"n\">σ</span> <span class=\"bp\">-</span> <span class=\"n\">k</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">multiset.prod</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>which should follow from that theorem using the indexing function<code>multiset.of_fin_card</code> and some lemmas that should exist in mathlib. I'm currently taking a look. Have you been able to prove it? Once it's proved, it's easy to deduce the formula between roots and coefficients, by taking <code>s</code> to be <code>p.roots.map neg</code>.</p>",
        "id": 287141796,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1655957274
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"488648\">@Xavier Roblot</span> I have been able to prove the multiset version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.multiset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.polynomial.vieta</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fin_range_eq_univ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset.fin_range</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">finset.univ</span> <span class=\"o\">:=</span>\n<span class=\"n\">finset.eq_univ_of_forall</span> <span class=\"n\">finset.mem_fin_range</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">multiset.length_to_list</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s.to_list.length</span> <span class=\"bp\">=</span> <span class=\"n\">s.card</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">multiset.coe_card</span><span class=\"o\">,</span> <span class=\"n\">s.coe_to_list</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">multiset.of_fin_card</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">s.card</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">s.to_list.nth_le</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">s.length_to_list</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">n.2</span> <span class=\"o\">})</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">list.map_nth_le</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">list.fin_range</span> <span class=\"n\">l.length</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">l.nth_le</span> <span class=\"n\">n</span> <span class=\"n\">n.2</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">list.ext_le</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">list.length_map</span><span class=\"o\">,</span> <span class=\"n\">list.length_fin_range</span><span class=\"o\">])</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">h</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">list.nth_le_map_rev</span><span class=\"o\">,</span> <span class=\"n\">congr</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">list.nth_le_fin_range</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">list.length_fin_range</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">multiset.exists_fin_map_eq</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">finset.univ</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val.map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">s.card</span><span class=\"o\">,</span> <span class=\"n\">s.of_fin_card</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">conv_rhs</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">s.coe_to_list</span> <span class=\"o\">},</span>\n  <span class=\"n\">convert</span> <span class=\"n\">multiset.coe_map</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"bp\">←</span> <span class=\"n\">s.to_list.map_nth_le</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">s.length_to_list</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">fin.heq_fun_iff</span> <span class=\"n\">s.length_to_list</span><span class=\"o\">,</span> <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">s.length_to_list</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">multiset_prod_X_add_C_coeff</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">s.card</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">s.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">polynomial.C</span> <span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">polynomial.X</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">prod.coeff</span> <span class=\"n\">k</span> <span class=\"bp\">=</span>\n  <span class=\"o\">((</span><span class=\"n\">s.powerset_len</span> <span class=\"o\">(</span><span class=\"n\">s.card</span> <span class=\"bp\">-</span> <span class=\"n\">k</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">multiset.prod</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">s.exists_fin_map_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">multiset.map_map</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">finset.prod_eq_multiset_prod</span><span class=\"o\">,</span> <span class=\"n\">mv_polynomial.prod_X_add_C_coeff</span><span class=\"o\">],</span>\n  <span class=\"n\">swap</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">multiset.card_map</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">multiset.powerset_len_map</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">finset.map_val_val_powerset_len</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.sum_eq_multiset_sum</span><span class=\"o\">,</span> <span class=\"n\">multiset.map_map</span><span class=\"o\">,</span> <span class=\"n\">multiset.map_map</span><span class=\"o\">],</span>\n  <span class=\"n\">congr</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">multiset.card_map</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 287146465,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1655962645
    },
    {
        "content": "<p>Hey, that’s great! I spent a couple of hours yesterday trying to make it work without going anywhere. I guess there is still a lot I need to learn about Lean and mathlib. Can you PR this into mathlib? It would be a great addition and allow me to PR Kronecker theorem. As you said, getting the result I need from your result is straightforward.</p>",
        "id": 287148837,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1655965495
    },
    {
        "content": "<p>Sure, I'll PR it later. It's still a bit nontrivial to deal with the negations (to extract a power of -1 as a factor), so I should probably include a version with <code>X - C r</code> in vieta.lean; then you can directly plug it into <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.C_leading_coeff_mul_prod_multiset_X_sub_C\">docs#polynomial.C_leading_coeff_mul_prod_multiset_X_sub_C</a>.</p>",
        "id": 287150153,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1655966576
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/14908\">#14908</a><br>\nwill add PR description later</p>",
        "id": 287168555,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1655979033
    }
]
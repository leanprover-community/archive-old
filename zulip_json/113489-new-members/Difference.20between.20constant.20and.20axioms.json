[
    {
        "content": "<p>I just noticed that <code>propext</code> is defined as a constant:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">constant</span> <span class=\"n\">propext</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n</pre></div>\n\n\n<p>Is this an alternative to <code>axiom</code>? What would change if I made it an axiom?</p>",
        "id": 154074362,
        "sender_full_name": "Abhimanyu Pallavi Sudhir",
        "timestamp": 1546238336
    },
    {
        "content": "<p>nothing at all</p>",
        "id": 154074420,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546238504
    },
    {
        "content": "<p>Why are there two different commands then? I would think it may make sense to use <code>axiom</code> for things whose type has type <code>Prop</code> and <code>constant</code> for things whose type has some other type (like a function), but the two examples I've seen are exactly the opposite.</p>",
        "id": 154074521,
        "sender_full_name": "Abhimanyu Pallavi Sudhir",
        "timestamp": 1546238712
    },
    {
        "content": "<p>I.e. <code>choice</code> defines a function and is an <code>axiom</code> but <code>propext</code> defines a (unproven) proof and is a <code>constant</code>.</p>",
        "id": 154074573,
        "sender_full_name": "Abhimanyu Pallavi Sudhir",
        "timestamp": 1546238850
    },
    {
        "content": "<p>There's no difference between <code>theorem</code> and <code>lemma</code> of course. But for constants and axioms I thought the rule of thumb was that constants were for data and axioms for propositions. As you spotted, this convention does not seem to be being followed here</p>",
        "id": 154078889,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546248332
    },
    {
        "content": "<p>The main difference between data and propositions in Lean is that Lean remembers how you constructed data but throws away your proof of a proposition and just remembers that it's proved. But of course here with constants and axioms this information doesn't exist, so they feel a lot more similar to each other than theorems and definitions do. If you're brave enough to look at Lean's source code and know enough C++ to understand it then you could maybe just check to see what the difference is.</p>",
        "id": 154079192,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546249079
    },
    {
        "content": "<p>Interestingly enough, <code>propext</code> was an <code>axiom</code> four years ago: <a href=\"https://github.com/leanprover/lean/blob/0da4f191fc2a37e34d53179d5cf924021de4fd15/library/logic/axioms/propext.lean\" target=\"_blank\" title=\"https://github.com/leanprover/lean/blob/0da4f191fc2a37e34d53179d5cf924021de4fd15/library/logic/axioms/propext.lean\">https://github.com/leanprover/lean/blob/0da4f191fc2a37e34d53179d5cf924021de4fd15/library/logic/axioms/propext.lean</a><br>\nBut yeah, it doesn't matter that much.  In the C++ code, you could tell the difference between axiom and constant, but this is not really used and not exposed to lean either.  Another difference is that you can do <code>meta constant</code> but not <code>meta axiom</code>.</p>",
        "id": 154079304,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1546249287
    },
    {
        "content": "<p>By the way, <code>propext</code> and <code>funext</code> together prove that all proofs (of a proposition) are equal, don't they? Since <code>propext</code> shows that <code>f(trivial) = trivial, g(trivial) = trivial</code> for any two functions <code>f : true \\to P</code> and <code>g : true \\to P</code>. So does that mean type theories in which proofs are distinct lack <code>propext</code>?</p>",
        "id": 154080836,
        "sender_full_name": "Abhimanyu Pallavi Sudhir",
        "timestamp": 1546251741
    },
    {
        "content": "<p>You don't need any axioms to prove that.</p>",
        "id": 154080842,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1546251809
    },
    {
        "content": "<p>I think the extra \"axiom\" is not just that all proofs of P are equal, but that they are definitionally equal.</p>",
        "id": 154080884,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546251847
    },
    {
        "content": "<p>look at the theorem <code>proof_irrel</code>.</p>",
        "id": 154080886,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1546251849
    },
    {
        "content": "<p>Oh. <code>rfl</code> is just anti-climactic.</p>",
        "id": 154080899,
        "sender_full_name": "Abhimanyu Pallavi Sudhir",
        "timestamp": 1546251957
    },
    {
        "content": "<p>:-)</p>",
        "id": 154080938,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546251969
    },
    {
        "content": "<p>But I see actually, even if it wasn't definitional, then propext would imply that anyway.</p>",
        "id": 154080939,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1546251970
    },
    {
        "content": "<p>Because every true <code>Prop</code> would be equal to <code>true</code> and <code>true</code> has only one proof.</p>",
        "id": 154080950,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1546252033
    },
    {
        "content": "<p>Proof relevant type theories tend to lack the type <code>Prop</code> altogether I think. Proof irrelevance is the only thing distinguishing <code>Prop</code> and <code>Type</code> so propositions tend to be defined using <code>Type</code> and some of them I think have an <code>is_Prop</code> predicate that says that the type has only one element.</p>",
        "id": 154081030,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1546252150
    },
    {
        "content": "<p>My recent thoughts about <code>quot</code>, and Mario's comments about them (sparked by Chris' observation that I used quot.sound to prove quot'.sound) made all this a bit clearer to me. There is just a whole bunch of stuff which, if you don't have it, would make maths basically impossible to do, and the CS people have made what appears to a mathematician to be a random small set of this stuff into axioms and then deduced all the rest of it. I'm not sure that the fact that propext is an axiom is remotely important.</p>",
        "id": 154081033,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546252154
    },
    {
        "content": "<blockquote>\n<p>Because every true <code>Prop</code> would be equal to <code>true</code> and <code>true</code> has only one proof.</p>\n</blockquote>\n<p>When I try writing that proof, though, Lean just changes it to <code>eq.refl H1</code> (when I print it).</p>",
        "id": 154081242,
        "sender_full_name": "Abhimanyu Pallavi Sudhir",
        "timestamp": 1546252570
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">proof_irrel&#39;</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H1</span> <span class=\"n\">H2</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">H1</span> <span class=\"bp\">=</span> <span class=\"n\">H2</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">ta</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">true</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">propext</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">trivial</span> <span class=\"o\">},</span> <span class=\"o\">{</span> <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">H1</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"n\">ta</span> <span class=\"n\">at</span> <span class=\"n\">H1</span> <span class=\"n\">H2</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 154081244,
        "sender_full_name": "Abhimanyu Pallavi Sudhir",
        "timestamp": 1546252598
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 154081245,
        "sender_full_name": "Abhimanyu Pallavi Sudhir",
        "timestamp": 1546252604
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 154081246,
        "sender_full_name": "Abhimanyu Pallavi Sudhir",
        "timestamp": 1546252610
    },
    {
        "content": "<p>Oh wait, I'm using a rewrite so it tries refl.</p>",
        "id": 154081247,
        "sender_full_name": "Abhimanyu Pallavi Sudhir",
        "timestamp": 1546252617
    },
    {
        "content": "<p>Wasn't there a version of <code>rw</code> that didn't try <code>refl</code>?</p>",
        "id": 154081294,
        "sender_full_name": "Abhimanyu Pallavi Sudhir",
        "timestamp": 1546252705
    },
    {
        "content": "<p>I think you can tweak the settings</p>",
        "id": 154081304,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546252756
    },
    {
        "content": "<p>I completely agree that it's a pain to experiment with stuff using <code>rw</code> becasue of this refl thing. I think \"dunfold\" and \"delta\" unfold functions without trying refl at the end but I don't know about rw.</p>",
        "id": 154081307,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546252773
    },
    {
        "content": "<p>I'm not sure this proof would actually work. Substitutions using equality of types are far more complicated and subtle than they might appear.</p>",
        "id": 154081313,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1546252792
    },
    {
        "content": "<blockquote>\n<p>I'm not sure this proof would actually work. Substitutions using equality of types are far more complicated and subtle than they might appear.</p>\n</blockquote>\n<p>? Surely rewrite works on <code>↔</code>, which is equality of types. E.g.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HP</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HPQ</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">=</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">sorry</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">HPQ</span> <span class=\"n\">at</span> <span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 154081426,
        "sender_full_name": "Abhimanyu Pallavi Sudhir",
        "timestamp": 1546252951
    },
    {
        "content": "<p>Actually, it definitely does work.</p>",
        "id": 154081485,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1546253054
    },
    {
        "content": "<p>This is the easiest way.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">proof_irrel&#39;</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H1</span> <span class=\"n\">H2</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">H1</span> <span class=\"bp\">=</span> <span class=\"n\">H2</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">ta</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">true</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">propext</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">trivial</span> <span class=\"o\">},</span> <span class=\"o\">{</span> <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">H1</span> <span class=\"o\">},</span>\n  <span class=\"n\">revert</span> <span class=\"n\">H1</span> <span class=\"n\">H2</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">ta</span><span class=\"o\">,</span>\n\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 154081500,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1546253120
    },
    {
        "content": "<p>And then use <code>no_confusion</code>? Hm, <code>true</code> doesn't have no_confusion.</p>",
        "id": 154081565,
        "sender_full_name": "Abhimanyu Pallavi Sudhir",
        "timestamp": 1546253260
    },
    {
        "content": "<p>That's because it's unnecessary. But if there was no proof irrelevance there would be.</p>",
        "id": 154081610,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1546253317
    },
    {
        "content": "<p>Actually, this is what you should do.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">proof_irrel&#39;</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H1</span> <span class=\"n\">H2</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">H1</span> <span class=\"bp\">=</span> <span class=\"n\">H2</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">ta</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">true</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">propext</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">trivial</span> <span class=\"o\">},</span> <span class=\"o\">{</span> <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">H1</span> <span class=\"o\">},</span>\n  <span class=\"n\">revert</span> <span class=\"n\">H1</span> <span class=\"n\">H2</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">ta</span><span class=\"o\">,</span>\n  <span class=\"k\">assume</span> <span class=\"n\">H1</span> <span class=\"n\">H2</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">H1</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">H2</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span>\n\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 154081617,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1546253371
    },
    {
        "content": "<p><code>no_confusion</code> is usually good for proving things are not equal.</p>",
        "id": 154081619,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1546253388
    },
    {
        "content": "<p>Yeah, I got confused (between the uniqueness of the constructors and their exhaustiveness)</p>",
        "id": 154081671,
        "sender_full_name": "Abhimanyu Pallavi Sudhir",
        "timestamp": 1546253461
    },
    {
        "content": "<p>To illustrate how complicated proof relevant equality can be, try proving this <code>example</code> without using <code>eq</code> anywhere in the proof. (Hint: it's impossible)</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">eq2</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">:</span> <span class=\"n\">eq2</span> <span class=\"n\">a</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">eq2</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">eq2</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 154081681,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1546253477
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">prelude</span>\n\n<span class=\"kn\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">notation</span> <span class=\"bp\">`</span><span class=\"kt\">Prop</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">Sort</span> <span class=\"mi\">0</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">iff</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mp</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mpr</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">eq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">:</span> <span class=\"n\">eq</span> <span class=\"n\">a</span>\n\n<span class=\"kn\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">↔</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">20</span> <span class=\"o\">:=</span> <span class=\"n\">iff</span>\n<span class=\"kn\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">=</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"o\">:=</span> <span class=\"n\">eq</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">elab_as_eliminator</span><span class=\"o\">,</span> <span class=\"n\">subst</span><span class=\"o\">]</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">subst</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"n\">h₂</span> <span class=\"n\">h₁</span>\n\n<span class=\"kn\">infixr</span> <span class=\"bp\">`</span> <span class=\"bp\">▸</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">75</span> <span class=\"o\">:=</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">subst</span>\n\n<span class=\"kn\">constant</span> <span class=\"n\">propext</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">true</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"o\">:</span> <span class=\"n\">true</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">proof_irrel</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H1</span> <span class=\"n\">H2</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">H1</span> <span class=\"bp\">=</span> <span class=\"n\">H2</span> <span class=\"o\">:=</span>\n<span class=\"k\">have</span> <span class=\"n\">true</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">propext</span> <span class=\"bp\">⟨λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">H1</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n<span class=\"o\">(</span><span class=\"n\">this</span> <span class=\"bp\">▸</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">H1</span> <span class=\"n\">H2</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"bp\">.</span><span class=\"n\">drec_on</span> <span class=\"n\">H1</span> <span class=\"o\">(</span><span class=\"n\">true</span><span class=\"bp\">.</span><span class=\"n\">drec_on</span> <span class=\"n\">H2</span> <span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">true</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"o\">)))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">H1</span> <span class=\"n\">H2</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">H1</span> <span class=\"bp\">=</span> <span class=\"n\">H2</span><span class=\"o\">)</span> <span class=\"n\">H1</span> <span class=\"n\">H2</span>\n</pre></div>",
        "id": 154082070,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546254342
    },
    {
        "content": "<p>What does the <code>subst</code> attribute do?</p>",
        "id": 154084763,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1546260223
    },
    {
        "content": "<p>Where is a complete list of all attributes and their explanations? Oh -- is <code>[subst]</code> it only used in core? Are users not supposed to use it?</p>",
        "id": 154087217,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546265069
    },
    {
        "content": "<p>I have no idea, I just copied the code out of the core library</p>",
        "id": 154087286,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546265206
    },
    {
        "content": "<blockquote>\n<p>Proof relevant type theories tend to lack the type <code>Prop</code> altogether I think. Proof irrelevance is the only thing distinguishing <code>Prop</code> and <code>Type</code> so propositions tend to be defined using <code>Type</code> and some of them I think have an <code>is_Prop</code> predicate that says that the type has only one element.</p>\n</blockquote>\n<p>This is not true. Impredicativity is also an important difference. I think Coq has Prop for this reason, and no definitional proof irrelevance</p>",
        "id": 154088165,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1546266760
    },
    {
        "content": "<p>What do you mean precisely by impredicativity?</p>",
        "id": 154089302,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1546268989
    },
    {
        "content": "<p>Coq has no definitional proof irrelevance? But does it have proof irrelevance?</p>",
        "id": 154089447,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546269151
    },
    {
        "content": "<p>I heard once it was an optional extra like <code>propext</code>. Though I guess that means <code>Prop</code> would still be special in the sense that any two proofs are not provably unequal.</p>",
        "id": 154089637,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1546269456
    },
    {
        "content": "<p>right, you have to have this property if impredicativity is to be consistent</p>",
        "id": 154096231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1546280784
    },
    {
        "content": "<p>because if a type has two elements, then you can build a cantor's paradox sort of thing using impredicativity</p>",
        "id": 154096238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1546280822
    },
    {
        "content": "<p>What does impredicativity mean precisely?</p>",
        "id": 154096291,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1546280907
    },
    {
        "content": "<p><code>forall x : A, P : Prop</code> if <code>P : Prop</code></p>",
        "id": 154096563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1546281325
    },
    {
        "content": "<p>even if <code>A : Type</code></p>",
        "id": 154096566,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1546281336
    },
    {
        "content": "<p>this means that propositions can quantify over themselves</p>",
        "id": 154096610,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1546281365
    },
    {
        "content": "<p><code>(forall x : A, P) : Prop</code> is what we're talking about here, presumably. The universe isn't the max, it's the imax.</p>",
        "id": 154096683,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546281537
    },
    {
        "content": "<p>in a predicative universe, the pi type has level max of the universe levels of the parts</p>",
        "id": 154096698,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1546281563
    },
    {
        "content": "<p>but we have this funny imax thing for level 0</p>",
        "id": 154096701,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1546281585
    },
    {
        "content": "<blockquote>\n<p>this means that propositions can quantify over themselves</p>\n</blockquote>\n<p>Isn't that just <code>P → P</code>?</p>",
        "id": 154114592,
        "sender_full_name": "Abhimanyu Pallavi Sudhir",
        "timestamp": 1546315975
    },
    {
        "content": "<p>Even with functions between types, the type of <code>P → Q</code> is the types of <code>P</code> and <code>Q</code>, so I don't understand why this makes <code>Prop</code> special.</p>",
        "id": 154114602,
        "sender_full_name": "Abhimanyu Pallavi Sudhir",
        "timestamp": 1546316012
    },
    {
        "content": "<p>I mean a function whose domain of quantification includes itself</p>",
        "id": 154114948,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1546316733
    },
    {
        "content": "<p>which permits self application</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">⦄,</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span>\n<span class=\"n\">def</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">p</span> <span class=\"n\">p</span>\n</pre></div>",
        "id": 154115111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1546317007
    },
    {
        "content": "<p>you can use this to do a variety of diagonalization type arguments</p>",
        "id": 154115115,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1546317038
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130500\">@Abhimanyu Pallavi Sudhir</span> if you quantify over all <code>Type</code>, you get <code>Type 1</code></p>",
        "id": 154116038,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546319029
    },
    {
        "content": "<p>A classic example of an impredicative definition of a Prop is defining the subgroup generated by a subset S of a group G to be the intersection of all the subgroups of G which contain S</p>",
        "id": 154129709,
        "sender_full_name": "Reid Barton",
        "timestamp": 1546349803
    },
    {
        "content": "<p>which is to say <code>def belongs_to_subgroup_generated_by (S : set G) (x : G) : Prop := \\forall (P : G \\to Prop), is_subgroup P \\and (\\forall y, S y \\to P y) \\to P x</code></p>",
        "id": 154129773,
        "sender_full_name": "Reid Barton",
        "timestamp": 1546349998
    },
    {
        "content": "<p>If <code>Prop</code> had a universe hierarchy like <code>Type</code>, you wouldn't be allowed to use the same <code>Prop</code> on both sides of that equation</p>",
        "id": 154129817,
        "sender_full_name": "Reid Barton",
        "timestamp": 1546350025
    },
    {
        "content": "<p>It hadn't occurred to me how important this was.</p>",
        "id": 154129832,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1546350108
    },
    {
        "content": "<p>of course it hadn't, you guys don't even care about foundations / of course it hadn't, this is hard core logic stuff</p>",
        "id": 154129986,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546350434
    },
    {
        "content": "<p>It's really hard to imagine from a classical perspective how anyone could object to the construction \"take all the subsets of G, keep the ones which are subgroups containing S, and form their intersection\".</p>",
        "id": 154130031,
        "sender_full_name": "Reid Barton",
        "timestamp": 1546350503
    },
    {
        "content": "<p>Before using Lean, I was not convinced that \"impredicative\" meant anything at all.</p>",
        "id": 154130032,
        "sender_full_name": "Reid Barton",
        "timestamp": 1546350516
    },
    {
        "content": "<p>From a \"classical perspective\", you run into issues like Δ0-predicates are absolute</p>",
        "id": 154130044,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546350589
    },
    {
        "content": "<p>that somehow P(ω) (i.e. powerset of ω) is not absolute</p>",
        "id": 154130092,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546350623
    },
    {
        "content": "<p>because taking powerset is not a predicative thing to do</p>",
        "id": 154130094,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546350639
    },
    {
        "content": "<p>Right, well, so the conclusion is that caring about predicativity is not a math thing to do.</p>",
        "id": 154130151,
        "sender_full_name": "Reid Barton",
        "timestamp": 1546350737
    },
    {
        "content": "<p>Especially since this example of an impredicative definition is something that one will encounter in a first course on algebra, it's not some scary thing involving universes or whatever.</p>",
        "id": 154130166,
        "sender_full_name": "Reid Barton",
        "timestamp": 1546350796
    },
    {
        "content": "<p>mathematicians have gone too far, doing impredicative stuff like that</p>",
        "id": 154130173,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546350830
    },
    {
        "content": "<p>how are they going to compute their examples if their definitions are impredicative</p>",
        "id": 154130179,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546350842
    },
    {
        "content": "<p>who cares about examples? We want theorems!</p>",
        "id": 154130229,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546350895
    },
    {
        "content": "<p>what do you want theorems for?</p>",
        "id": 154130240,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546350907
    },
    {
        "content": "<p>fun</p>",
        "id": 154130245,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546350916
    },
    {
        "content": "<p>and promotion</p>",
        "id": 154130247,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546350923
    },
    {
        "content": "<p>wasn't number theory created to solve diophantine equations</p>",
        "id": 154130248,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546350929
    },
    {
        "content": "<p>yes but now its job is to create theorems explaining what the structure of the solutions is</p>",
        "id": 154130253,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546350959
    },
    {
        "content": "<p>because solving them all turned out to be too hard</p>",
        "id": 154130292,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546350970
    },
    {
        "content": "<p>but now your impredicative definitions are not helping us to solve the equations, because they are incomputable</p>",
        "id": 154130294,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546350994
    },
    {
        "content": "<p>yes but we don't care about solving them because that's too hard. We now care about whether the solutions lie on some union of simple subvarieties or something. Nobody will get promoted for solving a Diophantine equation.</p>",
        "id": 154130303,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546351057
    },
    {
        "content": "<p>Can you compute the integers of Q[X]/(X^3-3X+1)?</p>",
        "id": 154130343,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546351111
    },
    {
        "content": "<p>sure, I read an algorithm to do that once</p>",
        "id": 154130349,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546351140
    },
    {
        "content": "<p>that doesn't mean you can compute it</p>",
        "id": 154130358,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546351150
    },
    {
        "content": "<p>it's in Cohen's book on computational number theory</p>",
        "id": 154130359,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546351153
    },
    {
        "content": "<p>sure it means I can compute it</p>",
        "id": 154130362,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546351159
    },
    {
        "content": "<p>I just ask a PhD student to compute it for me</p>",
        "id": 154130364,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546351169
    },
    {
        "content": "<p>that isn't <strong>you</strong> computing it</p>",
        "id": 154130367,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546351176
    },
    {
        "content": "<p>I think you have a lot to learn about the real world</p>",
        "id": 154130372,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546351191
    },
    {
        "content": "<p>Lean is designed for computer science, so impredicative definitions can't be that useless from a computational perspective. You can't compute with them, but you can still use them to help prove your program does what it's supposed to.</p>",
        "id": 154130934,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1546352314
    },
    {
        "content": "<p>By the way, HoTT uses predicative universes only (in the usual setup), so if you thought it would be a great thing that solves all your problems then this is one place where it isn't all sunshine and roses</p>",
        "id": 154132613,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1546356034
    },
    {
        "content": "<p>Also Agda makes a big deal about being 100% predicative</p>",
        "id": 154132623,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1546356080
    },
    {
        "content": "<p>It's true that in regular math predicativity doesn't really come up, but it shows up in non-absoluteness like Kenny says, or in model theory where adding more ordinals causes new subsets of nat to appear... you have this weird situation where you've built the set but not the elements, and that's where things like Cohen reals come from</p>",
        "id": 154132730,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1546356259
    },
    {
        "content": "<p>Also, we've discussed impredicative encodings of inductive types before, like <code>xnat : Type := \\all X : Type, X -&gt; (X -&gt; X) -&gt; X</code>, which doesn't typecheck in lean because <code>Type</code> is predicative</p>",
        "id": 154132796,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1546356441
    },
    {
        "content": "<p>Or when we have an object that is \"defined by a universal property\" and we want to just write that property but it doesn't work because the universe quantifier isn't large enough, so instead we re-express it by some kind of construction \"from below\"... that's predicativity</p>",
        "id": 154132846,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1546356583
    }
]
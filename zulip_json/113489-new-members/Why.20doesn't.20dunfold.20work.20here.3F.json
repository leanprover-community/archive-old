[
    {
        "content": "<p>I have the following:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra</span>\n<span class=\"c1\">--import data.equiv</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory</span><span class=\"bp\">.</span><span class=\"n\">group_action</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">equiv</span>\n<span class=\"kn\">open</span> <span class=\"n\">function</span>\n\n<span class=\"n\">def</span> <span class=\"n\">cayley</span> <span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"n\">perm</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"k\">let</span> <span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">perm</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">g1</span><span class=\"o\">:</span><span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"k\">by</span>\n        <span class=\"o\">{</span>\n            <span class=\"k\">let</span> <span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">g1</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"o\">),</span>\n            <span class=\"k\">let</span> <span class=\"n\">pinv</span><span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">g1</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"o\">),</span>\n            <span class=\"k\">have</span> <span class=\"n\">hleftinv</span><span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">left_inverse</span> <span class=\"n\">pinv</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"k\">by</span>\n                <span class=\"o\">{</span>\n                    <span class=\"n\">dunfold</span> <span class=\"n\">left_inverse</span><span class=\"o\">,</span>\n                    <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n                    <span class=\"n\">dunfold</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n\n\n                <span class=\"o\">},</span>\n            <span class=\"k\">have</span> <span class=\"n\">hrightinv</span><span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">right_inverse</span> <span class=\"n\">pinv</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n            <span class=\"n\">exact</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">p</span> <span class=\"n\">pinv</span> <span class=\"n\">hleftinv</span> <span class=\"n\">hrightinv</span><span class=\"o\">,</span>\n        <span class=\"o\">},</span>\n    <span class=\"k\">have</span> <span class=\"n\">h1</span><span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h2</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">⟨</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span> <span class=\"bp\">⟩</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>Hovering above <code>intro x,</code> gives me the goal state</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">G</span>\n<span class=\"n\">g1</span><span class=\"o\">:</span> <span class=\"n\">G</span>\n<span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">g1</span> <span class=\"bp\">*</span> <span class=\"n\">g</span>\n<span class=\"n\">pinv</span><span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">g1</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">g</span>\n<span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">G</span>\n<span class=\"err\">⊢</span> <span class=\"n\">pinv</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n</code></pre></div>\n\n\n<p>I want to unfold  <code>pinv (p x)</code>, but <code>dunfold p</code> gives me <code>unknown declaration 'p'</code>, even though clearly <code>p</code> is part of the assumptions. <br>\nAlso, just applying the <code>group</code> tactic doesn't work either, to my surprise. It reduces the goal to  <code>pinv (p x) * x ^ -1 = 1</code>.<br>\n<code>library_search</code> does work by the way, but I don't understand why the previous things don't.</p>",
        "id": 208056725,
        "sender_full_name": "Chris M",
        "timestamp": 1598423176
    },
    {
        "content": "<p><code>dsimp [p]</code> works fine. I tend not to use <code>dunfold</code> much.</p>",
        "id": 208058348,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1598425170
    },
    {
        "content": "<p>I've noticed that <code>dunfold</code> doesn't work with <code>let</code>-bound local definitions.  I'm not sure why.</p>\n<p>A workaround that might be worth knowing in case <code>dsimp</code> doesn't work is <code>set</code>, which lets you define an equation, too:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">set</span> <span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">g1</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n</code></pre></div>\n\n\n<p>and then you can do <code>rw hp</code>.  Another thing worth knowing is <code>delta</code> to expand definitions, though it doesn't work here for some reason.</p>",
        "id": 208059421,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598426261
    },
    {
        "content": "<p>I'm actually getting another error on this: The phrase<code>have h1: f 1 = 1, from sorry</code> doesn't give any  errors, but I get an error when I write <code>have h1: (f 1).to_fun = 1, from sorry</code>, namely:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"n\">class</span> <span class=\"kn\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n<span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">perm</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">g1</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span>\n    <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">g1</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n        <span class=\"n\">pinv</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">g1</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">g</span>\n    <span class=\"k\">in</span> <span class=\"o\">{</span><span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"n\">pinv</span><span class=\"o\">,</span> <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span><span class=\"o\">}</span>\n<span class=\"err\">⊢</span> <span class=\"n\">has_one</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n<span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">perm</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">g1</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span>\n    <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">g1</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n        <span class=\"n\">pinv</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">g1</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">g</span>\n    <span class=\"k\">in</span> <span class=\"o\">{</span><span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"n\">pinv</span><span class=\"o\">,</span> <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span><span class=\"o\">}</span>\n<span class=\"err\">⊢</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"n\">perm</span> <span class=\"n\">G</span>\n</code></pre></div>\n\n\n<p>I don't understand this error.</p>",
        "id": 208066658,
        "sender_full_name": "Chris M",
        "timestamp": 1598432051
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>failed to synthesize type class instance for\nG : Type ?,\n_inst_1 : group G,\nf : G → perm G :=\n  λ (g1 : G),\n    let p : G → G := λ (g : G), g1 * g,\n        pinv : G → G := λ (g : G), g1⁻¹ * g\n    in {to_fun := p, inv_fun := pinv, left_inv := _, right_inv := _}\n⊢ has_one (G → G)\n</code></pre></div>\n\n\n<blockquote>\n<p>I don't understand this error.</p>\n</blockquote>\n<p>It means that you asked Lean for a term called <code>1</code> of type <code>G → G</code> and it doesn't know what you mean.</p>",
        "id": 208071861,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598435669
    },
    {
        "content": "<p>Half your problem is that you are making definitions using tactic mode.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">cayley</span> <span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"n\">perm</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n</code></pre></div>\n\n\n<p>this is a bad move. You're constructing a term, not a proof. You should create the structure using the usual <code>{ field1 := value1, field2 := value2, ...}</code> structure creation syntax.</p>",
        "id": 208071930,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598435732
    },
    {
        "content": "<p>I'm not sure that \"don't use tactic mode to make definitions\" is an absolute rule. It is true that some tactics can make gross terms, and in particular it's easy to accidentally make terms that aren't definitionally what you expected them to be. Moreover using <code>simp</code> and <code>rw</code> when making definitions is likely to introduce <code>eq.rec</code> in your definition terms and you'll be sad later.</p>\n<p>But still I use tactic mode all the time when \"exploring\" how to make a definition; nearly always I golf it away afterwards to be sure I've done what I thought I was doing, but it can still be helpful.</p>",
        "id": 208075365,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1598438098
    },
    {
        "content": "<p>A guess why tactic mode is bad for constructing non-<code>Prop</code> terms: <code>Prop</code> has propositional extentionality, so we don't care about the proof, and hence the \"mess\" that a tactic block leaves behind is not something we care about, but for definitions, where we are gonna have to \"open it up\" later, it's a problem?</p>",
        "id": 208087855,
        "sender_full_name": "Chris M",
        "timestamp": 1598447051
    },
    {
        "content": "<p>That's part of it but this should really be directed not at tactics in general but at specific tactics like <code>rw</code>, <code>simp</code>, <code>linarith</code> etc.</p>",
        "id": 208087929,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598447100
    },
    {
        "content": "<p>Another reason is simply that if you make a definition then you will need to know later what the body of the definition actually is, and using tactics might make it harder to understand that</p>",
        "id": 208087987,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598447147
    },
    {
        "content": "<p>For example, if you are going to later unfold the definition in the course of some proof, then the actual proof term is going to appear in your proof state anyways</p>",
        "id": 208088180,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598447266
    },
    {
        "content": "<p>Does that apply to my code though? I only used non-trivial tactics in <code>Prop</code> terms.</p>",
        "id": 208088713,
        "sender_full_name": "Chris M",
        "timestamp": 1598447609
    },
    {
        "content": "<p>By the way, I've now turned it into a term mode definition, and now I'm getting the weird problem that it doesn't display a tactic goal state at all:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">Cayley</span> <span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"n\">perm</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">perm</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">g1</span><span class=\"o\">:</span><span class=\"n\">G</span><span class=\"o\">,</span>\n        <span class=\"k\">let</span> <span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">g1</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n        <span class=\"k\">let</span> <span class=\"n\">pinv</span><span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">g1</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n        <span class=\"k\">have</span> <span class=\"n\">hleftinv</span><span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">left_inverse</span> <span class=\"n\">pinv</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">inv_mul_cancel_left</span> <span class=\"n\">g1</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n        <span class=\"k\">have</span> <span class=\"n\">hrightinv</span><span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">right_inverse</span> <span class=\"n\">pinv</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">mul_right_inj</span> <span class=\"n\">g1</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"o\">(</span><span class=\"n\">hleftinv</span> <span class=\"o\">(</span><span class=\"n\">pinv</span> <span class=\"n\">x</span><span class=\"o\">))),</span>\n        <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">p</span> <span class=\"n\">pinv</span> <span class=\"n\">hleftinv</span> <span class=\"n\">hrightinv</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n    <span class=\"k\">have</span> <span class=\"n\">h1</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"k\">by</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">],</span>\n\n    <span class=\"o\">},</span>\n    <span class=\"k\">have</span> <span class=\"n\">h2</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n\n    <span class=\"bp\">⟨</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span> <span class=\"bp\">⟩</span>\n</code></pre></div>\n\n\n<p>When I hover my mouse after <code>dsimp [f],</code> there is no goal state</p>",
        "id": 208088847,
        "sender_full_name": "Chris M",
        "timestamp": 1598447674
    },
    {
        "content": "<p>Oh this seems to be because I had the tactic display mode set to \"widget\". Weird.</p>",
        "id": 208089645,
        "sender_full_name": "Chris M",
        "timestamp": 1598448139
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">equiv</span>\n\n<span class=\"kn\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"n\">def</span> <span class=\"n\">Cayley</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"n\">perm</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">group</span><span class=\"o\">,</span>\n    <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">group</span> <span class=\"o\">},</span>\n  <span class=\"n\">map_one&#39;</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span><span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">},</span>\n  <span class=\"n\">map_mul&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">mul_assoc</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 208090557,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598448632
    },
    {
        "content": "<p>what is <code>by group</code>?</p>",
        "id": 208090579,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598448642
    },
    {
        "content": "<p>the <code>group</code> tactic that Patrick wrote</p>",
        "id": 208090612,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598448660
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">Cayley</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"n\">perm</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">group</span><span class=\"o\">,</span>\n    <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">group</span> <span class=\"o\">},</span>\n  <span class=\"n\">map_one&#39;</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span><span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">},</span>\n  <span class=\"n\">map_mul&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">group</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 208090717,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598448722
    },
    {
        "content": "<p>Now I'm trying to figure out how <code>perm G</code> is an instance of <code>has_one</code>, i.e. where this is defined. How do I figure this out?</p>",
        "id": 208090831,
        "sender_full_name": "Chris M",
        "timestamp": 1598448791
    },
    {
        "content": "<p>hmm, just saw Kevin's definition</p>",
        "id": 208090903,
        "sender_full_name": "Chris M",
        "timestamp": 1598448838
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variable</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"o\">:</span> <span class=\"n\">has_one</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"n\">G</span><span class=\"o\">))</span> <span class=\"c1\">-- monoid.to_has_one (perm G) : has_one (perm G)</span>\n</code></pre></div>\n\n\n<p>The one is coming from <code>monoid.to_has_one</code> and the monoid structure on <code>perm G</code></p>",
        "id": 208090989,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598448875
    },
    {
        "content": "<p>Yes, since you're defining a structure, unless you intend to do it by applying another definition, it's generally convenient if the first character of your definition is <code>{</code></p>",
        "id": 208091633,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598449151
    },
    {
        "content": "<p>although perhaps for my learning experience it would have been better not to give the whole definition? not sure.</p>",
        "id": 208091839,
        "sender_full_name": "Chris M",
        "timestamp": 1598449207
    },
    {
        "content": "<p>Is there a way to show the types of the elements of a structure as you're defining it? If I write a typing statement in </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">group</span><span class=\"o\">,</span>\n      <span class=\"n\">rightinv</span> <span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">right_inverse</span> <span class=\"n\">to_inv</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">group</span> <span class=\"o\">},</span>\n</code></pre></div>\n\n\n<p>Then it gives an error. It'd be helpful to see this so I don't have to rely on memory. Is the only way just to copy the definition into a comment?</p>",
        "id": 208092308,
        "sender_full_name": "Chris M",
        "timestamp": 1598449437
    },
    {
        "content": "<p>What is the error?</p>",
        "id": 208092535,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598449540
    },
    {
        "content": "<p><code>invalid structure instance, ':=' expected</code></p>",
        "id": 208092640,
        "sender_full_name": "Chris M",
        "timestamp": 1598449577
    },
    {
        "content": "<p>perhaps fixing <code>rightinv</code> and <code>to_inv</code> will help</p>",
        "id": 208092733,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598449631
    },
    {
        "content": "<p>Put a <code>_</code> as the definition and hover over it or however you do it in VS Code. Or is that the memory you want to avoid?</p>",
        "id": 208092755,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598449642
    },
    {
        "content": "<p>but just putting <code>begin sorry end</code> after the <code>:=</code> will do it</p>",
        "id": 208092776,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598449652
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F/near/208092733\">said</a>:</p>\n<blockquote>\n<p>perhaps fixing <code>rightinv</code> and <code>to_inv</code> will help</p>\n</blockquote>\n<p>Sorry for that, no it doesn't.</p>",
        "id": 208093439,
        "sender_full_name": "Chris M",
        "timestamp": 1598449954
    },
    {
        "content": "<p>then just go for the <code>_</code> or <code>begin sorry end</code> option</p>",
        "id": 208093930,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598450177
    },
    {
        "content": "<p>ok</p>",
        "id": 208094586,
        "sender_full_name": "Chris M",
        "timestamp": 1598450451
    },
    {
        "content": "<p>After the <code>ext</code> tactic, it generates the goal state:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"mi\">1</span> <span class=\"n\">goal</span>\n<span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n<span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span>\n<span class=\"err\">⊢</span> <span class=\"err\">⇑</span><span class=\"o\">{</span><span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"mi\">1</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span><span class=\"o\">}</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"err\">⇑</span><span class=\"mi\">1</span> <span class=\"n\">x</span>\n</code></pre></div>\n\n\n<p>Is this goal simply equivalent to <code>( λ(h : G), 1 * h) x = ( λ(h:G), h) x</code>, because of the coercion arrow <code>⇑</code>? I guess this is true because it says in the tutorial doc: <code>Finally, ⇑f and ↥S are notations for coe_fn f and coe_sort S</code></p>",
        "id": 208095910,
        "sender_full_name": "Chris M",
        "timestamp": 1598451013
    },
    {
        "content": "<p>You can use <code>unfold_coes</code> to unfold the coercions and <code>dsimp</code> to simplify afterwards</p>",
        "id": 208101893,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598453487
    },
    {
        "content": "<p>Great!</p>",
        "id": 208103812,
        "sender_full_name": "Chris M",
        "timestamp": 1598454227
    },
    {
        "content": "<p>Actually, I don't understand why this <code>map_one' := by {ext, simp},</code> proof works, in particular the <code>ext</code> part: The <code>ext</code> tactic seems to (apart from applying the principle of functional extentionality) turn the goal of showing that the entire structure is the same, to just showing that <code>to_fun</code> is the same. Don't we also need to prove that <code>inv_fun</code> is the same? I guess I can accept that we don't need to prove the two properties are the same, because of propositional extentionality (though we're not actually invoking that, so I'm still not sure why that works).</p>",
        "id": 208105593,
        "sender_full_name": "Chris M",
        "timestamp": 1598454940
    },
    {
        "content": "<p>The <code>ext</code> tactic is much more general than that.</p>",
        "id": 208106129,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598455155
    },
    {
        "content": "<p>The goal I'm proving with <code>by {ext, simp}</code> is some statement that f(1)=1, it's an equality of functions, so ext uses functional extensionality.</p>",
        "id": 208106286,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598455211
    },
    {
        "content": "<p>But strictly speaking, it's an equality of \"functions with additional structure\", right? In particular, there are two functions that we need to show equality of, namely <code>to_fun</code> and <code>inv_inv</code>. We can deduce <code>inv_inv</code> from <code>to_fun</code>, but how does <code>ext</code> know this? did we have to teach this to <code>ext</code> explicitly and specifically for the typeclass <code>equiv</code>?</p>",
        "id": 208107836,
        "sender_full_name": "Chris M",
        "timestamp": 1598455839
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284606\">Chris M</span> <a href=\"#narrow/stream/113489-new-members/topic/Why.20doesn't.20dunfold.20work.20here.3F/near/208107836\">said</a>:</p>\n<blockquote>\n<p>But strictly speaking, it's an equality of \"functions with additional structure\", right? </p>\n</blockquote>\n<p>Yes, but the <code>ext</code> tactic knows that it suffices to prove the two functions are equal. <code>ext</code> is doing a lot.</p>",
        "id": 208108108,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598455961
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>  <span class=\"n\">map_one&#39;</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span><span class=\"n\">show_term</span> <span class=\"o\">{</span><span class=\"n\">ext</span><span class=\"o\">},</span> <span class=\"n\">simp</span><span class=\"o\">},</span>\n</code></pre></div>\n\n\n<p>shows that <code>ext</code> is using <code>perm.ext</code>, and <code>perm.ext</code> is the statement that if the \"to_fun\" functions coincide on all inputs, then the equivs are equal. <code>ext</code> is using this because <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.perm.ext\">docs#equiv.perm.ext</a> is tagged with <code>ext</code> in data.equiv.basic.</p>",
        "id": 208108418,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598456122
    },
    {
        "content": "<p>As a side-note: The weird thing is that this gives me <code>map_one' := by { refine perm.ext (λ (x : G), _[x]), simp},</code>, which gives me the error <code>placeholders '_' cannot be used where a function is expected</code></p>",
        "id": 208129727,
        "sender_full_name": "Chris M",
        "timestamp": 1598466657
    },
    {
        "content": "<p>What are you expecting with <code>_[x]</code>? I'm not familiar with that notation.  What happens if you replace it with just <code>_</code>?</p>",
        "id": 208129838,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598466710
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> , to be clear, this is what <code>show_term {ext}</code> gives me, I didn't adjust anything about it and I am not familiar with the notation either. You're right, replacing it with <code>_</code> makes it work.</p>",
        "id": 208130089,
        "sender_full_name": "Chris M",
        "timestamp": 1598466805
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> , Regarding the <code>ext</code> tactic though. Thanks, this clarifies a lot :).</p>",
        "id": 208130223,
        "sender_full_name": "Chris M",
        "timestamp": 1598466850
    },
    {
        "content": "<p>An unfortunate property of the pretty printer is that what it prints is not always what Lean accepts as source code.</p>",
        "id": 208130234,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598466856
    },
    {
        "content": "<p>I'm curious, what if you do <code>set_option pp.proofs true</code> at the top level?  Does it still print as <code>_[x]</code>?  I think it might be hiding a \"proof\" with an underscore, but that  proof is a metavariable.</p>",
        "id": 208130379,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598466927
    },
    {
        "content": "<p>Doesn't change anything. (I placed it directly above the definition of <code>cayley</code>).</p>",
        "id": 208130607,
        "sender_full_name": "Chris M",
        "timestamp": 1598467026
    },
    {
        "content": "<p>You should just put <code>_</code> there instead of <code>_[x]</code></p>",
        "id": 208131063,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598467238
    },
    {
        "content": "<p>Yes I did that after Kyle Miller's suggestion and it worked</p>",
        "id": 208131137,
        "sender_full_name": "Chris M",
        "timestamp": 1598467272
    },
    {
        "content": "<p>I just used show_term to see which function Lean had applied. <code>show_term {ext}</code> is a great way to start moving from a tactic proof to a term proof</p>",
        "id": 208135041,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598469205
    }
]
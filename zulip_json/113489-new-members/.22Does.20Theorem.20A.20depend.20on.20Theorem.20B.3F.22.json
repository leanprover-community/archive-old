[
    {
        "content": "<p>Is there something like <code>#print axioms</code> that can tell me whether the proof of some particular theorem depends on some other theorem, either directly or through some chain of dependencies?  For example, I just proved something that looked like it ought to depend on <code>nat.factors_unique</code> and wanted to confirm that it really was using that lemma.  To check this I had to do a series of searches in my file to trace out the chain of dependencies from <code>nat.factors_unique</code>.  That was a simple enough relay race in my case, but is there an automated way to do this?</p>",
        "id": 262230711,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1637485898
    },
    {
        "content": "<p><code>#print</code> will show you the term-mode proof, which includes the exact list of lemmas used (even the ones found by <code>simp</code> in the background)</p>",
        "id": 262232448,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637488725
    },
    {
        "content": "<p>I don't know of anything out of the box, but it shouldn't be too difficult to make something like this (based on Mario's get axioms perhaps <a href=\"#narrow/stream/113489-new-members/topic/intuitionistic.20logic/near/224372208\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/intuitionistic.20logic/near/224372208</a>)</p>",
        "id": 262233709,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637490674
    },
    {
        "content": "<p><code>#print</code> reveals the direct antecedents to the lemma but not their dependencies in turn.  I guess it should be possible to recursively apply something like this, building up the list of dependencies until either the target is found or some termination condition is reached.</p>",
        "id": 262236797,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1637495618
    },
    {
        "content": "<p>At some point I'll inevitably be drawn into learning how to write tactics, and then something like this might be a good project to work on.</p>",
        "id": 262236858,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1637495680
    },
    {
        "content": "<p>One dumb way to solve this is just replace the proof in question with <code>sorry</code> and see which other proofs start complaining</p>",
        "id": 262236883,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637495737
    },
    {
        "content": "<p>You'll have to wait for compilation, but it answers the question with minimal actual work by you</p>",
        "id": 262236930,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637495773
    },
    {
        "content": "<p>Or maybe even turn the theorem into an axiom and then you will find it in <code>#print axioms</code> if the other theorem depends on it</p>",
        "id": 262237314,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1637496269
    },
    {
        "content": "<p>I didn't test it so much yet so use with caution and if you find any errors please tell me and I'll fix it, but this is what I had in mind:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.prime</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">tactic.does_use_aux</span> <span class=\"o\">(</span><span class=\"n\">env</span> <span class=\"o\">:</span> <span class=\"n\">environment</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tgt</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">name</span> <span class=\"bp\">→</span>\n  <span class=\"n\">bool</span> <span class=\"bp\">×</span> <span class=\"n\">name_set</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"o\">(</span><span class=\"n\">bool</span> <span class=\"bp\">×</span> <span class=\"n\">name_set</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"n\">p</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">ns</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">ns.contains</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">pure</span> <span class=\"n\">p</span> <span class=\"k\">else</span> <span class=\"k\">do</span>\n  <span class=\"n\">d</span> <span class=\"bp\">←</span> <span class=\"n\">env.get</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">ns</span> <span class=\"o\">:=</span> <span class=\"n\">ns.insert</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">process</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"o\">(</span><span class=\"n\">bool</span> <span class=\"bp\">×</span> <span class=\"n\">name_set</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"k\">do</span>\n    <span class=\"n\">v.fold</span> <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">||</span> <span class=\"o\">(</span><span class=\"n\">d.to_name</span> <span class=\"bp\">=</span> <span class=\"n\">tgt</span><span class=\"o\">),</span> <span class=\"n\">ns</span><span class=\"o\">))</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"n\">_</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n      <span class=\"k\">if</span> <span class=\"n\">e.is_constant</span> <span class=\"k\">then</span> <span class=\"n\">tactic.does_use_aux</span> <span class=\"n\">e.const_name</span> <span class=\"n\">p</span> <span class=\"k\">else</span> <span class=\"n\">pure</span> <span class=\"n\">p</span><span class=\"o\">),</span>\n  <span class=\"k\">match</span> <span class=\"n\">d</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">declaration.defn</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">v</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">process</span> <span class=\"n\">v</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">declaration.thm</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">v</span><span class=\"o\">)</span>      <span class=\"o\">:=</span> <span class=\"n\">process</span> <span class=\"n\">v.get</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">ns</span><span class=\"o\">)</span>\n  <span class=\"kd\">end</span>\n\n<span class=\"sd\">/-- does `src` use `tgt`? -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">tactic.does_use</span> <span class=\"o\">(</span><span class=\"n\">src</span> <span class=\"n\">tgt</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">tactic.get_env</span><span class=\"o\">,</span>\n  <span class=\"n\">prod.fst</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">tactic.does_use_aux</span> <span class=\"n\">env</span> <span class=\"n\">tgt</span> <span class=\"n\">src</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"n\">mk_name_set</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">tactic.does_use</span> <span class=\"bp\">`</span><span class=\"n\">nat.prime.factors_pow</span> <span class=\"bp\">``</span><span class=\"n\">nat.factors_unique</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">tactic.trace</span>\n</code></pre></div>",
        "id": 262237659,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637496720
    },
    {
        "content": "<p>Here's a variation on that axiom checking code to check if an arbitrary theorem depends on an arbitrary set of other theorems/definitions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">tactic.get_dependents_aux</span> <span class=\"o\">(</span><span class=\"n\">env</span> <span class=\"o\">:</span> <span class=\"n\">environment</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">name</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">name</span> <span class=\"bp\">→</span>\n  <span class=\"n\">list</span> <span class=\"n\">name</span> <span class=\"bp\">×</span> <span class=\"n\">name_set</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">name</span> <span class=\"bp\">×</span> <span class=\"n\">name_set</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"n\">p</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">ns</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">ns.contains</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">pure</span> <span class=\"n\">p</span> <span class=\"k\">else</span> <span class=\"k\">do</span>\n  <span class=\"n\">d</span> <span class=\"bp\">←</span> <span class=\"n\">env.get</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">ns</span> <span class=\"o\">:=</span> <span class=\"n\">ns.insert</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">process</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">name</span> <span class=\"bp\">×</span> <span class=\"n\">name_set</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"k\">do</span>\n    <span class=\"n\">v.fold</span> <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">ns</span><span class=\"o\">))</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"n\">_</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n      <span class=\"k\">if</span> <span class=\"n\">e.is_constant</span> <span class=\"k\">then</span> <span class=\"n\">tactic.get_dependents_aux</span> <span class=\"n\">e.const_name</span> <span class=\"n\">p</span> <span class=\"k\">else</span> <span class=\"n\">pure</span> <span class=\"n\">p</span><span class=\"o\">),</span>\n  <span class=\"k\">if</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">::</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">ns</span><span class=\"o\">)</span> <span class=\"k\">else</span>\n  <span class=\"k\">match</span> <span class=\"n\">d</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">declaration.defn</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">v</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">process</span> <span class=\"n\">v</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">declaration.thm</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">v</span><span class=\"o\">)</span>      <span class=\"o\">:=</span> <span class=\"n\">process</span> <span class=\"n\">v.get</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">ns</span><span class=\"o\">)</span>\n  <span class=\"kd\">end</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">tactic.get_dependents</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">environment</span> <span class=\"bp\">→</span> <span class=\"n\">name</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">tactic.get_env</span><span class=\"o\">,</span>\n  <span class=\"n\">prod.fst</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">tactic.get_dependents_aux</span> <span class=\"n\">env</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">env</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"o\">([],</span> <span class=\"n\">mk_name_set</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">do</span>\n  <span class=\"n\">tactic.get_dependents</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"bp\">`</span><span class=\"n\">classical.some</span><span class=\"o\">)</span> <span class=\"bp\">`</span><span class=\"n\">classical.em</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">tactic.trace</span>\n  <span class=\"c1\">-- [classical.some]</span>\n</code></pre></div>\n<p>The lambda is a predicate yielding possible sources (i.e. \"theorem A\") and the second argument is the sink (\"theorem B\"), and it returns the set of elements satisfying the predicate among the dependencies, so if it's empty then it doesn't depend on the value.</p>",
        "id": 262237698,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1637496732
    },
    {
        "content": "<p>LOL nice Mario <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 262237709,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637496782
    },
    {
        "content": "<p>Wow, thanks!</p>",
        "id": 262237995,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1637497222
    },
    {
        "content": "<p>Actually, here's a more useful version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">tactic.get_dependents_aux</span> <span class=\"o\">(</span><span class=\"n\">env</span> <span class=\"o\">:</span> <span class=\"n\">environment</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">name</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">name</span> <span class=\"bp\">→</span>\n  <span class=\"n\">bool</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"n\">name</span> <span class=\"bp\">×</span> <span class=\"n\">name_map</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"o\">(</span><span class=\"n\">bool</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"n\">name</span> <span class=\"bp\">×</span> <span class=\"n\">name_map</span> <span class=\"n\">bool</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">b₁</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">ns</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">ns.find</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">b₁</span> <span class=\"bp\">||</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"n\">d</span> <span class=\"bp\">←</span> <span class=\"n\">env.get</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">process</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"o\">(</span><span class=\"n\">bool</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"n\">name</span> <span class=\"bp\">×</span> <span class=\"n\">name_map</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"k\">do</span>\n      <span class=\"n\">v.fold</span> <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">ns</span><span class=\"o\">))</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"n\">_</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n        <span class=\"k\">if</span> <span class=\"n\">e.is_constant</span> <span class=\"k\">then</span> <span class=\"n\">tactic.get_dependents_aux</span> <span class=\"n\">e.const_name</span> <span class=\"n\">p</span> <span class=\"k\">else</span> <span class=\"n\">pure</span> <span class=\"n\">p</span><span class=\"o\">),</span>\n    <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">ns</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"k\">if</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">tt</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">ns</span><span class=\"o\">)</span> <span class=\"k\">else</span>\n      <span class=\"k\">match</span> <span class=\"n\">d</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">declaration.defn</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">v</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">process</span> <span class=\"n\">v</span>\n      <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">declaration.thm</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">v</span><span class=\"o\">)</span>      <span class=\"o\">:=</span> <span class=\"n\">process</span> <span class=\"n\">v.get</span>\n      <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">ns</span><span class=\"o\">)</span>\n      <span class=\"kd\">end</span><span class=\"o\">,</span>\n    <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">b₁</span> <span class=\"bp\">||</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">b</span> <span class=\"k\">then</span> <span class=\"n\">n</span><span class=\"o\">::</span><span class=\"n\">l</span> <span class=\"k\">else</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">ns.insert</span> <span class=\"n\">n</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"kd\">end</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">tactic.get_dependents</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">environment</span> <span class=\"bp\">→</span> <span class=\"n\">name</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">tactic.get_env</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">ns</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">tactic.get_dependents_aux</span> <span class=\"n\">env</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">env</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"o\">[],</span> <span class=\"n\">mk_name_map</span><span class=\"o\">),</span>\n  <span class=\"n\">pure</span> <span class=\"n\">l</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">do</span>\n  <span class=\"n\">tactic.get_dependents</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"bp\">`</span><span class=\"n\">classical.some</span><span class=\"o\">)</span> <span class=\"bp\">``</span><span class=\"n\">classical.by_contradiction</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">tactic.trace</span>\n  <span class=\"c1\">-- [classical.by_contradiction,</span>\n  <span class=\"c1\">--  classical.prop_decidable,</span>\n  <span class=\"c1\">--  classical.prop_decidable._proof_1,</span>\n  <span class=\"c1\">--  classical.em,</span>\n  <span class=\"c1\">--  _private.3251178891.p_implies_uv,</span>\n  <span class=\"c1\">--  _private.3239198671.not_uv_or_p,</span>\n  <span class=\"c1\">--  _private.3639808893.v,</span>\n  <span class=\"c1\">--  _private.2514476823.u,</span>\n  <span class=\"c1\">--  classical.some]</span>\n</code></pre></div>\n<p>The input is the same, a target theorem and a source predicate, but now it returns the list of all theorems in the dependency lattice between the source and target, which should give you a sense of what the critical path is.</p>",
        "id": 262238284,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1637497625
    },
    {
        "content": "<p>That's fantastic, thank you!</p>",
        "id": 262238655,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1637498091
    },
    {
        "content": "<p>And indeed running </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"k\">do</span>\n  <span class=\"n\">tactic.get_dependents</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"bp\">`</span><span class=\"n\">nat.factors_unique</span><span class=\"o\">)</span>\n     <span class=\"bp\">``</span><span class=\"n\">prime_factorization_unique_of_pos</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">tactic.trace</span>\n</code></pre></div>\n<p>confirms that <code>prime_factorization_unique_of_pos</code> depends on <code>nat.factors_unique</code>, as expected:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">([</span><span class=\"n\">nat.factors_unique</span><span class=\"o\">],</span>\n <span class=\"o\">[</span><span class=\"n\">nat.prime_factorization_injective_on_pos</span><span class=\"o\">,</span>\n  <span class=\"n\">nat.factors_unique</span><span class=\"o\">,</span>\n  <span class=\"n\">nat.prime_factorization_unique_of_pos</span><span class=\"o\">,</span>\n  <span class=\"n\">nat.perm_factors_mul_of_coprime</span><span class=\"o\">,</span>\n  <span class=\"n\">nat.factor_count_eq_of_coprime_left</span><span class=\"o\">,</span>\n  <span class=\"n\">nat.perm_factors_mul_of_pos</span><span class=\"o\">,</span>\n  <span class=\"n\">nat.prime.factors_pow</span><span class=\"o\">,</span>\n  <span class=\"n\">nat.multiplicative_factorization</span><span class=\"o\">,</span>\n  <span class=\"n\">nat.prime_factorization_prod_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">nat.prime_factorization_union_of_coprime</span><span class=\"o\">,</span>\n  <span class=\"n\">nat.prime_factorization_prime_pos_pow</span><span class=\"o\">,</span>\n  <span class=\"n\">nat.factor_count_eq_of_coprime_right</span><span class=\"o\">])</span>\n</code></pre></div>",
        "id": 262238734,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1637498218
    },
    {
        "content": "<p>(updated the code above to use the <code>list name</code> the way it was intended. Now the list is in DFS dependency order instead of random order)</p>",
        "id": 262239003,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1637498654
    }
]
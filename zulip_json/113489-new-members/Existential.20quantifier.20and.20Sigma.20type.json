[
    {
        "content": "<p>I am confused about existential quantifiers and Sigma types.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">constant</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span>\n<span class=\"k\">#check</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"bp\">Σ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>Why is <code>Σ x</code> syntactically incorrect whereäs both <code>Π x</code> and <code>∀ x</code> are syntactically correct (and mean the same thing)? Isn't <code>∀</code> just a syntactic sugar for <code>Π</code> in the same way that <code>∃</code> is, at least I supposed, a syntactic sugar for <code>Σ</code> under the assumption that <code>p x : Prop</code> ?</p>",
        "id": 264328034,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639067876
    },
    {
        "content": "<p>(First, all of these are <em>syntactically</em> correct.)<br>\n<code>∀</code> and <code>Π</code> are indeed the same, but <code>∃</code> and <code>Σ</code> are completely separate: the first is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Exists\">docs#Exists</a> and the second is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sigma\">docs#sigma</a>.</p>",
        "id": 264328721,
        "sender_full_name": "Reid Barton",
        "timestamp": 1639068146
    },
    {
        "content": "<p>Oh, sorry, I considered type mismatch to be a kind of syntactic error.</p>",
        "id": 264328868,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639068220
    },
    {
        "content": "<p>How can I find a similar documentation for Pi instead of Sigma?</p>",
        "id": 264329958,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639068632
    },
    {
        "content": "<p>Pi is a primitive. There's some info on it in <a href=\"https://leanprover.github.io/theorem_proving_in_lean/quantifiers_and_equality.html#the-universal-quantifier\">section 4.1 of TPIL</a>.</p>",
        "id": 264330353,
        "sender_full_name": "Chris B",
        "timestamp": 1639068803
    },
    {
        "content": "<p>What is the difference between Pi being primitive and Sigma not being primitive? Does Pi have a constructor (as a structure) as well?</p>",
        "id": 264331067,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639069104
    },
    {
        "content": "<p>No, it doesn't have a constructor. Pi/forall is a kind of expression that the kernel handles directly because it's  'part of the system'. Sigma is an inductive type that gets declared by users.</p>",
        "id": 264332195,
        "sender_full_name": "Chris B",
        "timestamp": 1639069525
    },
    {
        "content": "<p>Oh, thank you!</p>",
        "id": 264332407,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639069601
    },
    {
        "content": "<p>This leaves me with the last question: Why cannot <code>∃</code> be translated to <code>Σ</code> in the similar way how <code>∀</code> is translated to <code>Π</code> (or maybe not translated to the other symbol but both being translated to the same kernel expression)?</p>",
        "id": 264332818,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639069775
    },
    {
        "content": "<p><code>∀</code> only exists in the pretty printer and as notation (for <code>Π a, p a</code> when <code>p a : Prop</code>), there's no real translation happening. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sigma\">docs#sigma</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Exists\">docs#Exists</a> are different types.</p>",
        "id": 264332977,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639069831
    },
    {
        "content": "<p>Yes, thanks, but why do they need to be different types?</p>",
        "id": 264333102,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639069876
    },
    {
        "content": "<p>Because they reside in different universes</p>",
        "id": 264333147,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639069891
    },
    {
        "content": "<p>Respectively, <code>sigma p : Type (max u v)</code>, <code>psigma p : Sort (max 1 u v)</code>, <code>Exists p : Prop</code></p>",
        "id": 264333348,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639069963
    },
    {
        "content": "<p>arguably we don't need both <code>sigma</code> and <code>psigma</code>, beyond the fact that <code>Sort (max 1 u v)</code> isannoying vs <code>Type (max u v)</code></p>",
        "id": 264333494,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639070021
    },
    {
        "content": "<p>I can now see that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">constant</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"mi\">3</span>\n<span class=\"k\">#check</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>is also correct.</p>",
        "id": 264333563,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639070042
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264333147\">said</a>:</p>\n<blockquote>\n<p>Because they reside in different universes</p>\n</blockquote>\n<p>But why can <code>Π x : α</code> eat <code>p : α -&gt; Sort 0</code> which <code>Σ x : α</code> rejects?</p>",
        "id": 264334144,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639070231
    },
    {
        "content": "<p><code>sigma</code> rejects that because it's defined to reject that</p>",
        "id": 264334301,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639070291
    },
    {
        "content": "<p><code>psigma</code>, <code>Σ' x, p x</code> doesn't, but is more annoying to work with</p>",
        "id": 264334311,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639070296
    },
    {
        "content": "<p>Yes, I see, but why is <code>Π</code> ok with that?</p>",
        "id": 264334364,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639070322
    },
    {
        "content": "<p>Because it's not defined like sigma?</p>",
        "id": 264334422,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639070345
    },
    {
        "content": "<p>The similarities end with the syntax being similar</p>",
        "id": 264334468,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639070364
    },
    {
        "content": "<p>Is there a fundamental reason why <code>Π</code> can be more versatile than <code>Σ</code> is?</p>",
        "id": 264334582,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639070405
    },
    {
        "content": "<p>maybe this helps compare the exact differences:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"c1\">-- the most general form of pi, just so that we can #check</span>\n<span class=\"kd\">def</span> <span class=\"k\">Pi</span><span class=\"bp\">'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"n\">i</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"k\">Pi</span><span class=\"bp\">'.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span>    <span class=\"c1\">-- Π {α : Sort u}, (α → Sort v) → Sort (imax u v)</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">psigma.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"c1\">-- Π {α : Sort u}, (α → Sort v) → Sort (max 1 u v)</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">sigma.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span>  <span class=\"c1\">-- Π {α : Type u}, (α → Type v) → Type (max u v)</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">Exists.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span>   <span class=\"c1\">-- Π {α : Sort u}, (α → Prop)   → Prop</span>\n</code></pre></div>",
        "id": 264334879,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639070531
    },
    {
        "content": "<p>Oh, it seems to be the magic inside <code>imax</code>.</p>",
        "id": 264335845,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639070939
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264334582\">said</a>:</p>\n<blockquote>\n<p>Is there a fundamental reason why <code>Π</code> can be more versatile than <code>Σ</code> is?</p>\n</blockquote>\n<p>That's just how the type theory works. Inductive types have to abide by certain rules to keep things from being inconsistent.</p>",
        "id": 264335925,
        "sender_full_name": "Chris B",
        "timestamp": 1639070972
    },
    {
        "content": "<p>A variation on <code>psigma</code> with the type <code>Π {α : Sort u}, (α → Sort v) → Sort (imax u v)</code> would not be desirable, because it would not have a first projection (like exists) and would also not have proof irrelevance, so it is sort of the worst of both worlds</p>",
        "id": 264336948,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639071362
    },
    {
        "content": "<p><code>(p)sigma</code> and <code>exists</code> have fundamentally different ways of getting information out of them: <code>sigma</code> has first and second projections, while <code>Exists</code> uses <code>Exists.rec</code> which only works for proving propositions, but on the other hand satisfies equations like <code>\\&lt;0, trivial\\&gt; = \\&lt;1, trivial\\&gt;</code> (as elements of, say, <code>\\exists n : nat, true</code>)</p>",
        "id": 264337426,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639071558
    },
    {
        "content": "<p><del>(I assume you meant \"like (p)sigma\" and not \"like exists\")</del> words are hard, \"would not (have X like Y)\" vs \"(would not have X) like Y\"</p>",
        "id": 264337443,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639071565
    },
    {
        "content": "<p>the parenthetical refers to the previous 6 words, not just the last 2</p>",
        "id": 264337599,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639071620
    },
    {
        "content": "<p>Can you please check for me that I extracted the main informations correctly?<br>\n<a href=\"/user_uploads/3121/YiVyy1H7BjkVRBGb5l4_fuLL/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/YiVyy1H7BjkVRBGb5l4_fuLL/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/YiVyy1H7BjkVRBGb5l4_fuLL/image.png\"></a></div>",
        "id": 264338638,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639072040
    },
    {
        "content": "<p>\"they don't have a constructor; they live kind of beyond the system\" is inaccurate. <code>Pi</code> has a constructor, it is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/expr.pi\">docs#expr.pi</a> . It is a builtin term constructor, unlike all other constructors which use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/expr.const\">docs#expr.const</a> for various choices of constant</p>",
        "id": 264339261,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639072283
    },
    {
        "content": "<p>Maybe it would also help to get rid of the type theory language. Let's just define a \"proposition\" to be a set with at most one element. If we form the product of a bunch of propositions, the result is again a proposition. However if we form the sum of a bunch of propositions, there's no reason why the result should have at most one element. Then I can decide to either truncate it to make a proposition again, or not. That's the difference between <code>Exists</code> and <code>sigma</code>.</p>",
        "id": 264339284,
        "sender_full_name": "Reid Barton",
        "timestamp": 1639072295
    },
    {
        "content": "<p><code>α × β</code> is not shorthand syntax for <code>Σ _ : α, β</code>. The former uses <code>prod</code> and the latter uses <code>sigma</code>. (Yes, this is not consistent with the behavior for <code>→</code> / <code>∀</code>.)</p>",
        "id": 264339489,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639072385
    },
    {
        "content": "<p>But it could have been, right? It just would have been annoying to use had it been defined that way.</p>",
        "id": 264340357,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639072710
    },
    {
        "content": "<p>Yes, you could conceivably define it that way. You would probably want more builtin sugar for it</p>",
        "id": 264340434,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639072748
    },
    {
        "content": "<p>I'm sure there are examples where the type inference is not as good</p>",
        "id": 264340519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639072788
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264339261\">said</a>:</p>\n<blockquote>\n<p><code>Pi</code> has a constructor, it is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/expr.pi\">docs#expr.pi</a> .</p>\n</blockquote>\n<p>I think introducing <code>meta inductive expr</code> sort of overloads the statement \"Pi has a constructor\" in a way that might not be helpful to someone learning the type theory.</p>",
        "id": 264342036,
        "sender_full_name": "Chris B",
        "timestamp": 1639073363
    },
    {
        "content": "<p>E.g. TPIL introduces Pi as something that's explicitly not an inductive: <code>in Lean’s library, every concrete type other than the universes and every type constructor other than Pi is an instance of a general family of type constructions known as inductive types</code>.</p>",
        "id": 264343186,
        "sender_full_name": "Chris B",
        "timestamp": 1639073710
    },
    {
        "content": "<p>True. But \"beyond the system\" was the main thing I wanted to address. It is more primitive than usual, but still something in the system</p>",
        "id": 264343223,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639073718
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264339261\">said</a>:</p>\n<blockquote>\n<p>\"they don't have a constructor; they live kind of beyond the system\" is inaccurate. <code>Pi</code> has a constructor, it is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/expr.pi\">docs#expr.pi</a> . It is a builtin term constructor, unlike all other constructors which use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/expr.const\">docs#expr.const</a> for various choices of constant</p>\n</blockquote>\n<p>What does <code>(elaborated : bool := tt)</code> mean, please?</p>",
        "id": 264343739,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639073911
    },
    {
        "content": "<p>To simplify representation, lean uses the same inductive type for both <code>expr := expr tt</code> and <code>pexpr := expr ff</code>, but <code>pexpr</code> (pre-expression) is only used during parsing and you can ignore it for the purpose of learning the theory</p>",
        "id": 264344045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639074039
    },
    {
        "content": "<p>Thank you all for your replies! It will take me a longer while to understand it and summarize it. Until then, my study notes will contain those mistakes that were pointed out above.</p>",
        "id": 264344428,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639074210
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris B</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264343186\">said</a>:</p>\n<blockquote>\n<p>E.g. TPIL introduces Pi as something that's explicitly not an inductive: <code>in Lean’s library, every concrete type other than the universes and every type constructor other than Pi is an instance of a general family of type constructions known as inductive types</code>.</p>\n</blockquote>\n<p>This sentence doesn't refer to the meaning of the word instance that is connected to typeclasses, does it?</p>",
        "id": 264461198,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639149392
    },
    {
        "content": "<p>Current version of my notes contains:<br>\n<a href=\"/user_uploads/3121/PdBSOHHdE6O4kqq7oNyWL5fF/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/PdBSOHHdE6O4kqq7oNyWL5fF/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/PdBSOHHdE6O4kqq7oNyWL5fF/image.png\"></a></div>",
        "id": 264465640,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639151349
    },
    {
        "content": "<p>It's hard to rell from the pixels, but you seem to be using <code>(a, b)</code> as notation for <code>sigma.mk</code>, whereas it's actually notation for <code>prod.mk</code>. Maybe those are angle brackets and the image is too small to tell though.</p>",
        "id": 264466071,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639151516
    },
    {
        "content": "<p>Is <code>z = (a, b)</code> incorrect?</p>",
        "id": 264466234,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639151574
    },
    {
        "content": "<p>Eh. The tuple notation in parenthesis is for <code>prod</code>, right? For <code>sigma</code>, I should have used chevrons (langle and rangle), right?</p>",
        "id": 264467091,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639151900
    },
    {
        "content": "<p>\"chevrons\" work for all inductive types with one constructor, so both prod and sigma. <code>(_, _, ...)</code> is only for <code>prod</code></p>",
        "id": 264471704,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639153708
    },
    {
        "content": "<p>Can I do a product of three types without nesting them? Or is it a property of the ˙( )˙ that it gets flattened?</p>",
        "id": 264472132,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639153917
    },
    {
        "content": "<p>The chevrons associate to the right, so <code>\\&lt;_,\\&lt;_,_\\&gt;\\&gt;</code> is the same as <code>\\&lt;_,_,_\\&gt;</code>.</p>",
        "id": 264473155,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639154375
    },
    {
        "content": "<p>Does the same apply for parentheses?</p>",
        "id": 264473273,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639154408
    },
    {
        "content": "<p>I would imagine so...</p>",
        "id": 264473294,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639154416
    },
    {
        "content": "<p>As long as you don't define your triple product at <code>(A \\x B) \\x C</code>, but rather use <code>A \\x B \\x C</code>, you should be able to write <code>(a,b,c)</code> (or with <code>\\&lt;...\\&gt;</code>)</p>",
        "id": 264473373,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639154458
    },
    {
        "content": "<p>Oh yes. And \\times associates in the same way. For example <code>int × Type × nat</code> is a short for <code>int × (Type × nat)</code>.</p>",
        "id": 264473676,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639154615
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264461198\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris B</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264343186\">said</a>:</p>\n<blockquote>\n<p>E.g. TPIL introduces Pi as something that's explicitly not an inductive: <code>in Lean’s library, every concrete type other than the universes and every type constructor other than Pi is an instance of a general family of type constructions known as inductive types</code>.</p>\n</blockquote>\n<p>This sentence doesn't refer to the meaning of the word instance that is connected to typeclasses, does it?</p>\n</blockquote>\n<p>It does not.</p>",
        "id": 264477435,
        "sender_full_name": "Chris B",
        "timestamp": 1639156279
    },
    {
        "content": "<p>Did I get it right, please?<br>\n<a href=\"/user_uploads/3121/wC_6-9QTQ_TQGk6tjClPb3oi/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/wC_6-9QTQ_TQGk6tjClPb3oi/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/wC_6-9QTQ_TQGk6tjClPb3oi/image.png\"></a></div>",
        "id": 264482490,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639158574
    },
    {
        "content": "<p>The parentheses don't stand for <code>g.mk</code>, but for <code>prod.mk</code>. In your notations <code>g</code> is a term of a product type, the prefix is the name of the type, not the term</p>",
        "id": 264485709,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1639159867
    },
    {
        "content": "<p>Oh, thank you!<br>\nIs it all right now?<br>\n<a href=\"/user_uploads/3121/Aeh923TmsG0URUtp4_zcvN8N/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/Aeh923TmsG0URUtp4_zcvN8N/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/Aeh923TmsG0URUtp4_zcvN8N/image.png\"></a></div>",
        "id": 264486762,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639160133
    },
    {
        "content": "<p>Well, conceptually at least yes, if you just want to use <code>g</code> to simplify the notation in your notes.</p>",
        "id": 264487366,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1639160395
    },
    {
        "content": "<p>But keep in mind that won't work as actual Lean code. If you were to define <code>g := prod</code>, then <code>g.mk</code> still wouldn't exist, only <code>prod.mk</code></p>",
        "id": 264487542,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1639160464
    },
    {
        "content": "<p>I am not sure whether I understand you. In my snippet,  I have <code>g = τ × δ</code> which is <code>g = prod τ δ</code> and not just <code>g = prod</code>.</p>",
        "id": 264488060,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639160680
    },
    {
        "content": "<p>Does <code>g.mk</code> exists then? Or how can I write a term of the type <code>g</code> without the syntactic sugar?</p>",
        "id": 264488210,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639160739
    },
    {
        "content": "<p>No, only <code>prod.mk</code> exists. You'd write <code>prod.mk bar baz</code></p>",
        "id": 264488353,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639160798
    },
    {
        "content": "<p>:-o</p>",
        "id": 264488441,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639160835
    },
    {
        "content": "<p>Does <code>h.mk</code> exist?</p>",
        "id": 264488515,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639160871
    },
    {
        "content": "<p>Also note that there is only one <code>prod.mk</code> for all <code>\\tau</code> and <code>\\delta</code>, it's not that for each two types you get some other <code>(prod \\tau \\delta).mk</code> (that's what your notation would suggest to me)</p>",
        "id": 264488618,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1639160905
    },
    {
        "content": "<p>No, for Sigma it's the same thing, and probably for any such type definition</p>",
        "id": 264488759,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1639160977
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329243\">Horatiu Cheval</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264488759\">said</a>:</p>\n<blockquote>\n<p>No, for Sigma it's the same thing, and probably for any such type definition</p>\n</blockquote>\n<p>Are you replying to <code>h.mk</code> here?</p>",
        "id": 264488983,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639161068
    },
    {
        "content": "<p>Yes</p>",
        "id": 264489224,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1639161174
    },
    {
        "content": "<p>Ah. Thanks a lot!</p>",
        "id": 264489257,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639161191
    },
    {
        "content": "<p>When I write <code>prod.mk</code> it works but when I write <code>Σ.mk</code> it doesn't work. How can I invoke the constructor explicitly (without chevrons)?</p>",
        "id": 264490755,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639161878
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/sigma.mk\">docs#sigma.mk</a></p>",
        "id": 264490800,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1639161899
    },
    {
        "content": "<p>I wrote:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">constant</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">constant</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"kd\">constant</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">a</span>\n<span class=\"k\">#check</span> <span class=\"n\">sigma.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n<span class=\"k\">#check</span> <span class=\"bp\">Σ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>The output is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">sigma</span> <span class=\"n\">β</span>\n<span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">β</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n</code></pre></div>\n<p>By looking at it, I don't know what the relationship between them is. So I added:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mytype</span> <span class=\"o\">:=</span> <span class=\"bp\">Σ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"n\">sigma.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>Unfortunately, the output is again:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">sigma</span> <span class=\"n\">β</span>\n</code></pre></div>\n<p>How can I obtain <code>(sigma.mk a b) : mytype</code> please?</p>",
        "id": 264492598,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639162709
    },
    {
        "content": "<p>Does <code>#check (sigma.mk a b : mytype)</code> work? In any case, the thing is that you have to explicitly type-annotate it</p>",
        "id": 264493073,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1639162894
    },
    {
        "content": "<p>By <code>#check (sigma.mk a b : mytype)</code> I obtain <code>⟨a, b⟩ : Σ (x : α), β x</code> which makes me more happy than the previous thing.</p>",
        "id": 264493287,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639162977
    },
    {
        "content": "<p>What would happen if, for concrete types, I would end up with <code>β a</code> being <code>int</code> for example? Would it still know that a term constructed by <code>sigma.mk a 5</code> is of the type <code>mytype</code>?</p>",
        "id": 264494099,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639163359
    },
    {
        "content": "<p>The way it's written here no, I don't think you will be able to do <code>def x : mtytype := sigma.mk a 5</code>, because <code>mytype</code> is just <code>Type</code>, it's not parametrized. In your definition <code>\\alpha</code> and <code>\\beta</code> are fixed constants, so they argument for the type <code>mytype</code></p>",
        "id": 264494496,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1639163536
    },
    {
        "content": "<p>You would be able to do that if used <code>variable</code> instead of <code>constant</code> for example</p>",
        "id": 264494531,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1639163565
    },
    {
        "content": "<p>Is it now correct?<br>\n<a href=\"/user_uploads/3121/6xvEjccEtaL16m3zADV3SzHV/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/6xvEjccEtaL16m3zADV3SzHV/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/6xvEjccEtaL16m3zADV3SzHV/image.png\"></a></div>",
        "id": 264495087,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639163841
    },
    {
        "content": "<p>I originally (wrongly) assumed that I could use <code>mytype.mk</code> and I would get (when provided correct arguments) a term of the type <code>mytype</code>. Now I can see that I cannot do it.</p>\n<p>As a result, it makes me uncomfortable that I must write e.g. <code>sigma.mk 5 9</code> but there are many possible sigma types which my term could be an instance of.</p>",
        "id": 264495648,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639164090
    },
    {
        "content": "<p>It seems correct</p>",
        "id": 264495849,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1639164191
    },
    {
        "content": "<p>But I don't really understand your last statement</p>",
        "id": 264495868,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1639164206
    },
    {
        "content": "<p>The reason is that there are many possibly functions  that send <code>5</code> to <code>nat</code></p>",
        "id": 264495993,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639164266
    },
    {
        "content": "<p>Let's say I have <code>f : int -&gt; Type</code> and <code>g : int -&gt; Type</code>. Let's say they agree on the value of <code>f 5 = nat = g 5</code>. Now I call <code>sigma.mk 5 9</code>. Do I have an instance of <code>sigma f</code> or of <code>signa g</code>?</p>",
        "id": 264496203,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639164369
    },
    {
        "content": "<p>Does that even typecheck? It shouldn't</p>",
        "id": 264496231,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1639164387
    },
    {
        "content": "<p>I'm talking about <code>sigma.mk 5 9</code></p>",
        "id": 264496243,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1639164394
    },
    {
        "content": "<p>Because <code>9</code> is not a function</p>",
        "id": 264496254,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1639164404
    },
    {
        "content": "<p>Why should I put function on the position of <code>9</code> in my expression? I have <code>f 5 = nat</code> and not something like <code>f 5 = (nat -&gt; nat)</code>.</p>",
        "id": 264496374,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639164477
    },
    {
        "content": "<p>In general you need to use type annotations to tell lean what the type family is when defining a term of a sigma type.</p>",
        "id": 264496462,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639164510
    },
    {
        "content": "<p>Should I write something like <code>let myvalue := (sigma.mk 5 9 : mytype)</code> ?</p>",
        "id": 264496559,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639164570
    },
    {
        "content": "<p>Oh right, sorry. I thought you meant <code>sigma 5 9</code></p>",
        "id": 264496567,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1639164573
    },
    {
        "content": "<p>What's <code>mytype</code>?</p>",
        "id": 264496601,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639164594
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264496601\">said</a>:</p>\n<blockquote>\n<p>What's <code>mytype</code>?</p>\n</blockquote>\n<p>Say <code>Σ x : int, f x</code>.</p>",
        "id": 264496840,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639164685
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">does_not_typecheck</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"bp\">=</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 264496857,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639164694
    },
    {
        "content": "<p>I would write <code>let myvalue : mytype := ...</code></p>",
        "id": 264496982,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639164746
    },
    {
        "content": "<p>If you want to define something inline, then you can do <code>(... : mytype)</code></p>",
        "id": 264497012,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639164768
    },
    {
        "content": "<p>Maybe a better example: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">ℤ</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">ℤ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">sigma</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">sigma</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">also_does_not_typecheck</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"bp\">=</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 264497469,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639165016
    },
    {
        "content": "<p>Thank you! Your last example explains a lot!</p>",
        "id": 264497550,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639165055
    },
    {
        "content": "<p>I still wasn't technically correct, was I?<br>\n<a href=\"/user_uploads/3121/brenY4pdggN3GD1MAgd23HMc/image.png\">image.png</a> <br>\nHere <code>(prod.mk bar baz)</code> automatically becomes a term of the type <code>τ × δ</code> hence it can be used as an argument of the type <code>g</code>. This isn't true for <code>(sigma.mk bar baz)</code> because I would have to explicitly say that I want a term of the type <code>h</code> (or something definitionally equal to <code>h</code>).</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/brenY4pdggN3GD1MAgd23HMc/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/brenY4pdggN3GD1MAgd23HMc/image.png\"></a></div>",
        "id": 264499061,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639165868
    },
    {
        "content": "<p>The type will generally not be inferred from context if you only write <code>sigma.mk a b</code> or <code>\\&lt;a,b\\&gt;</code>.</p>",
        "id": 264499195,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639165933
    },
    {
        "content": "<p>But it will be inferred for <code>(a,b)</code>, right?</p>",
        "id": 264499268,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639165971
    },
    {
        "content": "<p>Even if you write <code>sigma.mk a b</code>, there will be a metavariable because lean wouldn't know what the type family is without further hints</p>",
        "id": 264499274,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639165974
    },
    {
        "content": "<p>For <code>(a,b)</code> you will get a term of the product, and since lean knows the type of <code>a</code> and <code>b</code>, the type of <code>(a,b)</code> is inferred correctly.</p>",
        "id": 264499327,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639166000
    },
    {
        "content": "<p>For <code>prod.mk a b</code> I will automatically get inferred the right type.</p>",
        "id": 264499363,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639166018
    },
    {
        "content": "<p>Try this out in a vscode and see what happens:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"n\">sigma.mk</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"n\">sigma.mk</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 264499870,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639166269
    },
    {
        "content": "<p>Only the first one passes the typecheck!</p>",
        "id": 264500079,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639166381
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264340519\">said</a>:</p>\n<blockquote>\n<p>I'm sure there are examples where the type inference is not as good</p>\n</blockquote>\n<p>Is [the thing we discussed today (above)] an example of what you were talking about?</p>",
        "id": 264500808,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639166699
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264499195\">said</a>:</p>\n<blockquote>\n<p>The type will generally not be inferred from context if you only write <code>sigma.mk a b</code> or <code>\\&lt;a,b\\&gt;</code>.</p>\n</blockquote>\n<p>highlight 1</p>",
        "id": 264500948,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639166783
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 264500958,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639166790
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264499327\">said</a>:</p>\n<blockquote>\n<p>For <code>(a,b)</code> you will get a term of the product, and since lean knows the type of <code>a</code> and <code>b</code>, the type of <code>(a,b)</code> is inferred correctly.</p>\n</blockquote>\n<p>highlight 2</p>",
        "id": 264501026,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639166843
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> To save you some scrolling and reading, just have a look at the two comments (highlight 1 &amp; 2) above. Is it the motivation you were talking about — sigma could be used for prod but the type inference would be worse.</p>",
        "id": 264501243,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639166950
    },
    {
        "content": "<p>Apologies to derail slightly with a tangential question -- <span class=\"user-mention\" data-user-id=\"417654\">@Martin Dvořák</span> are you using some mind/concept mapping software in the screenshots? If so, which?</p>",
        "id": 264530086,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1639183522
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"417654\">@Martin Dvořák</span> Sure, yes that's an example. I haven't seen the trick with using a beta redex for the second pair element before, but it makes sense that it would work</p>",
        "id": 264539901,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639195811
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264530086\">said</a>:</p>\n<blockquote>\n<p>Apologies to derail slightly with a tangential question -- <span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> are you using some mind/concept mapping software in the screenshots? If so, which?</p>\n</blockquote>\n<p>Yes, it is OrgPad.<br>\n<a href=\"https://orgpad.com/\">https://orgpad.com/</a></p>\n<p>I will be glad if you give me any comments on my (current version of) study notes about Lean.<br>\n<a href=\"https://orgpad.com/s/ZBGjrzoGIBb\">https://orgpad.com/s/ZBGjrzoGIBb</a></p>",
        "id": 264689268,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639392778
    }
]
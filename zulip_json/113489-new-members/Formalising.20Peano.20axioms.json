[
    {
        "content": "<p>Hi everybody,</p>\n<p>I have recently started to look into lean, and, as a learning exercise, I decided to try to formalize Peano axioms in Lean.</p>\n<p>The idea became motivated by an introductory course  about sets and numbers that is taught by my department, so I thought it owuld be nice to prepare some material to show to the students (or instructors) of the course, that fits the corresponding syllabus.</p>\n<p>So they way it is taught, is by assuming some naive set theory, and then stating the following axioms:</p>\n<ol>\n<li>There exists a set named <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span></li>\n<li>There exists an element <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>∈</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">0\\in\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6835em;vertical-align:-0.0391em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span></li>\n<li>There is an injective function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mo>:</mo><mi mathvariant=\"double-struck\">N</mi><mo>→</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">s:\\mathbb{N}\\to\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span></li>\n<li>There is no <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>∈</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">n\\in \\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">s(n)=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></li>\n<li>If a subset <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>⊆</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">S\\subseteq \\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> satisfies that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>∈</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">0\\in S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6835em;vertical-align:-0.0391em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>∈</mo><mi>S</mi><mo>⇒</mo><mi>s</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo><mo>∈</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">n\\in S \\Rightarrow s(s)\\in S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>=</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">S=\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span></li>\n</ol>\n<p>And from there, we go to prove several properties by induction, define the sum and so on.</p>\n<p>I know that the \"right\" way to do this in Lean is to use the inductive type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span>, but since i would like the material to follow the course, i tried to somehow mimic enough of naive set theory instead of making the students switch to think in terms of type theory.</p>\n<p>This was my attempt so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">Conjunto</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"kt\">Type</span>  <span class=\"c1\">-- this is just to use a notation familiar to students</span>\n\n<span class=\"kd\">constant</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">Conjunto</span>   <span class=\"c1\">--  This would be the way to introduce  axiom 1</span>\n<span class=\"kd\">constant</span> <span class=\"n\">cero</span> <span class=\"o\">:</span> <span class=\"n\">N</span>  <span class=\"c1\">--  same for axiom 2</span>\n\n<span class=\"kd\">constant</span> <span class=\"n\">sig</span><span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">siginy</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">sig</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">sig</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span>   <span class=\"c1\">-- these two lines together would be axiom 3</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">ceronosig</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">sig</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">cero</span><span class=\"o\">)</span>  <span class=\"c1\">-- axiom 4</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">induction</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">S</span><span class=\"o\">:(</span><span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">cero</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">S</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">sig</span> <span class=\"n\">n</span><span class=\"o\">)))</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">S</span> <span class=\"n\">n</span> <span class=\"o\">)</span> <span class=\"c1\">--   this is the way I found to introduce axiom 5</span>\n                  <span class=\"c1\">-- It is not exactly the statement of the axiom, since we deal with predicates instead of subsets</span>\n                  <span class=\"c1\">--  but it could be acceptable to reinstate the axiom in these terms</span>\n</code></pre></div>\n<p>So the idea is to be able to use this setting to prove properties by induction. My first attempt was to prove the existence of a predecessor for naturals that are not cero:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">anterior</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"o\">(</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">cero</span><span class=\"o\">)</span>  <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">sig</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">):=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>So now my goal is </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">N</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">cero</span> <span class=\"bp\">∨</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"n\">sig</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>so far so good.</p>\n<p>Now I want to introduce a predicate to apply the induction axiom. I try this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">P1</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>  <span class=\"bp\">∀</span>  <span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">cero</span> <span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">m2</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">sig</span> <span class=\"n\">m2</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">),</span>\n</code></pre></div>\n<p>hoping to get a hypothesis like <code> ∀  m:N, ((m = cero ) ∨ (∃ m2:N, sig m2 = m) )</code> , but what i get is just <code>P1 : Prop</code>, which i cannot use to prove the goal.</p>\n<p>Is there a way to introduce a hypothesis with the type i want? Or is there a better way to formalize my five axioms(that stick to the idea of naive set theory) and prove theorems by inducton?</p>",
        "id": 263777861,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1638723684
    },
    {
        "content": "<p>I don't think declaring axioms like in your code is a good idea. this is because Lean is extremely bad at handling <code>axiom</code>s and <code>constant</code>s. try using <code>variables</code> or typeclasses instead, similar to the suggestions in the <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members/topic/Sebastian.20Zivota\">#new members &gt; Sebastian Zivota</a> thread</p>",
        "id": 263778181,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1638723982
    },
    {
        "content": "<p><a href=\"#narrow/stream/113489-new-members/topic/Sebastian.20Zivota/near/263149134\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Sebastian.20Zivota/near/263149134</a></p>",
        "id": 263778197,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1638724018
    },
    {
        "content": "<p>You want <code>have : ∀ ...,</code> not <code>let p : Prop := ∀ ...</code></p>",
        "id": 263778385,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1638724242
    },
    {
        "content": "<p>assuming \"conjunto\" means set, mathlib has a model of ZFC that you can use <a href=\"https://leanprover-community.github.io/mathlib_docs/set_theory/zfc.html\">https://leanprover-community.github.io/mathlib_docs/set_theory/zfc.html</a></p>",
        "id": 263778476,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1638724353
    },
    {
        "content": "<p>I find it unlikely that the zfc formalization will be at all helpful here</p>",
        "id": 263778765,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1638724733
    },
    {
        "content": "<p>Proof of <code>anterior</code>:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">anterior</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">cero</span> <span class=\"bp\">∨</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"n\">sig</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">induction</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">n</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">use</span> <span class=\"n\">n</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>",
        "id": 263778843,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1638724817
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"270523\">Huỳnh Trần Khanh</span> <a href=\"#narrow/stream/113489-new-members/topic/Formalising.20Peano.20axioms/near/263778181\">said</a>:</p>\n<blockquote>\n<p>I don't think declaring axioms like in your code is a good idea. this is because Lean is extremely bad at handling <code>axiom</code>s and <code>constant</code>s.</p>\n</blockquote>\n<p>I don't think the last half of this statement is true, but certainly the first half is. One way to avoid using <code>axiom</code>s is to use a <code>class</code> instead:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">Conjunto</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"kt\">Type</span>  <span class=\"c1\">-- this is just to use a notation familiar to students</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_N</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">Conjunto</span><span class=\"o\">)</span> <span class=\"o\">:=</span>   <span class=\"c1\">--  This would be the way to introduce  axiom 1</span>\n<span class=\"o\">(</span><span class=\"n\">cero</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span>  <span class=\"c1\">--  same for axiom 2</span>\n<span class=\"o\">(</span><span class=\"n\">sig</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">siginy</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">sig</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">sig</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">)</span>   <span class=\"c1\">-- these two lines together would be axiom 3</span>\n<span class=\"o\">(</span><span class=\"n\">ceronosig</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">sig</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">cero</span><span class=\"o\">))</span>  <span class=\"c1\">-- axiom 4</span>\n<span class=\"o\">(</span><span class=\"n\">induction</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">S</span><span class=\"o\">:(</span><span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">cero</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">S</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">sig</span> <span class=\"n\">n</span><span class=\"o\">)))</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">S</span> <span class=\"n\">n</span> <span class=\"o\">))</span> <span class=\"c1\">--   this is the way I found to introduce axiom 5</span>\n                  <span class=\"c1\">-- It is not exactly the statement of the axiom, since we deal with predicates instead of subsets</span>\n                  <span class=\"c1\">--  but it could be acceptable to reinstate the axiom in these terms</span>\n</code></pre></div>\n<p>which you can then use in your <code>anterior</code> as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">is_N</span>  <span class=\"c1\">-- so we don't have to type `is_N.cero`</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">anterior</span> <span class=\"o\">{</span><span class=\"n\">N</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">is_N</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"c1\">-- \"if N satisfies our axioms then...\"</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"o\">(</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">cero</span><span class=\"o\">)</span>  <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">sig</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">):=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>As a bonus, by using <code>class</code> you can then prove that <code>ℕ</code> satisfies these axioms:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">ℕ_is_N</span> <span class=\"o\">:</span> <span class=\"n\">is_N</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">cero</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">sig</span> <span class=\"o\">:=</span> <span class=\"n\">nat.succ</span><span class=\"o\">,</span>\n  <span class=\"n\">siginy</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">nat.succ.inj</span><span class=\"o\">,</span>\n  <span class=\"n\">ceronosig</span> <span class=\"o\">:=</span> <span class=\"n\">nat.succ_ne_zero</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">h0</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">⟩,</span> <span class=\"n\">nat.rec</span> <span class=\"n\">h0</span> <span class=\"n\">hs</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 263779371,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1638725486
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461731\">@Miguel Marco</span> If you rearrange the induction axiom like this, then it's easier to use it to induct on a particular variable (and <code>apply</code> will automatically give you two goals to prove):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">induction</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">S</span><span class=\"o\">:(</span><span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">S</span> <span class=\"n\">cero</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">S</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">sig</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">anterior</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"o\">(</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">cero</span><span class=\"o\">)</span>  <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">sig</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">):=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">induction</span> <span class=\"n\">_</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">m</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">use</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 263780055,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1638726372
    },
    {
        "content": "<p>I think writing axioms for small examples like this is perfectly fine.  Writing your own axioms should be avoided when you want to be certain that your proofs are correct (like for big projects with many things depending on the axioms), but for a demonstration that doesn't seem to be such a stringent requirement.</p>\n<p>That said, it's easy enough to use Lean's <code>nat</code> to prove your axioms are good:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">Conjunto</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">def</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">Conjunto</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span>\n<span class=\"kd\">def</span> <span class=\"n\">cero</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"o\">:=</span> <span class=\"n\">nat.zero</span>\n<span class=\"kd\">def</span> <span class=\"n\">sig</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span> <span class=\"o\">:=</span> <span class=\"n\">nat.succ</span>\n<span class=\"kd\">def</span> <span class=\"n\">siginy</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">sig</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">sig</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">nat.succ_injective</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ceronosig</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">sig</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">cero</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">nat.succ_ne_zero</span>\n<span class=\"kd\">def</span> <span class=\"n\">induction</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">S</span><span class=\"o\">:(</span><span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">S</span> <span class=\"n\">cero</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">S</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">sig</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">nat.rec_on</span>\n</code></pre></div>",
        "id": 263780418,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1638726895
    },
    {
        "content": "<p>You can make the induction axiom be in terms of Lean sets:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">induction</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">S</span><span class=\"o\">:</span><span class=\"n\">set</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">cero</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">sig</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">nat.rec_on</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 263780527,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1638727062
    },
    {
        "content": "<p>Though it seems you have to give the inductive set directly for Lean to not mess up the set membership syntax:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">anterior</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"o\">(</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">cero</span><span class=\"o\">)</span>  <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">sig</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">):=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">induction</span> <span class=\"o\">{</span><span class=\"n\">n'</span><span class=\"o\">:</span><span class=\"n\">N</span> <span class=\"bp\">|</span> <span class=\"n\">n'</span> <span class=\"bp\">=</span> <span class=\"n\">cero</span> <span class=\"bp\">∨</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">sig</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n'</span><span class=\"o\">}</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">m</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">use</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 263780627,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1638727178
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/Formalising.20Peano.20axioms/near/263780527\">said</a>:</p>\n<blockquote>\n<p>You can make the induction axiom be in terms of Lean sets:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">induction</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">S</span><span class=\"o\">:</span><span class=\"n\">set</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">cero</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">sig</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">nat.rec_on</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thanks everybody for the answers. I managed to make something decent from them.</p>\n<p>On a second try, using Lean set, I am stuck trying to prove a theorem where my goal is :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">N</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"n\">O</span><span class=\"bp\">+</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">sig</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"n\">O</span><span class=\"bp\">+</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>I guess that to prove the goal I just have to construct a proof that <code>O+(sig a)=(sig a)</code>. But my trouble is how to extract a proof of <code>O+a=a</code> from hypothesis <code>h</code>. </p>\n<p>Is there a tactic for that?</p>",
        "id": 264496657,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1639164605
    },
    {
        "content": "<p><code>h</code> is definitionally equal to <code>0 + n = n</code>. You could either do <code>dsimp at h</code> (probably even <code>dsimp only at h</code> will work but I can't check because you didn't post a mwe), or <code>change 0+a=a at h</code>.</p>",
        "id": 264497611,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1639165077
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461731\">@Miguel Marco</span> It looks like you're running into what happens when Lean tries to infer the inductive set for that<code>induction</code> axiom -- it turns it into a lambda, losing the set syntax.</p>\n<p>It seems like there's a way to get Lean to infer the right thing by using <code>{n' | _}</code> for that argument:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">anterior</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">cero</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">sig</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)):=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">induction</span> <span class=\"o\">{</span><span class=\"n\">n'</span> <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">m</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">use</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>You can change <code>n'</code> to whatever you want, and it's how you name the induction variable.</p>\n<p>By the way, if you want to make sure you only use the axioms you've defined, keeping Lean from making use of built-in definitional equalities, I think putting this line after all your axioms should work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">irreducible</span><span class=\"o\">]</span> <span class=\"n\">N</span>\n</code></pre></div>",
        "id": 264503103,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1639167906
    },
    {
        "content": "<p>To answer your immediate question, <code>h</code> is exactly a proof of <code>O+a = a</code>, and you fix the syntactic oddness with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">change</span> <span class=\"n\">O</span><span class=\"bp\">+</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>though it would be better to avoid seeing anything like that in the first place if it can be helped. (<em>Edit:</em> I somehow missed that Kevin already mentioned <code>change</code>.)</p>",
        "id": 264503289,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1639168003
    }
]
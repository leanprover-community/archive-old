[
    {
        "content": "<p>Can I allocate some special symbols for the \"non-standard\" subtraction in natural numbers, or integer division, and interpret the symbols <code>/</code> and  <code>-</code> in  \"the standard way\", even though it may cause requiring a richer structure? A similar behavioral change  was done from Python 2 to Python 3. Now, I am trying to prove something like <code>a / b = 2^(c-d)</code> where <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> originate from natural numbers (cardinalities of finite sets), and it is challenging to even understand how Lean understands it.<br>\nFor broader context, the relevant lemma I wanted to prove is:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">D</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span><span class=\"err\">^</span><span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span><span class=\"err\">^</span><span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">non_triv</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nk_le</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"n\">M</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"err\">^</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">-</span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span>\n</pre></div>\n\n\n<p>It is related to problem C4 from <a href=\"http://imo-official.org/problems/IMO2008SL.pdf\" title=\"http://imo-official.org/problems/IMO2008SL.pdf\">http://imo-official.org/problems/IMO2008SL.pdf</a></p>",
        "id": 192899133,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585992785
    },
    {
        "content": "<p>write <code>a * 2^d = b * 2^c</code></p>",
        "id": 192899212,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1585992938
    },
    {
        "content": "<p>well, yes, but that is not the statement of the original problem</p>",
        "id": 192899268,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585992983
    },
    {
        "content": "<p>the original IMO problem is about determining the ratio <code>a / b</code></p>",
        "id": 192899271,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585993004
    },
    {
        "content": "<p>So I am basically asking, how to translate the solution <code>a * 2^d = b * 2^c</code>, to the \"required\" form.</p>",
        "id": 192899343,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585993182
    },
    {
        "content": "<p>And I believe that standard behavior of <code>-</code> and <code>/</code> would help.</p>",
        "id": 192899405,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585993258
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">rat</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">norm_cast</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">D</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span><span class=\"err\">^</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span><span class=\"err\">^</span><span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">non_triv</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nk_le</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"bp\">/</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"err\">^</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">-</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">div_eq_iff_mul_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">domain</span><span class=\"bp\">.</span><span class=\"n\">mul_left_inj</span> <span class=\"o\">(</span><span class=\"n\">ne_of_gt</span> <span class=\"err\">$</span> <span class=\"n\">pow_pos</span> <span class=\"n\">two_pos</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"err\">^</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">pow_add</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">add_sub_cancel&#39;</span> <span class=\"n\">nk_le</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span> <span class=\"n\">at</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n  <span class=\"n\">exact_mod_cast</span> <span class=\"n\">h2</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">h1</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n  <span class=\"n\">exact_mod_cast</span> <span class=\"n\">ne_of_gt</span> <span class=\"n\">non_triv</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 192899596,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1585993624
    },
    {
        "content": "<p>Thank you for the proof.</p>",
        "id": 192900150,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585994593
    },
    {
        "content": "<p>You can't change the horrible uses of these symbols because they're already standard. We just have to live with them as mathematicians</p>",
        "id": 192900229,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585994699
    },
    {
        "content": "<p>Hm... Python did it.</p>",
        "id": 192900246,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585994739
    },
    {
        "content": "<p>Remember you can always cast. If you really want to work with subtraction you can use integers and if you really want to worth with division you can use rationale</p>",
        "id": 192900247,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585994742
    },
    {
        "content": "<p>Maybe some future version of Lean will manage it as well.</p>",
        "id": 192900290,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585994775
    },
    {
        "content": "<p>Python is just one programming language. This subtraction nonsense has permeated loads of the theorem prover languages</p>",
        "id": 192900301,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585994809
    },
    {
        "content": "<p>I have meant the division.</p>",
        "id": 192900326,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585994850
    },
    {
        "content": "<p>I would happily vote for a change but the CS people like trolling us. Why not have this conversation in #general? I will be right behind you</p>",
        "id": 192900331,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585994868
    },
    {
        "content": "<p>OK :-)</p>",
        "id": 192900372,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585994883
    },
    {
        "content": "<p>By the way, another question: Why</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">rat</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">/</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"err\">^</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>fails, and </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">/</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"err\">^</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>succeeds?</p>",
        "id": 192900442,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585995009
    },
    {
        "content": "<p>One of them probably imports algebra.group_power</p>",
        "id": 192901051,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585995968
    },
    {
        "content": "<p>And the other doesn't</p>",
        "id": 192901057,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585995980
    },
    {
        "content": "<p>Powers are only defined for naturals in core</p>",
        "id": 192901062,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585996002
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">rat</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group_power</span>\n<span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">/</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"err\">^</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>still does not work.</p>",
        "id": 192901375,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585996521
    },
    {
        "content": "<p>Well I'm not at a computer but I can tell you how to debug this yourself</p>",
        "id": 192901643,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585996960
    },
    {
        "content": "<p><code>def X := </code><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mi mathvariant=\"normal\">/</mi><mn>3</mn><msup><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo></msup><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(2/3)^(-1)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.138em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mord\">/</span><span class=\"mord\">3</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mopen mtight\">(</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> in a situation where it works</p>",
        "id": 192901700,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585997045
    },
    {
        "content": "<p>And then <code>#print X</code> and we can try and figure out what function lean is using to do the power</p>",
        "id": 192901728,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585997111
    },
    {
        "content": "<p>It says</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"mi\">4</span><span class=\"o\">:</span><span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"n\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"err\">^</span> <span class=\"bp\">-</span><span class=\"mi\">1</span>\n</pre></div>",
        "id": 192901738,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585997159
    },
    {
        "content": "<p>Not much helpful...</p>",
        "id": 192901779,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585997181
    },
    {
        "content": "<p>I have got it, <code>import algebra.field_power</code>, by following the source code.</p>",
        "id": 192901891,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585997440
    },
    {
        "content": "<p>OK great. Here's how to solve it my way: <code>set_option pp.all true</code> and then <code>#print X</code> again</p>",
        "id": 192901906,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585997492
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Miroslav Olšák</span> <a href=\"#narrow/stream/113489-new-members/topic/integer.20subtraction.20.2F.20rational.20division/near/192900246\" title=\"#narrow/stream/113489-new-members/topic/integer.20subtraction.20.2F.20rational.20division/near/192900246\">said</a>:</p>\n<blockquote>\n<p>Hm... Python did it.</p>\n</blockquote>\n<p>Python is also a dynamically typed language</p>",
        "id": 192901912,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585997507
    },
    {
        "content": "<p>and then we see that the exact term for <code>^</code> is <code>@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)</code></p>",
        "id": 192901987,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585997593
    },
    {
        "content": "<p>I know. On the other hand, Lean has a strong inference system that also often disquise the types from the user.</p>",
        "id": 192901988,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585997596
    },
    {
        "content": "<p>If you want to have subtraction in a \"richer structure\", then write <code>(x - y : int)</code> where <code>x,y : nat</code></p>",
        "id": 192901989,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585997605
    },
    {
        "content": "<p>Yes, as a mathematician, you simply shouldn't be using these functions, not complaining that their notation is confusing.</p>",
        "id": 192902042,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585997645
    },
    {
        "content": "<p>I figure I'll just let the CS people do what they like</p>",
        "id": 192902045,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585997655
    },
    {
        "content": "<p>But if you have to pass a subtraction to a function, as a nat, then nat subtraction is much better than any other option</p>",
        "id": 192902054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585997690
    },
    {
        "content": "<p>and now <code>#check int.has_pow</code> which is the underlying function it's using</p>",
        "id": 192902056,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585997692
    },
    {
        "content": "<p>and peeking the definition does indeed indicate that it's defined in algebra.field_power</p>",
        "id": 192902070,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585997729
    },
    {
        "content": "<p>If subtraction had type <code>nat -&gt; nat -&gt; int</code> then this wouldn't solve the problem of when the subtraction is actually a nat in the case of interest, and for typing reasons you need it to have type <code>nat</code>, so you have to cast it back with some ugly thing like <code>to_nat</code>... and now you've reinvented nat subtraction</p>",
        "id": 192902115,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585997765
    },
    {
        "content": "<p>The other part of <code>@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)</code> is the proof that the rationals are a division ring.</p>",
        "id": 192902132,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585997793
    },
    {
        "content": "<p>Miroslav, Mario's <code>(x-y : int)</code> trick is very important to understand because it relies on a very counter-intuitive Lean behavior which sometimes throws me off, even after more than two years of Lean. When you write <code>(x - y : int)</code> Lean does <strong>not</strong> \"compute\" <code>x - y</code> and then convert to <code>int</code> (which wouldn't solve your problem). It sees int and then infers that <code>-</code> should be an operation returning an <code>int</code>, which forces <code>x</code> and <code>y</code> to have type int, hence Lean inserts the coercion.</p>",
        "id": 192902149,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1585997841
    },
    {
        "content": "<p>I write C code sometimes and the coercion behavior is the other way around, it throws me off going back and forth</p>",
        "id": 192902194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585997899
    },
    {
        "content": "<p>You can play with <code>#eval (2 - 3 : int)</code> (inserting coercions in various places).</p>",
        "id": 192902202,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1585997919
    },
    {
        "content": "<p>If in doubt, write <code>(\\u x - \\u y : int)</code></p>",
        "id": 192902207,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585997936
    },
    {
        "content": "<p>or <code>(\\u(x-y) : int)</code></p>",
        "id": 192902215,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585997953
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/integer.20subtraction.20.2F.20rational.20division/near/192902042\" title=\"#narrow/stream/113489-new-members/topic/integer.20subtraction.20.2F.20rational.20division/near/192902042\">said</a>:</p>\n<blockquote>\n<p>Yes, as a mathematician, you simply shouldn't be using these functions, not complaining that their notation is confusing.</p>\n</blockquote>\n<p>I don't understand. What do you mean by it? What functions should I not use?</p>",
        "id": 192902291,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585998113
    },
    {
        "content": "<p>nat subtraction, that is, <code>x - y : nat</code> where <code>x,y:nat</code></p>",
        "id": 192902367,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585998238
    },
    {
        "content": "<p>when you write <code>(x - y : int)</code>, the subtraction there has type <code>int -&gt; int -&gt; int</code>. It's a completely different function and a much more well behaved one</p>",
        "id": 192902417,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585998274
    },
    {
        "content": "<p>However I disagree that you should avoid it completely. nat subtraction should be understood as a \"totalized partial function\", like division on reals or the sum of an infinite series or any number of other things. It returns garbage sometimes so you need to always be able to prove that you are not in the bad case when using it. This is somewhat of a pain, so if there are alternative formulations that avoid it they are probably preferable, but it's not the end of the world either</p>",
        "id": 192902498,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585998431
    },
    {
        "content": "<p>That is all nice, but how am I supposed to see what function is used in <code>2^(k-n)</code>, or even <code>2^(k-n) : ℚ</code> -- that it is probably the wrong subtraction function?</p>",
        "id": 192902642,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585998650
    },
    {
        "content": "<p>And Mario, how do you perceive <code>a / b : int</code>? As rounded division, or as totalized partial function that returns garbage if the two integers are not divisible?</p>",
        "id": 192902769,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1585998834
    },
    {
        "content": "<p>The subtraction function always has the same output type as input type, <code>A -&gt; A -&gt; A</code>. Lean will never insert coercions unless it has to to avoid a type mismatch. In this case, <code>k</code> and <code>n</code> are <code>nat</code> and <code>^</code> is generic so it provides no hint about the type it is expecting in the input, so lean lets it be <code>k - n : nat</code>, finds the instance <code>^ : A -&gt; nat -&gt; A</code>, and goes with that</p>",
        "id": 192902830,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585998913
    },
    {
        "content": "<p>Actually the \"totalized partial function\" is not an all or nothing business. We have tried to make the \"garbage\" values as useful as possible given the constraints, so they may be less garbage-like depending on the application. Nat subtraction, for instance, returns 0 when the subtraction is out of bounds. One nice consequence of this is that it puts nat subtraction in an adjunction with addition, <code>a - b &lt;= c &lt;-&gt; a &lt;= b + c</code>, while some other garbage value like 37 wouldn't satisfy that.</p>",
        "id": 192902989,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585999170
    },
    {
        "content": "<p>Miroslav there is an algorithm for working out the type of everything and if you use set_option pp.all true you can figure it out</p>",
        "id": 192902991,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585999178
    },
    {
        "content": "<p>So the justification of natural subtraction is that it is an adjoint functor</p>",
        "id": 192903046,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585999235
    },
    {
        "content": "<p>Or you can just look at where the coercions are happening</p>",
        "id": 192903056,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585999266
    },
    {
        "content": "<p>There is a similar adjunction for int division</p>",
        "id": 192903064,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1585999286
    },
    {
        "content": "<p>All this is very nice, but it doesn't hide the fact that we currently don't have a good solution to handle numbers in a proof assistant. Things are simply broken, and the only thing we can explain is why it's difficult to fix them while keeping other things that we do like.</p>",
        "id": 192903475,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1586000040
    },
    {
        "content": "<p>I know Mario knows this, I'm being explicit for Miroslav.</p>",
        "id": 192903516,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1586000065
    },
    {
        "content": "<p>And couldn't just the rational division / integer subtraction be chosen as the default, with possible forcing of the rounded functions by the external typing? So that <code>1/2 = 2/3</code> would be false, whereas <code>(1/2 : ℤ) = (2/3 : ℤ)</code>would be true?</p>",
        "id": 192903917,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1586000809
    },
    {
        "content": "<p>But of course, I don't see into the coersion / overloading rules. As far as I know, it is a mess even in C++.</p>",
        "id": 192904220,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1586001275
    },
    {
        "content": "<p>Having integer subtraction as the default on naturals is literally impossible</p>",
        "id": 192904373,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586001559
    },
    {
        "content": "<p>Look at the type of has_sub.sub</p>",
        "id": 192904376,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586001571
    },
    {
        "content": "<p>It has to return an element of the same type as those it eats</p>",
        "id": 192904386,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586001591
    },
    {
        "content": "<p>This is a design decision that can't really be changed</p>",
        "id": 192904428,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586001608
    },
    {
        "content": "<p>It's also the right design for int, rat, real, complex, and any ring</p>",
        "id": 192904434,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586001658
    },
    {
        "content": "<p>If you don't like subtraction on semirings, don't use it</p>",
        "id": 192904444,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586001681
    },
    {
        "content": "<p>We very rarely need it</p>",
        "id": 192904448,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586001690
    },
    {
        "content": "<p>The only convincing example I've ever seen in mathematics is when we differentiate X^n and even in this case you can split into zero and successor cases if you want</p>",
        "id": 192904510,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586001734
    },
    {
        "content": "<p>Do you know how many ways you have to decompose an integer <code>n</code> as a sum <code>i_1 + ... + i_k</code> of positive integers (where <code>k</code> is not fixed)? The answer is <code>2^(n-1)</code>. This is proved by thinking of a decomposition of <code>{0, ..., n-1}</code> into blocks, and taking the leftmost point of each of your blocks but the first one. This gives you a bijection between the set of decompositions and finite subsets of <code>{1, ..., n-1}</code>, which have cardinality <code>2^(n-1)</code>. Fun fact: all this also works for <code>n = 0</code>(where subtraction is nat subtraction).</p>",
        "id": 192905670,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1586003674
    },
    {
        "content": "<p>And the proof of this (which I needed to prove that the composition of analytic functions is analytic, upcoming PR once <a href=\"https://github.com/leanprover-community/mathlib/issues/2197\" title=\"https://github.com/leanprover-community/mathlib/issues/2197\">#2197</a> is merged) never distinguishes between <code>n = 0</code> and <code>n &gt; 0</code>!</p>",
        "id": 192905761,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1586003818
    },
    {
        "content": "<p>I never got my answer about <a href=\"https://github.com/leanprover-community/mathlib/issues/2197\" title=\"https://github.com/leanprover-community/mathlib/issues/2197\">#2197</a>, but I can merge anyway if it's blocking you.</p>",
        "id": 192905827,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1586003888
    },
    {
        "content": "<p>Your question was not about <a href=\"https://github.com/leanprover-community/mathlib/issues/2197\" title=\"https://github.com/leanprover-community/mathlib/issues/2197\">#2197</a> but about preexisting files, right? I don't have a good answer, I can only say it follows the same design as in the file for the operator norm.</p>",
        "id": 192906132,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1586004462
    },
    {
        "content": "<p>You don't know whether those norms lemmas are used directly in later files? Even in the operator norm case?</p>",
        "id": 192906175,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1586004510
    },
    {
        "content": "<p>I don't think they are (and a quick grep agrees with me). In the operator norm case, we are talking about the four lemmas <code>op_norm_zero_iff</code>, <code>op_norm_add_le</code>, <code>op_norm_neg</code> and <code>op_norm_smul</code>, which prove that the operator norm satisfies the usual properties of a norm. Then, the normed space instance is derived from these lemmas, and they become unnecessary as they are covered by general normed space properties. Still, the proofs of these lemmas depend on the previous lemmas, so it would not be obvious to give a direct proof of the instance (and in any case we say that in general it is good practice to split a big proof in smaller lemmas). The question is whether we should mark them as private. I don't really have an opinion on this.</p>",
        "id": 192906383,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1586004932
    },
    {
        "content": "<p>Yes, the question was about making them private. This is a very general question that I think should have a least a general guiding principle. But that's not a good reason to postpone merging.</p>",
        "id": 192906436,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1586005006
    },
    {
        "content": "<p>And if let's say, naturals didn't have <code>has_sub</code> and <code>has_div</code>, Lean still could not realize that <code>a - b</code> should be an integer and <code>a / b</code> should be a rational?</p>",
        "id": 192906807,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1586005663
    },
    {
        "content": "<p><code>-</code> <strong>is</strong> <code>has_sub.sub</code></p>",
        "id": 192906861,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1586005723
    },
    {
        "content": "<p>I understand, and if I deleted it?</p>",
        "id": 192906883,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1586005790
    },
    {
        "content": "<p>from naturals</p>",
        "id": 192906886,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1586005800
    },
    {
        "content": "<p>Then everything would break because this is a design decision</p>",
        "id": 192907086,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586006101
    },
    {
        "content": "<p>Core would break</p>",
        "id": 192907091,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586006112
    },
    {
        "content": "<p><code>-</code> notation is tied to has_sub.sub</p>",
        "id": 192907155,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586006168
    },
    {
        "content": "<p>And natural subtraction is used all over the place in parts of core that a mathematician has no interest in looking at but which make all the tactics work</p>",
        "id": 192907180,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586006256
    },
    {
        "content": "<p>I should say that this is just a conjecture</p>",
        "id": 192907193,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586006278
    },
    {
        "content": "<p>But if they didn't need natural subtraction it probably wouldn't be in core</p>",
        "id": 192907251,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586006307
    },
    {
        "content": "<p>I guess here is how to refactor</p>",
        "id": 192907263,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586006375
    },
    {
        "content": "<p>First change core so that the notation for has_sub.sub is some weird minus sign with a warning symbol above it</p>",
        "id": 192907308,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586006432
    },
    {
        "content": "<p>Then define a new notational typeclass for - and let it go from A x A to B. We can think of this as mathematician's subtraction</p>",
        "id": 192907335,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586006507
    },
    {
        "content": "<p>And now for rings you use this notation instead with B=A</p>",
        "id": 192907376,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586006536
    },
    {
        "content": "<p>And for nat you let it take values in int</p>",
        "id": 192907384,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586006560
    },
    {
        "content": "<p>But it wouldn't be long before you started regretting it</p>",
        "id": 192907387,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586006580
    },
    {
        "content": "<p>Because then you'll end up with goals where you think you've proved naturals a and b are equal but you've only proved that integers a and b are equal</p>",
        "id": 192907396,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586006623
    },
    {
        "content": "<p>And you'll have to apply the norm_cast tactic to fix things up which is a pain if you're writing a term mode proof</p>",
        "id": 192907456,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586006667
    },
    {
        "content": "<p>And will slow down your code immensely</p>",
        "id": 192907478,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586006686
    },
    {
        "content": "<p>I am sticking with my original assertion. If you do want to use negative numbers when why are you using nats in the first place? I have a student working on a dots and boxes project and she's using ints even though everything at the end is nonnegative and it hasn't caused any problems at all</p>",
        "id": 192907535,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586006776
    },
    {
        "content": "<p>And if you don't want to use them then just avoid subtraction by rephrasing in terms of addition</p>",
        "id": 192907552,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586006810
    },
    {
        "content": "<p>I understand that everything would break now :-). I was just curious whether the refactor would be hypotetically possible. I would imagine using other symbol for natural subtraction, and integer division (for example <code>a \\ b</code> and <code>a ÷ b</code>). But I would need Lean to trigger the integer subtraction, whenever I write <code>a - b</code> for <code>a</code>, <code>b</code> naturals. The question is whether the typing system would allow such behavior.<br>\nI am not doing it, I am just asking, it could help me with understanding insides of Lean. We can discuss on whether it would be a good idea later, now I just want to understand whether it is a possibility.</p>",
        "id": 192911197,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1586011923
    },
    {
        "content": "<p>What Lean does when it sees a-b depends simply on the definition of the notation -</p>",
        "id": 192911325,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586012112
    },
    {
        "content": "<p>Currently that notation is used in 1000 places in mathlib and is hard wired to mean something of type X to X to X</p>",
        "id": 192911517,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586012363
    },
    {
        "content": "<p>You can redefine it to go from X to X to Y and then fix 1000 errors</p>",
        "id": 192911528,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586012380
    },
    {
        "content": "<p>And then it'll work fine except that you'll find that it's really annoying</p>",
        "id": 192911536,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586012395
    },
    {
        "content": "<p>Because you don't want the types of your objects changing when you apply fundamental operations to them</p>",
        "id": 192911608,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586012475
    },
    {
        "content": "<p>I think that your idea of a subtraction operation from nat x nat to int is just as unnatural as leans design decision</p>",
        "id": 192911667,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586012547
    },
    {
        "content": "<p>If you want to subtract naturals you should be using integers from the beginning</p>",
        "id": 192911674,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586012569
    },
    {
        "content": "<p>Whether some idea is \"natural\" / \"unnatural\" is a subjective opinion, we apparently cannot resolve it here :-).<br>\nBut my question was somewhat different, let's phrase it without naturals.<br>\nLet's say, I have a type <code>α</code>, and I would like to have a subtraction such that <code>(x-y : β)</code> for any <code>x y : α</code>. Would it be possible?</p>",
        "id": 192912039,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1586013085
    },
    {
        "content": "<p>If you edit core lean, yes</p>",
        "id": 192912107,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586013168
    },
    {
        "content": "<p>Do you understand typeclass notation?</p>",
        "id": 192912114,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586013177
    },
    {
        "content": "<p>It's not possible with the current definition of <code>has_sub.sub</code> and with <code>-</code> being notation for <code>has_sub.sub</code>. If you want to change everything, then anything is possible.</p>",
        "id": 192912115,
        "sender_full_name": "Reid Barton",
        "timestamp": 1586013177
    },
    {
        "content": "<p>Look at the definition of - and then look at the definition of has_sub and then there you are at one of the first lean files lean ever reads when starting up and that's the line you have to change and it will break everything that comes later</p>",
        "id": 192912190,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586013263
    },
    {
        "content": "<p>I understand typeclasses just roughly. If I wrote  (sub : α → α → β) in the core instead, and kept all the instances of <code>has_sub</code> as they are now, what would break?</p>",
        "id": 192912314,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1586013411
    },
    {
        "content": "<p>nothing. except all of core and mathlib</p>",
        "id": 192912332,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586013439
    },
    {
        "content": "<p>:D</p>",
        "id": 192912336,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1586013449
    },
    {
        "content": "<p>One issue with a subtraction function like that is that the type is not determined by the input</p>",
        "id": 192912438,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586013497
    },
    {
        "content": "<p>if you write <code>let z := x - y</code>, lean has no idea what type <code>z</code> has, so it can't even find out if the subtraction typeclass exists</p>",
        "id": 192912455,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586013531
    },
    {
        "content": "<p>so you would probably want beta to be an <code>out_param</code>, essentially saying that subtraction maps each type with a subtraction operation to a unique other type</p>",
        "id": 192912480,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586013591
    },
    {
        "content": "<p>I see, <code>out_param</code> like in <code>is_mem</code>.</p>",
        "id": 192912618,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1586013757
    },
    {
        "content": "<p>But this causes problems elsewhere. For example, assuming that this isn't just a hack to support <code>nat</code> specifically, we might want a generalized version of the construction, for example mapping any semiring <code>R</code> to a new type <code>integral_closure R</code> formed by taking formal subtractions of elements of <code>R</code>. But then we have a conflict because a ring is a semiring, so the subtraction on <code>R</code> would land in both <code>R</code> and <code>integral_closure R</code> (which is isomorphic to <code>R</code>)</p>",
        "id": 192912641,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586013819
    },
    {
        "content": "<p>Mario we have monoid localisation thanks to <span class=\"user-mention\" data-user-id=\"118107\">@Amelia Livingston</span>  :-)</p>",
        "id": 192912687,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586013864
    },
    {
        "content": "<p>Ring is a semiring? I thought there is just coercion to semiring.</p>",
        "id": 192912762,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1586013962
    },
    {
        "content": "<p>The type is the same, there is no coercion, but the typeclasses are in a parent relationship</p>",
        "id": 192912808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586014000
    },
    {
        "content": "<p>OK, I think I understand why it is so problematic.</p>",
        "id": 192912833,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1586014038
    },
    {
        "content": "<p>In 99% of use cases, if a and b have type R then you really want a-b to have type R. So you can see why they went for this design decision.</p>",
        "id": 192913074,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586014348
    },
    {
        "content": "<p>However there is clearly a dichotomy because there are loads of lemmas called things like <code>sub_add_cancel</code> or whatever, that have versions <code>nat.sub_add_cancel</code>, so the contentious design decision of using this notation for natural subtraction has caused problems down the line. However without editing any Lean you could define a new kind of subtraction sub' with a different notation which mapped nat x nat to int. But then you'd realise that it didn't really fix any of the problems because now you'll need nat.sub'_add_cancel as well, which will say that some integer equals a coercion to integer of some natural.</p>",
        "id": 192913230,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586014560
    }
]
[
    {
        "content": "<p>Hi, everyone. <span class=\"user-mention\" data-user-id=\"368033\">@Runzhou Tao</span>  and I are new to Lean. We want to use Lean in quantum computing. As a practice, we want to prove the associativity of tensor products of (finite dimensional) matrices in different dimensions using the following code. It seems like defining kronecker product as on line 14, it depends on the dimension of the matrices, thus we cannot express the associativity theorem easily because the 3rd matrix will have a different dimension (a failed trial is on line 26). I am wondering is there a way of defining kronecker product (and matrices) so that the associativity can be expressed and proved? Thanks!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.matrix.basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">comp</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">nlinarith</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">def</span> <span class=\"n\">my_matrix</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">kron</span> <span class=\"o\">{</span><span class=\"n\">m1</span> <span class=\"n\">n1</span> <span class=\"n\">m2</span> <span class=\"n\">n2</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">my_matrix</span> <span class=\"n\">m1</span> <span class=\"n\">n1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">my_matrix</span> <span class=\"n\">m2</span> <span class=\"n\">n2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">my_matrix</span> <span class=\"o\">(</span><span class=\"n\">m1</span><span class=\"bp\">*</span><span class=\"n\">m2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n1</span><span class=\"bp\">*</span><span class=\"n\">n2</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">i</span> <span class=\"k\">with</span> <span class=\"n\">i</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">j</span> <span class=\"k\">with</span> <span class=\"n\">j</span> <span class=\"n\">hj</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">i1</span> <span class=\"o\">:=</span> <span class=\"n\">i</span> <span class=\"bp\">%</span> <span class=\"n\">m1</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">j1</span> <span class=\"o\">:=</span> <span class=\"n\">j</span> <span class=\"bp\">%</span> <span class=\"n\">n1</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">i2</span> <span class=\"o\">:=</span> <span class=\"n\">i</span> <span class=\"bp\">/</span> <span class=\"n\">m1</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">j2</span> <span class=\"o\">:=</span> <span class=\"n\">j</span> <span class=\"bp\">/</span> <span class=\"n\">n1</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"c1\">-- m1 n1 m2 n2 should not be</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">kron_assoc</span> <span class=\"o\">{</span><span class=\"n\">m1</span> <span class=\"n\">n1</span> <span class=\"n\">m2</span> <span class=\"n\">n2</span> <span class=\"n\">m3</span> <span class=\"n\">n3</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">my_matrix</span> <span class=\"n\">m1</span> <span class=\"n\">n1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">my_matrix</span> <span class=\"n\">m2</span> <span class=\"n\">n2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">my_matrix</span> <span class=\"n\">m3</span> <span class=\"n\">n3</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">kron</span> <span class=\"o\">(</span><span class=\"n\">kron</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">kron</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">kron</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 219268285,
        "sender_full_name": "Yunong Shi",
        "timestamp": 1607464421
    },
    {
        "content": "<p>Yup, this is a standard problem with dependent type theory and there are a few ways around it, although I still haven't really internalised them. The problem is that <code>x*(y*z)</code> and <code>(x*y)*z</code> are equal, but not definitionally equal.</p>",
        "id": 219268934,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607464789
    },
    {
        "content": "<p>This is the ugly way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">my_matrix_equiv</span> <span class=\"o\">{</span><span class=\"n\">m₁</span> <span class=\"n\">n₁</span> <span class=\"n\">m₂</span> <span class=\"n\">n₂</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">m₁</span> <span class=\"bp\">=</span> <span class=\"n\">m₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">n₁</span> <span class=\"bp\">=</span> <span class=\"n\">n₂</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">my_matrix</span> <span class=\"n\">m₁</span> <span class=\"n\">n₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">my_matrix</span> <span class=\"n\">m₂</span> <span class=\"n\">n₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n₁</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">⟨</span><span class=\"n\">i.1</span><span class=\"o\">,</span> <span class=\"n\">hm</span> <span class=\"bp\">▸</span> <span class=\"n\">i.2</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">j.1</span><span class=\"o\">,</span> <span class=\"n\">hn</span> <span class=\"bp\">▸</span> <span class=\"n\">j.2</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">kron_assoc</span> <span class=\"o\">{</span><span class=\"n\">m1</span> <span class=\"n\">n1</span> <span class=\"n\">m2</span> <span class=\"n\">n2</span> <span class=\"n\">m3</span> <span class=\"n\">n3</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">my_matrix</span> <span class=\"n\">m1</span> <span class=\"n\">n1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">my_matrix</span> <span class=\"n\">m2</span> <span class=\"n\">n2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">my_matrix</span> <span class=\"n\">m3</span> <span class=\"n\">n3</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">my_matrix_equiv</span> <span class=\"o\">(</span><span class=\"n\">mul_assoc</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mul_assoc</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">kron</span> <span class=\"o\">(</span><span class=\"n\">kron</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">kron</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">kron</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n<p>but I think there are better ways nowadays.</p>",
        "id": 219269668,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607465177
    },
    {
        "content": "<p>Note that <code>comp a b</code> exists already as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin_prod_fin_equiv\">docs#fin_prod_fin_equiv</a>, <code>fin_prod_fin_equiv (a, b)</code></p>",
        "id": 219273698,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607467455
    },
    {
        "content": "<p>You can also use <code>heq</code>, which isn't always as bad as its made out to be, <code>kron (kron a b) c == kron a (kron b c)</code></p>",
        "id": 219273799,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607467546
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.matrix.notation</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">repr</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">m'</span> <span class=\"n\">n'</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_repr</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">vec_repr</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">n'</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n'</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">string</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">string.intercalate</span> <span class=\"s2\">\", \"</span> <span class=\"o\">((</span><span class=\"n\">vector.of_fn</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_list.map</span> <span class=\"n\">repr</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">vec_repr_instance</span> <span class=\"o\">:</span> <span class=\"n\">has_repr</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n'</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">vec_repr</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">matrix_repr</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">m'</span> <span class=\"n\">n'</span><span class=\"o\">},</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">m'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n'</span><span class=\"o\">)</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">string</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">string.intercalate</span> <span class=\"s2\">\";</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span> <span class=\"o\">((</span><span class=\"n\">vector.of_fn</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_list.map</span> <span class=\"n\">repr</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">matrix_repr_instance</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_repr</span> <span class=\"o\">(</span><span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">m'</span><span class=\"o\">)</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">matrix_repr</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">repr</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">kron</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">kron</span> <span class=\"o\">{</span><span class=\"n\">m1</span> <span class=\"n\">n1</span> <span class=\"n\">m2</span> <span class=\"n\">n2</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">m1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">m2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">((</span><span class=\"n\">m1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">m2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">((</span><span class=\"n\">n1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"n\">K</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"o\">⟨</span><span class=\"n\">i</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">m2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">nat.div_lt_iff_lt_mul'</span> <span class=\"o\">(</span><span class=\"n\">nat.succ_pos'</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">i.is_lt</span><span class=\"o\">⟩</span>\n           <span class=\"o\">⟨</span><span class=\"n\">j</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">n2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">nat.div_lt_iff_lt_mul'</span> <span class=\"o\">(</span><span class=\"n\">nat.succ_pos'</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">j.is_lt</span><span class=\"o\">⟩)</span>\n           <span class=\"bp\">•</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n           <span class=\"o\">⟨</span><span class=\"n\">i</span> <span class=\"bp\">%</span> <span class=\"o\">(</span><span class=\"n\">m2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">nat.mod_lt</span> <span class=\"n\">_</span> <span class=\"n\">nat.succ_pos'</span><span class=\"o\">⟩</span>\n           <span class=\"o\">⟨</span><span class=\"n\">j</span> <span class=\"bp\">%</span> <span class=\"o\">(</span><span class=\"n\">n2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">nat.mod_lt</span> <span class=\"n\">_</span> <span class=\"n\">nat.succ_pos'</span><span class=\"o\">⟩</span>\n\n\n<span class=\"k\">#eval</span> <span class=\"n\">kron</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">],</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">]]</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">],</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">6</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">]]</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">0, 5, 0, 10;</span>\n<span class=\"cm\">6, 7, 12, 14;</span>\n<span class=\"cm\">0, 15, 0, 20;</span>\n<span class=\"cm\">18, 21, 24, 28</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">kron_assoc</span>\n<span class=\"o\">{</span><span class=\"n\">m1</span> <span class=\"n\">n1</span> <span class=\"n\">m2</span> <span class=\"n\">n2</span> <span class=\"n\">m3</span> <span class=\"n\">n3</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">m1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">m2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">m3</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n3</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span>\n<span class=\"n\">kron</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">kron</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">c</span> <span class=\"bp\">==</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">kron</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">kron</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 219274079,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607467727
    },
    {
        "content": "<p>Although proving associativity might be a tiny bit simpler if the mul definition is used instead of smul</p>",
        "id": 219275483,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607468657
    },
    {
        "content": "<p>Hi and welcome! I also work in quantum information, and I've thought a bit about the best way to represent states on multiple quantum systems in Lean. I think the way to go will be to write a pi-type version of the code in <code>linear_algebra/tensor_product.lean</code>. What we have there is the tensor product of two spaces <code>M</code> and <code>N</code>, and it's defined as a <code>free_add_monoid M × N</code> quotiented by an appropriate equivalence relation, so basically arbitrary sums of vectors of the form <code>x ⊗ y</code> and then selecting the right equivalence classes. I think we should do the same thing with <code>free_add_monoid (Π i : ι, f i)</code> with <code>f : ι → Type*</code> in order to have more than two systems. This would have the advantage of avoiding these associativity problems, by not even having an order on the systems in the first place.</p>",
        "id": 219279433,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1607470758
    },
    {
        "content": "<p>It also lets us work at a more abstract level, which I've (somewhat counterintuitively) found to be a lot easier in Lean. I also tried to go this route when I first learned Lean (i.e. do everything with concrete matrices) and it was constant pain, with indices everywhere.</p>",
        "id": 219279738,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1607470995
    },
    {
        "content": "<p>Thanks everyone. It will take some time for me to fully understand your replies. Let me get back to some of you later.</p>",
        "id": 219283066,
        "sender_full_name": "Yunong Shi",
        "timestamp": 1607473544
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"311453\">@Frédéric Dupuis</span> Thanks for the great suggestions and glad to know someone here is in quantum computation as well! As I understand your comment, there are two suggestions: 1. we can work with abstract tensor product that defined in <code>linear_algebra/tensor_product.lean</code>. 2. Using Pi-type to get rid of the dimension dependence. For 1, will the abstract definition make some proof harder, for example, prove some concrete results are indeed tensor products? For 2, I think it's a great idea! Will it involve some changes in the matrix definition (matrices with arbitrary dimensions)? Maybe I should look into the implementation more.</p>",
        "id": 219283757,
        "sender_full_name": "Yunong Shi",
        "timestamp": 1607474059
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"311453\">@Frédéric Dupuis</span> <span class=\"user-mention\" data-user-id=\"365384\">@Yunong Shi</span>  Not sure if it's useful for your application, but I've formalized an alternative definition of tensors in here: <br>\n<a href=\"https://github.com/leanprover-community/mathlib/blob/1f309c52c472a6cd37e41c580a470033e63d4720/src/data/holor.lean\">https://github.com/leanprover-community/mathlib/blob/1f309c52c472a6cd37e41c580a470033e63d4720/src/data/holor.lean</a></p>\n<p>We called this alternative view on tensors \"holors\" (I think we found that word in the literature somewhere). The difference is that this definition views the tensors as multidimensional arrays, not as functions. It's like viewing linear maps as matrices. The holor file also contains a proof of associativity of the tensor product.</p>",
        "id": 219311234,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1607504791
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"129120\">@Alexander Bentkamp</span>, is there a reason you use \\N and not <code>fin n</code> like matrices (usually) use?</p>",
        "id": 219312397,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607505582
    },
    {
        "content": "<p>I guess it makes the whole definition a bit simpler, but I am not sure. In some sense, the definition of <code>holor_index</code> is like <code>fin n</code>, but on lists.</p>",
        "id": 219313358,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1607506215
    },
    {
        "content": "<p>How would the definition of <code>holor_index</code> look like with <code>fin n</code>? I guess you would need a Pi-type or something?</p>",
        "id": 219313667,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1607506384
    },
    {
        "content": "<p>For matrices, it's simpler. It's just <code>fin n ⨉ fin m</code>.</p>",
        "id": 219313766,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1607506439
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">holor</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ds</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">ds</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">ds</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n</code></pre></div>",
        "id": 219314184,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607506696
    },
    {
        "content": "<p>Eg <code>holor ℝ ![fin 2, fin 3, fin 4]</code> for a 2x3x4 tensor</p>",
        "id": 219314350,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607506803
    },
    {
        "content": "<p>wow, what is the <code>![...]</code> notation? It constructs <code>fin n</code>?</p>",
        "id": 219314396,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1607506858
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/data/matrix/notation.html\">https://leanprover-community.github.io/mathlib_docs/data/matrix/notation.html</a></p>",
        "id": 219314452,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607506902
    },
    {
        "content": "<p>Well, then the reason for my definition was that the <code>fin n</code>/matrix library wasn't as developed back then.</p>",
        "id": 219314529,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1607506928
    },
    {
        "content": "<p>It constructs <code>fin n →  T</code></p>",
        "id": 219314537,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607506933
    },
    {
        "content": "<p>Ugh, that definition doesn't work: (<a href=\"#narrow/stream/113488-general/topic/fintype.20instances.20for.20matrix.20notation/near/219314820\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype.20instances.20for.20matrix.20notation/near/219314820</a>)</p>",
        "id": 219314635,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607507021
    },
    {
        "content": "<p>On second thoughts, my definition probably doesn't work because it means 2-tensors and 3-tensors have different types</p>",
        "id": 219316845,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607508403
    },
    {
        "content": "<p>Maybe I'll explore trying to overhaul holor to use it and see where I get stuck</p>",
        "id": 219316900,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607508453
    },
    {
        "content": "<p>Sure, go for it. It would be nice to have it more consistent with the matrix library.</p>",
        "id": 219317933,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1607509130
    },
    {
        "content": "<p>Having explored a little more, I think all the <code>holor_index</code> stuff is still quite hard to write with <code>fin</code>. <a href=\"https://github.com/leanprover-community/mathlib/issues/4406\">#4406</a> would make it easier.</p>",
        "id": 219320202,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607510654
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"129120\">@Alexander Bentkamp</span> Thanks for pointing this out! This is very close to what I want, but I think the definition I outlined above would still be worth doing, for a few reasons. I would really like to avoid having the tensor factors indexed by a specific predefined type like <code>ℕ</code> or <code>fin n</code>: for example, in a typical application in quantum information, we would have a quantum state <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>φ</mi><msub><mo stretchy=\"false\">⟩</mo><mrow><msup><mi>A</mi><mi>n</mi></msup><msup><mi>B</mi><mi>n</mi></msup><mi>E</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">|φ⟩_{A^n B^n E}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\">φ</span><span class=\"mclose\"><span class=\"mclose\">⟩</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5935428571428571em;\"><span style=\"top:-2.786em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5935428571428571em;\"><span style=\"top:-2.786em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">E</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>A</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">A^n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>B</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">B^n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> being two <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>-qubit states, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> being some other quantum system. So this object would be a vector in a space that is the tensor product of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2n+1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> spaces with those labels, and I'd like to be able to keep those system labels and never have to artificially number them. Also, one would want to be able to support infinite-dimensional spaces, which wouldn't be possible with holors.</p>",
        "id": 219335301,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1607520597
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"365384\">@Yunong Shi</span> I don't know what your plans are, but here's my take on doing quantum information in Lean at the moment: we're not there yet! :-) To give you an idea of the current situation, unitaries are not there, adjoints are not there (so forget Hermitian operators), there is no spectral decomposition, and we only got complex inner products and eigenvalues about two months ago. If you have a specific application that doesn't require too many of those features it might be possible to get started now, but personally my plan is to try to get those into mathlib by making PRs whenever I have a bit of time before trying to do actual quantum information.</p>",
        "id": 219337230,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1607521578
    },
    {
        "content": "<p>Depending on what you're doing, one option might be to switch to Coq and use this library: <a href=\"https://github.com/inQWIRE/QWIRE\">https://github.com/inQWIRE/QWIRE</a></p>",
        "id": 219337587,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1607521766
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"311453\">Frédéric Dupuis</span> <a href=\"#narrow/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product/near/219337230\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"365384\">Yunong Shi</span> I don't know what your plans are, but here's my take on doing quantum information in Lean at the moment: we're not there yet! :-) To give you an idea of the current situation, unitaries are not there, adjoints are not there (so forget Hermitian operators), there is no spectral decomposition, and we only got complex inner products and eigenvalues about two months ago. If you have a specific application that doesn't require too many of those features it might be possible to get started now, but personally my plan is to try to get those into mathlib by making PRs whenever I have a bit of time before trying to do actual quantum information.</p>\n</blockquote>\n<p>Thanks for the info. I'd love to help with the dev of libraries for quantum information. I will probably look at the code you mentioned and play around with it first.</p>",
        "id": 219388496,
        "sender_full_name": "Yunong Shi",
        "timestamp": 1607543290
    },
    {
        "content": "<p>I just managed to motivate myself to have a crack at this idea for the  tensor product of an indexed family of spaces: <a href=\"https://github.com/leanprover-community/mathlib/issues/5311\">#5311</a></p>",
        "id": 219518216,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1607626912
    },
    {
        "content": "<p>What should the tensor product of an empty index be? For the sake of tensor algebras, it feels like it should be isomorphic to <code>R</code>, but I think your PR is isomorphic to the trivial ring.</p>",
        "id": 219539535,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607637491
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>M</mi><mrow><mo>⊗</mo><mn>0</mn></mrow></msup><mo>=</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">M^{\\otimes 0}=R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊗</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> but I'm not sure if that's what you're asking</p>",
        "id": 219539590,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607637534
    },
    {
        "content": "<p>If you mean <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>⨂</mo><mrow><mi>i</mi><mo>∈</mo><mi mathvariant=\"normal\">∅</mi></mrow></msub><msub><mi>M</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\bigotimes_{i \\in \\emptyset} M_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.088602em;vertical-align:-0.338602em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">⨂</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.22528999999999993em;\"><span style=\"top:-2.4002900000000005em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">∈</span><span class=\"mord mtight\">∅</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.338602em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, this should definitely be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, as in Kevin's answer.</p>",
        "id": 219540110,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607637780
    },
    {
        "content": "<p>Having it the zero ring would break the usual formulas for the union of set indexes.</p>",
        "id": 219540230,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607637838
    },
    {
        "content": "<p><del>That's mostly what I'm asking, but for an indexed tensor product instead of a homogenous power</del> - edit: yes</p>",
        "id": 219540614,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607638012
    },
    {
        "content": "<p>My math answer would also be <code>R</code>, but right now the code assumes that the index type is nonempty.</p>",
        "id": 219549200,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1607643521
    },
    {
        "content": "<p>It's a bit awkward to change, because the <code>has_scalar</code> instance is defined by choosing one of the indices and doing <code>smul</code> on that coordinate.</p>",
        "id": 219549250,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1607643578
    },
    {
        "content": "<p>Also right now we can only do the tensor product over the whole type, and not a subset. It might be useful to put that in actually.</p>",
        "id": 219549379,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1607643680
    },
    {
        "content": "<p>Storing an R and <code>Pi i, M i</code> term separately under your quotient would fix that base case</p>",
        "id": 219550751,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607644811
    },
    {
        "content": "<p>Yeah, I was hoping for a more clever way but it doesn't look possible.</p>",
        "id": 219551636,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1607645597
    }
]
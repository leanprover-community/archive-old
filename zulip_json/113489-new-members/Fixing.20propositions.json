[
    {
        "content": "<p>While trying to understand <code>roption</code> I came up with the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">control.fix</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">aux</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">roption</span> <span class=\"n\">unit</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">roption</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">dom</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">()⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fix</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">roption.fix</span> <span class=\"o\">(</span><span class=\"n\">aux</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">dom</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">aux_id_eq_id</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">aux</span> <span class=\"n\">α</span> <span class=\"n\">id</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">aux</span><span class=\"o\">,</span> <span class=\"n\">has_mem.mem</span><span class=\"o\">,</span> <span class=\"n\">roption.mem</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">fix</span> <span class=\"n\">id</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n</code></pre></div>\n\n<p>What is <code>fix id a</code>? I strongly believe it is false (intuition!), but how do I show that to Lean?</p>",
        "id": 213081300,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1602533521
    },
    {
        "content": "<p>Also, <code>fix F a</code> where <code>F : (α → Prop) → α → Prop</code> and <code>a : α</code> is not decidable in general. What sort of predicate over <code>F</code> would it be necessary to show that it is?</p>",
        "id": 213081532,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1602533677
    },
    {
        "content": "<p>(It feels really weird to write <code>fix id</code> in Lean, where <code>fix</code> has some resemblance to Haskell's <code>fix</code>, since <code>fix id</code> is an infinite loop! I strongly believe this translates into an undecidable proposition here.)</p>",
        "id": 213081657,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1602533773
    },
    {
        "content": "<p>Here we go.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">fix</span> <span class=\"n\">id</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">⟩,</span> <span class=\"n\">h₂</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">i</span> <span class=\"k\">with</span> <span class=\"n\">i</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">h₁</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">ih</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 213083954,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1602534993
    },
    {
        "content": "<p>I am a bit bewildered by this proof. <code>fix id a</code> implies there is a natural number smaller than any natural number or larger than any natural number? (Does this question even make sense? I find it hard to describe what I am thinking.) Also, how <code>roption.fix.approx</code> works?</p>",
        "id": 213084184,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1602535126
    },
    {
        "content": "<p>Could you explain what <code>fix</code> does?</p>",
        "id": 213085151,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1602535832
    },
    {
        "content": "<p>To be honest, I am not really sure, since I don't understand <code>roption.fix</code>. But I am going to give a (hopefully) educated guess.</p>\n<p><code>roption</code> is the following type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- `roption α` is the type of \"partial values\" of type `α`. It</span>\n<span class=\"sd\">  is similar to `option α` except the domain condition can be an</span>\n<span class=\"sd\">  arbitrary proposition, not necessarily decidable. -/</span>\n<span class=\"kd\">structure</span> <span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">roption</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">dom</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">get</span> <span class=\"o\">:</span> <span class=\"n\">dom</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n\n<p>Note that <code>roption unit</code> is pretty much <code>Prop</code>. Also note that <code>roption</code> is a kind of continuation. <code>fix F a</code> return a proposition which is built recursively. This proposition may be is <em>fully</em> recursive (not \"terminating\" recursive, as functions in Lean). As such, it may not be decidable. <code>roption</code> acting like a continuation makes its construction \"lazy\" is some sense.</p>\n<p><code>F : (α → Prop) → α → Prop</code> can decide whether to or not to call its first argument. Therefore, it can branch depending on <code>α</code>. So the decidability <code>fix F a</code> (should) depend on <code>F</code> only.</p>",
        "id": 213088627,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1602538413
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">roption</span> <span class=\"bp\">$</span> <span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">roption</span> <span class=\"bp\">$</span> <span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/-- A series of successive, finite approximation of the fixed point of `f`, defined by</span>\n<span class=\"sd\">`approx f n = f^[n] ⊥`. The limit of this chain is the fixed point of `f`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">fix.approx</span> <span class=\"o\">:</span> <span class=\"n\">stream</span> <span class=\"bp\">$</span> <span class=\"bp\">Π</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">roption</span> <span class=\"bp\">$</span> <span class=\"n\">β</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"bp\">⊥</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">fix.approx</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div>\n\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The least fixed point of `f`.</span>\n\n<span class=\"sd\">If `f` is a continuous function (according to complete partial orders),</span>\n<span class=\"sd\">it satisfies the equations:</span>\n\n<span class=\"sd\">  1. `fix f = f (fix f)`          (is a fixed point)</span>\n<span class=\"sd\">  2. `∀ X, f X ≤ X → fix f ≤ X`   (least fixed point)</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">fix</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">roption</span> <span class=\"bp\">$</span> <span class=\"n\">β</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"n\">roption.assert</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">fix.approx</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">dom</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">well_founded.fix.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">nat.upto.wf</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fix_aux</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">nat.upto.zero</span> <span class=\"n\">x</span>\n</code></pre></div>\n\n<p><code>roption.fix.approx</code> recurses a finite amount of times before returning an empty <code>roption</code> (e.i. a continuation which cannot be called; in our case just <code>false</code>). To call the <code>roption</code> continuation you need to prove that <code>f</code> returns after iterating a finite amount of times, that is, <code>∃ i, (fix.approx f i x).dom</code>.</p>",
        "id": 213089142,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1602538804
    },
    {
        "content": "<p>I wonder how to get <code>fix F = F (fix F)</code> (in the cases where it is doable).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">pp.proofs</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">fix</span> <span class=\"n\">F</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">hF</span> <span class=\"o\">(</span><span class=\"n\">fix</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">fix</span> <span class=\"n\">roption.fix</span> <span class=\"n\">roption.assert</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 213090028,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1602539630
    },
    {
        "content": "<p>\"Beta reduced\" <code>fix</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.upto</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- A series of successive, finite approximation of the fixed point of `f`,</span>\n<span class=\"sd\">defined by `approx f n = f^[n] (λ _, false)`. The limit of this chain is the</span>\n<span class=\"sd\">fixed point of `f`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">fix.approx</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>       <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">false</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">fix.approx</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Loop body for finding the fixed point of `f`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">fix_aux</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">nat.upto</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">nat.upto</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">f</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">i.succ</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nat.lt_succ_self</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">a</span>\n\n<span class=\"sd\">/-- The least fixed point of `f`.</span>\n\n<span class=\"sd\">If `f` is a continuous function (according to complete partial orders),</span>\n<span class=\"sd\">it satisfies the equations:</span>\n\n<span class=\"sd\">  1. `fix f = f (fix f)`          (is a fixed point)</span>\n<span class=\"sd\">  2. `∀ p, f p ≤ p → fix f ≤ p`   (least fixed point)</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">fix</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">fix.approx</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">well_founded.fix</span> <span class=\"o\">(</span><span class=\"n\">nat.upto.wf</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fix_aux</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">nat.upto.zero</span> <span class=\"n\">a</span>\n\n<span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">nat.upto.wf</span>\n<span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">nat.upto.succ</span>\n</code></pre></div>\n\n<p><code>nat.upto.wf</code> and <code>nat.upto.succ</code> are the culprits why <code>fix</code> uses <code>classical.choice</code>. I believe <code>fix f</code> is always computable (although the <code>Prop</code> it returns might not).</p>",
        "id": 213091865,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1602541221
    },
    {
        "content": "<p>In general, the domain of an roption is not decidable - in fact that's the whole point; an roption with decidable domain is equivalent to an <code>option A</code></p>",
        "id": 213110839,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602563057
    },
    {
        "content": "<p>but it's also not that useful to have decidability for the domain of a particular roption. Normally you would instead just prove it is true or false (depending on the situation)</p>",
        "id": 213110858,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602563125
    },
    {
        "content": "<p>I find the simpler version <code>pfun.fix</code> easier to think about. This has the type <code>(A -&gt; roption (A + B)) -&gt; A -&gt; roption B</code>, and the idea is that starting from an initial value <code>A</code>, you call the provided function repeatedly until you get a <code>B</code>. If the function never returns a <code>B</code> then the roption is empty</p>",
        "id": 213110930,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602563233
    },
    {
        "content": "<p>You can define this without any choice principles; the domain of the roption is the proposition \"there exists a finite sequence of calls <code>f a0 = some (inl a1), f a1 = some (inl a2), ..., f an = some (inr b)</code>\", and under that assumption, the <code>b</code> that is obtained is uniquely defined</p>",
        "id": 213111017,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602563349
    },
    {
        "content": "<p>This proposition is clearly not decidable in general - it is equivalent to the halting problem - but it is maximal in the sense that if the function terminates then <code>pfun.fix</code> will pick out the right answer, which makes it very useful to specify values that have not yet been shown to exist</p>",
        "id": 213111079,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602563416
    },
    {
        "content": "<p><code>roption.fix</code> adds some classical logic in order to make it total, but the classical logic is all contained in the domain proposition so it's still computable (because this only concerns the function part, which is still uniquely defined)</p>",
        "id": 213111161,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602563548
    }
]
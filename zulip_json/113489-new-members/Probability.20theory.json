[
    {
        "content": "<p>I definitely agree that it would be great to have much of <a href=\"https://github.com/google/formal-ml\">formal ML</a> in mathlib. It seems like a fantastic addition to probability theory and I wasn't aware of it before. Thank you Joao for pointing it out! And of course thanks to Martin Zinkevich for the whole thing!</p>\n<p>(Btw, I think it might be best to rename this discussion's topic to something more accurately descriptive, e.g. \"probability theory\", maybe starting from Floris' message. Renaming topics seems to require admin rights, though.)</p>",
        "id": 233038577,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1617489902
    },
    {
        "content": "<p>(I've renamed the thread.)</p>",
        "id": 233039521,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1617491027
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"116448\">@Koundinya Vajjha</span>'s repo at <a href=\"https://github.com/jtristan/stump-learnable\">https://github.com/jtristan/stump-learnable</a> has some material on probability theory as well.</p>",
        "id": 233039682,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1617491221
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/113489-new-members/topic/Probability.20theory/near/233031296\">said</a>:</p>\n<blockquote>\n<p>I am not sure what the etiquette here is, not to mention the ethics and the law -- if a person writes a Lean package under an open-source license (as Martin did with FormalML), is it ok for someone else to PR parts of it, keeping the copyright and authorship intact?</p>\n</blockquote>\n<p>As far as ethics and law is concerned, the answer is yes and this is common practice in software.</p>\n<p>It's necessary that the licenses be compatible -- that is, the original license and that of the project the material is then contributed to must not have conditions that conflict with each other -- but it looks like Formal ML uses exactly the same license as mathlib, so that's not an issue here.</p>\n<p>(And of course it's essential to be explicit about the original authorship, essential ethically and also legally under typical open-source licenses.)</p>",
        "id": 233265945,
        "sender_full_name": "Greg Price",
        "timestamp": 1617684126
    },
    {
        "content": "<p>That doesn't answer the question of etiquette. I think the central question there is usually how the original author is likely to feel about it.</p>",
        "id": 233265964,
        "sender_full_name": "Greg Price",
        "timestamp": 1617684152
    },
    {
        "content": "<p>I just sent an email to Martin Zinkevich asking his permission to integrate FormalML into mathlib. Attached is a first attempt to integrate his file probability_space.lean into mathlib. Here is an immediate issue. He defines a probability space (see <a href=\"https://github.com/google/formal-ml/blob/master/src/formal_ml/probability_space.lean\">https://github.com/google/formal-ml/blob/master/src/formal_ml/probability_space.lean</a>) as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">probability_space</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">measure_theory.measure_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">univ_one</span><span class=\"o\">:</span><span class=\"n\">volume.measure_of</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>whereas mathlib already has </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">probability_measure</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">measure_univ</span> <span class=\"o\">:</span> <span class=\"n\">μ</span> <span class=\"n\">univ</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>How should these be reconciled? <a href=\"/user_uploads/3121/w_CHwPYslseOGK1DxDn3cazu/probability_space.lean\">probability_space.lean</a> Also measurable_setB needs a better name.</p>",
        "id": 234999681,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1618676340
    },
    {
        "content": "<p>Those are the same? A probability space is a measure space where the designated \"<code>volume</code>\" measure is a probability measure</p>",
        "id": 234999799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618676454
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  Repeating \"=1\" seems redundant--one definition could rely on the other, i.e., a probability_space is a measure_space with a measure that is a probability_measure.</p>",
        "id": 235000525,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1618677128
    },
    {
        "content": "<p>That's what I just said</p>",
        "id": 235000540,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618677145
    },
    {
        "content": "<p>I don't think it matters too much whether the field is <code>  (univ_one:volume.measure_of (set.univ) = 1)</code> or <code>[prob : probability_measure volume]</code></p>",
        "id": 235000719,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618677283
    },
    {
        "content": "<p>the former is probably a bit more convenient when constructing probability spaces</p>",
        "id": 235000740,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618677310
    },
    {
        "content": "<p>but you can have constructors for both versions</p>",
        "id": 235000754,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618677321
    },
    {
        "content": "<p>Judging by your first PR to attempt to integrate formalML into mathlib, it may make sense to first integrate mathlib into formalML; despite depending on mathlib, the library seems to repeat lots of our lemmas.</p>",
        "id": 235064742,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618744766
    },
    {
        "content": "<p>I guess how viable that is depends on whether Martin has the time to accept pull requests.</p>",
        "id": 235064812,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618744822
    },
    {
        "content": "<p>Or simply fork.</p>",
        "id": 235065258,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618745310
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I have created a branch probability_theory with the new file probability_space.lean based on <span class=\"user-mention\" data-user-id=\"247798\">@Martin Zinkevich</span>'s  formal-ml (<a href=\"https://github.com/leanprover-community/mathlib/blob/probability_theory/src/probability_theory/probability_theory.lean\">https://github.com/leanprover-community/mathlib/blob/probability_theory/src/probability_theory/probability_theory.lean</a>). This has nearly 700 lines of code, as a first step, from 3300 in the formal-ml file. I wanted to touch base before I submit a pull request. There are no repeated lemmas from mathlib that I could see.  How does this look?</p>",
        "id": 239769634,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1621611182
    },
    {
        "content": "<p>A quick skim:</p>\n<ul>\n<li><code>probability_space.to_measurable_space</code> should be automatic; in general, when adding an instance you can check if it's needed by first trying to define it with <code>by apply_instance</code></li>\n<li><code>measurable_set_sub</code> looks like a bad idea to me. Why not skip straight to <code>event</code>, and define it as <code>abbreviation event : Type* := {x : set Ω // measurable_set  x}</code>. That's likely to remove the need for most of the lemmas in the first 100 lines.</li>\n<li><code>to_ennreal_monotonic </code> exists already as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ennreal.coe_mono\">docs#ennreal.coe_mono</a>. <code>library_search</code> tells me that. In general, if you put all the arguments before the colon, <code>library_search</code> will have an easier time finding it. If you write a lemma <code>lemma foo : A  → B := begin intro a, ... end</code> then really you should have written <code>lemma foo (a : A) : B := begin ... end</code></li>\n</ul>",
        "id": 239772660,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621612363
    },
    {
        "content": "<ul>\n<li>I don't think you should even be writing <code>volume.measure_of x</code> - the canonical spelling should be <code>volume x</code></li>\n</ul>",
        "id": 239772950,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621612474
    },
    {
        "content": "<ul>\n<li>Instead of <code>{Ω : Type*} {P : probability_space Ω} (X : event P)</code> you probably want <code>{Ω : Type*} [probability_space Ω] (X : event Ω)</code></li>\n</ul>",
        "id": 239775638,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621613442
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, thoughts on renaming <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measurable_set\">docs#measurable_set</a> to <code>is_measurable</code> so that <code>measurable_set</code> can be used to instead mean <code>subtype is_measurable</code>?</p>",
        "id": 239776174,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621613682
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> thanks. If I skip straight to <code>abbreviation event : Type* := {x : set Ω // measurable_set  x}</code>, how do I address the error 'unknown identifier Ω'--does that not require a def? How would I modify the code to use the automatic instance? When I drop <code>measure_of</code>, how do I address the error \"invalid field notation, volume does not have explicit argument with type ...\". Your patience is appreciated.</p>",
        "id": 239778931,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1621614885
    },
    {
        "content": "<p>See my edited message</p>",
        "id": 239779169,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621614983
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">event</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">Ω</span> <span class=\"bp\">//</span> <span class=\"n\">measurable_set</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 239779173,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621614985
    },
    {
        "content": "<p>Then your lemmas below become something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">Pr_le_one</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">event</span> <span class=\"bp\">Ω</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Pr</span><span class=\"o\">[</span><span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 239779267,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621615034
    },
    {
        "content": "<blockquote>\n<p>invalid field notation, volume does not have explicit argument with type ...</p>\n</blockquote>\n<p>Change it from <code>P.volume.measure_of x</code> to <code>volume x</code>. You need to drop the <code>P.</code> too</p>",
        "id": 239779299,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621615054
    },
    {
        "content": "<p>I made a start on a very rough start on some of those changes here, which should be enough to answer some of your questions: <a href=\"https://gist.github.com/eric-wieser/1f119d6c22a9d14f5200f2be7b7ce511\">https://gist.github.com/eric-wieser/1f119d6c22a9d14f5200f2be7b7ce511</a></p>",
        "id": 239781174,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621615967
    },
    {
        "content": "<p>I am not really convinced by the design choice to try to hide as much as measure theory as possible, because I have the impression it will lead to a lot of code duplication. The branch uses <code>event</code> for a measurable set, and then formulates everything in terms of events. But this means that you will need to recreate all the set API for events (unions, intersections, diffs, Unions, sum over a finite event, and so on), and also all measure theory library (Lebesgue dominated convergence theorem, Fatou's lemma, and so on, and so on. It would feel to me much more economical to use standard terminology with measurability assumptions. And ideally one would craft a <code>measurability</code> tactic that one would use as a default tactic to fill all measurability fields when one applies lemmas.</p>",
        "id": 240019444,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1621844039
    },
    {
        "content": "<p>To me it seems the key change being proposed by this code is \"a bundled version of<code>measurable_set</code> would be useful\"</p>",
        "id": 240020665,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621844770
    },
    {
        "content": "<p>Along with lots of noise duplicating API</p>",
        "id": 240020672,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621844780
    },
    {
        "content": "<p>I made a PR providing some instances in <a href=\"https://github.com/leanprover-community/mathlib/issues/7702\">#7702</a></p>",
        "id": 240024739,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621847228
    },
    {
        "content": "<p>Also, we already have <code>probability_measure</code>, so I don't think <code>probability_space</code> is useful. Just using <code>(Pr : measure \\alpha) [probability_measure Pr]</code> should be enough.</p>",
        "id": 240024797,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1621847260
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.probability_measure\">docs#measure_theory.probability_measure</a> <del>seems not to exist</del></p>",
        "id": 240024805,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621847276
    },
    {
        "content": "<p>Presumably <code>[probability_measure (volume : measure_theory.measure α)]</code> would also work? (and be a direct substitution for the typeclass Hunter is proposing)</p>",
        "id": 240025087,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621847446
    },
    {
        "content": "<p>Thinking of standard probability measure changes arguments à la Girsanov, I think keeping the probability measure explicit can only help.</p>",
        "id": 240025267,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1621847580
    },
    {
        "content": "<p>The only drawback of this is that a measure is <code>ennreal</code>-valued, while here we would want to use mainly the real-valued version. We should probably introduce something like <code>measure.fin \\mu (A) = (\\mu A).to_real</code>, and use <code>Pr_ennreal</code> for the full measure and a notation for <code>Pr = Pr_ennreal.fin</code>.</p>",
        "id": 240025661,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1621847816
    },
    {
        "content": "<p>Another issue I have with the <code>event</code> idea is that very often there are several sigma-algebras playing together (martingales are a basic probabilistic object built precisely around this idea, but it also shows up all the time in Markov chains). So one would need to define a bunch of \"events\" for these different sigma-algebras, but it is well known that doing operations on bundled objects is painful (like, if you have <code>A</code> which is an event for the sigma algebra <code>B</code>, and <code>A'</code> which is an event for the sigma algebra <code>B'</code>, then what is <code>A \\cap A'</code>? With plain sets, you just have a set, and then depending on the relationships between <code>B</code> and <code>B'</code> you can argue that this intersection belongs to <code>B</code>, or to <code>B'</code>, or maybe to yet another natural sigma-algebra, depending on the situation at hand).</p>",
        "id": 240039848,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1621856825
    },
    {
        "content": "<blockquote>\n<p>but it is well known that doing operations on bundled objects is painful</p>\n</blockquote>\n<p>Sure, but also mathlib seems to have fallen into a convention of bundling them anyway. A similar case comes up with \"what is <code>x + y</code>\" when <code>x</code> and <code>y</code> are from different add_subgroups. You can always escape to unbundled land with coercions, and an API around <code>event</code> (aka <code>subtype measuable_set</code>) could behave just the same</p>",
        "id": 240040096,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621856979
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Probability.20theory/near/240040096\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>but it is well known that doing operations on bundled objects is painful</p>\n</blockquote>\n<p>Sure, but also mathlib seems to have fallen into a convention of bundling them anyway.</p>\n</blockquote>\n<p>I am not so sure about that: I'd rather say that mathlib is pragmatic, and tries to make the most common operation the easiest possible. Adding elements of different add_subgroups is not really common, while intersecting measurable sets coming from different sigma-algebras will happen all the time.</p>",
        "id": 240040676,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1621857342
    },
    {
        "content": "<p>Maybe a difficulty here is that elementary probability theory, as taught to undergrads say, is mostly taking finite intersections of sets within a fixed sigma-algebra, and never needs anything fancy in measure theory. While more advanced probability theory is very different from this naive point of view.</p>",
        "id": 240041061,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1621857556
    },
    {
        "content": "<p>I think I can see the argument for why you need the unbundled approach, but it's not clear to me why you can't also have the bundled approach for convenience in the simple cases. Ignoring the \"more accessible to undergrads\" argument, the \"does boring book-keeping for you\" argument still holds</p>",
        "id": 240041252,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621857642
    },
    {
        "content": "<p>Any by \"have the bundled approach for convenience\", I guess I really just mean \"provide a <code>[measurable_space α] : boolean_algebra (subtype (measurable_set : set α → Prop))</code> instance somewhere\".</p>",
        "id": 240041390,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621857727
    },
    {
        "content": "<p>Except that one also takes a lot of countable intersections, preimages under measurable functions, and so on. That's why a tactic seems to me to be more suited for the job (there is such a tactic in Isabelle, and 99% of the time you don't need to mention measurability, it's just taken care of transparently).</p>",
        "id": 240042321,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1621858314
    },
    {
        "content": "<p>Preimages don't sound like aren't a major obstacle, we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submonoid.comap\">docs#submonoid.comap</a> etc. Countable intersections I guess are problematic as mathlib only has lemmas about countable intersections of sets, not on arbitrary lattices?</p>",
        "id": 240043481,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621858984
    },
    {
        "content": "<p>My inexperienced but interested user's opinion so far matches well with many of the things Sebastien has said here. But I don't intend that as an opinion about implementation (I am not yet in a position to have one).</p>\n<p>I have played a bit with Lean's probability theory (i.e., measure theory) as a first formalization exercise for myself after some tutorials (NNG of course, Kevin's \"Formalizing math\" course, and some parts of \"Lean together\"). I feel parts of the library are quite mature, and I can (painfully slowly) do things I would hope to.</p>\n<p>I in particular agreed with Sebastien about all of the following:</p>\n<ul>\n<li>One very often wants to use many probability measures; whether in coupling arguments, or convergence in distribution, or in change-of-measure arguments (e.g., Girsanov's theorem).</li>\n<li>It seems essential in probability theory and stochastic processes to be able to work with many (sub)sigma-algebras on the same set; conditional expected values and martingales being probably the most prominent cases.</li>\n<li>Every now and then coercions between <code>ennreal</code>s and either <code>nnreal</code>s or <code>ℝ</code> get me stuck quite badly. For probabilities, these difficulties feel like they should not be there, but for expected values they are essentially as unavoidable as with integrals against general measures.</li>\n<li>Settling measurability questions by hand is sometimes indeed a pain (in Lean and to some extent on pen and paper). This seems to correspond to maths students' experience with measure-theoretic probability as well: often the most tedious step in probability courses are related to verifications of measurability (or other measurability issues such as indistinguishability / versions / ...). I have no idea about tactics except that when they work, they are fantastic. So if it is possible to have a <code>measurability</code> tactic as Sebastien proposes, I will be super happy!</li>\n</ul>\n<p>To be clear, these are just my experiences as a beginner, and not an opinion on how to develop the mathlib probability library. I am very impressed with the existing library and its implementation, so obviously the experts here (including in this thread) know what they are doing :).</p>",
        "id": 240072473,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1621872417
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span>, I've got an approval on <a href=\"https://github.com/leanprover-community/mathlib/issues/7702\">#7702</a> which I mention above. Are you against having these instances, or just claiming they're not nearly as useful as they might first look? If the latter, I'll go ahead and merge, since even if the instances aren't that helpful, they seem like the obvious instances to have available.</p>",
        "id": 240116719,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621892878
    },
    {
        "content": "<p>I'm definitely fine with having this merged! We will see later if this turns out to be useful or not so much.</p>",
        "id": 240144388,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1621920925
    },
    {
        "content": "<p>A follow-up question; which of these is preferable for working with <code>subtype (measurable_set : set α → Prop)</code>?</p>\n<ul>\n<li>Give that type a new name like <code>event α</code> (does this make sense for non-probability spaces? Is there a better name?)</li>\n<li>Rename <code>measurable_set s</code> to <code>is_measurable_set s</code>, so that that we can repurpose <code>measurable_set α</code> to mean `subtype (is_measurable_set : set α → Prop)</li>\n<li>Do not introduce a new name, and require users to work with the <code>subtype</code> directly. The main disadvantage of this approach is a lack of an obvious namespace to put definitions and lemmas about the bundled type in.</li>\n</ul>",
        "id": 240172545,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621941741
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  I have substantially updated probability_space.lean from formal-ml for inclusion in mathlib here (<a href=\"https://github.com/leanprover-community/mathlib/blob/1e717b785574bb153f1f3a1b3d0ff644b905751f/src/probability_theory/probability_space.lean\">https://github.com/leanprover-community/mathlib/blob/1e717b785574bb153f1f3a1b3d0ff644b905751f/src/probability_theory/probability_space.lean</a>). This now avoids creating many lemmas already in mathlib. I ran into a few roadblocks where I would appreciate your help again.. These are marked TODO. If you can help me resolve these, there are many other probability/machine learning components in formal-ml that would be good additions to mathlib.</p>\n<p>Line 70. \"def event\" should replace \"measurable_space\" with \"probability_space\" but then I could not resolve all the errors when I changed this.</p>\n<p>Line 649. Should we get rid of the alternative definition of measurable_set as measurable_setB (which I could work out how to do) or just keep it with a name like \"measurable_space_sub\".</p>\n<p>Line 1068. \"lemma eall_finset_empty\" is commented out because I could not resolve the type mismatch.</p>\n<p>Line 1122. I brought back \"infix <code> •ℕ </code>:70 := nsmul\" from an older version of mathlib to get this to compile. How do I get rid of it again?</p>\n<p>Line 1148. See new definition of \"noncomputable def classical.decidable_eq\" which I could not eliminate</p>\n<p>There are compile errors I could not resolve: line 1050, 1408 (Pr_exists_eq_powerset), 1492 (independent_events_not_of_independent_events), 2880 (Pr_eany_sum), 3260, 3298 (independent_events_empty), 3410 (and_mem_exists), 3521 (Pr_sum_partition), 3542 (conditional_independent_event_pair_limit), 3580 (compose_independent_pair_right).</p>\n<p>Line 2250. Is \"measurable_set_prod'\" necessary given \"measurable_set_prod\"</p>\n<p>Line 2326. \"noncomputable def fintype.encodable\" could be imported from data.equiv.list rather than being redefined here.</p>\n<p>Line 2402. Is \"singleton_prod'\" needed given \"set.prod_singleton_singleton\"?</p>\n<p>Line 2594. Can lemma eq_or_ne2 be dropped?</p>\n<p>Line 2605, 3029, 3124. Move to nnreal?</p>\n<p>Lines 2624, 2686, 2707, 2710, 2725, 2738, 2754, 2770, 2780, 2787, 2843, 2854, . Move to sum?</p>\n<p>Lines 3043, 3061, 3076. Move to set?</p>\n<p>Hunter</p>",
        "id": 240681505,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1622261110
    },
    {
        "content": "<p>Line 70 is better with <code>measurable_space</code></p>",
        "id": 240686761,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622269624
    },
    {
        "content": "<p>Line 649: <code>measurable_setB</code> is not an \"alternative definition\", it's an identical one to <code>event</code>. There is no reason to keep it.</p>",
        "id": 240686812,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622269697
    },
    {
        "content": "<p>Line 83: this already exists, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measurable_set.subtype.has_mem\">docs#measurable_set.subtype.has_mem</a></p>",
        "id": 240686945,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622269886
    },
    {
        "content": "<p>Line 210: <code>has_emptyc_event</code> already exists, it's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measurable_set.subtype.has_emptyc\">docs#measurable_set.subtype.has_emptyc</a>.</p>",
        "id": 240687032,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622270002
    },
    {
        "content": "<p>Line ???: eany_finset is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sup\">docs#finset.sup</a></p>",
        "id": 240687477,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622270667
    },
    {
        "content": "<p>I don't remember if I said this before, but I don't think your current approach to trying to pull parts of formal-ml into mathlib is going to be fruitful. Here's the approach I would take if I were invested in this project:</p>\n<ul>\n<li>Make a fork of formal-ml, and in that fork: ..</li>\n<li>Turn on CI (like I suggested in <a href=\"https://github.com/Google/formal-ml/issues/1\">Google/formal-ml#1</a>)</li>\n<li>Fix the build. Formal_ml currently doesn't compile without any changes</li>\n<li>Run <code>leanproject up</code>. Fix the build. The community on Zulip can likely help with bits of this step, as the people here (like me) are usually responsible for the breakage I. The first place. This step is the hardest one</li>\n<li>Look for parts of formal-ml that duplicate mathlib and remove them. Make sure the build still works by replacing their uses with mathlib equivalents. <a class=\"stream\" data-stream-id=\"217875\" href=\"/#narrow/stream/217875-Is-there-code-for-X.3F\">#Is there code for X?</a> can help with (self-contained) \"does mathlib already have this\" questions. </li>\n<li>Start looking for small bits of the now-compatible formal-ml that can be added to mathlib.</li>\n<li>Add these to mathlib, update mathlib in formal-ml, then remove them from formal-ml</li>\n</ul>\n<p>By skipping straight to this penultimate step as you are now, you're not only squashing all the hard work into one extra hard task, but you're also putting all your eggs into one basket; if your code doesn't end up in mathlib, then all your work essentially ends up discarded. With my suggestion, you still end up with a better formal-ml, even if it doesn't make it into mathlib.</p>",
        "id": 240689283,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622273556
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 240690546,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622275741
    },
    {
        "content": "<p>Thanks, I am making good progress on steps 4-5--no point in fixing broken bits that are unused or duplicate. I am primarily using <code>library_search</code>--has anyone explored making this faster for instance through indexing?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Probability.20theory/near/240689283\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Run <code>leanproject up</code>. Fix the build. The community on Zulip can likely help with bits of this step, as the people here (like me) are usually responsible for the breakage I. The first place. This step is the hardest one</li>\n<li>Look for parts of formal-ml that duplicate mathlib and remove them. Make sure the build still works by replacing their uses with mathlib equivalents. <a class=\"stream\" data-stream-id=\"217875\" href=\"/#narrow/stream/217875-Is-there-code-for-X.3F\">#Is there code for X?</a> can help with (self-contained) \"does mathlib already have this\" questions. ```</li>\n</ul>\n</blockquote>",
        "id": 240859335,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1622484541
    },
    {
        "content": "<p>The point in fixing formal-ml <em>before</em> updating mathlib (step 3) is to separate \"this code is broken because it is wrong\" and \"this code is broken because the community broke it\"</p>",
        "id": 240862175,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622487053
    },
    {
        "content": "<p>Ah, I see you \"fixed\" CI by commenting out bits you don't care about - that's probably ok</p>",
        "id": 240862575,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622487370
    },
    {
        "content": "<p>Nice job on getting it passing, anyway!</p>",
        "id": 240862719,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622487514
    },
    {
        "content": "<p>Yes, I got formal-ml to compile before upgrading, as there were only 1-2 two issues (I commented out a few tricky-looking bits) and also discovered that #check and #print send output to the console without triggering a CI failure. After upgrading, I was able to fix almost all community-broken code by hand and using library_search (can we provide deprecated defs/thms/lemmas that point to the new ones). The big task now is finding code that duplicates mathlib relying largely on running library_search over a hundred times, and factoring it out out manually (wish I had Eclipse-like \"inline/extract\" refactoring tools to do this automatically). I am holding off committing until I have finished or reached a roadblock.</p>",
        "id": 240866333,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1622490732
    },
    {
        "content": "<p>Is there a way to check if a definition duplicates one already in mathlib?</p>",
        "id": 240870108,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1622494218
    },
    {
        "content": "<p><code>library_search</code> is probably the best automatic method, but I would recommend reading all the theorem statements in files that seem to be in the same topic as what you are porting</p>",
        "id": 240870162,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622494306
    },
    {
        "content": "<p>You can also ask in the <a class=\"stream\" data-stream-id=\"217875\" href=\"/#narrow/stream/217875-Is-there-code-for-X.3F\">#Is there code for X?</a> stream.</p>",
        "id": 240870215,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1622494330
    },
    {
        "content": "<p>There is hopefully scope to make library_search faster, but it will rely on good caching. <code>library_search</code> under the hood is just using <code>apply</code>, and the \"problem\" is that Leo did an incredible job of making <code>apply</code> _fast_: so fast that any naive filtering you do actually makes things slower.</p>\n<p>But in the context of running library_search relative to a fixed library (i.e. mathlib), presumably you can cache a lot of the work required to build indices, and it would be great if someone did this!</p>",
        "id": 240875919,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622499635
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Probability.20theory/near/239776174\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span>, thoughts on renaming <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measurable_set\">docs#measurable_set</a> to <code>is_measurable</code> so that <code>measurable_set</code> can be used to instead mean <code>subtype is_measurable</code>?</p>\n</blockquote>\n<p>Huh, it used to be called <code>is_measurable</code> but was renamed to <code>measurable_set</code> in <a href=\"https://github.com/leanprover-community/mathlib/issues/6001\">#6001</a>. Perhaps <code>is_measurable_set</code> would be a better name.</p>",
        "id": 240922712,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622543860
    },
    {
        "content": "<p>How can I use the instance \"measurable_set.subtype.has_emptyc\" rather than the instance on the third line below? If I comment out that line, then there is a redline under the ∅ symbol.</p>\n<p>def event (Ω : Type<em>) [measurable_space Ω] : Type</em> := {x : set Ω // measurable_set x}<br>\ndef event_empty (Ω : Type*) [measurable_space Ω] : event Ω := { val := ∅,   property := measurable_set.empty,}<br>\ninstance has_emptyc_event {Ω : Type*} {M : measurable_space Ω} : has_emptyc (event Ω) := ⟨ @event_empty Ω M ⟩<br>\nlemma has_emptyc_emptyc_event {Ω : Type*} [probability_space Ω] : ∅ = (event_empty Ω) := sorry</p>",
        "id": 241090958,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1622592250
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a> / <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 241091096,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622592367
    },
    {
        "content": "<p>In front of <code>def event</code> write <code>@[derive has_emptyc]</code>.</p>",
        "id": 241091115,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622592388
    },
    {
        "content": "<p>This is how you copy instances to a type synonym.</p>",
        "id": 241091124,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622592398
    },
    {
        "content": "<p>Cool. But that does not seem to work for <code>@[derive has_mem]</code> as there is an error \"type expected at has_mem\"</p>\n<p><code>instance {Ω : Type*} [P : probability_space Ω] : has_mem Ω (event Ω) := { mem := event_mem }\nlemma event_mem_val {Ω : Type*} [P : probability_space Ω] (ω : Ω) (E : event Ω) :  (ω ∈ E) = (ω ∈ E.val) := rfl</code></p>",
        "id": 241091946,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1622593282
    },
    {
        "content": "<p><code>derive</code> takes typeclasses with just one argument. You may need to write a lambda to tell it what the other argument of <code>has_mem</code> should be.</p>",
        "id": 241092156,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622593456
    },
    {
        "content": "<p>Per <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a>, if you use triple backticks you'll get a code block, which is more readable.</p>",
        "id": 241092169,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622593476
    },
    {
        "content": "<p>It's also much easier to give a complete answer if you post a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, so others can copy and paste your problem into Lean.</p>",
        "id": 241092190,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622593505
    },
    {
        "content": "<p>If they have to add imports and variables themselves they're just not going to do it, so you get vaguer answers. :-)</p>",
        "id": 241092205,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622593524
    },
    {
        "content": "<p>Got it, how would you suggest proving the last below (now a mwe)</p>\n<div class=\"codehilite\" data-code-language=\"import\"><pre><span></span><code>import measure_theory.measure_space\nopen measure_theory measurable_space\nclass probability_space (α : Type*) extends measure_space α := (volume_univ : volume (set.univ) = 1)\n@[derive has_emptyc] def event (Ω : Type*) [measurable_space Ω] : Type* := {x : set Ω // measurable_set x}\ndef event_empty (Ω : Type*) [measurable_space Ω] : event Ω := { val := ∅,   property := measurable_set.empty,}\nlemma has_emptyc_emptyc_event {Ω : Type*} [probability_space Ω] : ∅ = (event_empty Ω) := sorry```\n</code></pre></div>",
        "id": 241092538,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1622593780
    },
    {
        "content": "<p>Put a return after the <code> ``` </code>, or else it will eat the first line of the code block and not syntax highlight it</p>",
        "id": 241092695,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622593899
    },
    {
        "content": "<p>(Put a newline after the initial three backticks.)</p>",
        "id": 241092700,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622593903
    },
    {
        "content": "<p>also before the final <code> ``` </code>, or else it will show up at the end of the code block</p>",
        "id": 241092793,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622593971
    },
    {
        "content": "<p><code>rfl</code>?</p>",
        "id": 241092938,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622594067
    },
    {
        "content": "<p>Actually never mind, this lemma is not needed for what it was being used for</p>",
        "id": 241093003,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1622594146
    },
    {
        "content": "<p>And just to demonstrate how to format this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.measure_space</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span> <span class=\"n\">measurable_space</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">probability_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">volume_univ</span> <span class=\"o\">:</span> <span class=\"n\">volume</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[derive has_emptyc]</span>\n<span class=\"kd\">def</span> <span class=\"n\">event</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">Ω</span> <span class=\"bp\">//</span> <span class=\"n\">measurable_set</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">event_empty</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">event</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"n\">measurable_set.empty</span><span class=\"o\">,}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">has_emptyc_emptyc_event</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">∅</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">event_empty</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 241093007,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622594149
    },
    {
        "content": "<p>As I said, the proof is just <code>rfl</code>, and you certainly don't need this lemma because you don't need the definition <code>event_empty</code>, because you can just use <code>∅</code>.</p>",
        "id": 241093077,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622594198
    },
    {
        "content": "<p>You missed the first line, which was <code>import measure_theory.measurable_space</code>, although it's not needed since it is implied by the second import</p>",
        "id": 241093215,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622594330
    },
    {
        "content": "<p>I deleted it on purpose. :-)</p>",
        "id": 241093250,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622594370
    },
    {
        "content": "<p>I think it might be a good idea to replace <code>def event</code> with <code>abbreviation event</code>? Since that way, you get all the instances and lemmas about them for free.</p>",
        "id": 241111606,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622616931
    },
    {
        "content": "<p>I don't think that would be a good idea. The space of measurable sets is quite structured (it's a sigma algebra!) so it would be better to have it be its own thing with a lattice instance (although that means that it should probably use <code>\\bot</code> instead of <code>\\empty</code>)</p>",
        "id": 241111933,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622617234
    },
    {
        "content": "<p>I don't see the problem - the only typeclasses we have on <code>subtype measurable_set</code> right now are precisely the ones Hunter wants</p>",
        "id": 241117928,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622621670
    },
    {
        "content": "<p>So why not make <code>event</code>, which is defined as that, reducible?</p>",
        "id": 241117951,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622621695
    },
    {
        "content": "<p>The lattice instance exists already as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measurable_set.subtype.boolean_algebra\">docs#measurable_set.subtype.boolean_algebra</a></p>",
        "id": 241117998,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622621743
    },
    {
        "content": "<p>How can I make event_univ have the type of event?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.measurable_space</span>\n<span class=\"kn\">import</span> <span class=\"n\">measure_theory.measure_space</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span> <span class=\"n\">measurable_space</span>\n\n<span class=\"kd\">@[derive [has_union,has_emptyc,has_compl, has_sdiff,has_union,has_inter]</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">event</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">Ω</span> <span class=\"bp\">//</span> <span class=\"n\">measurable_set</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">probability_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">volume_univ</span> <span class=\"o\">:</span> <span class=\"n\">volume</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">event_univ</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">event</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">set.univ</span><span class=\"o\">,</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"n\">measurable_set.univ</span><span class=\"o\">,}</span>\n</code></pre></div>",
        "id": 241488754,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1622779221
    },
    {
        "content": "<p>I don't understand your question. Doesn't it have type <code>event Ω</code> already in your code block?</p>",
        "id": 241489188,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622779710
    },
    {
        "content": "<p>Also --- I think you may have missed Eric's comment above that already the entire <code>boolean_algebra</code> structure is available, you should just <code>derive</code> that.</p>",
        "id": 241489210,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622779779
    },
    {
        "content": "<p>Or make <code>event</code> reducible (via <code>abbreviation</code>) so that you don't need to derive anything, <em>and</em> you get a handful of simp lemmas for free</p>",
        "id": 241498812,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622790987
    },
    {
        "content": "<p>With the <code>boolean_algebra</code> structure, <code>event_univ</code> is <code>⊤</code>.</p>",
        "id": 241498871,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622791070
    },
    {
        "content": "<p>Cool, so I change <code>def</code> to <code>abbreviation</code> in front of <code>event</code>, but how would I define <code>event_univ</code> as top leveraging the <code>boolean_algebra</code> structure (or otherwise). Right now, <code>event_univ</code> is not <code>event</code> but a Pi type: <code>event_univ : Π (Ω : Type u_1) [_inst_1 : measurable_space Ω], event Ω</code>.  Also, if I derive <code>boolean_algebra</code>, do I still need <code>has_union</code> etc?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.measurable_space</span>\n<span class=\"kn\">import</span> <span class=\"n\">measure_theory.measure_space</span>\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span> <span class=\"n\">measurable_space</span>\n<span class=\"kd\">@[derive [boolean_algebra,has_union,has_emptyc,has_compl, has_sdiff,has_union,has_inter]</span><span class=\"o\">]</span> <span class=\"c1\">-- is `has_union` etc needed?</span>\n<span class=\"kd\">abbreviation</span> <span class=\"n\">event</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">Ω</span> <span class=\"bp\">//</span> <span class=\"n\">measurable_set</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n<span class=\"kd\">class</span> <span class=\"n\">probability_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">volume_univ</span> <span class=\"o\">:</span> <span class=\"n\">volume</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">event_univ</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">event</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">set.univ</span><span class=\"o\">,</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"n\">measurable_set.univ</span><span class=\"o\">,}</span> <span class=\"c1\">-- does not work</span>\n<span class=\"k\">#check</span> <span class=\"n\">event_univ</span> <span class=\"c1\">--should be type event</span>\n<span class=\"kd\">def</span> <span class=\"n\">event_univ'</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">event</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"bp\">Ω.</span><span class=\"n\">T</span> <span class=\"c1\">-- ??? --how to make this \"top\"</span>\n</code></pre></div>\n<p>And then, would the <code>boolean_algebra</code> structure allow me to avoid new definitions of \"and\" etc for events, currently given as </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">measurable_inter</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">event</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">event</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span>  <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span><span class=\"n\">A.val</span> <span class=\"bp\">∩</span> <span class=\"n\">B.val</span><span class=\"o\">,</span>   <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"n\">measurable_set.inter</span> <span class=\"n\">A.property</span> <span class=\"n\">B.property</span><span class=\"o\">,}</span>\n<span class=\"kd\">def</span> <span class=\"n\">eand</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">event</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">event</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span>  <span class=\"n\">measurable_inter</span> <span class=\"n\">A</span> <span class=\"n\">B</span>\n<span class=\"kd\">infixr</span> <span class=\"bp\">`∧`</span> <span class=\"o\">:=</span> <span class=\"n\">eand</span>\n<span class=\"kd\">def</span> <span class=\"n\">enot</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">event</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">event</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=(</span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">ᶜ</span><span class=\"o\">,</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"n\">measurable_set.compl</span> <span class=\"n\">A.property</span><span class=\"o\">,}</span>\n<span class=\"kd\">def</span> <span class=\"n\">event_eqv</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">probability_space</span> <span class=\"bp\">Ω</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">:</span><span class=\"n\">event</span> <span class=\"bp\">Ω</span><span class=\"o\">):</span><span class=\"n\">event</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">((</span><span class=\"bp\">¬ₑ</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">¬ₑ</span> <span class=\"n\">B</span><span class=\"o\">))</span>\n<span class=\"kd\">infixr</span> <span class=\"bp\">`=ₑ`</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"o\">:=</span> <span class=\"n\">event_eqv</span>\n<span class=\"c1\">-- `measurable` is already in mathlib so `measurable_fun` seems duplicative</span>\n<span class=\"kd\">def</span> <span class=\"n\">measurable_fun</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>  <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Mα</span><span class=\"o\">:</span><span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Mβ</span><span class=\"o\">:</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">):</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">:=</span>  <span class=\"n\">subtype</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">measurable</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"n\">probability_space.to_measurable_space</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]:</span><span class=\"n\">measurable_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>  <span class=\"n\">measure_theory.measure_space.to_measurable_space</span>\n<span class=\"kd\">def</span> <span class=\"n\">random_variable</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Mβ</span><span class=\"o\">:</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">):</span><span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"n\">measurable_fun</span> <span class=\"o\">(</span><span class=\"n\">probability_space.to_measurable_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">Mβ</span>\n<span class=\"kd\">infixr</span>  <span class=\"bp\">`</span> <span class=\"bp\">→ₘ</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">80</span> <span class=\"o\">:=</span> <span class=\"n\">measurable_fun</span>\n<span class=\"kd\">infixr</span>  <span class=\"bp\">`</span> <span class=\"bp\">→ᵣ</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">80</span> <span class=\"o\">:=</span> <span class=\"n\">random_variable</span>\n</code></pre></div>",
        "id": 241710689,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1623013325
    },
    {
        "content": "<p>For eand and eor, you can probably just do <code>infixr `∧` := has_inf.inf</code>. if that doesn't work, copying the approach used by <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.Union/src\">src#set.Union</a> would probably work</p>",
        "id": 241711224,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623014200
    },
    {
        "content": "<p>That could look like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[reducible]</span>\n<span class=\"kd\">def</span> <span class=\"n\">eand</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">event</span> <span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">event</span> <span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">event</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">⊓</span><span class=\"o\">)</span>\n<span class=\"kd\">infixr</span> <span class=\"bp\">`∧`</span> <span class=\"o\">:=</span> <span class=\"n\">eand</span>\n\n<span class=\"kd\">@[reducible]</span>\n<span class=\"kd\">def</span> <span class=\"n\">enot</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">event</span> <span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">event</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"n\">has_compl.compl</span>\n</code></pre></div>",
        "id": 241711357,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623014415
    },
    {
        "content": "<p><code>(⊤ : event Ω)</code> is how to spell <code>event_univ</code>, but most of the time <code> ⊤</code> by itself will work, if you use it where lean is expecting an event.</p>",
        "id": 241711389,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623014516
    },
    {
        "content": "<p>You still need <code>has_union</code> if you want to be able to write <code>Ea ∪ Eb</code> as  another spelling of <code>Ea ⊔ Eb</code>. However, it sounds like you want to prefer a <code>Ea ∨ Eb</code> spelling anyway, so I wouldn't bother worrying about <code> ∪</code></p>",
        "id": 241711547,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623014705
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Probability.20theory/near/241117928\">said</a>:</p>\n<blockquote>\n<p>I don't see the problem - the only typeclasses we have on <code>subtype measurable_set</code> right now are precisely the ones Hunter wants</p>\n</blockquote>\n<p>I think the question to solve then is whether we intend to write this subtype as <code>subtype measurable_set</code> or <code>event</code> (or something else), and in either case there should be no abbreviation</p>",
        "id": 241726701,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623039221
    },
    {
        "content": "<p>I agree that we ought to decide on a spelling, but I can't help feeling that even if we pick <code>event</code> as the preferred spelling, it's useful for <code>event</code> to be reducible so that all the subtype coercion lemmas are easier to use.</p>",
        "id": 241733959,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623047205
    },
    {
        "content": "<p>Would having sub-lattice, sub-boolean-algebra and such structures make working with those coercions easier? Event would be defined as a sub-boolean-algebra for example. This is a question, not a suggestion, since those aspects are not very clear to me.<br>\nWe could define sub-sigma-algebra as well if we define those substructures, in order to get the properties of countable unions.</p>",
        "id": 241735634,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1623048674
    },
    {
        "content": "<p>Or maybe you already proved all the properties provided by <code>set_like</code> and the usual substructure construction for <code>subtype measurable_set</code> and it would make no difference. Turns out, I really don't know what I am talking about here, hence I'll stop. :)</p>",
        "id": 241736965,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1623049729
    },
    {
        "content": "<p>Yes, having sublattices in some form would help here</p>",
        "id": 241740949,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623052498
    },
    {
        "content": "<p>There was a start towards sublattices in <a href=\"https://github.com/leanprover-community/mathlib/issues/7093\">#7093</a>, but it looks abandoned.</p>",
        "id": 241741027,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1623052554
    },
    {
        "content": "<p>Although I'm starting to consider an alternative design, with a new typeclass <code>subtype.closed_under</code>, and have instances like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.lattice</span>\n\n<span class=\"sd\">/-- A class indicating a property holds on `op` if it holds on both arguments -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">subtype.closed_under₂</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">closed</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">},</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_inf</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">subtype.closed_under₂</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"bp\">⊓</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">has_inf</span> <span class=\"o\">(</span><span class=\"n\">subtype</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">inf</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">a</span> <span class=\"bp\">⊓</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">subtype.closed_under₂.closed</span> <span class=\"n\">_</span> <span class=\"n\">a.2</span> <span class=\"n\">b.2</span><span class=\"o\">⟩}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">subtype.semilattice_inf_of_closed_under</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semilattice_inf</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">subtype.closed_under₂</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"bp\">⊓</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">semilattice_inf</span> <span class=\"o\">(</span><span class=\"n\">subtype</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">subtype.semilattice_inf</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">subtype.closed_under₂.closed</span> <span class=\"n\">α</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 241741525,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623052900
    },
    {
        "content": "<p>Which means we don't need a different subtype for every combination of inf/sup/top/bot</p>",
        "id": 241741581,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623052927
    },
    {
        "content": "<p><code>borel_space</code> used to have <code>measurable.ennreal_mul</code>; what can I use in its place below:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ennreal_measurable_is_submonoid</span>\n  <span class=\"o\">{</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">M</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]:</span>\n   <span class=\"n\">is_submonoid</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">measurable</span> <span class=\"bp\">Ω</span> <span class=\"n\">ennreal</span> <span class=\"n\">M</span><span class=\"bp\">Ω</span> <span class=\"o\">(</span><span class=\"n\">borel</span> <span class=\"n\">ennreal</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">one_mem</span> <span class=\"o\">:=</span><span class=\"bp\">@</span><span class=\"n\">measurable_const</span> <span class=\"n\">ennreal</span> <span class=\"bp\">Ω</span> <span class=\"o\">(</span><span class=\"n\">borel</span> <span class=\"n\">ennreal</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"bp\">Ω</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_mem</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">A1</span> <span class=\"n\">A2</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">measurable.ennreal_mul</span> <span class=\"n\">A1</span> <span class=\"n\">A2</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 241966952,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1623177932
    },
    {
        "content": "<p>Is it just <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measurable.mul\">docs#measurable.mul</a>?</p>",
        "id": 241973080,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623180496
    },
    {
        "content": "<p>Yes, it is</p>",
        "id": 241973430,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623180631
    },
    {
        "content": "<p>Perfect, I should have consulted the documentation. Wonder why library_search/!, hint, suggest all missed the proof with one apply. It might be useful to have a deprecation file that proves old results with the new mathlib for each version.</p>",
        "id": 241989788,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1623188104
    },
    {
        "content": "<p>In the first instance defined below for nnreal, there is an error for <code>const_measurable_fun.has_coe</code> \"synthesized type class instance is not definitionally equal to expression inferred by typing rules, synthesized  nnreal.measurable_space inferred  borel nnreal\". Note that the second instance for real does not generate an error. I cannot replace <code>borel nnreal</code> with <code>nnreal.measurable_space</code> in the instance definition without creating other errors in subsequent code.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.measurable_space</span>\n<span class=\"kn\">import</span> <span class=\"n\">measure_theory.borel_space</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">measurable_fun</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>  <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Mα</span><span class=\"o\">:</span><span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Mβ</span><span class=\"o\">:</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">):</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">:=</span>\n    <span class=\"n\">subtype</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">measurable</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">infixr</span>  <span class=\"bp\">`</span> <span class=\"bp\">→ₘ</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">80</span> <span class=\"o\">:=</span> <span class=\"n\">measurable_fun</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">const_measurable</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">β</span><span class=\"o\">):</span>\n  <span class=\"o\">(</span><span class=\"n\">measurable</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">ω</span><span class=\"o\">:</span><span class=\"bp\">Ω</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">measurable_const</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">const_measurable_fun</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">M</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n   <span class=\"o\">[</span><span class=\"n\">Mβ</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">):</span><span class=\"n\">M</span><span class=\"bp\">Ω</span> <span class=\"bp\">→ₘ</span> <span class=\"n\">Mβ</span> <span class=\"o\">:=</span>\n   <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span><span class=\"o\">),</span> <span class=\"n\">c</span><span class=\"o\">),</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"n\">const_measurable</span> <span class=\"n\">c</span><span class=\"o\">,}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">const_measurable_fun.has_coe</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">M</span><span class=\"o\">:</span><span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">M</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">}:</span><span class=\"n\">has_coe</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"bp\">Ω</span> <span class=\"bp\">→ₘ</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">const_measurable_fun</span> <span class=\"n\">a</span><span class=\"o\">)}</span>\n\n<span class=\"c1\">--noncomputable</span>\n<span class=\"kd\">instance</span> <span class=\"n\">coe_measurable_fun_of_nnreal</span>\n      <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span><span class=\"o\">:</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">}</span>\n<span class=\"o\">:</span><span class=\"n\">has_coe</span> <span class=\"n\">nnreal</span> <span class=\"o\">(</span><span class=\"n\">measurable_fun</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">borel</span> <span class=\"n\">nnreal</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">const_measurable_fun.has_coe</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">coe_measurable_fun_of_real</span>\n      <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span><span class=\"o\">:</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">}</span>\n  <span class=\"o\">:</span><span class=\"n\">has_coe</span> <span class=\"n\">real</span> <span class=\"o\">(</span><span class=\"n\">measurable_fun</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">borel</span> <span class=\"n\">real</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">const_measurable_fun.has_coe</span>\n</code></pre></div>",
        "id": 242009878,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1623203774
    },
    {
        "content": "<p>What are the errors produced in the subsequent code?  It seems like the <code>measure_space</code> instance on <code>nnreal</code> has indeed been changed from the borel construction to the subtype construction, but presumably there was good reason for this.</p>",
        "id": 242011813,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1623206083
    },
    {
        "content": "<p>The change is from <a href=\"https://github.com/leanprover-community/mathlib/issues/6209\">#6209</a> (you can use git blame to track such things down)</p>",
        "id": 242011933,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1623206238
    },
    {
        "content": "<p>Hopefully the instance <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subtype.borel_space\">docs#subtype.borel_space</a> will let you convert from the one construction to the other.</p>",
        "id": 242012080,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1623206421
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> that worked, I just replaced <code>borel nnreal</code> with <code>nnreal.measurable_space</code> throughout the file. This was allow me to define expected value.</p>",
        "id": 242019506,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1623216582
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> I am stuck on what to replace <code>borel β</code> with in the sequence below  as <code>measurable_space β</code> does not work. In the instance declaration at the bottom, there is the error <code>SC_measurable_comm_semiring has type comm_semiring (measurable_fun MΩ (borel nnreal)) but is expected to have type  comm_semiring (measurable_fun MΩ nnreal.measurable_space)</code> :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.measurable_space</span>\n<span class=\"kn\">import</span> <span class=\"n\">measure_theory.borel_space</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.algebra.ring</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">formal_ml.real_measurable_space</span>\n<span class=\"kn\">import</span> <span class=\"n\">formal_ml.semiring</span>\n<span class=\"kn\">import</span> <span class=\"n\">formal_ml.independent_events</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">measurable_fun</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>  <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Mα</span><span class=\"o\">:</span><span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Mβ</span><span class=\"o\">:</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">):</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">:=</span>\n    <span class=\"n\">subtype</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">measurable</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">SC_sum_measurable_is_add_submonoid_from_semiring</span>\n<span class=\"o\">{</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">M</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">SC</span><span class=\"o\">:</span><span class=\"n\">topological_space.second_countable_topology</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n   <span class=\"o\">{</span><span class=\"n\">CSR</span><span class=\"o\">:</span><span class=\"n\">semiring</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">TA</span><span class=\"o\">:</span><span class=\"n\">topological_semiring</span> <span class=\"n\">β</span><span class=\"o\">}:</span>\n   <span class=\"n\">is_add_submonoid</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">measurable</span> <span class=\"bp\">Ω</span> <span class=\"n\">β</span> <span class=\"n\">M</span><span class=\"bp\">Ω</span> <span class=\"o\">(</span><span class=\"n\">borel</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n   <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">SC_sum_measurable_is_add_submonoid</span> <span class=\"bp\">Ω</span> <span class=\"n\">M</span><span class=\"bp\">Ω</span> <span class=\"n\">β</span> <span class=\"n\">T</span> <span class=\"n\">SC</span> <span class=\"o\">(</span><span class=\"n\">add_comm_monoid.to_add_monoid</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n   <span class=\"o\">(</span><span class=\"n\">topological_semiring.to_has_continuous_add</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">SC_mul_measurable_is_submonoid_from_semiring</span>\n  <span class=\"o\">{</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">M</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">SC</span><span class=\"o\">:</span><span class=\"n\">topological_space.second_countable_topology</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n   <span class=\"o\">{</span><span class=\"n\">CSR</span><span class=\"o\">:</span><span class=\"n\">semiring</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">TA</span><span class=\"o\">:</span><span class=\"n\">topological_semiring</span> <span class=\"n\">β</span><span class=\"o\">}:</span>\n   <span class=\"n\">is_submonoid</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">measurable</span> <span class=\"bp\">Ω</span> <span class=\"n\">β</span> <span class=\"n\">M</span><span class=\"bp\">Ω</span> <span class=\"o\">(</span><span class=\"n\">borel</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n   <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">SC_mul_measurable_is_submonoid</span> <span class=\"bp\">Ω</span> <span class=\"n\">M</span><span class=\"bp\">Ω</span> <span class=\"n\">β</span> <span class=\"n\">T</span> <span class=\"n\">SC</span> <span class=\"o\">(</span><span class=\"n\">monoid_with_zero.to_monoid</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n   <span class=\"o\">(</span><span class=\"n\">topological_semiring.to_has_continuous_mul</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">SC_measurable_semiring_is_sub_semiring</span>\n<span class=\"o\">{</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">M</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">:</span><span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">SC</span><span class=\"o\">:</span><span class=\"n\">topological_space.second_countable_topology</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n   <span class=\"o\">{</span><span class=\"n\">CSR</span><span class=\"o\">:</span><span class=\"n\">semiring</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">TA</span><span class=\"o\">:</span><span class=\"n\">topological_semiring</span> <span class=\"n\">β</span><span class=\"o\">}:</span>\n  <span class=\"n\">is_sub_semiring</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">measurable</span> <span class=\"bp\">Ω</span> <span class=\"n\">β</span> <span class=\"n\">M</span><span class=\"bp\">Ω</span> <span class=\"o\">(</span><span class=\"n\">borel</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">SC_sum_measurable_is_add_submonoid_from_semiring</span> <span class=\"bp\">Ω</span> <span class=\"n\">M</span><span class=\"bp\">Ω</span> <span class=\"n\">β</span> <span class=\"n\">T</span> <span class=\"n\">SC</span> <span class=\"n\">_</span> <span class=\"n\">TA</span><span class=\"o\">),</span>\n    <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">SC_mul_measurable_is_submonoid_from_semiring</span> <span class=\"bp\">Ω</span> <span class=\"n\">M</span><span class=\"bp\">Ω</span> <span class=\"n\">β</span> <span class=\"n\">T</span> <span class=\"n\">SC</span> <span class=\"n\">_</span> <span class=\"n\">TA</span><span class=\"o\">),</span>\n  <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">SC_measurable_comm_semiring</span>\n  <span class=\"o\">{</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">M</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">:</span><span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">SC</span><span class=\"o\">:</span><span class=\"n\">topological_space.second_countable_topology</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n   <span class=\"o\">{</span><span class=\"n\">CSR</span><span class=\"o\">:</span><span class=\"n\">comm_semiring</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">TA</span><span class=\"o\">:</span><span class=\"n\">topological_semiring</span> <span class=\"n\">β</span><span class=\"o\">}:</span>\n   <span class=\"n\">comm_semiring</span> <span class=\"o\">(</span><span class=\"n\">measurable_fun</span> <span class=\"n\">M</span><span class=\"bp\">Ω</span> <span class=\"o\">(</span> <span class=\"n\">borel</span> <span class=\"n\">β</span><span class=\"o\">)):=</span>\n   <span class=\"bp\">@</span><span class=\"n\">subtype.comm_semiring</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">measurable</span> <span class=\"bp\">Ω</span> <span class=\"n\">β</span> <span class=\"n\">M</span><span class=\"bp\">Ω</span> <span class=\"o\">(</span><span class=\"n\">borel</span> <span class=\"n\">β</span><span class=\"o\">))</span>\n   <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">SC_measurable_semiring_is_sub_semiring</span> <span class=\"bp\">Ω</span> <span class=\"n\">M</span><span class=\"bp\">Ω</span> <span class=\"n\">β</span> <span class=\"n\">T</span> <span class=\"n\">SC</span> <span class=\"o\">(</span><span class=\"n\">comm_semiring.to_semiring</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">TA</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">nnreal_measurable_fun_comm_semiring</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">M</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]:</span>\n  <span class=\"n\">comm_semiring</span> <span class=\"o\">(</span><span class=\"n\">measurable_fun</span> <span class=\"n\">M</span><span class=\"bp\">Ω</span> <span class=\"o\">(</span><span class=\"n\">nnreal.measurable_space</span><span class=\"o\">)):=</span>\n  <span class=\"bp\">@</span><span class=\"n\">SC_measurable_comm_semiring</span> <span class=\"bp\">Ω</span> <span class=\"n\">M</span><span class=\"bp\">Ω</span> <span class=\"n\">nnreal</span> <span class=\"n\">nnreal.topological_space</span>\n    <span class=\"n\">nnreal.topological_space.second_countable_topology</span> <span class=\"n\">nnreal.comm_semiring</span>\n    <span class=\"n\">nnreal.topological_semiring</span>\n</code></pre></div>",
        "id": 242133067,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1623274071
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"397140\">@Hunter Monroe</span> Can you please give a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?  This depends on a project, <code>formal_ml</code>, which I don't have downloaded.</p>",
        "id": 242134371,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1623274717
    },
    {
        "content": "<p>But, at a guess, instead of constructing all these algebraic structures using <code>borel β</code>, you should assume</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">borel_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 242134689,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1623274894
    },
    {
        "content": "<p>This is saying to Lean that, even though the <em>construction</em> of the sigma-algebra is not using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/borel\">docs#borel</a>, nonetheless the sigma-algebra which results is equal to the Borel sigma-algebra.</p>",
        "id": 242134814,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1623274959
    },
    {
        "content": "<p>Maybe you want to do something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.borel_space</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">SC_measurable_semiring_is_subsemiring</span>\n  <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space.second_countable_topology</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">borel_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_semiring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">subsemiring</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"bp\">|</span> <span class=\"n\">measurable</span> <span class=\"n\">f</span><span class=\"o\">},</span>\n  <span class=\"n\">one_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">measurable_const</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">hf</span> <span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"n\">hf.mul</span> <span class=\"n\">hg</span> <span class=\"o\">,</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">measurable_const</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">hf</span> <span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"n\">hf.add</span> <span class=\"n\">hg</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Measurable functions from `Ω` to `nnreal` are a subsemiring of all functions. -/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">subsemiring</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">nnreal</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">SC_measurable_semiring_is_subsemiring</span> <span class=\"bp\">Ω</span> <span class=\"n\">nnreal</span>\n</code></pre></div>",
        "id": 242137368,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1623276375
    },
    {
        "content": "<p>OK, here is a 452 line mwe, the question is focused on what to replace <code>borel</code> with in the last two def's (SC_measurable_semiring_is_sub_semiring, SC_measurable_comm_semiring) to avoid the error in the instance at the very end nnreal_measurable_fun_comm_semiring. The repository <a href=\"https://github.com/hmonroe/formal-ml\">https://github.com/hmonroe/formal-ml</a> has partial progress in getting formal-ml to work with the latest version of mathlib, which would bring a good chunk of probability theory.</p>",
        "id": 242138383,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1623277154
    },
    {
        "content": "<p>Not sure the attachment came through and I am just looking at your messages. <a href=\"/user_uploads/3121/lYIcwvNZgXNsduP0zin7j5vd/real_random_variable-copy.lean\">real_random_variable-copy.lean</a></p>",
        "id": 242138498,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1623277238
    },
    {
        "content": "<p>I think your example nearly works but the instance is looking for <code>SC_measurable_comm_semiring</code>--how would tweak your example?</p>",
        "id": 242138869,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1623277545
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"397140\">@Hunter Monroe</span> You don't need to do anything -- it already is a <code>comm_semiring</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.borel_space</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">SC_measurable_semiring_is_subsemiring</span>\n  <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space.second_countable_topology</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">borel_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_semiring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">subsemiring</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"bp\">|</span> <span class=\"n\">measurable</span> <span class=\"n\">f</span><span class=\"o\">},</span>\n  <span class=\"n\">one_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">measurable_const</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">measurable.mul</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">measurable_const</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">measurable.add</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Measurable functions from `Ω` to `nnreal` are a subsemiring of all functions. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">subsemiring</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">nnreal</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">SC_measurable_semiring_is_subsemiring</span> <span class=\"bp\">Ω</span> <span class=\"n\">nnreal</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">comm_semiring</span> <span class=\"o\">(</span><span class=\"n\">foo</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>",
        "id": 242140172,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1623278455
    },
    {
        "content": "<p>You can post stuff like this as a <a href=\"http://gist.github.com\">gist</a>, it saves people from having to download anything.</p>\n<p>I can't help with Borel stuff, but you use loads of <code>@</code>s. A use of <code>@</code> is often an indication that something is wrong -- <code>@</code>s can usually be avoided. For example (line 31): </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">set.preimage_fst_def</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Bα</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">set.preimage</span> <span class=\"o\">(</span><span class=\"n\">prod.fst</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">''</span> <span class=\"n\">Bα</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∈</span> <span class=\"n\">Bα</span><span class=\"o\">),</span> <span class=\"n\">U</span> <span class=\"bp\">=</span> <span class=\"n\">set.prod</span> <span class=\"n\">A</span> <span class=\"n\">set.univ</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">hA</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">hA</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">set.prod</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">refl</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">hA</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">hA</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">set.prod</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">refl</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>or</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">measurable_fun_product_measurableh</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">M1</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">M2</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]:</span>\n  <span class=\"n\">prod.measurable_space</span> <span class=\"bp\">=</span> <span class=\"n\">M1.comap</span> <span class=\"n\">prod.fst</span> <span class=\"bp\">⊔</span> <span class=\"n\">M2.comap</span> <span class=\"n\">prod.snd</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 242140213,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1623278501
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>  if I change the name of your def to <code>SC_measurable_comm_semiring</code>, then I get the error <code>SC_measurable_comm_semiring Ω nnreal term  nnreal.comm_semiring has type  comm_semiring nnrea but is expected to have type  measurable_space nnreal</code>. Could you help me fix that?</p>",
        "id": 242143152,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1623280936
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"397140\">@Hunter Monroe</span> What is the line that throws the error?</p>",
        "id": 242143400,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1623281173
    },
    {
        "content": "<p>In the instance, there is a red line under <code>SC_measurable_comm_semiring</code> with the error I gave, where I renamed your definition to <code>SC_measurable_comm_semiring</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">nnreal_measurable_fun_comm_semiring</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">M</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]:</span>\n  <span class=\"n\">comm_semiring</span> <span class=\"o\">(</span><span class=\"n\">measurable_fun</span> <span class=\"n\">M</span><span class=\"bp\">Ω</span> <span class=\"o\">(</span><span class=\"n\">nnreal.measurable_space</span><span class=\"o\">)):=</span>\n  <span class=\"bp\">@</span><span class=\"n\">SC_measurable_comm_semiring</span> <span class=\"bp\">Ω</span> <span class=\"n\">M</span><span class=\"bp\">Ω</span> <span class=\"n\">nnreal</span> <span class=\"n\">nnreal.topological_space</span>\n    <span class=\"n\">nnreal.topological_space.second_countable_topology</span> <span class=\"n\">nnreal.comm_semiring</span>\n    <span class=\"n\">nnreal.topological_semiring</span>\n</code></pre></div>",
        "id": 242143539,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1623281288
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"397140\">@Hunter Monroe</span> You ought not to need to define this explicitly as an instance!  I wrote it as an <code>example</code> to show that Lean can infer it where needed!</p>",
        "id": 242143705,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1623281437
    },
    {
        "content": "<p>What is the first place in the code where the <code>comm_semiring</code> instance is needed?  If you can give me that lemma, I can try to reframe the lemma so the <code>comm_semiring</code> instance is inferred automatically.</p>",
        "id": 242143755,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1623281498
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>Thanks for the tip. This is Martin Zinkevich's Formal-ML repository (over 33K lines of it), which I am trying to get to compile in the latest version of mathlib, as a way of learning Lean. Once the code compiles, I will address the @'s among other issues when refactoring for inclusion in mathlib.</p>",
        "id": 242144098,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1623281780
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> one example is below, where commenting out the instance generates a \"failed to synthesize instance\" error. The refl proof does not go through in any case (any ideas?). If you want to download the repository using the URL above, this is from the real_random_variable.lean file. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">infixr</span>  <span class=\"bp\">`</span> <span class=\"bp\">→ₘ</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">80</span> <span class=\"o\">:=</span> <span class=\"n\">measurable_fun</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">nnreal_measurable_fun_zero_val_def</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">M</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]:</span>  <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"bp\">Ω</span> <span class=\"bp\">→ₘ</span> <span class=\"o\">(</span><span class=\"n\">nnreal.measurable_space</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">refl</span>\n</code></pre></div>",
        "id": 242144942,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1623282561
    },
    {
        "content": "<p>At a glance, <code>measurable_fun</code> is designed with incorrect argument explicitness</p>",
        "id": 242145546,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623283119
    },
    {
        "content": "<p>I'd expect the two <code>Type</code>s in <code>()</code> not <code>{}</code>, and the two <code>measurable_space</code>s in <code>[]</code> not <code>()</code>.</p>",
        "id": 242145792,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623283307
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"397140\">@Hunter Monroe</span> The simp-lemma you provide doesn't use the commutativity, but here's how I'd do it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.borel_space</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">measurable_fun</span>\n  <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space.second_countable_topology</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">borel_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_semiring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">subsemiring</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"bp\">|</span> <span class=\"n\">measurable</span> <span class=\"n\">f</span><span class=\"o\">},</span>\n  <span class=\"n\">one_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">measurable_const</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">measurable.mul</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">measurable_const</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">measurable.add</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">infixr</span> <span class=\"bp\">`→ₘ</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">80</span> <span class=\"o\">:=</span> <span class=\"n\">measurable_fun</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">nnreal_measurable_fun_zero_val_def</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span> <span class=\"bp\">→ₘ</span> <span class=\"n\">nnreal</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- not needed for anything, but just to check</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">comm_semiring</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"bp\">→ₘ</span> <span class=\"n\">nnreal</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>",
        "id": 242147649,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1623285146
    },
    {
        "content": "<p>I should say that what I wrote above is slick for this use case, but it might cause problems down the line if you want <code>measurable_fun</code> to be a monoid when it maps into a monoid, a module when it maps into a module, etc etc.</p>\n<p>I think the standard way to get the full suite of algebraic objects (see <a href=\"https://leanprover-community.github.io/mathlib_docs/find/continuous_map.monoid\">docs#continuous_map.monoid</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bounded_continuous_function.normed_group\">docs#bounded_continuous_function.normed_group</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.ae_eq_fun.monoid\">docs#measure_theory.ae_eq_fun.monoid</a>) is to define <code>measurable_fun</code> to be the subtype and then equip it with successive algebraic structures by hand.  This is fairly close to what you did before but, when <a href=\"https://leanprover-community.github.io/mathlib_docs/find/borel_space\">docs#borel_space</a> and typeclass inference are used correctly, it doesn't throw errors.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.borel_space</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">measurable_fun</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">//</span> <span class=\"n\">measurable</span> <span class=\"n\">f</span><span class=\"o\">}</span>\n\n<span class=\"kd\">infixr</span> <span class=\"bp\">`→ₘ</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">80</span> <span class=\"o\">:=</span> <span class=\"n\">measurable_fun</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_measurable_add₂</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">add_monoid</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"bp\">→ₘ</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">f.1</span> <span class=\"bp\">+</span> <span class=\"n\">g.1</span><span class=\"o\">,</span> <span class=\"n\">f.2.add</span> <span class=\"n\">g.2</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">add_assoc</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">subtype.ext</span> <span class=\"bp\">$</span> <span class=\"n\">add_assoc</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">measurable_const</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">zero_add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">subtype.ext</span> <span class=\"bp\">$</span> <span class=\"n\">zero_add</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">add_zero</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">subtype.ext</span> <span class=\"bp\">$</span> <span class=\"n\">add_zero</span> <span class=\"n\">_</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_measurable_mul₂</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">monoid</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"bp\">→ₘ</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">f.1</span> <span class=\"bp\">*</span> <span class=\"n\">g.1</span><span class=\"o\">,</span> <span class=\"n\">f.2.mul</span> <span class=\"n\">g.2</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">mul_assoc</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">subtype.ext</span> <span class=\"bp\">$</span> <span class=\"n\">mul_assoc</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">one</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">measurable_const</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">one_mul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">subtype.ext</span> <span class=\"bp\">$</span> <span class=\"n\">one_mul</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_one</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">subtype.ext</span> <span class=\"bp\">$</span> <span class=\"n\">mul_one</span> <span class=\"n\">_</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space.second_countable_topology</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">borel_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_semiring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">semiring</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"bp\">→ₘ</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">add_comm</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">subtype.ext</span> <span class=\"bp\">$</span> <span class=\"n\">add_comm</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_mul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">subtype.ext</span> <span class=\"bp\">$</span> <span class=\"n\">zero_mul</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_zero</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">subtype.ext</span> <span class=\"bp\">$</span> <span class=\"n\">mul_zero</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">left_distrib</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">subtype.ext</span> <span class=\"bp\">$</span> <span class=\"n\">left_distrib</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">right_distrib</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">subtype.ext</span> <span class=\"bp\">$</span> <span class=\"n\">right_distrib</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span> <span class=\"n\">measurable_fun.add_monoid</span> <span class=\"bp\">Ω</span> <span class=\"n\">β</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span> <span class=\"n\">measurable_fun.monoid</span> <span class=\"bp\">Ω</span> <span class=\"n\">β</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space.second_countable_topology</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">borel_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_semiring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">comm_semiring</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"bp\">→ₘ</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mul_comm</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">subtype.ext</span> <span class=\"bp\">$</span> <span class=\"n\">mul_comm</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n  <span class=\"bp\">..</span> <span class=\"n\">measurable_fun.semiring</span> <span class=\"bp\">Ω</span> <span class=\"n\">β</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">nnreal_measurable_fun_zero_val_def</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span> <span class=\"bp\">→ₘ</span> <span class=\"n\">nnreal</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- not needed for anything, but just to check</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">comm_semiring</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"bp\">→ₘ</span> <span class=\"n\">nnreal</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>",
        "id": 242149444,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1623287176
    },
    {
        "content": "<p>I have an open PR against mathlib that does precisely that, <a href=\"https://github.com/leanprover-community/mathlib/issues/7833\">#7833</a></p>",
        "id": 242163933,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623306157
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> How would you suggest adapting the random variable definition to building on your suggestion:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.borel_space</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">measurable_fun</span>\n  <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space.second_countable_topology</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">borel_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_semiring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">subsemiring</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"bp\">|</span> <span class=\"n\">measurable</span> <span class=\"n\">f</span><span class=\"o\">},</span>\n  <span class=\"n\">one_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">measurable_const</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">measurable.mul</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">measurable_const</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">measurable.add</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">infixr</span> <span class=\"bp\">`→ₘ</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">80</span> <span class=\"o\">:=</span> <span class=\"n\">measurable_fun</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">nnreal_measurable_fun_zero_val_def</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span> <span class=\"bp\">→ₘ</span> <span class=\"n\">nnreal</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">random_variable'</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">):</span><span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"n\">measurable_fun</span> <span class=\"bp\">Ω</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">infixr</span>  <span class=\"bp\">`</span> <span class=\"bp\">→ᵣ'</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">80</span> <span class=\"o\">:=</span> <span class=\"n\">random_variable'</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">nnreal_random_variable_add_val_def</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span><span class=\"bp\">Ω</span> <span class=\"bp\">→ᵣ'</span> <span class=\"o\">(</span><span class=\"n\">nnreal</span><span class=\"o\">)}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a.val</span> <span class=\"bp\">+</span> <span class=\"n\">b.val</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 242420653,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1623462497
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"397140\">@Hunter Monroe</span> I don't know much about probability, sorry.</p>\n<p>By the way, it looks like you are defining the semiring structure using the <a href=\"#narrow/stream/113489-new-members/topic/Probability.20theory/near/242147649\">quick-and-dirty</a> method I proposed at first, but since <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> has an open PR for a more comprehensive construction, it would be better to merge that in and base your work on that ....</p>",
        "id": 242420786,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1623462742
    },
    {
        "content": "<p>I guess my first thought would be not to use <code>random_variable</code> at all -- just to refer throughout to <code>measurable_fun</code>, or perhaps to make <code>random_variable</code> an <code>abbreviation</code> for <code>measurable_fun</code>.  But maybe a probabilist could draw a distinction here that I'm not seeing.</p>",
        "id": 242421185,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1623463533
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/113489-new-members/topic/Probability.20theory/near/242421185\">said</a>:</p>\n<blockquote>\n<p>I guess my first thought would be not to use <code>random_variable</code> at all -- just to refer throughout to <code>measurable_fun</code></p>\n</blockquote>\n<p>This seems to be how it's done in, eg, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/probability_theory.lintegral_mul_eq_lintegral_mul_lintegral_of_indep_fun\">docs#probability_theory.lintegral_mul_eq_lintegral_mul_lintegral_of_indep_fun</a></p>",
        "id": 242421419,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1623463923
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> good point on random variables. Another question: how should I conjure up a <code>topological_semiring ennreal</code> as required for the def at the end using your method or Eric's new method?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.borel_space</span>\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"kd\">def</span> <span class=\"n\">measurable_fun</span>\n  <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space.second_countable_topology</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">borel_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_semiring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">subsemiring</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"bp\">|</span> <span class=\"n\">measurable</span> <span class=\"n\">f</span><span class=\"o\">},</span>\n  <span class=\"n\">one_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">measurable_const</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">measurable.mul</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">measurable_const</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">measurable.add</span> <span class=\"o\">}</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">nnreal_to_ennreal_measurable_fun</span><span class=\"o\">:</span><span class=\"n\">measurable_fun</span> <span class=\"o\">(</span> <span class=\"n\">nnreal</span><span class=\"o\">)</span> <span class=\"o\">(</span> <span class=\"n\">ennreal</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">nnreal</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ennreal</span><span class=\"o\">)),</span>\n  <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"n\">nnreal_to_ennreal_measurable</span><span class=\"o\">,}</span>\n</code></pre></div>",
        "id": 242460336,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1623516486
    },
    {
        "content": "<p>Actually, I didn't see a <code>topological_space</code> instance for <code>ennreal</code> in mathlib.  (Maybe I'm not looking in the right place.). Does anyone know for sure?</p>",
        "id": 242460715,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1623516872
    },
    {
        "content": "<p>There is definitely an instance</p>",
        "id": 242460755,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623516947
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/ennreal.topological_space\">docs#ennreal.topological_space</a></p>",
        "id": 242460800,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1623516969
    },
    {
        "content": "<p>Then maybe what's missing, if it's true, is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.algebra.ring</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.algebra.ordered.basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">canonically_ordered_comm_semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">order_topology</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">topological_semiring</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 242461035,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1623517361
    },
    {
        "content": "<p>are you sure that ennreal is a <code>topological_semiring</code>? I am worried about continuity of the multiplication. What do you need that instance for?</p>",
        "id": 242461246,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1623517681
    },
    {
        "content": "<p>can confirm it's not a topological semiring because multiplication is not continuous at (0, infty)</p>",
        "id": 242461452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623517996
    },
    {
        "content": "<p>The multiplication is not continuous, but there is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ennreal.has_measurable_mul₂\">docs#ennreal.has_measurable_mul₂</a> and similar for add etc. All needed properties for the subsemiring definition should be there. Just don't look for continuity, but directly use measurability.</p>",
        "id": 242461900,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1623518650
    },
    {
        "content": "<p>In the original formal-ml repository, commenting out the instance below creates an error in proof of a lemma E[X*Y]=E[X}E[Y} for X, Y independent, nnreal-valued random variables, so the instance is likely not essential for the proof. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">ennreal_random_variable_comm_semiring</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>  <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">probability_space</span> <span class=\"bp\">Ω</span><span class=\"o\">}:</span>  <span class=\"n\">comm_semiring</span> <span class=\"o\">(</span><span class=\"n\">random_variable</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">borel</span> <span class=\"n\">ennreal</span><span class=\"o\">)):=</span>  <span class=\"n\">ennreal_measurable_fun_comm_semiring</span>\n</code></pre></div>",
        "id": 242461988,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1623518863
    },
    {
        "content": "<p>I need a strategic decision on whether I should continue trying to get formal-ml to compile with current mathlib--which would likely require someone much more experienced with Lean to help me for an hour or so with compile errors prioritizing the files independent_events.lean, real_random_variable, measure, finite_pi_measure, prod_measure, random_variable_identical, and radon_nikodym/dependencies. I could then continue the spadework to modify formal-ml to include key parts in mathlib: definitions of random variable, the expectation operator, and the Radon-Nikodym theorem (the jewel in the crown). This would include factoring out extra definitions for measurablesetB, measurable functions, and any lemmas already in mathlib that I have missed, while using more standard notation. Alternatively, I could create a less ambitious submission of key probability concepts, cribbing from formal-ml without getting formal-ml to compile. The repository I am working in is <a href=\"https://github.com/hmonroe/formal-ml\">https://github.com/hmonroe/formal-ml</a>.</p>",
        "id": 242462720,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1623520045
    },
    {
        "content": "<p>I thought you got formal-ml to compile already?</p>",
        "id": 242462871,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623520312
    },
    {
        "content": "<p>I am not following what you are doing with formal-ml closely, but it looks like you would benefit from writing your own code in order to gain familiarity with mathlib, rather than adapting another code which uses quite different conventions. If I were you, I would pick one goal and build towards it from mathlib, not from formal-ml. Although following the general steps of formal-ml would of course help.</p>\n<p>The radon-nikodym theorem looks like a fun goal, and it can be written within measure theory: no need for all those events and random variable definitions. Writing theorems is more fun than coming up with definitions.</p>",
        "id": 242463051,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1623520535
    },
    {
        "content": "<p>Part of the thing that makes formal-ml awkward is that it contains lots of definitions that are almost-but-not-quite the same as the mathlib ones</p>",
        "id": 242463186,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623520689
    },
    {
        "content": "<p>Whilst I don't know anything about how probability theory is set up in either mathlib or formal-ml, I have got a lot of experience with getting lean-beginners to the stage where they can write mathlib-ready code, and I think that an effective way to learn Lean is to do small projects yourself from scratch rather than trying to understand 600 lines of rotting code. I agree with Remy that proving theorems is more fun than making definitions -- making definitions is extremely difficult. To give a pretty solid proof of this, take a look at mathlib's definition of a group, which is nothing like what a beginner would write, it is far far more complicated, for reasons which would be difficult for a beginner to understand. I would recommend short projects which could become mathlib PRs, because the PR process is an effective way of learning.</p>",
        "id": 242463445,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1623521015
    },
    {
        "content": "<p>OK, I have made a pull request for the first 800 or so lines of probability_space also defining events and probability. I switched to standard set notation (union/intersection/complement) for events. <a href=\"https://github.com/leanprover-community/mathlib/pull/7913#partial-pull-merging\">https://github.com/leanprover-community/mathlib/pull/7913#partial-pull-merging</a>.</p>",
        "id": 242483251,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1623548587
    },
    {
        "content": "<p>What is the purpose of making <code>probability_measure</code> a class as opposed to for instance a subtype?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">probability_measure</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">measure_univ</span> <span class=\"o\">:</span> <span class=\"n\">μ</span> <span class=\"n\">univ</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 242669320,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1623711604
    },
    {
        "content": "<p>Do you mean, a structure rather than a subtype?</p>",
        "id": 242669710,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1623711853
    },
    {
        "content": "<p>Or do you mean, defining it as a <code>Prop</code> rather than as a <code>measure</code> plus a <code>Prop</code>?</p>",
        "id": 242670240,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1623712231
    },
    {
        "content": "<p>Broadly, what are the choices and the design considerations? This would help understand how to build on top of it.</p>",
        "id": 242671403,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1623713163
    },
    {
        "content": "<p>Have you tried making your suggested variation on a clean copy of mathlib, and compiling it to see what breaks?</p>",
        "id": 242671719,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1623713472
    },
    {
        "content": "<p>Let's say you defined \"is_probability_measure mu : Prop := mu univ = 1\". Then, you'd likely prove all sorts of things about such measures, having to constantly pass (h : is_probability_measure mu) around. And make definitions that require the hypothesis also. In those lemmas and definitions, you might or might not refer to h. Typeclasses allow you require that hypothesis too, but to also infer them form the context. Often, you won't care exactly about h, but lemmas derived from it. And typeclasses will make it much easier to defer to those. The same way that add_le_add doesn't require you to pass a proof of the order.</p>",
        "id": 242673028,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1623714660
    },
    {
        "content": "<p>The definition of <code>ite</code> has changed so as to break this lemma statement, with error <code>type mismatch at application ite (classical.prop_decidable (s = ∅)) term classical.prop_decidable (s = ∅) has type decidable (s = ∅) but is expected to have type Prop</code>. Can someone suggest a fix?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.measurable_space</span>\n<span class=\"kn\">import</span> <span class=\"n\">measure_theory.measure_space</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">measure_theory.outer_measure.top_eq</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">M</span><span class=\"o\">:</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]:</span>\n  <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"bp\">⊤</span><span class=\"o\">:</span><span class=\"n\">measure_theory.outer_measure</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">set</span> <span class=\"bp\">Ω</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">=∅</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">classical.prop_decidable</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">=∅</span><span class=\"o\">))</span> <span class=\"n\">ennreal</span> <span class=\"mi\">0</span> <span class=\"bp\">⊤</span><span class=\"o\">))</span> <span class=\"o\">:=</span>  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 242908207,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1623861872
    },
    {
        "content": "<p>The right order of the arguments seems to be different:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">measure_theory.outer_measure.top_eq</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">M</span><span class=\"o\">:</span><span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]:</span>\n  <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"bp\">⊤</span><span class=\"o\">:</span><span class=\"n\">measure_theory.outer_measure</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">set</span> <span class=\"bp\">Ω</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ite</span> <span class=\"n\">ennreal</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">=∅</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">classical.prop_decidable</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">=∅</span><span class=\"o\">))</span> <span class=\"mi\">0</span> <span class=\"bp\">⊤</span><span class=\"o\">))</span> <span class=\"o\">:=</span>  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 242909345,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1623862380
    },
    {
        "content": "<p>You shouldn't be using <code>@</code> there in the first place</p>",
        "id": 242909691,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623862532
    },
    {
        "content": "<p>Adding <code>[decidable_pred (λ s : set Ω, s = ∅)]</code> as an argument removes the need for the <code>@</code> and results in a slightly more general lemma</p>",
        "id": 242910099,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623862727
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> sorry but how do I get rid of the @? I could not find a variation that worked.</p>\n<p>lemma measure_theory.outer_measure.top_eq {Ω:Type*} [M:measurable_space Ω] [decidable_pred (λ s : set Ω, s = ∅)]:<br>\n  ⇑(⊤:measure_theory.outer_measure Ω) = ( λ s, (@ite ennreal (s=∅) (classical.prop_decidable (s=∅)) 0 ⊤)) :=  sorry</p>",
        "id": 242915242,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1623864922
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">measure_theory.outer_measure.top_eq</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">Ω</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">measure_theory.outer_measure</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>you have to give a hint about the type of either 0 or top in the ite</p>",
        "id": 242915791,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1623865185
    },
    {
        "content": "<p>by the way, the standard notation for <code>⊤</code> in ennreal (<code>ℝ≥0∞</code>) is <code>∞</code></p>",
        "id": 242916040,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1623865289
    },
    {
        "content": "<p>The Lebesgue Radon Nikodym Theorem, as extracted from formal-ml, now compiles under the current version of mathlib!!! I have a lot of work to clean it up before submitting to mathlib.</p>",
        "id": 242918115,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1623866278
    },
    {
        "content": "<p>The proof below works for nnreal, but I not for ennreal, where my proof required three cases statements. Am I missing something, and more generally is there a generic way to move nnreal results to ennreal where correct?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.nnreal</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">nnreal</span><span class=\"o\">}:</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">add_le_add_left</span>\n</code></pre></div>",
        "id": 243431823,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1624304127
    },
    {
        "content": "<p>I opened it in the online lean editor and it works fine for ennreal.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.ennreal</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ennreal</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">add_le_add_left</span>\n</code></pre></div>\n<p>Is your local mathlib up to date?</p>",
        "id": 243432473,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1624304448
    },
    {
        "content": "<p>How can I apply <code>div_le_div_right</code> here? The error message is not clear: <code>type mismatch at application div_le_div_right h₅ term  h₅ has type  0 &lt; ↑(q.denom) but is expected to have type 0 &lt; ?m_3</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.rat</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">rat.exists_unit_frac_le_pos</span> <span class=\"o\">{</span><span class=\"n\">q</span><span class=\"o\">:</span><span class=\"n\">ℚ</span><span class=\"o\">}:</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"o\">((</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">rat</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">≤</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"k\">have</span> <span class=\"n\">h₄</span> <span class=\"o\">:</span> <span class=\"n\">q.denom</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">q.pos</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">h₅</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">q.denom</span><span class=\"o\">))</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">nat.cast_pos.mpr</span> <span class=\"n\">h₄</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">h₇</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">q.denom</span><span class=\"o\">))</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">q.num</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">q.denom</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">div_le_div_right</span> <span class=\"n\">h₅</span>  <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">q.denom</span><span class=\"o\">)),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 243465792,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1624328596
    },
    {
        "content": "<p>Do you know about <code>norm_cast</code>, etc?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.rat</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">rat.exists_unit_frac_le_pos</span> <span class=\"o\">{</span><span class=\"n\">q</span><span class=\"o\">:</span><span class=\"n\">ℚ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"o\">((</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">≤</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₅</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">q.denom</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact_mod_cast</span> <span class=\"n\">q.pos</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₇</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"n\">q.denom</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">q.num</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"n\">q.denom</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">div_le_div_right</span> <span class=\"n\">h₅</span><span class=\"o\">,</span>\n    <span class=\"n\">exact_mod_cast</span> <span class=\"n\">rat.num_pos_iff_pos.mpr</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 243466848,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1624329899
    },
    {
        "content": "<p>I didn't check out your version in a full-featured editor, but my guess is that you should have provided explicit casts to <code>ℚ</code> in place of some of the <code>↑</code>.</p>",
        "id": 243467127,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1624330208
    },
    {
        "content": "<p>Also, have you seen that the fact you want is a lemma in mathlib? <a href=\"https://leanprover-community.github.io/mathlib_docs/find/exists_nat_one_div_lt\">docs#exists_nat_one_div_lt</a></p>",
        "id": 243467281,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1624330449
    },
    {
        "content": "<p>Cool thanks.</p>",
        "id": 243470462,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1624334977
    },
    {
        "content": "<p>How can I prove the equivalence below (nnreal replaced with real). I tried <code>norm_cast</code> and <code>real.to_nnreal_mono</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.nnreal</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">ε</span><span class=\"o\">:</span><span class=\"n\">nnreal</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n'</span><span class=\"o\">:</span><span class=\"n\">ℕ</span> <span class=\"o\">}:</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">((</span><span class=\"n\">n'</span><span class=\"o\">:</span><span class=\"n\">real</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">ε</span><span class=\"o\">:</span><span class=\"n\">real</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">((</span><span class=\"n\">n'</span><span class=\"o\">:</span><span class=\"n\">nnreal</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span><span class=\"o\">):=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>As background, I am trying to prove versions of the following but for nnreal and ennreal, and more generally transfer over results about reals.. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">real.exists_unit_frac_lt_pos</span> <span class=\"o\">{</span><span class=\"n\">ε</span><span class=\"o\">:</span><span class=\"n\">real</span><span class=\"o\">}:</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"o\">((</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">real</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">exists_nat_one_div_lt</span>\n</code></pre></div>",
        "id": 243552168,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1624383496
    },
    {
        "content": "<p>This works, through the magic of <code>simp</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.nnreal</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">ε</span><span class=\"o\">:</span><span class=\"n\">nnreal</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n'</span><span class=\"o\">:</span><span class=\"n\">ℕ</span> <span class=\"o\">}:</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">((</span><span class=\"n\">n'</span><span class=\"o\">:</span><span class=\"n\">real</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">ε</span><span class=\"o\">:</span><span class=\"n\">real</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">((</span><span class=\"n\">n'</span><span class=\"o\">:</span><span class=\"n\">nnreal</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span><span class=\"o\">):=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">nnreal.coe_lt_coe</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"bp\">;</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"n\">convert</span> <span class=\"n\">H</span> <span class=\"n\">using</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">},</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 243558025,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1624386008
    },
    {
        "content": "<p>I'll just post also here a link to an exercise I did on weak convergence of probability measures and Portmanteau's theorem: <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members/topic/Portmanteau.20theorem\">#new members &gt; Portmanteau theorem</a>.</p>",
        "id": 244370873,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1625019740
    },
    {
        "content": "<p>I would like the statement of the existing theorem below to be <code>E[f*g]=E[f]*E[g]</code> but I am getting the error <code>don't know how to synthesize placeholder</code>. See a mwe below. Note this works in <a href=\"https://github.com/google/formal-ml/blob/630011d19fdd9539c8d6493a69fe70af5d193590/src/formal_ml/real_random_variable.lean#L795\">formal-ml</a> but is such an elaborate approach needed?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.integration</span>\n<span class=\"kn\">import</span> <span class=\"n\">probability_theory.independence</span>\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">ennreal</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">probability_theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">expected_value</span> <span class=\"o\">[</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span>\n   <span class=\"o\">:=</span> <span class=\"bp\">∫⁻</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">X</span> <span class=\"n\">a</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span>\n<span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">E</span><span class=\"o\">[</span><span class=\"bp\">`</span> <span class=\"n\">X</span> <span class=\"bp\">`</span><span class=\"o\">]</span><span class=\"bp\">`</span><span class=\"o\">:=</span> <span class=\"n\">expected_value</span> <span class=\"n\">X</span>\n\n<span class=\"sd\">/-- This (roughly) proves that if `f` and `g` are independent random variables,</span>\n<span class=\"sd\">   then `E[f * g] = E[f] * E[g]`.-/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">lintegral_mul_eq_lintegral_mul_lintegral_of_independent_measurable_space</span>\n  <span class=\"o\">{</span><span class=\"n\">Mf</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Mg</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hMf</span> <span class=\"o\">:</span> <span class=\"n\">Mf</span> <span class=\"bp\">≤</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hMg</span> <span class=\"o\">:</span> <span class=\"n\">Mg</span> <span class=\"bp\">≤</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_ind</span> <span class=\"o\">:</span> <span class=\"n\">indep</span> <span class=\"n\">Mf</span> <span class=\"n\">Mg</span> <span class=\"n\">μ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_meas_f</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">measurable</span> <span class=\"n\">α</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span> <span class=\"n\">Mf</span> <span class=\"n\">_</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_meas_g</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">measurable</span> <span class=\"n\">α</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span> <span class=\"n\">Mg</span> <span class=\"n\">_</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∫⁻</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"n\">a</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span> <span class=\"bp\">=</span> <span class=\"bp\">∫⁻</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span> <span class=\"bp\">*</span> <span class=\"bp\">∫⁻</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">a</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span> <span class=\"o\">:=</span><span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">probability_theory</span>\n</code></pre></div>",
        "id": 245611413,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1626015882
    },
    {
        "content": "<p>Your problem is that lean can't work out <code>μ</code> from the notation</p>",
        "id": 245611596,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626016094
    },
    {
        "content": "<p>One way to resolve this would be to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_space\">docs#measure_space</a> instead of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measurable_space\">docs#measurable_space</a>, and the canonical <code>volume</code> measure in place of <code>μ</code></p>",
        "id": 245611695,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626016211
    },
    {
        "content": "<p>I tried that below, replacing <code>μ</code> with <code>Mf.volume</code> and <code>Mg.volume</code>, creating new definitions for <code>measurable</code> and <code>indep</code> based on <code>measure_space</code> not <code>measurable_space</code>, and now have multiple type class instance errors. Presumably I would need to rewrite the statements and proofs in integration.lean as well. Even simple changes seem to blow up in this area.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.integration</span>\n<span class=\"kn\">import</span> <span class=\"n\">probability_theory.independence</span>\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">ennreal</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">probability_theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">expected_value</span> <span class=\"o\">[</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span>\n   <span class=\"o\">:=</span> <span class=\"bp\">∫⁻</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">X</span> <span class=\"n\">a</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span>\n<span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">E</span><span class=\"o\">[</span><span class=\"bp\">`</span> <span class=\"n\">X</span> <span class=\"bp\">`</span><span class=\"o\">]</span><span class=\"bp\">`</span><span class=\"o\">:=</span> <span class=\"n\">expected_value</span> <span class=\"n\">X</span>\n<span class=\"kd\">def</span> <span class=\"n\">indep'</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">m₁</span> <span class=\"n\">m₂</span> <span class=\"o\">:</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">measure_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span> <span class=\"bp\">.</span> <span class=\"n\">volume_tac</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">indep_sets</span> <span class=\"o\">(</span><span class=\"n\">m₁.measurable_set'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m₂.measurable_set'</span><span class=\"o\">)</span> <span class=\"n\">μ</span>\n<span class=\"kd\">def</span> <span class=\"n\">measurable'</span> <span class=\"o\">[</span><span class=\"n\">measure_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measure_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">⦄,</span> <span class=\"n\">measurable_set</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">measurable_set</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n<span class=\"sd\">/-- This (roughly) proves that if `f` and `g` are independent random variables,</span>\n<span class=\"sd\">   then `E[f * g] = E[f] * E[g]`.-/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">lintegral_mul_eq_lintegral_mul_lintegral_of_independent_measurable_space</span>\n  <span class=\"o\">{</span><span class=\"n\">Mf</span> <span class=\"o\">:</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Mg</span> <span class=\"o\">:</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n   <span class=\"o\">(</span><span class=\"n\">hMf</span> <span class=\"o\">:</span> <span class=\"n\">Mf</span> <span class=\"bp\">≤</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hMg</span> <span class=\"o\">:</span> <span class=\"n\">Mg</span> <span class=\"bp\">≤</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_ind</span> <span class=\"o\">:</span> <span class=\"n\">indep'</span> <span class=\"n\">Mf</span> <span class=\"n\">Mg</span> <span class=\"n\">μ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_meas_f</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">measurable'</span> <span class=\"n\">α</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span> <span class=\"n\">Mf</span> <span class=\"n\">_</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_meas_g</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">measurable'</span> <span class=\"n\">α</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span> <span class=\"n\">Mg</span> <span class=\"n\">_</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∫⁻</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"n\">a</span> <span class=\"bp\">∂</span><span class=\"o\">(</span><span class=\"n\">Mf.volume</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">∫⁻</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">∂</span><span class=\"o\">(</span><span class=\"n\">Mf.volume</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"bp\">∫⁻</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">a</span> <span class=\"bp\">∂</span><span class=\"o\">(</span><span class=\"n\">Mf.volume</span><span class=\"o\">)</span> <span class=\"o\">:=</span><span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span> <span class=\"n\">probability_theory</span>\n</code></pre></div>",
        "id": 245612662,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1626017708
    },
    {
        "content": "<p>Wait, I think I don't understand what you meant by</p>\n<blockquote>\n<p>I would like the statement of the existing theorem below to be <code>E[f*g]=E[f]*E[g] </code></p>\n</blockquote>\n<p>Can you provide the things you tried that didn't work?</p>",
        "id": 245612726,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626017805
    },
    {
        "content": "<p>Or are you saying you want the statement you posted to be shown using that notation, but you don't actually want to restate it?</p>",
        "id": 245612732,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626017821
    },
    {
        "content": "<p>The broader goal is to introduce the expected value operator E[...], while the narrow goal is to rewrite that lemma to read: <code>lemma lintegral_mul_eq_lintegral_mul_lintegral_of_independent_measurable_space... : E[f*g]=E[f]*E[g] :=...</code></p>",
        "id": 245612965,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1626018234
    },
    {
        "content": "<p>The first thing that did not work was my mwe above, but with <code>E[f*g]=E[f]*E[g]</code> as the thing to be proved. That is, replacing <code>∫⁻ a, f a ∂μ</code> with <code>E[f]</code>.</p>",
        "id": 245613101,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1626018440
    },
    {
        "content": "<p>In that case, please include in your <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> both the version that does work <em>and</em> the version that doesn't work!</p>",
        "id": 245613156,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626018499
    },
    {
        "content": "<p>Don't make us try to guess what the non-working version was.</p>",
        "id": 245613170,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626018526
    },
    {
        "content": "<p>Here is the nonworking mwe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.integration</span>\n<span class=\"kn\">import</span> <span class=\"n\">probability_theory.independence</span>\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">ennreal</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">probability_theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">expected_value</span> <span class=\"o\">[</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span>\n   <span class=\"o\">:=</span> <span class=\"bp\">∫⁻</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">X</span> <span class=\"n\">a</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span>\n<span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">E</span><span class=\"o\">[</span><span class=\"bp\">`</span> <span class=\"n\">X</span> <span class=\"bp\">`</span><span class=\"o\">]</span><span class=\"bp\">`</span><span class=\"o\">:=</span> <span class=\"n\">expected_value</span> <span class=\"n\">X</span>\n\n<span class=\"sd\">/-- This (roughly) proves that if `f` and `g` are independent random variables,</span>\n<span class=\"sd\">   then `E[f * g] = E[f] * E[g]`.-/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">lintegral_mul_eq_lintegral_mul_lintegral_of_independent_measurable_space</span>\n  <span class=\"o\">{</span><span class=\"n\">Mf</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Mg</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hMf</span> <span class=\"o\">:</span> <span class=\"n\">Mf</span> <span class=\"bp\">≤</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hMg</span> <span class=\"o\">:</span> <span class=\"n\">Mg</span> <span class=\"bp\">≤</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_ind</span> <span class=\"o\">:</span> <span class=\"n\">indep</span> <span class=\"n\">Mf</span> <span class=\"n\">Mg</span> <span class=\"n\">μ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_meas_f</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">measurable</span> <span class=\"n\">α</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span> <span class=\"n\">Mf</span> <span class=\"n\">_</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_meas_g</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">measurable</span> <span class=\"n\">α</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span> <span class=\"n\">Mg</span> <span class=\"n\">_</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">E</span><span class=\"o\">[</span><span class=\"n\">f</span><span class=\"bp\">*</span><span class=\"n\">g</span><span class=\"o\">]</span><span class=\"bp\">=</span><span class=\"n\">E</span><span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">]</span><span class=\"bp\">*</span><span class=\"n\">E</span><span class=\"o\">[</span><span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:=</span><span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">probability_theory</span>\n</code></pre></div>",
        "id": 245613296,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1626018734
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.integration</span>\n<span class=\"kn\">import</span> <span class=\"n\">probability_theory.independence</span>\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">ennreal</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">probability_theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">expected_value</span> <span class=\"o\">[</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∫⁻</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">X</span> <span class=\"n\">a</span> <span class=\"bp\">∂</span><span class=\"o\">(</span><span class=\"n\">volume</span><span class=\"o\">)</span>\n<span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">E</span><span class=\"o\">[</span><span class=\"bp\">`</span> <span class=\"n\">X</span> <span class=\"bp\">`</span><span class=\"o\">]</span><span class=\"bp\">`</span><span class=\"o\">:=</span> <span class=\"n\">expected_value</span> <span class=\"n\">X</span>\n\n<span class=\"sd\">/-- This (roughly) proves that if `f` and `g` are independent random variables,</span>\n<span class=\"sd\">   then `E[f * g] = E[f] * E[g]`.-/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">lintegral_mul_eq_lintegral_mul_lintegral_of_independent_measurable_space</span>\n  <span class=\"o\">{</span><span class=\"n\">Mf</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Mg</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hMf</span> <span class=\"o\">:</span> <span class=\"n\">Mf</span> <span class=\"bp\">≤</span> <span class=\"n\">measure_space.to_measurable_space</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hMg</span> <span class=\"o\">:</span> <span class=\"n\">Mg</span> <span class=\"bp\">≤</span> <span class=\"n\">measure_space.to_measurable_space</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_ind</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">indep</span> <span class=\"n\">_</span> <span class=\"n\">Mf</span> <span class=\"n\">Mg</span> <span class=\"n\">measure_space.to_measurable_space</span> <span class=\"o\">(</span><span class=\"n\">volume</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_meas_f</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">measurable</span> <span class=\"n\">α</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span> <span class=\"n\">Mf</span> <span class=\"n\">_</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_meas_g</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">measurable</span> <span class=\"n\">α</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span> <span class=\"n\">Mg</span> <span class=\"n\">_</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">E</span><span class=\"o\">[</span><span class=\"n\">f</span><span class=\"bp\">*</span><span class=\"n\">g</span><span class=\"o\">]</span><span class=\"bp\">=</span><span class=\"n\">E</span><span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">]</span><span class=\"bp\">*</span><span class=\"n\">E</span><span class=\"o\">[</span><span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:=</span><span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">probability_theory</span>\n</code></pre></div>",
        "id": 245613997,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626019717
    },
    {
        "content": "<p>I think either you're working with this API in the wrong way, or this API isn't well thought out - the problem with this lemma is that <code>measurable_space</code> is a typeclass, but this lemma is talking about three different instances of the same typeclass, meaning you needs <code>@</code>s everywhere to be clear which one of the three you care about</p>",
        "id": 245614036,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626019789
    },
    {
        "content": "<p>Fantastic. My aim is to rewrite integration.lean so the conclusions have the form <code>E[f*g]=E[f]*E[g]</code> and can serve as a building block for probability theory. Are you suggesting that the lemma should be stated differently? The next lemma matters more, but uses this lemma: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- This proves that if `f` and `g` are independent random variables, then `E[f * g] = E[f] * E[g]`. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">lintegral_mul_eq_lintegral_mul_lintegral_of_indep_fun</span> <span class=\"o\">[</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_meas_f</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_meas_g</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_indep_fun</span> <span class=\"o\">:</span> <span class=\"n\">indep_fun</span> <span class=\"o\">(</span><span class=\"n\">borel</span> <span class=\"n\">ennreal</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">borel</span> <span class=\"n\">ennreal</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∫⁻</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span> <span class=\"bp\">=</span> <span class=\"bp\">∫⁻</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span> <span class=\"bp\">*</span> <span class=\"bp\">∫⁻</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">g</span> <span class=\"n\">a</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span>\n</code></pre></div>",
        "id": 245615524,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1626021982
    },
    {
        "content": "<p>Eric is simply saying that <code>measurable_space</code> has been designed with the idea in mind that any type should have at most one measurable space structure, and in your lemma you're putting two measurable space structures on alpha. Typeclasses are not designed to do this.</p>",
        "id": 245615749,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626022367
    },
    {
        "content": "<p>Ok thanks (it is not my lemma but the one in mathlib that needs tuning up).</p>",
        "id": 245616495,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1626023327
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"397140\">Hunter Monroe</span> <a href=\"#narrow/stream/113489-new-members/topic/Probability.20theory/near/245615524\">said</a>:</p>\n<blockquote>\n<p>My aim is to rewrite integration.lean so the conclusions have the form <code>E[f*g]=E[f]*E[g]</code> and can serve as a building block for probability theory.</p>\n</blockquote>\n<p>What do you mean? We certainly don't want the integration files to be polluted with probabilistic notation. Do you mean you want to duplicate <code>integration.lean</code> in some new file with different notations?</p>",
        "id": 245616662,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1626023484
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, I get the feeling that the lemma statement using the original notation is part of mathlib, and that there are lots of places in the measure theory library where two different measurable_space instances are put on the same type.</p>",
        "id": 245617731,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626024618
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> the whole point of the file integration.lean under probability_theory according to the doc strings is to show that for independent random variables <code>E[f*g]=E[f]*E[g]</code>, but then the theorems themselves did not use that notation.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113489-new-members/topic/Probability.20theory/near/245616662\">said</a>:</p>\n<blockquote>\n<p>What do you mean? We certainly don't want the integration files to be polluted with probabilistic notation. Do you mean you want to duplicate <code>integration.lean</code> in some new file with different notations?</p>\n</blockquote>",
        "id": 245643208,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1626063368
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"397140\">@Hunter Monroe</span> I just saw this thread and I see that you are working on porting formal-ml to mathlib. I just wanted to say that I have Radon-Nikodym proved through the signed measure rout here: <a href=\"https://github.com/JasonKYi/probability_theory/blob/main/src/singular.lean#L479\">https://github.com/JasonKYi/probability_theory/blob/main/src/singular.lean#L479</a></p>",
        "id": 245818022,
        "sender_full_name": "Jason KY.",
        "timestamp": 1626180056
    },
    {
        "content": "<p>Radon-Nikodym even works for sigma-finite measures, as you know probably, but the hard part is the part for finite measures that you have done. Very nice! Even more motivation for me to review <a href=\"https://github.com/leanprover-community/mathlib/issues/8247\">#8247</a> :-)</p>",
        "id": 245818632,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1626180350
    },
    {
        "content": "<p>I do plan to work on generalizing to sigma-finiteness later this week :)</p>",
        "id": 245818799,
        "sender_full_name": "Jason KY.",
        "timestamp": 1626180418
    },
    {
        "content": "<p>Awesome. Review done (well, I stopped after a few lines, because there is something I don't understand :-)</p>",
        "id": 245819917,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1626180933
    },
    {
        "content": "<p>I've now removed the extra <code>R</code>. Certainly a surprise that a vector measures doesn't require a vector space!</p>",
        "id": 245822907,
        "sender_full_name": "Jason KY.",
        "timestamp": 1626182259
    },
    {
        "content": "<p>That is great. The Hahn decomposition theorem is already in measure_theory/decomposition--you may be introducing a duplicate version in your hahn.lean file. Note that formal-ml was not well integrated with mathlib with duplicates of many results, including its own proof of the Hahn decomposition theorem. I am no longer trying to bring formal-ml up to date with the latest mathlib, but am still working on key probability theorems, in some cases comparing against formal-ml.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"243312\">Jason KY.</span> <a href=\"#narrow/stream/113489-new-members/topic/Probability.20theory/near/245818022\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"397140\">Hunter Monroe</span> I just saw this thread and I see that you are working on porting formal-ml to mathlib. I just wanted to say that I have Radon-Nikodym proved through the signed measure rout here: <a href=\"https://github.com/JasonKYi/probability_theory/blob/main/src/singular.lean#L479\">https://github.com/JasonKYi/probability_theory/blob/main/src/singular.lean#L479</a></p>\n</blockquote>",
        "id": 245832068,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1626186239
    },
    {
        "content": "<p>My immediate priority is Borel-Cantelli (other direction) and basic expectation/variance results.</p>",
        "id": 245832478,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1626186375
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"397140\">Hunter Monroe</span> <a href=\"#narrow/stream/113489-new-members/topic/Probability.20theory/near/245832068\">said</a>:</p>\n<blockquote>\n<p>The Hahn decomposition theorem is already in measure_theory/decomposition--you may be introducing a duplicate version in your hahn.lean file. </p>\n</blockquote>\n<p>The one in mathlib right now is the non-signed version while the one in mine repo is the signed version :)</p>",
        "id": 245833642,
        "sender_full_name": "Jason KY.",
        "timestamp": 1626186871
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 245837104,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1626188258
    },
    {
        "content": "<p>Good point, so you will do another PR with Radon-Nikodym and Hahn?</p>",
        "id": 245837737,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1626188449
    },
    {
        "content": "<p>Right, I will need the signed version of Hahn for Radon-Nikodym</p>",
        "id": 245838637,
        "sender_full_name": "Jason KY.",
        "timestamp": 1626188683
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243312\">@Jason KY.</span> have you done a PR for Radon-Nikodym?</p>",
        "id": 249661618,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1629156660
    },
    {
        "content": "<p>Radon-Nikodym should come right after <a href=\"https://github.com/leanprover-community/mathlib/pull/8687\">#8687</a> <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 249662794,
        "sender_full_name": "Jason KY.",
        "timestamp": 1629157724
    },
    {
        "content": "<p>Hi everyone!</p>\n<p>I am a new member of Lean community. </p>\n<p>For now I try to proof \"Weak Law of Large Number\". </p>\n<p>I am confused on the following problem</p>\n<p>\"<br>\nHow to defined all set of form {1}, {1,2}, {1,2,3}.... and say something like there exists N such that \\forall n&gt;N \\sum_{i=1}^n .......<br>\n\"<br>\nCan someone help with this?</p>\n<p>Thank you in advance:)</p>",
        "id": 294668574,
        "sender_full_name": "Daniil Homza",
        "timestamp": 1661172656
    },
    {
        "content": "<p>Does <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin\">docs#fin</a> and/or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.range\">docs#finset.range</a> help?</p>",
        "id": 294671523,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661173529
    },
    {
        "content": "<p>See also <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sum\">docs#finset.sum</a>.</p>",
        "id": 294671589,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661173553
    },
    {
        "content": "<p>Hi Lean Community,</p>\n<p>I have some easy question to solve but I can not get it. I am interesting to proof that expected value of m r.v. is sum of m expected value of r.v. I can not find such result of summarising of two integrals in section measure_theory. Actually i have problem even in case of such result in case of two r.v. Any Help? Thanks in advance <a href=\"/user_uploads/3121/xtvGL6RhSQMpnnc8_RiiafCp/123.PNG\">123.PNG</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/xtvGL6RhSQMpnnc8_RiiafCp/123.PNG\" title=\"123.PNG\"><img src=\"/user_uploads/3121/xtvGL6RhSQMpnnc8_RiiafCp/123.PNG\"></a></div>",
        "id": 298725143,
        "sender_full_name": "Daniil Homza",
        "timestamp": 1663144345
    },
    {
        "content": "<p>Hi! Helping you would be easier if you posted code instead of a picture, ideally in the form of an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> . But it looks like the lemma you are looking for is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.integral_finset_sum\">docs#measure_theory.integral_finset_sum</a></p>",
        "id": 298725617,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1663144582
    },
    {
        "content": "<p>for two random variables it would be <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.integral_add\">docs#measure_theory.integral_add</a></p>",
        "id": 298725764,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1663144651
    },
    {
        "content": "<p>o, yep, i think is that i am looking for. Sorry for picture) Thank you!</p>",
        "id": 298728793,
        "sender_full_name": "Daniil Homza",
        "timestamp": 1663145990
    }
]
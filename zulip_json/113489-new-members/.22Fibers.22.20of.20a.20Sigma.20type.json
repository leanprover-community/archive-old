[
    {
        "content": "<p>Hey, what would be the \"right\" way to define the \"fiber\" of some sigma type? I can do the following </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"kd\">constant</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"kd\">def</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">h</span> <span class=\"n\">t.fst</span> <span class=\"n\">t.snd</span>\n<span class=\"kd\">constants</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span>\n<span class=\"kd\">def</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">//</span> <span class=\"n\">t.fst.fst</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">t.fst.snd</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">u</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">u1</span> <span class=\"o\">:=</span> <span class=\"n\">t.val.snd</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">subtype.val_eq_coe</span> <span class=\"n\">at</span> <span class=\"n\">u1</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">t.prop.left</span> <span class=\"n\">at</span> <span class=\"n\">u1</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">t.prop.right</span> <span class=\"n\">at</span> <span class=\"n\">u1</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">u1</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>but this feels so wrong to have to invoque rewrites and stuff in a definition. Is there a more \"canonical\" way to define the type <code>C</code> so that the <code>u</code> might have a better definition that does not involve clumsy rewrites like this?</p>",
        "id": 260264958,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1636030525
    },
    {
        "content": "<p>The issue is that the equalities in C are propositional rather than definitional but I don't know if there is a way around this.</p>",
        "id": 260265148,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1636030634
    },
    {
        "content": "<p>I guess <code>h x y</code>is already the type I'm looking for in a way, though, this is probably not exactly the question I wanted to ask.</p>",
        "id": 260267431,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1636031716
    },
    {
        "content": "<p>(note that using <code>constant</code> like that is atypical, usually you'd use <code>variable</code>)</p>",
        "id": 260283812,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636038676
    },
    {
        "content": "<p>First, this is a more typical way this might be written (<code>constant</code> is atypical because it introduces things as axioms; <code>variables</code> introduces them as arguments for the definitions instead):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">h</span> <span class=\"n\">t.fst</span> <span class=\"n\">t.snd</span>\n<span class=\"kd\">def</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"n\">h</span> <span class=\"bp\">//</span> <span class=\"n\">t.fst.fst</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">t.fst.snd</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">u</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">u1</span> <span class=\"o\">:=</span> <span class=\"n\">t.val.snd</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">subtype.val_eq_coe</span> <span class=\"n\">at</span> <span class=\"n\">u1</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">t.prop.left</span> <span class=\"n\">at</span> <span class=\"n\">u1</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">t.prop.right</span> <span class=\"n\">at</span> <span class=\"n\">u1</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">u1</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I'm not sure there's a way around needing to rewrite for fibers of a sigma type.  There's a trick, though, using the fancier decomposition tactics like <code>rintro</code>, <code>rcases</code>, and <code>obtain</code> which is to use the fact you can have constructors appear in the pattern.  The effect of the <code>rfl</code> constructor is <code>subst</code>, so you can do the rewrites in one fell swoop:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">u</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260285772,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636039455
    },
    {
        "content": "<p>Second, I would probably use nested sigma types rather than use a product.  It doesn't really change much, but it's worth knowing that you can do it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"n\">y</span>   <span class=\"c1\">-- short for Σ (x : A), Σ (y : A), h x y</span>\n<span class=\"kd\">def</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"n\">h</span> <span class=\"bp\">//</span> <span class=\"n\">t.fst</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">t.snd.fst</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">u</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260286326,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636039662
    },
    {
        "content": "<p>One more comment: rather than <code>.fst</code> and <code>.snd</code>, for these simple types it's common to use <code>.1</code> and <code>.2</code> like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"n\">h</span> <span class=\"bp\">//</span> <span class=\"n\">t.1</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">t.2.1</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>This numerical notation works universally for structures, no matter what the names of the fields actually are.</p>",
        "id": 260287393,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636040054
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"286014\">Robin Carlier</span> <a href=\"#narrow/stream/113489-new-members/topic/.22Fibers.22.20of.20a.20Sigma.20type/near/260267431\">said</a>:</p>\n<blockquote>\n<p>I guess <code>h x y</code>is already the type I'm looking for in a way, though, this is probably not exactly the question I wanted to ask.</p>\n</blockquote>\n<p>Here's sort of a proof that <code>h x y</code> is the type you're looking for, but also a sort of proof that all the rewrites don't really get in the way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">u</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">≃</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"o\">⟨⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 260297131,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636043538
    },
    {
        "content": "<p>IMO It's a little strange to try to define the fibres of a sigma type... The point of a sigma type is to define a type if you're given the fibres. What are you actually trying to do?</p>",
        "id": 260344347,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636065500
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> The thing I'm trying to do is related to the colimit of quivers and category thing I mentionned in an other thread: quivers in lean are defined as a structure of a type <code>V</code> of 'vertices' and a hom <code>V → V → Type u</code>.<br>\nA common way to describe quivers in category theory is as a presheaf on the walking parallel pair (two objects V and E, two morphisms from V to E): the functor from quivers a la lean to a quiver as presheaves sends a quiver to the functor that sends <code>V</code>to its type,  and that sends  <code>E</code> to the sigma type I defined above, and the two maps to the two projections.<br>\nNow the inverse functor sends a presheaf <code>F</code> to the type <code>F.obj V</code>, and the <code>hom</code>between two elements <code>x</code>and <code>y</code> in that type should be defined as the fiber at <code>x, y</code> of the map <code>F.obj E → F.obj V × F.obj V </code>. To see this gives an equivalence of categories, you have to go through the fact this fiber thing gives back the type you want, which is what Kyle proved above. <br>\nThe presheaf description of quivers is nice in that it gives existence of limits and colimits for free, since they are functors from a small category to <code>Type u</code>.</p>",
        "id": 260377968,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1636101770
    },
    {
        "content": "<p>when trying to implement that the rewrites got a bit in the way, so <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> 's answer is very helpful!</p>",
        "id": 260378261,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1636101970
    },
    {
        "content": "<p>The rewritings are still a bit of a pain... I put my stuff in <a href=\"https://gist.github.com/robin-carlier/9e833c13031e80083a38eb3640bb31dc\">https://gist.github.com/robin-carlier/9e833c13031e80083a38eb3640bb31dc</a> if someone wants to have a look, the goal in the first sorry is a complete mess because of those rewrites.<br>\nI think I'm not taking the right approach to this.</p>",
        "id": 260413090,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1636122938
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span> this old discussion is related: <br>\n<a href=\"#narrow/stream/252551-graph-theory/topic/spans/near/214898332\">https://leanprover.zulipchat.com/#narrow/stream/252551-graph-theory/topic/spans/near/214898332</a></p>",
        "id": 260413800,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636123282
    },
    {
        "content": "<p>Very relevant indeed, thanks a lot for this link! <br>\nWhat I get out of this is that \"working with sigma types for this sort of thing leads to a huge amount of pain very quickly\", which is also my experience this far :D <br>\nI see that in the end <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> seems to have part of the desired equivalence, the remaining part being an equivalence between <code>dgraph</code> and an actual category of functor.</p>",
        "id": 260414949,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1636123794
    },
    {
        "content": "<p>In another discussion, Reid said something about the theoretical relationship when I asked a couple message up: <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/prefunctor.3F/near/214905554\">https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/prefunctor.3F/near/214905554</a></p>",
        "id": 260422103,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636126862
    },
    {
        "content": "<p>Yes, that stuff is in the end an instance of the grothendieck construction but I think this would be a huge rabbit hole to formalize in itself.</p>",
        "id": 260422263,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1636126935
    },
    {
        "content": "<p>Right so in ordinary math, an S-indexed family of sets is \"the same as\" a set with a map to S, but as you've discovered, in type theory the former has a preferred status.</p>",
        "id": 260424704,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636127973
    },
    {
        "content": "<p>Even though one has a preferred status, the equivalence between the two should still be expected, despite being perhaps a bit more convoluted to prove right?</p>",
        "id": 260433780,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1636131654
    },
    {
        "content": "<p>Passing information along equivalences however might not be so easy.</p>",
        "id": 260434079,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636131758
    },
    {
        "content": "<p>Yes, this I'm ok to believe.<br>\nIn the case of \"quivers as families\" vs. \"quiver as presheaves\", the fact that they are equivalent as categories is enough to prove the former has limits and colimits anyway, which was the goal here.</p>",
        "id": 260434627,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1636131971
    },
    {
        "content": "<p>Trying to extract actual construction of limits or colimits via this equivalence will be rather hard</p>",
        "id": 260434810,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1636132053
    },
    {
        "content": "<p>Here's some category theory without the <code>category_theory</code>, showing (most of the argument) that spans are equivalent to indexed families:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">dgraph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">dgraph'</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">edge</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">dgraph.hom</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">dgraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"n\">G.E</span> <span class=\"bp\">→</span> <span class=\"n\">G'.E</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">s_map</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">G.E</span><span class=\"o\">),</span> <span class=\"n\">G'.s</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">G.s</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">t_map</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">G.E</span><span class=\"o\">),</span> <span class=\"n\">G'.t</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">G.t</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">dgraph.hom.comp</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"n\">G'</span> <span class=\"n\">G''</span> <span class=\"o\">:</span> <span class=\"n\">dgraph</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G.hom</span> <span class=\"n\">G'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f'</span> <span class=\"o\">:</span> <span class=\"n\">G'.hom</span> <span class=\"n\">G''</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G.hom</span> <span class=\"n\">G''</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"n\">f'.map</span> <span class=\"bp\">∘</span> <span class=\"n\">f.map</span><span class=\"o\">,</span>\n  <span class=\"n\">s_map</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">dgraph.hom.s_map</span><span class=\"o\">],</span>\n  <span class=\"n\">t_map</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">dgraph.hom.t_map</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">dgraph.hom.id</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">dgraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">G.hom</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"n\">id</span><span class=\"o\">,</span>\n  <span class=\"n\">s_map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">t_map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">dgraph'.hom</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">dgraph'</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"n\">G.edge</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">G'.edge</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">dgraph'.hom.comp</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"n\">G'</span> <span class=\"n\">G''</span> <span class=\"o\">:</span> <span class=\"n\">dgraph'</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G.hom</span> <span class=\"n\">G'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f'</span> <span class=\"o\">:</span> <span class=\"n\">G'.hom</span> <span class=\"n\">G''</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G.hom</span> <span class=\"n\">G''</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">f'.map</span> <span class=\"o\">(</span><span class=\"n\">f.map</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">dgraph'.hom.id</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">dgraph'</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">G.hom</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">id</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- A functor from the dgraph category to the dgraph' category -/</span>\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">dgraph.to_dgraph'</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">dgraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">dgraph'</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">edge</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">G.E</span> <span class=\"bp\">//</span> <span class=\"n\">G.s</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"bp\">∧</span> <span class=\"n\">G.t</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">dgraph.to_dgraph'_hom</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">dgraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">dgraph.hom</span> <span class=\"n\">G</span> <span class=\"n\">G'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">dgraph'.hom</span> <span class=\"n\">G.to_dgraph'</span> <span class=\"n\">G'.to_dgraph'</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">f.map</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">f.s_map</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">f.t_map</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- A functor from the dgraph' category to the dgraph category -/</span>\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">dgraph'.to_dgraph</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">dgraph'</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">dgraph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">G'.edge</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n  <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e.1</span><span class=\"o\">,</span>\n  <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e.2.1</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">dgraph'.to_dgraph_hom</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">dgraph'</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">dgraph'.hom</span> <span class=\"n\">G</span> <span class=\"n\">G'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">dgraph.hom</span> <span class=\"n\">G.to_dgraph</span> <span class=\"n\">G'.to_dgraph</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">e.1</span><span class=\"o\">,</span> <span class=\"n\">e.2.1</span><span class=\"o\">,</span> <span class=\"n\">f.map</span> <span class=\"n\">e.2.2</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">s_map</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">t_map</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- The composition of these functors is an equivalence:</span>\n\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">dgraph.to_dgraph_to_dgraph'</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">dgraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">dgraph.hom</span> <span class=\"n\">G</span> <span class=\"n\">G.to_dgraph'.to_dgraph</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">G.s</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">G.t</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">s_map</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">t_map</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">dgraph.to_dgraph_to_dgraph'_symm</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">dgraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">dgraph.hom</span> <span class=\"n\">G.to_dgraph'.to_dgraph</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e.2.2.1</span><span class=\"o\">,</span>\n  <span class=\"n\">s_map</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">t_map</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">dgraph.to_dgraph_equiv1</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">dgraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.to_dgraph_to_dgraph'.comp</span> <span class=\"n\">G.to_dgraph_to_dgraph'_symm</span> <span class=\"bp\">=</span> <span class=\"n\">dgraph.hom.id</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">dgraph.to_dgraph_equiv2</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">dgraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.to_dgraph_to_dgraph'_symm.comp</span> <span class=\"n\">G.to_dgraph_to_dgraph'</span> <span class=\"bp\">=</span> <span class=\"n\">dgraph.hom.id</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- The composition of these functors in the other direction is an equivalence:</span>\n\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">dgraph'.to_dgraph'_to_dgraph</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">dgraph'</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">dgraph'.hom</span> <span class=\"n\">G</span> <span class=\"n\">G.to_dgraph.to_dgraph'</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"o\">⟨⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">dgraph'.to_dgraph'_to_dgraph_symm</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">dgraph'</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">dgraph'.hom</span> <span class=\"n\">G.to_dgraph.to_dgraph'</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">convert</span> <span class=\"n\">e.1.2.2</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">e.2.1.symm</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">e.2.2.symm</span> <span class=\"o\">},</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">dgraph'.to_dgraph'_equiv1</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">dgraph'</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.to_dgraph'_to_dgraph.comp</span> <span class=\"n\">G.to_dgraph'_to_dgraph_symm</span> <span class=\"bp\">=</span> <span class=\"n\">dgraph'.hom.id</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">dgraph'.to_dgraph'_equiv2</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">dgraph'</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.to_dgraph'_to_dgraph_symm.comp</span> <span class=\"n\">G.to_dgraph'_to_dgraph</span> <span class=\"bp\">=</span> <span class=\"n\">dgraph'.hom.id</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">e</span><span class=\"bp\">;</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">e</span><span class=\"bp\">;</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260436328,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636132718
    },
    {
        "content": "<p>Wow, great!</p>",
        "id": 260437145,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1636133086
    },
    {
        "content": "<p>(It'd be a good <code>category_theory</code> exercise to put it in that language -- I'm not really sure why I didn't start that way.)</p>",
        "id": 260437551,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636133272
    },
    {
        "content": "<p>Yup, that's what I intend to do at some point :D</p>",
        "id": 260437745,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1636133356
    },
    {
        "content": "<p><code>dgraph'.to_dgraph'_equiv1</code> by the way was the most horrific proof to get working, and luck seemed to be on my side to be able to find this.  You should take a look at the term a plain <code>simp</code> gives right after <code>ext v w e</code>...</p>",
        "id": 260437942,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636133446
    },
    {
        "content": "<p>It might be because the <code>@[simps]</code> aren't generating good simp lemmas, but I'd expect something like that anyway because of how many rewrites &amp; destructurings are needed in these definitions.</p>",
        "id": 260438149,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636133550
    },
    {
        "content": "<p>Which version of lean is your code in? vscode is complaining that <code>@[ext]</code> is an unknown attribute.</p>",
        "id": 260438286,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1636133622
    },
    {
        "content": "<p>Same for <code>@[simps]</code></p>",
        "id": 260438417,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1636133681
    },
    {
        "content": "<p>Are you using an up to date mathlib master Robin?</p>",
        "id": 260438625,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636133792
    },
    {
        "content": "<p>oh ! Kyle didn't put any imports! <code>import tactic</code> at the top fixes everything.</p>",
        "id": 260438676,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636133828
    },
    {
        "content": "<p>Oops, it's just <code>import tactic</code></p>",
        "id": 260438732,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636133856
    },
    {
        "content": "<p>Putting <code>import tactic</code>at the top makes lean gives me an \"excessive memory consumption\", I'll figure something. I think my mathlib is up-to-date yes.</p>",
        "id": 260439413,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1636134178
    },
    {
        "content": "<p>Exit VS Code and restart it.</p>",
        "id": 260439440,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636134196
    },
    {
        "content": "<p>Or ctrl-shift-P -&gt; Restart Lean</p>",
        "id": 260439486,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636134222
    },
    {
        "content": "<p>Unrelated to memory consumption, I made a more \"surgical\" definition for <code>dgraph'.to_dgraph'_to_dgraph_symm</code> and the proof is much less horrific: now it's <code>rfl</code>!  (The code block above is updated.)</p>",
        "id": 260439628,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636134270
    },
    {
        "content": "<p>The kind of goal it was giving before the update was the kind of goal I was stuck on in the gist I posted a few posts above</p>",
        "id": 260441317,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1636134966
    }
]
[
    {
        "content": "<p>What is large elimination? What is subsingleton elimination? Why do we care about these? What do they have to do with proof irrelevance? What's so good about proof irrelevance anyway?</p>",
        "id": 196007956,
        "sender_full_name": "Ken Lee",
        "timestamp": 1588366024
    },
    {
        "content": "<p>Some inductive propsition have a recursor that can make elements of a Type e.g. <code>eq</code>, <code>true</code>, <code>false</code>, <code>and</code>, <code>acc</code>. Others can only make a Prop, e.g. <code>exists</code> and <code>or</code>. eliminating into Type is call large elemination. If large elimination was allowed on <code>or</code> then the iota reduction rule would be inconsistent because of proof irrelevance, your function could return different values for <code>or.inl x</code> and <code>or.inr y</code>, even though <code>or.inl x.= or.inr y</code>. The Props with large elimination don't have this problem.</p>",
        "id": 196012582,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1588368819
    },
    {
        "content": "<p>This is basically because they would be a subsingleton anyway, even if they were types. They only have one constructor, and all arguments are either props or are mentioned in the type of the output. There is a more precise rule for this somewhere.</p>",
        "id": 196012775,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1588368920
    },
    {
        "content": "<p>I think other people can answer what is so good about proof irrelevance better than me, but one example is that <code>subtype.ext</code> would not hold without it.</p>",
        "id": 196012885,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1588368978
    },
    {
        "content": "<p><a href=\"https://lean-forward.github.io/logical-verification/2018/41_notes.html\" title=\"https://lean-forward.github.io/logical-verification/2018/41_notes.html\">https://lean-forward.github.io/logical-verification/2018/41_notes.html</a> might be helpful</p>",
        "id": 196013729,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1588369493
    },
    {
        "content": "<p>Thanks Chris. I will have a read</p>",
        "id": 196015004,
        "sender_full_name": "Ken Lee",
        "timestamp": 1588370392
    },
    {
        "content": "<p>Only the Prop type is proof irrelevant (all terms are definitionally equal) because it has to be in order to support classical reasoning - that was my understanding from the HoTT book. I asked a related question a little while ago, where I learned there are type theories that support continuation passing (e.g. exception handlers) model classical logic in a proof relevant way  (I think). As far as I know there are no proof assistants that utilize this approach for reasons unknown to me.</p>",
        "id": 196015631,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588370799
    },
    {
        "content": "<p>Is this the thing about callcc with type <code>(((A -&gt; B) -&gt; A) -&gt; A</code> that has some computational interpretation. I never understood that.</p>",
        "id": 196015836,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1588370972
    },
    {
        "content": "<p>Yes. I don't understand it either. But it seems like an exciting approach since to me proof relevance and computational interpretation seem desirable. But I'm sure there's some drawback that makes it not practical or something</p>",
        "id": 196016521,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588371546
    },
    {
        "content": "<p>I think it's an interesting observation that proof irrelevance and ignoring computation, the approach used in mathlib in general, has meant that the library has grown very quickly and seems to be well on the way to covering a pure mathematics degree</p>",
        "id": 196017228,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588372181
    },
    {
        "content": "<p>Well I certainly wouldn't want to adopt a system that provides proof relevance at the expense of being able to do ordinary mathematics efficiently. But from my feeble understanding of the exception handling/continuation-passing style is that this wouldn't be the case. I don't see how on the surface any of what we do in Lean would be different and would slow anything down, it would just add proof relevance so that we could do interesting things with proof objects themselves.</p>",
        "id": 196017788,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588372731
    },
    {
        "content": "<p>There are all these different interesting ways to write a proof of the same proposition that I as a human outside the system can appreciate, but the type theory itself cannot because all the proofs are equal. It would be neat if the type theory itself could represent all the proofs and therefore have functions from one proof to another etc. You could prove things about the space of proofs for a proposition or something.</p>",
        "id": 196018062,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588372956
    },
    {
        "content": "<p>You not really forced to use proof irrelevance in Lean even though it's available, you can always use <code>Type</code> if you want.</p>",
        "id": 196018176,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1588373085
    },
    {
        "content": "<p>Yes but my understanding is you're restricted to constructive logic outside of Prop</p>",
        "id": 196018344,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588373245
    },
    {
        "content": "<p>I think the continuation passing style would look something like this under-the-hood (mixing C++-style code with Lean)</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">theorem</span> <span class=\"n\">dne</span> <span class=\"o\">:</span> <span class=\"bp\">¬¬</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"k\">assume</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">,</span>\n<span class=\"n\">try</span> <span class=\"o\">{</span>\n   <span class=\"c1\">-- derive contradiction, raising an exception</span>\n<span class=\"o\">}</span> <span class=\"n\">catch</span> <span class=\"n\">Exception</span> <span class=\"n\">e</span> <span class=\"o\">{</span>\n    <span class=\"c1\">-- something something</span>\n    <span class=\"n\">return</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 196018881,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588373801
    },
    {
        "content": "<p>We already have a syntax for LEM, namely <code>if/then/else</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">theorem</span> <span class=\"n\">dne</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">not</span> <span class=\"o\">(</span><span class=\"n\">not</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"k\">then</span> <span class=\"n\">hp</span> <span class=\"k\">else</span> <span class=\"n\">false</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">hp</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>I think you are proposing a kind of \"computational\" semantics for <code>if/then/else</code> where <code>if hp : p then x[hp] else y[hp]</code> is implemented as \"capture the current continuation and pass it to <code>y</code> as a claimed proof of <code>not p</code>; if <code>y</code> ever tries to invoke this proof then reset to the branch point and instead pass <code>x</code> the proof of <code>p</code> you got from <code>y</code>\".</p>",
        "id": 196020106,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588374904
    },
    {
        "content": "<p>As I understand it, this is somehow logically sound in that a valid proof using classical logic is transformed into a program which terminates (in some sense).</p>",
        "id": 196020172,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588374965
    },
    {
        "content": "<p>Yes yes. Now do you know why this doesn't seem to be implemented in any proof assistant? Looks like continuation passing idea dates back to at least the early 90s</p>",
        "id": 196020244,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588375042
    },
    {
        "content": "<p>However, another property you would probably like for your language is that <code>if hp : p then x[hp] else y[hp]</code> evaluates to <code>x[hp]</code> if <code>p</code> is true and <code>y[hp]</code> if <code>p</code> is false, and this property would be lost. For example if <code>y</code> does not actually use <code>hp</code> then the result will always be <code>y</code>.</p>",
        "id": 196020248,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588375049
    },
    {
        "content": "<p>So, the semantics is logically sound (you will get out some value) but not sound in the sense of producing the <em>correct</em> value.</p>",
        "id": 196020318,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588375084
    },
    {
        "content": "<p>So, for programming it's rather useless.</p>",
        "id": 196020330,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588375090
    },
    {
        "content": "<p>In particular using LEM you can define a function <code>value : Prop -&gt; bool</code> with <code>value true = tt</code> and <code>value false = ff</code> according to the logic, but if you actually run <code>value p</code> you will always get the answer <code>ff</code> (or maybe <code>tt</code>, depending on how you defined it).</p>",
        "id": 196020486,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588375243
    },
    {
        "content": "<p>I'm not sure I follow but that's my fault not yours. I thought all we care about when proving something is to create a valid term of a type, doesn't matter what term it is</p>",
        "id": 196020827,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588375534
    },
    {
        "content": "<p>I agree that a function that always raises an exception and doesn't give you what you expect isn't a useful function, but exception handling as a construct is useful in that it allows you to do something else before the function returns. You might try calling the function again with a different value for example.</p>",
        "id": 196020913,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588375600
    },
    {
        "content": "<p>Well that's what I care about, and that's why proof <em>ir</em>relevance is a natural and good property to look for in your system.</p>",
        "id": 196020914,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588375602
    },
    {
        "content": "<p>Well there are two levels. On the one hand, in order to prove something under the propositions-as-types paradigm, I only need to construct a term of that type, any term. So in some sense, no matter what all terms are \"equally good\" since they prove the type. But in another sense, I might care that a particular term uses lemma1 versus another term that uses lemma2, and this could be an interesting area of study in its own right. That is only possible with proof relevance. So I don't see how proof relevance gets rid of anything good that is in a proof irrelevant system; you only get more options.</p>",
        "id": 196021065,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588375783
    },
    {
        "content": "<p>No, it is possible for example by examining the proof metatheoretically.</p>",
        "id": 196021127,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588375806
    },
    {
        "content": "<p>I don't think it has any internal meaning.</p>",
        "id": 196021133,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588375817
    },
    {
        "content": "<p>We have this in Lean in the sense that the olean file will be different depending on which proof you wrote.</p>",
        "id": 196021171,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588375861
    },
    {
        "content": "<p>To turn your argument around, being able to prove that <code>proof1 = proof2</code> for any two proofs of the same statement is something only possible with proof irrelevance, and it can only be good to have this additional option.</p>",
        "id": 196021264,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588375932
    },
    {
        "content": "<p>If two terms are syntactically identical but with different names, you could prove proof1 = proof2 using reflexivity right?</p>",
        "id": 196021462,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588376113
    },
    {
        "content": "<p>Sure, but the interesting case is when the proofs are not syntactically identical</p>",
        "id": 196021546,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588376193
    },
    {
        "content": "<p>for a more recent version of the link that chris posted, see <a href=\"https://github.com/blanchette/logical_verification_2020/raw/master/hitchhikers_guide.pdf\" title=\"https://github.com/blanchette/logical_verification_2020/raw/master/hitchhikers_guide.pdf\">https://github.com/blanchette/logical_verification_2020/raw/master/hitchhikers_guide.pdf</a>.<br>\nthey talk about benefits of proof irrelevance in 11.2 and 11.4.</p>",
        "id": 196021575,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1588376224
    },
    {
        "content": "<p>I think the usual abuse of \"proof\" to mean inhabitant of a proposition causes some confusion here</p>",
        "id": 196021784,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588376464
    },
    {
        "content": "<p>But in Lean right now, if I restrict myself to non-Prop types and therefore do not use classical axioms, then I can construct two (non-syntactically identical) terms for a theorem about some property of lists, for example. Then I could perhaps write a function that computes a distance between two terms and then I could have a sort of metric space of proof terms. Many other interesting things I could do with the proof terms.</p>",
        "id": 196021857,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588376563
    },
    {
        "content": "<p>And with continuation-passing, I think this could be extended into proofs using classical logic</p>",
        "id": 196021917,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588376631
    },
    {
        "content": "<p>You seem to be confusing a proof <strong>term</strong> (a syntactic thing) with its value internally</p>",
        "id": 196021982,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588376674
    },
    {
        "content": "<p>If I give you <code>x y : forall (a b : nat), a + b = b + a</code>, there is no function you can define inside Lean that has any way to distinguish between <code>x</code> and <code>y</code></p>",
        "id": 196022017,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588376736
    },
    {
        "content": "<p>In fact, in this case, I'm pretty sure that even if you do not use Prop at all, you can still prove that <code>x = y</code></p>",
        "id": 196022090,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588376833
    },
    {
        "content": "<p>well, at least if you allow <code>funext</code></p>",
        "id": 196022101,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588376848
    },
    {
        "content": "<p>You can distinguish proofs of <code>p -&gt; p or p</code> based on whether they produce <code>or.inl</code> or <code>or.inr</code>, but this is not at all the same kind of thing as \"distance between two terms\".</p>",
        "id": 196022272,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588377013
    },
    {
        "content": "<p>Ah I see now. You could only do stuff like that metatheoretically as you said earlier. Like in homoiconic programming languages like Lisp or Julia you could take the syntactic term code and use it as data. Not sure if such languages could be made to correspond to a consistent logic.</p>",
        "id": 196022625,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588377401
    },
    {
        "content": "<p>Here is a concrete advantage of (definitional) proof irrelevance. Suppose I need to prove</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">3</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"bp\">^</span><span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n<span class=\"c1\">-- example shamelessly stolen from Kevin</span>\n</code></pre></div>\n\n\n<p>as part of a larger development. Proving this by hand would be a not very enjoyable exercise. Fortunately we have the <code>ring</code> tactic so I can just write <code>by ring</code> and move on. Later I use lemma <code>A</code> in order to prove some amazing theorem.</p>\n<p>Now the next day somebody finds that the <code>ring</code> tactic has an annoying bug where sometimes you have to write <code>ring, ring</code>, and this gets fixed. As a side effect, maybe <code>ring</code> no longer produces the exact same proof term for lemma <code>A</code> as it did before. But that is fine, since I have a guarantee that changing the proof of <code>A</code> will not break the proof of my amazing theorem--that's provided by definitional proof irrelevance.</p>",
        "id": 196022656,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588377471
    },
    {
        "content": "<p>But even if it changes the proof term I don't see how it should affect anything downstream. It just needs to type check right?</p>",
        "id": 196023025,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588377879
    },
    {
        "content": "<p>In terms of using Lean for mathematics, we really only need the type checker right?. We don't actually need to compute with values. So technically the type of functions <code>ℕ → ℕ</code> is a theorem and I can \"prove\" it by constructing e.g. <code>theorem add2 (n : ℕ) : ℕ := n + 2</code> or <code>theorem mul2 (n : ℕ) : ℕ := 2 * n</code> and if I have some downstream theorem that depends on there being a proof of ℕ → ℕ then I could give it <code>add2</code> or <code>mul2</code> and it shouldn't care. Now if I want to use Lean to like crunch numbers for data analysis then I absolutely care whether I'm using <code>add2</code> or <code>mul2</code></p>",
        "id": 196023308,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588378253
    },
    {
        "content": "<p>If you use the keyword <code>theorem</code> then you cannot use the function defined computationally, and we do not call these theorems nor their definitions proofs.</p>",
        "id": 196023599,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588378619
    },
    {
        "content": "<p>Of course, Lean is not \"definition-irrelevant\"!</p>",
        "id": 196023614,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588378642
    },
    {
        "content": "<p>But I can compute with the theorem. <code>#reduce mul2 5 -- 10</code></p>",
        "id": 196023634,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588378680
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243102\">Brandon Brown</span> <a href=\"#narrow/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions/near/196023025\" title=\"#narrow/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions/near/196023025\">said</a>:</p>\n<blockquote>\n<p>But even if it changes the proof term I don't see how it should affect anything downstream. It just needs to type check right?</p>\n</blockquote>\n<p>If changing a proof term does not affect anything downstream, it exactly means that you have proof irrelevance.</p>",
        "id": 196023664,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588378683
    },
    {
        "content": "<p>Okay, but you can't use <code>#eval</code> or <code>lean --run</code> and this is clearly not the way the language is meant to be used.</p>",
        "id": 196023697,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588378759
    },
    {
        "content": "<p>But I assume that's just an efficiency thing, no need to generate code for things that won't be used for computation. There's no fundamental reason <code>theorem</code> couldn't simply be an alias for <code>def</code>  , I guess except for the fact that non-constructive proofs won't be computable</p>",
        "id": 196023767,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588378897
    },
    {
        "content": "<p>I'm increasingly lost here.</p>",
        "id": 196023831,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588379012
    },
    {
        "content": "<p>Didn't you just suggest that you want to use <code>add2</code> or <code>mul2</code> for computation?</p>",
        "id": 196023889,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588379047
    },
    {
        "content": "<p>I'm saying sometimes I care about computation sometimes I only care about type correctness</p>",
        "id": 196023907,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588379071
    },
    {
        "content": "<p>If you don't want to distinguish between <code>theorem</code> and <code>def</code> then fine: we call something a \"theorem\" when its type is a Prop, and a \"definition\" otherwise.</p>",
        "id": 196023915,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588379093
    },
    {
        "content": "<p>Great, so use Prop when you only care about proving and don't use it when you care about computation.</p>",
        "id": 196023923,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588379109
    },
    {
        "content": "<p>By proof we mean some <code>p</code> where the type of <code>p</code> is a Prop.</p>",
        "id": 196023929,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588379136
    },
    {
        "content": "<p>Then, proof irrelevance is what we want because we don't intend to compute with such <code>p</code> anyways.</p>",
        "id": 196023935,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588379159
    },
    {
        "content": "<p>We don't use the word \"proof\" for things like <code>add2</code>. I think other sources (e.g., the HoTT book?) may use the term in a sense which includes things like <code>add2</code>.</p>",
        "id": 196024167,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588379531
    },
    {
        "content": "<p>But that's just a convention</p>",
        "id": 196024285,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588379741
    },
    {
        "content": "<p>Anyway, I think I need to sit on this for awhile before I can come back with anything more interesting. I can see that proof irrelevance (just using the type checker) is all we need for ordinary mathematics. Perhaps there is no benefit if all theorems had computable terms, but I still haven't ruled it out and it's something I want to think about more.</p>",
        "id": 196024353,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588379835
    },
    {
        "content": "<p>Is callcc consistent with funext? It seems like the implementation could return different thing for extensionally equal functions as input.</p>",
        "id": 196024354,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1588379836
    },
    {
        "content": "<p>Of course, but it is the convention we are using in the context of the term \"proof irrelevance\"</p>",
        "id": 196024358,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588379848
    },
    {
        "content": "<p>Well <code>((A -&gt; B) -&gt; A) -&gt; A</code> can be constructed using <code>choice</code>, right? The problem only begins when you want to start asserting equations about it</p>",
        "id": 196024645,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588380249
    },
    {
        "content": "<p>Does this application of callcc terminate? The term of type <code>A</code> I returned used the function <code>A -&gt; B</code> that doesn't exist.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">axiom</span> <span class=\"n\">callcc</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"n\">callcc</span> <span class=\"bp\">_</span> <span class=\"n\">false</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"err\">∘</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 196024860,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1588380540
    },
    {
        "content": "<p>I might have misunderstood what it does.</p>",
        "id": 196024932,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1588380609
    },
    {
        "content": "<p>I think any function you can write using <code>callcc</code> will terminate, but certainly this one does. Moreover, if you compose it with <code>p ∨ ¬ p -&gt; bool</code> defined in the obvious way, it will produce <code>ff</code>.</p>",
        "id": 196025270,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588381165
    },
    {
        "content": "<p>Operationally this is because the <code>p ∨ ¬ p -&gt; bool</code> function doesn't inspect the proof of <code>¬ p</code>, which is where the continuation is stored, so execution will follow the normal path</p>",
        "id": 196025322,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588381252
    },
    {
        "content": "<p>If you happen to have a proof <code>H : p</code> and use it to eliminate the <code>¬ p</code> case, what will happen operationally is this: first the normal path will be taken, returning <code>or.inr (h ∘ or.inl)</code>,  where <code>h</code> is the saved continuation; then you pattern match on this, obtaining <code>h ∘ or.inl = \\lam x, h (or.inl x) : p -&gt; false</code>, and apply this to <code>H</code>; the result is to apply <code>h</code> to <code>or.inl H</code>, which resets the computation to the point where <code>callcc</code> returns, this time giving you <code>or.inl H</code>.</p>",
        "id": 196025651,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588381816
    },
    {
        "content": "<p>If you happen to have a proof <code>H : not (not p)</code> and use it to eliminate the <code>not p</code> case, then what happens depends on the definition of <code>H</code> and things might get complicated...</p>",
        "id": 196025719,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588381942
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243102\">Brandon Brown</span> <a href=\"#narrow/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions/near/196023907\" title=\"#narrow/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions/near/196023907\">said</a>:</p>\n<blockquote>\n<p>I'm saying sometimes I care about computation sometimes I only care about type correctness</p>\n</blockquote>\n<p>I think you underestimate the complexity of type checking with <em>dependent</em> types. Consider the following:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n<span class=\"n\">def</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">5</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"c1\">-- type checks</span>\n<span class=\"c1\">-- #check (rfl : b = 3) -- does not type check</span>\n</code></pre></div>\n\n\n<p>Here <code>a</code> and <code>b</code> have the same type, but they are not interchangeable.</p>\n<p>Another example: suppose I've defined a function <code>exp : ℝ → ℝ</code>, and now I want to prove that <code>exp</code> is increasing. My proof of this will certainly rely on the definition of <code>exp</code>, not just its type! But I'm not really 'computing' with <code>exp</code>; I'm only doing proofs.</p>\n<p>So you should always be careful with how you define \"data\" like <code>exp</code>, but by Proof Irrelevance there is no need to worry about how you prove theorems</p>",
        "id": 196039027,
        "sender_full_name": "David Wärn",
        "timestamp": 1588405474
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions/near/196012582\" title=\"#narrow/stream/113489-new-members/topic/Please.20Eliminate.20My.20Large.20Questions/near/196012582\">said</a>:</p>\n<blockquote>\n<p>Some inductive propsition have a recursor that can make elements of a Type e.g. <code>eq</code>, <code>true</code>, <code>false</code>, <code>and</code>, <code>acc</code>. Others can only make a Prop, e.g. <code>exists</code> and <code>or</code>. eliminating into Type is call large elemination. If large elimination was allowed on <code>or</code> then the iota reduction rule would be inconsistent because of proof irrelevance, your function could return different values for <code>or.inl x</code> and <code>or.inr y</code>, even though <code>or.inl x.= or.inr y</code>. The Props with large elimination don't have this problem.</p>\n</blockquote>\n<p>I just understood your example with or. It makes sense now. Thanks!</p>",
        "id": 197008657,
        "sender_full_name": "Ken Lee",
        "timestamp": 1589053024
    },
    {
        "content": "<p>People who don't use a proof irrelevant prop night think there are two different proofs of (P and Q) implies (P or Q).</p>",
        "id": 197016240,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589062099
    },
    {
        "content": "<p>I was going to object to the phrasing of this statement but I guess it's technically accurate. But the alternative to \"using a proof irrelevant prop\" is \"not using prop\", not \"using a proof relevant prop\" (which is an oxymoron).</p>",
        "id": 197016820,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589062838
    },
    {
        "content": "<p>At least if proof relevance is taken up to propositional equality.</p>",
        "id": 197016829,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589062864
    },
    {
        "content": "<p>One way to think about this that generalizes to higher dimensions is that Props secretly have extra \"truncation constructors\" that assert that any two values of the type are actually equal. When you eliminate out of a Prop you need to say where these truncation constructors go, and there is no way to do that. However, there are two cases where it's fine to omit them:</p>\n<ul>\n<li>when eliminating into another Prop, since then in the target it's also automatically true that any two values are equal;</li>\n<li>when the singleton elimination rule applies (rouhgly, there's at most one constructor), since then you don't need to add the truncation constructors.</li>\n</ul>",
        "id": 197018121,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589064110
    },
    {
        "content": "<p>Can I eliminate or into a subsingleton?</p>",
        "id": 197018197,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589064235
    },
    {
        "content": "<p>No</p>",
        "id": 197018236,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1589064250
    },
    {
        "content": "<p>It's true that definitional proof irrelevance makes this picture a bit murky, which is why you have to imagine the truncation constructors as \"proofs of definitional equality\" or something and they are not expressable in the language.</p>",
        "id": 197018254,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589064309
    },
    {
        "content": "<p>The recursor you get in Lean for a Prop (whether large- or small-eliminating) is sort of the best approximation that you can actually write down.</p>",
        "id": 197018311,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589064399
    },
    {
        "content": "<p>One thing I don't have a very good understanding of is the significance of definitional proof irrelevance versus propositional proof irrelevance. There are quite big differences between the two I think. Understanding this difference is I guess quite important to understanding the downsides of HoTT.</p>",
        "id": 197018384,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1589064555
    },
    {
        "content": "<p>It seems like a big deal to me, but somehow Coq users managed without it for a long time.</p>",
        "id": 197018613,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589064930
    },
    {
        "content": "<p>Are things like the Odd order theorem done in a logic weaker than HoTT?</p>",
        "id": 197018696,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1589065068
    },
    {
        "content": "<p>I think so...</p>",
        "id": 197018703,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589065081
    },
    {
        "content": "<p>well, as far as Prop is concerned anyways</p>",
        "id": 197018766,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589065163
    },
    {
        "content": "<p>I imagine Coq in general has crazy stuff you cannot disable</p>",
        "id": 197018769,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589065185
    },
    {
        "content": "<p>So it's weaker than Coq HoTT right?</p>",
        "id": 197018815,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1589065221
    },
    {
        "content": "<p>oh I understand the question now... I'm not sure.</p>",
        "id": 197018885,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589065367
    },
    {
        "content": "<p>I think you are asking whether you can prove that identity types are subsingletons in Coq, right?</p>",
        "id": 197018900,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589065397
    },
    {
        "content": "<p>It looks like it is an axiom but I don't know whether the Feit-Thompson proof used it. I guess probably. But it seems like the kind of axiom you can just push back onto your hypotheses (e.g., into the definition of \"finite\" group)</p>",
        "id": 197019060,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589065598
    },
    {
        "content": "<p>oh, now I'm reading that it follows from decidable equality</p>",
        "id": 197019076,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589065625
    },
    {
        "content": "<p>My memory of this was that there was a proof irrelevance axiom, but that's not as good as definitional proof irrelevance I don't think.</p>",
        "id": 197019082,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1589065652
    },
    {
        "content": "<p>Right, it's not as good, but the question is how much not as good and/or can you fix it with automation.</p>",
        "id": 197019088,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589065679
    },
    {
        "content": "<p>Is this provable without proof irrelevance. <code>(Π (a b : α) (h₁ h₂ : a = b), subsingleton (h₁ = h₂)) → ∀ a b : α, subsingleton (a = b)</code> This is the key to proving identity types are subsinlgetons with proof irrelevance right? You need that two proofs of equality of equalities are equal?</p>",
        "id": 197019470,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1589066210
    },
    {
        "content": "<p>This is not true in HoTT. A 1-type need not be a 0-type.</p>",
        "id": 197020021,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589066759
    },
    {
        "content": "<p>And this is because you can have topological spaces where the fundamental group at any point is trivial, but it is not path connected, like the disjoint union of path connected spaces?</p>",
        "id": 197020521,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1589067230
    },
    {
        "content": "<p>Well, it's one level up from that, I think...</p>",
        "id": 197020687,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589067406
    },
    {
        "content": "<p>or maybe two levels?</p>",
        "id": 197020701,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589067420
    },
    {
        "content": "<p>You said: Suppose whenever I have two points <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>, and two paths <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">h_1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">h</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>h</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">h_2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">h</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>, and two homotopies between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">h_1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">h</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>h</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">h_2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">h</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, they are equal.</p>",
        "id": 197020821,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589067500
    },
    {
        "content": "<p>So I can't have a space like a 2-sphere, but a circle is fine.</p>",
        "id": 197020847,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589067524
    },
    {
        "content": "<p>I think I should have said simply connected not path connected.</p>",
        "id": 197020943,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1589067625
    },
    {
        "content": "<p>A counterexample to your statement is going to be a something whose loop spaces are discrete but which is not discrete. Like a circle for example</p>",
        "id": 197020955,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589067690
    },
    {
        "content": "<p>By \"discrete\" I mean like an ordinary set without any of this funny homotopy business.</p>",
        "id": 197021007,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589067772
    },
    {
        "content": "<p>Oh yes. I see now. I had an out by one error.</p>",
        "id": 197021059,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1589067870
    },
    {
        "content": "<p>Can you prove <code>eq_of_heq</code> in Coq? This is something that really uses the definitional proof irrelevance right?</p>",
        "id": 197040372,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1589097223
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">universe</span> <span class=\"n\">u</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">eq&#39;</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">eq&#39;</span> <span class=\"n\">a</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">heq&#39;</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">},</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">heq&#39;</span> <span class=\"n\">a</span>\n\n<span class=\"kn\">axiom</span> <span class=\"n\">proof_irrel&#39;</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">eq&#39;</span> <span class=\"n\">α</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">eq&#39;</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"kn\">theorem</span> <span class=\"n\">eq_of_heq&#39;</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">heq&#39;</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">eq&#39;</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@@</span><span class=\"n\">heq&#39;</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">β</span> <span class=\"n\">b</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">h&#39;</span> <span class=\"o\">:</span> <span class=\"n\">eq&#39;</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">eq&#39;</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">h&#39;</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">eq&#39;</span> <span class=\"n\">α</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"o\">(</span><span class=\"n\">proof_irrel&#39;</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">rfl</span> <span class=\"n\">h₂</span><span class=\"o\">)</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 197041519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589099020
    }
]
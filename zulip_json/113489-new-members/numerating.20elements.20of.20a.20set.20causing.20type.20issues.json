[
    {
        "content": "<p>Hello everyone,</p>\n<p>I defined a directed walk in a directed graph with start and ending points in V. However, I would like to have a path which starting and ending points are in A and B, respectively. Additionally, as I want to define n different path, I want to numerate the elements in A.verts and B.verts by making them a list. But then the nth member of that list hast the wrong type to be plugged in the direct walk. Here a MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">directed_simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">):=</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">directed_simple_graph</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[derive decidable_eq]</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">directed_walk</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">directed_walk</span> <span class=\"n\">u</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">directed_walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">directed_walk</span> <span class=\"n\">u</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">vertex_subset_n</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">verts</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">card</span> <span class=\"o\">:</span> <span class=\"n\">verts.card</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">vertex_subset_n</span> <span class=\"n\">n</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">directed_walk</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">start</span> <span class=\"o\">:</span> <span class=\"n\">A.verts</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">finish</span> <span class=\"o\">:</span> <span class=\"n\">B.verts</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.directed_walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">p2</span> <span class=\"o\">:</span> <span class=\"n\">G.directed_walk</span> <span class=\"n\">start</span> <span class=\"n\">finish</span><span class=\"o\">}</span> <span class=\"c1\">--works but start and end point are not numerated</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">A.verts</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_list.nth</span> <span class=\"mi\">1</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">p3</span> <span class=\"o\">:</span> <span class=\"n\">directed_walk</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"c1\">-- does not work</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">directed_walk</span>\n<span class=\"kd\">end</span> <span class=\"n\">directed_simple_graph</span>\n</code></pre></div>\n<p>The knowledge that <code>.nth 0</code> up to <code>.nth (n-1)</code> is a member of the list :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">A_verts_list_length_eq_n</span> <span class=\"o\">:</span> <span class=\"n\">A.verts.to_list.length</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>  <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">finset.length_to_list</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"n\">A.card</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>How can I combine those such that I can numerate my start and end points, as it is important to differentiate between different ones ?<br>\nAny help is appreciated.</p>",
        "id": 321618475,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673868864
    },
    {
        "content": "<p>I didn't read your code so my answer is possibly OT, but I wanna say that <code>list.nth</code> and <code>list.nth_le</code> indexes elements from zero.</p>",
        "id": 321618750,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1673868957
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321618750\">schrieb</a>:</p>\n<blockquote>\n<p>I didn't read your code so my answer is possibly OT, but I wanna say that <code>list.nth</code> and <code>list.nth_le</code> indexes elements from zero.</p>\n</blockquote>\n<p>Thats true, but unfortunately not helpful. Nevertheless, edited the last part, should be correct now.</p>",
        "id": 321619226,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673869071
    },
    {
        "content": "<p>Can we <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> this? What is the main theorem you're wanting to prove? You're getting into territory where it's helpful to know the goal.</p>",
        "id": 321620031,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673869284
    },
    {
        "content": "<p>Also, having a universe <code>u</code> and a \"graph vertex <code>u</code>\" is probably not a good idea.</p>",
        "id": 321620883,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1673869544
    },
    {
        "content": "<p>Is there a way to make the compiler complain about these name collisions?</p>",
        "id": 321621222,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1673869665
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321620031\">schrieb</a>:</p>\n<blockquote>\n<p>Can we <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> this? What is the main theorem you're wanting to prove? You're getting into territory where it's helpful to know the goal.</p>\n</blockquote>\n<p>Fair enough.<br>\nWell I am trying to formalize the Lindström Gessel Viennot Lemma as a bachelor thesis (therefore all the directed stuff). So I am working on establishing all the necessary objects which are weights, weight of a walk, path system, weight of path system, path matrix.</p>\n<p>The current goal is to define the structure of a (vertex disjoint) path system which needs </p>\n<ul>\n<li>a permutation s and its sign</li>\n<li>n paths p_i : A_i \\to B_s(i), whereas A and B are subsets of the vertices of cardinality n<br>\n(- vertex disjointness of the paths)</li>\n</ul>\n<p>Therefor the effort to numerate A.verts and B.verts and get the correct elements as an input for direct walks.</p>",
        "id": 321621638,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673869803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321620883\">said</a>:</p>\n<blockquote>\n<p>Also, having a universe <code>u</code> and a \"graph vertex <code>u</code>\" is probably not a good idea.</p>\n</blockquote>\n<p>Maybe not, but for better or for worse we've been doing this in mathlib code throughout the graph library and its seems to work out fine</p>",
        "id": 321644888,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673876900
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"573061\">@Christopher Schmidt</span> I'm not sure I understand exactly what you're trying to do yet (what does it mean to <em>numerate</em> a set?), but maybe it's helpful to know that the way we talk about ordered finite lists of elements is either <code>f : fin n -&gt; V</code> or the combination <code>[fintype α]</code> with <code>f : α -&gt; V</code>. Sometimes we use a coercion, where <code>s : finset α</code> and then use <code>f : s -&gt; V</code>.</p>",
        "id": 321645574,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673877101
    },
    {
        "content": "<p>Then when you have a pair of such a family of elements (for example <code>[fintype α]</code> with <code>f g : α -&gt; V</code>), you can work with <code>Π (i : α), G.directed_walk (f i) (g i)</code>, which is an <code>α</code>-indexed family of walks.</p>",
        "id": 321646478,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673877371
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"417654\">@Martin Dvořák</span> I see your <span aria-label=\"prohibited\" class=\"emoji emoji-1f6ab\" role=\"img\" title=\"prohibited\">:prohibited:</span>, but universe level variables and normal variables are in different namespaces, so it can't cause problems for Lean at least.</p>",
        "id": 321646864,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673877483
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"573061\">Christopher Schmidt</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321621638\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321620031\">schrieb</a>:</p>\n<blockquote>\n<p>Can we <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> this? What is the main theorem you're wanting to prove? You're getting into territory where it's helpful to know the goal.</p>\n</blockquote>\n<p>Fair enough.<br>\nWell I am trying to formalize the Lindström Gessel Viennot Lemma as a bachelor thesis (therefore all the directed stuff). So I am working on establishing all the necessary objects which are weights, weight of a walk, path system, weight of path system, path matrix.</p>\n<p>The current goal is to define the structure of a (vertex disjoint) path system which needs </p>\n<ul>\n<li>a permutation s and its sign</li>\n<li>n paths p_i : A_i \\to B_s(i), whereas A and B are subsets of the vertices of cardinality n<br>\n(- vertex disjointness of the paths)</li>\n</ul>\n<p>Therefor the effort to numerate A.verts and B.verts and get the correct elements as an input for direct walks.</p>\n</blockquote>\n<p>Let's rather focus on the question.</p>",
        "id": 321647292,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1673877603
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321645574\">schrieb</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"573061\">Christopher Schmidt</span> I'm not sure I understand exactly what you're trying to do yet (what does it mean to <em>numerate</em> a set?), but maybe it's helpful to know that the way we talk about ordered finite lists of elements is either <code>f : fin n -&gt; V</code> or the combination <code>[fintype α]</code> with <code>f : α -&gt; V</code>. Sometimes we use a coercion, where <code>s : finset α</code> and then use <code>f : s -&gt; V</code>.</p>\n</blockquote>\n<p>Maybe, what I have got by now, illustrates my issue more clearly.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">path_system</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">vertex_subset_n</span> <span class=\"n\">n</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">equiv.perm</span> <span class=\"o\">(</span><span class=\"n\">finset.range</span> <span class=\"n\">n</span><span class=\"o\">)}</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">start_pts</span> <span class=\"o\">:=</span> <span class=\"n\">A.verts</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">finish_pts</span> <span class=\"o\">:</span> <span class=\"n\">B.verts</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">start</span>  <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">A.verts</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span> <span class=\"c1\">-- λ i, A.verts.to_list.nth i</span>\n<span class=\"o\">(</span><span class=\"n\">finish</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">B.verts</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span> <span class=\"c1\">-- λ i, B.verts_to_list.nth σ(i)</span>\n<span class=\"o\">(</span><span class=\"n\">n_walks</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">G.directed_walk</span> <span class=\"n\">start_pt</span> <span class=\"n\">finish_pt</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">G.directed_walk</span> <span class=\"n\">start_pt</span> <span class=\"n\">finish_pt</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">start_pt</span> <span class=\"bp\">=</span> <span class=\"n\">start</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">finish_pt</span> <span class=\"bp\">=</span> <span class=\"n\">finish</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)})</span>\n<span class=\"o\">(</span><span class=\"n\">sgn</span> <span class=\"o\">:=</span> <span class=\"n\">σ.sign</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I somehow want to manage that the starting and ending point of a walk are precisely the corresponding ones in the following sense:<br>\nn_walk (i) goes from i to \\sigma(i).<br>\nTherefore, I need to be able to numerate the elements of A and B. But a list as suggested in the comments cuases type issues. Is there a way out of this arising type issue ?</p>\n<p>I also thought about leaving away the \\sigma and just claim that any starting and ending point of A and B is only used once. However, I need the concrete bijection as I need the sign.</p>",
        "id": 321652264,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673878796
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321646478\">said</a>:</p>\n<blockquote>\n<p>Then when you have a pair of such a family of elements (for example <code>[fintype α]</code> with <code>f g : α -&gt; V</code>), you can work with <code>Π (i : α), G.directed_walk (f i) (g i)</code>, which is an <code>α</code>-indexed family of walks.</p>\n</blockquote>\n<p>Let me mention this again, since this is how you can have a system of walks that go between corresponding vertices.</p>",
        "id": 321653671,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673879118
    },
    {
        "content": "<p>There are a few formulations of this, but this is the general idea.</p>",
        "id": 321653754,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673879136
    },
    {
        "content": "<p>In Lean, you usually have to translate things from set theory to type theory. Oftentimes, if you see \"a finite set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{a_1,\\dots,a_n\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span>\" it's better to translate it to \"a function <code>f : fin n -&gt; A</code>\" rather than speak of sets at all.</p>",
        "id": 321654149,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673879236
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321653754\">schrieb</a>:</p>\n<blockquote>\n<p>There are a few formulations of this, but this is the general idea.</p>\n</blockquote>\n<p>Ok thank you. I thought its just shifting the problem to defining the sign, but I will try.</p>",
        "id": 321654413,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673879301
    },
    {
        "content": "<p>The sign of a permutation should already exist somewhere in mathlib.</p>",
        "id": 321654487,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673879320
    },
    {
        "content": "<p>Unless you're talking about defining a new concept, like a sign of a path system or something.</p>",
        "id": 321654637,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673879358
    },
    {
        "content": "<p>Oh, I see, you already found <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.perm.sign\">docs#equiv.perm.sign</a></p>",
        "id": 321654837,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673879407
    },
    {
        "content": "<p>Yes. Well, I better try to use your suggested approach with f and g and hoepfully get the points and sign right. <br>\nThanks again.<br>\nI apologize if I have not stated the problem properly and/or wasted your time.</p>",
        "id": 321656255,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673879729
    },
    {
        "content": "<p>Getting right type definitions at the beginning is a difficult part of formalization.</p>\n<p>If you haven't done it already, you should try to very carefully specify as formally as possible what it is you're trying to enter into Lean. This will likely help you with what you're doing, but also as you get stuck you can point to a part of this \"blueprint\" to get more precise help.</p>",
        "id": 321657875,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673880159
    },
    {
        "content": "<p>Combinatorics is already more difficult to formalize than abstract math since it tends to be done more informally on paper since the objects are more intuitive. You have to do the paper formalization yourself here before it's as amenable to formalization.</p>",
        "id": 321658213,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673880246
    },
    {
        "content": "<p>This takes some thinking (or more likely, experimentation) with how this will interact with how the definitions will be used in your theorems. That can be hard to think about though if you haven't gotten to thinking carefully about the theorems because you don't have formalized definitions, which points toward why definitions can be hard.</p>",
        "id": 321658504,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673880331
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> <br>\nI have noticed that and could not agree more. As it is my first Lean project, it takes a lot of nerve. <br>\nI largely appreciate your consistent help.</p>",
        "id": 321659803,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673880683
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"573061\">@Christopher Schmidt</span> Here's a start:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">logic.equiv.fintype</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.perm.sign</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">directed_simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">):=</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">directed_simple_graph</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[derive decidable_eq]</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">directed_walk</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">directed_walk</span> <span class=\"n\">u</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">directed_walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">directed_walk</span> <span class=\"n\">u</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">directed_walk.support</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"n\">G.directed_walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">V</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">v</span> <span class=\"n\">directed_walk.nil</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">v</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"n\">u</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">directed_walk.cons</span> <span class=\"n\">h</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">u</span> <span class=\"o\">::</span> <span class=\"n\">p.support</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">path_system</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">↪</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">B'</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">↪</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">range_B'</span> <span class=\"o\">:</span> <span class=\"n\">set.range</span> <span class=\"n\">B'</span> <span class=\"bp\">=</span> <span class=\"n\">set.range</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">walk</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">G.directed_walk</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B'</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">walk_disj</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"n\">list.disjoint</span> <span class=\"o\">(</span><span class=\"n\">walk</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"o\">(</span><span class=\"n\">walk</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">}</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">path_system.σ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">↪</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">G.path_system</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">equiv.of_injective</span> <span class=\"n\">s.B'</span> <span class=\"n\">s.B'.inj'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n  <span class=\"o\">((</span><span class=\"n\">equiv.set.of_eq</span> <span class=\"n\">s.range_B'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">equiv.of_injective</span> <span class=\"n\">B</span> <span class=\"n\">B.inj'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">path_system.sign</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">↪</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">G.path_system</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">equiv.perm.sign</span> <span class=\"n\">s.σ</span>\n</code></pre></div>",
        "id": 321662556,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673881511
    },
    {
        "content": "<p>Another design for <code>path_system</code> could have been to include sigma as a permutation on <code>α</code> or as a permutation on <code>set.range B</code>.</p>",
        "id": 321662992,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673881625
    },
    {
        "content": "<p>But you don't need anything saying it's a <em>finite</em> system of paths in any case. That only comes in for <code>sign</code>.</p>",
        "id": 321663122,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673881662
    },
    {
        "content": "<p>For another example of this idea of generalizing indices so that you take an arbitrary index type rather than just the set of 1,...,n, take a look at <a href=\"https://github.com/leanprover-community/mathlib/blob/9003f28797c0664a49e4179487267c494477d853/src/data/matrix/basic.lean#L54\">matrix</a>. Matrices are indexed by arbitrary types, not numbers.</p>",
        "id": 321663753,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673881828
    },
    {
        "content": "<p>(Also, quick disclaimer, I just read the wikipedia page for the theorem and wrote up these definitions. They might be wrong or unoptimal for any number of reasons, but hopefully it's in the right direction.)</p>",
        "id": 321664474,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673882020
    },
    {
        "content": "<p>Just for illustration, an option using sigma. I can't tell immediately whether this is better or worse than the previous definition.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">path_system</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">↪</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">equiv.perm</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">walk</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">G.directed_walk</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n<span class=\"o\">(</span><span class=\"n\">walk_disj</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"n\">list.disjoint</span> <span class=\"o\">(</span><span class=\"n\">walk</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"o\">(</span><span class=\"n\">walk</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- This definition is not actually necessary since one can write `s.σ.sign` just as easily as `s.sign`.</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">path_system.sign</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">↪</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">G.path_system</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">s.σ.sign</span>\n</code></pre></div>",
        "id": 321665950,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673882379
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321644888\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321620883\">said</a>:</p>\n<blockquote>\n<p>Also, having a universe <code>u</code> and a \"graph vertex <code>u</code>\" is probably not a good idea.</p>\n</blockquote>\n<p>Maybe not, but for better or for worse we've been doing this in mathlib code throughout the graph library and its seems to work out fine</p>\n</blockquote>\n<p>Living on the directed edge!  <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 321682611,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1673887693
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321658213\">said</a>:</p>\n<blockquote>\n<p>Combinatorics is already more difficult to formalize than abstract math since it tends to be done more informally on paper since the objects are more intuitive. You have to do the paper formalization yourself here before it's as amenable to formalization.</p>\n</blockquote>\n<p>I would even phrase it as \"Combinatorics is harder to formalise than other subjects until you understand why it is easy\"</p>",
        "id": 321696556,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673893183
    },
    {
        "content": "<p>I am having a lot of success formalising combinatorics now, but this took two years of trying.</p>",
        "id": 321696738,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673893251
    },
    {
        "content": "<p>I would be very interested in writing a chapter of the new Mathematics in Lean book on how to formalise combinatorics.</p>",
        "id": 321696826,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673893293
    },
    {
        "content": "<p>You could use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pairwise\">docs#pairwise</a> for <code>walk_disj</code>.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321646864\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> I see your <span aria-label=\"prohibited\" class=\"emoji emoji-1f6ab\" role=\"img\" title=\"prohibited\">:prohibited:</span>, but universe level variables and normal variables are in different namespaces, so it can't cause problems for Lean at least.</p>\n</blockquote>\n<p>If universe variables clash with declaration names you get trouble though. Last time I changed <code>v'</code> to <code>w</code> in <a href=\"https://github.com/leanprover-community/mathlib/blob/9003f28797c0664a49e4179487267c494477d853/src/topology/sheaves/sheaf_condition/equalizer_products.lean#L23\">this file</a> I got weird errors when Lean got to line 76 (<code>lemma w</code>).</p>",
        "id": 321707606,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1673897844
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> I tried two things:</p>\n<ol>\n<li>I changed that lemma to <code>lemma w'</code>, and there was no error.</li>\n<li>I renamed the universe variable from <code>v'</code> to <code>w</code>, and then both <code>res_π</code> and <code>w</code> had a universe variable error. Removing the <code>@[elementwise]</code> attribute, though, removes the error.</li>\n</ol>\n<p>It seems more likely to me that there is some subtle bug in that attribute.</p>",
        "id": 321708999,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673898565
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/9003f28797c0664a49e4179487267c494477d853/src/tactic/elementwise.lean#L100\">This line</a> might be why having a universe variable that's a <code>w</code> is a problem.</p>",
        "id": 321709281,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673898711
    },
    {
        "content": "<p>Universes are in a different namespace, so <code>get_unused_name_reserved</code> doesn't seem like the right way to get a fresh universe variable name.</p>",
        "id": 321709618,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673898855
    },
    {
        "content": "<p>Oh! So it's just a red herring that the lemma is named <code>w</code>.</p>",
        "id": 321709658,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1673898878
    },
    {
        "content": "<p>Thanks for the diagnosis!</p>",
        "id": 321709701,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1673898901
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321696738\">said</a>:</p>\n<blockquote>\n<p>I am having a lot of success formalising combinatorics now, but this took two years of trying.</p>\n</blockquote>\n<p>I suspect that if I now redid my <a href=\"https://github.com/jsm28/bmo2-2020-lean/blob/master/src/p3.lean\">formalization of British MO 2020 round 2 problem 3</a> it would be rather less than 3000 lines of Lean for a not-very-hard combinatorics problem (that was the third Lean formalization I ever did after NNG).</p>",
        "id": 321711866,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673899953
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321665950\">schrieb</a>:</p>\n<blockquote>\n<p>Just for illustration, an option using sigma. I can't tell immediately whether this is better or worse than the previous definition.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">path_system</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">↪</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">equiv.perm</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">walk</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">G.directed_walk</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n<span class=\"o\">(</span><span class=\"n\">walk_disj</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"n\">list.disjoint</span> <span class=\"o\">(</span><span class=\"n\">walk</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"o\">(</span><span class=\"n\">walk</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- This definition is not actually necessary since one can write `s.σ.sign` just as easily as `s.sign`.</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">path_system.sign</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">↪</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">G.path_system</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">s.σ.sign</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thanks for the effort! Thats more than one could as for. I will implement both versions and see which is more practical.</p>",
        "id": 321712892,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673900470
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321696826\">said</a>:</p>\n<blockquote>\n<p>I would be very interested in writing a chapter of the new Mathematics in Lean book on how to formalise combinatorics.</p>\n</blockquote>\n<p>This could be nice if it fits with the style of other parts. You can write something anyway, and then decide what to do with it.</p>",
        "id": 321782132,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1673946317
    },
    {
        "content": "<p>Where can I see the current progress on the book?</p>",
        "id": 321782384,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673946401
    },
    {
        "content": "<p>I'm not sure I understand the question, but the source is at <a href=\"https://github.com/avigad/mathematics_in_lean_source/\">https://github.com/avigad/mathematics_in_lean_source/</a></p>",
        "id": 321782513,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1673946447
    },
    {
        "content": "<p>I am simply trying to get a sense of what \"the style of other parts\" is</p>",
        "id": 321782825,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673946570
    },
    {
        "content": "<p>I just Google for mathematics in lean to find it</p>",
        "id": 321783552,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1673946810
    },
    {
        "content": "<p>Ah! I understand the confusion now. I thought there was some Mathematics in Lean 4 whose writing was underway.</p>",
        "id": 321785238,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673947358
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  I have added the following to your first approach :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"o\">(</span><span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">partial_order.lift</span> <span class=\"n\">adj</span> <span class=\"n\">ext</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">edge_set</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span> <span class=\"bp\">↪</span><span class=\"n\">o</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">order_embedding.of_map_le_iff</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span> <span class=\"bp\">|</span> <span class=\"n\">G.adj</span> <span class=\"n\">p.1</span> <span class=\"n\">p.2</span><span class=\"o\">})</span> <span class=\"bp\">$</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">G</span> <span class=\"n\">G'</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">set.le_eq_subset</span><span class=\"o\">,</span> <span class=\"n\">set.set_of_subset_set_of</span><span class=\"o\">,</span> <span class=\"n\">prod.forall</span><span class=\"o\">],</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">directed_walk</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">↪</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">weight</span> <span class=\"o\">:</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">walk_weight</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">weight</span> <span class=\"o\">:</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n<span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"n\">G.directed_walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span>\n<span class=\"bp\">|</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">h</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">weight</span> <span class=\"o\">⟨(</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">*</span> <span class=\"n\">walk_weight</span> <span class=\"n\">p</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">path_system_weight</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">weight</span> <span class=\"o\">:</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">↪</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">G.path_system</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∏</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">walk_weight</span> <span class=\"o\">(</span><span class=\"n\">s.walk</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"c1\">-- not working</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">G.path_system</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"k\">#check</span> <span class=\"n\">walk_weight</span> <span class=\"o\">(</span><span class=\"n\">s.walk</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"c1\">-- works</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">directed_walk</span>\n</code></pre></div>\n<p>I do not understand, why it is not working in the first but working in the second case. What have I messed up again?</p>",
        "id": 321805706,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673954150
    },
    {
        "content": "<p>The opening statement being at the begining of the file after imports.</p>",
        "id": 321805814,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673954185
    },
    {
        "content": "<p>What's the error?</p>",
        "id": 321806557,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673954455
    },
    {
        "content": "<p>(Without running any code, I'm guessing it's that you don't have <code>[fintype α]</code>, which you need to take a product like that.)</p>",
        "id": 321806659,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673954491
    },
    {
        "content": "<p>Design suggestion: make <code>weight</code> an explicit variable since it can't be inferred from the other arguments.</p>",
        "id": 321806773,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673954526
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321806773\">schrieb</a>:</p>\n<blockquote>\n<p>Design suggestion: make <code>weight</code> an explicit variable since it can't be inferred from the other arguments.</p>\n</blockquote>\n<p>Had the fintype, but this solved the issue. I do not get how but now it seems to work. Thanks !</p>",
        "id": 321807651,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673954844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"573061\">Christopher Schmidt</span> has marked this topic as resolved.</p>",
        "id": 322031423,
        "sender_full_name": "Notification Bot",
        "timestamp": 1674042134
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"573061\">Christopher Schmidt</span> has marked this topic as unresolved.</p>",
        "id": 322058017,
        "sender_full_name": "Notification Bot",
        "timestamp": 1674050200
    },
    {
        "content": "<p>Hello everyone I am running into a type issue again,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">directed_walk</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">↪</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">new_weight</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">↪</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">weight</span> <span class=\"o\">:</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">path_matrix</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">↪</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">weight</span> <span class=\"o\">:</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">new_weight</span> <span class=\"n\">weight</span> <span class=\"o\">(</span><span class=\"n\">G.directed_path</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"c1\">-- error : failed to synthesize class instance for ... ⊢ field R</span>\n\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">weight</span> <span class=\"o\">:</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"k\">#check</span> <span class=\"n\">G.directed_path</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"c1\">-- Type u</span>\n<span class=\"k\">#check</span> <span class=\"n\">new_weight</span> <span class=\"n\">weight</span> <span class=\"o\">(</span><span class=\"n\">G.directed_path</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"c1\">-- type R</span>\n<span class=\"kd\">end</span> <span class=\"n\">directed_walk</span>\n</code></pre></div>\n<p>the <code>new_weight weight (G.directed_path (A i) (B j))</code> is type R as shown below but the def of \"path matrix\" does not work. I do not understand how this is possible. Anyone got an idea?</p>",
        "id": 322060059,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1674050694
    },
    {
        "content": "<p>You have <code>variable {R : Type} [field R]</code> so that R is a field, but you have <code>def path_matrix... {R : Type}...</code> and this means \"use a new R which isn't a field\".</p>",
        "id": 322077964,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674055093
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/322077964\">schrieb</a>:</p>\n<blockquote>\n<p>You have <code>variable {R : Type} [field R]</code> so that R is a field, but you have <code>def path_matrix... {R : Type}...</code> and this means \"use a new R which isn't a field\".</p>\n</blockquote>\n<p>Thank you.</p>",
        "id": 322087859,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1674057408
    }
]
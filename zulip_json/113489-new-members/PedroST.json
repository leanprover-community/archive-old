[
    {
        "content": "<p>Hi, I'm new here... introducing myself as expected.</p>",
        "id": 205964784,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1596577459
    },
    {
        "content": "<p>I'm a mathematician from Argentina and I'm partly working on formalization. For that two reasons I got curious about Lean.</p>",
        "id": 205965018,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1596577604
    },
    {
        "content": "<p>What area of maths do you work in?</p>",
        "id": 205965477,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596577906
    },
    {
        "content": "<p>Hi! I'm working in mathematical logic, did my PhD in Universal Algebra and now going into Set Theory, mostly applications of Descriptive S.T.</p>",
        "id": 205965682,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1596578064
    },
    {
        "content": "<p>Mainly, those applications are to theoretical comp. sci.</p>",
        "id": 205965837,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1596578174
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> was asking questions about universal algebra on the Discord today</p>",
        "id": 205966267,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596578464
    },
    {
        "content": "<p>If it is something close to the topics I studied, I'd be glad to answer here (though I would also strongly suggest to ask on <a href=\"http://math.stackexchange.com\">math.stackexchange.com</a>, I know at least one extremely good expert that visits often).</p>",
        "id": 205966819,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1596578766
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"327749\">@Pedro Sánchez Terraf</span> and <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> : I've done (and still doing) some basic stuff with universal algebra with <span class=\"user-mention\" data-user-id=\"315523\">@Colter MacDonald</span> in lean. We have a repo here: <a href=\"https://github.com/adamtopaz/UnivAlg\">https://github.com/adamtopaz/UnivAlg</a> in case you find it interesting/useful.</p>",
        "id": 205966937,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596578846
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> Thanks, I'll take a look</p>",
        "id": 205967142,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1596578984
    },
    {
        "content": "<p>And since you're now a set theorist, you would probably be interested in flypitch (if you don't already know about it): <a href=\"https://flypitch.github.io/\">https://flypitch.github.io/</a></p>",
        "id": 205967150,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596578989
    },
    {
        "content": "<p>They are actually my direct competitors :-)... We were also formalizing forcing, but in Isabelle.</p>",
        "id": 205967218,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1596579033
    },
    {
        "content": "<p>Ah!</p>",
        "id": 205967240,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596579055
    },
    {
        "content": "<p>We're not done yet, our approach is rather different. But I'm aware of their work</p>",
        "id": 205967260,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1596579070
    },
    {
        "content": "<p>Yesterday's competitors are today's collaborators :)</p>",
        "id": 205967261,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596579070
    },
    {
        "content": "<p>Hi Mario!</p>",
        "id": 205967272,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1596579080
    },
    {
        "content": "<p>I think it's a great idea to formalise serious maths in several provers, so we can figure out what is best at what.</p>",
        "id": 205967283,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596579089
    },
    {
        "content": "<p>So sorry, I have to leave for while, my family arrived and have some obligations.<br>\nBtw, very nice talk at CICM, <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> . I also feel sympathetic, I've been at math Olympiads at my country :-) See you in while, or tomorrow.</p>",
        "id": 205967462,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1596579198
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> By the way, the rest of my team (Emmanuel Gunther and Miguel Pagano) were also working on the formalization of UA, but this time without me and in Agda.</p>",
        "id": 205969779,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1596580939
    },
    {
        "content": "<p>I love agda. But I'm not experienced enough with actually using it.</p>",
        "id": 205970369,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596581356
    },
    {
        "content": "<p>Universal Algebra ought to not only be formalized in a theorem prover, it ought to be 'internalized' too. Its constructions work so well (and uniformly), that they should be kept to the meta-level. Much too useful to be segregated just there.</p>",
        "id": 205977717,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1596588205
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"326322\">@Jacques Carette</span> I think I'm not familiar enough with ITP terminology  to fully understand the meaning of \"internalized\",  I'd be grateful for any pointer to the literature.</p>",
        "id": 205978089,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1596588692
    },
    {
        "content": "<p>I mean that it ought to be able to operate on Lean theories to output Lean theories (say for the homomorphism construction). But that is currently metaprogramming of the kind that is not (yet) available. Or has that changed?  Last I look metaprogramming in Lean was restricted to the proof monad.</p>",
        "id": 205978446,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1596589086
    },
    {
        "content": "<p>I also don't know what \"internalized\" means, but I still completely agree! I started that UnivAlg repository as an experiment because it felt silly to repeat all these free constructions from universal algebra (and some basic ones still seem to be missing from mathlib, like the free algebra on a multiplicative monoid with an absorbing zero, which I wanted for other reasons). In this case the internalization can probably be accomplished with some metaprogramming</p>",
        "id": 205978465,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596589131
    },
    {
        "content": "<p>Oh, just saw the new comment!</p>",
        "id": 205978498,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596589177
    },
    {
        "content": "<p>[I'm also \"cheating\" here, as I've been working on that for a while. See the paper at CICM 2020 for an example of the work that's already done. Just not in Lean. Not quite in Agda either as, although it comes closer, it still doesn't let one create fresh names that escape their scope.]</p>",
        "id": 205978648,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1596589337
    },
    {
        "content": "<p>i think this kind of thing is in scope for current lean metaprogramming</p>",
        "id": 205979176,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596590126
    },
    {
        "content": "<p>one of the more advanced things I know of in this direction is <code>to_additive</code></p>",
        "id": 205979835,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596591293
    },
    {
        "content": "<p>i think it is true that this kind of metaprogramming will be easier in lean 4, and indeed the community will have to learn about new metaprogramming stuff in order to port mathlib</p>",
        "id": 205979858,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596591359
    },
    {
        "content": "<p>I think a fairly low-hanging piece of universal algebra / metaprogramming might be to automate the construction of colimits in algebraic categories, i.e. writing Lean commands that synthesize most or all of <a href=\"https://github.com/leanprover-community/mathlib/blob/84b450d/src/algebra/category/Group/colimits.lean\">https://github.com/leanprover-community/mathlib/blob/84b450d/src/algebra/category/Group/colimits.lean</a> just looking at the definitions of <code>add_comm_group</code> and <code>monoid_hom</code>. But it's not clear to me it's really worth the effort. :-)</p>",
        "id": 205980448,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596592152
    },
    {
        "content": "<p>One could also \"do more theory\" first (Lawvere theories).</p>",
        "id": 205980473,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596592187
    },
    {
        "content": "<p>It's all about scale.  From ~300 lines of Tog (a toy Agda-like language), my PhD student Yasmine can generate slightly over 10,000 lines of Tog that in all systems we know about need to be written out by human beings.  We're working a DSL to control the generation (you don't really want all that stuff by default). Homomorphisms, 4 different variations of term algebras, products, logical relations, and more, are all \"free\". Why would we force humans to write them out by hand once we know they don't have to?</p>",
        "id": 205980847,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1596592756
    },
    {
        "content": "<p>[I've tried to do Lawvere Theories in Agda. I didn't get far. Most of the stuff out there is seriously thin on details, and I chose to not use the (evil) skeletal version, and that made things worse. I don't think any of what's out there is wrong, just massively detail-poor.]</p>",
        "id": 205980951,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1596592871
    },
    {
        "content": "<p>What do you mean by the \"evil\" skeletal version of Lawvere theories?</p>",
        "id": 205982138,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596594423
    },
    {
        "content": "<p>Oh, is this just referring to a choice of a skeleton for the category of finite sets?</p>",
        "id": 205982232,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596594565
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>  Yes. I was trying to see if I could get away without artificial choices like that. Mostly, yes. In that case, I got thoroughly stuck. I think it's my problem. Not sure who to ask though - most don't have the patience for these kinds of concerns.</p>",
        "id": 205982532,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1596594975
    },
    {
        "content": "<p>maybe someone on the category theory zulip would offer some patience</p>",
        "id": 205982853,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596595473
    },
    {
        "content": "<p>Jacques, I have two questions about your description of your work. First, did you look at what Cyril and his coauthors did in <a href=\"https://hal.archives-ouvertes.fr/hal-02478907v4\">this paper</a> which is also about fighting boilerplate while writing algebraic theories, but maybe in another direction? This whole story seems pretty important to me, and it would be nice to have a specification language independent from the target proof assistant. My second question may sound polemic but I'm really curious so I hope it won't sound aggressive. Since you seem really interested in mathematics, why do you use Agda which is openly a type theory playground and programming language much more than a proof assistant (and is basically not used for maths compared to Mizar, Coq, Isabelle and Lean)?</p>",
        "id": 206007937,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596624054
    },
    {
        "content": "<p>I also have a question for Pedro, a very naive one since  I know nothing about foundations and set theory. You wrote that you use Isabelle/ZF to formalize forcing. Isn't it harder to prove things about set theory in a proof assistant based on set theory? Naively I expect it to be much harder to separate the meta-theory from the theory in this setup. Type theory naturally seems more neutral with respect to axioms of set theory.</p>",
        "id": 206008072,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596624222
    },
    {
        "content": "<p>Most set theory is done in set theory, even more explicitly than the usual hat tip to ZFC you see elsewhere</p>",
        "id": 206008268,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596624393
    },
    {
        "content": "<p>Also Lean definitely isn't neutral with respect to the axioms of set theory (it proves ZFC!)</p>",
        "id": 206008307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596624468
    },
    {
        "content": "<p>Flypitch was IIRC mainly a problem of how to rephrase all the constructions of meta-set theory from set theory (where these people all worked) to type theory, often quite nontrivially</p>",
        "id": 206008431,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596624594
    },
    {
        "content": "<p>For example a \"countable transitive model of ZFC\" is a very common concept in meta-set theory but it doesn't make any sense in type theory (because \"transitive model\" talks about the relation between the model's epsilon and the real epsilon, and the latter doesn't exist in type theory)</p>",
        "id": 206008574,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596624738
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> for your question. Mario's observations are all correct. Let me put some detail.<br>\nOne of the appealing features of forcing is that it enables you to prove rather basic/fundamental stuff by working with the full machinery of set theory. </p>\n<p>In a nutshell, assuming that ZFC is consistent, you want to prove that ZFC + ¬CH is consistent (the assumption is necessary by Gödel's second thm). Naively, this amounts to assuming you have a model M of ZFC, and you need to construct some model N of ZFC + ¬CH. Forcing lets you do this in a rather canonical way (akin to adding a new element G which is “transcendental” over M). Now, some logical manipulations translate this model-theoretic construction to finitary one: you end up with a proof (assuming only arithmetic) that there is no proof of contradiction from the axioms of ZFC+¬CH, if there wasn't one from ZFC.</p>",
        "id": 206016235,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1596630779
    },
    {
        "content": "<p>Our formalization work focuses on the model-theoretic part of the argument, that is, forcing as a tool to extend (countable transitive) models of ZFC, and our results are proved in ZF. This <strong>does not</strong> gives us finitary consistency proofs, but are framework does not assume more than needed. </p>\n<p>Type theories like the ones that support Lean and Coq assume much more than that (due to the availability of universes). In that sense, they are “more likely to be inconsistent” (though nobody believe they are). It is just that if you want to formalize (relative) consistency results as above, you have to start with a really poor metatheory.</p>\n<p>All that said, working on Isabelle/<strong>ZF</strong> is especially laborious, since it lacks the full automation of the usual Isabelle logic (HOL), yet.</p>",
        "id": 206016893,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1596631293
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> I'll answer your first question here (it doesn't highjack this thread too much) and start a new one for the other.  I am well aware of that paper - chronologically it appeared <strong>after</strong> the authors saw <a href=\"https://www.cas.mcmaster.ca/~carette/publications/Dagstuhl_Aug20_2018.pdf\">my talk</a> in August 2018 at a Dagstuhl meeting on formalizing mathematics in type theory, where I showed a lot of my work on boilerplate elimination.  My current work (with Yasmine Sharoda and Bill Farmer) aims for just that: a language-independent specification language for algebraic theories. See <a href=\"https://arxiv.org/abs/2006.09292\">Leveraging the Information Contained in Theory Presentations</a> presented at the latest CICM for the details. The prototype is on github (<a href=\"https://github.com/ysharoda/tog\">https://github.com/ysharoda/tog</a>). We embed it into Tog, but that's just because we didn't want to write a type checker for a dependently typed language with modules from scratch, and also be able to program it easily [so the fact that it's written in Haskell is a big plus.] Yasmine's next task is to write back-ends that target other languages, to show that it is indeed system-independent.</p>",
        "id": 206087419,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1596667798
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"326322\">@Jacques Carette</span> please ping for your next answer!</p>",
        "id": 206090999,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1596671172
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"327749\">@Pedro Sánchez Terraf</span> It's in the \"Why Agda?\" thread.</p>",
        "id": 206095074,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1596675629
    },
    {
        "content": "<p>Thanks Jacques. Am I right to think that <a href=\"https://github.com/ysharoda/tog/blob/master/Library/mathscheme.tog\">https://github.com/ysharoda/tog/blob/master/Library/mathscheme.tog</a> is the source that gets translated? I don't see anything involving several types, like a module over a base ring. Do you handle that?</p>",
        "id": 206123394,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596708778
    },
    {
        "content": "<p>Yes, that's the main input.  Right now, the code only handles unisorted equational theories (same as with classical universal algebra). We're definitely planning to extend to the multi-sorted case. We just want to be careful, as there are some subtleties that arise, and we don't want to produce incorrect results.</p>",
        "id": 206127530,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1596712285
    }
]
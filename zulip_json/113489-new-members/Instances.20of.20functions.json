[
    {
        "content": "<p>I'm trying to get some instance code working but I'm running into \"maximum class-instance resolution depth has been reached ...\", and I'm a little bit worried that I'm using instances beyond their intended capacity. The only instances I have defined are:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">iteration_complexity</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">α_en</span><span class=\"o\">:</span> <span class=\"n\">has_encoding</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">cf</span><span class=\"o\">:</span> <span class=\"n\">has_complexity</span> <span class=\"n\">f</span><span class=\"o\">]:</span> <span class=\"n\">has_complexity</span> <span class=\"o\">(</span><span class=\"n\">nat.iterate</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">fconstructor</span><span class=\"o\">,</span>\n  <span class=\"n\">fconstructor</span><span class=\"o\">,</span>\n  <span class=\"n\">swap</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">iteration_complexity_le</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">cf.value.2</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">flip_complexity</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">α_en</span><span class=\"o\">:</span> <span class=\"n\">has_encoding</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">β_en</span><span class=\"o\">:</span> <span class=\"n\">has_encoding</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">γ_en</span><span class=\"o\">:</span> <span class=\"n\">has_encoding</span> <span class=\"n\">γ</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">cf</span><span class=\"o\">:</span> <span class=\"n\">has_complexity</span> <span class=\"n\">f</span><span class=\"o\">]:</span> <span class=\"n\">has_complexity</span> <span class=\"o\">(</span><span class=\"n\">function.swap</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">fconstructor</span><span class=\"o\">,</span>\n  <span class=\"n\">fconstructor</span><span class=\"o\">,</span>\n  <span class=\"n\">swap</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">flip_complexity_le</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">cf.value.2</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">pred_complexity</span><span class=\"o\">:</span> <span class=\"n\">has_complexity</span> <span class=\"n\">nat.pred</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">fconstructor</span><span class=\"o\">,</span>\n  <span class=\"n\">fconstructor</span><span class=\"o\">,</span>\n  <span class=\"n\">swap</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">pred_complexity_le</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">sub_complexity</span><span class=\"o\">:</span> <span class=\"n\">has_complexity</span> <span class=\"n\">nat.sub</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"k\">show</span> <span class=\"n\">nat.sub</span> <span class=\"bp\">=</span> <span class=\"n\">function.swap</span> <span class=\"o\">(</span><span class=\"n\">nat.iterate</span> <span class=\"n\">nat.pred</span><span class=\"o\">),</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">ext1</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">ext1</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">m</span> <span class=\"n\">generalizing</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nat.sub</span><span class=\"o\">,</span> <span class=\"n\">function.swap</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">function.swap</span><span class=\"o\">,</span> <span class=\"n\">function.iterate_succ_apply'</span><span class=\"o\">,</span> <span class=\"n\">nat.sub</span><span class=\"o\">,</span> <span class=\"n\">nat.sub_succ</span><span class=\"o\">,</span> <span class=\"n\">m_ih</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span><span class=\"o\">],</span>\n  <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- maximum class-instance resolution depth has been reached</span>\n  <span class=\"c1\">-- (the limit can be increased by setting option 'class.instance_max_depth')</span>\n  <span class=\"c1\">-- (the class-instance resolution trace can be visualized by setting option 'trace.class_instances')</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The last one doesn't compile (I don't think any of the other proofs are important here, but I can provide more details if they are). With the error message in the comment. I'm wondering if this is improper use of instances because I'm matching on function names instead of types. As a human it looks pretty easy to unwrap the declaration (find an instance that matches function.swap, then find one that matches nat.iterate, then find the one for nat.pred).</p>",
        "id": 319701679,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1672966776
    },
    {
        "content": "<p>I think the problem is that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.swap\">docs#function.swap</a> is reducible and so <code>flip_complexity </code> forms a loop with itself</p>",
        "id": 319702174,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1672967035
    },
    {
        "content": "<p>Ah, interesting. Wrapping a new function for flip worked, thanks <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> .</p>",
        "id": 319702906,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1672967448
    },
    {
        "content": "<p>Does <a href=\"https://leanprover-community.github.io/mathlib_docs/find/flip\">docs#flip</a> work for you?</p>",
        "id": 319703132,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1672967622
    },
    {
        "content": "<p>Yes it does, not sure how I missed it, given it had the name I expected</p>",
        "id": 319704258,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1672968373
    },
    {
        "content": "<p>A follow-up question (related mostly on the question of instance abuse).<br>\nI've defined the instance as follows</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">is_complexity</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_encodable_function</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">):=</span>\n<span class=\"n\">mk</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">cost</span> <span class=\"o\">:</span> <span class=\"n\">cost_function'</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">complexity_le</span> <span class=\"n\">f</span> <span class=\"n\">cost</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_complexity</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_encodable_function</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">:</span> <span class=\"n\">is_complexity</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">complexity</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_encodable_function</span> <span class=\"n\">α</span><span class=\"o\">]</span>  <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">cf</span><span class=\"o\">:</span> <span class=\"n\">has_complexity</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"n\">cf.value.1</span>\n</code></pre></div>\n<p>is there a way for me to interact with the underlying cost function from an instance? Or is it quotiented away in some sense.<br>\nI.e.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">sc_cost</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">15</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">5</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">sc</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">complexity</span> <span class=\"n\">nat.sub</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">always_le</span> <span class=\"n\">sc_cost</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">complexity</span><span class=\"o\">,</span> <span class=\"n\">sc_cost</span><span class=\"o\">],</span>\n  <span class=\"c1\">-- |- has_complexity.value.cost n m ≤ (2 * n + 15) * m + 5</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 319704748,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1672968748
    },
    {
        "content": "<p>Sure it's possible, though it will be kind of hard to work with because you used <code>rw</code> to define data</p>",
        "id": 319734578,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672992495
    },
    {
        "content": "<p>It would be better to define a function like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin.cast\">docs#fin.cast</a> that copies the data, and only rewrites in the proof</p>",
        "id": 319734675,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672992582
    },
    {
        "content": "<p>Thanks, I'll take a look</p>",
        "id": 320349908,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1673306386
    }
]
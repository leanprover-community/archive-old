[
    {
        "content": "<p>I was trying to prove decidability of some predicates (about inhabited lists), and I got to a point where <code>#eval</code> on <code>to_bool</code> works the way I would expect but <code>#reduce</code> timeouts when using mathlib (and it works fine without it), and the <code>dec_trivial</code> tactic fails. What am I doing wrong? My experiment is attached:<br>\n<a href=\"/user_uploads/3121/aed9iCvYAFjZiCO8S4OEyRqH/decibility_experiment.lean\">decibility_experiment.lean</a></p>",
        "id": 234885593,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1618591289
    },
    {
        "content": "<p>Since the file is short, I've pasted it here:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">--import data.list -- import some mathlib, or not</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">forall2_inh_bool</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">default</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">default</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"o\">::</span><span class=\"n\">t1</span><span class=\"o\">)</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">P</span> <span class=\"n\">h1</span> <span class=\"o\">(</span><span class=\"n\">default</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"n\">forall2_inh_bool</span> <span class=\"n\">t1</span> <span class=\"o\">[])</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">::</span><span class=\"n\">t2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">default</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">h2</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"n\">forall2_inh_bool</span> <span class=\"o\">[]</span> <span class=\"n\">t2</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"o\">::</span><span class=\"n\">t1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">::</span><span class=\"n\">t2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">P</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"n\">forall2_inh_bool</span> <span class=\"n\">t1</span> <span class=\"n\">t2</span><span class=\"o\">)</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">forall2_inh_bool</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">to_bool</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n<span class=\"c1\">-- tt without mathlib</span>\n<span class=\"c1\">-- timeout with mathlib</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">my_get</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"n\">l.head</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"n\">my_get</span> <span class=\"n\">n</span> <span class=\"n\">l.tail</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">my_get_nil</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">my_get</span> <span class=\"n\">n</span> <span class=\"n\">list.nil</span> <span class=\"bp\">=</span> <span class=\"n\">default</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">my_get_nil</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">forall2_inh_bool.correct</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Hdec</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)]</span>\n<span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">l1</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">l2</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">β</span><span class=\"o\">,</span>\n<span class=\"n\">forall2_inh_bool</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">to_bool</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"n\">l1</span> <span class=\"n\">l2</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span>\n<span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">my_get</span> <span class=\"n\">n</span> <span class=\"n\">l1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">my_get</span> <span class=\"n\">n</span> <span class=\"n\">l2</span><span class=\"o\">))</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">my_get_nil</span><span class=\"o\">,</span> <span class=\"n\">forall2_inh_bool</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">H</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">H</span> <span class=\"mi\">0</span><span class=\"o\">⟩</span> <span class=\"c1\">-- comment this line when using mathlib</span>\n<span class=\"kd\">end</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"o\">::</span><span class=\"n\">t1</span><span class=\"o\">)</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">forall2_inh_bool</span><span class=\"o\">,</span> <span class=\"n\">forall2_inh_bool.correct</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">H</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">H.1</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">H.2</span> <span class=\"n\">n</span> <span class=\"o\">},</span>\n  <span class=\"n\">intro</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">H</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">H</span> <span class=\"n\">n.succ</span><span class=\"o\">⟩</span>\n<span class=\"kd\">end</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">::</span><span class=\"n\">t2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">forall2_inh_bool</span><span class=\"o\">,</span> <span class=\"n\">forall2_inh_bool.correct</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">H</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">H.1</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">H.2</span> <span class=\"n\">n</span> <span class=\"o\">},</span>\n  <span class=\"n\">intro</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">H</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">H</span> <span class=\"n\">n.succ</span><span class=\"o\">⟩</span>\n<span class=\"kd\">end</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"o\">::</span><span class=\"n\">t1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">::</span><span class=\"n\">t2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">forall2_inh_bool</span><span class=\"o\">,</span> <span class=\"n\">forall2_inh_bool.correct</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">H</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">H.1</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">H.2</span> <span class=\"n\">n</span> <span class=\"o\">},</span>\n  <span class=\"n\">intro</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">H</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">H</span> <span class=\"n\">n.succ</span><span class=\"o\">⟩</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">forall2_inh_dec</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Hdec</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)]</span>\n<span class=\"o\">(</span><span class=\"n\">l1</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l2</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">my_get</span> <span class=\"n\">n</span> <span class=\"n\">l1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">my_get</span> <span class=\"n\">n</span> <span class=\"n\">l2</span><span class=\"o\">))</span>\n<span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">forall2_inh_bool</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">to_bool</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"n\">l1</span> <span class=\"n\">l2</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span> <span class=\"k\">then</span>\n  <span class=\"n\">is_true</span> <span class=\"o\">((</span><span class=\"n\">forall2_inh_bool.correct</span> <span class=\"n\">P</span> <span class=\"n\">l1</span> <span class=\"n\">l2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"k\">else</span> <span class=\"n\">is_false</span> <span class=\"o\">(</span><span class=\"n\">mt</span> <span class=\"o\">(</span><span class=\"n\">forall2_inh_bool.correct</span> <span class=\"n\">P</span> <span class=\"n\">l1</span> <span class=\"n\">l2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">my_equiv</span> <span class=\"o\">(</span><span class=\"n\">l1</span> <span class=\"n\">l2</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">my_get</span> <span class=\"n\">n</span> <span class=\"n\">l1</span> <span class=\"bp\">=</span> <span class=\"n\">my_get</span> <span class=\"n\">n</span> <span class=\"n\">l2</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">equiv_decidable</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">decidable_rel</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">my_equiv</span>\n<span class=\"o\">:=</span> <span class=\"n\">forall2_inh_dec</span> <span class=\"n\">eq</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">to_bool</span> <span class=\"o\">(</span><span class=\"n\">my_equiv</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"c1\">-- tt</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">to_bool</span> <span class=\"o\">(</span><span class=\"n\">my_equiv</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"c1\">-- tt without mathlib</span>\n<span class=\"c1\">-- timeout with mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">my_equiv</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">dec_trivial</span>\n<span class=\"c1\">-- fails</span>\n</code></pre></div>\n</div></div>",
        "id": 234886272,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618591583
    },
    {
        "content": "<p>iirc, <code>&amp;&amp;</code> does not short circuit in Lean, correct?</p>",
        "id": 234886390,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618591630
    },
    {
        "content": "<p>What does \"shortening circuit\" mean? It is defined as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[inline]</span> <span class=\"kd\">def</span> <span class=\"n\">bor</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"n\">tt</span> <span class=\"n\">_</span>  <span class=\"o\">:=</span> <span class=\"n\">tt</span>\n<span class=\"bp\">|</span> <span class=\"n\">ff</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span>\n<span class=\"bp\">|</span> <span class=\"n\">ff</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span>\n\n<span class=\"kd\">@[inline]</span> <span class=\"kd\">def</span> <span class=\"n\">band</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"n\">ff</span> <span class=\"n\">_</span>  <span class=\"o\">:=</span> <span class=\"n\">ff</span>\n<span class=\"bp\">|</span> <span class=\"n\">tt</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span>\n<span class=\"bp\">|</span> <span class=\"n\">tt</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">x</span> <span class=\"bp\">||</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">bor</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n<span class=\"kd\">notation</span> <span class=\"n\">x</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">band</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n</code></pre></div>",
        "id": 234931647,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1618612833
    },
    {
        "content": "<p>in normal programming languages, something like <code>f(x) &amp;&amp; y(x)</code> will be executed as the following: it first checks <code>f(x)</code>. If it's false, then it won't even bother checking <code>y(x)</code>, as the and of them is false. Similarly for <code>f(x) || y(x)</code> when <code>f(x)=tt</code>. This is short circuiting</p>",
        "id": 234932071,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1618613117
    },
    {
        "content": "<p>Ah, I see, then as far as I understand, it does by the definition. However, it shouldn't make a difference anyway when I tested in on 5 simple checks...</p>",
        "id": 234932265,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1618613257
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">tt</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">to_bool</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">∈</span> <span class=\"n\">list.range</span> <span class=\"mi\">10000000</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 234932326,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618613288
    },
    {
        "content": "<p>then add another 0</p>",
        "id": 234932348,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618613304
    },
    {
        "content": "<p>After a bit of more experimenting, any reason why the following code times out with mathlib (and succeeds with <code>tt</code> when I replace the third line with <code>ff</code>)?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"o\">::</span><span class=\"n\">t1</span><span class=\"o\">)</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">test</span> <span class=\"n\">t1</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">::</span><span class=\"n\">t2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">test</span> <span class=\"o\">[]</span> <span class=\"n\">t2</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"o\">::</span><span class=\"n\">t1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">::</span><span class=\"n\">t2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">test</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">[]</span>\n</code></pre></div>\n<p>But I don't even know whether this is important, I primarily wanted to make the <code>dec_trivial</code> work in the original question (and similar cases)...</p>",
        "id": 234933916,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1618614430
    },
    {
        "content": "<p>OK, so after making the function <code>forall2_inh_bool</code> recursive only in one argument (which required defining another helper function), the problem is solved, and my takeover from this is that recursion on multiple arguments is somehow evil.</p>",
        "id": 234937992,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1618617894
    },
    {
        "content": "<p>I'm not sure what you mean by \"with mathlib\" here. I am not having any trouble evaluating that expression, but the general recommendation on <code>#reduce</code> is \"don't use it, it doesn't work beyond toy examples\"</p>",
        "id": 234949221,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618623497
    },
    {
        "content": "<p>I mean, when I prepend the code of <code>test</code> (I believe should be a toy example) with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.list</span>\n</code></pre></div>\n<p>Then the <code>#reduce</code> times out. By the way, I am using lean version, leanprover-community/lean:3.28.0</p>\n<p>And I was trying to use <code>#reduce</code> just to figure out what the problem could be. The original issue was that <code>dec_trivial</code> was not working in the original question.</p>",
        "id": 234971088,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1618646954
    },
    {
        "content": "<p>This is a minimal working example, I believe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"o\">::</span><span class=\"n\">t1</span><span class=\"o\">)</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">test</span> <span class=\"n\">t1</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">::</span><span class=\"n\">t2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">test</span> <span class=\"o\">[]</span> <span class=\"n\">t2</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"o\">::</span><span class=\"n\">t1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">::</span><span class=\"n\">t2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test2</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"o\">::</span><span class=\"n\">t1</span><span class=\"o\">)</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">test2</span> <span class=\"n\">t1</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">::</span><span class=\"n\">t2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"o\">::</span><span class=\"n\">t1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">::</span><span class=\"n\">t2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">test</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">[]</span>\n<span class=\"c1\">-- tt</span>\n<span class=\"k\">#eval</span> <span class=\"n\">test2</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">[]</span>\n<span class=\"c1\">-- tt</span>\n<span class=\"c1\">--#reduce test [0] [] -- times out</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">test2</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">[]</span>\n<span class=\"c1\">-- tt</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">test</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">[]</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">dec_trivial</span>\n<span class=\"c1\">-- fails</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">test2</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">[]</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">dec_trivial</span>\n<span class=\"c1\">-- succeeds</span>\n</code></pre></div>",
        "id": 234973375,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1618649679
    },
    {
        "content": "<p>Oh interesting. <code>test</code> is apparently compiled using well founded recursion, which is going to cause problems with <code>#reduce</code> for sure, but importantly the default well founded recursion tactic uses <code>simp</code>, so importing mathlib can change the proof that is discovered, from one that computes to one that uses axioms. There is a recent \"fix\" to lean 3 that should be arriving in the next version, which will make this fail rather than unfold the proof</p>",
        "id": 234973826,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618650193
    },
    {
        "content": "<p>If you want to avoid well founded recursion, you can rewrite it to make it more obviously structural recursive:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">test1</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">::</span><span class=\"n\">t2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">test1</span> <span class=\"n\">t2</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test2</span> <span class=\"o\">(</span><span class=\"n\">IH</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">IH</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">::</span><span class=\"n\">t2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">test1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"o\">::</span><span class=\"n\">t1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">test2</span> <span class=\"o\">(</span><span class=\"n\">test</span> <span class=\"n\">t1</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">test</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">[]</span>\n</code></pre></div>",
        "id": 234974033,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618650419
    },
    {
        "content": "<p>OK, I did it this way in the end. Originally, I found it convenient that lean (contrary to say coq) can handle recursion on multiple parameters on its own but it is apparently not for free.</p>",
        "id": 234974586,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1618651056
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">tt</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">to_bool</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">∈</span> <span class=\"n\">list.range</span> <span class=\"mi\">10000000</span><span class=\"o\">)</span>\n</code></pre></div>\n<blockquote>\n<p>then add another 0</p>\n</blockquote>\n<p>(a bit offtopic)<br>\nI was still a bit puzzled by this. First, let's just clarify that it is not an example of not shortening circuit for <code>&amp;&amp;</code> since <code>tt &amp;&amp;</code> must continue with the evaluation. If we replace it with <code>tt ||</code> or <code>ff &amp;&amp;</code>, lean handles it without problem. But still, I thought that <code>1</code> should be at the beginning of  the <code>range</code>, so it should be possible to find it quickly. So I looked up the definition of <code>list.range</code>, and it turned out that by lean's definition, it counts down to zero until it starts making the list. So I wrote my own <code>range</code> definition, however, even that one didn't turn out working fast. Why it is the case seems to be a technical detail of how lean do / doesn't do lazy evaluation which is beyond my understanding.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">list.my_range</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"n\">n0</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"n\">n0</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">n0</span><span class=\"o\">::(</span><span class=\"n\">list.my_range</span> <span class=\"o\">(</span><span class=\"n\">n0</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">l</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">::(</span><span class=\"n\">list.my_range</span> <span class=\"mi\">1</span> <span class=\"mi\">9999999</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">head</span>\n<span class=\"c1\">-- fast</span>\n<span class=\"k\">#eval</span> <span class=\"o\">((</span><span class=\"n\">list.my_range</span> <span class=\"mi\">0</span> <span class=\"mi\">10000000</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">head</span>\n<span class=\"c1\">-- slow</span>\n</code></pre></div>",
        "id": 235013827,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1618690087
    },
    {
        "content": "<p>Lean is an eager, or call-by-value language, like ML and unlike Haskell. That means that it won't evaluate <code>list.mem</code> until it has fully evaluated the <code>list.range 10000000</code> into a list with 10000000 elements. If you used lazy lists (which lean has btw, as <code>lazy_list A</code>) then it would only evaluate as many elements as needed and leave the rest as thunks, so the operation would evaluate quickly.</p>",
        "id": 235030370,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618705983
    },
    {
        "content": "<p>Well, but not exactly, when I run the following code in OCaml,</p>\n<div class=\"codehilite\" data-code-language=\"OCaml\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"k\">rec</span> <span class=\"n\">range</span> <span class=\"n\">n0</span> <span class=\"o\">=</span> <span class=\"k\">function</span> <span class=\"o\">|</span> <span class=\"mi\">0</span> <span class=\"o\">-&gt;</span> <span class=\"bp\">[]</span> <span class=\"o\">|</span> <span class=\"n\">l</span> <span class=\"o\">-&gt;</span> <span class=\"n\">n0</span><span class=\"o\">::(</span><span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">n0</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">));;</span>\n<span class=\"nn\">List</span><span class=\"p\">.</span><span class=\"n\">hd</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">::(</span><span class=\"n\">range</span> <span class=\"mi\">0</span> <span class=\"mi\">1000000</span><span class=\"o\">));;</span>\n</code></pre></div>\n<p>I get an error. On the other hand, lean can handle</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">::(</span><span class=\"n\">list.range</span> <span class=\"mi\">1000000000</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">head</span>\n</code></pre></div>",
        "id": 235057412,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1618736612
    },
    {
        "content": "<p>I guess, it is not so important, just that it surprised me a bit.</p>",
        "id": 235058362,
        "sender_full_name": "Miroslav Olšák",
        "timestamp": 1618737820
    },
    {
        "content": "<p>Heh, that's because lean cheats:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.compiler.optimize_bytecode</span> <span class=\"n\">true</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">::(</span><span class=\"n\">list.range</span> <span class=\"mi\">1000000000</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">head</span>\n\n<span class=\"c1\">-- [compiler.optimize_bytecode]  foo 0</span>\n<span class=\"c1\">-- 0: scnstr #0</span>\n<span class=\"c1\">-- 1: ret</span>\n</code></pre></div>",
        "id": 235059902,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618739427
    },
    {
        "content": "<p>Using the magic of pure functional programming it was able to prove that the thing evaluates to 0 without having to work out the tail of the list</p>",
        "id": 235059921,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618739468
    },
    {
        "content": "<p>It doesn't need laziness to justify this transformation because all functions are total</p>",
        "id": 235060098,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618739659
    },
    {
        "content": "<p>Hello! My name is Ben Selfridge. I work at Galois, Inc. in Portland and am learning Lean in my spare time, both for joy and professional development. I've been learning the proofs of Gödel's incompleteness theorems at a deeper level than I've ever had time to lately, and I partly decided to learn Lean to see if I could formalize them as a fun challenge. I initially started with Lean4, but gave up as soon as I realized that most of the relevant mathlib work had not been ported yet, so now I'm on Lean3.</p>\n<p>I have a newbie question. I have a prop definition</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">divides</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>I want to show that the following function <code>dividesF</code> decides this proposition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">dividesF_aux</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">a.succ</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n  <span class=\"k\">then</span> <span class=\"n\">tt</span>\n  <span class=\"k\">else</span> <span class=\"n\">dividesF_aux</span> <span class=\"n\">a</span> <span class=\"n\">m</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dividesF</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span> <span class=\"n\">dividesF_aux</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>In proving the following lemma, I got stuck:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">divides_of_dividesF_aux</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">dividesF_aux</span> <span class=\"n\">a</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">divides</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">pa</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- a = 0</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">dividesF_aux</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">divides</span><span class=\"o\">],</span>\n    <span class=\"n\">apply</span> <span class=\"n\">exists.intro</span> <span class=\"n\">nat.zero</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- How do I get to_bool (n = 0) to turn into n = 0?</span>\n    <span class=\"gr\">admit</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- a = pa.succ</span>\n    <span class=\"gr\">admit</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>As indicated in the comment, I have <code>to_bool(n = 0)</code> as my hypothesis, and I'd like it to resolve to <code>n = 0</code>. In Lean4, <code>simp</code> did the trick, but not here.</p>\n<p>Any suggestions? Also, any pointers for code quality are welcome.</p>",
        "id": 291572658,
        "sender_full_name": "Ben Selfridge",
        "timestamp": 1659359569
    },
    {
        "content": "<p>Should <code>h</code> be of type <code>dividesF_aux a m n = tt</code>?</p>",
        "id": 291574729,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1659360295
    },
    {
        "content": "<p><code>simp</code> should do this reduction, but you need the file containing the simp lemma to be imported. In this case I would guess it's <a href=\"https://leanprover-community.github.io/mathlib_docs/data/bool/basic.html\"><code>data.bool.basic</code></a></p>",
        "id": 291575453,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659360593
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"325367\">Mauricio Collares</span> <a href=\"#narrow/stream/113489-new-members/topic/decidability.20struggles/near/291574729\">said</a>:</p>\n<blockquote>\n<p>Should <code>h</code> be of type <code>dividesF_aux a m n = tt</code>?</p>\n</blockquote>\n<p>Yes, it should! That fixed the problem. Do you know if Lean4 automatically figures out that's what I meant? Because I've tried it both ways in Lean4 and it didn't seem to affect anything.</p>",
        "id": 291597693,
        "sender_full_name": "Ben Selfridge",
        "timestamp": 1659370375
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/decidability.20struggles/near/291575453\">said</a>:</p>\n<blockquote>\n<p><code>simp</code> should do this reduction, but you need the file containing the simp lemma to be imported. In this case I would guess it's <a href=\"https://leanprover-community.github.io/mathlib_docs/data/bool/basic.html\"><code>data.bool.basic</code></a></p>\n</blockquote>\n<p>Thank you -- this also worked!</p>",
        "id": 291598081,
        "sender_full_name": "Ben Selfridge",
        "timestamp": 1659370530
    }
]
[
    {
        "content": "<p>I am working on a fairly complex proof where in part of the proof I get a contradiction by simplifying  using <code>x=a</code> at a hypothesis <code>not (a = x)</code>, thus yielding a term of type <code>false</code>. Normally I can just close the current goal with <code>contradiction</code>, but in this case I get an error. Below you can see my context, my goal, and the (quite unhelpful) error I get:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">contradiction</span> <span class=\"n\">tactic</span> <span class=\"n\">failed</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"mi\">4</span> <span class=\"n\">goals</span>\n<span class=\"n\">case</span> <span class=\"n\">or.inl</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">this</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)),</span> <span class=\"n\">l.length</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">intercalate</span> <span class=\"o\">[</span><span class=\"n\">l.head</span><span class=\"o\">,</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">intercalate</span> <span class=\"n\">l.tail</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">intercalate</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n<span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">tl</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">ih</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n    <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">list.split_on_first</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"k\">in</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">tl</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list.split_on</span> <span class=\"n\">a</span> <span class=\"n\">tl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n<span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">list.split_on_first</span> <span class=\"n\">a</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">hd</span> <span class=\"o\">::</span> <span class=\"n\">tl</span><span class=\"o\">,</span>\n<span class=\"n\">list_contains</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">hd</span> <span class=\"o\">::</span> <span class=\"n\">tl</span><span class=\"o\">,</span>\n<span class=\"n\">or</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">h_1</span> <span class=\"o\">:</span> <span class=\"n\">false</span>\n<span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"k\">let</span> <span class=\"n\">or</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">hd</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">tl</span> <span class=\"o\">:=</span> <span class=\"n\">list.eq_or_mem_of_mem_cons</span> <span class=\"n\">list_contains</span> <span class=\"k\">in</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">tl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_root_.or.inl</span> <span class=\"n\">or</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I can post the full context if need be, but it is quite long.</p>",
        "id": 302190439,
        "sender_full_name": "Josiah Eldon Bills",
        "timestamp": 1664859589
    },
    {
        "content": "<p>Does <code>exact h_1.elim</code> work at that point?</p>",
        "id": 302191377,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1664860347
    },
    {
        "content": "<p>(At least for me, a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, even if not too minimized), would be helpful.)</p>",
        "id": 302191521,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1664860466
    },
    {
        "content": "<p>I get the following error when I try that. Similarly, if I try to use <code>exact absurd</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">infer</span> <span class=\"n\">type</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">function</span> <span class=\"n\">expected</span> <span class=\"n\">at</span>\n  <span class=\"o\">(</span><span class=\"k\">let</span> <span class=\"n\">or</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">hd</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">tl</span> <span class=\"o\">:=</span> <span class=\"n\">list.eq_or_mem_of_mem_cons</span> <span class=\"n\">list_contains</span> <span class=\"k\">in</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">tl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">hypothesis</span><span class=\"o\">)</span>\n<span class=\"n\">term</span>\n  <span class=\"k\">let</span> <span class=\"n\">or</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">hd</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">tl</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n  <span class=\"k\">in</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">tl</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Prop</span>\n</code></pre></div>",
        "id": 302191750,
        "sender_full_name": "Josiah Eldon Bills",
        "timestamp": 1664860706
    },
    {
        "content": "<p>and also <code>refine false.elim _, </code> gives an error?</p>",
        "id": 302191930,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1664860887
    },
    {
        "content": "<p>or <code>apply false.elim,</code>?</p>",
        "id": 302191949,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1664860916
    },
    {
        "content": "<p>The former gives </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">infer</span> <span class=\"n\">type</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">function</span> <span class=\"n\">expected</span> <span class=\"n\">at</span>\n  <span class=\"o\">(</span><span class=\"k\">let</span> <span class=\"n\">or</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">hd</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">tl</span> <span class=\"o\">:=</span> <span class=\"n\">list.eq_or_mem_of_mem_cons</span> <span class=\"n\">list_contains</span> <span class=\"k\">in</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">tl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">hypothesis</span><span class=\"o\">)</span>\n<span class=\"n\">term</span>\n  <span class=\"k\">let</span> <span class=\"n\">or</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">hd</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">tl</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n  <span class=\"k\">in</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">tl</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>again, while the latter gives</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">apply</span> <span class=\"n\">tactic</span><span class=\"o\">,</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">unify</span>\n  <span class=\"o\">(</span><span class=\"k\">let</span> <span class=\"n\">or</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">hd</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">tl</span> <span class=\"o\">:=</span> <span class=\"n\">list.eq_or_mem_of_mem_cons</span> <span class=\"n\">list_contains</span> <span class=\"k\">in</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">tl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">hypothesis</span><span class=\"o\">)</span>\n<span class=\"k\">with</span>\n  <span class=\"bp\">?</span><span class=\"n\">m_1</span>\n</code></pre></div>",
        "id": 302192085,
        "sender_full_name": "Josiah Eldon Bills",
        "timestamp": 1664861026
    },
    {
        "content": "<p>Here is the theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">list.split_on_first</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">l.split_on</span> <span class=\"n\">a</span> <span class=\"k\">in</span>\n  <span class=\"o\">(</span><span class=\"n\">s.head</span><span class=\"o\">,</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">intercalate</span> <span class=\"n\">s.tail</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">list.split_on_first.infix</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">list.split_on_first</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"k\">in</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">s.1</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"bp\">++</span> <span class=\"n\">s.2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">list_contains</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">intercalate</span> <span class=\"o\">[</span><span class=\"n\">s.1</span><span class=\"o\">,</span> <span class=\"n\">s.2</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>\n    <span class=\"k\">let</span> <span class=\"n\">intercalate_append</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">intercalate</span> <span class=\"o\">[</span><span class=\"n\">s.1</span><span class=\"o\">,</span> <span class=\"n\">s.2</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">s.1</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"bp\">++</span> <span class=\"n\">s.2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">list.intercalate</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">intercalate_append</span><span class=\"o\">,</span>\n    <span class=\"n\">symmetry</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">l.length</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">intercalate</span> <span class=\"o\">[</span><span class=\"n\">l.head</span><span class=\"o\">,</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">intercalate</span> <span class=\"n\">l.tail</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">intercalate</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>\n    <span class=\"k\">suffices</span> <span class=\"n\">split_len</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">list.split_on</span> <span class=\"n\">a</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span>\n      <span class=\"n\">specialize</span> <span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"n\">list.split_on</span> <span class=\"n\">a</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"n\">split_len</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">list.intercalate_split_on</span> <span class=\"n\">l</span> <span class=\"n\">a</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">this</span>\n    <span class=\"o\">},</span>\n\n    <span class=\"n\">induction</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"n\">generalizing</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">list_contains</span><span class=\"o\">,</span>\n    <span class=\"n\">contradiction</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">list.split_on</span><span class=\"o\">,</span> <span class=\"n\">list.split_on_p_cons</span><span class=\"o\">],</span>\n    <span class=\"n\">split_ifs</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">list.split_on_p_ne_nil</span><span class=\"o\">],</span>\n      <span class=\"n\">cases</span> <span class=\"n\">th</span><span class=\"o\">:</span> <span class=\"n\">list.split_on_p</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">_x</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">tl</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">list.split_on_p_ne_nil</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">th</span><span class=\"o\">,</span>\n      <span class=\"n\">contradiction</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">th</span><span class=\"o\">]</span>\n    <span class=\"o\">},</span>\n    <span class=\"n\">rw</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"n\">list_contains</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">tl</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span>\n      <span class=\"k\">let</span> <span class=\"n\">or</span> <span class=\"o\">:=</span> <span class=\"n\">list.eq_or_mem_of_mem_cons</span> <span class=\"n\">list_contains</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">or</span> <span class=\"k\">with</span> <span class=\"n\">hypothesis</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hypothesis</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h_1</span><span class=\"o\">,</span>\n      <span class=\"n\">contradiction</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">h_2</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n    <span class=\"k\">let</span> <span class=\"n\">induction</span> <span class=\"o\">:=</span> <span class=\"n\">ih</span> <span class=\"n\">tl</span> <span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"n\">eq.refl</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">list.split_on</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"o\">(</span><span class=\"n\">list.split_on</span> <span class=\"n\">a</span> <span class=\"n\">tl</span><span class=\"o\">),</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">induction</span><span class=\"o\">,</span>\n    <span class=\"n\">contradiction</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">induction</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">induction</span><span class=\"o\">],</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">intros</span> <span class=\"n\">lol</span> <span class=\"n\">lol_size_2</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">lol</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">lol_size_2</span><span class=\"o\">,</span>\n  <span class=\"n\">contradiction</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">lol_tl</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">lol_size_2</span><span class=\"o\">,</span>\n  <span class=\"n\">contradiction</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">list.intercalate</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The error occurs in the proof of <code>let : a ∈ tl,</code>.</p>",
        "id": 302192224,
        "sender_full_name": "Josiah Eldon Bills",
        "timestamp": 1664861137
    },
    {
        "content": "<p>I found that if you use <code>cases dont_care: or with hypothesis,</code> then this works just fine.</p>",
        "id": 302192361,
        "sender_full_name": "Josiah Eldon Bills",
        "timestamp": 1664861230
    },
    {
        "content": "<p>If you do this then the goal remains <code>a ∈ tl</code>, while if you don't then the goal gets a whole bunch of garbage thrown in it.</p>",
        "id": 302192459,
        "sender_full_name": "Josiah Eldon Bills",
        "timestamp": 1664861293
    },
    {
        "content": "<p>what happens if you type <code>intros</code> first?</p>",
        "id": 302192541,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1664861388
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"o\">{</span>\n      <span class=\"k\">have</span> <span class=\"n\">or</span> <span class=\"o\">:=</span> <span class=\"n\">list.eq_or_mem_of_mem_cons</span> <span class=\"n\">list_contains</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">or</span> <span class=\"k\">with</span> <span class=\"n\">hypothesis</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hypothesis</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h_1</span><span class=\"o\">,</span>\n      <span class=\"n\">contradiction</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">or</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n</code></pre></div>\n<p>I used <code>have</code> instead of <code>let</code>.</p>",
        "id": 302192773,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1664861539
    },
    {
        "content": "<p>Even though this does not seem to be causing problems, I am very skeptical about calling a variable with the name of an existing function such as <code>or</code>...</p>",
        "id": 302192880,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1664861610
    },
    {
        "content": "<p>Briefly, <code>let</code> is for introducing \"shorthand\" notation for something, while <code>have</code> is for introducing extra hypotheses.  In your situation, I think that you used <code>let</code> to mean \"let us call <code>or</code> the hypothesis <code>a = hd ∨ a ∈ tl</code>\".  In Lean, this is done by using <code>have</code>, not <code>let</code>.</p>",
        "id": 302193082,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1664861747
    },
    {
        "content": "<p>The name point is well made, I will change it. It isn't the cause of the issue though. Why does this bubble down to cause issues in <code>cases</code>?</p>",
        "id": 302193224,
        "sender_full_name": "Josiah Eldon Bills",
        "timestamp": 1664861874
    },
    {
        "content": "<p>I do not know, but the <code>cases</code> on the <code>let</code> mangles the type of the target.  I am actually not sure about what the precise effect is, but Lean is not very happy with it either.</p>",
        "id": 302194162,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1664862506
    },
    {
        "content": "<p>When you use <code>let</code> you are informing Lean that you will use <code>or</code> to mean whatever you say it is.  At this stage, I suspect that lean thinks that <code>or</code> is the Prop that it displays, not its proof.</p>\n<p>I imagine that, to Lean, what you wrote was not very different than <code>let or := A ∨ B</code>, with <code>A B : Prop</code> completely arbitrary, with no indication that actually at least one of them is true.</p>",
        "id": 302198593,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1664865465
    },
    {
        "content": "<p><code>let</code> changes the goal. It's not the correct tactic to use when defining a proof, <code>have</code> is.</p>",
        "id": 302205300,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1664868967
    },
    {
        "content": "<p>Indeed, here is a smaller version of the same issue as above:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">logic.basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">or1</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">em</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">or1</span><span class=\"o\">,</span>\n  <span class=\"n\">trivial</span><span class=\"o\">,</span>  <span class=\"c1\">-- fails</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 302206517,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1664869501
    }
]
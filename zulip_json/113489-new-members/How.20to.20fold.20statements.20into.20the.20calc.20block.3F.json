[
    {
        "content": "<p>Ah, so <a class=\"stream\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members\">#new members</a> is a “stream,” and it has multiple “topics.” Now the terminology is coming together in my head.</p>",
        "id": 123008970,
        "sender_full_name": "Sean Leather",
        "timestamp": 1519672281
    },
    {
        "content": "<p>And I'm too tired to fully comprehend anything else about Zulip right now. I'm sure I'll find lots of messages in the morning. Good night!</p>",
        "id": 123009044,
        "sender_full_name": "Sean Leather",
        "timestamp": 1519672398
    },
    {
        "content": "<p>I like the generated profile pictures here.</p>",
        "id": 123011348,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1519676127
    },
    {
        "content": "<p>You can still use the opportunity to brighten your previous profile picture before uploading</p>",
        "id": 123011404,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1519676175
    },
    {
        "content": "<p>usually this is achieved by constructing the set in a way so that it's obvious that it's a finset. How is <code>isCanonicalPartition</code> defined?</p>",
        "id": 165591474,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557807050
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118987\">@Huyen Chau Nguyen</span> to format code on this chat (you can still edit your message) use</p>\n<div class=\"codehilite\"><pre><span></span>```lean\nput your code here\n```\n</pre></div>\n\n\n<p>That way it is formatted as a code block with syntax highlighting.</p>",
        "id": 165591475,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557807055
    },
    {
        "content": "<p>Hello, newb in functional languages here! Im stuck on excercise at \"2.4. Introducing Definitions\"</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c\">/-</span><span class=\"cm\"> Above, we discussed the process of “currying” a function, that is, taking a function f (a, b) that takes an ordered pair as an argument, and recasting it as a function f&#39; a b that takes two arguments successively. As another exercise, we encourage you to complete the following definitions, which “curry” and “uncurry” a function.</span>\n<span class=\"cm\">def curry (α β γ : Type) (f : α × β → γ) : α → β → γ := sorry</span>\n<span class=\"cm\">def uncurry (α β γ : Type) (f : α → β → γ) : α × β → γ := sorry</span>\n<span class=\"cm\">-/</span>\n<span class=\"n\">def</span> <span class=\"n\">curry</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n</pre></div>\n\n\n<p>the closest solution i came up with is</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">curry</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">γ</span><span class=\"o\">),</span> <span class=\"n\">c</span>\n</pre></div>\n\n\n<p>returns error:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">/</span><span class=\"n\">home</span><span class=\"bp\">/</span><span class=\"n\">runner</span><span class=\"bp\">/.</span><span class=\"n\">code</span><span class=\"bp\">.</span><span class=\"n\">tio</span><span class=\"o\">:</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"mi\">56</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span><span class=\"o\">,</span> <span class=\"n\">term</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">γ</span><span class=\"o\">),</span> <span class=\"n\">c</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span>\n</pre></div>\n\n\n<p>i don't understand how i should return this λ itself. As is can't just leave it like \"λ (a: α) (b: β) (c: γ)\"</p>",
        "id": 167292319,
        "sender_full_name": "hpxmd",
        "timestamp": 1559654653
    },
    {
        "content": "<p>you need to use <code>f</code> at some point</p>",
        "id": 167292425,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559654748
    },
    {
        "content": "<p>I tried for like whole day and a half. Im no mathematitian also. Should i just continue reading then?</p>",
        "id": 167292828,
        "sender_full_name": "hpxmd",
        "timestamp": 1559655003
    },
    {
        "content": "<p>the type signature of curry states that given a value of type alpha and a value of type beta, you get a value of type gamma. <br>\nthe function you defined with your lambda however takes a value of type alpha, a value of type beta and a value of type gamma.<br>\nyou need to drop the gamma parameter and come up with a way to produce a value of type gamma from values of types alpha and beta, which will involve using f.</p>",
        "id": 167292871,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1559655022
    },
    {
        "content": "<blockquote>\n<p>you need to use <code>f</code> at some point</p>\n</blockquote>\n<p>See, the question was under-specified. No wonder the continuum hypothesis is undecidable.</p>",
        "id": 167292909,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1559655052
    },
    {
        "content": "<p>Seriously, <span class=\"user-mention\" data-user-id=\"224062\">@hpxmd</span> you need to reread the last paragraph of <a href=\"https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#simple-type-theory\" target=\"_blank\" title=\"https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#simple-type-theory\">https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#simple-type-theory</a></p>",
        "id": 167293143,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1559655169
    },
    {
        "content": "<blockquote>\n<p>I tried for like whole day and a half. Im no mathematitian also. Should i just continue reading then?</p>\n</blockquote>\n<p>How many mathematicians do you think know what <code>curry</code> means? I bet that 99% think it is something you put on a sausage.</p>",
        "id": 167293173,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559655183
    },
    {
        "content": "<p>That's where the specification is explicitly given</p>",
        "id": 167293178,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1559655184
    },
    {
        "content": "<p>Johan, I think you spend <em>way</em> too much time in Germany</p>",
        "id": 167293221,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1559655210
    },
    {
        "content": "<p>Thanks Patrick, ill try that</p>",
        "id": 167293295,
        "sender_full_name": "hpxmd",
        "timestamp": 1559655244
    },
    {
        "content": "<p>So i had to read wiki to write it:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">curry</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>is this right?</p>",
        "id": 167309231,
        "sender_full_name": "hpxmd",
        "timestamp": 1559664154
    },
    {
        "content": "<p>Yup!</p>",
        "id": 167309258,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559664176
    },
    {
        "content": "<p>then i guess i dont understand this lambda calculus thing</p>",
        "id": 167309397,
        "sender_full_name": "hpxmd",
        "timestamp": 1559664249
    },
    {
        "content": "<p>thank you</p>",
        "id": 167309403,
        "sender_full_name": "hpxmd",
        "timestamp": 1559664256
    },
    {
        "content": "<p>This has not much to do with lambda calculus</p>",
        "id": 167309612,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1559664365
    },
    {
        "content": "<p>This is exactly completely basic lambda calculus, isn't it?</p>",
        "id": 167309673,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559664396
    },
    {
        "content": "<p>No, it's about functions of two variable vs function of one variable with values in functions of one variable.</p>",
        "id": 167309761,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1559664439
    },
    {
        "content": "<p>You could write the answer as <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>↦</mo><mo>(</mo><mi>b</mi><mo>↦</mo><mi>f</mi><mo>(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">a \\mapsto (b \\mapsto f (a,b))</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">a</span><span class=\"mrel\">↦</span><span class=\"mopen\">(</span><span class=\"mord mathit\">b</span><span class=\"mrel\">↦</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">a</span><span class=\"mpunct\">,</span><span class=\"mord mathit\">b</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> and you woudln't see any <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">λ</span></span></span></span></p>",
        "id": 167309813,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1559664478
    },
    {
        "content": "<p>The point of lambda-calculus is not using a stupid notation instead of a legible one (reading: the one <em>we</em> are used to). It's about the reduction rules</p>",
        "id": 167309929,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1559664521
    },
    {
        "content": "<p>this topic made me curious: when getting started with lean (or a similar language), did the function application syntax without parens feel unnatural or even hard to read to any of you, compared to the syntax with parens?<br>\ni'm asking because i've heard this complaint quite a lot over the years from people coming from traditional programming languages, and i've been wondering whether this initial feeling is common for everyone, or whether it's just because i've mostly talked to people that had gotten used to the syntax with parens over the years.</p>",
        "id": 167316162,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1559668828
    },
    {
        "content": "<p>I was a mathematician for 25 years before I learnt any functional programming and yes, the lack of brackets looked super-weird to me. I still occasionally put them in by accident.</p>",
        "id": 167319865,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559671134
    },
    {
        "content": "<p>Yes but use it long enough and you'll start hating brackets. :-)</p>",
        "id": 167320016,
        "sender_full_name": "Koundinya Vajjha",
        "timestamp": 1559671229
    },
    {
        "content": "<p>I've caught myself not writing brackets on paper</p>",
        "id": 167320208,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1559671346
    },
    {
        "content": "<p>In dynamics it is very common to omit the brackets.</p>",
        "id": 167325388,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1559674395
    },
    {
        "content": "<p>Meh. We should be writing function application as <code>x f</code> anyway. Losing the brackets is partial progress. :-)</p>",
        "id": 167327636,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1559676052
    },
    {
        "content": "<p>Reverse Polish notation was the best thing in calculators. Maybe I ought to implement it in lean 4, hah.</p>",
        "id": 167341596,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1559688161
    },
    {
        "content": "<p>Then you can stare at expressions like 15 7 1 1 + − ÷ 3 × 2 1 1 + + − and truly live the bracket free life</p>",
        "id": 167341835,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1559688419
    },
    {
        "content": "<p>How do I enter the Greek letter lambda (symbol for  functional abstraction) in the Lean javascript window?</p>",
        "id": 168785596,
        "sender_full_name": "Robert Solovay",
        "timestamp": 1561280192
    },
    {
        "content": "<p><code>\\lam</code></p>",
        "id": 168785599,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561280210
    },
    {
        "content": "<p><code>\\la</code> apparently works too</p>",
        "id": 168785605,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561280228
    },
    {
        "content": "<p>Thanks.</p>",
        "id": 168785607,
        "sender_full_name": "Robert Solovay",
        "timestamp": 1561280234
    },
    {
        "content": "<p>Nice to see you here, by the way!</p>",
        "id": 168785618,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561280253
    },
    {
        "content": "<p>welcome!</p>",
        "id": 168791239,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1561290567
    },
    {
        "content": "<p>Hi! <br>\nI am trying to proof completeness theorem for Hilbert style classical propositional system. While working my way through I ran into this lemma below. The lemma is quite important, but i am not able to prove it. I can do that  for n and k particular numbers (1,2,3, ..),  but not for n and k general. Is there some way to prove it?</p>\n<div class=\"codehilite\"><pre><span></span>def eval := ℕ → bool\ndef g(n:ℕ)(f:eval): ℕ → bool := (λ m:ℕ, nat.lt_by_cases (λ h:m&lt;n, f m) (λ h, tt) (λ h, tt))\n\nlemma Lemma1(n:ℕ)(f:eval): ∀ k:ℕ, k &lt; n → g n f k = f k :=\n</pre></div>\n\n\n<p>Thanks :)</p>",
        "id": 168969707,
        "sender_full_name": "jachym simon",
        "timestamp": 1561491313
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"kn\">eval</span> <span class=\"o\">:=</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"n\">def</span> <span class=\"n\">g</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">)(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"kn\">eval</span><span class=\"o\">):</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">lt_by_cases</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">m</span><span class=\"bp\">&lt;</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">tt</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">tt</span><span class=\"o\">))</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">Lemma1</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">)(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"kn\">eval</span><span class=\"o\">):</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">g</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">k</span> <span class=\"n\">hk</span><span class=\"o\">,</span> <span class=\"n\">dif_pos</span> <span class=\"n\">hk</span>\n</pre></div>",
        "id": 168970125,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561491623
    },
    {
        "content": "<blockquote>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"kn\">eval</span> <span class=\"o\">:=</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"n\">def</span> <span class=\"n\">g</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">)(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"kn\">eval</span><span class=\"o\">):</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">lt_by_cases</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">m</span><span class=\"bp\">&lt;</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">tt</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">tt</span><span class=\"o\">))</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">Lemma1</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">)(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"kn\">eval</span><span class=\"o\">):</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">g</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">k</span> <span class=\"n\">hk</span><span class=\"o\">,</span> <span class=\"n\">dif_pos</span> <span class=\"n\">hk</span>\n</pre></div>\n\n\n</blockquote>\n<p>Thank you :)</p>",
        "id": 168973733,
        "sender_full_name": "jachym simon",
        "timestamp": 1561494241
    },
    {
        "content": "<p>HI again,<br>\ni have  got one more connected question. How do i prove the two below? Thought it would be the same, but it does not seem to work. </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"kn\">eval</span> <span class=\"o\">:=</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"n\">def</span> <span class=\"n\">g</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">)(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"kn\">eval</span><span class=\"o\">):</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">lt_by_cases</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">m</span><span class=\"bp\">&lt;</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">tt</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">tt</span><span class=\"o\">))</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">Lemma2</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">)(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"kn\">eval</span><span class=\"o\">):</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">g</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span>  <span class=\"o\">:=</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">Lemma3</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">)(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"kn\">eval</span><span class=\"o\">):</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"bp\">&gt;</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">g</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span>  <span class=\"o\">:=</span>\n</pre></div>",
        "id": 169005779,
        "sender_full_name": "jachym simon",
        "timestamp": 1561533542
    },
    {
        "content": "<p>It might be simpler to not use <code>lt_by_cases</code></p>",
        "id": 169005987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561533829
    },
    {
        "content": "<p>and just use <code>if</code></p>",
        "id": 169005990,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561533834
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"kn\">eval</span> <span class=\"o\">:=</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"n\">def</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kn\">eval</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">f</span> <span class=\"n\">m</span> <span class=\"k\">else</span> <span class=\"n\">tt</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">Lemma2</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kn\">eval</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span>\n<span class=\"k\">have</span> <span class=\"bp\">¬</span> <span class=\"n\">k</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"bp\">λ</span> <span class=\"n\">h&#39;</span><span class=\"o\">,</span> <span class=\"n\">ne_of_lt</span> <span class=\"n\">h&#39;</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">this</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">Lemma3</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kn\">eval</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">&gt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span>\n<span class=\"k\">have</span> <span class=\"bp\">¬</span> <span class=\"n\">k</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">not_lt_of_gt</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">this</span><span class=\"o\">]</span>\n</pre></div>",
        "id": 169006136,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561534014
    },
    {
        "content": "<p>Yep, that was it.  It was just updating something in the background</p>",
        "id": 174031793,
        "sender_full_name": "Daniel Donnelly",
        "timestamp": 1566638956
    },
    {
        "content": "<p>How can I browse Lean's mathlib with VS code. Lean works in VS code, but when I open a file in mathlib (I cloned the code) it cannot resolve the imports. I did \"leanpkg configure\" and \"leanpkg build\" in the root directory of mathlib</p>",
        "id": 176214388,
        "sender_full_name": "Juho Kupiainen",
        "timestamp": 1569001065
    },
    {
        "content": "<p>Are you opening the entire mathlib directory in VS Code? Often these issues occur when you just try to open a random file from mathlib without having opened the directory as a workspace.</p>",
        "id": 176216909,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1569002800
    },
    {
        "content": "<p>Opening the directory helped after I had created a new project according to the instruction on mathlib github page.</p>",
        "id": 176217470,
        "sender_full_name": "Juho Kupiainen",
        "timestamp": 1569003238
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>import data.rat\n\ndef mean (l : list rat) : rat := list.sum l / l.length\ndef E (f : rat -&gt; rat) (l : list rat) := mean $ list.map f l\n\ntheorem E.const_left (f : rat -&gt; rat) (c : rat) (l : list rat)\n    : E (fun x, c * f x) l = c * E f l  := sorry\n\ntheorem E.const_right (c : rat) (l : list rat) : E (fun x, x * c) l = E id l * c :=\n    have mult_dist : (fun x, x * c) = (fun x, c * x), from funext $ fun x, mul_comm x c,\n    have const_left : E (fun x, c * x) l = c * E id l, from E.const_left id c l,\n    calc\n        E (fun x, x * c) l = E (fun x, c * x) l : by rw mult_dist\n        ... = c * E id l : by rw const_left\n        ... = E id l * c : by rw mul_comm\n</pre></div>\n\n\n<p>I am trying to rewrite the above so the extraneous names and type annotations are eliminated. Here is what I want to write.</p>\n<div class=\"codehilite\"><pre><span></span>import data.rat\n\ndef mean (l : list rat) : rat := list.sum l / l.length\ndef E (f : rat -&gt; rat) (l : list rat) := mean $ list.map f l\n\ntheorem E.const_left (f : rat -&gt; rat) (c : rat) (l : list rat)\n    : E (fun x, c * f x) l = c * E f l  := sorry\n\ntheorem E.const_right (c : rat) (l : list rat) : E (fun x, x * c) l = E id l * c :=\n    calc\n        E (fun x, x * c) l = E (fun x, c * x) l : by {rw (funext $ fun x, mul_comm x c)}\n        ... = c * E id l : by {rw (E.const_left id c l)}\n        ... = E id l * c : by rw mul_comm\n</pre></div>\n\n\n<p>It says that the rewrite tactic fails for some reason. At first I thought that it might have been because in the original version some of the arguments were implicit, but that turned out to not be it. I am not sure what to think about this. I am having trouble with similar rewrites in other places. Lean seems to be bad at inferring the right types in the calc block proofs from expressions on the left side.</p>",
        "id": 178083107,
        "sender_full_name": "Marko Grdinić",
        "timestamp": 1571041555
    },
    {
        "content": "<p>In the first one, maybe you can try <code>by { funext, ext, rw mul_comm }</code>?</p>",
        "id": 178083521,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1571041916
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">E</span><span class=\"bp\">.</span><span class=\"n\">const_right</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">rat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">rat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">E</span> <span class=\"n\">id</span> <span class=\"n\">l</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n    <span class=\"k\">calc</span>\n        <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span><span class=\"o\">]</span>\n        <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">E</span> <span class=\"n\">id</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">E</span><span class=\"bp\">.</span><span class=\"n\">const_left</span><span class=\"bp\">;</span> <span class=\"n\">refl</span>\n        <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">E</span> <span class=\"n\">id</span> <span class=\"n\">l</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span>\n</pre></div>",
        "id": 178083712,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571042087
    },
    {
        "content": "<p>If you use <code> ```lean ... ``` </code> then you get syntax highlighting btw</p>",
        "id": 178083769,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571042146
    },
    {
        "content": "<p>also:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">E</span><span class=\"bp\">.</span><span class=\"n\">const_right</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">rat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">rat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">E</span> <span class=\"n\">id</span> <span class=\"n\">l</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">E</span><span class=\"bp\">.</span><span class=\"n\">const_left</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"o\">]</span>\n</pre></div>",
        "id": 178083849,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571042218
    },
    {
        "content": "<p>I am surprised by <code>.. = c * E id l : by rw ← E.const_left; refl</code>. Why rewrite to the left? That does not make much sense to me.</p>",
        "id": 178084361,
        "sender_full_name": "Marko Grdinić",
        "timestamp": 1571042651
    },
    {
        "content": "<p><code>rw</code> will rewrite any subterm of the <em>entire goal</em> using the given equation from left to right (or right to left if you give the <code>&lt;-</code>). That means that it can be used to rewrite the right side of the equation as well as the left side, at which point both sides become equal and <code>refl</code> closes the goal</p>",
        "id": 178084507,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571042796
    },
    {
        "content": "<p>Ah, I see. I just realized that <code>... = c * E id l : by rw E.const_left; refl</code> works too. The type error does not indicate what the problem is.</p>",
        "id": 178084708,
        "sender_full_name": "Marko Grdinić",
        "timestamp": 1571042995
    },
    {
        "content": "<p>Oh, I guess it was able to match <code>f := \\lam x, x</code> even if you write from left to right, I wouldn't have expected that</p>",
        "id": 178084919,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571043130
    },
    {
        "content": "<p>The matching problem from right to left is easier, because it doesn't have to do any higher order matching</p>",
        "id": 178084947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571043174
    },
    {
        "content": "<p>That is, it's easy to match <code> c * E id l</code> against the pattern <code>?c * E ?f ?l</code></p>",
        "id": 178084995,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571043223
    },
    {
        "content": "<p>Yeah, I think I understand it now.</p>\n<div class=\"codehilite\"><pre><span></span>rewrite tactic failed, did not find instance of the pattern in the target expression\n  E (λ (x : ℚ), c * id x) l\nstate:\nc : ℚ,\nl : list ℚ\n⊢ E (λ (x : ℚ), c * x) l = c * E id l\n</pre></div>\n\n\n<p>I should have looked at the type error more carefully. <code>c * id x</code> and <code>c * x</code> are not quite the same thing here.</p>\n<p>Is there a way to make <code>... = c * E id l : by {rw (E.const_left id c l)}</code> work by getting it to simplify the expression passed to <code>rw</code> namely the <code>E.const_left id c l</code> ?</p>",
        "id": 178085549,
        "sender_full_name": "Marko Grdinić",
        "timestamp": 1571043661
    },
    {
        "content": "<p>sure, but it would take more than one line to do so</p>",
        "id": 178085662,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571043736
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>        <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">E</span> <span class=\"n\">id</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"o\">{</span>\n          <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">E</span><span class=\"bp\">.</span><span class=\"n\">const_left</span> <span class=\"n\">id</span> <span class=\"n\">c</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n          <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">id</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n          <span class=\"n\">rw</span> <span class=\"n\">this</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 178085791,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571043809
    },
    {
        "content": "<p>it's easier in this case to rewrite backwards so you get <code>E (λ (x : ℚ), c * x) l = E (λ (x : ℚ), c * id x) l</code>, which can then be closed by <code>refl</code></p>",
        "id": 178085931,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571043892
    },
    {
        "content": "<p>because <code>id x</code> is defeq to <code>x</code></p>",
        "id": 178085944,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571043901
    },
    {
        "content": "<p>Thank you very much. This was definitely instructive for me.</p>",
        "id": 178086090,
        "sender_full_name": "Marko Grdinić",
        "timestamp": 1571044035
    },
    {
        "content": "<p>You can also use <code>erw (E.const_left id c l)</code>, which unfolds definitions while matching. However, we tend not to use <code>erw</code> much because it can be slow.</p>",
        "id": 178101981,
        "sender_full_name": "Reid Barton",
        "timestamp": 1571059140
    },
    {
        "content": "<p>In this case you can also just use the term <code>E.const_left id c l</code> directly, without bothering with <code>by rw </code></p>",
        "id": 178102034,
        "sender_full_name": "Reid Barton",
        "timestamp": 1571059190
    }
]
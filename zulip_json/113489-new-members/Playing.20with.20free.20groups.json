[
    {
        "content": "<p>I tried to get back to my questions about free groups, and tried the following. Can some kind soul please help me out?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.free_group</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">free_group</span> <span class=\"n\">bool</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g1</span> <span class=\"o\">:=</span> <span class=\"n\">free_group.mk</span> <span class=\"o\">[(</span><span class=\"n\">tt</span><span class=\"o\">,</span><span class=\"n\">tt</span><span class=\"o\">)]</span>\n<span class=\"kd\">def</span> <span class=\"n\">g2</span> <span class=\"o\">:=</span> <span class=\"n\">free_group.mk</span> <span class=\"o\">[(</span><span class=\"n\">ff</span><span class=\"o\">,</span><span class=\"n\">tt</span><span class=\"o\">)]</span>\n<span class=\"kd\">def</span> <span class=\"n\">G1</span> <span class=\"o\">:=</span> <span class=\"n\">free_group.mk</span> <span class=\"o\">[(</span><span class=\"n\">tt</span><span class=\"o\">,</span><span class=\"n\">ff</span><span class=\"o\">)]</span>\n<span class=\"kd\">def</span> <span class=\"n\">G2</span> <span class=\"o\">:=</span> <span class=\"n\">free_group.mk</span> <span class=\"o\">[(</span><span class=\"n\">ff</span><span class=\"o\">,</span><span class=\"n\">ff</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">trivialthm1</span> <span class=\"o\">:</span> <span class=\"n\">g1</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"n\">G1</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"c1\">-- this one is easy, it's by definition</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">trivialthm2</span> <span class=\"o\">:</span> <span class=\"n\">g1</span> <span class=\"bp\">≠</span> <span class=\"n\">g2</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"c1\">-- this is easy too, the map bool -&gt; f is injective. Is there a way to golf it down to a single command?</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"n\">free_group.of_injective</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">tauto</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">trivialthm3</span> <span class=\"o\">:</span> <span class=\"n\">g1</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"c1\">-- this is hard (for me)</span>\n  <span class=\"n\">intro</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"n\">free_group.reduce.sound</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"c1\">-- now goal is \"false\", and hypothesis is \"free_group.reduce [(tt, tt)] = free_group.reduce list.nil\"</span>\n  <span class=\"c1\">-- I want to say that these reductions are [(tt,tt)] and list.nil respectively, using free_group.reduce.cons</span>\n  <span class=\"c1\">-- and then say that the reductions are different, contradiction.</span>\n  <span class=\"c1\">-- I could do none of these things :(</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 235657059,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1619089577
    },
    {
        "content": "<p><code>cases k</code></p>",
        "id": 235659261,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619090803
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">trivialthm2</span> <span class=\"o\">:</span> <span class=\"n\">g1</span> <span class=\"bp\">≠</span> <span class=\"n\">g2</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">bool.no_confusion</span> <span class=\"bp\">$</span> <span class=\"n\">free_group.of_injective</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 235662905,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619092656
    },
    {
        "content": "<p>It's maybe nicer to directly define</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">g1</span> <span class=\"o\">:=</span> <span class=\"n\">free_group.of</span> <span class=\"n\">tt</span>\n<span class=\"n\">g2</span> <span class=\"o\">:=</span> <span class=\"n\">free_group.of</span> <span class=\"n\">ff</span>\n<span class=\"n\">G1</span> <span class=\"o\">:=</span> <span class=\"n\">g1</span><span class=\"bp\">⁻¹</span>\n<span class=\"n\">G2</span> <span class=\"o\">:=</span> <span class=\"n\">g2</span><span class=\"bp\">⁻¹</span>\n</code></pre></div>\n<p>For longer words you can just multiply the generators. The list stuff is sort of an implementation detail that you as an end-user shouldn't have to see. Of course <code>free_group.reduce.sound</code> will still give you an equality of lists (as it should), but you don't need to start with lists.</p>",
        "id": 235665893,
        "sender_full_name": "David Wärn",
        "timestamp": 1619093922
    },
    {
        "content": "<p><del>Hooray, my speculative adding of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/free_group.of_injective\">docs#free_group.of_injective</a> turned out to be useful!</del> edit: looks like I didn't add that one after all</p>",
        "id": 235667622,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619094562
    },
    {
        "content": "<p>Great, thanks a lot! now, harder: a free group on 3 generators! Am I creating a type with 3 elements in the correct way? (I know I could put everything into a \"free_group \\nat\", but I'd also like to be able to define free groups of finite rank \\ne 2). How do I tell lean that three's elements are distinct, and that there are exactly these three?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.free_group</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">three</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">three</span>\n<span class=\"bp\">|</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">three</span>\n<span class=\"bp\">|</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">three</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">free_group</span> <span class=\"n\">three</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g1</span> <span class=\"o\">:=</span> <span class=\"n\">free_group.of</span> <span class=\"n\">three.x</span>\n<span class=\"kd\">def</span> <span class=\"n\">g2</span> <span class=\"o\">:=</span> <span class=\"n\">free_group.of</span> <span class=\"n\">three.y</span>\n<span class=\"kd\">def</span> <span class=\"n\">g3</span> <span class=\"o\">:=</span> <span class=\"n\">free_group.of</span> <span class=\"n\">three.z</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">trivialthm1</span> <span class=\"o\">:</span> <span class=\"n\">g1</span><span class=\"bp\">*</span><span class=\"n\">g2</span><span class=\"bp\">*</span><span class=\"n\">g2</span><span class=\"bp\">⁻¹*</span><span class=\"n\">g1</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">trivialthm2</span> <span class=\"o\">:</span> <span class=\"n\">g1</span> <span class=\"bp\">≠</span> <span class=\"n\">g2</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">free_group.of_injective</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">trivialthm3</span> <span class=\"o\">:</span> <span class=\"n\">g1</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">free_group.reduce.sound</span> <span class=\"n\">h</span>\n<span class=\"c1\">-- fails: needs to know \"decidable_eq three\"</span>\n</code></pre></div>",
        "id": 235680239,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1619099340
    },
    {
        "content": "<p>You can use <code>fin 3</code></p>",
        "id": 235680443,
        "sender_full_name": "David Wärn",
        "timestamp": 1619099407
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> <a href=\"#narrow/stream/113489-new-members/topic/Playing.20with.20free.20groups/near/235680443\">said</a>:</p>\n<blockquote>\n<p>You can use <code>fin 3</code></p>\n</blockquote>\n<p>Very nice! So I'm happy with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g1</span> <span class=\"o\">:=</span> <span class=\"n\">free_group.of</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">g2</span> <span class=\"o\">:=</span> <span class=\"n\">free_group.of</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">g3</span> <span class=\"o\">:=</span> <span class=\"n\">free_group.of</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Now, something I don't understand (and could be unrelated): why is <code>def g2 := free_group.of (4 : fin 3)</code> legal? I guess types don't have cardinalities, but it seems I can coerce every natural into <code>fin 3</code>, meaning it has more than 3 elements!</p>",
        "id": 235682283,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1619099990
    },
    {
        "content": "<p><code>fin n</code> works modulo <code>n</code>, so <code>(0 : fin 3) = (3 : fin 3) = (6 : fin 3) = ...</code></p>",
        "id": 235682610,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1619100067
    },
    {
        "content": "<p>Actually Lean knows that <code>free_group A</code> has decidable equality whenever <code>A</code> does, so you can also write things like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">free_group</span>\n<span class=\"kd\">def</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">of</span> <span class=\"mi\">0</span>\n<span class=\"kd\">def</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">of</span> <span class=\"mi\">1</span>\n<span class=\"kd\">def</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">of</span> <span class=\"mi\">2</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">≠</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n</code></pre></div>",
        "id": 235682780,
        "sender_full_name": "David Wärn",
        "timestamp": 1619100119
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"130377\">@David Wärn</span> ! That's two hole-in-one in a row!</p>",
        "id": 235685003,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1619100808
    },
    {
        "content": "<p>The original inductive definition of <code>three</code> would also have been fine -- if you prefix it with <code>@[derive decidable_eq]</code> then probably the proofs would work just the same. You can't push <code>dec_trivial</code> too far though. However an MSc student of mine, Chris Hughes, has been working on group theory algorithms in Lean and he has some working tactics which can solve equalities and inequalities even in finitely presented groups (of course this is not decidable in general, but the algorithm just has a go and often succeeds).</p>",
        "id": 235689436,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619102313
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"263407\">@Laurent Bartholdi</span> if you want a challenge, this recent work of  Gardam <a href=\"https://arxiv.org/abs/2102.11818\">disproving the unit conjecture for group rings</a> got some <a href=\"https://www.quantamagazine.org/mathematician-disproves-group-algebra-unit-conjecture-20210412/\">press coverage</a> recently and would probably be an interesting but feasible challenge to do in Lean. I talked to <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> about it who pointed out that it would not be immediately straightforward but the arguments seem to me to be very amenable to formalisation.</p>",
        "id": 235958145,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619257987
    },
    {
        "content": "<p>That's a great idea! Unfortunately I'm again stuck at basics:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.free_group</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.monoid_algebra</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">free_group</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">of</span> <span class=\"mi\">0</span>\n<span class=\"kd\">def</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">of</span> <span class=\"mi\">1</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">rx</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra.of</span> <span class=\"n\">ℤ</span> <span class=\"o\">(</span><span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)))</span> <span class=\"n\">x</span> <span class=\"c1\">-- noncomputable!</span>\n<span class=\"kd\">def</span> <span class=\"n\">ry</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra.of</span> <span class=\"n\">ℤ</span> <span class=\"o\">(</span><span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)))</span> <span class=\"n\">y</span> <span class=\"c1\">-- noncomputable!</span>\n<span class=\"c1\">-- and: how do I avoid re-typing this \"(monoid_algebra.of ℤ (free_group (fin 2)))\"?</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">rx</span> <span class=\"bp\">≠</span> <span class=\"n\">ry</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span> <span class=\"c1\">-- understandably, fails</span>\n</code></pre></div>\n<p>If I can get this running, though, I think the Gardam paper will be easy to formalize. It's a matter of defining a group by 2x2 matrices, which we could do using (explicitly) invertible functions Z^2-&gt;Z^2, and have everything be evaluated by lean.</p>",
        "id": 236242308,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1619470909
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I should add that I convinced a few students to learn lean with me, and hopefully they'll soon be more expert than me. A suggestion I made was to formalize the ping-pong lemma (<a href=\"https://en.wikipedia.org/wiki/Ping-pong_lemma\">https://en.wikipedia.org/wiki/Ping-pong_lemma</a>), at least in its simplest form (proving that an action of a free group is faithful). Do you see any objections to this project?</p>",
        "id": 236243009,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1619471045
    },
    {
        "content": "<p>Here is how to do what you want:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.free_group</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.monoid_algebra</span>\n<span class=\"kd\">noncomputable theory</span> <span class=\"c1\">-- disables the noncomputable warning</span>\n<span class=\"kn\">open</span> <span class=\"n\">free_group</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">of</span> <span class=\"mi\">0</span>\n<span class=\"kd\">def</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">of</span> <span class=\"mi\">1</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">monoid_algebra</span> <span class=\"c1\">-- so we can jsut write `of` below, slightly less copy pasting</span>\n<span class=\"kd\">def</span> <span class=\"n\">rx</span> <span class=\"o\">:=</span> <span class=\"n\">of</span> <span class=\"n\">ℤ</span> <span class=\"n\">_</span> <span class=\"n\">x</span>  <span class=\"c1\">-- because lean knows where x and y live the free_group (fin 2) is duplicate information and you can leave that out with an underscore</span>\n<span class=\"kd\">def</span> <span class=\"n\">ry</span> <span class=\"o\">:=</span> <span class=\"n\">of</span> <span class=\"n\">ℤ</span> <span class=\"n\">_</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">rx</span> <span class=\"bp\">≠</span> <span class=\"n\">ry</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">monoid_algebra.of_injective</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"c1\">-- key lemma</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">dec_trivial</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">this</span><span class=\"o\">,</span>  <span class=\"c1\">-- same idea as your first example, one we have a statement about the free group over fin 2 everything is checkable by lean</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 236244628,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1619471497
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"263407\">@Laurent Bartholdi</span> this is what happened to me -- I introduced some students to Lean and after a while they started teaching it to me. <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> is an example -- Chris, do you think the ping pong lemma would be formalisable in a relatively straightforward manner?</p>",
        "id": 236248686,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619472807
    },
    {
        "content": "<p>Re: the Gardam paper -- Chris already pointed out to me that if you're not careful then you might find it hard to prove that the unit he constructs is not of the form lambda*g, i.e. you'll need to prove that various elements of your group are distinct. There seemed to be two ways of thinking about the group in the paper -- one as an extension of Z/2 x Z/2 by Z^3 and another as some explicit finite presentation. I don't know a maths proof that these two groups are equal (but I didn't look at the paper carefully and I don't know this stuff at all -- Chris has been doing his MSc project with me on finitely generated groups in Lean so might well know more)</p>",
        "id": 236248885,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619472920
    },
    {
        "content": "<p>Another simple result about free groups, which I think would be nice to see in Lean, is the fact that the free group on two generators contains as a subgroup a free group on infinitely many generators</p>",
        "id": 236251318,
        "sender_full_name": "David Wärn",
        "timestamp": 1619474333
    },
    {
        "content": "<p>I think proving the ping pong lemma should be fairly easy. It actually looks easier than proving associativity of multiplication of the free product. I do think that working with free groups is generally extremely challenging, there are a lot of arguments about the normal form that are intuitive on paper but very challenging to formalize. There are a bunch of questions about the best approach to this stuff. I think it might even be sensible to work mostly with binary coproducts, and then transfer to larger coproducts. Binary coproducts can be implemented as a subtype of <code>H × list (G × H) × G</code>, with the stipulation that none of the pairs in the list is <code>1</code>. The element <code>(h₁, [(g₂, h₂)], g₃) </code> would represent the element  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub><msub><mi>g</mi><mn>2</mn></msub><msub><mi>h</mi><mn>2</mn></msub><msub><mi>g</mi><mn>3</mn></msub></mrow><annotation encoding=\"application/x-tex\">h_1g_2h_2g_3</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. You could also just do the list of pairs and stipulate that the first and last elements are allowed to be one. It would require a lot of work to really work out how to properly reason with free groups. An elegant proof of associativity of multiplication of reduced words would be a nice start.</p>",
        "id": 236251616,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1619474497
    },
    {
        "content": "<p>I do think the current interface for free groups isn't anywhere near enough to reason about normal forms. I have some [code](<a href=\"https://github.com/ChrisHughes24/single_relation/tree/master/src/coprod\">https://github.com/ChrisHughes24/single_relation/tree/master/src/coprod</a> about normal forms of coproducts of groups, but the associativity proof is messy and it's not mathlib ready. I don't have time right now to work on it, but I certainly wouldn't be offended if someone else PRed it or modified it.</p>",
        "id": 236252352,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1619474881
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> <a href=\"#narrow/stream/113489-new-members/topic/Playing.20with.20free.20groups/near/236251318\">said</a>: </p>\n<blockquote>\n<p>Another simple result about free groups, which I think would be nice to see in Lean, is the fact that the free group on two generators contains as a subgroup a free group on infinitely many generators </p>\n</blockquote>\n<p>The argument I know for this is that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F(2)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mclose\">)</span></span></span></span> is isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">)</mo><mo>⋊</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">F(\\mathbb{Z}) \\rtimes \\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin amsrm\">⋊</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span> acts on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F(\\mathbb{Z})</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mclose\">)</span></span></span></span> by extending the left regular action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span> on itself. This is all really easy in Lean right now.</p>",
        "id": 236252492,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1619474946
    },
    {
        "content": "<p>Huh, I wasn't aware of this argument. I suppose you just show that <code>left (of 0)</code> and <code>right 1</code> freely generate this semidirect product? Anyway I agree it shouldn't be difficult. The argument I had in mind was to consider the kernel of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mn>2</mn><mo stretchy=\"false\">)</mo><mo>→</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">F(2) \\to \\mathbb Z</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> sending <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>, using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subgroup_is_free_of_is_free\">docs#subgroup_is_free_of_is_free</a>, and doing a bit of work to show that the set of generators is really <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><msup><mi>y</mi><mi>n</mi></msup><mi>x</mi><msup><mi>y</mi><mrow><mo>−</mo><mi>n</mi></mrow></msup><mo>∣</mo><mi>n</mi><mo>∈</mo><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{y^n x y^{-n} \\mid n \\in \\mathbb Z\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.021331em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">x</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mclose\">}</span></span></span></span> (it's this picture where you have an infinite path and a loop at every vertex).</p>",
        "id": 236253542,
        "sender_full_name": "David Wärn",
        "timestamp": 1619475504
    },
    {
        "content": "<p>My favourite theorem about finitely generated free groups is that a subgroup of index n is also f.g. free and the Euler characteristic 2g-2 gets multiplied by n, e.g. an index 2 subgroup of F(2) must be free on 3 generators. The proof I know is topological.</p>",
        "id": 236253714,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619475605
    },
    {
        "content": "<p>You can deduce this from what's currently in mathlib without too much effort! I did so <a href=\"https://github.com/dwarn/nielsen-schreier-2/blob/e51a8c6511d374dc584698c7fa236a5be47e7dbe/src/index_formula.lean#L79\">here</a> (except you need to perform some subtractions to get the usual version with finite ranks)</p>",
        "id": 236254107,
        "sender_full_name": "David Wärn",
        "timestamp": 1619475864
    },
    {
        "content": "<p>I mean mathlib now has the \"free\" part, you just need to do a bit more work to get the formula relating rank and index</p>",
        "id": 236254149,
        "sender_full_name": "David Wärn",
        "timestamp": 1619475905
    },
    {
        "content": "<p>Oh nice -- a constructive version!</p>",
        "id": 236254179,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619475919
    },
    {
        "content": "<p>I had no clue that the formula for the group's size was because of Euler's characteristic - that's really cool</p>",
        "id": 236254195,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1619475928
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/stream/113489-new-members/topic/Playing.20with.20free.20groups/near/236252352\">said</a>:</p>\n<blockquote>\n<p>I do think the current interface for free groups isn't anywhere near enough to reason about normal forms. I have some <a href=\"https://github.com/ChrisHughes24/single_relation/tree/master/src/coprod\">code</a> about normal forms of coproducts of groups, but the associativity proof is messy and it's not mathlib ready. I don't have time right now to work on it, but I certainly wouldn't be offended if someone else PRed it or modified it.</p>\n</blockquote>\n<p>There's a reasonably nice way to do this, where you take the set of reduced words and act on it one letter at a time, but mabye this is as complicated as what you currently have? Suppose we want to construct <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∐</mo><mi>i</mi></msub><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\coprod_i G_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497100000000001em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∐</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.16195399999999993em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. For <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> a reduced word and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>∈</mo><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">g \\in G_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, define the reduced word given by prepending <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> (this is your <code>rcons</code>). Then show that this determines an action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">G_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> on the set of reduced words. It's obviously faithful, by acting on the empty word. So for each <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> we can view <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">G_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> as a subgroup of the symmetric group on the reduced words. Then take the subgroup generated by all of these, and show it bijects with the set of reduced words</p>",
        "id": 236258166,
        "sender_full_name": "David Wärn",
        "timestamp": 1619478339
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Playing.20with.20free.20groups/near/236254179\">said</a>:</p>\n<blockquote>\n<p>Oh nice -- a constructive version!</p>\n</blockquote>\n<p>It's not completely constructive since taking spanning trees in the infinite-index case is verboten</p>",
        "id": 236258260,
        "sender_full_name": "David Wärn",
        "timestamp": 1619478384
    },
    {
        "content": "<p>I proved that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mi>Z</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F(Z)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mclose\">)</span></span></span></span> embeds into <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F(2)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mclose\">)</span></span></span></span> <a href=\"https://gist.github.com/ChrisHughes24/6829f57b86cb00b1067011f673c472b4\">https://gist.github.com/ChrisHughes24/6829f57b86cb00b1067011f673c472b4</a> Nowhere near as pretty as I'd like. There's some missing simp lemmas in the library about how a bunch of stuff like <code>mul_action.to_perm</code> behave.</p>",
        "id": 236262984,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1619481504
    },
    {
        "content": "<p>It's a special case of a more general argument saying <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>∗</mo><mi>H</mi><mo>≅</mo><mo stretchy=\"false\">(</mo><msub><mo>∐</mo><mrow><mi>h</mi><mo>∈</mo><mi>H</mi></mrow></msub><mi>G</mi><mo stretchy=\"false\">)</mo><mo>⋊</mo><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">G \\ast H \\cong (\\coprod_{h \\in H} G) \\rtimes H</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.07708em;vertical-align:-0.32708000000000004em;\"></span><span class=\"mopen\">(</span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∐</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.18639799999999984em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">h</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.08125em;\">H</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32708000000000004em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin amsrm\">⋊</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span></p>",
        "id": 236264648,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1619482595
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/113489-new-members/topic/Playing.20with.20free.20groups/near/236244628\">said</a>:</p>\n<blockquote>\n<p>Here is how to do what you want:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.free_group</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.monoid_algebra</span>\n<span class=\"kd\">noncomputable theory</span> <span class=\"c1\">-- disables the noncomputable warning</span>\n<span class=\"kn\">open</span> <span class=\"n\">free_group</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">of</span> <span class=\"mi\">0</span>\n<span class=\"kd\">def</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">of</span> <span class=\"mi\">1</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">monoid_algebra</span> <span class=\"c1\">-- so we can jsut write `of` below, slightly less copy pasting</span>\n<span class=\"kd\">def</span> <span class=\"n\">rx</span> <span class=\"o\">:=</span> <span class=\"n\">of</span> <span class=\"n\">ℤ</span> <span class=\"n\">_</span> <span class=\"n\">x</span>  <span class=\"c1\">-- because lean knows where x and y live the free_group (fin 2) is duplicate information and you can leave that out with an underscore</span>\n<span class=\"kd\">def</span> <span class=\"n\">ry</span> <span class=\"o\">:=</span> <span class=\"n\">of</span> <span class=\"n\">ℤ</span> <span class=\"n\">_</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">rx</span> <span class=\"bp\">≠</span> <span class=\"n\">ry</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">monoid_algebra.of_injective</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"c1\">-- key lemma</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">dec_trivial</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">this</span><span class=\"o\">,</span>  <span class=\"c1\">-- same idea as your first example, one we have a statement about the free group over fin 2 everything is checkable by lean</span>\n<span class=\"kd\">end</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Great! however, I'm stuck now an inch further:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">monoid_algebra</span> <span class=\"n\">ℤ</span> <span class=\"o\">(</span><span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">rx.support</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">rx</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">rx</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">monoid_algebra</span> <span class=\"n\">ℤ</span> <span class=\"o\">(</span><span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)))</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>It seems to me that, generally speaking, it's good to argue about supports of elements in a group ring. However, I find it hard to dec_trivial away any of the examples, such as the next-to-last one.</p>\n<p>As I understand it, elements of a group ring are functions, so it makes sense to evaluate them. This is what I try in the last example : show two functions differ because they have different values at x.</p>",
        "id": 236506364,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1619616498
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> <a href=\"#narrow/stream/113489-new-members/topic/Playing.20with.20free.20groups/near/236258166\">said</a>:</p>\n<blockquote>\n<p>There's a reasonably nice way to do this, where you take the set of reduced words and act on it one letter at a time, but mabye this is as complicated as what you currently have? Suppose we want to construct <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∐</mo><mi>i</mi></msub><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\coprod_i G_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497100000000001em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∐</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.16195399999999993em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. For <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> a reduced word and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>∈</mo><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">g \\in G_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, define the reduced word given by prepending <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> (this is your <code>rcons</code>). Then show that this determines an action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">G_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> on the set of reduced words. It's obviously faithful, by acting on the empty word. So for each <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> we can view <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">G_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> as a subgroup of the symmetric group on the reduced words. Then take the subgroup generated by all of these, and show it bijects with the set of reduced words</p>\n</blockquote>\n<p>I second this -- the reference is [van der Waerden, B. L. Free products of groups. Amer. J. Math. 70 (1948), 527–528. <a href=\"https://doi.org/10.2307/2372196]\">https://doi.org/10.2307/2372196]</a>.  The article really feels like van der Waerden had formalization in mind!</p>",
        "id": 236563482,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1619637641
    },
    {
        "content": "<p>Thanks for this reference! I only knew it as a folklore idea, so it's nice to see the reference. I wrote up a definition of coproducts in PR  <a href=\"https://github.com/leanprover-community/mathlib/issues/7395\">#7395</a> using some of these ideas. It turned out quite nice.</p>",
        "id": 236572448,
        "sender_full_name": "David Wärn",
        "timestamp": 1619641474
    },
    {
        "content": "<p>For supports in the monoid algebra: there is a lemma called <code>finsupp.support_single_ne_zero</code> which should do what you want. Note the it relies on the non-obvious fact <code>1 ≠ 0</code>. <code>simp</code> can help you with the second sorry if you let it know what <code>rx</code> is (e.g. <code>simp [rx]</code>)</p>",
        "id": 236575348,
        "sender_full_name": "David Wärn",
        "timestamp": 1619642788
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> <a href=\"#narrow/stream/113489-new-members/topic/Playing.20with.20free.20groups/near/236575348\">said</a>:</p>\n<blockquote>\n<p>For supports in the monoid algebra: there is a lemma called <code>finsupp.support_single_ne_zero</code> which should do what you want. Note the it relies on the non-obvious fact <code>1 ≠ 0</code>. <code>simp</code> can help you with the second sorry if you let it know what <code>rx</code> is (e.g. <code>simp [rx]</code>)</p>\n</blockquote>\n<p>I just feel I managed to conquer Mt Everest:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">x_ne_y</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">rx</span> <span class=\"bp\">+</span> <span class=\"n\">ry</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finsupp.nonzero_iff_exists</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">rx</span><span class=\"o\">,</span><span class=\"n\">ry</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finsupp.single_apply</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">x_ne_y.symm</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Is there a better way to do this? In particular, how do I avoid putting \"simp\" everywhere?</p>",
        "id": 236651096,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1619692305
    },
    {
        "content": "<p>A shorter proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">rx</span> <span class=\"bp\">+</span> <span class=\"n\">ry</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">rx</span><span class=\"o\">,</span> <span class=\"n\">ry</span><span class=\"o\">,</span> <span class=\"n\">monoid_algebra.of_apply</span><span class=\"o\">,</span> <span class=\"n\">monoid_algebra.of_apply</span><span class=\"o\">,</span> <span class=\"n\">finsupp.nonzero_iff_exists</span><span class=\"o\">],</span>\n  <span class=\"n\">use</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finsupp.add_apply</span><span class=\"o\">,</span> <span class=\"n\">finsupp.single_eq_same</span><span class=\"o\">,</span><span class=\"n\">finsupp.single_eq_of_ne</span> <span class=\"n\">x_ne_y.symm</span><span class=\"o\">,</span> <span class=\"n\">add_zero</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">one_ne_zero</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 236655811,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619694896
    },
    {
        "content": "<p>Or a different strategy:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">rx</span> <span class=\"bp\">+</span> <span class=\"n\">ry</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">dunfold</span> <span class=\"n\">rx</span> <span class=\"n\">ry</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">monoid_algebra.of_apply</span><span class=\"o\">,</span> <span class=\"n\">monoid_algebra.of_apply</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">eq_neg_iff_add_eq_zero</span><span class=\"o\">,</span>\n    <span class=\"bp\">←</span><span class=\"n\">finsupp.single_neg</span><span class=\"o\">,</span> <span class=\"n\">finsupp.single_eq_single_iff</span><span class=\"o\">],</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">x_ne_y</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>where <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finsupp.single_eq_single_iff\">docs#finsupp.single_eq_single_iff</a> does most of the work</p>",
        "id": 236656566,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619695281
    },
    {
        "content": "<p>OK, my next attempt: a new tactic! There are 2 things I could not find in the documentation: how to use a tactic variable (here \"elt\"), and how to construct on-the-fly a proof of equality / inequality of group elements:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">group_ring_ne_zero_at</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">elt</span> <span class=\"o\">:</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">monoid_algebra.of_apply</span> <span class=\"o\">},</span>\n          <span class=\"n\">rw</span> <span class=\"n\">finsupp.nonzero_iff_exists</span><span class=\"o\">,</span>\n          <span class=\"n\">use</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"c1\">-- here \"use elt\" does not work :(</span>\n          <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">finsupp.add_apply</span> <span class=\"o\">},</span>\n          <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finsupp.single_eq_same</span><span class=\"o\">,</span><span class=\"n\">finsupp.single_eq_of_ne</span> <span class=\"n\">x_ne_y.symm</span><span class=\"o\">]</span> <span class=\"o\">},</span> <span class=\"c1\">-- I want the tactic to look up the variable of the present term, and try to prove (by dec_trivial) that they're equal or unequal</span>\n          <span class=\"n\">simp</span>\n         <span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">rx</span> <span class=\"bp\">+</span> <span class=\"n\">rx</span> <span class=\"bp\">+</span> <span class=\"n\">ry</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">rx</span><span class=\"o\">,</span> <span class=\"n\">ry</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"n\">group_ring_ne_zero_at</span> <span class=\"n\">x</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 236830399,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1619787817
    },
    {
        "content": "<p>Yes, it's unfortunately the case that you can't use antiquotations to embed variables inside <code>`[...]</code> blocks.</p>",
        "id": 236831168,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619788146
    },
    {
        "content": "<p>Instead you need to lean the distinction between \"interactive\" tactics and non-interactive tactics, and use these \"under the hood\" tactics.</p>",
        "id": 236831212,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619788168
    },
    {
        "content": "<p>If you jump-to-definition on <code>use</code>, you'll see that it immediately calls <code>tactic.use</code>, which is the underlying non-interactive tactic.</p>",
        "id": 236831327,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619788215
    },
    {
        "content": "<p>However you'll see that <code>use</code> doesn't take a <code>g</code>, of course, it takes a <code>list pexpr</code>.</p>",
        "id": 236831452,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619788269
    },
    {
        "content": "<p><code>pexpr</code> is a \"pre-expression\": a \"meta\" representation of some mathematical term.</p>",
        "id": 236831521,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619788299
    },
    {
        "content": "<p>When you actually use <code>use</code> inside a <code>begin ... end</code> block the parser takes care of converting what you thinking of as \"the actual mathematical thing <code>x</code>\" into this <code>pexpr</code> representation of it.</p>",
        "id": 236831639,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619788350
    },
    {
        "content": "<p>(Of course, Lean itself knows nothing about \"the actual mathematical thing\", and is just manipulating <code>pexpr</code> and <code>expr</code> objects in the C++ code.)</p>",
        "id": 236831686,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619788381
    },
    {
        "content": "<p>So if you want to do this too in your tactic you'll need to learn a bit about the parser, and take <code>pexpr</code> arguments as appropriate.</p>",
        "id": 236831789,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619788439
    },
    {
        "content": "<p>Explaining all that is perhaps beyond the scope of this thread, but you should watch Rob Lewis' excellent tutorial from LFTCM2020, and its associated exercises.</p>",
        "id": 236831874,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619788473
    },
    {
        "content": "<p><a href=\"https://www.youtube.com/playlist?list=PLlF-CfQhukNnq2kDCw2P_vI5AfXN7egP2\">https://www.youtube.com/playlist?list=PLlF-CfQhukNnq2kDCw2P_vI5AfXN7egP2</a></p>",
        "id": 236831916,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619788497
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> <a href=\"#narrow/stream/113489-new-members/topic/Playing.20with.20free.20groups/near/235682780\">said</a>:</p>\n<blockquote>\n<p>Actually Lean knows that <code>free_group A</code> has decidable equality whenever <code>A</code> does, so you can also write things like</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">free_group</span>\n<span class=\"kd\">def</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">of</span> <span class=\"mi\">0</span>\n<span class=\"kd\">def</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">of</span> <span class=\"mi\">1</span>\n<span class=\"kd\">def</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">of</span> <span class=\"mi\">2</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">≠</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>i'm trying to do proofs with free groups and was wondering what the \"of\" notation means, and where else it could be used? or if you could link me somewhere? also, does <code>free_group.of</code> and <code>of</code> do the same things?<br>\ncould you also explain how <code>fin 3</code> is implemented?</p>",
        "id": 243110341,
        "sender_full_name": "Holly Liu",
        "timestamp": 1623983581
    },
    {
        "content": "<p>If the namespace <code>free_group</code> is open (which will happen if we run <code>open free_group</code>) then yes <code>of</code> will very likely be shorthand for <code>free_group.of</code></p>",
        "id": 243111119,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1623984722
    },
    {
        "content": "<p>Does the docstring at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/free_group.of\">docs#free_group.of</a> help?</p>",
        "id": 243111211,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1623984856
    },
    {
        "content": "<p><code>fin 3</code> is a simple to use type with only 3 terms/elements, a term of <code>fin 3</code> is a natural number <code>n</code> and a proof that <code>n</code> is less than 3. As the proofs don't change which terms are equal you can just think of these terms as the number 0,1,2.</p>",
        "id": 243111312,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1623985027
    },
    {
        "content": "<p>So <code>of 0</code> is the generator corresponding to the number 0 of the free group generated by the terms 0, 1, 2</p>",
        "id": 243111383,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1623985100
    },
    {
        "content": "<p>Where these terms have no relations between them in the free group</p>",
        "id": 243111390,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1623985134
    },
    {
        "content": "<p>that helps a lot, thanks. is <code>def g1 := free_group.of tt</code> creating a <code>list (g1 x tt)</code>? and is <code>list (g1 x ff)</code> its inverse?</p>",
        "id": 243112497,
        "sender_full_name": "Holly Liu",
        "timestamp": 1623986663
    },
    {
        "content": "<p>actually, is it the generator corresponding to the bool true of the free group?</p>",
        "id": 243112819,
        "sender_full_name": "Holly Liu",
        "timestamp": 1623987133
    },
    {
        "content": "<p>Yeah the second thing, its just a single term of type <code>free_group bool</code></p>",
        "id": 243112930,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1623987299
    },
    {
        "content": "<p>ok. is there a difference between using<code>tt</code> or <code>ff</code>?</p>",
        "id": 243113301,
        "sender_full_name": "Holly Liu",
        "timestamp": 1623987840
    },
    {
        "content": "<p>The terms <code>tt</code> (true) and <code>ff</code> (false) are the two distinct terms of <code>bool</code> so the corresponding <code>of tt</code> and <code>of ff</code> are terms of <code>free_group bool</code>that are not equal.</p>",
        "id": 243113374,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1623987947
    },
    {
        "content": "<p>i was wondering where <code>quot.mk</code> is defined? i found the following snippet at <a href=\"https://github.com/leanprover-community/lean/blob/a5822ea47ebc52eec6323d8f1b60f6ec025daf99/library/init/data/quot.lean#L93\">https://github.com/leanprover-community/lean/blob/a5822ea47ebc52eec6323d8f1b60f6ec025daf99/library/init/data/quot.lean#L93</a> that uses <code>mk</code> in the definition of <code>mk</code>, which I am a bit confused about.  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">mk</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">quotient</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"n\">quot.mk</span> <span class=\"n\">setoid.r</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 243695979,
        "sender_full_name": "Holly Liu",
        "timestamp": 1624474109
    },
    {
        "content": "<p><code>quot</code> is a bit special, it's added by the command <code>init_quotient</code> <a href=\"https://github.com/leanprover-community/lean/blob/a5822ea47ebc52eec6323d8f1b60f6ec025daf99/library/init/core.lean#L162\">here</a>.</p>",
        "id": 243696174,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1624474218
    },
    {
        "content": "<p>Section <a href=\"https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#quotients\">11.4 of TPiL</a> is about quotient types in Lean.</p>",
        "id": 243696304,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1624474287
    },
    {
        "content": "<p>This is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quotient.mk\">docs#quotient.mk</a> being defined in terms of <code>quot.mk</code>, which is defined by magic at start-up in an unconventional way.</p>",
        "id": 243720978,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624487320
    }
]
[
    {
        "content": "<p>I have a situation where I want to extend a structure with an additional proof that its partial function is in fact total. I don't want to create a whole new structure because I want to view it as an instance of the more general structure and use all the existing definitions for it. </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">process_model</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">c0</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">O</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">compat</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">transfer</span> <span class=\"n\">P</span> <span class=\"n\">O</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">T</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">gt_process_model</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">process_model</span> <span class=\"n\">C</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">total</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">O</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">incorrect</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">process_model</span> <span class=\"n\">C</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">gt_process_model</span> <span class=\"n\">C</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">m_reach_state</span> <span class=\"n\">K</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">m_reach_state</span> <span class=\"n\">R</span> <span class=\"n\">s</span><span class=\"o\">))</span>\n</code></pre></div>\n\n\n<p>The problem with the above is that <code>R</code> is of the wrong type in the final definition. I could explicitly define the coersion that forgets the totality of <code>O</code>,  but I don't have a good grasp for how coersions work. </p>\n<p>If I declare <code>gt_process_model</code> as an instance of <code>process_model</code> Lean complains that <code>process_model</code> is not a class (obviously true). But when I simply declare it as a class, all sorts of other definitions start breaking. What do I need to do to get Lean to let me write something like </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">incorrect</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">process_model</span> <span class=\"n\">C</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">gt_process_model</span> <span class=\"n\">C</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">m_reach_state</span> <span class=\"n\">K</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">m_reach_state</span> <span class=\"err\">↑</span><span class=\"n\">R</span> <span class=\"n\">s</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 208230105,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1598541042
    },
    {
        "content": "<p>Ok, I figured something out. It works if I define an instance of <code>has_lift_t</code> as follows:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">instance</span> <span class=\"n\">gtpm_lift</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">has_lift_t</span> <span class=\"o\">(</span><span class=\"n\">gt_process_model</span> <span class=\"n\">C</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">process_model</span> <span class=\"n\">C</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">R</span><span class=\"bp\">.</span><span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">c0</span> <span class=\"o\">:=</span> <span class=\"n\">R</span><span class=\"bp\">.</span><span class=\"n\">c0</span><span class=\"o\">,</span> <span class=\"n\">O</span> <span class=\"o\">:=</span> <span class=\"n\">R</span><span class=\"bp\">.</span><span class=\"n\">O</span><span class=\"o\">,</span> <span class=\"n\">T</span> <span class=\"o\">:=</span> <span class=\"n\">R</span><span class=\"bp\">.</span><span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">compat</span> <span class=\"o\">:=</span> <span class=\"n\">R</span><span class=\"bp\">.</span><span class=\"n\">compat</span> <span class=\"o\">}</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n\n\n<p>Type class inference needs a little help my final definition, but it works once I explicitly elaborate the types: </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">incorrect</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">process_model</span> <span class=\"n\">C</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">gt_process_model</span> <span class=\"n\">C</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">m_reach_state</span> <span class=\"n\">K</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">m_reach_state</span> <span class=\"n\">C</span> <span class=\"n\">S</span> <span class=\"err\">↑</span><span class=\"n\">R</span> <span class=\"n\">s</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 208233570,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1598542301
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"300396\">Paul Rowe</span> <a href=\"#narrow/stream/113489-new-members/topic/making.20coersions/near/208233570\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">instance</span> <span class=\"n\">gtpm_lift</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">has_lift_t</span> <span class=\"o\">(</span><span class=\"n\">gt_process_model</span> <span class=\"n\">C</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">process_model</span> <span class=\"n\">C</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">gt_process_model</span><span class=\"bp\">.</span><span class=\"n\">to_process_model</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n\n\n</blockquote>\n<p>I can't check it right now, but you could probably use coercion function that <code>extends</code> defines for you here.</p>",
        "id": 208248849,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598549045
    },
    {
        "content": "<p>Would that be <code>R.to_process_model</code> in this case? Is there a less verbose notation? I am starting to run into problems with my approach. Lean seems to be getting confused about the access functions. Or rather, I'm the one who's confused and I can't figure out what Lean wants me to think. :)</p>\n<p>Edit: using <code>R.to_process_model</code> looks promising so far. But it's so clunky to type and read. That's why I'm looking for a slicker notation.</p>",
        "id": 208250794,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1598550018
    },
    {
        "content": "<p>It can be a bit of a surprise that all <code>extends</code> does for structures is to create a totally new type that happens to also include the fields of the original structure (while defining a <code>to_X</code> function to cast it to the supertype).  You might need to define a bunch of lemmas (which you can mark with <code>@[simp]</code>) to rewrite access functions on the <code>gt_process_model</code> to ones on the <code>to_process_model</code> version to keep confusion under control.</p>\n<p>(The <code>extends</code> keyword seems to work in a slightly different way for classes, since it seems to define an instance for you, too.)</p>",
        "id": 208252527,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598550852
    },
    {
        "content": "<p>I'm not sure what the best way of dealing with this is -- it's just something I might try if I wanted to use <code>extends</code> for structures.</p>",
        "id": 208252636,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598550909
    },
    {
        "content": "<p>Thanks. That helps me a lot. It does seem like a shame that it's not somehow simpler all around. I'll have to play around more with classes and instances to see what mode works best for me. </p>\n<p>I appreciate the help!</p>",
        "id": 208253678,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1598551347
    },
    {
        "content": "<p>I think the issue is that type inference in the presence of subtype relationships for records ends up being tricky, so Lean doesn't support it, but I'm not sure what the problem is exactly.</p>",
        "id": 208255679,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598552228
    }
]
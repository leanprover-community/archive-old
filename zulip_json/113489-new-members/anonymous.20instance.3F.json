[
    {
        "content": "<p>In TPIL, the example syntax for the <code>instance</code> declaration is given as (for example)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">Prop_inhabited</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">inhabited.mk</span> <span class=\"n\">true</span>\n</code></pre></div>\n<p>In reading the source code for the <code>list</code> type, I see something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">is_left_id</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">has_append.append</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span> <span class=\"n\">nil_append</span> <span class=\"o\">⟩</span>\n</code></pre></div>\n<p>A few questions:</p>\n<ul>\n<li>why is there no name for this instance?</li>\n<li>if I do the command <code>#print instances is_left_id</code> if find that <code>list.nil.is_left_id</code> shows up, which, it seems to me, is the instance declared above.  But how did it get associated with <code>list.nil</code>?</li>\n<li>I gather that the <code>\\&lt; \\&gt;</code> is a default constructor of some kind, so <code>nil_append</code> proves the claim that <code>[]</code> is in fact a left identity element for <code>list.append</code>. But how is this actually being done?</li>\n</ul>\n<p>I could add that it appears the reference manual doesn't yet cover the syntax for instances.... unless I'm looking in the wrong place.</p>",
        "id": 266940978,
        "sender_full_name": "Jeremy Teitelbaum",
        "timestamp": 1641392571
    },
    {
        "content": "<blockquote>\n<p>why is there no name for this instance?</p>\n</blockquote>\n<p><code>instance</code> will attempt to autogenerate a name for you if you do not provide one</p>\n<blockquote>\n<p>But how did it get associated with list.nil?</p>\n</blockquote>\n<p>Presumably it saw <code>[]</code> (which is syntax for list.nil) and named it after that</p>",
        "id": 266942450,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1641393434
    },
    {
        "content": "<blockquote>\n<p>But how is this actually being done?</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.nil_append/src\">src#list.nil_append</a> is the actual proof</p>",
        "id": 266942565,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1641393493
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/anonymous.20instance.3F/near/266942565\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>But how is this actually being done?</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.nil_append/src\">src#list.nil_append</a> is the actual proof</p>\n</blockquote>\n<p>I get that, but what is the purpose of the <code>\\&lt; \\&gt;</code>?</p>",
        "id": 266942860,
        "sender_full_name": "Jeremy Teitelbaum",
        "timestamp": 1641393671
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 266943064,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641393795
    },
    {
        "content": "<p>It's calling the constructor of <code>is_left_id</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">qq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">is_left_id</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">has_append.append</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span>\n<span class=\"n\">is_left_id.mk</span> <span class=\"n\">list.nil_append</span>\n</code></pre></div>",
        "id": 266943881,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641394203
    },
    {
        "content": "<p>This is the definition of <code>is_left_id</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[algebra]</span> <span class=\"kd\">class</span> <span class=\"n\">is_left_id</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">left_id</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">op</span> <span class=\"n\">o</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 266943974,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641394241
    },
    {
        "content": "<p>I'm going to write it in a strange syntax so maybe it's clearer:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">//</span> <span class=\"n\">this</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">lean</span><span class=\"bp\">!</span>\n<span class=\"kd\">instance</span> <span class=\"n\">qq</span> <span class=\"o\">{</span><span class=\"n\">α'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"n\">is_left_id</span><span class=\"o\">(</span>\n  <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">list</span> <span class=\"n\">α'</span><span class=\"o\">,</span>\n  <span class=\"n\">op</span> <span class=\"bp\">=</span> <span class=\"n\">has_append.append</span><span class=\"o\">,</span>\n  <span class=\"n\">o</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span>\n<span class=\"o\">)</span>\n</code></pre></div>",
        "id": 266944487,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641394453
    },
    {
        "content": "<p>(Almost?) every type in Lean is an inductive type. Structures are a special kind of inductive types, with only one constructor. For structure <code>foo</code>, this constructor is (usually) called <code>foo.mk</code> and that's what <code>⟨ ⟩</code> does under the hood. <code>⟨h1, h2, h3⟩ : foo</code> is interpreted as <code>foo.mk h1 h2 h3</code></p>",
        "id": 266945109,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641394745
    },
    {
        "content": "<p>Meanwhile <code>list.nil_append</code> says</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">nil_append</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"bp\">\\</span><span class=\"n\">alpha</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">[]</span> <span class=\"bp\">++</span><span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>so how does this get disassembled to yield the proper arguments for <code>is_left_id.mk</code>?</p>",
        "id": 266945216,
        "sender_full_name": "Jeremy Teitelbaum",
        "timestamp": 1641394803
    },
    {
        "content": "<p>To take a familiar example, if <code>p : P</code> and <code>q : Q</code> then <code>⟨p, q⟩ : P ∧ Q</code>.</p>",
        "id": 266945272,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641394809
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"462625\">Jeremy Teitelbaum</span> <a href=\"#narrow/stream/113489-new-members/topic/anonymous.20instance.3F/near/266945216\">said</a>:</p>\n<blockquote>\n<p>Meanwhile <code>list.nil_append</code> says</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">nil_append</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"bp\">\\</span><span class=\"n\">alpha</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">[]</span> <span class=\"bp\">++</span><span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>so how does this get disassembled to yield the proper arguments for <code>is_left_id.mk</code>?</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"n\">list.nil_append</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">@[_refl_lemma, _simp_cache, simp]</span>\n<span class=\"cm\">theorem list.nil_append : ∀ {α : Type u} (s : list α), list.nil ++ s = s :=</span>\n<span class=\"cm\">λ {α : Type u} (s : list α), rfl</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 266945476,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641394881
    },
    {
        "content": "<p>replace <code>list.nil ++ s</code> for <code>list.append list.nil s</code> and you'd get:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">list.nil_append</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">list.append</span> <span class=\"n\">list.nil</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">s</span>\n</code></pre></div>",
        "id": 266945613,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641394943
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 266945652,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641394964
    },
    {
        "content": "<p>That is, <code>list.nil_append</code> is exactly of the expected type</p>",
        "id": 266945792,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641395044
    },
    {
        "content": "<p>Yes, this is uncomfortable, I get you</p>",
        "id": 266946004,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641395128
    },
    {
        "content": "<p>Compare this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">op</span> <span class=\"n\">o</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>With this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">list.append</span> <span class=\"n\">list.nil</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">s</span>\n</code></pre></div>\n<p>Can you see the pattern here?</p>",
        "id": 266946737,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641395479
    },
    {
        "content": "<p>This is super helpful, thanks for your patience.  I see that pattern. But that is on the right hand side of the function definition for <code>is_left_id</code>,<br>\nand somehow I thought we were looking for arguments for the left side (in the definition). SO when you call <code>is_left_id.mk</code>, the effect is<br>\nto pull this apart and extract the components?</p>",
        "id": 266947169,
        "sender_full_name": "Jeremy Teitelbaum",
        "timestamp": 1641395692
    },
    {
        "content": "<p>An argument being on the left or right of the <code>:</code> has (the immense majority of the time) no effect.</p>",
        "id": 266947257,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641395743
    },
    {
        "content": "<p>I'm more concerned about the <code>:=</code> then then <code>:</code>.</p>",
        "id": 266947407,
        "sender_full_name": "Jeremy Teitelbaum",
        "timestamp": 1641395803
    },
    {
        "content": "<p>I hope to have understood your doubt. Let's see if I did.<br>\nGoing back to <code>is_left_id</code>, you can see:<br>\n<code>(left_id : ∀ a, op o a = a)</code></p>\n<p>If you had instead:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">some_foo_type</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">some_bar_type</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Calling <code>is_left_id.mk</code> would expect two parameters in the exact order defined above (<code>some_foo_type</code> then <code>some_bar_type</code>)</p>",
        "id": 266947972,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641396070
    },
    {
        "content": "<p>Well, I just looked at <code>is_left_id.mk</code> and I think some light is dawning:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">is_left_id.mk</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">?</span><span class=\"n\">M_1</span><span class=\"o\">),</span> <span class=\"bp\">?</span><span class=\"n\">M_2</span> <span class=\"bp\">?</span><span class=\"n\">M_3</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">is_left_id</span> <span class=\"bp\">?</span><span class=\"n\">M_1</span> <span class=\"bp\">?</span><span class=\"n\">M_2</span> <span class=\"bp\">?</span><span class=\"n\">M_3</span>\n</code></pre></div>\n<p>SO this is exactly what we want.</p>",
        "id": 266947980,
        "sender_full_name": "Jeremy Teitelbaum",
        "timestamp": 1641396074
    },
    {
        "content": "<p>Yeah, it's a function that, if you provide a term of type <code>(∀ (a : ?M_1), ?M_2 ?M_3 a = a)</code>, it returns a term of type <code>is_left_id ?M_1 ?M_2 ?M_3</code></p>",
        "id": 266948535,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641396342
    },
    {
        "content": "<p>And <code>list.nil_append</code> is of type <code>∀ (s : list α), list.append list.nil s = s</code>. So if you feed it to <code>is_left_id.mk</code> it will return a term of type <code>is_left_id (list α) list.append list.nil</code></p>",
        "id": 266948944,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641396523
    },
    {
        "content": "<p>There's extra stuff going on with this instance involving type classes. It's not a good minimal example of anonymous instance</p>",
        "id": 266949978,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641396948
    },
    {
        "content": "<p>Just to beat this into the ground, suppose i do </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">is_left_id.mk</span> <span class=\"n\">list.nil_append</span>\n</code></pre></div>\n<p>Then <code>#check</code> tells me that I have a term of type <code>is_left_id (list ?M_1) list.append list.nil</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">{</span><span class=\"n\">left_id</span> <span class=\"o\">:=</span> <span class=\"n\">list.nil_append</span> <span class=\"bp\">?</span><span class=\"n\">M_1</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">is_left_id</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"bp\">?</span><span class=\"n\">M_1</span><span class=\"o\">)</span> <span class=\"n\">append</span> <span class=\"n\">list.nil</span>\n</code></pre></div>\n<p>This term has a field <code>left_id</code> which is <code>list.nil_append ?M_1</code>.</p>\n<p>How would I fill in the placeholder <code>?M_1</code>?</p>",
        "id": 266951446,
        "sender_full_name": "Jeremy Teitelbaum",
        "timestamp": 1641397656
    },
    {
        "content": "<p>I'm not entirely sure of the context, but presumably ?M_1 is coming from an input in <code>{}</code> brackets. If you use <code>@foo</code> instead of <code>foo</code> then Lean will let you fill in the <code>{}</code> inputs instead of getting the unifier to do it.</p>",
        "id": 266951621,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641397745
    },
    {
        "content": "<p>e.g. <code>#check is_left_id.mk (@list.nil_append ℕ)</code></p>",
        "id": 266951792,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641397827
    },
    {
        "content": "<p>Yes after your comment I tried that and it cleared things up:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">is_left_id.mk</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">list.nil_append</span> <span class=\"bp\">\\</span><span class=\"n\">N</span> <span class=\"o\">)</span> <span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">left_id</span>\n</code></pre></div>\n<p>is a term:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">is_left_id.left_id</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">list.nil</span> <span class=\"bp\">++</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 266952148,
        "sender_full_name": "Jeremy Teitelbaum",
        "timestamp": 1641397997
    },
    {
        "content": "<p>Alternatively tell Lean the type you expect:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">is_left_id.mk</span> <span class=\"n\">list.nil_append</span> <span class=\"o\">:</span> <span class=\"n\">is_left_id</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"n\">append</span> <span class=\"n\">list.nil</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 266952167,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641398010
    },
    {
        "content": "<p>Is it fair to say that <code>is_left_id (list bool) append list.nil</code> is a proposition that asserts that <code>list.nil</code> is a left identity for <code>list.append</code>, and<br>\n<code>is_left_id.mk</code> constructs a proof of that proposition?  I need to keep types and terms of a given type straight in my head.</p>",
        "id": 266952445,
        "sender_full_name": "Jeremy Teitelbaum",
        "timestamp": 1641398146
    },
    {
        "content": "<p>Yes -- <code>is_left_id (list bool) append list.nil</code> is the theorem statement and <code>is_left_id.mk list.nil_append</code> is the proof.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"n\">is_left_id</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"n\">append</span> <span class=\"n\">list.nil</span> <span class=\"c1\">-- Prop</span>\n</code></pre></div>",
        "id": 266952608,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641398201
    },
    {
        "content": "<p>Hovering over <code>is_left_id</code> you can see the ultimate output is a term of type Prop (i.e. a theorem statement, which is a kind of type), and hovering over <code>is_left_id.mk</code> you can see that the ultimate output is a term of type <code>is_left_id α op o</code> which isn't a universe so must be a type of some kind (indeed it's a proposition) so this must be a term (i.e., in this case, a proof)</p>",
        "id": 266953340,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641398514
    },
    {
        "content": "<p>To return to the original question, how would one use this anonymous instance in practice?  My informal interpretation is that we have<br>\nproven the general fact that <code>list.append</code> has a left identity element <code>list.nil</code> and so the <code>list</code> class belongs to <code>has_append</code> and also its <code>append</code> method has this property.  Is there a way to see where this might be invoked?</p>",
        "id": 266954114,
        "sender_full_name": "Jeremy Teitelbaum",
        "timestamp": 1641398887
    },
    {
        "content": "<p>In practice the instance should be automatically resolved by type class resolution whenever required.</p>",
        "id": 266954187,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1641398938
    },
    {
        "content": "<p>I think he's asking for an example of such \"whenever required\" context, but it's not clear to me either <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 266954397,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641399026
    },
    {
        "content": "<p>Here's a trivial example.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">[]</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"o\">:=</span><span class=\"gr\">sorry</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>It seems like this result should be relevant here.</p>",
        "id": 266954672,
        "sender_full_name": "Jeremy Teitelbaum",
        "timestamp": 1641399166
    },
    {
        "content": "<p><code>example : [] ++ [0,1,2] = [0,1,2] := rfl</code> ;-)</p>",
        "id": 266954772,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641399220
    },
    {
        "content": "<p>Which brings me back to the question of what we needed the instance for in the first place.</p>",
        "id": 266954855,
        "sender_full_name": "Jeremy Teitelbaum",
        "timestamp": 1641399257
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">[]</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">is_left_id.left_id</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 266955018,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641399343
    },
    {
        "content": "<p>I think the instance is what allows you to prove <code>[] ++ [0,1,2] = [0,1,2]</code> with <code>rfl</code></p>",
        "id": 266955103,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641399366
    },
    {
        "content": "<p>no, this just follows from definition of <code>++</code></p>",
        "id": 266955127,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641399381
    },
    {
        "content": "<p>Oh I take that back!</p>",
        "id": 266955179,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641399405
    },
    {
        "content": "<p><code>++</code> is not <code>list.append</code>, it's <code>has_append.append</code></p>",
        "id": 266955209,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641399419
    },
    {
        "content": "<p>Still, the <code>is_left_id</code> instance has nothing to do with it being refl</p>",
        "id": 266955466,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641399555
    },
    {
        "content": "<p>Yes, we're just using the fact that this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_append</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>",
        "id": 266955513,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641399571
    },
    {
        "content": "<p>The presence or absence of an instance is never the reason a proof is <code>rfl</code>, unless the instance itself _defines_ the statement you're trying to prove.</p>",
        "id": 266955525,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1641399577
    },
    {
        "content": "<p>How would this instance be invoked then? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 266955655,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641399621
    },
    {
        "content": "<p>What makes it refl is that it's a concrete list.</p>",
        "id": 266955667,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641399625
    },
    {
        "content": "<p>Here, <code>((++) : list T -&gt; list T) = list.append := rfl</code> because of the <code>has_append</code> instance. Then <code>list.append [] s = s := rfl</code> by the definition of <code>list.append</code> (as long as I got the order of args right).</p>",
        "id": 266955717,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1641399649
    },
    {
        "content": "<p>For an arbitrary list (by which I mean we don't know how it was built), the lemma won't be refl</p>",
        "id": 266955753,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641399664
    },
    {
        "content": "<p>How about this  then:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">\\</span><span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"bp\">\\</span><span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"o\">[]</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"n\">x</span><span class=\"o\">]:=</span><span class=\"gr\">sorry</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 266955769,
        "sender_full_name": "Jeremy Teitelbaum",
        "timestamp": 1641399675
    },
    {
        "content": "<p>Lean is using the existence of <code>list.has_append</code> to make sense of the question, but then the question becomes <code>list.append [] [0,1,2] = [0,1,2]</code> which is definitionally true.</p>",
        "id": 266955783,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641399682
    },
    {
        "content": "<p>We still know how <code>[0, 1, x]</code> was built.</p>",
        "id": 266955939,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641399756
    },
    {
        "content": "<p>What's the question?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">[]</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"n\">x</span><span class=\"o\">]:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">is_left_id.left_id</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">[]</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"n\">x</span><span class=\"o\">]:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 266956014,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641399811
    },
    {
        "content": "<p>Here's an example where <code>rfl</code> doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"mi\">37</span> <span class=\"bp\">=</span> <span class=\"mi\">37</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 266956105,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641399854
    },
    {
        "content": "<p>I think one of the issues here is that <code>is_left_id</code> is maybe a bit of a niche typeclass</p>",
        "id": 266956129,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1641399878
    },
    {
        "content": "<p>So seeing where its used isn't so easy</p>",
        "id": 266956162,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1641399900
    },
    {
        "content": "<p>But <code>list.append</code> is defined by recursion on the left variable so <code>rfl</code> will always work here</p>",
        "id": 266956163,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641399901
    },
    {
        "content": "<p>The most \"practical\" use case would probably be to construct more complex algebraic type classses based on it?</p>",
        "id": 266956185,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1641399919
    },
    {
        "content": "<p>Yes. Just the same way as when you declare a <code>0</code> on a concrete type. When you're dealing with your <code>concrete_type</code> you can always use the spelling <code>concrete_type.zero</code> instead <code>0</code>. But without the <code>has_zero concrete_type</code> instance you can't use general machinery</p>",
        "id": 266956652,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641400189
    },
    {
        "content": "<p>Feels like I'm gonna be learning the basics of Lean for the next 5 years <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 266956830,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641400258
    },
    {
        "content": "<p>Here's a different example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">head</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span>       <span class=\"o\">:=</span> <span class=\"n\">default</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>here <code>head</code> is a function that takes a list and produces the first element of the list.</p>\n<p>But what if the list was empty? We want a function from list of alphas to alphas, rather than \"alpha or nothing\", so one way to do this is to pick once and for all a default element of alpha for each alpha.<br>\nOf course this isn't always possible, some types are empty and have no elements after all! But when it is we can define an instance of the inhabited typeclass, which is then inferred automatically whenever <code>head</code> is called.<br>\n<code>inhabited</code> has type</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">default</span> <span class=\"o\">[]</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>so we can make an instance using</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">inst1</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">default</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>but this is a bit verbose, when we just want to say a number, so this is where anonymous constructors, which are just a shorthand come in:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">inst2</span><span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>after defining one of these instances we can check it was inferred automatically by </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">list.head</span> <span class=\"o\">[]</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>This example also highlights one of the main stumbling blocks with typeclasses, what if we declare more than one of the same type? In this case this is a bad thing, as then the default value of nat will depend on whichever instance lean happens to choose. So in general we have to pay attention to ensure than all instances with the same type are equal.</p>",
        "id": 266957091,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1641400407
    },
    {
        "content": "<p>If we want to give the typeclass argument manually by hand we can do that too, by using <code>@</code> to signal that we want to provide all implicit arguments for example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">list.head</span> <span class=\"n\">ℕ</span> <span class=\"n\">inst1</span> <span class=\"o\">[]</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 266957299,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1641400507
    },
    {
        "content": "<p>This is the only time when the name of an instance should really matter, as it is a somewhat rare situation that we need to tell lean the instance by hand</p>",
        "id": 266957376,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1641400551
    },
    {
        "content": "<p>In LISP (which I admit I haven't used in 30 years) if you take the <code>car</code> of an empty list you get a <code>nil</code> symbol, but I guess in lean you can't even define the <code>head</code> of a list unless you have some kind of default value of the same type as the list entries, is that right?</p>",
        "id": 266958284,
        "sender_full_name": "Jeremy Teitelbaum",
        "timestamp": 1641400879
    },
    {
        "content": "<p>Right -- else you could take <code>[] : list empty</code> and make an element of the empty type which would let you prove anything</p>",
        "id": 266958405,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641400916
    },
    {
        "content": "<p>Yeah there are other functions like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.nth\">docs#list.nth</a> that you can use instead if you want that behaviour</p>",
        "id": 266959152,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1641401299
    },
    {
        "content": "<p>Maybe this is too vague, but suppose you want to write a Lean function that takes a string that represents a computation in postfix notation, and return the value of the expression. You'd typically use a stack.  I'm trying visualize what this might look like in lean.  Is there something like this out there to look at?</p>",
        "id": 266959440,
        "sender_full_name": "Jeremy Teitelbaum",
        "timestamp": 1641401446
    },
    {
        "content": "<p>On the earlier point: <br>\n<span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/113489-new-members/topic/anonymous.20instance.3F/near/266959152\">said</a>:</p>\n<blockquote>\n<p>Yeah there are other functions like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.nth\">docs#list.nth</a> that you can use instead if you want that behaviour</p>\n</blockquote>\n<p>So in that case you are extending the type of elements of the list to allow for a <code>none</code> symbol or whatever <code>option \\alpha</code> has.</p>",
        "id": 266959711,
        "sender_full_name": "Jeremy Teitelbaum",
        "timestamp": 1641401568
    },
    {
        "content": "<p>You're only extending the type of the output to allow <code>none</code> but yes.</p>",
        "id": 266959764,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641401600
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"462625\">Jeremy Teitelbaum</span> <a href=\"#narrow/stream/113489-new-members/topic/anonymous.20instance.3F/near/266959440\">said</a>:</p>\n<blockquote>\n<p>Maybe this is too vague, but suppose you want to write a Lean function that takes a string that represents a computation in postfix notation, and return the value of the expression. You'd typically use a stack.  I'm trying visualize what this might look like in lean.  Is there something like this out there to look at?</p>\n</blockquote>\n<p>Fun exercise! Here is how I would code it, note that this looks a bit different to the process of proving mathematical results in lean, but there is a lot of overlap still such as in using the equation compiler to make definitions specifying outputs corresponding to matching inputs, hope it helps!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.list.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.int.basic</span>\n\n<span class=\"c1\">-- following this outline from: https://www.geeksforgeeks.org/stack-set-4-evaluation-postfix-expression/</span>\n<span class=\"c1\">-- 1) Create a stack to store operands (or values).</span>\n<span class=\"c1\">-- 2) Scan the given expression and do the following for every scanned element.</span>\n<span class=\"c1\">-- …..a) If the element is a number, push it into the stack</span>\n<span class=\"c1\">-- …..b) If the element is an operator, pop operands for the operator from the stack. Evaluate the operator and push the result back to the stack</span>\n<span class=\"c1\">-- 3) When the expression is ended, the number in the stack is the final answer</span>\n\n<span class=\"c1\">-- this is a language of tokenised terms we will use, we do this because pattern matching on strings</span>\n<span class=\"c1\">-- isn't so nice in lean (roughly because strings are list of characters, which are given by nats</span>\n<span class=\"c1\">-- representing their ascii numeral)</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">postfix_lang</span>\n<span class=\"bp\">|</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">postfix_lang</span>\n<span class=\"bp\">|</span> <span class=\"n\">sub</span> <span class=\"o\">:</span> <span class=\"n\">postfix_lang</span>\n<span class=\"bp\">|</span> <span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"n\">postfix_lang</span>\n<span class=\"bp\">|</span> <span class=\"n\">nat</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">postfix_lang</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">postfix_lang</span>\n\n<span class=\"c1\">-- now we can make elements of this type like so</span>\n<span class=\"k\">#check</span> <span class=\"n\">postfix_lang.add</span>\n<span class=\"k\">#check</span> <span class=\"n\">postfix_lang.sub</span>\n<span class=\"k\">#check</span> <span class=\"n\">postfix_lang.nat</span> <span class=\"mi\">2</span>\n<span class=\"c1\">-- every element is either one of these symbols or a natural number</span>\n\n<span class=\"c1\">-- converts a string token, either + - or * into the postfix lang</span>\n<span class=\"kd\">def</span> <span class=\"n\">of_string</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"n\">postfix_lang</span>\n<span class=\"bp\">|</span> <span class=\"s2\">\"+\"</span> <span class=\"o\">:=</span> <span class=\"n\">add</span>\n<span class=\"bp\">|</span> <span class=\"s2\">\"-\"</span> <span class=\"o\">:=</span> <span class=\"n\">sub</span>\n<span class=\"bp\">|</span> <span class=\"s2\">\"*\"</span> <span class=\"o\">:=</span> <span class=\"n\">mul</span>\n<span class=\"bp\">|</span> <span class=\"n\">s</span>   <span class=\"o\">:=</span> <span class=\"n\">nat</span> <span class=\"o\">(</span><span class=\"n\">string.to_nat</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"c1\">-- anything that doesn't match the above gets converted to a nat</span>\n\n<span class=\"c1\">-- the core of the algorithm, a recursive function that takes a list of tokens and stack of integers</span>\n<span class=\"c1\">-- so far and returns the new stack</span>\n<span class=\"kd\">def</span> <span class=\"n\">eval_postfix_aux</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">postfix_lang</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">ℤ</span>\n<span class=\"c1\">-- the next token is an add so we take the first two elements of the stack, add them and put it</span>\n<span class=\"c1\">-- back on the rest of the stack, and recurse with the remaining tokens and that stack</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"o\">::</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">eval_postfix_aux</span> <span class=\"n\">r</span> <span class=\"o\">((</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">sub</span> <span class=\"o\">::</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">eval_postfix_aux</span> <span class=\"n\">r</span> <span class=\"o\">((</span><span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"o\">::</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">eval_postfix_aux</span> <span class=\"n\">r</span> <span class=\"o\">((</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"c1\">-- the next token is the natural number `n` so we put `n` on the stack (it is implicitly converted</span>\n<span class=\"c1\">-- to an integer)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat</span> <span class=\"n\">n</span> <span class=\"o\">::</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">eval_postfix_aux</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">::</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">s</span> <span class=\"c1\">-- if there are no operations left stop recursing and return the stack as is</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span> <span class=\"c1\">-- if we see anything else there is probably a mistake</span>\n\n<span class=\"c1\">-- we can call this directly on a list of postfix_langs like so</span>\n<span class=\"k\">#eval</span> <span class=\"n\">eval_postfix_aux</span> <span class=\"o\">[</span><span class=\"n\">nat</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">nat</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"n\">nat</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">mul</span><span class=\"o\">,</span> <span class=\"n\">add</span><span class=\"o\">,</span> <span class=\"n\">nat</span> <span class=\"mi\">9</span><span class=\"o\">,</span> <span class=\"n\">sub</span><span class=\"o\">]</span> <span class=\"o\">[]</span>\n<span class=\"k\">#eval</span> <span class=\"n\">eval_postfix_aux</span> <span class=\"o\">[</span><span class=\"n\">nat</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">nat</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"n\">nat</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">mul</span><span class=\"o\">,</span> <span class=\"n\">add</span><span class=\"o\">,</span> <span class=\"n\">nat</span> <span class=\"mi\">9</span><span class=\"o\">,</span> <span class=\"n\">sub</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"c1\">-- starting with a nonempty stack</span>\n<span class=\"k\">#eval</span> <span class=\"n\">eval_postfix_aux</span> <span class=\"o\">[</span><span class=\"n\">nat</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">nat</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"n\">nat</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">mul</span><span class=\"o\">,</span> <span class=\"n\">add</span><span class=\"o\">,</span> <span class=\"n\">nat</span> <span class=\"mi\">9</span><span class=\"o\">,</span> <span class=\"n\">sub</span><span class=\"o\">,</span> <span class=\"n\">sub</span><span class=\"o\">]</span> <span class=\"o\">[]</span> <span class=\"c1\">-- nonsense case</span>\n\n<span class=\"c1\">-- but you asked for a function from strings to evaluations, we can do this like so:</span>\n<span class=\"c1\">-- call the above algorithm on a string by tokenising, running eval_postfix_aux and then taking the</span>\n<span class=\"c1\">-- head of the resulting list</span>\n<span class=\"kd\">def</span> <span class=\"n\">eval_postfix</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">eval_postfix_aux</span> <span class=\"o\">((</span><span class=\"n\">s.split_on</span> <span class=\"sc\">' '</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">of_string</span><span class=\"o\">)</span> <span class=\"o\">[])</span><span class=\"bp\">.</span><span class=\"n\">head</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">eval_postfix</span> <span class=\"s2\">\"2 3 1 * + 9 -\"</span>\n<span class=\"k\">#eval</span> <span class=\"n\">eval_postfix</span> <span class=\"s2\">\"2 3 1 * + 9 - 7 +\"</span>\n\n<span class=\"c1\">-- we get zero if we do nonesense</span>\n<span class=\"k\">#eval</span> <span class=\"n\">eval_postfix</span> <span class=\"s2\">\"2 3 1 * + 9 - - - -\"</span>\n</code></pre></div>",
        "id": 266967464,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1641405237
    },
    {
        "content": "<p>This is fantastic, thanks!!!! <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> <span aria-label=\"octopus\" class=\"emoji emoji-1f419\" role=\"img\" title=\"octopus\">:octopus:</span></p>",
        "id": 266971583,
        "sender_full_name": "Jeremy Teitelbaum",
        "timestamp": 1641407225
    },
    {
        "content": "<p>Regarding <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_left_id\">docs#is_left_id</a> (and the entire file it resides in), it's part of a major refactor of the algebraic typeclasses that was abandoned long ago. See the github link at the top of the page.</p>",
        "id": 266971764,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1641407313
    },
    {
        "content": "<p>So the answer to \"what's the instance useful for\" is \"not much because those typeclasses never replaced things like <code>monoid</code>\"</p>",
        "id": 266971920,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1641407393
    },
    {
        "content": "<p>So much for reading the middle of source code files.</p>",
        "id": 266972954,
        "sender_full_name": "Jeremy Teitelbaum",
        "timestamp": 1641407859
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span>  following up on your parser, what about the following?<br>\nIn general terms, we have the type of <code>list postfix_lang</code> that you've described.  Then some of these are \"well-formed\" in the sense<br>\nthat they evaluate to a number. This gives a predicate on <code>list postfix_lang</code> which is decidable (via your algorithm).  Would such an approach make sense?</p>\n<p>I'm not trying to give you homework, so if you think it's reasonable I can try to do it for <em>my</em> homework.</p>",
        "id": 266985089,
        "sender_full_name": "Jeremy Teitelbaum",
        "timestamp": 1641413645
    },
    {
        "content": "<p>You could definitely define that predicate, either by counting number of operations vs number of nats in the list, or just asserting that <code>eval_postfix_aux</code> doesn't return <code>[]</code> I guess, hopefully one can prove they are equivalent. And it should be provable that it is a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/decidable_pred\">docs#decidable_pred</a>.</p>",
        "id": 266987674,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1641414958
    },
    {
        "content": "<p>OK, this gives me something concrete to think about, thanks for the help!</p>",
        "id": 266987901,
        "sender_full_name": "Jeremy Teitelbaum",
        "timestamp": 1641415074
    },
    {
        "content": "<p>Hmm I guess \"counting\" was a bit over-simple, and the condition is something like there are always at least 1 more number than operation in every prefix of the list?</p>",
        "id": 266988914,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1641415632
    }
]
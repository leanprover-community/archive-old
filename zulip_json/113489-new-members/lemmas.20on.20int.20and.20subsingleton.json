[
    {
        "content": "<p>Dear All,</p>\n<p>while working on the <code>lean-liquid</code> branch, I found the lemmas below useful and I could not find them in mathlib.  If you think that it would be helpful to have some of them in mathlib, let me know and I will be happy to make the relevant PRs!</p>\n<p>Thanks!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.associated</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int.nat_abs_eq_iff</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">n.nat_abs</span> <span class=\"bp\">=</span> <span class=\"n\">k</span> <span class=\"bp\">↔</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">k</span> <span class=\"bp\">∨</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">int.nat_abs_eq</span> <span class=\"n\">n</span> <span class=\"o\">},</span> <span class=\"kd\">by</span> <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int.is_unit_plus_minus_one_of</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"n\">n</span> <span class=\"bp\">↔</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∨</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"n\">is_unit_int.trans</span> <span class=\"o\">(</span><span class=\"n\">int.nat_abs_eq_iff.trans</span> <span class=\"n\">iff.rfl</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">function.injective.of_subsingleton</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">subsingleton</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">function.injective</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">ab</span><span class=\"o\">,</span> <span class=\"n\">subsingleton_iff.mp</span> <span class=\"n\">hs</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">function.surjective.to_subsingleton</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">subsingleton</span> <span class=\"n\">t</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">function.surjective</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"n\">function.surjective_iff_has_right_inverse.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">function.inv_fun</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">finish</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">subsingleton_eq_univ_of_mem</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">subsingleton</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">({</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">set.univ</span> <span class=\"o\">:=</span>\n<span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a1</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">set.mem_univ</span> <span class=\"n\">a1</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">set.mem_singleton_iff.mpr</span> <span class=\"o\">(</span><span class=\"n\">subsingleton_iff.mp</span> <span class=\"n\">hA</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 233275321,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617692692
    },
    {
        "content": "<p>LGTM.<br>\n<code>nonempty s</code> should be a type class assumption (in lemma 4)</p>",
        "id": 233275551,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617692851
    },
    {
        "content": "<p>For the last lemma, I wonder whether you want to generalise the LHS to an arbitrary set <code>s</code> with assumption <code>s.nonempty</code></p>",
        "id": 233275645,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617692900
    },
    {
        "content": "<p>Johan, thanks!</p>\n<p>lemma4 : I edited the list above and, in the same lemma, went ahead to make <code>subsingleton</code> also a typeclass assumption!</p>",
        "id": 233275735,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617692977
    },
    {
        "content": "<p>I am working on a proof of the other suggestion that you made!</p>",
        "id": 233276032,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617693202
    },
    {
        "content": "<p>I could almost find the version that Johan suggested with a set:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">subsingleton_eq_univ_of_subset</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">subsingleton</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">set.univ</span> <span class=\"o\">:=</span>\n<span class=\"n\">subsingleton.eq_univ_of_nonempty</span> <span class=\"n\">set.nonempty_of_nonempty_subtype</span>\n</code></pre></div>\n<p>and the same proof works for the earlier lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">subsingleton_eq_univ_of_mem</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">subsingleton</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">({</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">set.univ</span> <span class=\"o\">:=</span>\n<span class=\"n\">subsingleton.eq_univ_of_nonempty</span> <span class=\"n\">set.nonempty_of_nonempty_subtype</span>\n</code></pre></div>\n<p>I guess that this means that this lemma \"is\" already in mathlib!</p>",
        "id": 233277378,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617694126
    },
    {
        "content": "<p>Is <code>nonempty a</code> (for <code>a : set _</code>) the preferred spelling of set emptiness? That inserts a coercion to sort, which is why it would surprise me if it is!</p>",
        "id": 233278422,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617694835
    },
    {
        "content": "<p>Ah, indeed the proof you give translates your spelling to the less surprising one</p>",
        "id": 233278492,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617694889
    },
    {
        "content": "<p>I'm pretty sure I've seen int.nat_abs_eq_iff or similar in review recently...</p>",
        "id": 233278624,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617694972
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> <code>s</code> is a Type. Maybe those letters should be changed to <code>X</code> and <code>Y</code> or <code>\\alpha</code> and <code>\\beta</code>.</p>",
        "id": 233278749,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617695044
    },
    {
        "content": "<p>Ah, I mistakenly assumed the last code snippet agreed with the earlier ones, and didn't scroll sideways to check on mobile!</p>",
        "id": 233278865,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617695121
    },
    {
        "content": "<p>Besides the fact that there is one case in which the assumption <code>nonempty</code> is applied to a set, the confusion is probably also caused by the fact that I used <code>s</code> for a Type, whereas often <code>s</code> denotes a subset.   I tried to uniformize the notation, in the code below:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">int</span>\n\n<span class=\"c1\">-- proof provided by Ruben</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">nat_abs_eq_iff</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a.nat_abs</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">int.nat_abs_eq_nat_abs_iff</span><span class=\"o\">,</span> <span class=\"n\">int.nat_abs_of_nat</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_unit_plus_minus_one_of</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"n\">is_unit_int.trans</span> <span class=\"o\">(</span><span class=\"n\">nat_abs_eq_iff.trans</span> <span class=\"n\">iff.rfl</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">int</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">function.injective.of_subsingleton</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">subsingleton</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">function.injective</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">ab</span><span class=\"o\">,</span> <span class=\"n\">subsingleton_iff.mp</span> <span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">function.surjective.to_subsingleton</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">subsingleton</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">function.surjective</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"n\">function.surjective_iff_has_right_inverse.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">function.inv_fun</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">finish</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- this lemma and the next may be \"too close\" to results in mathlib: I will probably not PR them,</span>\n<span class=\"c1\">-- unless there is some explicit interest in them!</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">subsingleton_eq_univ_of_mem</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">subsingleton</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">({</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">set.univ</span> <span class=\"o\">:=</span>\n<span class=\"n\">subsingleton.eq_univ_of_nonempty</span> <span class=\"n\">set.nonempty_of_nonempty_subtype</span>\n\n<span class=\"c1\">-- here [nonempty s] introduces a coercion mentioned by Eric</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">subsingleton_eq_univ_of_subset</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">subsingleton</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">set.univ</span> <span class=\"o\">:=</span>\n<span class=\"n\">subsingleton.eq_univ_of_nonempty</span> <span class=\"n\">set.nonempty_of_nonempty_subtype</span>\n</code></pre></div>",
        "id": 233279732,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617695650
    },
    {
        "content": "<p>Alternative proof for the first one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.associated</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">int.nat_abs_eq_iff</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">n.nat_abs</span> <span class=\"bp\">=</span> <span class=\"n\">k</span> <span class=\"bp\">↔</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">k</span> <span class=\"bp\">∨</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">int.nat_abs_eq_nat_abs_iff</span><span class=\"o\">,</span> <span class=\"n\">int.nat_abs_of_nat</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 233279868,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1617695748
    },
    {
        "content": "<p>Ruben, thanks!  I will update with your proof, since it seems more direct!</p>",
        "id": 233279992,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617695794
    },
    {
        "content": "<p>I think <code>is_unit_plus_minus_one_of</code> is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/int.units_eq_one_or\">docs#int.units_eq_one_or</a></p>",
        "id": 233281212,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617696420
    },
    {
        "content": "<p>Or at least, it's a more direct proof via that lemma</p>",
        "id": 233281278,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617696460
    },
    {
        "content": "<p>Ok, I was actually right now playing with this, since I had also found <code>int.units_eq_one_or</code>, trying to place <code>is_unit_plus_minus_one_of</code></p>",
        "id": 233281386,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617696509
    },
    {
        "content": "<p>I am failing to be able to use <code>int.units_eq_one_or</code>.  I would like to apply the conclusion of that lemma to get Lean to ask me to produce a unit.  Is there a way to do this?</p>\n<p>What is a good way to proceed?</p>\n<p>Below is a proof that I would like to see if it can be made to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_unit_plus_neg_one_of</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">units_eq_one_or</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n<span class=\"c1\">-- of course this does not work, since Lean does not know that `a` is a piece of a unit.</span>\n<span class=\"c1\">-- How can I get Lean to proceed there?</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 233282308,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617697035
    },
    {
        "content": "<p>Also, the word <code>minus</code> should be <code>neg</code>!</p>",
        "id": 233283221,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617697497
    },
    {
        "content": "<p>Eric, this last one was easy to fix! <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 233283305,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617697534
    },
    {
        "content": "<p><code>is_unit.eq_one_or_neg_one</code>?</p>",
        "id": 233283580,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617697669
    },
    {
        "content": "<p>Of course it's a bit weird to put a lemma specific to <code>int</code> in the <code>is_unit</code> namespace</p>",
        "id": 233283638,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617697689
    },
    {
        "content": "<p>Do we already have <code>is_unit.eq_one</code> for <code>nat</code>?</p>",
        "id": 233283679,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617697707
    },
    {
        "content": "<p><del><code>library_search</code> doesn't find either of these:</del></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">nat.units_eq_one</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">units</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">library_search</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_unit.eq_one</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">library_search</span>\n</code></pre></div>\n<p>edit: ah, we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.units_eq_one\">docs#nat.units_eq_one</a></p>",
        "id": 233283863,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617697800
    },
    {
        "content": "<p>And <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.is_unit_iff\">docs#nat.is_unit_iff</a></p>",
        "id": 233284091,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617697875
    },
    {
        "content": "<p>So, should the name be <code>int.is_unit_iff</code>?</p>",
        "id": 233284298,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617697961
    },
    {
        "content": "<p>Still, I have not been able to prove the <code>is_unit</code> lemma from the <code>units</code> one.</p>",
        "id": 233284414,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617698007
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_unit.eq_one_or</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">units.coe_one</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">units.coe_neg</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">int.units_eq_one_or</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">imp</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">coe</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">coe</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 233284851,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617698219
    },
    {
        "content": "<p>To confuse me further, </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">is_unit_int</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"n\">n</span> <span class=\"bp\">↔</span> <span class=\"n\">n.nat_abs</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>is in <code>algebra/associated</code> and not in <code>data/int/basic</code>, where the stuff about units in <code>int</code> appears.</p>",
        "id": 233284937,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617698267
    },
    {
        "content": "<p>It might be that the reason for this is to not import <code>algebra/associated</code> into <code>data/int/basic</code>.</p>",
        "id": 233285115,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617698362
    },
    {
        "content": "<p>Or a shorter proof,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_unit.eq_one_or'</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hx</span> <span class=\"bp\">▸</span> <span class=\"o\">(</span><span class=\"n\">int.units_eq_one_or</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">imp</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">coe</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">coe</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 233285158,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617698389
    },
    {
        "content": "<p>If that proof can be moved to data/int/basic, it probably should be</p>",
        "id": 233285244,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617698423
    },
    {
        "content": "<p>At the moment, it cannot, since the proof uses lemmas in <code>algebra/associated</code>, but I am sure that I can prove this lemma from what is in <code>data/int/basic</code>, since we already know that units in <code>int</code> are 1 and -1!  <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 233285394,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617698504
    },
    {
        "content": "<p>Should it be an iff, though?</p>",
        "id": 233286130,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1617698924
    },
    {
        "content": "<p>Ruben, I took Erics suggestion to mean the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_unit.eq_one_or'</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hx</span> <span class=\"bp\">▸</span> <span class=\"o\">(</span><span class=\"n\">int.units_eq_one_or</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">imp</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">coe</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">coe</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_unit_iff</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">is_unit.eq_one_or'</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">is_unit_one</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">is_unit_of_mul_eq_one</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">neg_one_mul</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 233286282,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617699009
    },
    {
        "content": "<p>Note the <code>'</code> was just to distinguish it from my previous lemma, there's no need for <code>'</code> if you PR that</p>",
        "id": 233286732,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617699296
    },
    {
        "content": "<p>How do people feel about making <code>is_unit_iff</code> a <code>simp</code> lemma?</p>",
        "id": 233286813,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617699351
    },
    {
        "content": "<p><del>Should the <code>iff</code> version of <code>units</code> be there as well?</del><br>\nHmm, I had not given enough TT thought about this: the <code>units</code> lemma is tricky to convert into an iff, right?</p>",
        "id": 233286891,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617699378
    },
    {
        "content": "<p>Also as a simp lemma?</p>",
        "id": 233286894,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617699379
    },
    {
        "content": "<p>Looks like you could do with an <code>is_unit.neg</code> lemma there too:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_unit.neg</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_unit</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_unit_iff</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">is_unit.eq_one_or</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">is_unit_one</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">is_unit_one.neg</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 233287354,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617699656
    },
    {
        "content": "<p>I think that might be a bad idea as a simp lemma</p>",
        "id": 233287462,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617699721
    },
    {
        "content": "<p>With the changes above, the lemma below now fits in <code>data/int/basic</code> and is no longer needed in <code>algebra/associated</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">is_unit_int</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"n\">n</span> <span class=\"bp\">↔</span> <span class=\"n\">n.nat_abs</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nat_abs_eq_iff</span><span class=\"o\">,</span> <span class=\"n\">is_unit_iff</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 233287547,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617699743
    },
    {
        "content": "<p>Ok, I will remove the simp attribute!</p>",
        "id": 233287570,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617699759
    },
    {
        "content": "<p>I was thinking about the <code>is_unit.neg</code>, but it probably does not belong to any file that is already imported into <code>data/int/basic</code>, right?</p>",
        "id": 233287795,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617699856
    },
    {
        "content": "<p>I am happy to prove that the opposite of a unit is again a unit, though it would probably be a different PR!</p>",
        "id": 233287845,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617699895
    },
    {
        "content": "<p>I had</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_unit.neg</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">is_unit</span> <span class=\"n\">u</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"bp\">;</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">u'</span><span class=\"o\">,</span> <span class=\"n\">hu</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">use</span> <span class=\"bp\">-</span><span class=\"n\">u'</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hu</span><span class=\"o\">,</span> <span class=\"n\">neg_neg</span><span class=\"o\">,</span> <span class=\"n\">units.coe_neg</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 233288485,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1617700232
    },
    {
        "content": "<p>PR <a href=\"https://github.com/leanprover-community/mathlib/issues/7058\">#7058</a></p>",
        "id": 233288957,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617700508
    },
    {
        "content": "<p>Any is_unit lemma is also a lemma about units. And units are a group/subgroup depending on how you approach it. The neg one is just a special case of a mul_hom</p>",
        "id": 233327824,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617719278
    },
    {
        "content": "<p>Sure, but we have <code>is_unit.mul</code> and <code>is_unit.inv</code>, so we may as well add versions for the other operators for convenience</p>",
        "id": 233327970,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617719326
    },
    {
        "content": "<p>Do we have the fact that units are a subgroup?</p>",
        "id": 233328005,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617719339
    },
    {
        "content": "<p>In case it helps, this is the part of the code where opposites interact with <code>is_unit</code> in the PR:</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib/blob/042166150bc51f7976161ff8642f3b408a823f07/src/algebra/ring/basic.lean#L627\">https://github.com/leanprover-community/mathlib/blob/042166150bc51f7976161ff8642f3b408a823f07/src/algebra/ring/basic.lean#L627</a></p>",
        "id": 233328559,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617719528
    }
]
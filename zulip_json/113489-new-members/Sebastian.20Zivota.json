[
    {
        "content": "<p>Hi, I'm interested in formalizing some (synthetic) projective geometry in Lean for my own enjoyment. To be honest I'm already struggling with how to formulate the definition of a projective plane, to wit: A projective plane comprises a set P of Points and a set L of Lines, with an incidence relation ε between them, satisfying the following axioms:</p>\n<ol>\n<li>For every p, q ∈ P with p ≠ q, there is a unique ℓ ∈ L such that p ε ℓ and q ε ℓ.</li>\n<li>For every ℓ, m ∈ L with ℓ ≠ m, there is a p ∈ P such that p ε ℓ and p ε m.</li>\n<li>There are four points such that no three among them lie on a line.</li>\n</ol>\n<p>My first approach was to model this as a structure:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">projective_plane</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">is_on</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">L</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">connecting_line</span> <span class=\"o\">:</span> <span class=\"bp\">…</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">intersection_point</span> <span class=\"o\">:</span> <span class=\"bp\">…</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">exists_quadrangle</span> <span class=\"o\">:</span> <span class=\"bp\">…</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>But if I do this, I don't see how I can e.g. define ε as notation for is_on (because it's relative to the plane). Is this the right approach or should I be doing something differently?</p>",
        "id": 263148316,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1638280911
    },
    {
        "content": "<p>Here is a rough estimate for what could be done...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">projective_plane</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">is_on</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">L</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">connecting_line</span> <span class=\"o\">:</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">intersection_point</span> <span class=\"o\">:</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">exists_quadrangle</span> <span class=\"o\">:</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">a</span> <span class=\"bp\">`</span><span class=\"n\">ε</span><span class=\"bp\">`</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">projective_plane.is_on</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">projective_plane</span> <span class=\"n\">P</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">p</span> <span class=\"n\">ε</span> <span class=\"n\">l</span>\n</code></pre></div>",
        "id": 263149134,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1638281251
    },
    {
        "content": "<p>Excellent, thank you very much.</p>",
        "id": 263149638,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1638281479
    },
    {
        "content": "<p>yeah, creating a typeclass is a nice idea. alternatively, you can also use a <code>variables</code> declaration to introduce an instance of the plane structure, and then define notations to your heart's content!</p>",
        "id": 263149671,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1638281497
    },
    {
        "content": "<p>I prefer <code>variables</code> because that's what the IMO Grand Challenge does</p>",
        "id": 263149873,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1638281559
    },
    {
        "content": "<p>mathlib is a treasure trove of quality lean code. you should clone and read the code to learn lean <a href=\"https://github.com/leanprover-community/mathlib/tree/master/archive/imo\">https://github.com/leanprover-community/mathlib/tree/master/archive/imo</a></p>",
        "id": 263150108,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1638281643
    },
    {
        "content": "<p>Making <code>projective_plane</code> a class sounds like the way to go, because then you can instantiate it for concrete projective planes instead of always having to pass around the same 3 hypotheses.</p>",
        "id": 263154849,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638283552
    },
    {
        "content": "<p>Why not a <code>structure</code>?</p>",
        "id": 263158252,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1638284997
    },
    {
        "content": "<p>Does it make sense to create an auxiliary class <code>has_incidence</code> so that I can use the <code>ε</code> notation in the definition of a projective plane? And can I set this up so that I don't have to put both <code>[has_incidence]</code> and <code>[projective_plane]</code> bounds on functions?</p>",
        "id": 263163586,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1638287263
    },
    {
        "content": "<p>Do you really insist on not using the usual <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∈</mo></mrow><annotation encoding=\"application/x-tex\">\\in</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">∈</span></span></span></span> symbol?</p>",
        "id": 263166949,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1638288531
    },
    {
        "content": "<p>No, not at all. I'd be fine with using <code>∈</code>.</p>",
        "id": 263167887,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1638288904
    },
    {
        "content": "<p>To use the standard symbol, you can extend the <code>has_mem</code> class:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">projective_plane</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_mem</span> <span class=\"n\">P</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">connecting_line</span> <span class=\"o\">:</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">intersection_point</span> <span class=\"o\">:</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">exists_quadrangle</span> <span class=\"o\">:</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">projective_plane</span> <span class=\"n\">P</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span>\n</code></pre></div>",
        "id": 263172089,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1638290599
    },
    {
        "content": "<p>Is there an equivalent of has_mem in Lean 4?</p>",
        "id": 263210241,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1638307125
    },
    {
        "content": "<p>yes, in mathlib4: <a href=\"https://github.com/leanprover-community/mathlib4/blob/ceae8916f072cb3cb7fc67a88e01828d42bd924f/Mathlib/Init/SetNotation.lean#L1-L2\">https://github.com/leanprover-community/mathlib4/blob/ceae8916f072cb3cb7fc67a88e01828d42bd924f/Mathlib/Init/SetNotation.lean#L1-L2</a></p>",
        "id": 263214527,
        "sender_full_name": "David Renshaw",
        "timestamp": 1638309433
    },
    {
        "content": "<p>There's also a little-used feature where you can define notation for use inside a definition.  I don't recommend it here because it conflicts with <code>has_mem</code>, but anyway here's how that works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">projective_plane</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_on</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">L</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">∈</span> <span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">is_on</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">connecting_line</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">ℓ</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">ℓ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">intersection_point</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">ℓ</span> <span class=\"n\">ℓ'</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">),</span> <span class=\"n\">ℓ</span> <span class=\"bp\">≠</span> <span class=\"n\">ℓ'</span> <span class=\"bp\">→</span> <span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">ℓ</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">ℓ'</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">exists_quadrangle</span> <span class=\"o\">:</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n\n<span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">∈</span> <span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">projective_plane.is_on</span>\n</code></pre></div>",
        "id": 263221256,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1638313200
    },
    {
        "content": "<p>How can I use/import <code>mathlib4</code>?</p>",
        "id": 263285258,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1638363550
    },
    {
        "content": "<p><code>mathlib4</code> right now is just some playground for experimenting with mathematics in Lean 4. Are you sure you want to use/import it? If so then just clone it and open it in VS Code, making sure you have the lean 4 extension enabled. Note however that all the code above was written in Lean 3, and there is no compatibility between the two versions.</p>",
        "id": 263318666,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1638376778
    },
    {
        "content": "<p>Right, I'm gonna switch to Lean 3 then :)</p>",
        "id": 263420005,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1638442502
    },
    {
        "content": "<p>Can I define a function for the connecting line of two distinct points? The problem is that it wouldn't be well-defined for all pairs of points.</p>",
        "id": 263504704,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1638481640
    },
    {
        "content": "<p>In the context of affine geometry?</p>",
        "id": 263504831,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638481723
    },
    {
        "content": "<p>You can use <code>if ... then ... else ...</code> and just have it take a junk value if the two points are the same (you might need to assume <code>[nonempty L]</code>, then the junk value can be <code>default L</code>).  This is an approach taken fairly often in similar situations in mathlib.</p>\n<p>Here's a discussion of the \"junk value\" technique from Kevin Buzzard's blog:<br>\n<a href=\"https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/\">https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/</a></p>",
        "id": 263505022,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1638481871
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"460941\">Sebastian Zivota</span> <a href=\"#narrow/stream/113489-new-members/topic/Sebastian.20Zivota/near/263504704\">said</a>:</p>\n<blockquote>\n<p>Can I define a function for the connecting line of two distinct points? The problem is that it wouldn't be well-defined for all pairs of points.</p>\n</blockquote>\n<p>How do you define \"line\"? In the context of affine geometry, you could take two points and return the affine span of the two points, so if the two points are the same you just get the point back.</p>",
        "id": 263505072,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1638481920
    },
    {
        "content": "<p>AH of course this is for your projective geometry above <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 263505120,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638481936
    },
    {
        "content": "<p>Ah ok, so if you have already defined projective spaces, you could (first define, then.....) take the projective span ;)</p>",
        "id": 263505152,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1638481959
    },
    {
        "content": "<p>Ah I see, you want to use <code>projective_plane</code>from the code above. Yes, I would follow Heather's advice.</p>",
        "id": 263505310,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1638482080
    },
    {
        "content": "<p>(sorry, my connection seems to be lagging a bit today)</p>",
        "id": 263505327,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1638482099
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"460941\">Sebastian Zivota</span> <a href=\"#narrow/stream/113489-new-members/topic/Sebastian.20Zivota/near/263504704\">said</a>:</p>\n<blockquote>\n<p>Can I define a function for the connecting line of two distinct points? The problem is that it wouldn't be well-defined for all pairs of points.</p>\n</blockquote>\n<p>If your axiom is <code>connecting_line : ∀ (p q : P), p ≠ q → ∃! (ℓ : L), p ∈ ℓ</code>, then you can use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/exists.some\">docs#exists.some</a></p>\n<p>For example if <code>h</code> is a proof that <code>p</code> and <code>q</code> are not equal, you can do <code>(connecting_line p q h).some</code> (though you might need to specify the intended type <code>L</code> for the typeclass resolution to work).</p>",
        "id": 263506071,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1638482478
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/Sebastian.20Zivota/near/263506071\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"460941\">Sebastian Zivota</span> <a href=\"#narrow/stream/113489-new-members/topic/Sebastian.20Zivota/near/263504704\">said</a>:</p>\n<blockquote>\n<p>Can I define a function for the connecting line of two distinct points? The problem is that it wouldn't be well-defined for all pairs of points.</p>\n</blockquote>\n<p>If your axiom is <code>connecting_line : ∀ (p q : P), p ≠ q → ∃! (ℓ : L), p ∈ ℓ</code>, then you can use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/exists.some\">docs#exists.some</a></p>\n<p>For example if <code>h</code> is a proof that <code>p</code> and <code>q</code> are not equal, you can do <code>(connecting_line p q h).some</code> (though you might need to specify the intended type <code>L</code> for the typeclass resolution to work).</p>\n</blockquote>\n<p>Assuming you mean <a href=\"https://leanprover-community.github.io/mathlib_docs/logic/basic.html#Exists.some\">Exists.some</a>: this doesn't appear to use the uniqueness at all. <br>\nShould I define</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">connecting_line</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">ℓ</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">ℓ</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">ℓ</span>\n<span class=\"n\">line</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"n\">Exists.some</span> <span class=\"o\">(</span><span class=\"n\">connecting_line</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n<span class=\"n\">line_connects₁</span> <span class=\"o\">:=</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">line</span> <span class=\"n\">p</span> <span class=\"n\">q</span>\n<span class=\"n\">line_connects₂</span> <span class=\"o\">:=</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">line</span> <span class=\"n\">p</span> <span class=\"n\">q</span>\n<span class=\"n\">line_unique</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ℓ</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">line</span> <span class=\"n\">p</span> <span class=\"n\">q</span>\n</code></pre></div>\n<p>i.e. have <code>line p q</code> defined even for <code>p = q</code> and prove the interesting property (uniqueness) only for distinct points? Or is there another way to do it?</p>",
        "id": 263508559,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1638483989
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"460941\">@Sebastian Zivota</span> do you have a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> with your <code>projective_plane</code> class?</p>",
        "id": 263509235,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1638484369
    },
    {
        "content": "<p>That's true that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Exists.some\">docs#Exists.some</a> doesn't need uniqueness.  You can make use of the uniqueness property (to characterize this function) using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Exists.some_spec\">docs#Exists.some_spec</a></p>\n<p>Splitting the axiom like that seems like a reasonable idea, though, since we do know that there's a line running through every point.</p>",
        "id": 263509466,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1638484503
    },
    {
        "content": "<p>That then makes <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Exists.some\">docs#Exists.some</a> responsible for choosing the \"junk data\" for <code>line p p</code></p>",
        "id": 263509544,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1638484563
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/Sebastian.20Zivota/near/263509235\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"460941\">Sebastian Zivota</span> do you have a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> with your <code>projective_plane</code> class?</p>\n</blockquote>\n<p>Working, if not exactly pretty.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">logic.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_triangle</span> <span class=\"o\">[</span><span class=\"n\">has_mem</span> <span class=\"n\">P</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n    <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"n\">q</span>\n  <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"n\">r</span>\n  <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">≠</span> <span class=\"n\">r</span>\n  <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"bp\">∃</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">∧</span> <span class=\"n\">r</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_quadrangle</span> <span class=\"o\">[</span><span class=\"n\">has_mem</span> <span class=\"n\">P</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">@</span><span class=\"n\">is_triangle</span> <span class=\"n\">_</span> <span class=\"n\">L</span> <span class=\"n\">_</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span>\n  <span class=\"bp\">∧</span> <span class=\"bp\">@</span><span class=\"n\">is_triangle</span> <span class=\"n\">_</span> <span class=\"n\">L</span> <span class=\"n\">_</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">s</span>\n  <span class=\"bp\">∧</span> <span class=\"bp\">@</span><span class=\"n\">is_triangle</span> <span class=\"n\">_</span> <span class=\"n\">L</span> <span class=\"n\">_</span> <span class=\"n\">p</span> <span class=\"n\">r</span> <span class=\"n\">s</span>\n  <span class=\"bp\">∧</span> <span class=\"bp\">@</span><span class=\"n\">is_triangle</span> <span class=\"n\">_</span> <span class=\"n\">L</span> <span class=\"n\">_</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">projective_plane</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_mem</span> <span class=\"n\">P</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">exists_connecting_line</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">exists_intersection_point</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">l</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">point_line_uniq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">},</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">exists_quadrangle</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">is_quadrangle</span> <span class=\"n\">_</span> <span class=\"n\">L</span> <span class=\"n\">_</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">projective_plane</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">}</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">connecting_line</span> <span class=\"o\">[</span><span class=\"n\">projective_plane</span> <span class=\"n\">P</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"n\">Exists.some</span> <span class=\"o\">(</span><span class=\"n\">exists_connecting_line</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">p</span> <span class=\"bp\">`</span> <span class=\"bp\">⊔</span> <span class=\"bp\">`</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"n\">connecting_line</span> <span class=\"n\">p</span> <span class=\"n\">q</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">connecting_line_left</span> <span class=\"o\">[</span><span class=\"n\">projective_plane</span> <span class=\"n\">P</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">,</span>  <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">connecting_line</span> <span class=\"n\">P</span> <span class=\"n\">L</span> <span class=\"n\">_</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">Exists.some_spec</span> <span class=\"o\">(</span><span class=\"n\">exists_connecting_line</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">connecting_line_right</span> <span class=\"o\">[</span><span class=\"n\">projective_plane</span> <span class=\"n\">P</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">,</span>  <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">connecting_line</span> <span class=\"n\">P</span> <span class=\"n\">L</span> <span class=\"n\">_</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">Exists.some_spec</span> <span class=\"o\">(</span><span class=\"n\">exists_connecting_line</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">connecting_line_uniq</span> <span class=\"o\">[</span><span class=\"n\">projective_plane</span> <span class=\"n\">P</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"bp\">⊔</span> <span class=\"n\">q</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">l</span> <span class=\"n\">hpq</span> <span class=\"n\">hpl</span> <span class=\"n\">hql</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hpm</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">p</span> <span class=\"bp\">⊔</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"n\">connecting_line_left</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hqm</span> <span class=\"o\">:</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">p</span> <span class=\"bp\">⊔</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"n\">connecting_line_right</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"bp\">⊔</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">point_line_uniq</span> <span class=\"n\">hpl</span> <span class=\"n\">hql</span> <span class=\"n\">hpm</span> <span class=\"n\">hqm</span><span class=\"o\">),</span>\n    <span class=\"n\">exact</span> <span class=\"n\">or_iff_not_imp_left.mp</span> <span class=\"n\">h</span> <span class=\"n\">hpq</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">intersection_point</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">projective_plane</span> <span class=\"n\">P</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">Exists.some</span> <span class=\"bp\">$</span> <span class=\"n\">exists_intersection_point</span> <span class=\"n\">l</span> <span class=\"n\">m</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">l</span> <span class=\"bp\">`</span> <span class=\"bp\">⊓</span> <span class=\"bp\">`</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">intersection_point</span> <span class=\"n\">l</span> <span class=\"n\">m</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">projective_plane</span>\n<span class=\"c1\">-- insert dual theorems here</span>\n</code></pre></div>\n<p>I find myself having to fully spell out an uncomfortable number of types that I would rather keep implicit, like <code>@is_triangle _ L _ p q r</code> in the definition of <code>is_quadrangle</code>. I'm also not happy with the end of the proof of <code>connecting_line_uniq</code>; I wonder if there is a more elegant way to derive <code>B</code> from <code>A ∨ B</code> and <code>¬A</code> than using <code>or_iff_not_imp_left.mp</code>.</p>",
        "id": 263562392,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1638528951
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"460941\">Sebastian Zivota</span> <a href=\"#narrow/stream/113489-new-members/topic/Sebastian.20Zivota/near/263562392\">said</a>:</p>\n<blockquote>\n<p>I'm also not happy with the end of the proof of <code>connecting_line_uniq</code>; I wonder if there is a more elegant way to derive <code>B</code> from <code>A ∨ B</code> and <code>¬A</code> than using <code>or_iff_not_imp_left.mp</code>.</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/or.resolve_left\">docs#or.resolve_left</a></p>",
        "id": 263588820,
        "sender_full_name": "Reid Barton",
        "timestamp": 1638542546
    },
    {
        "content": "<p>ah, and <code>tauto</code> is also pretty useful for closing simple 1st order logic goals!</p>",
        "id": 263594727,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1638545094
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#tautology\">https://leanprover-community.github.io/mathlib_docs/tactics.html#tautology</a></p>",
        "id": 263595119,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1638545279
    }
]
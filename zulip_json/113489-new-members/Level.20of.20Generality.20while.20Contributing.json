[
    {
        "content": "<p>Hi there, I had a question relating to contributing to mathlib as a newer mathematician. </p>\n<p>The other week I was working with even/odd functions, and I found that the definitions I was familiar with were not in mathlib.</p>\n<p>I created some simple definitions that work for what I want to do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">even_fun</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">odd_fun</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>But when I asked about it on zulip, it looks like if I wanted to contribute to mathlib, I would need the most generalized version of it:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113489-new-members/topic/even.2Fodd.20functions/near/273317780\">said</a>:</p>\n<blockquote>\n<p>I haven't seen it (which doesn't mean it isn't there!), but if we did have it, then the appropriate level of generality would be something like an involutive linear map on a vector space over a field of characteristic different from 2. Any such map decomposes the vector space into a fixed part, and an anti-fixed part. For even functions (the fixed part) the involution is (lambda x, f x) -&gt; (lambda x, f -x). (Sorry, on mobile)</p>\n</blockquote>\n<p>As of right now, I'm not quite sure how to implement that definition, but I do have this definition that works for my needs. </p>\n<p>I am curious about the standpoint of having specialized versions of theorems in mathlib, like my basic ones I've defined</p>\n<p>To me it makes sense to have at least one form of the definition (generalized or not) in mathlib at any point in time so that at least some people can use it (rather than none) and then over time work on getting the most generalized version in.</p>\n<p>What do you think?</p>",
        "id": 276545887,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1648159695
    },
    {
        "content": "<p>I think another way to say Jireh's suggestion is that even/odd functions correspond to eigenvectors of the domain-reversing involution associated to the eigenvalues 1 and -1. (Though Jireh is explaining, additionally, the even/odd direct sum decomposition.)</p>",
        "id": 276547087,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648160461
    },
    {
        "content": "<p>I'm not sure what the \"right\" generalization of even/odd should be.  One thing that comes to mind is how the fact it's centered at 0 is arbitrary, so that could be generalized as well -- rather than the involution acting on a vector space, it could also be an involution on an affine space.</p>",
        "id": 276547384,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648160680
    },
    {
        "content": "<p>One formalization:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.group.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.eigenspace</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">act</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">module.End</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_even</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"bp\">∈</span> <span class=\"n\">module.End.eigenspace</span> <span class=\"o\">(</span><span class=\"n\">act</span> <span class=\"o\">(</span><span class=\"n\">has_neg.neg</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"mi\">1</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_odd</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"bp\">∈</span> <span class=\"n\">module.End.eigenspace</span> <span class=\"o\">(</span><span class=\"n\">act</span> <span class=\"o\">(</span><span class=\"n\">has_neg.neg</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_even_iff</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_even</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">is_even</span><span class=\"o\">,</span> <span class=\"n\">module.End.mem_eigenspace_iff</span><span class=\"o\">,</span> <span class=\"n\">one_smul</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">congr_fun</span> <span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_odd_iff</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_odd</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">is_odd</span><span class=\"o\">,</span> <span class=\"n\">module.End.mem_eigenspace_iff</span><span class=\"o\">,</span> <span class=\"n\">one_smul</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">congr_fun</span> <span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 276548598,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648161687
    },
    {
        "content": "<p>There's probably something somewhere in the library that can replace <code>act</code></p>",
        "id": 276548610,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648161701
    },
    {
        "content": "<p>That said, there's probably no reason to define <code>is_even</code> and <code>is_odd</code> in such a complicated way if you can write lemmas showing a definition is equivalent to the fancy (and \"right\") definition, so I might go with this (using <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>'s suggestion from the other thread):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.group.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.eigenspace</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">function.is_even</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_neg</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">function.is_odd</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_neg</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_neg</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">f</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">act</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">module.End</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_even_iff</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">function.is_even</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"n\">f</span> <span class=\"bp\">∈</span> <span class=\"n\">module.End.eigenspace</span> <span class=\"o\">(</span><span class=\"n\">act</span> <span class=\"o\">(</span><span class=\"n\">has_neg.neg</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">module.End.mem_eigenspace_iff</span><span class=\"o\">,</span> <span class=\"n\">one_smul</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">congr_fun</span> <span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_odd_iff</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">function.is_odd</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"n\">f</span> <span class=\"bp\">∈</span> <span class=\"n\">module.End.eigenspace</span> <span class=\"o\">(</span><span class=\"n\">act</span> <span class=\"o\">(</span><span class=\"n\">has_neg.neg</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">module.End.mem_eigenspace_iff</span><span class=\"o\">,</span> <span class=\"n\">neg_smul</span><span class=\"o\">,</span> <span class=\"n\">one_smul</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">congr_fun</span> <span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 276549455,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648162304
    },
    {
        "content": "<p>So as a beginner if I find something not included in mathlib, but I'm not aware of the most general definition, would you recommend me to try to PR with that definition?</p>",
        "id": 276549586,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1648162388
    },
    {
        "content": "<p>Others can overrule me, but I would do the following: ask on Zulip, \"I'm considering implementing concept X using method Y, is this a good approach, or should I attempt it a different way?\" Then people can provide input before you PR. That way, when you do PR, you likely won't have to rewrite everything from scratch.</p>\n<p>Note: in mathlib, we are at least sometimes willing to wait a long time to have things done the \"right\" way. Other times, we decide it's important enough to have a given thing that we forgo such considerations. </p>\n<p>As for the specific even/odd discussion above, I'll write something up tonight or tomorrow showing the kind of thing I was thinking. </p>\n<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> zero isn't quite as arbitrary when you think of the involution on the vector space of functions as additive group inversion on the domain (of course, yes, you can have other involutions of the domain)</p>",
        "id": 276551248,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1648163473
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"367659\">@Callum Cassidy-Nolan</span> I don't think I can give a blanket recommendation.  You can try asking <a class=\"stream\" data-stream-id=\"217875\" href=\"/#narrow/stream/217875-Is-there-code-for-X.3F\">#Is there code for X?</a> whether something is already in mathlib or if it's close to something already in mathlib, and there's also <a class=\"stream\" data-stream-id=\"116395\" href=\"/#narrow/stream/116395-maths\">#maths</a> to discuss how you might formalize something and to draw up a plan. A problem with just doing a PR is that not everyone is reviewing everything, so it might not get so much attention.</p>\n<p>There can also be many ways to generalize something, so it takes gaining some kind of consensus to know if something is \"most\" general. This is a matter of thinking through the sorts of theorems you're wanting to prove, what sorts of math we're each personally interested in formalizing, what resources (e.g. time) we have to do the formalization, and so on. We don't want to generalize just for the sake of generalization -- if we think no one is going to prove theorems about generalized even/odd functions (or, if they do, it's going to be a long long time from now), then it can be a waste of effort. If you're not careful, you might do the <em>wrong</em> generalization due to lack of foresight (this is a common software engineering problem...)</p>",
        "id": 276551463,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648163629
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> I get that the domain is a vector space and that even/odd corresponds to the isotypic components of representation of the group generated by <code>has_neg.neg</code> acting on the domain (and I do like this generalization). My question is whether this is the \"right\" generalization, given the theory what might be in the theory of even/odd functions.</p>",
        "id": 276551743,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648163820
    },
    {
        "content": "<p>Like if you're considering power series representations of functions centered at different points, you probably want to generalize even/odd to this situation.</p>",
        "id": 276551772,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648163847
    },
    {
        "content": "<p>(But that would also be more complicated, since I guess you want more of a pseudogroup acting on the domain to deal with the radius of convergence.)</p>",
        "id": 276551911,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648163954
    },
    {
        "content": "<p>By the way, the reason I was thinking about this generalization is that it occurs all over:</p>\n<ol>\n<li>Complex numbers with conjugation as real-linear involution -&gt; real and imaginary parts.</li>\n<li>Square matrices with transpose -&gt; symmetric and skew-symmetric parts.</li>\n<li>Yes, power series</li>\n<li>Adjoint operation in *-Algebras</li>\n<li>Even and odd functions</li>\n</ol>",
        "id": 276551915,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1648163956
    },
    {
        "content": "<p>I never required objects to be functions in my original proposal.</p>",
        "id": 276551965,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1648163992
    },
    {
        "content": "<p>For power series you could just work with formal multilinear series and ignore convergence</p>",
        "id": 276552055,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1648164035
    },
    {
        "content": "<p>Oh, I misread part of your proposal: I thought you were talking about, essentially, taking a representation V of a group then considering Hom(V, W) for some reason.</p>",
        "id": 276552168,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648164122
    },
    {
        "content": "<p>This generality is why I considered it to be the right generalization, but of course I'm open to other ideas.</p>",
        "id": 276552199,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1648164131
    },
    {
        "content": "<p>Regarding the generalization you're talking about, would you want to do anything other than studying <code>module.End.eigenspace T 1</code> and <code>module.End.eigenspace T (-1)</code> for some involution <code>T</code>?</p>",
        "id": 276552288,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648164198
    },
    {
        "content": "<p>I hadn't thought about it that much (other than this is one of my pet problems to give to linear algebra students and then show them how to occurs everywhere). </p>\n<p>Basically all I was thinking is that if we are going to do this at all, then it probably makes sense to have a uniform definition and API. Just plug in a linear involution, get out the relevant fixed and anti-fixed submodules and the decomposition.</p>",
        "id": 276552714,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1648164472
    },
    {
        "content": "<p>That being said, if we think it's not worth the effort that's fine too.</p>",
        "id": 276552793,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1648164516
    },
    {
        "content": "<p>I think it's worth the effort to flesh all that out. I just think that, except for all the surrounding theory and the decomposition in char-not-2 (including projections), we sort of already have it.</p>",
        "id": 276552942,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648164608
    },
    {
        "content": "<p>This is basically the kind of thing I was thinking. The names might be improved, and of course for fields with characteristic different from 2 we could prove more specialized stuff.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Copyright (c) 2022 Jireh Loreaux. All rights reserved.</span>\n<span class=\"cm\">Released under Apache 2.0 license as described in the file LICENSE.</span>\n<span class=\"cm\">Authors: Jireh Loreaux</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.eigenspace</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.direct_sum.module</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! # Linear involution decomposition</span>\n\n<span class=\"cm\">Throughout mathematics a certain phenomenon can be observed which amounts to the decomoposition of</span>\n<span class=\"cm\">some module into two pieces, one of which is fixed by a given operation and the other of which is</span>\n<span class=\"cm\">anti-fixed. As examples:</span>\n\n<span class=\"cm\">1. The decomposition of `z : ℂ` into `z = z.re + I * z.im` with the operation of `conj`.</span>\n<span class=\"cm\">2. The decomposition of a matrix into its symmetric and skew-symmetric parts with the transpose</span>\n<span class=\"cm\">  operation.</span>\n<span class=\"cm\">3. The decomposition of an operator into its selfadjoint and skew-selfadjoint parts, with the</span>\n<span class=\"cm\">  adjoint operation.</span>\n<span class=\"cm\">4. The decomposition of a real-valued function into its even and odd parts, with the operation</span>\n<span class=\"cm\">  given by `λ f : ℝ → ℝ, λ x, f (-x)`.</span>\n<span class=\"cm\">5. The decomposition of a polynomial into its even and odd parts.begin</span>\n<span class=\"cm\">6. The decomposition of complex-valued measures into their real and imaginary parts.</span>\n\n<span class=\"cm\">All of these are unified by a common thread. There is a linear involution acting on the module.</span>\n<span class=\"cm\">Here we ellucidate that role.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">lin_inv</span> <span class=\"o\">:</span> <span class=\"n\">module.End</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">linear_involution</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">function</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">postfix</span> <span class=\"bp\">`†`</span><span class=\"o\">:</span><span class=\"n\">std.prec.max_plus</span> <span class=\"o\">:=</span> <span class=\"n\">lin_inv</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fixed</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">lin_inv.eigenspace</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">anti_fixed</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">lin_inv.eigenspace</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">lin_inv</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_fixed_def</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">fixed</span> <span class=\"n\">lin_inv</span> <span class=\"bp\">↔</span> <span class=\"n\">m</span><span class=\"bp\">†</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"n\">module.End.mem_eigenspace_iff</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_fixed_iff</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">fixed</span> <span class=\"n\">lin_inv</span> <span class=\"bp\">↔</span> <span class=\"n\">m</span><span class=\"bp\">†</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">mem_fixed_def</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">one_smul</span> <span class=\"n\">R</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_anti_fixed_def</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">anti_fixed</span> <span class=\"n\">lin_inv</span> <span class=\"bp\">↔</span> <span class=\"n\">m</span><span class=\"bp\">†</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"n\">module.End.mem_eigenspace_iff</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_anti_fixed_iff</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">anti_fixed</span> <span class=\"n\">lin_inv</span> <span class=\"bp\">↔</span> <span class=\"n\">m</span><span class=\"bp\">†</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">mem_anti_fixed_def</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">neg_smul</span><span class=\"o\">,</span> <span class=\"n\">one_smul</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">add_lin_inv_self_fixed</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">involutive</span> <span class=\"n\">lin_inv</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"bp\">†</span> <span class=\"bp\">∈</span> <span class=\"n\">fixed</span> <span class=\"n\">lin_inv</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h.right_inverse</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span> <span class=\"n\">m</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">sub_lin_inv_self_anti_fixed</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">involutive</span> <span class=\"n\">lin_inv</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">m</span> <span class=\"bp\">-</span> <span class=\"n\">m</span><span class=\"bp\">†</span> <span class=\"bp\">∈</span> <span class=\"n\">anti_fixed</span> <span class=\"n\">lin_inv</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h.right_inverse</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span> <span class=\"n\">m</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">lin_inv</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">fixed_anti_fixed_pair</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span>\n<span class=\"bp\">|</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"n\">fixed</span> <span class=\"n\">lin_inv</span>\n<span class=\"bp\">|</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"n\">anti_fixed</span> <span class=\"n\">lin_inv</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">submodule</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fixed_anti_fixed_sum</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">h₂.unit</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">h₂.unit</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">†</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">h₂.unit</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">h₂.unit</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">†</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">units.smul_def</span><span class=\"o\">,</span> <span class=\"n\">add_add_sub_cancel</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">smul_add</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">two_smul</span> <span class=\"n\">R</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">smul_smul</span><span class=\"o\">,</span> <span class=\"n\">h₂.coe_inv_mul</span><span class=\"o\">,</span> <span class=\"n\">one_smul</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">lin_inv</span><span class=\"o\">}</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">sup_fixed_anti_fixed</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">involutive</span> <span class=\"n\">lin_inv</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">fixed</span> <span class=\"n\">lin_inv</span><span class=\"o\">)</span> <span class=\"bp\">⊔</span> <span class=\"o\">(</span><span class=\"n\">anti_fixed</span> <span class=\"n\">lin_inv</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span>\n<span class=\"n\">eq_top_iff'.mpr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">mem_sup.mpr</span>\n  <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">add_lin_inv_self_fixed</span> <span class=\"n\">h</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n   <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">sub_lin_inv_self_anti_fixed</span> <span class=\"n\">h</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n   <span class=\"n\">fixed_anti_fixed_sum</span> <span class=\"n\">lin_inv</span> <span class=\"n\">h₂</span> <span class=\"n\">m</span><span class=\"o\">⟩)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">zero_of_fixed_of_anti_fixed</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hm₁</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">fixed</span> <span class=\"n\">lin_inv</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hm₂</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">anti_fixed</span> <span class=\"n\">lin_inv</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_fixed_iff</span><span class=\"o\">,</span> <span class=\"n\">mem_anti_fixed_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hm₁</span> <span class=\"n\">hm₂</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hm₃</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">two_smul</span><span class=\"o\">],</span> <span class=\"n\">nth_rewrite</span> <span class=\"mi\">1</span> <span class=\"bp\">←</span><span class=\"n\">hm₁</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hm₂</span><span class=\"o\">,</span> <span class=\"n\">add_neg_self</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">h₂.unit</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"o\">((</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">h₂.unit</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg2</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span> <span class=\"n\">hm₃</span><span class=\"o\">,</span>\n  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">smul_smul</span><span class=\"o\">,</span> <span class=\"n\">h₂.coe_inv_mul</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">inf_fixed_anti_fixed</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">involutive</span> <span class=\"n\">lin_inv</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">fixed</span> <span class=\"n\">lin_inv</span><span class=\"o\">)</span> <span class=\"bp\">⊓</span> <span class=\"o\">(</span><span class=\"n\">anti_fixed</span> <span class=\"n\">lin_inv</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">submodule.eq_bot_iff</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">hm</span><span class=\"o\">,</span> <span class=\"n\">zero_of_fixed_of_anti_fixed</span> <span class=\"n\">h₂</span> <span class=\"o\">(</span><span class=\"n\">mem_inf.mp</span> <span class=\"n\">hm</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">mem_inf.mp</span> <span class=\"n\">hm</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">linear_involution</span>\n</code></pre></div>",
        "id": 276689504,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1648249075
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, see above.</p>",
        "id": 276689715,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1648249212
    }
]
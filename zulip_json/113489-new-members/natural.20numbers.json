[
    {
        "content": "<p>Hi, I'm new to Lean/mathlib and trying to undestand the conceptual framework. Every time I've seen defined natural numbers they are an inductive type. I still haven't tried but seems to me possible to define them as a typeclass (e.g. is_nat (a: Type)) parametrised over a generic type. Peano axioms then become proofs that this particular type satisfy the properties of natural numbers (i.e. one has a specific embedding). This would allow to treat \\ZZ as an instance of \\NN. Actually also \\ZZ and all the other mathematical structures could be type classes. Is there any obvious problem with this approach (before I try it out...) ?</p>",
        "id": 226943653,
        "sender_full_name": "Massimiliano Gubinelli",
        "timestamp": 1613729595
    },
    {
        "content": "<p>What is the payoff? </p>\n<blockquote>\n<p>This would allow to treat \\ZZ as an instance of \\NN.</p>\n</blockquote>\n<p>sounds like a bad thing rather than a good thing. :-)</p>",
        "id": 226949308,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1613733005
    },
    {
        "content": "<p>How does your proposed typeclass for $\\mathbb{N}$ differ from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_comm_monoid\">docs#add_comm_monoid</a>?</p>",
        "id": 226949529,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613733200
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"390066\">@Massimiliano Gubinelli</span> We already get a canonical coercion from <code>nat</code> to every type that has instances of <code>has_zero</code>, <code>has_one</code>, and <code>has_add</code>.</p>",
        "id": 226949558,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613733233
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/natural.20numbers/near/226949529\">said</a>:</p>\n<blockquote>\n<p>How does your proposed typeclass for $\\mathbb{N}$ differ from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_comm_monoid\">docs#add_comm_monoid</a>?</p>\n</blockquote>\n<p>it is a comm_monoid + more properties, like that S n \\neq n. Also before I made a mistake I was meaning that I wanted to have a class is_nat and then a class is_int and every instance of is_nat can also be made an instance of is_int (for example). Of course the inductive type will be an instance of the is_nat class, but one can prove theorems just on the class without needing the explicit representation. </p>\n<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  I guess I want a typeclass is_nat for which every instance can be coerced into nat (not only the other way around). This would express the idea that anything with the right properties can be a model for nat.</p>",
        "id": 226950881,
        "sender_full_name": "Massimiliano Gubinelli",
        "timestamp": 1613734118
    },
    {
        "content": "<p>You're proposing a structure such that an instance of that structure is uniquely isomorphic to the naturals. You could then in theory take every theorem proved about the naturals and then reprove it for your structure. Sure this is possible. And it's also kind of beautiful. But it's not clear whether it actually helps us to do things like e.g. develop MSc level commutative algebra in Lean, which is one direction where I personally would like the maths library to go next.</p>",
        "id": 226951093,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613734312
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"390066\">Massimiliano Gubinelli</span> <a href=\"#narrow/stream/113489-new-members/topic/natural.20numbers/near/226950881\">said</a>:</p>\n<blockquote>\n<p>I guess I want a typeclass is_nat for which every instance can be coerced into nat (not only the other way around). This would express the idea that anything with the right properties can be a model for nat.</p>\n</blockquote>\n<p>So then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span> would not be an instance.</p>",
        "id": 226951167,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613734344
    },
    {
        "content": "<p>Note that <code>is_nat</code> is not a very good name for this, because it is very much _structure_, not _property_, that the typeclass is carrying around.</p>",
        "id": 226951410,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1613734484
    },
    {
        "content": "<p>We do have this framework already for various other types, e.g. as well as the rationals we have a predicate saying \"this ring is a field of fractions of the integers\" so variants of (my understanding of) your proposal already exist. But I don't understand why you keep saying that the naturals are the integers, or the integers are the naturals.</p>",
        "id": 226951418,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613734494
    },
    {
        "content": "<p>any countable type \"is the naturals\" in the sense that you can define a zero and a successor function...</p>",
        "id": 226952140,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1613734966
    },
    {
        "content": "<p>just by picking an arbitrary bijection with <code>nat</code> and transporting its structure across...</p>",
        "id": 226952155,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1613734982
    },
    {
        "content": "<p>In a sense, looking for a typeclass that unifies the naturals with the integers is working in the wrong direction. A better thing to do is start with  proofs of the  \"same thing\" about ints and nats, and ask yourself \"what typeclass would I need to write a single proof for both\". Because if you go in that direction, you'll likely find:</p>\n<ul>\n<li>The typeclass you want already exists, or almost does</li>\n<li>You'll find other types your typeclass applies to</li>\n</ul>",
        "id": 226953078,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613735701
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> , what i wanted to say is that something that is_nat can be made an instance of is_int . This would express the fact that the naturals can be faithfully embedded in the integers (maybe one can say this better).<br>\n<span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>  indeed, one could use lists as a model (i.e. concrete instance) of is_nat or (as in lambda calculus) some particular class of functions. But you need a \"good\" (i.e. large enough) structure.   <br>\nMy point is that I do not see reasons to use a particular model as definition of integers (in OO programming one would consider them in interface). In this context I tend to think to natural numbers just some bunch of objects satisfying some axioms (like all the other math structures).  I just wanted to understand if there are reasons to not treat any mathematical structure as a class.</p>",
        "id": 226953214,
        "sender_full_name": "Massimiliano Gubinelli",
        "timestamp": 1613735768
    },
    {
        "content": "<p>Right now the philosophy of mathlib seems to be that even though things like the naturals and the reals can be characterised up to unique isomorphism by some structure and axioms, and so in theory every proof that we have about the real numbers could have been generalised to be a proof about any structure satisfying the axioms of the real numbers, it is not clear to me how this benefits us <em>in practice</em>. It sounds more like a theoretical type-theory exercise. However I do envisage that sometimes we will run into situations where we have proved theorems about X and want to apply these theorems to objects isomorphic to X. My plan for when these situations arise is to write tactics to transport the theorems along the isomorphism, rather than refactoring the theorems themselves so they're proved for all X-like objects. This proposal seems like a better idea than the one suggested for nats, because (a) it is more widely applicable (in particular I cannot envisage _any_ situation in actual mathematics where one comes up with something which is isomorphic to nat but where one needs a non-trivial theorem about nat to be pulled back to this structure, whereas I can envisage it for other objects), and (b) it even works in situations where objects are not classified up to unique isomorphism, but more generally where one has an isomorphism of structures X and Y and one wants to pull theorems about X back to Y. It is also worth adding that whilst a couple of years ago I was convinced that this sort of thing would show up all the time in mathematics, it has thus far been rather rare that we've had to make these kinds of pullback constructions.</p>",
        "id": 226953282,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613735821
    },
    {
        "content": "<p>Your comments about is_nat -&gt; is_int make no sense to me. If <code>is_int X</code> means \"I am isomorphic to the integers\" and <code>is_nat Y</code> means \"I am canonically isomorphic to the naturals\" then there is no <code>is_int Y</code> or <code>is_nat X</code>.</p>",
        "id": 226953425,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613735901
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/natural.20numbers/near/226953078\">said</a>:</p>\n<blockquote>\n<p>In a sense, looking for a typeclass that unifies the naturals with the integers is working in the wrong direction. A better thing to do is start with  proofs of the  \"same thing\" about ints and nats, and ask yourself \"what typeclass would I need to write a single proof for both\". Because if you go in that direction, you'll likely find:</p>\n<ul>\n<li>The typeclass you want already exists, or almost does</li>\n<li>You'll find other types your typeclass applies to</li>\n</ul>\n</blockquote>\n<p>Well if I have a structure which behaves like natural numbers, then I want to say that is_nat, so that I can use the theorems I already proved for that. I have difficulty to see why one consider the notion of monoid a good class but the notion of natural number not a good class (both are defined just via a bunch of axioms, no?).</p>",
        "id": 226953480,
        "sender_full_name": "Massimiliano Gubinelli",
        "timestamp": 1613735946
    },
    {
        "content": "<p>Because there are lots of interesting monoids, but only one interesting natural numbers?</p>",
        "id": 226953531,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1613735978
    },
    {
        "content": "<p>If your proof doesn't use anything about multiplication, then why assume <code>is_nat N</code> when you only needed to assume <code>add_comm_monoid N</code> (for example).</p>",
        "id": 226953543,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613735990
    },
    {
        "content": "<p>(where of course we're making sure to do the Goldilocks level of identification of isomorphic structures :-)</p>",
        "id": 226953765,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1613736056
    },
    {
        "content": "<p>The reason to have a particular definition of integers is that this is the way that mathematicians have proceeded classically, so what we have now does not look intimidating to working mathematicians. To a working mathematician your idea looks like a needless obfuscation with no clear practical benefits. We (working mathematicians) don't want to say \"Take some type Z which is the integers\", we want to see <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span>. As part of the story it's not just a case of showing that any two instances of the class are isomorphic, it's also crucial that one proves that instances of the class exist. And then when one does do this, one has <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span>, which mathematicians have been proving theorems about for centuries, without ever caring that their proofs also work for any object canonically isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span>.</p>",
        "id": 226953855,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613736110
    },
    {
        "content": "<p>When definining \"canonicity\" - are there any properties of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span> not captured by some existing typeclass?</p>",
        "id": 226953967,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613736168
    },
    {
        "content": "<p>I totally agree that from a theoretical CS point of view the class approach looks like an appealing idea. However it does not seem to bring any practical benefits to the modern working mathematician.</p>",
        "id": 226953979,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613736174
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/natural.20numbers/near/226953967\">said</a>:</p>\n<blockquote>\n<p>When definining \"canonicity\" - are there any properties of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span> not captured by some existing typeclass?</p>\n</blockquote>\n<p>Sure, the set of its prime ideals are a smooth 1-dimensional scheme.</p>",
        "id": 226954043,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613736232
    },
    {
        "content": "<p>I should be more wary of asking questions I won't understand the answer to... Is that statement formalized in lean yet?</p>",
        "id": 226954132,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613736289
    },
    {
        "content": "<p>no, that's why this is an answer to your question. In fact we haven't even defined smooth schemes yet.</p>",
        "id": 226954161,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613736312
    },
    {
        "content": "<p>It's a regular ring, a Cohen-Macauley ring, a complete intersection ring.</p>",
        "id": 226954198,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613736342
    },
    {
        "content": "<p>It's Japanese and universally catenary. <a href=\"https://stacks.math.columbia.edu/tag/032F\">https://stacks.math.columbia.edu/tag/032F</a> <a href=\"https://stacks.math.columbia.edu/tag/00NL\">https://stacks.math.columbia.edu/tag/00NL</a></p>",
        "id": 226954325,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613736414
    },
    {
        "content": "<p>Is it actually possible to fully state the properties of N in a typeclass such that <code>nat.rec</code> can be recovered without universe issues?</p>",
        "id": 226954382,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613736459
    },
    {
        "content": "<p>Yes, but only because <code>nat</code> exists</p>",
        "id": 226954572,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613736571
    },
    {
        "content": "<p>The proof that <code>X</code> with <code>is_nat X</code> satisfies the same recursor as <code>nat</code> is to show that <code>X ~= nat</code> and then pull back the property</p>",
        "id": 226954665,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613736622
    },
    {
        "content": "<p>If you were working in some kind of weak MLTT theory without nat then it wouldn't be possible to prove that X eliminates to all universes</p>",
        "id": 226954726,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613736675
    },
    {
        "content": "<p>Here <code>~=</code> is some monstrous \"ring equiv and order iso and ...\" equivalence that we don't have a strucutre for?</p>",
        "id": 226954864,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613736753
    },
    {
        "content": "<p>No, I mean <code>equiv</code></p>",
        "id": 226954875,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613736762
    },
    {
        "content": "<p>well, I suppose you want an equiv that preserves 0 and S</p>",
        "id": 226954900,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613736781
    },
    {
        "content": "<p>I was going to say, I can construct an equiv between int and nat - but maybe that is still enough for the recursor</p>",
        "id": 226954963,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613736826
    },
    {
        "content": "<p>By the way, regarding the puzzling claims about int being <code>is_nat</code>, I think Massimiliano is suggesting a typeclass which doesn't have a recursor clause, it's just a type, an element 0 and an injective endomorphism S such that 0 is not in the range of S</p>",
        "id": 226955055,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613736878
    },
    {
        "content": "<p>I suppose we would call this typeclass <code>infinite</code></p>",
        "id": 226955142,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613736959
    },
    {
        "content": "<p>If we mean <code>is_nat</code> to include the recursor, then it is provable exactly when the type is <code>denumerable</code>, i.e. <code>X ~= nat</code> with a regular equiv</p>",
        "id": 226955356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613737091
    },
    {
        "content": "<p>in fact <a href=\"https://leanprover-community.github.io/mathlib_docs/find/denumerable\">docs#denumerable</a> is probably the closest existing definition to what <span class=\"user-mention\" data-user-id=\"390066\">@Massimiliano Gubinelli</span> is looking for</p>",
        "id": 226955438,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613737141
    },
    {
        "content": "<p>and incidentally <a href=\"https://leanprover-community.github.io/mathlib_docs/data/equiv/denumerable.html#denumerable.int\">we do</a> have a proof that <code>int</code> is denumerable</p>",
        "id": 226955589,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613737223
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> is right, I was confused myself about this point. Indeed I was thinking to is_nat without implying isomorphism but only an injection. And I agree that if one require also isomorphism one falls into denumerable. If I understand the definition it uses the concrete type <code>nat</code> to enforce that a denumerable type is a type of natural numbers. What I had in mind was more a typeclass which packages the basic axioms (e.g. Peano's?). It uses a concrete type to enforce structural informations.<br>\n<span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  My question was coming from doing the Natural number game. I'm a \"general\" mathematician but indeed in mathematics one defines natural numbers as some set with some properties, not as an inductive type, so I was feeling that a typeclass would be \"nearer\" to the way I was taught the foundations. I understand the objection that makes the \"implementation\" a bit more awkward, because all will depend on a type variable which is never fixed. On the other hand this is a matter of syntax (one could probably hide the low-level implementation from the user, as it is already done with other aspects).<br>\nAnyway, thanks for all these answers. I think things are (a bit) clearer now. If I come up with a meaningful example where such idea could be useful I will let you know :)</p>",
        "id": 226959596,
        "sender_full_name": "Massimiliano Gubinelli",
        "timestamp": 1613739639
    },
    {
        "content": "<p>My point to Eric above is that it's not really possible to do everything without ever using a \"canonical\" version of the class; the existence of inductive types is needed to prove some theorems that pure axiomatic classes won't help with. Basically, you eventually have to show that your axiomatic class is not vacuous</p>",
        "id": 226960042,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613739879
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> yes I think understand this: the axioms could be contradictory so you need a model to show that they do not cause problems.</p>",
        "id": 226960123,
        "sender_full_name": "Massimiliano Gubinelli",
        "timestamp": 1613739933
    },
    {
        "content": "<p>The naturals are defined as a set with some properties, but those properties are precisely the construtors of the inductive type. In set theory there is this artificial construction involving {{},{{}},...}={0,1,...} but again it is a concrete model rather than \"a thing satisfying some axioms\".</p>",
        "id": 226960229,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613739982
    },
    {
        "content": "<p>How would you state derived definitions avoiding the concrete definition? For example, a first countable topology needs a prior definition of some nat-like type, unless you quantify (universally or existentially) over a nat-like type</p>",
        "id": 226960291,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613740025
    },
    {
        "content": "<p>We do have situations where we end up proving things about e.g. \"natural numbers, but regarded as real numbers\". That's a pretty good example of a thing which is isomorphic to the naturals but not literally equal to them. But we have tactics which pull back statements about natural real numbers to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span></span></span>.</p>",
        "id": 226960343,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613740060
    },
    {
        "content": "<p>and no matter what quantifier you use you will eventually have to prove forall implies exists or something along those lines and then you need to know that some nat-like type exists</p>",
        "id": 226960355,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613740066
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I'm clueless :) I will try to write down some actual code to clarify my ideas. I'm just starting looking over these matters. (I know some Haskell but that's all)<br>\n<span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> as a general mathematician who likes programming I'm interested in formalization also because I have a vague hope that it could allow to \"think\" (research level) mathematics differently. Usually I find that a computer could be used in new ways to do math, not only as a \"better\" way to do old stuff (e.g. like when we go into a lot of trouble to use it as a support on which to write with a pen....). For example: non-standard analysis has never worked quite well in the \"real world\" of everyday math, but somehow was an attempt to put a different \"API\" on the concepts of analysis.</p>",
        "id": 226971867,
        "sender_full_name": "Massimiliano Gubinelli",
        "timestamp": 1613745610
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/natural.20numbers/near/226960291\">said</a>:</p>\n<blockquote>\n<p>How would you state derived definitions avoiding the concrete definition? For example, a first countable topology needs a prior definition of some nat-like type, unless you quantify (universally or existentially) over a nat-like type</p>\n</blockquote>\n<p>I think I had in mind to quantify universally. The proposal was really: every time you see <code>nat</code> you should really have <code>is_nat a</code> for an arbitrary type a. I have hard time to see at which point you need \"a model\" when you prove things. Of course if your axioms are contradictory your proofs means nothing, so instantiate the abstract theory on a concrete model is a way to reduce the axioms of the abstract theory to that of the model and carry the burden of coherence to that of the model (which being simpler is less risky).</p>",
        "id": 226973186,
        "sender_full_name": "Massimiliano Gubinelli",
        "timestamp": 1613746209
    },
    {
        "content": "<p>The idea behind <a href=\"https://github.com/leanprover-community/mathlib/issues/3292\">#3292</a> (<span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> and <span class=\"user-mention\" data-user-id=\"252300\">@Jalex Stark</span> 's PR for \"conditionally_complete_linear_ordered_field, aka the reals\") is similar, right?</p>",
        "id": 226973605,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1613746425
    },
    {
        "content": "<p>You can probably do everything with some <code>is_nat</code> class. But you have to ask at the end of the day whether a mathematician wants to see</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">∧</span> <span class=\"n\">a</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"n\">c</span><span class=\"bp\">^</span><span class=\"n\">n</span>\n</code></pre></div>\n<p>or</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_nat</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">∧</span> <span class=\"n\">a</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"n\">c</span><span class=\"bp\">^</span><span class=\"n\">n</span>\n</code></pre></div>\n<p>and I definitely prefer the former. So whilst the class version does have some kind of pleasing \"more general\" appeal to it, another point of view is that it is obfuscating for no practical gain.</p>",
        "id": 226977791,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613748103
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span> for what I understand seems so. They give a class which wraps the relevant axioms. I would be interested to know what prompted this PR. <br>\n<span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I could guess with appropriate support from the parser, support this kind of style would not be more difficult that support notations like a * b. The real question indeed is whether it is useful or opens new way of working with mathematical structures, this I do not know. My reason for asking in the first place was to check my understating of how Lean works. <br>\nThanks for the feedback!</p>",
        "id": 226997301,
        "sender_full_name": "Massimiliano Gubinelli",
        "timestamp": 1613755322
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> (btw, I'm going thru the material on youtube from last summer, it is very helpful to see how things work and how to set up e.g. topology in the elementary way, thanks for sharing it)</p>",
        "id": 226997472,
        "sender_full_name": "Massimiliano Gubinelli",
        "timestamp": 1613755388
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"390066\">Massimiliano Gubinelli</span> <a href=\"#narrow/stream/113489-new-members/topic/natural.20numbers/near/226997301\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> for what I understand seems so. They give a class which wraps the relevant axioms. I would be interested to know what prompted this PR. <br>\n<span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> I could guess with appropriate support from the parser, support this kind of style would not be more difficult that support notations like a * b. The real question indeed is whether it is useful or opens new way of working with mathematical structures, this I do not know. My reason for asking in the first place was to check my understating of how Lean works. <br>\nThanks for the feedback!</p>\n</blockquote>\n<p>At least with the reals there are several very distinct construction (cauchy sequences, dedekind cuts, eudoxus reals) so aligning them seemed important. Also interesting is the fact that the definition of the isomorphism between such fields gives you unique embeddings of any linear ordered field (e.g. the rationals) into the reals, so you get some nice results as a side effect. One actual motivation for me was that <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> produced a lean proof of the prime number theorem that was automatically translated from a proof in metamath, the problem is that the definitions were also autogenerated from metamath and so do not align completely with the mathlib ones. So in order to start getting the real PNT (pun intended) you need either to relate the definitions manually, or some theorem like this that lets you just check some properties of metamath reals hold to get the isomorphism for free.</p>",
        "id": 226998454,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1613755856
    },
    {
        "content": "<p>I took nat as an example. Indeed the same arguments apply to all mathematical structures. Is more evident if the structure does not have a \"preferred\" representation. However if you come from lambda calculus then naturals are represented via lambda abstractions, not inductive types. I was thinking if I have an example where could be useful. The only thing which was coming to my mind was that one could have a function on nat which want to prove to be increasing, a strategy familiar to me (I'm an analyst/probabilist) is to extend it (arbitrarily) to the reals so that I can use calculus and prove that the derivative is positive. So in this case a model of nat based on the reals seems to help in the job. </p>\n<p>It is interesting however to know that the same mechanism could help to bridge the gap between different systems.</p>",
        "id": 227013424,
        "sender_full_name": "Massimiliano Gubinelli",
        "timestamp": 1613762221
    },
    {
        "content": "<p>Aah, this is a nice example! So here is what the proof would look like in Lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hfg</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">g_mono</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">g</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">g</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">m</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hfg</span><span class=\"o\">,</span> <span class=\"n\">hfg</span><span class=\"o\">],</span>\n  <span class=\"n\">apply</span> <span class=\"n\">g_mono</span><span class=\"o\">,</span>\n  <span class=\"n\">assumption_mod_cast</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>After <code>apply g_mono</code> we have two naturals m and n, a proof that m &lt;= n, and our goal is to prove that <code>(m : real) &lt;= (n : real).</code> The proof is one line long though, <code>assumption_mod_cast</code>, which is a tactic specifically written to move proofs between the naturals and the reals.</p>",
        "id": 227016234,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613763242
    },
    {
        "content": "<p>So you are saying \"why not prove all theorems for any model of the naturals\", and I am saying \"in Lean we prove things for our one model, and in practice the only other models which show up are things like the copy of the naturals in the reals / rationals / complexes / integers / p-adic numbers, where we have a specific tactic for doing this\".</p>",
        "id": 227016526,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613763334
    },
    {
        "content": "<p>And the observation is that in practice this approach has worked really really well.</p>",
        "id": 227016690,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613763382
    },
    {
        "content": "<p>However sometimes we do use your approach, for example when doing localisation of rings, and in this case we had to think hard about precisely how to classify such things by a list of axioms, because there are several equivalent characterisations. Strickland came up with a list which was really practical to use in practice, and this was the big change between versions 1 and 2 of schemes as described in this paper: <a href=\"https://arxiv.org/abs/2101.02602\">https://arxiv.org/abs/2101.02602</a> . Here we have both the concrete model and the abstract class parametrised by Strickland's axioms, and some key intermediate theorems were proved for the abstract class because it turned out that there were examples of rings in the literature which mathematicians were treating as the same but which actually were set-theoretically not quite equal. I say more about this in this part of this talk here <a href=\"https://youtu.be/g2--VL2SkMo?t=2267\">https://youtu.be/g2--VL2SkMo?t=2267</a> which I gave to an undergraduate maths society last month. So your phenomenon really does show up, and we are dealing with it in different ways depending on the circumstances.</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"g2--VL2SkMo\" href=\"https://youtu.be/g2--VL2SkMo?t=2267\"><img src=\"https://i.ytimg.com/vi/g2--VL2SkMo/default.jpg\"></a></div>",
        "id": 227017663,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613763762
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"390066\">Massimiliano Gubinelli</span> <a href=\"#narrow/stream/113489-new-members/topic/natural.20numbers/near/226973186\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/natural.20numbers/near/226960291\">said</a>:</p>\n<blockquote>\n<p>How would you state derived definitions avoiding the concrete definition? For example, a first countable topology needs a prior definition of some nat-like type, unless you quantify (universally or existentially) over a nat-like type</p>\n</blockquote>\n<p>I think I had in mind to quantify universally. The proposal was really: every time you see <code>nat</code> you should really have <code>is_nat a</code> for an arbitrary type a. I have hard time to see at which point you need \"a model\" when you prove things. Of course if your axioms are contradictory your proofs means nothing, so instantiate the abstract theory on a concrete model is a way to reduce the axioms of the abstract theory to that of the model and carry the burden of coherence to that of the model (which being simpler is less risky).</p>\n</blockquote>\n<p>If you quantify universally, then the problem comes when you want to discharge assumptions local to a proof. Let's say we want to prove <code>A -&gt; B</code> where <code>A</code> and <code>B</code> make no mention of natural numbers (perhaps the idea that you would even need natural numbers isn't on the radar - for a less trivial example consider that the statement of Fermat's last theorem does not invoke the existence of modular forms in any way). However the proof goes via an intermediate statement <code>P(nat)</code> where <code>nat</code> is any reasonable definition of natural numbers. That is, we can prove <code>A -&gt; P(nat)</code> and <code>P(nat) -&gt; B</code>. If <code>nat</code> is some concrete structure then we can just chain these together and we get a proof of <code>A -&gt; B</code>, but if we had been universally quantifying over is_nats, we would have proved <code>∀ X, is_nat X -&gt; A -&gt; P(X)</code> and <code>∀ X, is_nat X -&gt; P(X) -&gt; B</code>, and if you put those two together you get <code>∀ X, is_nat X -&gt; A -&gt; B</code>, or <code>(∃ X, is_nat X) -&gt; A -&gt; B</code> if you prefer. In order to finish the proof and prove the original <code>A -&gt; B</code> goal we need <code>∃ X, is_nat X</code>.</p>",
        "id": 227051023,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613781149
    },
    {
        "content": "<p>I see. Your observation clarifies to me at which point you need a proof that the axioms for is_nat are not incoherent in the Lean system, that's nice. Can the second statement be $\\exists X, (is_nat X -&gt; P(X) -&gt; B)$ and still be able to conclude? I think so, no? (or even the first one existential and the second universal? or do we really need both to be universal?) That would leave the freedom to choose a particular model for certain computations.</p>",
        "id": 227080204,
        "sender_full_name": "Massimiliano Gubinelli",
        "timestamp": 1613813941
    },
    {
        "content": "<p>Yes, if one of the statements was universal and the other existential, then you could conclude as desired. But then you are somehow \"coloring\" the library with red and blue theorems and which should be which? What's worse, while two universal theorems get along just fine, two existential theorems don't, because they might have two different choices of <code>X</code> and then you have to have coherence theorems that show that if <code>is_nat X</code> and <code>is_nat Y</code> and <code>P(X)</code> then <code>P(Y)</code>, where <code>P</code> is a property of interest. If <code>is_nat</code> determines <code>X</code> up to isomorphism this is probably possible to prove, but it's not automatic and making everything work together gets a lot harder.</p>",
        "id": 227080414,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613814239
    },
    {
        "content": "<p>I can imagine. For the moment I'm even stuck at the complex number game ... :)</p>",
        "id": 227085782,
        "sender_full_name": "Massimiliano Gubinelli",
        "timestamp": 1613820937
    },
    {
        "content": "<p>Does mathlib have a linter for \"this typeclass has no instances\"?</p>",
        "id": 227086042,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613821224
    },
    {
        "content": "<p>Isn't that the <code>inhabited</code> instance?  I have been asked by the linter to produce <code>inhabited</code>instances when defining a new type.</p>",
        "id": 227088962,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1613824572
    }
]
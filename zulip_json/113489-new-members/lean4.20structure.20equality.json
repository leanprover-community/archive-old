[
    {
        "content": "<p>What's the Lean4  approach for this proof (or even one direction of it?)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Foo</span> <span class=\"n\">where</span>\n  <span class=\"n\">mk</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">eq_ext</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a.bar</span> <span class=\"bp\">=</span> <span class=\"n\">b.bar</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 305914209,
        "sender_full_name": "Arien Malec",
        "timestamp": 1666645768
    },
    {
        "content": "<p>should probably note that I've tried what I would consider the usual; <code>rfl</code>, various flavors of trying to destructure, <code>rw</code> etc.</p>",
        "id": 305921604,
        "sender_full_name": "Arien Malec",
        "timestamp": 1666649462
    },
    {
        "content": "<p>Possibly there's a clevererer way to do it (which I can't check because I can't update mathlib4 yet :/), but here's a simplistic way that seems to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Foo</span> <span class=\"n\">where</span>\n  <span class=\"n\">mk</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">eq_ext</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a.bar</span> <span class=\"bp\">=</span> <span class=\"n\">b.bar</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">],</span>\n <span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">a</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">b</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]⟩</span>\n</code></pre></div>\n<p>seems to do it here at least.</p>",
        "id": 305922249,
        "sender_full_name": "Julian Berman",
        "timestamp": 1666649804
    },
    {
        "content": "<p>With the <code>ext</code> tactic you get it for free:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.Ext</span>\n\n<span class=\"kd\">@[ext]</span> <span class=\"kd\">structure</span> <span class=\"n\">Foo</span> <span class=\"n\">where</span>\n  <span class=\"n\">mk</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">eq_ext</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a.bar</span> <span class=\"bp\">=</span> <span class=\"n\">b.bar</span> <span class=\"o\">:=</span> <span class=\"n\">Foo.ext_iff</span>\n</code></pre></div>",
        "id": 305922494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666649927
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321696\">Julian Berman</span> <a href=\"#narrow/stream/113489-new-members/topic/lean4.20structure.20equality/near/305922249\">said</a>:</p>\n<blockquote>\n<p>Possibly there's a clevererer way to do it (which I can't check because I can't update mathlib4 yet :/), but here's a simplistic way that seems to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Foo</span> <span class=\"n\">where</span>\n  <span class=\"n\">mk</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">eq_ext</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a.bar</span> <span class=\"bp\">=</span> <span class=\"n\">b.bar</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">],</span>\n <span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">a</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">b</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]⟩</span>\n</code></pre></div>\n<p>seems to do it here at least.</p>\n</blockquote>\n<p>OK, I get the <code>mp</code> direction, which seems obvious in retrospect. The <code>mpr</code> direction seems like magic. </p>\n<p>I go from</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">case</span> <span class=\"n\">mpr.mk.mk</span>\n<span class=\"n\">bar</span><span class=\"bp\">✝¹</span><span class=\"n\">bar</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"n\">bar</span><span class=\"bp\">✝¹</span> <span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">bar</span> <span class=\"bp\">=</span> <span class=\"o\">{</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"n\">bar</span><span class=\"bp\">✝</span> <span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">bar</span>\n<span class=\"bp\">⊢</span> <span class=\"o\">{</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"n\">bar</span><span class=\"bp\">✝¹</span> <span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"n\">bar</span><span class=\"bp\">✝</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>to <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> via <code>simp [h]</code> but it doesn't feel like there's anything to apply <code>simp</code> to that isn't already in the premise...</p>",
        "id": 305923508,
        "sender_full_name": "Arien Malec",
        "timestamp": 1666650527
    },
    {
        "content": "<p>Here's another way to write the proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">eq_ext</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a.bar</span> <span class=\"bp\">=</span> <span class=\"n\">b.bar</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">],</span>\n <span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n  <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">a_bar</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">b_bar</span><span class=\"o\">⟩,</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a_bar</span> <span class=\"bp\">=</span> <span class=\"n\">b_bar</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]⟩</span>\n</code></pre></div>",
        "id": 305924539,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666651051
    },
    {
        "content": "<p>The point is that after the two <code>cases</code>, <code>h</code>, which has the type <code>⟨a_bar⟩.bar = ⟨b_bar⟩.bar</code>, is definitionally equal to <code>h : a_bar = b_bar</code> and so we can use the same proof as the first half - we're just applying the <code>mk</code> function to both sides to get equal values.</p>",
        "id": 305924703,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666651123
    }
]
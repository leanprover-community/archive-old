[
    {
        "content": "<p>Hi. I'm sure a very basic type class definition question given I'm jumping in on the deep end on something I may not be too capable of yet. I'm trying to define a structure -- M by N chessboards, and to prove some theorems about them. I defined an inductive type called pieces with just placeholders for each of the pieces, and then I was trying to define a board as a map from m -&gt; n -&gt; pieces (and then I was going to define moves as particular maps from boards to boards that satisfy \"one thing moved, etc.\"). Does that sound like a reasonable approach, and if so, to express finiteness of m and n it seems like I want <code>fintype</code>? At least that seems like something I should read a tiny bit on looking at how mathlib defines matrices, though it doesn't look like they're defined via <code>class</code>.  Any advice definitely welcome (including \"go back to tutorials you won't be able to do that yet\").</p>",
        "id": 208385394,
        "sender_full_name": "Julian Berman",
        "timestamp": 1598642813
    },
    {
        "content": "<p>Yeah, matrices will give you what you want. You might want to look at <a href=\"https://leanprover-community.github.io/mathlib_docs/data/matrix/notation.html\">https://leanprover-community.github.io/mathlib_docs/data/matrix/notation.html</a></p>",
        "id": 208386262,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598643322
    },
    {
        "content": "<p>Which are matrices indexed by <code>fin n</code>, the finite set of <code>n</code> elements. Or you can just use the <code>matrix</code> definition.</p>",
        "id": 208386396,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598643394
    },
    {
        "content": "<p>Ah awesome! Thanks, I was reading the notation.lean file itself but definitely easier to read that.</p>",
        "id": 208386469,
        "sender_full_name": "Julian Berman",
        "timestamp": 1598643436
    },
    {
        "content": "<p>There are some clumsy things about jumping between different <code>fin n</code> and <code>fin m</code>, especially when <code>n \\ne m</code>. But if something comes up, do say something. I've been trying to make <code>fin _</code> smoother. And with lean 3.19, working with <code>fin _</code> might get better. If you don't care about the ordering within the \"N\" or \"M\", working directly with a <code>fintype</code>might be easier.</p>",
        "id": 208386628,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598643536
    },
    {
        "content": "<p>But with a chessboard and moves, there is often \"move-math\" that happens, which then uses some knowledge of equality or ordering of the board.</p>",
        "id": 208386674,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598643573
    },
    {
        "content": "<p>And I don't know if you care about \"computability\" or not.</p>",
        "id": 208386689,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598643588
    },
    {
        "content": "<p>In any case, something like <code>function.update</code> might be useful to indicate moves.</p>",
        "id": 208386805,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598643644
    },
    {
        "content": "<p>(Thanks making notes of all these to review :)</p>\n<p>The first \"theorems\" I want to prove are simply given two positions exhibiting existence of a sequence of moves (with no captures for simplicity) that move the board from one to the final position</p>",
        "id": 208386922,
        "sender_full_name": "Julian Berman",
        "timestamp": 1598643715
    },
    {
        "content": "<p>And then statements that certain sequences moves are equivalent under different ordering (of the moves, not the board arrangement), etc could rely on equality checks of the fact that the \"positions\" are the same.</p>",
        "id": 208386969,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598643724
    },
    {
        "content": "<p>Ah, I was just typing about sequences of moves as you posted that.</p>",
        "id": 208387005,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598643744
    },
    {
        "content": "<p>You might have to postulate first, if you disallow captures, that a valid move retains the total number of pieces on a board.</p>",
        "id": 208387105,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598643807
    },
    {
        "content": "<p>And that no two pieces can occupy the same spot.</p>",
        "id": 208387121,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598643819
    },
    {
        "content": "<p>yeah exactly. cool -- that's I think what I was assuming I'd need to do -- and then when I <em>did</em> do captures, I postualte there's exactly 1 fewer piece on the board, that it's of the opposite color, and that the moved piece went to that square, and then I redefine moves to be \"capture or noncapture\", yeah?</p>",
        "id": 208387401,
        "sender_full_name": "Julian Berman",
        "timestamp": 1598643969
    },
    {
        "content": "<p>Just writing up a quick example.</p>",
        "id": 208388051,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598644406
    },
    {
        "content": "<p>Ah awesome. Much appreciated! (Don't ruin too much :D but definitely could use one next nudge yeah)</p>",
        "id": 208388146,
        "sender_full_name": "Julian Berman",
        "timestamp": 1598644449
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">matrix</span><span class=\"bp\">.</span><span class=\"kn\">notation</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">m&#39;</span> <span class=\"n\">n&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">n&#39;</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">n&#39;</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">m&#39;</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">m&#39;</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">occupied_board</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">pieces</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">board</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">m&#39;</span> <span class=\"n\">n&#39;</span> <span class=\"o\">(</span><span class=\"n\">option</span> <span class=\"n\">ι</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">no_superposition</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">x&#39;</span> <span class=\"o\">:</span> <span class=\"n\">m&#39;</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"n\">y&#39;</span> <span class=\"o\">:</span> <span class=\"n\">n&#39;</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">x&#39;</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">≠</span> <span class=\"n\">y&#39;</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">board</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_some</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">board</span> <span class=\"n\">x&#39;</span> <span class=\"n\">y&#39;</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_some</span> <span class=\"bp\">→</span> <span class=\"n\">board</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">≠</span> <span class=\"n\">board</span> <span class=\"n\">x&#39;</span> <span class=\"n\">y&#39;</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">constant_pieces</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">ix</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">m&#39;</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">n&#39;</span><span class=\"o\">,</span> <span class=\"n\">board</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">ix</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 208388735,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598644797
    },
    {
        "content": "<p>So the occupied board is a structure with some data and some axioms about how that data is structured.</p>",
        "id": 208388820,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598644825
    },
    {
        "content": "<p>You have an indexed set of pieces, so that you can tell them apart.</p>",
        "id": 208388833,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598644839
    },
    {
        "content": "<p>And a board, where at each square you have either no piece, or some piece, which you refer to by an index</p>",
        "id": 208388866,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598644867
    },
    {
        "content": "<p>For any two distinct positions, if both are occupied, they must be occupied by different pieces (they're different because their indices are different. So two identical pawns can be different because they have an index written on their bottom when checked.</p>",
        "id": 208389131,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598645019
    },
    {
        "content": "<p>There's probably a cleaner way to state that axiom, or in a way that makes proving various things easier.</p>",
        "id": 208389210,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598645044
    },
    {
        "content": "<p>The last axiom is that every index can be found in the board.</p>",
        "id": 208389233,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598645062
    },
    {
        "content": "<p>Thanks! That is super helpful (I had some pieces of that written down and was struggling with getting it to compile, especially around the fintype declarations where I was somehow getting the syntax wrong)</p>",
        "id": 208389295,
        "sender_full_name": "Julian Berman",
        "timestamp": 1598645112
    },
    {
        "content": "<p>Maybe one \"design\" question I guess -- is the reason to use matrix simply because it's got the notation and finite domain pieces which are convenient to use?</p>",
        "id": 208389496,
        "sender_full_name": "Julian Berman",
        "timestamp": 1598645244
    },
    {
        "content": "<p>I obviously don't expect I'd need to use the ring operations on it right? So it's just a fancy 2d array</p>",
        "id": 208389512,
        "sender_full_name": "Julian Berman",
        "timestamp": 1598645260
    },
    {
        "content": "<p>There are some APIs about updating it that exist. With lemmas about how transpose commutes with certain ops, etc</p>",
        "id": 208389727,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598645402
    },
    {
        "content": "<p>a ha, got it</p>",
        "id": 208389786,
        "sender_full_name": "Julian Berman",
        "timestamp": 1598645417
    },
    {
        "content": "<p>But a matrix is defeq to a <code>m -&gt; n -&gt; alpha</code></p>",
        "id": 208389793,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598645418
    },
    {
        "content": "<p>It just has certain constraints on what can be <code>m</code> or <code>n</code></p>",
        "id": 208389836,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598645455
    },
    {
        "content": "<p>You might run into some clumsiness stating things about the <code>constant_pieces</code> if you're actually removing pieces form the board. You could take an approach of generating a new index type with the removed pieces removed, or keeping track of a \"graveyard\", or something else.</p>",
        "id": 208389976,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598645535
    },
    {
        "content": "<p>Jeremy Avigad has an explanation about a Lean proof of how to place 8 (or 6) queens on a board.</p>",
        "id": 208390056,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598645594
    },
    {
        "content": "<p>Makes sense.</p>",
        "id": 208390057,
        "sender_full_name": "Julian Berman",
        "timestamp": 1598645594
    },
    {
        "content": "<p>Which was instrumental for me to understand how Lean works.</p>",
        "id": 208390085,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598645608
    },
    {
        "content": "<p>ha yeah domination theorems will be next after I get this one done.</p>",
        "id": 208390091,
        "sender_full_name": "Julian Berman",
        "timestamp": 1598645611
    },
    {
        "content": "<p>I don't know if that's a good thing for me to read it may spoil the ending.</p>",
        "id": 208390099,
        "sender_full_name": "Julian Berman",
        "timestamp": 1598645619
    },
    {
        "content": "<p>(Maybe I should keep it on the side to cheat from when I get stuck?)</p>",
        "id": 208390122,
        "sender_full_name": "Julian Berman",
        "timestamp": 1598645640
    },
    {
        "content": "<p>I can't find it at the moment. <span class=\"user-mention\" data-user-id=\"110865\">@Jeremy Avigad</span> , do you have a link on the n-queens problem? Thanks!</p>",
        "id": 208390360,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598645768
    },
    {
        "content": "<p>I might be misremembering. I've found a mutilated chessboard experiment with Isabelle: <a href=\"https://github.com/avigad/arwm/blob/master/isabelle_experiments/mutilated_notes.md\">https://github.com/avigad/arwm/blob/master/isabelle_experiments/mutilated_notes.md</a></p>",
        "id": 208390442,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598645837
    },
    {
        "content": "<p>ah cool yeah the corner removal one -- I was expecting it'd be difficult to express the usual \"board color parity\" proof so definitely will read that</p>",
        "id": 208390569,
        "sender_full_name": "Julian Berman",
        "timestamp": 1598645904
    },
    {
        "content": "<p>One might say, just make the indexing of the board use a Cartesian product of two fintypes</p>",
        "id": 208391613,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598646543
    },
    {
        "content": "<p>Which is also a fintype</p>",
        "id": 208391637,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598646554
    },
    {
        "content": "<p>But then statements about columns or rows get clunkier</p>",
        "id": 208391660,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598646572
    },
    {
        "content": "<p>You have to choose what definition works best for what you're trying to prove. That's one of the hardest parts!</p>",
        "id": 208391798,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598646636
    },
    {
        "content": "<p>Because a good definition leads to more smooth lemma statements and proofs</p>",
        "id": 208391825,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598646658
    },
    {
        "content": "<p>For example, I could have stated the no superposition lemma using (x, y) ne (x', y'). Which is somewhat more concise. But generating a proof of that hypothesis will be clunkier than the separate hypotheses about x and about y separately. In fact, the proof of that Cartesian pair hypothesis would likely use the separate inequality proofs anyway.</p>",
        "id": 208392055,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598646793
    },
    {
        "content": "<p>Once you've started to try to prove lemmas, and found something is clunky, there's nothing wrong with going back and reworking the definition, instead of trying to get the lemma to conform.</p>",
        "id": 208392169,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598646866
    },
    {
        "content": "<p>It might be nicer for you to define the piece as inherently indexed, for example</p>",
        "id": 208392215,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598646899
    },
    {
        "content": "<p>hm, as in order the set of pieces arbitrarily?</p>",
        "id": 208392473,
        "sender_full_name": "Julian Berman",
        "timestamp": 1598647078
    },
    {
        "content": "<p>So def piece := io -&gt; K. Maybe a statement about some surjectivity of the indexing at the beginning of the game, that all the possible piece types are present initally.</p>",
        "id": 208392915,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598647344
    },
    {
        "content": "<p>ah got it. OK going to take your examples and play around a bit and see where I run into trouble. Much appreciated again I'm sure you'll see me again :)</p>",
        "id": 208394516,
        "sender_full_name": "Julian Berman",
        "timestamp": 1598648407
    },
    {
        "content": "<p>Hello again. Getting back to this after a few days doing other things. Haven't made a ton of progress other than putting what was suggested here in a repo and combining it with the simple notation things I already had (<a href=\"https://github.com/Julian/lean-across-the-board/blob/main/src/chess/board.lean\">https://github.com/Julian/lean-across-the-board/blob/main/src/chess/board.lean</a>) -- I'm trying to take the board definition that was suggested and just learn how to instantiate that board now. I have:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">{</span>\n  <span class=\"n\">chess</span><span class=\"bp\">.</span><span class=\"n\">board</span> <span class=\"bp\">.</span>\n  <span class=\"n\">pieces</span> <span class=\"o\">:=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"err\">♞</span><span class=\"o\">],</span>\n  <span class=\"n\">contents</span> <span class=\"o\">:=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">1</span><span class=\"o\">)],</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">none</span><span class=\"o\">],</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">none</span><span class=\"o\">]],</span>\n  <span class=\"n\">contains_pieces</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n  <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">no_superimposed_pieces</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>and am now I guess tasked with proving that containment. Assuming that's already on the right track, is there a tactic that's \"brute force\" there? What it looks like I need to prove is <code>∀ (ix : fin 1), ∃ (x : fin 1.succ.succ) (y : fin 1), ![![↑0], ![none], ![none]] x y = ↑ix</code> so basically it's a finite list of things, is there a tactic that says \"loop over each one and check the thing on the right side, it's there\"? Or regardless, if I have <code>fintype 1</code> which has one element, and I do <code>intro h</code>, which now hypothesizes I have an element of <code>fin 1</code>, how do I say \"there's only one of those so give me (0 : fin 1)\"?</p>",
        "id": 208961470,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599137542
    },
    {
        "content": "<p>(If I can do the second part, extract <code>0: fin 1</code> then I can use <code>use</code> twice right?)</p>",
        "id": 208961974,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599137787
    },
    {
        "content": "<p>I think I need an emoji reaction meaning decoder dictionary :D</p>",
        "id": 208965356,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599139310
    },
    {
        "content": "<p>For the last question I think you can use <code>fin_cases h</code></p>",
        "id": 208966656,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599139860
    },
    {
        "content": "<p>but, you might get away with proving the whole <code>∀ (ix : fin 1), ∃ ...</code> statement using <code>dec_trivial</code></p>",
        "id": 208966694,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599139887
    },
    {
        "content": "<p>A ha! Thank you! I tried <code>cases</code> but it didn't make me progress, it just told me now I have <code>\\N</code>...</p>",
        "id": 208969992,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599141223
    },
    {
        "content": "<p>Yeah <code>fin_cases h, use 0, use 0, refl</code> indeed seems to work, and <code>dec_trivial</code> indeed seems to be my \"brute force\" or whatever, and closes it itself.</p>",
        "id": 208970805,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599141524
    },
    {
        "content": "<p>Not sure if this is a reasonable question to ask as well, but since <code>library_search</code> and <code>simp</code> didn't close the goal, which were the two things I'd previously heard of, is there some other \"higher level\" fancy tactic which loops over all tactics with the type of the proposition to prove and gives me one that immediately closes the goal if it does so in 1 step? (i.e. something that would have told me of the existence of <code>dec_trivial</code>?)</p>",
        "id": 208971409,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599141733
    },
    {
        "content": "<p>Zulip is that fancy tactic.</p>",
        "id": 208976438,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1599143648
    },
    {
        "content": "<p>\"there's only one of those so give me (0 : fin 1)\": how about <code>exact 0</code>?</p>",
        "id": 208976548,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1599143687
    },
    {
        "content": "<p>There's also <code>subsingleton.elim x y</code> which will give you <code>x = y</code> for <code>x y : fin 1</code> or any other subsingleton type.</p>",
        "id": 208976721,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1599143746
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/Advice.20on.20Definitions/near/208976548\">said</a>:</p>\n<blockquote>\n<p>\"there's only one of those so give me (0 : fin 1)\": how about <code>exact 0</code>?</p>\n</blockquote>\n<p>if I try that I get</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">lean</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"n\">invalid</span> <span class=\"n\">pre</span><span class=\"bp\">-</span><span class=\"n\">numeral</span><span class=\"o\">,</span> <span class=\"kn\">universe</span> <span class=\"n\">level</span> <span class=\"n\">must</span> <span class=\"n\">be</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">1</span>\n<span class=\"err\">⊢</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"err\">↑</span><span class=\"mi\">0</span><span class=\"o\">],</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">none</span><span class=\"o\">],</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">none</span><span class=\"o\">]]</span> <span class=\"mi\">0</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"err\">↑</span><span class=\"n\">h</span>\n</code></pre></div>",
        "id": 208979404,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599144792
    },
    {
        "content": "<p>(trying the subsingleton thing now too)</p>",
        "id": 208979505,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599144843
    },
    {
        "content": "<p>Ah, I didn't know you had an <code>exists</code> goal. Then yes, <code>0</code> works. You can combine <code>use</code> steps like so: <code>use [0, 0]</code>.</p>",
        "id": 208980044,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1599145056
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">{</span>\n  <span class=\"n\">chess</span><span class=\"bp\">.</span><span class=\"n\">board</span> <span class=\"bp\">.</span>\n  <span class=\"n\">pieces</span> <span class=\"o\">:=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"err\">♞</span><span class=\"o\">],</span>\n  <span class=\"n\">contents</span> <span class=\"o\">:=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">1</span><span class=\"o\">)],</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">none</span><span class=\"o\">],</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">none</span><span class=\"o\">]],</span>\n  <span class=\"n\">contains_pieces</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">ix</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span>\n  <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">no_superimposed_pieces</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 208981620,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1599145681
    },
    {
        "content": "<p>Nice, thanks. How can I interpret what that error message means just so I know? I didn't really take the time to understand universes yet, though I assume it has something to do with maybe russel-paradoxy-set-theory stuff? But what is that error message saying, is it telling me <em>I</em> needed to define that some types are at a higher universe level than I did?</p>",
        "id": 208985821,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599147323
    },
    {
        "content": "<p>This is just an error message where Lean is completely confused about what you wanted</p>",
        "id": 208985992,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599147386
    },
    {
        "content": "<p>A ha. OK.</p>",
        "id": 208986079,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599147435
    },
    {
        "content": "<p>I think it happens when you try to use <code>0</code> as a type</p>",
        "id": 208986662,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599147644
    },
    {
        "content": "<p>or more likely, accidentally use <code>0</code> as a type</p>",
        "id": 208986681,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599147651
    },
    {
        "content": "<p>Syntactically is there a way to avoid needing the underscores when trying to write out an example of my structure: <a href=\"https://github.com/Julian/lean-across-the-board/blob/57ae80d7714f20299d2abab6d8a3e3ac5c477f6c/test/board.lean#L4\">https://github.com/Julian/lean-across-the-board/blob/57ae80d7714f20299d2abab6d8a3e3ac5c477f6c/test/board.lean#L4</a> -- if I don't and just write <code>example : chess.board :=</code>, I seem to get <code>type,mismatch as structure instance [...] but is expected to have type ⁇ : Sort ?</code></p>",
        "id": 209036089,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599171534
    },
    {
        "content": "<p>(And secondly can I within a namespace make all the literals be elements of fintype so I don't have to individually annotate all the numbers I write?)</p>",
        "id": 209036115,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599171565
    },
    {
        "content": "<p>actually I guess that fintype would change from example to example, so never mind that</p>",
        "id": 209036198,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599171621
    },
    {
        "content": "<p>It's possible that <code>hint</code> would have revealed here that <code>dec_trivial</code> would work.</p>",
        "id": 209036522,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1599171884
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113489-new-members/topic/Advice.20on.20Definitions/near/209036522\">said</a>:</p>\n<blockquote>\n<p>It's possible that <code>hint</code> would have revealed here that <code>dec_trivial</code> would work.</p>\n</blockquote>\n<p>hm I must be using that wrong -- I found/followed <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#hint\">https://leanprover-community.github.io/mathlib_docs/tactics.html#hint</a> and added <code>import tactic.hint</code> but I still seem to get <code>unknown identifier 'hint'</code> -- did I miss a step somehow?</p>",
        "id": 209037006,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599172275
    },
    {
        "content": "<p>oh does that mean I should add <em>both</em> of those imports? /me tries...</p>",
        "id": 209037166,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599172392
    },
    {
        "content": "<p>Ah interesting ok I figured it out (that I need <code>by hint</code> not just <code>hint</code> there)</p>",
        "id": 209038539,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599173555
    },
    {
        "content": "<p>and yes it does suggest dec_trivial, thanks!</p>",
        "id": 209038554,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599173571
    },
    {
        "content": "<p>Sorry, yes -- you worked it out: <code>hint</code> is a tactic so only does anything inside a <code>begin ... end</code> or <code>by ...</code> block.</p>",
        "id": 209038901,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1599173898
    },
    {
        "content": "<p>Don't get in the habit of relying on <code>hint</code> too much. It is really dumb, and will suggest terrible ideas.</p>",
        "id": 209038913,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1599173924
    },
    {
        "content": "<p>All good -- and understood :)</p>",
        "id": 209039000,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599174002
    },
    {
        "content": "<p>I guess I'm getting syntax fairly fundamentally wrong, but what's wrong with <code>def width (b : board m n ι K) : ℕ := m.card</code>? I get an error of <code>error| [lean] invalid field notation, type is not of the form (C ...) where C is a constant [E]</code></p>",
        "id": 209383671,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599570795
    },
    {
        "content": "<p>Or I guess alternatively how do I get the dimension of a side of a matrix instance, probably that's clearer anyhow... that maybe I can look up</p>",
        "id": 209383821,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599570858
    },
    {
        "content": "<p>It will probably work if you use <code>fintype.card m</code> instead of <code>m.card</code>.</p>\n<p>I'm assuming you have declared <code>m</code> like above:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">m</span><span class=\"o\">]</span>\n</code></pre></div>\n\n\n<p>Abbreviations for the dot-notation like <code>m.card</code> work as follows: we infer the type of <code>m</code>. If it is of the form <code>some_constant x1 x2 ...</code>, then <code>m.card</code> gets expanded to <code>some_constant.card m</code>. So if <code>m : finset α</code>, we get <code>finset.card m</code>, but if <code>m</code> is just any arbitrary type there is no constant whose name we can use. Instead you have to write out the full name of <code>fintype.card</code>.</p>",
        "id": 209385344,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1599571559
    },
    {
        "content": "<p>Aha, ok thanks. It does indeed compile at least if I use <code>fintype.card</code> explicitly, though I still get another error that I've seen before when I try to use it</p>",
        "id": 209386469,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599572083
    },
    {
        "content": "<p>(fuller example incoming...)</p>",
        "id": 209386484,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599572088
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">width</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">board</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">ι</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">m</span>\n\n<span class=\"n\">def</span> <span class=\"n\">b₁</span> <span class=\"o\">:</span> <span class=\"n\">board</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">board</span> <span class=\"bp\">.</span>\n    <span class=\"n\">pieces</span> <span class=\"o\">:=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"err\">♞</span><span class=\"o\">],</span>\n    <span class=\"n\">contents</span> <span class=\"o\">:=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">1</span><span class=\"o\">)],</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">__</span><span class=\"o\">],</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">__</span><span class=\"o\">]],</span>\n    <span class=\"n\">contains_pieces</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n    <span class=\"n\">no_superimposed_pieces</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">width</span> <span class=\"n\">b₁</span>\n</code></pre></div>\n\n\n<p>The <code>check</code> produces:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">width</span> <span class=\"n\">b₁</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">b₁</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">board</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">colored_pieces</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 209386811,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599572272
    },
    {
        "content": "<p>I suspect you need to declare some variables as implicit. What is the output of <code>#check width</code>?</p>",
        "id": 209387402,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1599572569
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">width</span> <span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_3</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_4</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">m</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_5</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_6</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">),</span> <span class=\"n\">board</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">ι</span> <span class=\"n\">K</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span>\n</code></pre></div>",
        "id": 209387522,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599572631
    },
    {
        "content": "<p>do I basically put all the types there in that product-y notation as square bracketed variables in the call to width?</p>",
        "id": 209387742,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599572715
    },
    {
        "content": "<p>er sorry definition of width</p>",
        "id": 209387763,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599572723
    },
    {
        "content": "<p>it's <code>width m n ι K b₁</code> as dictated by the arguments with (round brackets)</p>",
        "id": 209387943,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1599572788
    },
    {
        "content": "<p>as in the signature of width is saying now I should provide all those parameters?</p>",
        "id": 209388006,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599572828
    },
    {
        "content": "<p>You should provide the ones in <code>()</code> and not the ones in <code>[]</code> or <code>{}</code>.</p>",
        "id": 209388146,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599572885
    },
    {
        "content": "<p>Indeed, so for usage of <code>width</code> it's better to make some arguments implicit. Try writing </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">ι</span> <span class=\"n\">K</span><span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>above <code>def width</code>, and now <code>#check width b₁</code> should work.</p>",
        "id": 209388171,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1599572899
    },
    {
        "content": "<p>Or more likely you should arrange to not have so many ones in <code>()</code>, and make them <code>{}</code> instead.</p>",
        "id": 209388182,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599572903
    },
    {
        "content": "<p>aha! ok <code>{}</code> not <code>[]</code> awesome, that works perfectly</p>",
        "id": 209388323,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599572983
    },
    {
        "content": "<p>how should I understand that syntax for <code>variables</code>?</p>",
        "id": 209388565,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599573094
    },
    {
        "content": "<p>more specifically -- why is that something you specify in the whole \"scope\" or namespace or whatever?</p>",
        "id": 209388592,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599573109
    },
    {
        "content": "<p>and not in the function declaration?</p>",
        "id": 209388601,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599573115
    },
    {
        "content": "<p>to avoid repetition</p>",
        "id": 209388653,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599573128
    },
    {
        "content": "<p>ok -- but now every function from that point till the bottom of the namespace implicitly takes that variable as an arg right?</p>",
        "id": 209388761,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599573189
    },
    {
        "content": "<p>Only if it needs it</p>",
        "id": 209388791,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599573203
    },
    {
        "content": "<p>aha ok</p>",
        "id": 209388827,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599573222
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321696\">Julian Berman</span> <a href=\"#narrow/stream/113489-new-members/topic/Advice.20on.20Definitions/near/209388323\">said</a>:</p>\n<blockquote>\n<p>aha! ok <code>{}</code> not <code>[]</code> awesome, that works perfectly</p>\n</blockquote>\n<p>The difference between <code>{}</code> and <code>[]</code> is that <code>{m : Type}</code> indicates <code>m</code> can be inferred from its usage later on in the type, <code>#check width</code> will now give something like <code>board ?m ?n ?ι ?K → ℕ</code>. Since <code>b₁ : board m n ι K</code>, and Lean is expecting this argument to be something of the form <code>board ?m ?n ?ι ?K</code>, it concludes the argument <code>?m</code> has to be <code>m</code>. If you wrote <code>[m : Type]</code> then you're asking the typeclass inference system to produce an element of <code>Type</code>. <code>#check width</code> will give an error in that case, because there is no typeclass instance defined for <code>Type</code>.</p>",
        "id": 209389133,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1599573355
    },
    {
        "content": "<p>so what I tried previously was more like adding <code>[fintype m]</code> to the definition of <code>width</code></p>",
        "id": 209389393,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599573463
    },
    {
        "content": "<p>which I thought would say there was a <code>fintype</code> that should be being implicitly referred to in my function</p>",
        "id": 209389429,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599573481
    },
    {
        "content": "<p>but that obviously didn't work either</p>",
        "id": 209389476,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599573488
    },
    {
        "content": "<p>(thanks by the way, that explanation I think definitely helped)</p>",
        "id": 209389929,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599573718
    },
    {
        "content": "<p>Do you mean implicitly referred to when you wrote <code>m.card</code>? that syntax is resolved using type information of <code>m</code>, and adding <code>[fintype m]</code> doesn't affect the type of <code>m</code>.</p>",
        "id": 209390228,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599573849
    },
    {
        "content": "<p>so originally I wrote something like (without the <code>variables</code> statement suggested): <code>def width (b: board m n i K) [fintype m] := fintype.card m</code></p>",
        "id": 209390368,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599573921
    },
    {
        "content": "<p>which I thought would mean <code>m</code> was implicitly an argument</p>",
        "id": 209390396,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599573933
    },
    {
        "content": "<p>but I guess what I should learn is that that <code>[...]</code> syntax is more like refining an argument that's already declared</p>",
        "id": 209390429,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599573952
    },
    {
        "content": "<p>so I'd need both that <em>and</em> <code>{m : Type}</code> to say that m was implicit and also by the way a fintype?</p>",
        "id": 209390507,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599573970
    },
    {
        "content": "<p>Technically a <code>[...]</code> argument is just another argument</p>",
        "id": 209390640,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599574030
    },
    {
        "content": "<p>If you don't give it a name, it will be assigned one like <code>_inst</code>. And when the function is used, the argument will be synthesized using the type class system.</p>",
        "id": 209390731,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599574066
    },
    {
        "content": "<p><code>[fintype m]</code> should be read as <code>[some_variable_name_that_nobody_should_ever_mention : fintype m]</code></p>",
        "id": 209390825,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599574093
    },
    {
        "content": "<p>aha... ok</p>",
        "id": 209390848,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599574104
    },
    {
        "content": "<p>So, the end result is more or less as you describe.</p>",
        "id": 209390852,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599574107
    },
    {
        "content": "<p>why doesn't just <code>def width (b : board m _ _ _) : ℕ := fintype.card n</code> work, which also confused me</p>",
        "id": 209390989,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599574168
    },
    {
        "content": "<p>doesn't the type system know based on how I declared <code>board</code> what types the other 3 need to be?</p>",
        "id": 209391015,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599574181
    },
    {
        "content": "<p>no, they can be any fintype</p>",
        "id": 209391648,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1599574422
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">ι</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"n\">def</span> <span class=\"n\">board</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"n\">def</span> <span class=\"n\">width</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">board</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">ι</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>is equivalent to</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">board</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">ι</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"n\">def</span> <span class=\"n\">width</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">ι</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">board</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">ι</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 209391821,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1599574501
    },
    {
        "content": "<p>so Lean doesn't know that it should use <code>m</code></p>",
        "id": 209391829,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1599574507
    },
    {
        "content": "<p>not sure I understood the point yet (I'm sure that's just me being a bit dense though)</p>",
        "id": 209393879,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599575363
    },
    {
        "content": "<p>I might as well have written:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">width</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">ι</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">board</span> <span class=\"n\">n</span> <span class=\"n\">n</span> <span class=\"n\">n</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 209393971,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1599575396
    },
    {
        "content": "<p>as in the type system doesn't know whether I meant that?</p>",
        "id": 209394093,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599575428
    },
    {
        "content": "<p>yes</p>",
        "id": 209394107,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1599575433
    },
    {
        "content": "<p>(sorry, maybe this is still just a poor questions but) I would assume the type system should think I mean \"take the most general type from the board definition that's allowed for each field\" no?</p>",
        "id": 209394330,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599575513
    },
    {
        "content": "<p>i.e. \"apply no further restrictions\", so not <code>n n n n</code></p>",
        "id": 209394391,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599575523
    },
    {
        "content": "<p>(at some point feel free to just tell me \"that's just not how it works\" obviously :)</p>",
        "id": 209394466,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599575554
    },
    {
        "content": "<p>that's too much to ask for the type system to retrospectively declare variables</p>",
        "id": 209394474,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1599575557
    },
    {
        "content": "<p><code>_</code> is reserved for situations when the type system can <em>infer</em> the <strong>term</strong></p>",
        "id": 209394560,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1599575599
    },
    {
        "content": "<p>and there's no <em>deferred</em> mechanism there too right?</p>",
        "id": 209394623,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599575620
    },
    {
        "content": "<p>because really the type I want is \"I'm going to pass you an instance later, the type of that parameter is the type of that field on the instance I'll give you later\"</p>",
        "id": 209394658,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599575639
    },
    {
        "content": "<p>I don't understand what you mean</p>",
        "id": 209394903,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1599575752
    },
    {
        "content": "<p>if you want to say that Lean should use the definition to infer the underscores</p>",
        "id": 209394970,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1599575764
    },
    {
        "content": "<p>then it is possible, but not from <code>fintype.card n</code></p>",
        "id": 209394996,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1599575774
    },
    {
        "content": "<p>will maybe mull on this a bit as I learn some more (I'm sure my dynamically typed daytime programming is showing through a bit too much)</p>",
        "id": 209395198,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599575859
    },
    {
        "content": "<p>thanks for indulging the question</p>",
        "id": 209395208,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599575864
    },
    {
        "content": "<p>This doesn't work, in part because I don't yet understand how to easily deal with the <code>option</code> type, but am I on the right track syntactically with using <code>match</code> to define this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\">- A move is an initial chess board along with the start and end squares</span>\n<span class=\"cm\">    containing the piece which is moved. -/</span>\n<span class=\"kn\">structure</span> <span class=\"n\">move</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">board</span><span class=\"o\">:</span> <span class=\"n\">board</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">ι</span> <span class=\"n\">colored_pieces</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">start_square</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">×</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">end_square</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">×</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">occupied_start</span><span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">board</span><span class=\"bp\">.</span><span class=\"n\">contents</span> <span class=\"n\">start_square</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">start_square</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_some</span>\n    <span class=\"bp\">.</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">exact_dec_trivial</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">valid_for_piece</span><span class=\"o\">:</span> <span class=\"n\">pieces</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">board</span><span class=\"bp\">.</span><span class=\"n\">pieces</span> <span class=\"o\">(</span><span class=\"n\">board</span><span class=\"bp\">.</span><span class=\"n\">contents</span> <span class=\"n\">start_square</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">start_square</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pieces</span><span class=\"bp\">.</span><span class=\"n\">knight</span> <span class=\"o\">:=</span> <span class=\"o\">(</span>\n    <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">end_square</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">start_square</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span>\n        <span class=\"bp\">∧</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">end_square</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">start_square</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∨</span>\n    <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">end_square</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">start_square</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span>\n        <span class=\"bp\">∧</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">end_square</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">start_square</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n <span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span>\n <span class=\"kn\">end</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 210033772,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600102895
    },
    {
        "content": "<p>It's <code>valid_for_piece</code> that I'm trying to add/define (and I don't see how to tell the match that I already know the square is occupied from <code>occupied_start</code>, so probably I'm doing that part wrong as well and they should somehow combine)</p>",
        "id": 210033908,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600102939
    },
    {
        "content": "<p>I know there's likely a few things wrong with that, just trying to make progress I guess. <code>tt</code> is not a Prop, if that even is the right type I want there -- what's the trivial proposition?</p>",
        "id": 210034614,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600103260
    },
    {
        "content": "<p><code>true</code></p>",
        "id": 210034635,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600103272
    },
    {
        "content": "<p>Ah of course.</p>",
        "id": 210034676,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600103282
    },
    {
        "content": "<p>I would define a separate def that takes a piece and a pair of positions and says whether it is a valid move</p>",
        "id": 210035071,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1600103464
    },
    {
        "content": "<p>Whether or not the end pos is occupied</p>",
        "id": 210035113,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1600103483
    },
    {
        "content": "<p>And doesn't care about board dimensions etc</p>",
        "id": 210035128,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1600103497
    },
    {
        "content": "<p>and then that <code>def</code> would match on the piece?</p>",
        "id": 210035153,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600103512
    },
    {
        "content": "<p>Exactly. Even more verbose would be separate defns for each move type. Then the match statement is just properly connecting to the defns you made.</p>",
        "id": 210035294,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1600103568
    },
    {
        "content": "<p>makes sense</p>",
        "id": 210035328,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600103587
    },
    {
        "content": "<p>Which you'd have to do anyway because of en passant or castling, etc.</p>",
        "id": 210035336,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1600103589
    },
    {
        "content": "<p>yeah I'm not even going to bother doing anything but knights to start, and no captures, and no other fun</p>",
        "id": 210035373,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600103612
    },
    {
        "content": "<p>keepin it quite simple for now, I'm trying to \"prove\" / \"represent\" <a href=\"https://github.com/Julian/lean-across-the-board/blob/main/src/guarini.lean\">https://github.com/Julian/lean-across-the-board/blob/main/src/guarini.lean</a></p>",
        "id": 210035418,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600103641
    },
    {
        "content": "<p>will give that a shot.</p>",
        "id": 210035466,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600103647
    },
    {
        "content": "<p>Oh also how do I convert between <code>m × n</code> and <code>m \\to n</code>? I assume there's some nicer way than the explicit unpacking I did there</p>",
        "id": 210035767,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600103801
    },
    {
        "content": "<p><code>function.curry</code> and <code>function.uncurry</code></p>",
        "id": 210035827,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1600103837
    },
    {
        "content": "<p>aha, thanks!</p>",
        "id": 210035856,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600103852
    },
    {
        "content": "<p>I guess that I should indeed first look for things named like the operation I'm doing... :)</p>",
        "id": 210035891,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600103874
    },
    {
        "content": "<p>Seriously, that is an extremely important strategy.</p>",
        "id": 210035987,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1600103923
    },
    {
        "content": "<p>It's the reason why <code>zmod.pow_card</code> is called like that, instead of <code>fermats_little_theorem</code></p>",
        "id": 210036088,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1600103954
    },
    {
        "content": "<p>Or look up Cayley Hamilton, or any other theorem that carries the name of a famous mathematician that you learned in 1st or 2nd year...<br>\nThe mathematician might be named in the docstring, but the theorem will have some crazy name that says what it is doing.<br>\nException: <code>function.curry</code></p>",
        "id": 210036264,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1600104042
    },
    {
        "content": "<p>How do you plan on using move? As it is now, every time you try to create a move, you'll have to prove something about a complex board state.</p>",
        "id": 210036317,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1600104078
    },
    {
        "content": "<p>I'm picturing a move as a pair of positions, and possibly tupled with the piece being moved. That is in turn passed to a \"is_valid\" which takes a board state and that move, and tells you if it's valid.</p>",
        "id": 210036514,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1600104173
    },
    {
        "content": "<p>Maybe <code>dec_trivial</code> can prove that?</p>",
        "id": 210036515,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1600104174
    },
    {
        "content": "<p>I was hoping <code>dec_trivial</code> would do magic again yeah</p>",
        "id": 210036536,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600104186
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/Advice.20on.20Definitions/near/210036264\">said</a>:</p>\n<blockquote>\n<p>Or look up Cayley Hamilton, or any other theorem that carries the name of a famous mathematician that you learned in 1st or 2nd year...<br>\nThe mathematician might be named in the docstring, but the theorem will have some crazy name that says what it is doing.<br>\nException: <code>function.curry</code></p>\n</blockquote>\n<p>yeah I've noticed a few examples of that already (from just browsing around random theorems) -- it's definitely super helpful</p>",
        "id": 210036701,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600104265
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/Advice.20on.20Definitions/near/210036317\">said</a>:</p>\n<blockquote>\n<p>How do you plan on using move? As it is now, every time you try to create a move, you'll have to prove something about a complex board state.</p>\n</blockquote>\n<p>clearly I don't know too much about what I'm doing yet, but other than hoping that <code>dec_trivial</code> would just prove this for me each time I made one, I also assumed at some point I'll want to define ways to \"reify\" moves onto boards and be able to convert between sequences of moves and sequences of boards -- because ultimately I think the theorem I'm going for is like \"this sequence of moves is valid and takes this starting board to this ending board\"</p>",
        "id": 210036949,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600104417
    },
    {
        "content": "<p>I guess \"your way\" you instead just have sequences of boards, and then you assert that the moves between them are all valid</p>",
        "id": 210037160,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600104544
    },
    {
        "content": "<p>Totally. Monadic moves while satisfying the valid constraint. Then the whole thing is a 'sequence' in Haskell lingo.</p>",
        "id": 210040403,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1600106005
    },
    {
        "content": "<p>Yes somehow I am getting the distinct sense that I'd be further along in Lean if I knew more Haskell :)</p>",
        "id": 210041296,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600106459
    },
    {
        "content": "<p>Or more math.</p>",
        "id": 210041528,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600106572
    },
    {
        "content": "<p>or both, oy.</p>",
        "id": 210041532,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600106576
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321696\">@Julian Berman</span>, I haven't looked in any detail at what you're doing, but have you looked at the existing examples of combinatorial games? They will be of a different flavour than what you're doing, but may be useful reading to see how similar things have been done previously. From memory we only have domineering and nim (there is an abandoned dots-and-boxes branch, but I think it didn't have much).</p>",
        "id": 210069481,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1600121686
    },
    {
        "content": "<p>There's an abandoned dots and boxes branch??</p>",
        "id": 210070155,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600122236
    },
    {
        "content": "<p>I saw the file actually a week or so ago when grepping around. It definitely looked interesting yeah</p>",
        "id": 210070803,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600122753
    },
    {
        "content": "<p>I didn't read it carefully then but made a note to read it. Maybe now's indeed the time</p>",
        "id": 210070832,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600122786
    },
    {
        "content": "<p>The <a href=\"https://github.com/leanprover-community/mathlib/tree/dots_and_boxes\">branch#dots_and_boxes</a> seems to have irremediably diverged from master; attempting to merge gave lots of conflicts. The actual <code>dots_and_boxes.lean</code> file is at <a href=\"https://gist.github.com/semorrison/b14fac4a1cb65a117f0fab08a6afabf8\">https://gist.github.com/semorrison/b14fac4a1cb65a117f0fab08a6afabf8</a>, although I have no idea if there are supporting lemmas in other files that got lost. As you can see its far from complete.</p>",
        "id": 210071211,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1600123087
    },
    {
        "content": "<p>(If I remember right, while most of that file is reasonable, at the end I tried to force dots-and-boxes to \"be\" a Conway combinatorial game, which it isn't, by doing something awkward like including \"alternately counting claimed boxes\" as moves after the end of the usual game. This is probably dumb in some way that I hadn't thought of.)</p>",
        "id": 210071391,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1600123256
    },
    {
        "content": "<p>I don't think you can do it like that</p>",
        "id": 210071419,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600123280
    },
    {
        "content": "<p>I think that dots and boxes is not a combinatorial game and can't be made into one in any natural way. The combinatorial game is called nimdots.</p>",
        "id": 210071444,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600123317
    },
    {
        "content": "<p>I remember thinking hard about this a decade or so ago</p>",
        "id": 210071489,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600123329
    },
    {
        "content": "<p>nimdots is just like dots and boxes except last player to complete a legal move wins.</p>",
        "id": 210071509,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600123356
    },
    {
        "content": "<p>Yes, I had a bad feeling about this as I was going. In any case I hope the top 80% of that file is still sensible, and one should just lop it off at the first place <code>pgame</code> is mentioned.</p>",
        "id": 210071518,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1600123368
    },
    {
        "content": "<p>in Winning Ways they argue that the two games are very similar, and this is true to a certain extent; I once wrote a paper explaining where the two theories started to differ.</p>",
        "id": 210071529,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600123392
    },
    {
        "content": "<p>In any case, I think the most important thing to salvage from that branch is the following doc-string:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\">- All games of dots and boxes are short, because it&#39;s hard to beat Kevin. -/</span>\n<span class=\"kn\">instance</span> <span class=\"n\">short_dots_and_boxes</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">dots_and_boxes</span><span class=\"bp\">.</span><span class=\"n\">board</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">short</span> <span class=\"o\">(</span><span class=\"n\">dots_and_boxes</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 210071562,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1600123436
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> some very superficial questions I'm sure as I try to understand your commits (thanks again! glad I tempted you :)</p>",
        "id": 210156389,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600188828
    },
    {
        "content": "<p>I guess first -- <code>rfl</code> is to <code>by refl</code> what like <code>dec_trivial</code> is to <code>tactic.exact_dec_trivial</code> or so?</p>",
        "id": 210156516,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600188869
    },
    {
        "content": "<p>it's like a tactic that just calls a specific (lemma?/callable?something? what's the terminology for what those are)</p>",
        "id": 210156578,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600188903
    },
    {
        "content": "<p>Hm does go to definition take me to <code>rfl</code>'s definition...</p>",
        "id": 210156694,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600188955
    },
    {
        "content": "<p>it does, cool, so scratch the above</p>",
        "id": 210156781,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600188973
    },
    {
        "content": "<p>ok, next, what's the point of <code>simp only</code>?</p>",
        "id": 210157268,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600189150
    },
    {
        "content": "<p>I can see what it does, but is it just a performance optimization?</p>",
        "id": 210157302,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600189161
    },
    {
        "content": "<p>Yes, though it's also sometimes useful if <code>simp</code> simplifies an expression too much. We have a tutorial page on <code>simp</code> which discusses this: <a href=\"https://leanprover-community.github.io/extras/simp.html\">https://leanprover-community.github.io/extras/simp.html</a></p>",
        "id": 210157553,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1600189250
    },
    {
        "content": "<p>Ah, cool, thanks!</p>",
        "id": 210157621,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600189278
    },
    {
        "content": "<p>I like that that page uses language like \"Lean seems to [...] (apparently unfold just asks simp to do its dirty work for it\". Makes me feel better about feeling fuzzy about lean's behavior.</p>",
        "id": 210160060,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600190378
    },
    {
        "content": "<p>The tactic <code>refl</code> is slightly more general than the term <code>rfl</code>, because the tactic will close any goal of the form <code>R x y</code> if <code>R</code> is tagged with an attribute saying it's reflexive (the attribute might also be called <code>refl</code>, I can't remember). On the other hand <code>rfl</code> is just reflexivity of equality; for example if you wanted to prove <code>X &lt;-&gt; X</code> in term mode, you'd use <code>iff.rfl</code>.</p>",
        "id": 210162760,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600191627
    },
    {
        "content": "<p>Writing <code>lemma FLT : lemma_statement := rfl</code> also flags <code>FLT</code> as a <code>[refl]</code> lemma.</p>",
        "id": 210163382,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1600191892
    },
    {
        "content": "<p>(From that simp page too) -- I guess <code>existsi</code> is probably similar to <code>use</code>? Is there a reason to use <code>existsi</code> instead of <code>use</code> or vice versa?</p>",
        "id": 210164029,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600192156
    },
    {
        "content": "<p>Ah, use's docstring says things...</p>",
        "id": 210164171,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600192207
    },
    {
        "content": "<p>OK I don't know the practical implications of <code>Unlike existsi, x is elaborated with respect to the expected type.</code> but I guess I can learn \"always use <code>use</code> from that\" probably?</p>",
        "id": 210164297,
        "sender_full_name": "Julian Berman",
        "timestamp": 1600192266
    }
]
[
    {
        "content": "<p>Hi, I didn't see anything in Chapter 11 of TPIL about taking a function (which Lean fails to synthesize \"decidable\" for) and specifying it is decidable.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">open</span> <span class=\"n\">equiv</span> <span class=\"c1\">-- &quot;perm x&quot; is &quot;equiv x x&quot; AKA &quot;x ≃ x&quot;</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Defining a predicate for a permutation on a finite set to be a k-cycle</span>\n<span class=\"cm\">Start at 0, and take k steps (which don&#39;t bring you to 0 until the last one)</span>\n<span class=\"cm\">-/</span>\n<span class=\"n\">def</span> <span class=\"n\">cyclicrec</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">},</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"mi\">0</span>        <span class=\"n\">curr</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">curr</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">curr</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">curr</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">)</span>\n                                            <span class=\"bp\">∧</span> <span class=\"n\">cyclicrec</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">curr</span><span class=\"o\">)</span> <span class=\"n\">p</span>\n\n<span class=\"n\">def</span> <span class=\"n\">cyclic</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n <span class=\"bp\">|</span> <span class=\"mi\">0</span>        <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span> <span class=\"c1\">-- exclude 0-cycles</span>\n <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">cyclicrec</span> <span class=\"n\">m</span> <span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">succ_pos&#39;</span><span class=\"bp\">⟩</span> <span class=\"n\">p</span>\n\n<span class=\"bp\">//</span> <span class=\"n\">something</span> <span class=\"n\">like</span><span class=\"o\">:</span> <span class=\"kn\">instance</span> <span class=\"n\">decidable</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">cyclic</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"err\">???</span>\n</code></pre></div>\n\n\n<p>I'd like to make some unit tests to see if my definition is sane, so I construct a concrete instance  like <code>def cyc : perm (fin 3) := (0 1 2)</code> and would like to do something like <code>#eval cyclic cyc</code> and see <code>tt</code>, and likewise for <code>#eval cyclic not_cyc</code> to show <code>ff</code>. Is there a way to do this in Lean?</p>",
        "id": 201416111,
        "sender_full_name": "Kris Brown",
        "timestamp": 1592586013
    },
    {
        "content": "<p>for me your definitions fail at the equation compiler level</p>",
        "id": 201422360,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1592589489
    },
    {
        "content": "<p>Hm, I'm using Lean (version 3.16.2, commit 8f928c403cee, Release). I'd love to test it on the Lean Web Editor but it seems like you can't import from mathlib using that? (I get <code>file 'data/equiv/basic' not found in the LEAN_PATH</code>)</p>",
        "id": 201425268,
        "sender_full_name": "Kris Brown",
        "timestamp": 1592591135
    },
    {
        "content": "<p>I'm not exactly sure what failing at the equation compiler level specifically means - I thought the definition was valid because my VScode editor is not highlighting anything</p>",
        "id": 201425516,
        "sender_full_name": "Kris Brown",
        "timestamp": 1592591288
    },
    {
        "content": "<p>Hmm, you might have to clear the library cache, because <a href=\"https://leanprover-community.github.io/lean-web-editor/#code=import%20data.equiv.basic%0A\">this</a> works for me in the Lean web editor. To do so, click the (?) button and then scroll to the bottom and click the \"Clear library cache and refresh\" button.</p>",
        "id": 201425566,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1592591319
    },
    {
        "content": "<p>Using VS Code is highly preferred to using the web editor, by the way.</p>",
        "id": 201425593,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1592591341
    },
    {
        "content": "<p>Sorry, I was using leanprover.github rather than leanprover-community.github.</p>",
        "id": 201425622,
        "sender_full_name": "Kris Brown",
        "timestamp": 1592591364
    },
    {
        "content": "<p>That one imports a 2018 version of mathlib, I think.</p>",
        "id": 201425713,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1592591419
    },
    {
        "content": "<p>OK, I made some slight tweaks, and this should work with the latest version of mathlib and the community web editor:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">open</span> <span class=\"n\">equiv</span> <span class=\"n\">nat</span> <span class=\"c1\">-- &quot;perm x&quot; is &quot;equiv x x&quot; AKA &quot;x ≃ x&quot;</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Defining a predicate for a permutation on a finite set to be a k-cycle</span>\n<span class=\"cm\">Start at 0, and take k steps (which don&#39;t bring you to 0 until the last one)</span>\n<span class=\"cm\">-/</span>\n<span class=\"n\">def</span> <span class=\"n\">cyclicrec</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">},</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"mi\">0</span>        <span class=\"n\">curr</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">curr</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">curr</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">curr</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">)</span>\n                                            <span class=\"bp\">∧</span> <span class=\"n\">cyclicrec</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">curr</span><span class=\"o\">)</span> <span class=\"n\">p</span>\n\n<span class=\"n\">def</span> <span class=\"n\">cyclic</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n <span class=\"bp\">|</span> <span class=\"mi\">0</span>        <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span> <span class=\"c1\">-- exclude 0-cycles</span>\n <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">cyclicrec</span> <span class=\"n\">m</span> <span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">succ_pos&#39;</span><span class=\"bp\">⟩</span> <span class=\"n\">p</span>\n</code></pre></div>\n\n\n<p>(I'm using a version of mathlib that's just a few days old, but still on Lean 3.16.3.)</p>",
        "id": 201425832,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1592591517
    },
    {
        "content": "<p>Thanks! So if you just add</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">iden</span>  <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span> <span class=\"c1\">-- identity permutation</span>\n<span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"k\">if</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">cyclic</span> <span class=\"n\">iden</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"mi\">1</span>\n</code></pre></div>\n\n\n<p>You'll see that it is not able to synthesize <code>decidable</code> for <code>cyclic p</code>.  </p>\n<p>Is the problem then that Lean doesn't know that <code>iden</code> is decidable, rather than an issue with <code>cyclic</code>?</p>",
        "id": 201426346,
        "sender_full_name": "Kris Brown",
        "timestamp": 1592591823
    },
    {
        "content": "<p>A lot of stuff in mathlib was written by mathematicians, who are typically not bothered with decidability. Certainly this is decidable, indeed I can think of a really crap algorithm which decides it, but I can quite believe that nobody put it into mathlib. If you're interested in that kind of thing then there are two ways to go: either you do some super-inefficient general thing saying \"clearly some brute force argument works, so done\", or you write an algorithm which actually terminates in practice. Of course the latter is much harder, because you'll also have to formally verify that your algorithm works.</p>",
        "id": 201426775,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592592142
    },
    {
        "content": "<p>It would not surprise me if the corresponding thing were in Coq, they are far more concerned with these issues.</p>",
        "id": 201426829,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592592182
    },
    {
        "content": "<p>I am not really able to help more -- most Lean files I write start with assuming the axiom that everything is decidable -- I am more interested in proofs than algorithms. But there are certainly people here who could help (although they might not read <a class=\"stream\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members\">#new members</a> -- you could ask in <a class=\"stream\" data-stream-id=\"116395\" href=\"/#narrow/stream/116395-maths\">#maths</a> as this is a perfectly respectable question)</p>",
        "id": 201426890,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592592226
    },
    {
        "content": "<p>Thanks, I appreciate the in-depth answer! I can post there too. Though I still don't understand what the actual problem I'm facing is. Is there some dependency (in <code>data.{nat,equiv,fintype}.basic</code>) that I'm implicitly using that's noncomputable (and I'd have to find it and replace with something computable)?</p>",
        "id": 201427747,
        "sender_full_name": "Kris Brown",
        "timestamp": 1592592790
    },
    {
        "content": "<p><code>decidable</code> is an inductive type. <a href=\"https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#decidable-propositions\">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#decidable-propositions</a></p>",
        "id": 201427890,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592592877
    },
    {
        "content": "<p>If you want to make a term of type <code>decidable p</code> then you have two constructors available to you -- you either have to prove that p is true or that p is false.</p>",
        "id": 201427971,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592592922
    },
    {
        "content": "<p>I am not a computer scientist and I found the abstract description in TPIL quite hard to follow in this abstract setting. However when I looked at the proof that &lt;= on nat was decidable in Lean it all made sense.</p>",
        "id": 201428062,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592592966
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">instance</span> <span class=\"n\">decidable_le</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"n\">b</span>     <span class=\"o\">:=</span> <span class=\"n\">is_true</span> <span class=\"o\">(</span><span class=\"n\">zero_le</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"mi\">0</span>     <span class=\"o\">:=</span> <span class=\"n\">is_false</span> <span class=\"o\">(</span><span class=\"n\">not_succ_le_zero</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">decidable_le</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">is_true</span> <span class=\"n\">h</span>  <span class=\"o\">:=</span> <span class=\"n\">is_true</span> <span class=\"o\">(</span><span class=\"n\">succ_le_succ</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">is_false</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">is_false</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">le_of_succ_le_succ</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n  <span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 201428126,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592593016
    },
    {
        "content": "<p>This is a pretty sensible algorithm to work out if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a\\leq b</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> -- if one is 0 it's easy, and if they're both positive then subtract one and continue. Note that in this case you have to pass to Lean proofs of things like if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a\\leq b</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>+</mo><mn>1</mn><mo>≤</mo><mi>b</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">a+1\\leq b+1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> -- it's a formally verified algorithm.</p>",
        "id": 201428273,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592593100
    },
    {
        "content": "<p>For decidability of questions like cyclicity of a permutation, you could either attempt to write some sort of sensible algorithm like that, or you can perhaps (I am not strong in this area so take everything I say with a pinch of salt) just do it by magic -- say \"it's a finite computation, so there's bound to be an algorithm\"</p>",
        "id": 201428410,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592593195
    },
    {
        "content": "<p>There is an art to this, and some people (who don't read <a class=\"stream\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members\">#new members</a> ) are very good at it. Unfortunately I'm not one of those people, because I just cheat and add the axiom that all props are decidable whenever I run into an undecidability issue. I'm afraid I've now told you everything I know about decidability. You might want to ask in #maths .</p>",
        "id": 201428551,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592593267
    },
    {
        "content": "<p>But I think the answer to your question is that pretty much <em>everything</em> is implicitly undecidable, in the sense that most propositions in Lean won't have the decidable predicate proved for them, perhaps because of laziness -- it is not a high priority around here.</p>",
        "id": 201428686,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592593354
    },
    {
        "content": "<p>Thanks! I wanted to take a crack at it before asking maths, but I can't even get the signature to typecheck:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">instance</span> <span class=\"n\">decidable_cyclic</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">Π</span> <span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">cyclic</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n  <span class=\"bp\">_</span>     <span class=\"bp\">_</span>     <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>Error</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">function</span> <span class=\"n\">expected</span> <span class=\"n\">at</span>\n  <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">cyclic</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n<span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span>\n</code></pre></div>\n\n\n<p>This doesn't make sense to me since <code>cyclic p</code> is a <code>Prop</code> and <code>decidable</code> is <code>Prop -&gt; Type</code>.</p>",
        "id": 201429261,
        "sender_full_name": "Kris Brown",
        "timestamp": 1592593756
    },
    {
        "content": "<p>Just pattern matching off the <code>decidable_le</code> example</p>",
        "id": 201429290,
        "sender_full_name": "Kris Brown",
        "timestamp": 1592593794
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">instance</span> <span class=\"n\">decidable_cyclic</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">Π</span> <span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">cyclic</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"n\">def</span> <span class=\"n\">iden</span>  <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span> <span class=\"c1\">-- identity permutation</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"k\">if</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">cyclic</span> <span class=\"n\">iden</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 201430044,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592594239
    },
    {
        "content": "<p>The <code>_</code>s in the &lt;= example are matching a and b, which you don't have (they're proving forall a b, ...)</p>",
        "id": 201430102,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592594282
    },
    {
        "content": "<p>I see, ok think I've got enough info to try this now - thanks so much!</p>",
        "id": 201430230,
        "sender_full_name": "Kris Brown",
        "timestamp": 1592594376
    },
    {
        "content": "<p>Good luck!</p>",
        "id": 201430237,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592594383
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">instance</span> <span class=\"n\">decidable_cyclic</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">Π</span> <span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">cyclic</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>I just saw you had two inputs too -- sorry, was talking nonsense earlier. You were missing the bar.</p>",
        "id": 201430343,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592594445
    },
    {
        "content": "<p>oops - good catch!</p>",
        "id": 201430807,
        "sender_full_name": "Kris Brown",
        "timestamp": 1592594715
    },
    {
        "content": "<p>Thinking about this -- the order should be computable, and so should the sizes of the orbits, so if you had a theorem saying that the permutation was cyclic iff one orbit has size equal to the order and the others all have size 1 then <code>dec_trivial</code> might be able to tell that this is decidable.</p>",
        "id": 201433025,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592596120
    },
    {
        "content": "<p>Oh maybe our definitions are different. It's annoying that the derive handler can't do this though</p>",
        "id": 201433385,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592596327
    },
    {
        "content": "<p>Do I understand correctly that your definition of cyclic means that <code>p</code> should be an <code>n</code>-cycle? not just an arbitrary cycle?<br>\nIn any case you might find <code>decidable_of_iff</code> usefull, you can then change to an equivalent proposition for which proving decidablity is easier.</p>",
        "id": 201433458,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1592596378
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable/near/201428686\">said</a>:</p>\n<blockquote>\n<p>But I think the answer to your question is that pretty much <em>everything</em> is implicitly undecidable, in the sense that most propositions in Lean won't have the decidable predicate proved for them, perhaps because of laziness -- it is not a high priority around here.</p>\n</blockquote>\n<p>As far as I know, this is not true. We've proved decidability for basically every predicate for which it makes sense</p>",
        "id": 201438234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1592599569
    },
    {
        "content": "<p>But you mathematicians are moving fast and maybe not keeping this practice up for newly defined predicates</p>",
        "id": 201438290,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1592599620
    },
    {
        "content": "<p>I'm sure you know a lot more about what's decidable than I do Mario!</p>",
        "id": 201438328,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592599658
    },
    {
        "content": "<p>I believe the correct version of that statement would be <code>decidable (cyclic A)</code> given <code>fintype A</code> and <code>decidable_eq A</code></p>",
        "id": 201438349,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1592599675
    },
    {
        "content": "<p>However this is not a very good implementation computation wise</p>",
        "id": 201438475,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1592599740
    },
    {
        "content": "<p>but it's better than nothing and it will probably suffice for groups of size 3 or so</p>",
        "id": 201438517,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1592599782
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300622\">@Kris Brown</span> Reading this thread more carefully, I notice that the definition of <code>cyclic</code> is not the usual mathematical style definition, but rather an explicit recursive function that could be used as the algorithm. In this case, there is a simple hack you can do to make it obviously decidable: change the return type from <code>Prop</code> to <code>bool</code> and let coercion do the rest</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">open</span> <span class=\"n\">equiv</span> <span class=\"n\">nat</span> <span class=\"c1\">-- &quot;perm x&quot; is &quot;equiv x x&quot; AKA &quot;x ≃ x&quot;</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Defining a predicate for a permutation on a finite set to be a k-cycle</span>\n<span class=\"cm\">Start at 0, and take k steps (which don&#39;t bring you to 0 until the last one)</span>\n<span class=\"cm\">-/</span>\n<span class=\"n\">def</span> <span class=\"n\">cyclicrec</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">},</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"mi\">0</span>        <span class=\"n\">curr</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">curr</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">curr</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">curr</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">)</span>\n                                            <span class=\"bp\">∧</span> <span class=\"n\">cyclicrec</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">curr</span><span class=\"o\">)</span> <span class=\"n\">p</span>\n\n<span class=\"n\">def</span> <span class=\"n\">cyclic</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n <span class=\"bp\">|</span> <span class=\"mi\">0</span>        <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span> <span class=\"c1\">-- exclude 0-cycles</span>\n <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">cyclicrec</span> <span class=\"n\">m</span> <span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">succ_pos&#39;</span><span class=\"bp\">⟩</span> <span class=\"n\">p</span>\n\n<span class=\"n\">def</span> <span class=\"n\">iden</span>  <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span> <span class=\"c1\">-- identity permutation</span>\n<span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"k\">if</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">cyclic</span> <span class=\"n\">iden</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"mi\">1</span> <span class=\"c1\">-- 1</span>\n</code></pre></div>",
        "id": 201439089,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1592600182
    },
    {
        "content": "<p>Would you want PRs for any additional decidability proofs? I have</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"n\">r</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">decidable_exists_of_subsets</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"err\">⊆</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"n\">t</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">decidable_of_iff</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"n\">t</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"k\">by</span> <span class=\"n\">finish</span>\n\n<span class=\"kn\">variable</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">decidable_exists_of_ssubsets</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"err\">⊂</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"n\">t</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">decidable_of_iff</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">s</span> <span class=\"err\">⊆</span> <span class=\"n\">t</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"n\">t</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"k\">by</span> <span class=\"n\">finish</span>\n</code></pre></div>",
        "id": 201439192,
        "sender_full_name": "Alistair Tucker",
        "timestamp": 1592600258
    },
    {
        "content": "<p>Hm, that seems okay, although you can end up writing a lot of such functions without some guiding principles</p>",
        "id": 201439461,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1592600413
    },
    {
        "content": "<p>I don't mind asking people to craft their predicates in a particular way in order to make them more obviously decidable. In examples like this, it's just as possible that the real predicate isn't explicitly over a finset at all (or subsets or ssubsets of one) but rather the predicate <code>r</code> is false outside the finset <code>s</code> for some reason</p>",
        "id": 201439737,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1592600570
    },
    {
        "content": "<p>so you would have to insert some rewrite anyway</p>",
        "id": 201439771,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1592600595
    },
    {
        "content": "<p>(but if you are going to PR these functions you should do the forall version too)</p>",
        "id": 201439817,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1592600637
    },
    {
        "content": "<p>Also, <code>r</code> should not depend on <code>s</code> here, there is no reason for that dependency</p>",
        "id": 201439913,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1592600693
    },
    {
        "content": "<p>You are right, it still works without the explicit dependence on <code>s</code>. I guess Lean is smarter than I realised! I'm not sure I understand your first point though. Do you mean it should be made over a more general type sharing some of <code>finset</code>'s properties?</p>",
        "id": 201441246,
        "sender_full_name": "Alistair Tucker",
        "timestamp": 1592601566
    },
    {
        "content": "<p>Oh I just found completely by accident that there is a definition <code>is_cycle</code> in group_theory.perm.sign expressing the same notion, seems like there are a lot of lemmas for it there already.</p>",
        "id": 201443129,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1592602861
    }
]
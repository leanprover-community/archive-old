[
    {
        "content": "<p>as a minimal (not-)working example, consider the following (re-)definition of a monoid action by first defining a semigroup action then extending the structure to include the additional axiom:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory</span><span class=\"bp\">.</span><span class=\"n\">coset</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">semigroup_act</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semigroup</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">smul</span>     <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mul_smul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">smul</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">smul</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">smul</span> <span class=\"n\">y</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">monoid_act</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">semigroup_act</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">one_smul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">smul</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>followed by some definitions and proofs:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">α</span><span class=\"o\">]:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">monoid_act</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">semigroup_act</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">to_semigroup_act</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">invariant</span> <span class=\"o\">[</span><span class=\"n\">semigroup</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">semigroup_act</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">S</span><span class=\"o\">),</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">smul</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">S</span>\n\n<span class=\"kn\">variable</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">invariant_univ₁</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">monoid_act</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">invariant</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">semigroup_act</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>but the following doesn't work, (I think) because the metavariables in the expected type prevent lean from considering the coercion:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">invariant_univ₂</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">monoid_act</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">invariant</span> <span class=\"n\">f</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"c1\">-- type mismatch at application</span>\n<span class=\"c1\">--  invariant f</span>\n<span class=\"c1\">-- term</span>\n<span class=\"c1\">--  f</span>\n<span class=\"c1\">-- has type</span>\n<span class=\"c1\">--  monoid_act α β : Type (max u_1 u_2)</span>\n<span class=\"c1\">-- but is expected to have type</span>\n<span class=\"c1\">--  semigroup_act ?m_1 ?m_2 : Type (max ? ?)</span>\n</code></pre></div>\n\n\n<p>I think I first encountered a version of this problem when I tried to write down things about continuous linear maps, and lean complained when I tried to invoke lemmas like <code>map_smul</code>. mathlib does <a href=\"https://github.com/leanprover-community/mathlib/blob/37119b416e06f6afef641da7f826d0b08ac7f84b/src/topology/algebra/module.lean#L232\">this</a>, which makes the following seem tempting to me:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">invariant</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">monoid_act</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">invariant</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">semigroup_act</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">S</span>\n</code></pre></div>\n\n\n<p>(in a practical case the the definitions will probably be under different namespaces so that no collision happens.)</p>\n<p>this feels somewhat redundant, though, if only because \"a set is invariant under a monoid action f if it is invariant under f as a semigroup action\" feels very obvious. is duplicating definitions/lemmas like this a good idea in general?</p>",
        "id": 208213580,
        "sender_full_name": "Jean Lo",
        "timestamp": 1598533605
    },
    {
        "content": "<p>This kind of error was fixed a while back for <code>has_coe_to_fun</code>, maybe it can be fixed for coercions more generally? <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span></p>",
        "id": 208214141,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598533909
    },
    {
        "content": "<p>(Well, not \"more generally\", but \"also\".)</p>",
        "id": 208214467,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598534068
    },
    {
        "content": "<p>No, we can now coerce <code>monoid_act ?m_1 ?m_2</code> to <code>semigroup_act ?m_1 ?m_2</code>.  But Jean's example requires finding a coercion and assigning the metavariables at the same time.  I don't think this can be done using the current coercion system in Lean 3.  It will also be impossible in Lean 4 as far as I can tell.</p>",
        "id": 208214552,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1598534120
    },
    {
        "content": "<p>Oh, because the target type of the coercion is also an argument to the class for <code>has_coe</code>, while the result of a <code>has_coe_to_fun</code> is a field of the class?</p>",
        "id": 208217177,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598535401
    },
    {
        "content": "<p>I guess this one wouldn't work in Haskell either (or a hypothetical Haskell with coercions). Just because there is</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">monoid_act</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">semigroup_act</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>doesn't mean there isn't/shouldn't also be, say,</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">monoid_act</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">semigroup_act</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 208217324,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598535477
    },
    {
        "content": "<p>ah, that makes sense, thanks!</p>\n<p>so maybe this is indeed a library design / convention question rather than a \"how to do coercions\" question. I guess an alternative would be to make <code>α</code> and <code>β</code> explicit arguments to <code>invariant</code>, and do</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">invariant_univ₂</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">monoid_act</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">invariant</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">f</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"c1\">-- this is ok</span>\n</code></pre></div>\n\n\n<p>between this, type ascriptions, and duplicating the definitions for the extended structure, do <code>mathlib</code> conventions have a preference? or is this something that depends on the context (supplying the types explicitly in the example here feels redundant, but e.g. — though I'm not sure how good of an example this is — when trying to apply <code>finite_dimensional</code> to a linear space + additional structure it makes sense that I should have to tell lean which <code>vector_space K V</code> i'm coercing into) ?</p>",
        "id": 208292483,
        "sender_full_name": "Jean Lo",
        "timestamp": 1598574668
    }
]
[
    {
        "content": "<p>What is the best way of proving that if <code>f : R ≃+* S</code> is an isomorphism of rings and <code>I : ideal R</code> then I get an iso <code>I.quotient ≃+* (map (f : R →+* S) I).quotient</code>? As in the following</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.ideal.operations</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">ideal</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">quotient_equiv</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">≃+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">I.quotient</span> <span class=\"bp\">≃+*</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"n\">I</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The map in one direction if given immediately by <code>quotient_map (map ↑f I) ↑f (@le_comap_map _ S _ _ _ _)</code>, but going in the other direction requires <code>(I : ideal R) (f : R ≃+* S) : I.map (f : R →+* S) ≤ I.comap f.symm</code> that, even if not difficult, is annoying. The fact that I am doing this by hand make me suspicious that I didn't understand the API correctly, in particular <code>ideal.rel_iso_of_bijective</code> seems relevant, but I don't know how to use it. Thank you!</p>",
        "id": 227973160,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614365220
    },
    {
        "content": "<p>Here's a proof I came up with that's WAY too long:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.ideal.operations</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">ideal</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">helper</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">≃+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">I.map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">I</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">submodule.span_induction</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">tauto</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">I.zero_mem</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">hx</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"n\">hy</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"n\">I.add_mem</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">hx</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">f.symm</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">refine</span> <span class=\"n\">I.mul_mem_left</span> <span class=\"n\">_</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"n\">hy</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">mem_map_of_mem</span> <span class=\"n\">hy</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">quotient_equiv</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">≃+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">I.quotient</span> <span class=\"bp\">≃+*</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"n\">I</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">J</span> <span class=\"o\">:=</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"n\">I</span><span class=\"o\">,</span>\n    <span class=\"n\">π</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">I.quotient</span> <span class=\"o\">:=</span> <span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">π'</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→+*</span> <span class=\"n\">J.quotient</span> <span class=\"o\">:=</span> <span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">_</span>\n<span class=\"k\">in</span>\n<span class=\"n\">ring_equiv.of_hom_inv</span>\n<span class=\"o\">(</span><span class=\"n\">ideal.quotient.lift</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">π'.comp</span> <span class=\"n\">f.to_ring_hom</span><span class=\"o\">)</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n  <span class=\"n\">erw</span> <span class=\"n\">quotient.eq_zero_iff_mem</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">mem_map_of_mem</span> <span class=\"n\">ha</span>\n<span class=\"kd\">end</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.lift</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">π.comp</span> <span class=\"n\">f.symm.to_ring_hom</span><span class=\"o\">)</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"n\">erw</span> <span class=\"n\">quotient.eq_zero_iff_mem</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"n\">_</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">helper</span> <span class=\"n\">at</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">hs</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">r</span><span class=\"o\">,</span><span class=\"n\">hr</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">change</span> <span class=\"o\">((</span><span class=\"n\">f.symm</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">simpa</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span><span class=\"o\">)</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">quotient.mk_surjective</span> <span class=\"n\">x</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">tidy</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">quotient.mk_surjective</span> <span class=\"n\">x</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">tidy</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 227983519,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614369469
    },
    {
        "content": "<p>It is surprisingly annoying, isn't it? If this is not my fault no problem, I will prove the relevant lemmas to improve the API. For example I am a little surprised that <code>ext</code> doesn't work for ideals...</p>",
        "id": 227984635,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614369858
    },
    {
        "content": "<p>It looks like there should certainly be some more api around this <code>map</code> function.</p>",
        "id": 227984690,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614369889
    },
    {
        "content": "<p>For example your <code>helper</code> should be an immediate consequence of <code>ideal.mem_image_of_mem_map_of_surjective</code></p>",
        "id": 227984798,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614369942
    },
    {
        "content": "<p>Oh yeah, I didn't know about that lemma.</p>",
        "id": 227985020,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614370042
    },
    {
        "content": "<p>Ah sure, because you wrote  <code>(I.map (f : R →+* S) : set S)</code>, but I mean, this should be true without going to <code>set S</code></p>",
        "id": 227985199,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614370102
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/6492\">#6492</a> if someone is interested</p>",
        "id": 228280321,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1614622816
    }
]
[
    {
        "content": "<p>Hello, I'm a beginner in Lean and I want to create my first contribution to mathlib with the Ostrowski theorem: <a href=\"https://en.wikipedia.org/wiki/Ostrowski%27s_theorem\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Ostrowski%27s_theorem\">https://en.wikipedia.org/wiki/Ostrowski%27s_theorem</a> — I read that I should try to inform the community first and discuss regarding new contributions, so here I am. I also use this post to ask about the topological equivalence between metrics, I looked through the API doc for some \"equiv\", \"metric equivalence\" but didn't found anything.</p>\n<p>So my guess is either it does not exist yet, it exists under a name that I do not know, it can be trivially created from the data.equiv module (?).</p>\n<p>Thank you in advance and thank you for this awesome thing!</p>",
        "id": 187391951,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580844912
    },
    {
        "content": "<p>Which equivalence relation are you talking about? The Wiki page doesn't state it in the header, and I don't want to read the proof.</p>",
        "id": 187392277,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1580845094
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> Topological equivalence (metrics induces the same topology), I can see topological_space_eq and uniform_space_eq but what about metric_space_eq ?</p>",
        "id": 187393181,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580845574
    },
    {
        "content": "<p>So you want to say that the identity is a homeomorphism.</p>",
        "id": 187393255,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1580845624
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> Right.</p>",
        "id": 187393399,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580845706
    },
    {
        "content": "<p>Then define a <code>homeomorph</code> between two metric spaces with <code>to_fun = id</code> and <code>inv_fun = id</code>.</p>",
        "id": 187393474,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1580845762
    },
    {
        "content": "<p>Note that we use typeclasses for norms so you'll need something like <code>def rat_with_norm (norm : has_norm rat) := rat</code>, or maybe a more general version.</p>",
        "id": 187393591,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1580845836
    },
    {
        "content": "<p>Alright, understood @ topological equivalence in metric spaces! That's super clear.</p>\n<p>But, I'm not sure why I would need to define <code>rat_with_norm</code> for now?</p>",
        "id": 187393999,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580846089
    },
    {
        "content": "<p>When you write <code>rat</code>, Lean tries to find the norm associated with this type. If you want to deal with two norms on the same space, you need to fool Lean into treating them as to different types.</p>",
        "id": 187394664,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1580846440
    },
    {
        "content": "<p>I don't think you need such wrapper.</p>",
        "id": 187394980,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580846638
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> Oh, makes sense.</p>\n<p>Also, I'm trying to make general definitions of <code>metric_space_eq</code> like this:</p>\n<div class=\"codehilite\"><pre><span></span>definition metric_space_eq {α : Type u} {β : Type u} [metric_space α] [metric_space β] :=\n    ({continuous_to_fun := id _, continuous_inv_fun := id _} : homeomorph α β)\n</pre></div>\n\n\n<p>And I have a lot of errors, but I guess I'm doing something super wrong, I defined some universe <code>u</code> before and imported everything I needed:</p>\n<div class=\"codehilite\"><pre><span></span>ostrowski.lean:19:5: error\ninvalid structure value { ... }, field &#39;to_fun&#39; was not provided\nostrowski.lean:19:5: error\ninvalid structure value { ... }, field &#39;inv_fun&#39; was not provided\nostrowski.lean:19:5: error\ninvalid structure value { ... }, field &#39;left_inv&#39; was not provided\nostrowski.lean:19:5: error\ninvalid structure value { ... }, field &#39;right_inv&#39; was not provided\n</pre></div>\n\n\n<p>When I use <code>to_fun</code> and <code>inv_fun</code>, it says that continuous ones are missing.</p>",
        "id": 187395036,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580846658
    },
    {
        "content": "<p>Also, Ryan, you should have a look at the <code>data/padics</code> in mathlib</p>",
        "id": 187395038,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580846660
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Yes I'm reusing most of the stuff that I can that is in there.</p>",
        "id": 187395049,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580846672
    },
    {
        "content": "<p>In particular I don't think it uses doesn't  <code>analysis/normed_space</code></p>",
        "id": 187395195,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580846765
    },
    {
        "content": "<p>You should reuse <code>equiv.refl</code> for many fields. Sorry, I have to go.</p>",
        "id": 187395307,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1580846870
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> It's alright, thank you, I'll try to figure it out!</p>",
        "id": 187395395,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580846915
    },
    {
        "content": "<p>Anyway the main lemma should state that <code>id</code> is continuous. Once you prove this, packing into <code>homeomorph</code> will be easy.</p>",
        "id": 187395414,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1580846942
    },
    {
        "content": "<p>I mean, <code>id</code> from <code>rat</code> with one norm to <code>rat</code> with standard norm.</p>",
        "id": 187395443,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1580846969
    },
    {
        "content": "<p>And the same for reversed <code>id</code>.</p>",
        "id": 187395446,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1580846977
    },
    {
        "content": "<p>Ryan, could you clarify what you want about \"equivalent metrics\"? I mean the math meaning, not Lean code.</p>",
        "id": 187395788,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580847201
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Topological equivalence</p>",
        "id": 187395814,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580847233
    },
    {
        "content": "<p>Of what?</p>",
        "id": 187395862,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580847247
    },
    {
        "content": "<p>Two metric structure on the same type?</p>",
        "id": 187395868,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580847254
    },
    {
        "content": "<p>Or different types?</p>",
        "id": 187395876,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580847258
    },
    {
        "content": "<p>Do you want to define a predicate or something containing data?</p>",
        "id": 187395904,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580847289
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Mathematically, what I want is something that <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> said: I want that id : (E, d_1) → (E, d_2) is an homemorphism, implying that (E, d_1) and (E, d_2) have the same opens (so topological equivalence of topological spaces?)</p>",
        "id": 187395957,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580847337
    },
    {
        "content": "<p>So you want a predicate with input E, d_1 and d_2, right?</p>",
        "id": 187396014,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580847364
    },
    {
        "content": "<p>Indeed, what I defined earlier takes two metric spaces which is not what I want in fact</p>",
        "id": 187396037,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580847390
    },
    {
        "content": "<p>Ostrowski can be formalised without any mention of topology. The guts of it is a purely algebraic statement. There is an independent fact that two norms on a field are equivalent (|.|_1=|.|_2^d) if and only if they induce the same topology, but this is somehow an independent thing.</p>",
        "id": 187396053,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1580847407
    },
    {
        "content": "<p>Yes, this is what I fond confusing.</p>",
        "id": 187396057,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580847411
    },
    {
        "content": "<p>What you ask for is then:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">metric_space_eqv</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">d&#39;</span> <span class=\"o\">:</span> <span class=\"n\">metric_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">to_uniform_space</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span> <span class=\"bp\">=</span> <span class=\"n\">d&#39;</span><span class=\"bp\">.</span><span class=\"n\">to_uniform_space</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span>\n</pre></div>",
        "id": 187396075,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580847426
    },
    {
        "content": "<p>I was answering Ryan, not Kevin.</p>",
        "id": 187396099,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580847442
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I agree with this, I just want to port the entire theorem, it's also a way for me to get better at Lean and understand more ; though I think I'll try to isolate the algebraic statement from the topological one.</p>",
        "id": 187396182,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580847487
    },
    {
        "content": "<p>What Kevin says is more specific. In general there is no nice algebraic criterion for topological equivalence between metrics (for instance asking that Id is bilipschitz is much stronger).</p>",
        "id": 187396218,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580847510
    },
    {
        "content": "<p>Yes, this is specific to fields, but Ostrowski is about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85556em;vertical-align:-0.16667em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span></span></span></span> so this topology talk is perhaps misleading.</p>",
        "id": 187396277,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1580847551
    },
    {
        "content": "<p>The work is checking that every norm is one of the ones we know already. There's a proof in Cassels' book on local fields which might be pleasant to formalise.</p>",
        "id": 187396309,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1580847586
    },
    {
        "content": "<p>Indeed, this is why I suggested reading <code>data/padics</code> instead of anything living under <code>topology</code> or <code>analysis</code>.</p>",
        "id": 187396327,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580847599
    },
    {
        "content": "<p>Cassels' proof involves taking a limit though, it might be quite an interesting project to do in Lean.</p>",
        "id": 187396455,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1580847685
    },
    {
        "content": "<p>That sounds super interesting, I'm going to get the proof and study it, if I have any further issue, I'll try to come back ; BTW, are limits available in Lean?</p>",
        "id": 187396610,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580847805
    },
    {
        "content": "<p>sure, I just thought it was interesting that things like limits and logs were involved when the statement feels quite algebraic.</p>",
        "id": 187396722,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1580847883
    },
    {
        "content": "<p>Sure, we have a lot about limits in mathlib.</p>",
        "id": 187396767,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580847942
    },
    {
        "content": "<p>Awesome :)</p>",
        "id": 187396775,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580847948
    },
    {
        "content": "<p>Search for <code>tendsto</code>.</p>",
        "id": 187396781,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580847955
    },
    {
        "content": "<p>You can use the search at <a href=\"https://leanprover-community.github.io/mathlib_docs/\" target=\"_blank\" title=\"https://leanprover-community.github.io/mathlib_docs/\">https://leanprover-community.github.io/mathlib_docs/</a></p>",
        "id": 187396864,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580848009
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Yes, it has been super useful so far</p>",
        "id": 187397005,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580848130
    },
    {
        "content": "<p>[I just clicked on the link you posted and it looks to me like it's the same proof as in Cassels]</p>",
        "id": 187397142,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1580848226
    },
    {
        "content": "<p>I come back with plenty of questions:<br>\n— let's say I want to prove that a finite product of M non-negative rationals such that the result is &lt; 1 contains at least a term such that it is &lt; 1, should I use the list type for this?<br>\nI have a lemma like this:</p>\n<div class=\"codehilite\"><pre><span></span>lemma product_of_nonnegative_rat_le_one_contains_at_least_one_le_one_factor (L : list ℚ)  (H: ∀ a : ℚ, a ∈ L → a ≥ 0) (J: list.prod L ≤ 1)\n    : ∃ a : ℚ, a ∈ L ∧ a ≤ 1 := sorry\n</pre></div>\n\n\n<p>bonus: should I design it so that it rather show the existence of j such that nth L j ≤ 1 (that's better I suppose).</p>\n<p>— next is, I have an n0 ≥ 2, I want to apply the absolute value on its prime factor decomposition, so naively, I do <code>have afactors := list.map abv (nat.factors n0)</code> and I get a list of Q, but I have this hypothesis on n0 which is abv n0 &lt;= 1 and I want to transmit it to <code>list.prod afactors</code>, so I guess I have to use the fact that <code>list.prod (nat.factors n0) = n0</code> to get<code>list.prod (list.map abv nat.factors n0) = abv n0</code>.<br>\nMaybe I don't know enough about the mathlib to perform this easily.</p>\n<p>Thank you!</p>",
        "id": 187411659,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580859208
    },
    {
        "content": "<blockquote>\n<p>Hello, I'm a beginner in Lean and I want to create my first contribution to mathlib with the Ostrowski theorem: <a href=\"https://en.wikipedia.org/wiki/Ostrowski%27s_theorem\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Ostrowski%27s_theorem\">https://en.wikipedia.org/wiki/Ostrowski%27s_theorem</a> — I read that I should try to inform the community first and discuss regarding new contributions, so here I am. I also use this post to ask about the topological equivalence between metrics, I looked through the API doc for some \"equiv\", \"metric equivalence\" but didn't found anything.</p>\n<p>So my guess is either it does not exist yet, it exists under a name that I do not know, it can be trivially created from the data.equiv module (?).</p>\n</blockquote>\n<p>I took a crack at Ostrowski at one point (see the attached file). Its a complete work in progress and it needs a lot of cleanup, but some of the key steps were there. I was hindered a bit by the fact that I didn't really develop the theory of equivalences, or expressing different numbers in different bases before I began, and I didn't really have a mathematical reference in mind before I started. The most succinct math proof I have seen is due to Artin and combines a lot of the steps in quite a neat way, so I'd probably try and reformat it to follow that more if I did it again or restarted.  You are more than welcome to take bits of this or completely ignore it of course ;): <a href=\"/user_uploads/3121/gS3jskD-aTYwB52dE5AA874V/ostrowski.lean\" target=\"_blank\" title=\"ostrowski.lean\">ostrowski.lean</a></p>",
        "id": 187414117,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1580861834
    },
    {
        "content": "<p>I think people usually use finset.prod,  which has the best interface</p>",
        "id": 187430920,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1580886898
    },
    {
        "content": "<p>The lemma that you need about applying a group hom to a finite product being equal to the product of the factors will surely be there for finset products</p>",
        "id": 187431001,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1580886977
    },
    {
        "content": "<p>Note that the finset isn't the set of factors, it is an auxiliary finite set equipped with a map to the factors</p>",
        "id": 187431030,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1580887045
    },
    {
        "content": "<p>In other words... one option is to use a family of elements, indexed by some index type <code>\\iota</code>. This is how the <code>finset.prod</code> stuff works.</p>",
        "id": 187431100,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1580887148
    },
    {
        "content": "<p>Using lists is in principle a good idea. It's just not the way it's been done in mathlib. Not sure if that is silly on our side, though...</p>",
        "id": 187431109,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1580887178
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>Hello, I'm a beginner in Lean and I want to create my first contribution to mathlib with the Ostrowski theorem: <a href=\"https://en.wikipedia.org/wiki/Ostrowski%27s_theorem\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Ostrowski%27s_theorem\">https://en.wikipedia.org/wiki/Ostrowski%27s_theorem</a> — I read that I should try to inform the community first and discuss regarding new contributions, so here I am. I also use this post to ask about the topological equivalence between metrics, I looked through the API doc for some \"equiv\", \"metric equivalence\" but didn't found anything.</p>\n<p>So my guess is either it does not exist yet, it exists under a name that I do not know, it can be trivially created from the data.equiv module (?).</p>\n</blockquote>\n<p>I took a crack at Ostrowski at one point (see the attached file). Its a complete work in progress and it needs a lot of cleanup, but some of the key steps were there. I was hindered a bit by the fact that I didn't really develop the theory of equivalences, or expressing different numbers in different bases before I began, and I didn't really have a mathematical reference in mind before I started. The most succinct math proof I have seen is due to Artin and combines a lot of the steps in quite a neat way, so I'd probably try and reformat it to follow that more if I did it again or restarted.  You are more than welcome to take bits of this or completely ignore it of course ;): <a href=\"/user_uploads/3121/gS3jskD-aTYwB52dE5AA874V/ostrowski.lean\" target=\"_blank\" title=\"ostrowski.lean\">ostrowski.lean</a></p>\n</blockquote>\n<p>That's super helpful, I want to read a lot of Lean to understand more :)</p>",
        "id": 187448197,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580905204
    },
    {
        "content": "<blockquote>\n<p>In other words... one option is to use a family of elements, indexed by some index type <code>\\iota</code>. This is how the <code>finset.prod</code> stuff works.</p>\n</blockquote>\n<p>I understand ; but is<code>nat.factors</code> compatible with <code>finset</code>?</p>",
        "id": 187448332,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580905342
    },
    {
        "content": "<p>Maybe not as compatible as we would like <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 187448398,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1580905435
    },
    {
        "content": "<p>This might be an argument to go with lists</p>",
        "id": 187448453,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1580905446
    },
    {
        "content": "<p>Here's a question: can you <em>state</em> Ostrowski in Lean? Or is that impossible with current state of the library?</p>",
        "id": 187448476,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1580905492
    },
    {
        "content": "<p>(And then I mean a relatively clean statement. I'm sure we can get some unreadable thing that is some form of Ostrowski.)</p>",
        "id": 187448508,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1580905534
    },
    {
        "content": "<p>State as in: says that if some absolute value over Q is not the trivial absolute value (in terms of pointwise equality), then (Q, |⋅|) is topologically equivalent as topological spaces to (Q, |⋅|_p) or (Q, |⋅|_inf) for some p prime ; right?</p>\n<p>Or in terms of proof?</p>",
        "id": 187448825,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580905814
    },
    {
        "content": "<p>No, I mean</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">Ostrowski</span> <span class=\"o\">:</span> <span class=\"bp\">_</span><span class=\"n\">fill_this_in_</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n</pre></div>",
        "id": 187448870,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1580905852
    },
    {
        "content": "<p>So, you can leave the <code>sorry</code> there, for now.</p>",
        "id": 187448891,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1580905861
    },
    {
        "content": "<blockquote>\n<p>No, I mean</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">Ostrowski</span> <span class=\"o\">:</span> <span class=\"bp\">_</span><span class=\"n\">fill_this_in_</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n</pre></div>\n\n\n</blockquote>\n<p>This is what I understood, don't worry ; </p>\n<p><code>(abv : \\Q \\to \\Q) [is_absolute_value abv] (H\\_1: \\not (abv \\eq trivial_abs)) : (\\exists p : nat.primes, …) \\or (…))</code></p>\n<p>Where <code>…</code> is something about the topological equivalence regarding <code>padic.padic_norm</code> and standard absolute value which I think is possible based on what <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> and <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> told me.</p>\n<p>I might be wrong though and this could be wishful thinking.</p>",
        "id": 187449132,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580906114
    },
    {
        "content": "<p>That's why I'm asking <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span> I think it would be good to have a version that Lean is happy with.</p>",
        "id": 187449877,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1580906763
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"262143\">@Ryan Lahfa</span> Is <code>is_absolute_value</code> something that Lean know about? Or is this something that still has to be written?</p>",
        "id": 187449927,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1580906825
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/data/real/cau_seq.html#is_absolute_value\" target=\"_blank\" title=\"https://leanprover-community.github.io/mathlib_docs/data/real/cau_seq.html#is_absolute_value\">https://leanprover-community.github.io/mathlib_docs/data/real/cau_seq.html#is_absolute_value</a></p>",
        "id": 187450566,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580907460
    },
    {
        "content": "<p>thanks</p>",
        "id": 187450656,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1580907514
    },
    {
        "content": "<p>It's nice to see you've been able to use padics in mathlib without knowing this file. It proves the API is good.</p>",
        "id": 187450695,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580907547
    },
    {
        "content": "<p>BTW, I'd prefer to see p-adics defined as sequences of digits, maybe using some generic algebraic construction. This way Lean will be able to actually do finite precision computations in p-adics.</p>",
        "id": 187451264,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1580908052
    },
    {
        "content": "<p>Then we can prove that they form a <code>complete_space</code> w.r.t. the p-adic norm.</p>",
        "id": 187451823,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1580908510
    },
    {
        "content": "<p>All of this needs a ring (probably with some additional properties), a prime ideal, and something equivalent to the quotient (used for computations).</p>",
        "id": 187451951,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1580908663
    },
    {
        "content": "<p>The p-adic numbers are an example of a nonarchimedean local field and I'd prefer to see a general theory of these set up.</p>",
        "id": 187486378,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1580931058
    },
    {
        "content": "<p>I tried to look for equality of functions but I'm not sure I found something in mathlib, I got overwhelmed by the amount of equiv modules ; I have the feeling that <code>abv \\neq trivial_abv</code> is stronger than saying that <code>\\forall x \\in F, abv x \\neq trivial_abv x</code>, but is there a way to not write this?</p>",
        "id": 187489464,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580932980
    },
    {
        "content": "<p>It's not stronger.</p>",
        "id": 187490311,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580933595
    },
    {
        "content": "<p>Yeah one problem my ostrowski formulation I had was my absolute values mapped from $\\Q \\to \\Q$ instead of $\\Q \\to \\R$, I chose this as the usual absolute value function and p-adic valuation for rationals defaults to maps like  this iirc. But really you want the stronger statement that any $\\Q \\to \\R$ is one of $|\\cdot |$ or $|\\cdot|_p$.</p>",
        "id": 187490805,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1580933977
    },
    {
        "content": "<p>So my notion of equivalence was a weird hack where you extend to $\\R$ then ask that one be a power of the other.</p>",
        "id": 187490884,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1580934028
    },
    {
        "content": "<blockquote>\n<p>It's not stronger.</p>\n</blockquote>\n<p>So <code>abv = trivial_abv</code> is exactly <code>\\forall x : some domain, abv x = trivial_abv x</code> (?)</p>",
        "id": 187491520,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580934503
    },
    {
        "content": "<blockquote>\n<p>Yeah one problem my ostrowski formulation I had was my absolute values mapped from $\\Q \\to \\Q$ instead of $\\Q \\to \\R$, I chose this as the usual absolute value function and p-adic valuation for rationals defaults to maps like  this iirc. But really you want the stronger statement that any $\\Q \\to \\R$ is one of $|\\cdot |$ or $|\\cdot|_p$.</p>\n</blockquote>\n<p>Exact, I've read and thanks to your code, I moved faster than I expected, I learnt a lot about how to do some simple stuff (product of terms, etc.)</p>",
        "id": 187491602,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580934580
    },
    {
        "content": "<p>Yes the principle that functions are equal when their values are is called function extensionality. A tactic to use this is called funext. If you apply this to a goal <code>f=g</code>  you'll get a value <code> x </code> and have to prove <code> f x =g X</code></p>",
        "id": 187492685,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1580935301
    },
    {
        "content": "<p>A more complete answer is: for mathematicians, the equivalence is trivial. Because Lean is also used for software verification, this triviality is not an base axiom, but you have it anyway.</p>",
        "id": 187492860,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580935384
    },
    {
        "content": "<p>It's just something that computer scientists make a fuss about for some reason ;-)</p>",
        "id": 187493667,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1580935873
    },
    {
        "content": "<p>I agree with the facts it was trivial for mathematicians, and for Lean, it requires some base axiom, my underlying question was: is this axiom there? I have my answer now :)</p>",
        "id": 187494358,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580936345
    },
    {
        "content": "<p>Also forget what Alex wrote about <code>funext</code>, this is a historical accident. This tactic is subsumed by the more general <code>ext</code> tactic.</p>",
        "id": 187494483,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580936412
    },
    {
        "content": "<p>The only time one needs to use funext is in a conv block right?</p>",
        "id": 187497059,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1580938222
    },
    {
        "content": "<p>Oh maybe yes. Maybe <code>ext</code> has no <code>conv</code> version.</p>",
        "id": 187497088,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580938247
    },
    {
        "content": "<p>Here's new questions!</p>\n<p>I'm trying to figure out how to instantiate some fields and stuff and I often run into \"failed to synthesize type class instance for […]\", for example, if I try to do <code>#check \\Q_[3]</code> it'll fail, I guess I have to prove that 3 is prime but I'm unsure how to inject this information? It seems like <code>apply_instance</code> is what I want but once I'm not sure how to use it.</p>",
        "id": 187503956,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580943457
    },
    {
        "content": "<p>Also, what's the difference between writing <code>\\exists p : nat.primes, …</code> and <code>\\exists (p), [hp: nat.prime p], …</code> ?</p>",
        "id": 187504196,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580943628
    },
    {
        "content": "<p>In the first case <code>p</code> is a structure with two fields: <code>p.val</code> is a number and <code>p.property</code> says that <code>p.val</code> is prime. In the latter case <code>p</code> is a number and <code>hp</code> says that it is prime.</p>",
        "id": 187504406,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1580943833
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> Okay, makes sense, thank you!</p>",
        "id": 187504647,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580943994
    },
    {
        "content": "<p>New question, so if I have some absolute value |⋅| and I want to induce some metric_space using it over \\Q ; like <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> said earlier, I have to define some <code>rat_with_abv</code> to create a new type and then I can define as an instance of metric_space for example, right? I don't think I can avoid it ; but curious question, is there a technical limitation for why we could not have:</p>\n<div class=\"codehilite\"><pre><span></span>def field_with_abv {a: Type*} (abv: a \\to a) [normed_field a] [is_absolute_value abv]: normed_field a := [build generally the normed_field using abv over a]\n</pre></div>\n\n\n<p>I'm not exactly sure that a must be a discrete_field, but whatever it has to be.</p>\n<p>And this way we could swap absolute values (or norm) for all normed fields I guess (?).</p>",
        "id": 187505412,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580944664
    },
    {
        "content": "<p>I suppose I could use the Cauchy completion by showing that from all absolute values, we can derive some norms?</p>",
        "id": 187505520,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580944753
    },
    {
        "content": "<blockquote>\n<p>It's just something that computer scientists make a fuss about for some reason ;-)</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> How many different ways are there to sort a list?</p>",
        "id": 187520513,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1580965515
    },
    {
        "content": "<p>Just the one</p>",
        "id": 187524440,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1580972083
    },
    {
        "content": "<p>It's called \"WLOG the elements are in increasing order\"</p>",
        "id": 187524525,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1580972192
    },
    {
        "content": "<p>unless of course it's not WLOG, in which case sorting it would be non-canonical.</p>",
        "id": 187524540,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1580972269
    },
    {
        "content": "<p>Ryan, you don't have to create an instance if you don't want to use it through type class inference. This instance stuff is all about Lean figuring out what you don't write. You always keep the possibility of not asking Lean but telling it.</p>",
        "id": 187527888,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580976659
    },
    {
        "content": "<p>Maybe this discussion is too abstract. Let me write some code:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">metric_space</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">theory</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">is_absolute_value</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">metric_space_of_real_abv</span> <span class=\"o\">(</span><span class=\"n\">abv</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_absolute_value</span> <span class=\"n\">abv</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">metric_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">dist</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">abv</span> <span class=\"err\">$</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">dist_self</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">show</span> <span class=\"n\">abv</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">abv_zero</span> <span class=\"n\">abv</span><span class=\"o\">],</span>\n  <span class=\"n\">eq_of_dist_eq_zero</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">eq_of_sub_eq_zero</span> <span class=\"err\">$</span> <span class=\"o\">(</span><span class=\"n\">abv_eq_zero</span> <span class=\"n\">abv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">dist_comm</span> <span class=\"o\">:=</span> <span class=\"n\">abv_sub</span> <span class=\"n\">abv</span><span class=\"o\">,</span>\n  <span class=\"n\">dist_triangle</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"k\">begin</span>\n    <span class=\"n\">change</span> <span class=\"n\">abv</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">-</span><span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">abv</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">-</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">abv</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"bp\">-</span><span class=\"n\">z</span><span class=\"o\">),</span>\n    <span class=\"n\">rw</span> <span class=\"k\">show</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">-</span> <span class=\"n\">z</span><span class=\"o\">),</span> <span class=\"k\">by</span> <span class=\"n\">abel</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">abv_add</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span><span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">topology_of_real_abv</span> <span class=\"o\">(</span><span class=\"n\">abv</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_absolute_value</span> <span class=\"n\">abv</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">metric_space_of_real_abv</span> <span class=\"n\">abv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_uniform_space</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span>\n\n<span class=\"n\">def</span> <span class=\"n\">abv_top_eqv</span> <span class=\"o\">(</span><span class=\"n\">abv₁</span> <span class=\"n\">abv₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_absolute_value</span> <span class=\"n\">abv₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_absolute_value</span> <span class=\"n\">abv₂</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">topology_of_real_abv</span> <span class=\"n\">abv₁</span> <span class=\"bp\">=</span> <span class=\"n\">topology_of_real_abv</span> <span class=\"n\">abv₂</span>\n</pre></div>",
        "id": 187529292,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580978359
    },
    {
        "content": "<p>Is this what you want? This is still going toward a very weak version of the conclusion of Ostrowski.</p>",
        "id": 187529309,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580978383
    },
    {
        "content": "<p>It makes a lot of sense now, regarding the instance. Thank you!</p>",
        "id": 187546822,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580995266
    },
    {
        "content": "<blockquote>\n<p>Is this what you want? This is still going toward a very weak version of the conclusion of Ostrowski.</p>\n</blockquote>\n<p>What's the strong version of Ostrowski? IMHO, I was under the assumption it was a statement of the form: for all absolute values over Q, either it is equivalent to the real absolute value, or there is some prime p such that the absolute value is equivalent to the padic one.</p>\n<p>It appears to me that I need the <code>metric_space_of_real_abv</code> to have:</p>\n<div class=\"codehilite\"><pre><span></span>theorem rat_abs_val_p_adic_or_real (abv: ℚ → ℚ)\n    [habv: is_absolute_value abv]\n    (hnontriv: abv ≠ trivial_abs):\n    (metric_space_eq\n        (metric_rat_with_abv abv)\n        (rat.metric_space))\n    ∨\n    (∃ (p) [hp: nat.prime p],\n        (metric_space_eq\n            (metric_rat_with_abv abv)\n            (padic.metric_space p)))\n</pre></div>\n\n\n<p>Something like this.</p>",
        "id": 187546921,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580995367
    },
    {
        "content": "<p>But sure, that might be better to just prove that there is directly some relation between the absolute values themselves.</p>",
        "id": 187546948,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580995409
    },
    {
        "content": "<p>I think the stronger form would be saying that the two absolute values differ by a power</p>",
        "id": 187549864,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1580997729
    },
    {
        "content": "<blockquote>\n<p>I think the stronger form would be saying that the two absolute values differ by a power</p>\n</blockquote>\n<p>Ah ; but I was going to derive the weak form (same topology) by the strong form (absolute values differ by a power).</p>\n<p>So yes I agree that it might be better to expose the stronger form as a theorem and derive the weak form through a lemma.</p>",
        "id": 187550067,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1580997850
    },
    {
        "content": "<p>Also, it's good to see that you have a Lean statement now. Does it already typecheck?</p>",
        "id": 187550371,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1580998081
    },
    {
        "content": "<p>Could you post a self-contained piece of code that we can copy-paste (including the necessary <code>import</code> and <code>variable</code> statements etc...)</p>",
        "id": 187550451,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1580998124
    },
    {
        "content": "<blockquote>\n<p>Could you post a self-contained piece of code that we can copy-paste (including the necessary <code>import</code> and <code>variable</code> statements etc...)</p>\n</blockquote>\n<p>For now, it's still somewhat a scratch file with a lot of code / sorry, but next time I post something, I'll try to give a minimal example, sure.</p>",
        "id": 187568814,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581009822
    },
    {
        "content": "<blockquote>\n<p>Also, it's good to see that you have a Lean statement now. Does it already typecheck?</p>\n</blockquote>\n<p>I did a lot of changes and it does not typecheck anymore :D</p>",
        "id": 187568873,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581009847
    },
    {
        "content": "<p>New question, when I have, let's say I have:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">prime</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">cau_seq</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">apply</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">apply_fun</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"n\">real</span>\n<span class=\"kn\">open</span> <span class=\"n\">list</span> <span class=\"n\">option</span>\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"c1\">-- absolute values are monoid homemorphisms.</span>\n<span class=\"n\">def</span> <span class=\"n\">hom_of_abv</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">hlifield</span><span class=\"o\">:</span> <span class=\"n\">linear_ordered_field</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">abv</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">habv</span><span class=\"o\">:</span> <span class=\"n\">is_absolute_value</span> <span class=\"n\">abv</span><span class=\"o\">]:</span> <span class=\"n\">monoid_hom</span> <span class=\"n\">α</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n    <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">abv</span><span class=\"o\">,</span>\n    <span class=\"n\">map_one&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">is_absolute_value</span><span class=\"bp\">.</span><span class=\"n\">abv_one</span> <span class=\"n\">abv</span><span class=\"o\">,</span>\n    <span class=\"n\">map_mul&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">is_absolute_value</span><span class=\"bp\">.</span><span class=\"n\">abv_mul</span> <span class=\"n\">abv</span>\n<span class=\"o\">}</span>\n\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_absolute_value</span> <span class=\"n\">f</span><span class=\"o\">]:</span>\n    <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">hom_of_abv</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">factors</span> <span class=\"n\">z</span><span class=\"o\">)))</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">factors</span> <span class=\"n\">z</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">exact</span> <span class=\"n\">prod_hom</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span><span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">factors</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hom_of_abv</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_absolute_value</span> <span class=\"n\">f</span><span class=\"o\">]:</span> <span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">factors</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"err\">↑</span><span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"n\">factors</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n    <span class=\"k\">begin</span>\n    <span class=\"n\">exact</span> <span class=\"n\">prod_hom</span> <span class=\"o\">(</span><span class=\"n\">factors</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span><span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">))</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>The second example is failing because f is not an unbundled monoid homomorphism (under the assumption that there is something which implements is_monoid_hom for f \\circ g), but while reading the documentation, I see that those are deprecated and being slowed removed from mathlib.</p>\n<p>Does that mean I have to use bundled monoid homomorphism?</p>\n<p>In this example, I can trivially have a <code>hom_of_abv</code> which gives me a <code>monoid_hom Q Q</code> (or whatever) and then, I can use prod_hom on it and have a close result except that it has this upper arrow which I suppose says this is a bundled homomorphism.</p>\n<p>But, can I lift those to rewrite the unbundled version of the homomorphism?</p>\n<p>Better, I'd like to prod_hom with (f \\circ (coe : N → Q)) but unsure how that's feasible w/o having something which takes (f, g), bundle the composition. How does that scale to f_1 \\circ … \\circ f_n ? It does not sound general enough…</p>",
        "id": 187570599,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581010952
    },
    {
        "content": "<p>Tip: if you write</p>\n<div class=\"codehilite\"><pre><span></span>```lean\ncode here\n```\n</pre></div>\n\n\n<p>then you even get syntax highlighting</p>",
        "id": 187572034,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581011889
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> — now I add regarding my last question that I know I could merge the map map using list.map_map,</p>\n<p>but then, I'm stuck with this coe_fn in front of all my abv functions ; I'm not super strong with the coercion thing, I understand most of it, but I'm not sure how I can lift it in the context? I tried: <code>simp</code>, <code>push_cast</code>, <code>norm_cast</code> and all of them failed.</p>",
        "id": 187572567,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581012274
    },
    {
        "content": "<p>If they fail, that might also be because of missing simp-lemmas in the library...</p>",
        "id": 187572748,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581012440
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"262143\">@Ryan Lahfa</span> To fix the second example, you should add an <code>instance</code> that shows that <code>is_absolute_value f</code> implies <code>is_monoid_hom f</code>.</p>",
        "id": 187572863,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581012525
    },
    {
        "content": "<p>Apparently that one is missing</p>",
        "id": 187572874,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581012533
    },
    {
        "content": "<blockquote>\n<p>If they fail, that might also be because of missing simp-lemmas in the library...</p>\n</blockquote>\n<p>AFAIK, according to this, should not this be enough: <a href=\"https://leanprover-community.github.io/mathlib_docs/algebra/group/hom.html#monoid_hom.has_coe_to_fun\" target=\"_blank\" title=\"https://leanprover-community.github.io/mathlib_docs/algebra/group/hom.html#monoid_hom.has_coe_to_fun\">https://leanprover-community.github.io/mathlib_docs/algebra/group/hom.html#monoid_hom.has_coe_to_fun</a> ?</p>",
        "id": 187572906,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581012558
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"262143\">Ryan Lahfa</span> To fix the second example, you should add an <code>instance</code> that shows that <code>is_absolute_value f</code> implies <code>is_monoid_hom f</code>.</p>\n</blockquote>\n<p>Sure, I could do this, but the docs say it is deprecated to use <code>is_monoid_hom f</code> so I'm not sure what's the situation, I prefer to avoid introducing stuff that will have to be rewritten :P</p>",
        "id": 187572934,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581012597
    },
    {
        "content": "<p>Well... that means that absolute values should be refactored, and replaced with bundled versions...</p>",
        "id": 187573706,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581013149
    },
    {
        "content": "<p>That's a lot of work for a first PR, so I wouldn't advice it</p>",
        "id": 187573751,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581013183
    },
    {
        "content": "<p>unbundled homs are deprecated, but that really only means that we are starting to use them in new stuff. Because bundled homs are not entirely supported yet, we can't just delete the unbundled homs, and some proofs will require both</p>",
        "id": 187574442,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581013567
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Ryan is concerned about adding new instances of <code>is_monoid_hom</code> to mathlib in a PR on Ostrowski.</p>",
        "id": 187574954,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581013901
    },
    {
        "content": "<p>I think adding such instances is indeed \"discouraged\". But we might also make some exceptions.</p>",
        "id": 187575033,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581013928
    },
    {
        "content": "<p>That seems fine to me, especially if the bundled version is included as well</p>",
        "id": 187575043,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581013939
    },
    {
        "content": "<p>How would that look like?</p>",
        "id": 187575094,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581013973
    },
    {
        "content": "<p>We have unbundled absolute values. Those are monoid homs, but Lean doesn't know this.</p>",
        "id": 187575139,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581014000
    },
    {
        "content": "<p>I don't expect such a PR to introduce bundled absolute values.</p>",
        "id": 187575166,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581014021
    },
    {
        "content": "<p>Actually, it makes a lot of sense to have bundled absolute values for ostrowski, since it is about characterizing this space</p>",
        "id": 187575298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581014098
    },
    {
        "content": "<p>you can define an equivalence relation on the type <code>absolute_value</code> which is \"differs by a power\", and then define the real and p-adic and trivial absolute values, and then it is easy to state the theorem</p>",
        "id": 187575418,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581014189
    },
    {
        "content": "<p>That makes sense. (And then later derive an unbundled statement? In case someone actually wants to apply Ostrowski at some point? Although by that time we'll hopefully want and have a version for number fields.)</p>",
        "id": 187576333,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581014819
    },
    {
        "content": "<p>Alright, it makes sense, so I should wrap all abv into bundled hom and work with them, this I can do.</p>\n<p>At some point, statement about bundled hom abv can be made into statement about unbundled abv; this I don't see how to do, but I can believe that someone will figure out, right?</p>",
        "id": 187576469,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581014895
    },
    {
        "content": "<p>Sure, that last step is not so hard: no maths involved, just shuffling some data around in Lean.</p>",
        "id": 187576566,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581014978
    },
    {
        "content": "<blockquote>\n<p>you can define an equivalence relation on the type <code>absolute_value</code> which is \"differs by a power\", and then define the real and p-adic and trivial absolute values, and then it is easy to state the theorem</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> already done it in its version of Ostrowski and I'm reusing this. The only thing is that we have not defined this equiv relation on the <code>monoid_hom Q R</code> which implements <code>is_absolute_value</code> but rather on <code>Q → R</code> which implements <code>is_absolute_value</code>, right?</p>",
        "id": 187576578,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581014984
    },
    {
        "content": "<p>For an idea of how to define <code>absolute_value</code>, see: <a href=\"https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/src/valuation/basic.lean#L58\" target=\"_blank\" title=\"https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/src/valuation/basic.lean#L58\">https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/src/valuation/basic.lean#L58</a></p>",
        "id": 187576741,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581015077
    },
    {
        "content": "<p>But do we agree this require a change from:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">is_absolute_value</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">discrete_linear_ordered_field</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">abv_nonneg</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">abv_eq_zero</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">},</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">abv_add</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">abv_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>to</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">is_absolute_value</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">discrete_linear_ordered_field</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">monoid_hom</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">abv_nonneg</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">abv_eq_zero</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">},</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">abv_add</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>I guess <code>abv_mul</code> is now trivial due to <code>monoid_hom.map_mul'</code>, so not required to implement it. It also looks better IMHO, because it makes sense to say that an absolute value is a monoid homomorphism which implements additional stuff.<br>\nAlso, <code>abv_one</code> becomes trivial too.</p>",
        "id": 187576791,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581015120
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Shouldn't we change the <code>is_absolute_value</code> definition coming from Cauchy completion?</p>",
        "id": 187576913,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581015196
    },
    {
        "content": "<p>But that also requires changes in the padic.padic_norm definition and the real absolute value definition (right?)</p>",
        "id": 187576997,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581015245
    },
    {
        "content": "<p>I understand your confusion. But you should ignore all the existing stuff (for now).</p>",
        "id": 187577622,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581015674
    },
    {
        "content": "<p>In the end, we'll have both bundled and unbundled versions. And Mario says that's ok.</p>",
        "id": 187577650,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581015691
    },
    {
        "content": "<p>Don't worry about refactoring things.</p>",
        "id": 187577663,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581015703
    },
    {
        "content": "<p>Just introduce a new thing <code>absolute_value</code> that extends <code>mul_hom</code>, like in the example I linked to.</p>",
        "id": 187577721,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581015730
    },
    {
        "content": "<p>After that, define some coercions and prove some trivial simp-lemmas, like we did for valuations.</p>",
        "id": 187577752,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581015757
    },
    {
        "content": "<p>After that, define some examples, like <code>real.abs_val</code> and <code>padic.abs_val</code>, and here you will reuse the unbundled versions. Defining these examples is not hard.</p>",
        "id": 187577809,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581015808
    },
    {
        "content": "<p>Also, define an equivalence relation.</p>",
        "id": 187577820,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581015818
    },
    {
        "content": "<p>And then you are good to go to get a nice statement for Ostrowski.</p>",
        "id": 187577837,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581015835
    },
    {
        "content": "<p>Alright, that works for me :)</p>",
        "id": 187578237,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581016084
    },
    {
        "content": "<p>We don't need to change <code>is_absolute_value</code> itself, but <code>absolute_value := {abv // is_absolute_value abv}</code> is easy enough to define</p>",
        "id": 187580028,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581017280
    },
    {
        "content": "<p>I would prefer that the monoid hom thing be proven rather than assumed (it's not immediate from the definition that <code>f 1 = 1</code>, for example, and we wouldn't want to require that to be proven too)</p>",
        "id": 187580149,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581017344
    },
    {
        "content": "<p>The usage of <code>is_absolute_value</code> in the definition of <code>real</code> is somewhat foundational, so it's okay if it's not completely in line with conventions</p>",
        "id": 187580308,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581017438
    },
    {
        "content": "<blockquote>\n<p>I would prefer that the monoid hom thing be proven rather than assumed (it's not immediate from the definition that <code>f 1 = 1</code>, for example, and we wouldn't want to require that to be proven too)</p>\n</blockquote>\n<p>Do you mean to prove that absolute_value are monoid hom by proving that abv 1 = 1?</p>\n<p>Under which assumptions should we define absolute_value? Like for real, discrete linear ordered fields?</p>",
        "id": 187580693,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581017707
    },
    {
        "content": "<p>The reason <code>is_absolute_value</code> in <code>cau_seq</code> requires a <code>discrete_linear_ordered_field</code> is because I needed it on Q and R</p>",
        "id": 187581256,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581018085
    },
    {
        "content": "<p>The statement only needs an ordered ring afaik</p>",
        "id": 187581298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581018116
    },
    {
        "content": "<p>But I think Ostrowski works in the context of a real-valued absolute value</p>",
        "id": 187581423,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581018185
    },
    {
        "content": "<blockquote>\n<p>But I think Ostrowski works in the context of a real-valued absolute value</p>\n</blockquote>\n<p>We can always specialize it afterwards, but I guess we want a general <code>is_absolute_value</code> right?</p>",
        "id": 187585793,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581021157
    },
    {
        "content": "<p>New questions:<br>\nI'm trying to do some real power algebra, and I have a real in my exponent, so I'm trying to find some theorems to manipulate them, I expected most of the theorems to be there or in group power:</p>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/algebra/field_power.html\" target=\"_blank\" title=\"https://leanprover-community.github.io/mathlib_docs/algebra/field_power.html\">https://leanprover-community.github.io/mathlib_docs/algebra/field_power.html</a></p>\n<p>But I'm lacking something akin to <code>(a ^ n) ^ m = a ^ (n*m)</code> for <code>m n : R</code>, which would be some <code>fpow_mul</code> I guess.<br>\nAt the same time, I guess that real pow are more analysis than true algebra, making sense for why those theorems would not be in field power.</p>\n<p>I looked in analysis, found nothing. I tried the custom search but it is not super reliable. I guess I could do some PR or something to improve the search and replacing it by some full text search using JavaScript. This is a parallel idea but it would be awesome to have a Hoogle-like search for Lean, just give it some types and it'll give you what you want, this could be a project I would be super proficient in I think.</p>",
        "id": 187586049,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581021348
    },
    {
        "content": "<p><code>fpow_mul</code> would be for powers by integers</p>",
        "id": 187586202,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581021441
    },
    {
        "content": "<p>There is <code>rpow.*</code> I think</p>",
        "id": 187586219,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581021460
    },
    {
        "content": "<p>Or was it <code>real_pow.*</code>?</p>",
        "id": 187586227,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581021466
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I searched for <code>rpow</code> and <code>real_pow</code> and found nothing :/</p>",
        "id": 187586796,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581021886
    },
    {
        "content": "<p>real.rpow</p>",
        "id": 187587136,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581022084
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/analysis/complex/exponential.html#real.rpow\" target=\"_blank\" title=\"https://leanprover-community.github.io/mathlib_docs/analysis/complex/exponential.html#real.rpow\">https://leanprover-community.github.io/mathlib_docs/analysis/complex/exponential.html#real.rpow</a> Indeed… I was supposing that complex had nothing to do with what I wanted.</p>",
        "id": 187587180,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581022122
    },
    {
        "content": "<p>I found it by running <code>mk_all.sh</code> and then inside <code>all.lean</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">rpo</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">suggest</span><span class=\"o\">,</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 187587235,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581022157
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Thank you for the tip!</p>",
        "id": 187587921,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581022650
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/pcGeOZ1SrIVGBHZpoZyvaV1W/ostrowski-ext.lean\" target=\"_blank\" title=\"ostrowski-ext.lean\">ostrowski-ext.lean</a> <br>\nI have a more difficult question, if you load the file I provide here.<br>\nAnd go line 312, for some reason, I cannot close the goal \"prime p\" by using a hypothesis which is \"prime p\", I guess it has to do with implicit contexts, but unsure how to debug, nor solve this. I guess I'm too newbie in coe stuff.</p>",
        "id": 187588085,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581022756
    },
    {
        "content": "<p>Hmm, I currently don't have Lean available. what happens if you <code>convert this</code>?</p>",
        "id": 187590099,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581024072
    },
    {
        "content": "<p>My guess: <code>_root_.prime</code> and <code>nat.prime</code> are fighting over this proof.</p>",
        "id": 187591394,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581024982
    },
    {
        "content": "<blockquote>\n<p>Hmm, I currently don't have Lean available. what happens if you <code>convert this</code>?</p>\n</blockquote>\n<p>it becomes <code> prime p = prime p</code> and <code>refl</code> does not end it.</p>",
        "id": 187591801,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581025343
    },
    {
        "content": "<blockquote>\n<p>My guess: <code>_root_.prime</code> and <code>nat.prime</code> are fighting over this proof.</p>\n</blockquote>\n<p>What's the difference?</p>",
        "id": 187591806,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581025352
    },
    {
        "content": "<p>You're right, I think it's that. When I replaced <code>apply prime.ne_zero</code> by <code>apply nat.prime.ne_zero</code> and <code>nat.mem_factors</code> it worked!</p>",
        "id": 187591997,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581025539
    },
    {
        "content": "<p>Does anyone know why we still have <code>nat.prime</code>?</p>",
        "id": 187592253,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581025734
    },
    {
        "content": "<p>I'm not sure I like replacing the obvious definition with a complicated one</p>",
        "id": 187592559,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581026033
    },
    {
        "content": "<blockquote>\n<p>I'm not sure I like replacing the obvious definition with a complicated one</p>\n</blockquote>\n<p>Which definition?</p>",
        "id": 187592621,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581026063
    },
    {
        "content": "<p>the abstract algebra definition</p>",
        "id": 187592633,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581026073
    },
    {
        "content": "<p>that's <code>_root_.prime</code></p>",
        "id": 187592641,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581026083
    },
    {
        "content": "<p>You can still keep the same API for nat.</p>",
        "id": 187592682,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581026120
    },
    {
        "content": "<p>we should at least make sure that the definition of <code>_root_.prime</code> does not have high dependencies</p>",
        "id": 187592702,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581026158
    },
    {
        "content": "<p>and move the proof of (the equivalent of) <code>prime n &lt;-&gt; nat.prime n</code> as early as possible</p>",
        "id": 187592790,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581026193
    },
    {
        "content": "<p>Ryan, if you really need this, the lemma is <code>nat.prime_iff_prime</code> in <code>algebra.gcd_domain</code></p>",
        "id": 187593127,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581026414
    },
    {
        "content": "<p>I can do just fine by being explicit and I never manipulate abstract prime concepts, so I'm fine with explicit <code>nat.prime</code> everywhere! Thank you :)</p>",
        "id": 187593816,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581026890
    },
    {
        "content": "<p>I'm continuing my work on power manipulation and I am trying the abv_nonneg property of my <code>real_padic_norm</code>, so here is an example which is perfectly working:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">prime</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">cau_seq</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">exponential</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">apply</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">apply_fun</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">padics</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"n\">real</span>\n<span class=\"kn\">open</span> <span class=\"n\">list</span> <span class=\"n\">option</span>\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"n\">def</span> <span class=\"n\">real_padic_norm</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">):</span> <span class=\"n\">ℚ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">,</span> <span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">of_rat</span> <span class=\"o\">(</span><span class=\"n\">padic_norm</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">hp</span><span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">prime</span> <span class=\"n\">p</span><span class=\"o\">]:</span> <span class=\"n\">is_absolute_value</span> <span class=\"o\">(</span><span class=\"n\">real_padic_norm</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n    <span class=\"n\">abv_nonneg</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n    <span class=\"n\">abv_eq_zero</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n    <span class=\"n\">abv_add</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n    <span class=\"n\">abv_mul</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"o\">}</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">hp</span><span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">prime</span> <span class=\"n\">p</span><span class=\"o\">]:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"n\">real_padic_norm</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"err\">^</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(((</span><span class=\"n\">real_padic_norm</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"err\">^</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"err\">^</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">rpow_mul</span> <span class=\"o\">(</span><span class=\"n\">is_absolute_value</span><span class=\"bp\">.</span><span class=\"n\">abv_nonneg</span> <span class=\"o\">(</span><span class=\"n\">real_padic_norm</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"o\">),</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>But when I do more or less the same in the attached file, line 394, excerpt:</p>\n<div class=\"codehilite\"><pre><span></span>      <span class=\"n\">conv_rhs</span> <span class=\"n\">at</span> <span class=\"n\">this</span> <span class=\"o\">{</span>\n          <span class=\"n\">congr</span><span class=\"o\">,</span> <span class=\"n\">skip</span><span class=\"o\">,</span>\n          <span class=\"n\">rw</span> <span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">rpow_mul</span> <span class=\"o\">(</span><span class=\"n\">is_absolute_value</span><span class=\"bp\">.</span><span class=\"n\">abv_nonneg</span> <span class=\"o\">(</span><span class=\"n\">real_padic_norm</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"o\">),</span>\n      <span class=\"o\">},</span>\n</pre></div>\n\n\n<p>It fails to synthesize type classes and fails, unsure what's the difference with the minimal case below and this one. <a href=\"/user_uploads/3121/s0F5mXZfwujwMfax7PXImB65/ostrowski-ext.lean\" target=\"_blank\" title=\"ostrowski-ext.lean\">ostrowski-ext.lean</a></p>",
        "id": 187598721,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581030906
    },
    {
        "content": "<p>Also, is there any way to solve this kind of problems:</p>\n<div class=\"codehilite\"><pre><span></span>type mismatch at application\n  is_unit_int.mp a\nterm\n  a\nhas type\n  @is_unit ℤ\n    (@ring.to_monoid ℤ\n       (@domain.to_ring ℤ (@integral_domain.to_domain ℤ (@principal_ideal_domain.to_integral_domain ℤ _inst))))\n    x_2\nbut is expected to have type\n  @is_unit ℤ int.monoid x_2\nstate:\nabv : ℚ → ℝ,\nhabv : is_absolute_value abv,\nhnontriv : abv ≠ trivial_abv,\nB : ℚ,\nint_lt_B : ∀ (z : ℕ), abv ↑z ≤ ↑B,\nall_nat_le_one : ∀ (z : ℕ), abv ↑z ≤ 1,\nall_int_le_one : ∀ (z : ℤ), abv ↑z ≤ 1,\nz : ℕ+,\nhz : abv ↑z &lt; 1,\np : ℕ,\np_fact : p ∈ factors ↑z,\nabv_p_lt_one : abv ↑p &lt; 1,\nthis : ∀ (q : ℕ), coprime p q → abv ↑q = 1,\nhp : prime p,\nα : ℝ := abv ↑p,\nthis : 0 &lt; -(real.log α / real.log ↑p),\nx : ℚ,\nx_1 : ℤ,\n_inst : principal_ideal_domain ℤ,\n_inst_1 : unique_factorization_domain ℤ,\nx_2 : ℤ,\na : is_unit x_2\n⊢ abv ↑x_2 = real_padic_norm p ↑x_2 ^ -(real.log α / real.log ↑p)\n</pre></div>\n\n\n<p>More difficult, I guess, I see that <code>is_unit_int</code> provides <code>int.nat_abs x_2 = 1</code>, but this notion of absolute value is incompatible with absolute values in general I suppose.</p>\n<p>Knowing that <code>int.nat_abs x_2 = 1</code> do not give me <code>abv (coe x_2) = int.nat_abs</code> in general AFAIK. So I guess I have to work more to interface <code>nat_abs</code> with absolute values.</p>",
        "id": 187602214,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581034214
    },
    {
        "content": "<p>For your first question, first a side comment. In the attachment you have <code>by infer_instance</code> and <code>infer_instance</code> isn't a tactic -- you would want to put <code>by apply_instance</code> or <code>infer_instance</code>. Another side comment is that this proof is gigantic and you might seriously want to consider breaking it up into smaller pieces if possible.</p>\n<p>The reason that <code>rw real.rpow_mul (is_absolute_value.abv_nonneg (real_padic_norm p) _)</code> is failing is that type class inference can't find an instance of <code>is_absolute_value (real_padic_norm p)</code>. The reason it won't use the instance on line 184 is that this only applies when type class inference can find an instance of <code>nat.prime p</code> and it seems to me that typeclass inference can't find an instance of that. If I insert <code>haveI : nat.prime p := by apply_instance,</code> in line 392 of your attached file, it fails. Conversely, if I write <code>haveI : nat.prime p := sorry</code> on line 392 then things work again -- although it takes a few seconds on my machine to do anything after any line is changed, and this is I guess because the proof is so long.</p>",
        "id": 187716895,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581168187
    },
    {
        "content": "<p>For your second question, I guess I need more context. It seems to me that <code>a</code> is a proof that <code>x_2</code> is a unit wrt one monoid structure on the integers, and you want it to be a proof that <code>x_2</code> is a unit wrt another one. If these two monoid structures are definitionally equal then Lean would not be complaining. I tried to reproduce what you did but I can't:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">padics</span><span class=\"bp\">.</span><span class=\"n\">padic_norm</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">principal_ideal_domain</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">cau_seq</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">exponential</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">apply</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">apply_fun</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">principal_ideal_domain</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n<span class=\"n\">def</span> <span class=\"n\">M1</span> <span class=\"o\">:</span> <span class=\"n\">monoid</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n<span class=\"n\">def</span> <span class=\"n\">M2</span> <span class=\"o\">:</span> <span class=\"n\">monoid</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">to_monoid</span> <span class=\"bp\">ℤ</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">domain</span><span class=\"bp\">.</span><span class=\"n\">to_ring</span> <span class=\"bp\">ℤ</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">integral_domain</span><span class=\"bp\">.</span><span class=\"n\">to_domain</span> <span class=\"bp\">ℤ</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">principal_ideal_domain</span><span class=\"bp\">.</span><span class=\"n\">to_integral_domain</span> <span class=\"bp\">ℤ</span> <span class=\"n\">I</span><span class=\"o\">))))</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">M1</span> <span class=\"bp\">=</span> <span class=\"n\">M2</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</pre></div>\n\n\n<p>So I am totally confused by this one. Did you write <code>[principal_ideal_domain ℤ]</code> at some point? This would be bad because it means \"let the integers have the structure of a principal ideal domain in a way which I am not going to tell you anything about, and in particular the underlying addition and multiplication might be completely random\".</p>",
        "id": 187717202,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581168731
    },
    {
        "content": "<p>You seem to have a diamond and there should be no diamonds in mathlib.</p>",
        "id": 187717208,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581168763
    },
    {
        "content": "<blockquote>\n<p>For your first question, first a side comment. In the attachment you have <code>by infer_instance</code> and <code>infer_instance</code> isn't a tactic -- you would want to put <code>by apply_instance</code> or <code>infer_instance</code>. Another side comment is that this proof is gigantic and you might seriously want to consider breaking it up into smaller pieces if possible.</p>\n<p>The reason that <code>rw real.rpow_mul (is_absolute_value.abv_nonneg (real_padic_norm p) _)</code> is failing is that type class inference can't find an instance of <code>is_absolute_value (real_padic_norm p)</code>. The reason it won't use the instance on line 184 is that this only applies when type class inference can find an instance of <code>nat.prime p</code> and it seems to me that typeclass inference can't find an instance of that. If I insert <code>haveI : nat.prime p := by apply_instance,</code> in line 392 of your attached file, it fails. Conversely, if I write <code>haveI : nat.prime p := sorry</code> on line 392 then things work again -- although it takes a few seconds on my machine to do anything after any line is changed, and this is I guess because the proof is so long.</p>\n</blockquote>\n<p>Thank you for looking for a so long time, I totally agree on the fact that the proof is too big and I will refactor it soon.</p>\n<p>It makes a lot more sense to me now.</p>",
        "id": 187717772,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581169976
    },
    {
        "content": "<blockquote>\n<p>For your second question, I guess I need more context. It seems to me that <code>a</code> is a proof that <code>x_2</code> is a unit wrt one monoid structure on the integers, and you want it to be a proof that <code>x_2</code> is a unit wrt another one. If these two monoid structures are definitionally equal then Lean would not be complaining. I tried to reproduce what you did but I can't:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">padics</span><span class=\"bp\">.</span><span class=\"n\">padic_norm</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">principal_ideal_domain</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">cau_seq</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">exponential</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">apply</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">apply_fun</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">principal_ideal_domain</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n<span class=\"n\">def</span> <span class=\"n\">M1</span> <span class=\"o\">:</span> <span class=\"n\">monoid</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n<span class=\"n\">def</span> <span class=\"n\">M2</span> <span class=\"o\">:</span> <span class=\"n\">monoid</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">to_monoid</span> <span class=\"bp\">ℤ</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">domain</span><span class=\"bp\">.</span><span class=\"n\">to_ring</span> <span class=\"bp\">ℤ</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">integral_domain</span><span class=\"bp\">.</span><span class=\"n\">to_domain</span> <span class=\"bp\">ℤ</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">principal_ideal_domain</span><span class=\"bp\">.</span><span class=\"n\">to_integral_domain</span> <span class=\"bp\">ℤ</span> <span class=\"n\">I</span><span class=\"o\">))))</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">M1</span> <span class=\"bp\">=</span> <span class=\"n\">M2</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</pre></div>\n\n\n<p>So I am totally confused by this one. Did you write <code>[principal_ideal_domain ℤ]</code> at some point? This would be bad because it means \"let the integers have the structure of a principal ideal domain in a way which I am not going to tell you anything about, and in particular the underlying addition and multiplication might be completely random\".</p>\n</blockquote>\n<p>The reason must be the one you pointed, I wrote <code>principal_ideal_domain Z</code>at some point. Is there any way to add more details on the PID I'm looking at?</p>",
        "id": 187717783,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581170017
    },
    {
        "content": "<p>Lean knows that the integers are a PID, you don't have to type <code>[principal_ideal_domain ℤ]</code> (which inserts a new instance of this fact into the type class inference machine) -- the instance is there already as you can see with <code>instance : principal_ideal_domain ℤ := by apply_instance</code></p>",
        "id": 187717833,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581170089
    },
    {
        "content": "<p>If you type <code>[principal_ideal_domain ℤ]</code> then you just made the <em>set</em> of integers (or more precisely the type of integers) into a principal ideal domain by choosing a completely random integer and saying \"this one is the 0\", another completely random integer and saying \"this one is the 1\", choosing a random binary function and saying \"this can be +\" etc.</p>",
        "id": 187717882,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581170191
    },
    {
        "content": "<p>Your <code>inst_1</code> is not my <code>I</code>, I suspect.</p>",
        "id": 187717896,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581170224
    },
    {
        "content": "<p>so then you get problems later on because now you have two different concepts of unit on the set of integers.</p>",
        "id": 187717905,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581170272
    },
    {
        "content": "<p>I discussed with my math advisor who told me that it might be interesting to rework a bit the absolute value, valuations stuff to do a complete classification of all valuations over a field (according to Artin, Algebraic Numbers &amp; Algebraic Functions), Artin makes super satisfying proofs IMHO, its proof of Ostrowski is quite the same of the Cassels' one, except he's able to make it a lot more compact by doing some work beforehand on the base $b$ expansions.</p>\n<p>So I think it makes sense to create a concept of valuations, derive the fact that valuations are always equivalent to one with triangular inequality, then I can have Ostrowski with kind of the same proof (shortened maybe) I have. Modulo base expansions.</p>\n<p>BTW, is there any plan regarding decimal/bases expansions in mathlib?</p>",
        "id": 187718041,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581170506
    },
    {
        "content": "<p>I'm not sure there is any sensible classification of all valuations over a general field?</p>",
        "id": 187718112,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581170597
    },
    {
        "content": "<blockquote>\n<p>Lean knows that the integers are a PID, you don't have to type <code>[principal_ideal_domain ℤ]</code> (which inserts a new instance of this fact into the type class inference machine) -- the instance is there already as you can see with <code>instance : principal_ideal_domain ℤ := by apply_instance</code></p>\n</blockquote>\n<p>It makes sense to me, but when I do this, I still have the same issue:</p>\n<div class=\"codehilite\"><pre><span></span>haveI : principal_ideal_domain ℤ := by apply_instance,\nhaveI : unique_factorization_domain ℤ := by apply_instance,\napply unique_factorization_domain.induction_on_prime x_1,\n {sorry,},\n{intros, have abs_x2_eq_one: int.nat_abs x_2 = 1 := is_unit_int.1 a},\n{ sorry },\n</pre></div>\n\n\n<p>where <code>x_1 : \\Z</code>.</p>\n<p>Am I still doing something wrong?</p>",
        "id": 187718160,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581170660
    },
    {
        "content": "<p>I only know of classifications over number fields (and I can believe that there will be a classification for global fields). Anything beyond that gets hairy very quickly.</p>",
        "id": 187718165,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581170673
    },
    {
        "content": "<p>I can't answer your question about instances unless you post complete working code.</p>",
        "id": 187718170,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581170700
    },
    {
        "content": "<p>I am explicitly asking you whether you have any <code>[principal_ideal_domain ℤ]</code> <em>with the rectangular brackets</em> in your code. If you don't, the problem is elsewhere.</p>",
        "id": 187718184,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581170756
    },
    {
        "content": "<blockquote>\n<p>I'm not sure there is any sensible classification of all valuations over a general field?</p>\n</blockquote>\n<p>AFAIK, Artin provides some results regarding archimedean/non-archimedean.</p>",
        "id": 187718224,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581170768
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/AZjjMTFRVVnaNPhiZRypzbnG/ostrowski-ext.lean\" target=\"_blank\" title=\"ostrowski-ext.lean\">ostrowski-ext.lean</a> <br>\nHere's the long file, because whenever I extract it into a minimal case, it works, so I don't understand what's the difference, sorry for the long proof. You'll see line 414 the issue.</p>",
        "id": 187718228,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581170806
    },
    {
        "content": "<p>I can't really comment on the Artin results because I am not sure what precisely you're talking about.</p>",
        "id": 187718236,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581170831
    },
    {
        "content": "<p>Not sure I can link a PDF for a book here, I suppose. But the exact reference is \"Artin, Algebraic Numbers &amp; Algebraic Functions\", chapter 1, section 3, \"Classifications of Valuations\"</p>",
        "id": 187718291,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581170979
    },
    {
        "content": "<p>He proves a necessary &amp; sufficient condition for a field to be non-archimedean based on the boundness of the values of the rationals integers for the valuation if I read well.</p>\n<p>My advisor told me that it'd be interested to go this way in order to develop <a href=\"https://en.wikipedia.org/wiki/Berkovich_space\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Berkovich_space\">https://en.wikipedia.org/wiki/Berkovich_space</a> in Lean.</p>",
        "id": 187718355,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581171100
    },
    {
        "content": "<p>Commelin, Massot and me already developed adic spaces in Lean, probably what we did would be of some help if you wanted to do Berkovich spaces.</p>",
        "id": 187718404,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581171166
    },
    {
        "content": "<p>It's not in mathlib though.</p>",
        "id": 187718407,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581171182
    },
    {
        "content": "<blockquote>\n<p>It's not in mathlib though.</p>\n</blockquote>\n<p>Is it in the perfectoid repository?</p>",
        "id": 187718413,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581171192
    },
    {
        "content": "<p>Right.</p>",
        "id": 187718414,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581171198
    },
    {
        "content": "<p>That's something I'm interested in, thanks, I'll take a look to the repo then.</p>",
        "id": 187718421,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581171224
    },
    {
        "content": "<p>I am now beginning to think that the problem with your code is <code>unique_factorization_domain.induction_on_prime</code></p>",
        "id": 187718652,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581171629
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>unique_factorization_domain.induction_on_prime :\n  ∀ {α : Type u_2} [_inst_1 : integral_domain α] [_inst_2 : unique_factorization_domain α] {P : α → Prop}\n  (a : α),\n    P 0 → (∀ (x : α), is_unit x → P x) → (∀ (a p : α), a ≠ 0 → prime p → P a → P (p * a)) → P a\n</pre></div>",
        "id": 187718663,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581171671
    },
    {
        "content": "<p>no I'm wrong, this looks fine; unique_factorization_domain doesn't extend integral_domain</p>",
        "id": 187718675,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581171714
    },
    {
        "content": "<p>Oh! I am a twit. It shouldn't be <code>haveI</code> -- you need to change them to <code>letI</code>.</p>",
        "id": 187719815,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581173979
    },
    {
        "content": "<blockquote>\n<p>Oh! I am a twit. It shouldn't be <code>haveI</code> -- you need to change them to <code>letI</code>.</p>\n</blockquote>\n<p>Is there some docs on what's the difference between them?</p>",
        "id": 187719819,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581173999
    },
    {
        "content": "<p>And it worked! :D</p>",
        "id": 187719872,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581174045
    },
    {
        "content": "<p>you use <code>let</code> to define data and <code>have</code> to define proofs.</p>",
        "id": 187719965,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581174237
    },
    {
        "content": "<p>Because <code>principal_ideal_domain</code> extends <code>integral_domain</code>, it's data.</p>",
        "id": 187720012,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581174280
    },
    {
        "content": "<p>The term of type <code>principal_ideal_domain int</code> contains all the data of the multiplication etc.</p>",
        "id": 187720033,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581174334
    },
    {
        "content": "<p>Okay I got it!</p>",
        "id": 187720088,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581174397
    },
    {
        "content": "<blockquote>\n<p>My advisor told me that it'd be interested to go this way in order to develop <a href=\"https://en.wikipedia.org/wiki/Berkovich_space\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Berkovich_space\">https://en.wikipedia.org/wiki/Berkovich_space</a> in Lean.</p>\n</blockquote>\n<p>Who is your advisor? Antoine?</p>",
        "id": 187730805,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581194645
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>My advisor told me that it'd be interested to go this way in order to develop <a href=\"https://en.wikipedia.org/wiki/Berkovich_space\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Berkovich_space\">https://en.wikipedia.org/wiki/Berkovich_space</a> in Lean.</p>\n</blockquote>\n<p>Who is your advisor? Antoine?</p>\n</blockquote>\n<p>Frédéric Paugam (I'm not in PhD)</p>",
        "id": 187731080,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581195213
    },
    {
        "content": "<p>I didn't know Frédéric was interested in Lean!</p>",
        "id": 187731124,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581195249
    },
    {
        "content": "<p>Are you a M2 student?</p>",
        "id": 187731137,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581195309
    },
    {
        "content": "<blockquote>\n<p>Are you a M2 student?</p>\n</blockquote>\n<p>I'm in L3 :D…</p>",
        "id": 187731140,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581195324
    },
    {
        "content": "<p>Doing Berkovich spaces? Interesting...</p>",
        "id": 187731145,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581195342
    },
    {
        "content": "<blockquote>\n<p>I didn't know Frédéric was interested in Lean!</p>\n</blockquote>\n<p>Frédéric Le Roux is also working on metric spaces in Lean IIRC, he wants to redo limits/etc without using uniform spaces so that it can be closer to what students know AFAIK.</p>",
        "id": 187731190,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581195374
    },
    {
        "content": "<blockquote>\n<p>Doing Berkovich spaces? Interesting...</p>\n</blockquote>\n<p>Too much free time… :D</p>",
        "id": 187731193,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581195384
    },
    {
        "content": "<p>Yes, I know that Frédéric is interested in Lean, I didn't know about Paugam.</p>",
        "id": 187731200,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581195421
    },
    {
        "content": "<p>Lean is very good software for students who have too much free time.</p>",
        "id": 187731265,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581195540
    },
    {
        "content": "<p>Definitely agreed!</p>",
        "id": 187731331,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1581195631
    }
]
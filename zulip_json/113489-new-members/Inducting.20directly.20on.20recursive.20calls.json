[
    {
        "content": "<p>I'd like to be able to induct directly on the recursion of a function instead of on the inputs to that function.<br>\nI want to prove a property of a function and have the inductive hypothesis that all of the recursive calls satisfy the property for their inputs.</p>\n<p>Something like this silly example (which can obviously be done in another way):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fib</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">fib</span> <span class=\"n\">n.succ</span> <span class=\"bp\">+</span> <span class=\"n\">fib</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">property_of_function</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fib</span> <span class=\"n\">k</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">k</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- base cases etc...</span>\n\n  <span class=\"c1\">-- I want to be able to get this inductive hypothesis in the case where k &gt; 2 and we recur</span>\n  <span class=\"k\">have</span> <span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"n\">fib</span> <span class=\"n\">k.pred</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">k.pred</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">∧</span> <span class=\"n\">fib</span> <span class=\"n\">k.pred.pred</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">k.pred.pred</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 262015646,
        "sender_full_name": "Ryan Greenblatt",
        "timestamp": 1637284388
    },
    {
        "content": "<p>Are you asking about how to do strong induction?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction</span> <span class=\"n\">k</span> <span class=\"n\">using</span> <span class=\"n\">nat.strong_induction_on</span> <span class=\"k\">with</span> <span class=\"n\">k</span> <span class=\"n\">ih</span>\n</code></pre></div>\n<p>This gives you the hypotheses <code>∀ (m : ℕ), m &lt; k → (fib m &gt; 0 ↔ m &gt; 0)</code></p>",
        "id": 262016815,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1637285411
    },
    {
        "content": "<p>(I guess it's just an example, but if you simplify the definition of <code>fib</code> to not include the the <code>2</code> case, then you'll have fewer things to prove in the induction.)</p>",
        "id": 262016880,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1637285497
    },
    {
        "content": "<p>Strong induction should work in the case I have in mind, but it would be nice if you could just induct on recursion itself.<br>\nThis would make things easier when the well_foundedness measure is a pain to work with I think.<br>\nFair enough if this isn't possible in general.</p>",
        "id": 262017096,
        "sender_full_name": "Ryan Greenblatt",
        "timestamp": 1637285654
    },
    {
        "content": "<p>I've been using mathlib's <code>induction'</code> which generalizes everything by default.<br>\nDo you know the syntax for generalizing a given variable with the standard <code>induction</code> or how to do strong induction with mathlib (google/docs don't seem to very helpful here...)</p>",
        "id": 262018110,
        "sender_full_name": "Ryan Greenblatt",
        "timestamp": 1637286646
    },
    {
        "content": "<p>Ah, looks like mathlib <code>induction'</code> doesn't support  <code>using</code></p>",
        "id": 262018129,
        "sender_full_name": "Ryan Greenblatt",
        "timestamp": 1637286680
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"457807\">@Ryan Greenblatt</span> One way to induct on the recursion itself is to have an inductive type that implements the function.  I'm not sure how to really set this up properly, but here's an attempt:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fib</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">fib</span> <span class=\"n\">n.succ</span> <span class=\"bp\">+</span> <span class=\"n\">fib</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">fib_fun</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">case0</span> <span class=\"o\">:</span> <span class=\"n\">fib_fun</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">case1</span> <span class=\"o\">:</span> <span class=\"n\">fib_fun</span> <span class=\"mi\">1</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">recur</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fsn</span> <span class=\"o\">:</span> <span class=\"n\">fib_fun</span> <span class=\"n\">n.succ</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fn</span> <span class=\"o\">:</span> <span class=\"n\">fib_fun</span> <span class=\"n\">n</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fib_fun</span> <span class=\"n\">n.succ.succ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- not used here -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">fib_fun_is_fib</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fib_fun</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fib</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">fib</span><span class=\"o\">,</span> <span class=\"bp\">*</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fib_is_fib_fun</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fib_fun</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">fib</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">using</span> <span class=\"n\">nat.strong_induction_on</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">fib_fun.case0</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">fib_fun.case1</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">fib_fun.recur</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">nat.less_than_or_equal.refl</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">nat.less_than_or_equal.step</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">nat.less_than_or_equal.refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">property_of_function</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fib</span> <span class=\"n\">k</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">k</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">fib_is_fib_fun</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"c1\">-- induct on the recursion</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nat.succ_eq_add_one</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">omega</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 262018138,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1637286688
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"457807\">Ryan Greenblatt</span> <a href=\"#narrow/stream/113489-new-members/topic/Inducting.20directly.20on.20recursive.20calls/near/262018110\">said</a>:</p>\n<blockquote>\n<p>I've been using mathlib's <code>induction'</code> which generalizes everything by default.<br>\nDo you know the syntax for generalizing a given variable with the standard <code>induction</code> or how to do strong induction with mathlib (google/docs don't seem to very helpful here...)</p>\n</blockquote>\n<p>Does <code>induction ... generalizing ...</code> do what you want? <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#induction\">tactic#induction</a></p>",
        "id": 262018204,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1637286748
    },
    {
        "content": "<p>Huh, cool. Thanks for all the help!</p>",
        "id": 262018220,
        "sender_full_name": "Ryan Greenblatt",
        "timestamp": 1637286774
    },
    {
        "content": "<p>Will probably just use strong induction.</p>",
        "id": 262018235,
        "sender_full_name": "Ryan Greenblatt",
        "timestamp": 1637286789
    }
]
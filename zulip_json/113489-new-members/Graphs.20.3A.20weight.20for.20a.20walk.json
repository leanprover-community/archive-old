[
    {
        "content": "<p>Hello everyone,<br>\nI am trying to define a weight for a walk as the product of the weights of the edges the walk visits.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">directed_simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">directed_simple_graph</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[ext, derive decidable_eq]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">dart</span> <span class=\"kd\">extends</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_adj</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">fst</span> <span class=\"n\">snd</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dart.edge</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">G.dart</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">d.to_prod</span>\n\n<span class=\"kd\">@[derive decidable_eq]</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">directed_walk</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">directed_walk</span> <span class=\"n\">u</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">directed_walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">directed_walk</span> <span class=\"n\">u</span> <span class=\"n\">w</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">directed_walk</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">darts</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"n\">G.directed_walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">G.dart</span>\n<span class=\"bp\">|</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">h</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨(</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">::</span> <span class=\"n\">p.darts</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">edges</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.directed_walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">p.darts.map</span> <span class=\"o\">(</span><span class=\"n\">dart.edge</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">edges_set</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">G.directed_walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span> <span class=\"bp\">|</span> <span class=\"o\">[(</span><span class=\"n\">x.1</span><span class=\"o\">,</span> <span class=\"n\">x.2</span><span class=\"o\">)]</span> <span class=\"bp\">⊆</span> <span class=\"n\">p.edges</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">constant</span> <span class=\"n\">walk_edge_weight</span> <span class=\"o\">:</span> <span class=\"n\">p.edges_set</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">edges_mult_set</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">G.directed_walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"o\">((</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x.1.1</span><span class=\"o\">,</span><span class=\"n\">x.1.2</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">p.edges_set</span> <span class=\"bp\">∧</span> <span class=\"n\">x.2</span> <span class=\"bp\">=</span>  <span class=\"o\">(</span><span class=\"n\">p.edges</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">count</span> <span class=\"o\">(</span><span class=\"n\">x.1.1</span><span class=\"o\">,</span><span class=\"n\">x.1.2</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">walk_weight</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">G.directed_walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The issue, I have, is :<br>\nFirst, I need to introduce a weight function that sends the edge of a walk to a real number. I would like to have a function </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">p.edges</span> <span class=\"bp\">\\</span><span class=\"n\">to</span> <span class=\"bp\">\\</span><span class=\"n\">R</span>\n</code></pre></div>\n<p>however this does not seem to work. Therefore, I defined a set, \"edges_set\", instead of a list (V \\times V), \"edges\". Now, I can introduce the weight function, \"walk_edge_weight\". However, wanting to introduce a weight fot the walk, I must not lose duplicates. Thats why I came up with \"edges_mult_set\". Now I am trying to map the walk to a real number by</p>\n<p>Product_{e=(e1,e1,e3) in edges_set_mult} walk_edge_weight (e1,e2) * e3</p>\n<p>But I dont know, how to implement that or whether there is a way more convenient way of achieving the goal of a weight for a walk. Any help is appreciated.</p>",
        "id": 321193165,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673624944
    },
    {
        "content": "<p>This is untested, but this might be something like what you're looking for:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">walk_weight</span> <span class=\"o\">(</span><span class=\"n\">wt</span> <span class=\"o\">:</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"n\">G.directed_walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span>\n<span class=\"bp\">|</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">h</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">wt</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">*</span> <span class=\"n\">walk_weight</span> <span class=\"n\">p</span>\n</code></pre></div>",
        "id": 321196852,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673625835
    },
    {
        "content": "<p>That's a function that takes a weight function on the edges of a graph and a directed walk and outputs a real number. I might have gotten <code>wt ⟨_, h⟩</code> wrong. You might also do something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">walk_weight</span> <span class=\"o\">(</span><span class=\"n\">wt</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"n\">G.directed_walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span>\n<span class=\"bp\">|</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">cons</span> <span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">wt</span> <span class=\"n\">u</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">walk_weight</span> <span class=\"n\">p</span>\n</code></pre></div>",
        "id": 321197183,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673625911
    },
    {
        "content": "<p>It generally is OK to allow larger domains for things, like <code>wt</code> in this case taking in arbitrary pairs of vertices. You can always put \"junk\" values for non-edges</p>",
        "id": 321197381,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673625962
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/Graphs.20.3A.20weight.20for.20a.20walk/near/321197381\">schrieb</a>:</p>\n<blockquote>\n<p>It generally is OK to allow larger domains for things, like <code>wt</code> in this case taking in arbitrary pairs of vertices. You can always put \"junk\" values for non-edges</p>\n</blockquote>\n<p>Thanks for helping me, again <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>.  This most likely is what I have been looking for. I still find the \"nil cons recursive way\"  of defining stuff quite unintuitive. </p>\n<p>How do I define a junk value ? I mean it could be defined as 0, but is there a way to make the output an error and not an element in \\R ?</p>\n<p>By the way, has anyone worked on similar stuff already ? I also plan on introducing a path system and the weight of such. (The goal is to work on the Lindstrom Gessel Viennot Lemma.)</p>",
        "id": 321204019,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673627536
    },
    {
        "content": "<p>You can use <code>arbitrary \\R</code> for your junk value. It turns out to be equal to <code>0</code>, but it's marked <code>@[irreducible]</code> so it's not easy to accidentally rely on this behaviour.</p>",
        "id": 321220984,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673632209
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/arbitrary\">docs#arbitrary</a></p>",
        "id": 321221009,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673632219
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"492774\">@Sky Wilshaw</span> Thanks.</p>",
        "id": 321222828,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673632761
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/Graphs.20.3A.20weight.20for.20a.20walk/near/321196852\">schrieb</a>:</p>\n<blockquote>\n<p>This is untested, but this might be something like what you're looking for:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">walk_weight</span> <span class=\"o\">(</span><span class=\"n\">wt</span> <span class=\"o\">:</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"n\">G.directed_walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span>\n<span class=\"bp\">|</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">h</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">wt</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">*</span> <span class=\"n\">walk_weight</span> <span class=\"n\">p</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Both of those definition did not seem to work. So I modified the second one to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">walk_weight2</span> <span class=\"o\">(</span><span class=\"n\">wt</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"n\">G.directed_walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span>\n<span class=\"bp\">|</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">cons</span> <span class=\"n\">V</span> <span class=\"n\">G</span> <span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">wt</span> <span class=\"n\">u</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">walk_weight2</span> <span class=\"n\">p</span>\n</code></pre></div>\n<p>and alternatively formulated :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">walk_weight3</span> <span class=\"o\">(</span><span class=\"n\">wt</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"n\">G.directed_walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span>\n<span class=\"bp\">|</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">cons</span> <span class=\"n\">V</span> <span class=\"n\">G</span> <span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"k\">have</span> <span class=\"n\">r1</span> <span class=\"o\">:=</span> <span class=\"n\">wt</span> <span class=\"n\">u</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">have</span> <span class=\"n\">r2</span> <span class=\"o\">:=</span> <span class=\"n\">walk_weight3</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">r1</span> <span class=\"bp\">*</span> <span class=\"n\">r2</span><span class=\"o\">)}</span>\n</code></pre></div>\n<p>Are both equivalent ?</p>",
        "id": 321278237,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673652789
    },
    {
        "content": "<p>Ah, right, I forgot the <code>V</code> and <code>G</code> arguments.</p>\n<p>Yes, the two definitions are equivalent. The first is preferred since tactics can obscure the precise expressions used in a definition. Just so you know about it (and I'm not suggesting you use it here), you can use <code>let</code> expressions. Again untested, but rather than <code>by {have r1 := wt u x, have r2 := walk_weight3 p, exact (r1 * r2)}</code> you should be able to do <code>let r1 := wt u x, r2 := walk_weight3 p in r1 * r2</code></p>",
        "id": 321342705,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673697021
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/Graphs.20.3A.20weight.20for.20a.20walk/near/321342705\">schrieb</a>:</p>\n<blockquote>\n<p>Ah, right, I forgot the <code>V</code> and <code>G</code> arguments.</p>\n<p>Yes, the two definitions are equivalent. The first is preferred since tactics can obscure the precise expressions used in a definition. Just so you know about it (and I'm not suggesting you use it here), you can use <code>let</code> expressions. Again untested, but rather than <code>by {have r1 := wt u x, have r2 := walk_weight3 p, exact (r1 * r2)}</code> you should be able to do <code>let r1 := wt u x, r2 := walk_weight3 p in r1 * r2</code></p>\n</blockquote>\n<p>Ah I see. I am not familiar with all syntactic possibilities, so good to know. Thanks.</p>",
        "id": 321360214,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673704334
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 321361011,
        "sender_full_name": "Alistair Tucker",
        "timestamp": 1673704703
    },
    {
        "content": "<p>Notice that <code>have</code> should only be used for proofs because it erases data; for data use <code>let</code> instead.</p>",
        "id": 321410835,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1673732088
    }
]
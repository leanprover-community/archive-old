[
    {
        "content": "<p>Hello world!<br>\nI played enough of the \"number game\" that I thought I should try something a bit different -- more in my area, and more advanced.</p>\n<p>I checked that Lean has the concepts of group, and in particular finite groups, built-in. I was thinking about proving the following theorems, in order of difficulty:<br>\n-- The group generated by x-&gt;x+1 acting on the reals is the free group &lt;a|&gt;<br>\n-- The group generated by x-&gt;x+1 and x-&gt;2x has as presentation &lt;a,b|ab=ba^2&gt;<br>\n-- The group generated by x-&gt;x+1 and x-&gt;x^3 is the free group &lt;a,b|&gt;</p>\n<p>Any opinions on whether this is a sensible task for a newbie?</p>\n<p>TIA, Laurent</p>",
        "id": 187916327,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1581431434
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"263407\">@Laurent Bartholdi</span> What exactly do you mean with \"the group generated by x -&gt; x+1 and x -&gt; x^3\"?</p>",
        "id": 187917115,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581431812
    },
    {
        "content": "<p>Are you fixing a real number, and then taking the closure under those functions?</p>",
        "id": 187917152,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581431832
    },
    {
        "content": "<p>Anyway, I think such statements can be done in Lean, although there might be some annoying technicalities.</p>",
        "id": 187917287,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581431915
    },
    {
        "content": "<blockquote>\n<p>Are you fixing a real number, and then taking the closure under those functions?</p>\n</blockquote>\n<p>There are two options. I could think about maps on the reals, and this is my preferred choice. I could also think of the orbit of \\pi under these operations (assuming lean knows that \\pi is transcendental, of course).</p>",
        "id": 187917849,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1581432313
    },
    {
        "content": "<p>It doesn't know that <code>pi</code> is transcendental</p>",
        "id": 187921238,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581434623
    },
    {
        "content": "<p>Aha, so you want to look at subgroups of <code>Aut(R)</code>, sorry, I was being dense.</p>",
        "id": 187921317,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581434663
    },
    {
        "content": "<p>There is something called <code>\\R \\equiv \\R</code>, which is all bijections from R to itself.</p>",
        "id": 187921391,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581434728
    },
    {
        "content": "<p>Lean knows that it is a group.</p>",
        "id": 187921399,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581434735
    },
    {
        "content": "<p>Lean also knows how to generate a subgroup from a set.</p>",
        "id": 187921406,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581434748
    },
    {
        "content": "<p>So you could start by building the bijections that you stated in your post. That would be task 0.1 I guess</p>",
        "id": 187921462,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581434778
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">add_one</span> <span class=\"o\">:</span> <span class=\"err\">\\</span><span class=\"n\">R</span> <span class=\"err\">\\</span><span class=\"n\">equiv</span> <span class=\"err\">\\</span><span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">double</span> <span class=\"o\">:</span> <span class=\"err\">\\</span><span class=\"n\">R</span> <span class=\"err\">\\</span><span class=\"n\">equiv</span> <span class=\"err\">\\</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"n\">def</span> <span class=\"n\">pow_three</span> <span class=\"o\">:</span> <span class=\"err\">\\</span><span class=\"n\">R</span> <span class=\"err\">\\</span><span class=\"n\">equiv</span> <span class=\"err\">\\</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 187921534,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581434843
    },
    {
        "content": "<p>(Sorry, no unicode nearby...)</p>",
        "id": 187921548,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581434855
    },
    {
        "content": "<p>It will be no problem proving that the group generated by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>↦</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">x\\mapsto x+1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.522em;vertical-align:-0.011em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> is isomorphic to the free group.</p>",
        "id": 187929480,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581439709
    },
    {
        "content": "<p>For the others, I don't know a formal maths proof but it wouldn't surprise me if it were straightforward for an expert to formalise, although it might be long for a beginner.</p>",
        "id": 187930395,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581440330
    },
    {
        "content": "<p>Laurent, the honest answer is: everything is hard, but it's a lot of fun.</p>",
        "id": 187934442,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581442857
    },
    {
        "content": "<p>What Johan wrote is probably not enough to get you started. The first point is that, for computer science related reasons, a lot of things in mathlib are setup in terms of this <code>equiv</code> structure which packages a map, its inverse and proofs that the inverse is indeed a left and right inverse. Of course from a mathematics perspective, it has no additional content compared to a map and a proof of bijectivity, but from a computational perspective it's different. This is slightly painful but it would be much worse if you wanted to use Coq whose community is full of people who care about computations.</p>",
        "id": 187934728,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581443059
    },
    {
        "content": "<p>We also have an abbreviation for self-equiv called <code>perm</code>. So the map <code>x+1</code> seen as a permutation of reals is defined as:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n</pre></div>\n\n\n<p>The last two lines are the proofs, they are crushed by the simplifier.</p>",
        "id": 187934804,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581443141
    },
    {
        "content": "<p>Then the subgroup spanned by <code>T</code> is: <code>group.closure ({T} : set (perm ℝ))</code>. Note that it should be enough to write <code>group.closure {T}</code> but Lean3's elaborator is failing badly here (this is a known bug) so we need to tell it explicitly that this singleton <code>{T}</code> is a set of permutations of ℝ.</p>",
        "id": 187935099,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581443321
    },
    {
        "content": "<p>Question <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> and <span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span>  who seem to be around. Do you have any idea why Lean doesn't immediately get a subgroup instance on that group closure?</p>",
        "id": 187935281,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581443379
    },
    {
        "content": "<p>Minimal example here:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory</span><span class=\"bp\">.</span><span class=\"n\">free_group</span>\n<span class=\"kn\">open</span> <span class=\"n\">equiv</span> <span class=\"n\">function</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"n\">noncomputable</span> <span class=\"n\">theory</span>\n\n<span class=\"n\">def</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">LB1</span>\n<span class=\"c1\">-- The subgroup generated by T</span>\n<span class=\"n\">def</span> <span class=\"n\">LB1</span> <span class=\"o\">:=</span> <span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">closure</span> <span class=\"o\">({</span><span class=\"n\">T</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"n\">LB1</span> <span class=\"o\">:=</span> <span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">closure</span><span class=\"bp\">.</span><span class=\"n\">is_subgroup</span> <span class=\"bp\">_</span>  <span class=\"c1\">-- by apply_instance fails</span>\n</pre></div>",
        "id": 187935370,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581443419
    },
    {
        "content": "<p>Next trap for Laurent. You may think that <code>T</code> belongs to <code>LB1</code>. But elements of <code>LB1</code> are packages containing a permutation <em>and</em> a proof that it belongs to the subgroup spanned by <code>T</code>. So you need something like <code>def t : LB1 := ⟨T, group.in_closure.basic (by simp)</code> to define <code>t</code> which is <code>T</code> seen as an element of <code>LB1</code> (we could probably write a nice helper function here).</p>",
        "id": 187935557,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581443537
    },
    {
        "content": "<p>Then you need to start reading <a href=\"https://leanprover-community.github.io/mathlib_docs/group_theory/free_group.html\" target=\"_blank\" title=\"https://leanprover-community.github.io/mathlib_docs/group_theory/free_group.html\">https://leanprover-community.github.io/mathlib_docs/group_theory/free_group.html</a> or the corresponding Lean file. Unfortunately this was written before we enforced nice documentation requirements. I you like documenting what you understand, you could take this as a challenge to contribute documentation to mathlib.</p>",
        "id": 187935794,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581443693
    },
    {
        "content": "<p>Same applies to <a href=\"https://leanprover-community.github.io/mathlib_docs/group_theory/presented_group.html\" target=\"_blank\" title=\"https://leanprover-community.github.io/mathlib_docs/group_theory/presented_group.html\">https://leanprover-community.github.io/mathlib_docs/group_theory/presented_group.html</a></p>",
        "id": 187935825,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581443709
    },
    {
        "content": "<p>One possible way to state your first two challenges would then be:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory</span><span class=\"bp\">.</span><span class=\"n\">free_group</span>\n<span class=\"kn\">open</span> <span class=\"n\">equiv</span> <span class=\"n\">function</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"n\">noncomputable</span> <span class=\"n\">theory</span>\n\n<span class=\"n\">def</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">LB1</span>\n<span class=\"c1\">-- The subgroup generated by T</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">derive</span> <span class=\"n\">is_subgroup</span><span class=\"o\">]</span>\n<span class=\"n\">def</span> <span class=\"n\">LB1</span> <span class=\"o\">:=</span> <span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">closure</span> <span class=\"o\">({</span><span class=\"n\">T</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- The transformation T seen as an element of the subgroup it generates.</span>\n<span class=\"n\">def</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">LB1</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">in_closure</span><span class=\"bp\">.</span><span class=\"n\">basic</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n\n\n<span class=\"c1\">-- Free group on one generator denoted by ()</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">derive</span> <span class=\"n\">group</span><span class=\"o\">]</span>\n<span class=\"n\">def</span> <span class=\"n\">F₁</span> <span class=\"o\">:=</span> <span class=\"n\">free_group</span> <span class=\"n\">unit</span>\n\n<span class=\"c1\">-- Laurent&#39;s first map</span>\n<span class=\"n\">def</span> <span class=\"n\">LB1_map</span> <span class=\"o\">:</span> <span class=\"n\">F₁</span> <span class=\"bp\">→</span> <span class=\"n\">LB1</span> <span class=\"o\">:=</span> <span class=\"n\">free_group</span><span class=\"bp\">.</span><span class=\"n\">to_group</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">unit</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">LB1_iso</span> <span class=\"o\">:</span> <span class=\"n\">bijective</span> <span class=\"n\">LB1_map</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">LB1</span>\n\n<span class=\"n\">def</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">/</span><span class=\"mi\">2</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"bp\">;</span> <span class=\"n\">ring</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"bp\">;</span> <span class=\"n\">ring</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">LB2</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">derive</span> <span class=\"n\">is_subgroup</span><span class=\"o\">]</span>\n<span class=\"n\">def</span> <span class=\"n\">LB2</span> <span class=\"o\">:=</span> <span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">closure</span> <span class=\"o\">({</span><span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span>\n\n<span class=\"n\">def</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">LB2</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">in_closure</span><span class=\"bp\">.</span><span class=\"n\">basic</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n<span class=\"n\">def</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">LB2</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">in_closure</span><span class=\"bp\">.</span><span class=\"n\">basic</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n\n<span class=\"c1\">-- The free group generated by booleans tt and ff</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">derive</span> <span class=\"n\">group</span><span class=\"o\">]</span>\n<span class=\"n\">def</span> <span class=\"n\">F₂</span> <span class=\"o\">:=</span> <span class=\"n\">free_group</span> <span class=\"n\">bool</span>\n\n<span class=\"c1\">-- First generator of F</span>\n<span class=\"n\">def</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">F₂</span> <span class=\"o\">:=</span> <span class=\"n\">free_group</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">[(</span><span class=\"n\">tt</span><span class=\"o\">,</span> <span class=\"n\">tt</span><span class=\"o\">)]</span>\n<span class=\"n\">def</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">F₂</span> <span class=\"o\">:=</span> <span class=\"n\">free_group</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">[(</span><span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"n\">tt</span><span class=\"o\">)]</span>\n\n<span class=\"c1\">-- Laurent&#39;s second map</span>\n<span class=\"n\">def</span> <span class=\"n\">LB2_map</span> <span class=\"o\">:</span> <span class=\"n\">F₂</span> <span class=\"bp\">→</span> <span class=\"n\">LB2</span> <span class=\"o\">:=</span> <span class=\"n\">free_group</span><span class=\"bp\">.</span><span class=\"n\">to_group</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">b</span> <span class=\"k\">then</span> <span class=\"n\">t</span> <span class=\"k\">else</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">is_group_hom</span> <span class=\"n\">LB2_map</span> <span class=\"o\">:=</span> <span class=\"n\">free_group</span><span class=\"bp\">.</span><span class=\"n\">to_group</span><span class=\"bp\">.</span><span class=\"n\">is_group_hom</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">surj</span> <span class=\"o\">:</span> <span class=\"n\">surjective</span> <span class=\"n\">LB2_map</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">ker</span> <span class=\"o\">:</span> <span class=\"n\">is_group_hom</span><span class=\"bp\">.</span><span class=\"n\">ker</span> <span class=\"n\">LB2_map</span> <span class=\"bp\">=</span> <span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">normal_closure</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">b</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">*</span><span class=\"n\">a</span><span class=\"err\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n<span class=\"kn\">end</span> <span class=\"n\">LB2</span>\n</pre></div>",
        "id": 187935994,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581443810
    },
    {
        "content": "<p>Understanding that piece should already give you plenty of questions to ask here. For everybody else: note there is another mysterious instance that type class instance resolution is not finding.</p>",
        "id": 187936064,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581443860
    },
    {
        "content": "<blockquote>\n<p>Question <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> and <span class=\"user-mention silent\" data-user-id=\"110596\">Rob Lewis</span>  who seem to be around. Do you have any idea why Lean doesn't immediately get a subgroup instance on that group closure?</p>\n</blockquote>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">group_theory</span><span class=\"bp\">.</span><span class=\"n\">perm</span><span class=\"bp\">.</span><span class=\"n\">all</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">open</span> <span class=\"n\">tactic</span> <span class=\"n\">equiv</span>\n\n<span class=\"n\">def</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"o\">(</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">closure</span> <span class=\"o\">({</span><span class=\"n\">T</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"n\">ℝ</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n</pre></div>\n\n\n<p>seems fine?</p>",
        "id": 187936103,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1581443882
    },
    {
        "content": "<p>Oh sorry. It's unfolding again.</p>",
        "id": 187936417,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581444031
    },
    {
        "content": "<p>So I could have written</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">derive</span> <span class=\"n\">is_subgroup</span><span class=\"o\">]</span>\n<span class=\"n\">def</span> <span class=\"n\">LB1</span> <span class=\"o\">:=</span> <span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">closure</span> <span class=\"o\">({</span><span class=\"n\">T</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 187936511,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581444082
    },
    {
        "content": "<p>This doesn't work for the second failing instance. <code>derive</code> complains it want a <code>group real</code> instance.</p>",
        "id": 187936544,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581444113
    },
    {
        "content": "<p>For <code>+1</code> we have <code>equiv.add_right</code>.</p>",
        "id": 187936802,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581444248
    },
    {
        "content": "<p>I'd define all these subgroups as images of the free group under a <code>lift</code> homomorphism, then study the kernels of these homomorphisms.</p>",
        "id": 187936812,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581444253
    },
    {
        "content": "<blockquote>\n<p>This doesn't work for the second failing instance. <code>derive</code> complains it want a <code>group real</code> instance.</p>\n</blockquote>\n<p>What's the second failing instance?</p>",
        "id": 187936836,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1581444265
    },
    {
        "content": "<p><code>is_group_hom LB2_map</code></p>",
        "id": 187936870,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581444287
    },
    {
        "content": "<p>It needs the big message with 67 lines of code.</p>",
        "id": 187936948,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581444350
    },
    {
        "content": "<p>And maybe it's not the right starting point. I only tried to get one, but maybe Yury has a better way. I don't know group theory in mathlib.</p>",
        "id": 187937026,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581444387
    },
    {
        "content": "<p>There should be a nice documented way of formalizing those kind of questions, but I don't think anyone did this yet (at least it doesn't seem documented).</p>",
        "id": 187937116,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581444471
    },
    {
        "content": "<p>Oh, I think the derive handler is struggling with the function type there like in <a href=\"https://github.com/leanprover-community/mathlib/issues/1951\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/issues/1951\">#1951</a>. I'll look into it eventually.</p>",
        "id": 187937246,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1581444549
    },
    {
        "content": "<p>BTW, it would be nice to turn <code>equiv.mul_left</code> (or <code>_right</code>?) into a group homomorphism <code>G →* (mul_equiv G G)</code></p>",
        "id": 187937372,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581444622
    },
    {
        "content": "<p>Thanks to all, esp. <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> for getting me on the horse.</p>\n<p>Indeed I do have some questions, that I can't answer myself.<br>\n1) why the \"instance : is_group_hom LB2_map := free_group.to_group.is_group_hom\"? I understand \"instance\" as forcing is_group_hom(LB2_map) to be non-empty by supplying an instance; but why isn't it automatic? Maybe I'm missing the point of the discussion in the following messages</p>\n<p>2) what are the angles in \"⟨T, group.in_closure.basic (by simp)⟩\"? Is it that we would like to write \"def t : LB2 := T\" but need to help lean perform the type conversion? Are the angles equivalent to \"begin... end\"?</p>\n<p>3) I tried, of course, LB3 :). However,<br>\ndef R : perm ℝ :=<br>\n{ to_fun := λ x, x^3,<br>\n  inv_fun := λ x, x^(1/3),<br>\n  left_inv := λ x, by simp ; ring,<br>\n  right_inv := λ x, by simp ; ring }</p>\n<p>and lean complains that (x^3)^(1/3) cannot be simplified. I grep'ed through deps/mathlib/src hoping to find something on real numbers, but failed.</p>",
        "id": 187950685,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1581452474
    },
    {
        "content": "<p>You can put code between triple backticks (```) to format it nicely.</p>",
        "id": 187952452,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1581453675
    },
    {
        "content": "<p>(1) Lean doesn't unfold definitions when checking whether <code>is_group_hom(LB2_map)</code> is non-empty, so we have to tell it explicitly.  Alternatively you can mark <code>LB2_map</code> as reducible (with <code>@[reducible] def LB2_map ...</code>) and then it will be unfolded.</p>",
        "id": 187952636,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1581453810
    },
    {
        "content": "<p>(2) These are \"anonymous constructors\". When providing any kind of tuple (for example an inhabitant of a <code>structure</code>) you can use it to provide the fields.</p>",
        "id": 187952747,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1581453878
    },
    {
        "content": "<p>I don't think Lean reads that <code>x^(1/3)</code> the way you would expect it.</p>",
        "id": 187953460,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581454337
    },
    {
        "content": "<p>I guess it uses division on natural number and makes it <code>x^0</code>. <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> can you help here?</p>",
        "id": 187953516,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581454377
    },
    {
        "content": "<p>I guess you need to tell lean that this one is a real number</p>",
        "id": 187954105,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581454707
    },
    {
        "content": "<p>Laurent, you need to read a bit more if you only played the natural number game and want to do more. Did  you get <a href=\"https://github.com/leanprover-community/tutorials/\" target=\"_blank\" title=\"https://github.com/leanprover-community/tutorials/\">https://github.com/leanprover-community/tutorials/</a> and played a bit with the unique lean file it contains? You should also read <a href=\"https://leanprover.github.io/theorem_proving_in_lean/index.html\" target=\"_blank\" title=\"https://leanprover.github.io/theorem_proving_in_lean/index.html\">Theorem Proving in Lean</a>. If you use VScode you can type Ctrl-Shift-p and then type doc (you should see in the menu Lean: Open documentation view) and then Enter. This will open the book webpage and allow you to try the examples right in VScode.</p>",
        "id": 187954126,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581454719
    },
    {
        "content": "<p>It doesn't. You probably want</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"err\">^</span><span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span>\n<span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"err\">^</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span>\n</pre></div>\n\n\n<p>but then the proofs of <code>left_inv</code> and <code>right_inv</code> are harder.</p>",
        "id": 187954146,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1581454731
    },
    {
        "content": "<p>I just checked, and there isn't actually a nice way to take cube roots in the reals right now. <code>rpow</code> is the function for reals to the power of reals, but it returns junk when the first real is negative (I think it will return the real part of one of the complex cube roots, but not the real cube root). There should probably be a theorem saying there are real nth roots of negative numbers when <code>n</code> is odd</p>",
        "id": 187954156,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1581454734
    },
    {
        "content": "<p>This is what I feared. Cube roots of real numbers are not used to solve the cap set problem or define perfectoid spaces.</p>",
        "id": 187954315,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581454808
    },
    {
        "content": "<p>mathlib is still very young and such embarrassing holes are not uncommon.</p>",
        "id": 187954394,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581454831
    },
    {
        "content": "<p>Is there a way to take derivatives, even only point-wise, for simple functions like polynomials? I just tried to, but couldn't get more than a <code>Prop</code> so far.</p>",
        "id": 187956947,
        "sender_full_name": "Daniel Keys",
        "timestamp": 1581456129
    },
    {
        "content": "<p>If <code>f</code> is a real function, <code>deriv f x</code> is the derivative of <code>f</code> at the point <code>x</code>.</p>",
        "id": 187962753,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1581459887
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span>   Right, that is what I did. What I mean is that I don't seem to be able to get a value, evaluation/reduction fails:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">calculus</span><span class=\"bp\">.</span><span class=\"n\">deriv</span>\n\n<span class=\"n\">def</span> <span class=\"n\">twoX</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">twoX</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">has_deriv_at</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">has_deriv_at</span> <span class=\"n\">twoX</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"c1\">-- type Prop</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">deriv</span> <span class=\"n\">twoX</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span>  <span class=\"c1\">-- type real</span>\n<span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"n\">deriv</span> <span class=\"n\">twoX</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"c1\">-- this fails</span>\n</pre></div>\n\n\n<p>Is there something I'm doing wrong?</p>",
        "id": 187963189,
        "sender_full_name": "Daniel Keys",
        "timestamp": 1581460330
    },
    {
        "content": "<p>You cannot use Lean to <code>#eval</code> or <code>#reduce</code> anything on the real numbers: they are not computable. You have to prove that it equals a value:</p>\n<div class=\"codehilite\"><pre><span></span>example : deriv twoX (2:ℝ) = 2 :=\n[...]\n</pre></div>",
        "id": 187964193,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1581461212
    },
    {
        "content": "<p>In proofs, you can use <code>norm_num</code> to compute with specific real numbers, like <code>example : (2:ℝ) + 3 = 5 := by norm_num</code>.<br>\nIt is imaginable that at some point we will have a similar tactic for computing derivatives, but that time is not now.</p>",
        "id": 187964339,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1581461355
    },
    {
        "content": "<p>OK, now it all makes sense!</p>",
        "id": 187964481,
        "sender_full_name": "Daniel Keys",
        "timestamp": 1581461450
    },
    {
        "content": "<p>In your manual proof, try using <code>deriv_add</code> and <code>deriv_id</code>.</p>",
        "id": 187964541,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1581461466
    },
    {
        "content": "<p>So do I need to prove for every point I am interested in?</p>",
        "id": 187964654,
        "sender_full_name": "Daniel Keys",
        "timestamp": 1581461516
    },
    {
        "content": "<p>You can do it for all real numbers at the same time:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">calculus</span><span class=\"bp\">.</span><span class=\"n\">deriv</span>\n\n<span class=\"n\">def</span> <span class=\"n\">twoX</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x</span>\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">deriv</span> <span class=\"n\">twoX</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">has_deriv_at</span><span class=\"bp\">.</span><span class=\"n\">deriv</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">has_deriv_at</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">has_deriv_at_id</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 187964981,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1581461825
    },
    {
        "content": "<p>This is very helpful, very glad I asked! Thanks <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span></p>",
        "id": 187965071,
        "sender_full_name": "Daniel Keys",
        "timestamp": 1581461894
    },
    {
        "content": "<p>I haven't really worked at all with <code>deriv</code> yet, but should we have (or is there?) a deriv rule simp set? Something like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">calculus</span><span class=\"bp\">.</span><span class=\"n\">deriv</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">deriv</span>\n\n<span class=\"n\">mk_simp_attribute</span> <span class=\"n\">deriv_simp</span> <span class=\"s2\">&quot;simp rules for deriv&quot;</span>\n\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"n\">deriv_simp</span><span class=\"o\">]</span> <span class=\"n\">differentiable_at_pow</span> <span class=\"n\">differentiable_at_const</span>\n  <span class=\"n\">deriv_add</span> <span class=\"n\">deriv_const</span> <span class=\"n\">deriv_pow</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">deriv</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"err\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"k\">with</span> <span class=\"n\">deriv_simp</span>\n</pre></div>",
        "id": 187965283,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1581462079
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> were we talking about something like this in Pittsburgh?</p>",
        "id": 187965319,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1581462122
    },
    {
        "content": "<p>Yes, we talked about this in relationship with the continuity tactic. I was afraid that, on more complicated examples with composition, the apply bug would show up and make a simpset not powerful enough and that one would need a dedicated tactic, but on this example the naive simpset idea works pretty well.</p>",
        "id": 187986786,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1581491678
    },
    {
        "content": "<p>The apply bug can now be fixed in lean 3.5.1, right?</p>",
        "id": 187987683,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581493044
    }
]
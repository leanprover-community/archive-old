[
    {
        "content": "<p>Suppose I have a theorem of the form:</p>\n<div class=\"codehilite\"><pre><span></span>constant P : X → Y → Prop\ntheorem existenceresult : ∀x:X, ∃y:Y, P x y := sorry\n</pre></div>\n\n\n<p>How can I define a function <code>f: X → Y</code> on the basis of <code>existenceresult</code>, such that <code>∀x:X, P x f(x)</code>?<br>\nI've looked at the reference manual on the axiom of choice, but I can't actually see how to do this using Lean's choice.</p>",
        "id": 193598774,
        "sender_full_name": "Chris M",
        "timestamp": 1586541639
    },
    {
        "content": "<p>You can use the <code>choose</code> tactic: <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#choose\" title=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#choose\">https://leanprover-community.github.io/mathlib_docs/tactics.html#choose</a></p>",
        "id": 193598831,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586541681
    },
    {
        "content": "<p>Is there a way to do it without tactics? (I a tactic is just a command for Lean to search for a proof that doesn't contain tactics, isn't it?)</p>",
        "id": 193599007,
        "sender_full_name": "Chris M",
        "timestamp": 1586541776
    },
    {
        "content": "<p>There is, you can use <code>classical.some</code> to define the function, and <code>classical.some_spec</code> to prove it has the property you want.</p>",
        "id": 193599232,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586541906
    },
    {
        "content": "<p>What you posted doesn't make sense right now, you have a theorem, but its conclusion isn't a Proposition.</p>",
        "id": 193599343,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586541955
    },
    {
        "content": "<p>Also see <code>classical.choice</code></p>",
        "id": 193599422,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1586541987
    },
    {
        "content": "<p>Yeah sorry, typo.</p>",
        "id": 193599434,
        "sender_full_name": "Chris M",
        "timestamp": 1586541991
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hP</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">∃</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"n\">include</span> <span class=\"n\">P</span> <span class=\"n\">hP</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">hP</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 193599512,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586542030
    },
    {
        "content": "<p>People around here get edgy about constants and axioms</p>",
        "id": 193599669,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586542086
    },
    {
        "content": "<p>Oh, why is that ?</p>",
        "id": 193599795,
        "sender_full_name": "Chris M",
        "timestamp": 1586542179
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hP</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">∃</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"n\">include</span> <span class=\"n\">P</span> <span class=\"n\">hP</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">hP</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">P</span> <span class=\"n\">hP</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span> <span class=\"o\">(</span><span class=\"n\">hP</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 193599804,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586542182
    },
    {
        "content": "<p>Mathlib doesn't have any and we don't really see why we need any.</p>",
        "id": 193599881,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586542205
    },
    {
        "content": "<p>But note that I just had to write <code>f P hP</code> instead of <code>f</code> :-)</p>",
        "id": 193599907,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586542222
    },
    {
        "content": "<p>I think once someone told me that they were problematic in some other way, maybe something doesn't work very well with them, but I was a beginner at the time and probably didn't understand what they were talking about</p>",
        "id": 193599984,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586542282
    },
    {
        "content": "<p>Why is <code>f P hP x</code> well formed? <code>f</code> takes an <code>X</code> but <code>P : X \\to Y \\to Prop</code>, and <code>P</code> can't take <code>hP</code> either right?</p>",
        "id": 193600208,
        "sender_full_name": "Chris M",
        "timestamp": 1586542425
    },
    {
        "content": "<p>I changed the brackets round X and Y to be the squiggly \"Lean will fill these in using unification\" brackets</p>",
        "id": 193600284,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586542458
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">section</span>\n\n<span class=\"kn\">parameters</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hP</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">∃</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">hP</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span> <span class=\"o\">(</span><span class=\"n\">hP</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>Here's another way which now looks beautiful</p>",
        "id": 193600364,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586542535
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">section</span>\n\n<span class=\"kn\">parameters</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hP</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">∃</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">hP</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span> <span class=\"o\">(</span><span class=\"n\">hP</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">foo</span> <span class=\"c1\">-- foo : ∀ (x : X), P x (f x)</span>\n\n<span class=\"kn\">end</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">foo</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">foo : ∀ (X Y : Type) (P : X → Y → Prop) (hP : ∀ (x : X), ∃ (y : Y), P x y)</span>\n<span class=\"cm\">  (x : X), P x (f X Y P hP x)</span>\n<span class=\"cm\">-/</span>\n</pre></div>\n\n\n<p>Inside the section the parameters are suppressed.</p>",
        "id": 193600472,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586542595
    },
    {
        "content": "<p>I think there's some kind of \"real Lean programmers don't use constants\" thing going on, and I don't really know why, but I try and stick to the general principle of no constants and no axioms</p>",
        "id": 193600565,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586542668
    },
    {
        "content": "<p><code>constant</code> is just another name for <code>axiom</code>, isn't it? So when you write <code>constant P : ...</code>, you're postulating the existence of such a <code>P</code> rather than stating a result about any such <code>P</code> (if they exist). The former is dangerous since you could postulate something that contradicts Lean's other axioms.</p>",
        "id": 193602049,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1586543584
    },
    {
        "content": "<p>The last couple of files make sense to me, thanks! I'm surprised though, after having just read about <code>{}</code> in the docs, that <code>f P hP x</code> works. I would have guessed that since <code>X,Y</code> are in <code>{}</code> brackets, but <code>P</code> and <code>hP</code> are not. I would have guessed that <code>f X Y x</code> would work, but it gives me \"<em>can't synthesize placeholder</em>\"</p>",
        "id": 193602198,
        "sender_full_name": "Chris M",
        "timestamp": 1586543651
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span>, is that different from assuming a <code>variable</code> that contradicts one of Lean's axioms?</p>",
        "id": 193602306,
        "sender_full_name": "Chris M",
        "timestamp": 1586543722
    },
    {
        "content": "<p>You're talking about before I switched to parameters? <code>{}</code> means \"just leave this out completely, I'll guess what it is\".</p>",
        "id": 193602324,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586543735
    },
    {
        "content": "<p>So when Lean sees <code>f P hP x</code> it reads <code>f _ _ P hP x</code> and then has to guess what the missing things are, and this is easy: for things to typecheck, if you look at the type of P, the missing things must be X and Y</p>",
        "id": 193602407,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586543778
    },
    {
        "content": "<p>The risk of using a constant is that you might be able to prove <code>false</code> outright. With a variable you can't, you can only prove \"forall (something), false\".</p>",
        "id": 193602482,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586543837
    },
    {
        "content": "<p>and if you can't actually feed in an example of the something, which you can't if Lean is consistent, then you can't prove false.</p>",
        "id": 193602514,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586543858
    },
    {
        "content": "<p>yeah, but since <code>P</code> and <code>hP</code> are NOT in <code>{}</code> but in <code>()</code>, I would guess that <code>f</code> would implicitly take the type <code>f: {X Y :Type} \\to (X\\to Y)</code>, so that <code>P</code> and <code>hP</code> can't be arguments.</p>",
        "id": 193602675,
        "sender_full_name": "Chris M",
        "timestamp": 1586543947
    },
    {
        "content": "<p>Oh that makes sense.</p>",
        "id": 193602707,
        "sender_full_name": "Chris M",
        "timestamp": 1586543967
    },
    {
        "content": "<p>Ok tomorrow I'll look at how to do it with classical.choice. Going to bed now, thanks a lot for the help!</p>",
        "id": 193603053,
        "sender_full_name": "Chris M",
        "timestamp": 1586544150
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284606\">Chris M</span> <a href=\"#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193602306\" title=\"#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193602306\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span>, is that different from assuming a <code>variable</code> that contradicts one of Lean's axioms?</p>\n</blockquote>\n<p>Yes! Consider this example:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">section</span>\n\n<span class=\"kn\">variable</span> <span class=\"n\">FALSE</span> <span class=\"o\">:</span> <span class=\"n\">false</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">everything_is_true</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"bp\">_</span> <span class=\"n\">FALSE</span>\n\n<span class=\"kn\">end</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">everything_is_true</span>\n<span class=\"c1\">-- `everything_is_true` says: Under the assumption that we have something of</span>\n<span class=\"c1\">-- type `false`, we can prove anything.</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">zero_eq_one</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">everything_is_true</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- To apply everything_is_true, we need to exhibit something of type `false`,</span>\n  <span class=\"c1\">-- but thankfully there&#39;s no such thing.</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n\n\n<span class=\"kn\">constant</span> <span class=\"n\">FALSE</span> <span class=\"o\">:</span> <span class=\"n\">false</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">everything_is_true&#39;</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"bp\">_</span> <span class=\"n\">FALSE</span>\n<span class=\"c1\">-- `everything_is_true&#39;` says: we can prove anything, no extra assumptions</span>\n<span class=\"c1\">-- needed. So now we&#39;re inconsistent.</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">zero_eq_one&#39;</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">everything_is_true&#39;</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 193603432,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1586544360
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193599669\" title=\"#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193599669\">said</a>:</p>\n<blockquote>\n<p>People around here get edgy about constants and axioms</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193599984\" title=\"#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193599984\">said</a>:</p>\n<blockquote>\n<p>I think once someone told me that they were problematic in some other way, maybe something doesn't work very well with them, but I was a beginner at the time and probably didn't understand what they were talking about</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193600565\" title=\"#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193600565\">said</a>:</p>\n<blockquote>\n<p>I think there's some kind of \"real Lean programmers don't use constants\" thing going on, and I don't really know why, but I try and stick to the general principle of no constants and no axioms</p>\n</blockquote>\n<p>Variables can be substituted. If you prove that \"for any variable G, a group structure on G induces a semigroup structure on G\", then you can use this \"theorem\" to deduce a semigroup structure on <code>units \\Z</code>; but if you have a constant G, a constant group structure on G, and a theorem that G has a semigroup structure, then you're in effect introducing to the world of Lean a new constant G that exists per fiat, and you cannot substitute it with <code>units \\Z</code></p>",
        "id": 193604844,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1586545089
    },
    {
        "content": "<p>Is it actually possible to define a function from ∀x, ∃y using <code>classical.choice</code>, instead of <code>classical.some</code>? I haven't heard of the <code>some</code> axiom in math, so it must be Lean-specific, and in math one would use choice for this.</p>",
        "id": 193692849,
        "sender_full_name": "Chris M",
        "timestamp": 1586664115
    },
    {
        "content": "<p>choice is a derived theorem from some more fundamental axioms assumed in Lean's classical library</p>",
        "id": 193693103,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1586664564
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">axiom_of_choice</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">some_spec</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n</pre></div>",
        "id": 193693104,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1586664568
    },
    {
        "content": "<p>er, I mean, the axiom of choice you are familiar with is derived from classical.choice. <code>classical.some</code> is similarly</p>",
        "id": 193693155,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1586664653
    },
    {
        "content": "<p>if I remember correctly, old versions of Lean didn't even use <code>classical.choice</code>, it was all derived from</p>",
        "id": 193693201,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1586664733
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">axiom</span> <span class=\"n\">strong_indefinite_description</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">//</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n</pre></div>",
        "id": 193693202,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1586664736
    },
    {
        "content": "<p>then at some point it got simplified because it was confusing people</p>",
        "id": 193693213,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1586664810
    },
    {
        "content": "<p>My first impression is that the problem with this is that we don't actually strictly speaking know that <code>strong_indefinite_description</code> is not stronger than choice? If we want to rigorously know that the <code>classical</code> axioms actually correspond to the classical axioms, then we should build <code>classical</code> from the same axioms that are used in mathematics?</p>",
        "id": 193693530,
        "sender_full_name": "Chris M",
        "timestamp": 1586665384
    },
    {
        "content": "<p>what is mathematics?</p>",
        "id": 193693826,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1586665974
    },
    {
        "content": "<p>ZFC set theory?</p>",
        "id": 193693827,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1586665981
    },
    {
        "content": "<p>but Lean's foundations are in the type theory, specifically the calculus of inductive constructions</p>",
        "id": 193693836,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1586665997
    },
    {
        "content": "<p>applying the axiom of choice as defined in set theory</p>",
        "id": 193693889,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1586666075
    },
    {
        "content": "<p>doesn't really make much sense</p>",
        "id": 193693890,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1586666080
    },
    {
        "content": "<p>I see</p>",
        "id": 193694012,
        "sender_full_name": "Chris M",
        "timestamp": 1586666366
    },
    {
        "content": "<p>In lean, it is easy to prove that <code>classical.choice</code> and <code>strong_indefinite_description</code> are equivalent in strength</p>",
        "id": 193695252,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586668687
    },
    {
        "content": "<p>(actually the proof that <code>strong_indefinite_description</code> follows from <code>choice</code> is not entirely obvious since it requires Diaconescu's proof of EM first)</p>",
        "id": 193695254,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586668735
    },
    {
        "content": "<p>As for whether they are equivalent to the axiom known as the \"axiom of choice\" in ZFC, this depends on some details of the foundational setup</p>",
        "id": 193695263,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586668779
    },
    {
        "content": "<p>lean's <code>choice</code> is actually closer to Hilbert's epsilon operator, or a variant of AC called \"global choice\", because it posits a single class function that chooses elements simultaneously from every nonempty set</p>",
        "id": 193695311,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586668843
    },
    {
        "content": "<p>The usual formulation of AC in ZFC puts the function that does the choosing behind an existential</p>",
        "id": 193695324,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586668892
    },
    {
        "content": "<p>However, it is well known that this is a conservative extension; the general process is known as Skolemization</p>",
        "id": 193695333,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586668920
    },
    {
        "content": "<p>In lean you actually can't prove <code>classical.choice</code> from the theorem <code>axiom_of_choice</code> mentioned above because of this</p>",
        "id": 193695439,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586669063
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284606\">Chris M</span> <a href=\"#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193692849\" title=\"#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193692849\">said</a>:</p>\n<blockquote>\n<p>Is it actually possible to define a function from ∀x, ∃y using <code>classical.choice</code>, instead of <code>classical.some</code>? I haven't heard of the <code>some</code> axiom in math, so it must be Lean-specific, and in math one would use choice for this.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"284606\">@Chris M</span> here are two interesting uses of <code>some</code> in Lean. For the first one, consider the proof that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X\\to Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> is a surjection then there's an injection <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">Y\\to X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span></span></span></span> which is a one-sided inverse. In Lean this construction is immediate using <code>some</code> -- you pick <code>y : Y</code> and then observe that we have a non-empty type of <code>x : X</code> to choose from and use <code>some</code> to pick one. In ZFC you would use choice for this. Here <code>choice</code> and <code>some</code> seem to be about the same.</p>\n<p>For the second one, consider the proof that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X\\to Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> is a <em>bijection</em> then there's a bijection <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">Y\\to X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span></span></span></span> which is a two-sided inverse. In Lean this construction is also made using <code>some</code> because even though we have a proof that the preimage contains exactly one term, the assertion has type <code>Prop</code>, whereas we need to move into the <code>Type</code> universe if we actually want the element. This whole <code>some</code> business can be thought of as a method of getting from Lean's proof-irrelevant <code>Prop</code> universe to the universe <code>Type</code> where data is remembered. The way <code>Prop</code> is modelled internally in Lean is that you can make a proof that the pre-image has exactly one element, but because this is in <code>Prop</code> the statement is just recorded by Lean as being proved, there is no information in the system as to what that element is and in particular there is no way of extracting it. This is a foundational issue where set theory and type theory seem to me to differ. Here when people talk about choice they often just mean the ability to move from <code>Prop</code> to <code>Type</code>. <code>some</code> is somehow the basic example of this.</p>",
        "id": 193701164,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586679972
    },
    {
        "content": "<p>very interesting. I am actually surprised though that <code>Prop</code> doesn't record that data, i.e. that propositional extentionality is used as an axiom. To put it a different way, I'm surprised that Choice is considered a classical notion. It seems to me that, according to the constructivist notion of <code>$\\exists$</code>, we only prove it once we have an example. Hence as soon as we've proven it, we do in fact have aconstructed example somewhere. Hence, shouldn't we be able to choose that example, without leaving constructivist logic? This argument basically makes me think that <code>$\\exists$</code> should just be a tuple like <code>$\\Sigma$</code>, i.e. that <code>$\\exists$</code> should just be syntactic sugar for, but otherwise identical to, <code>$\\Sigma$</code>, and that propositional extentionality shouldn't hold. I'm curious where people disagree with my view.</p>",
        "id": 193745488,
        "sender_full_name": "Chris M",
        "timestamp": 1586753870
    },
    {
        "content": "<p>This is the approach taken in more hardcore constructivist foundations like HoTT. There, there is no difference between Prop and Type</p>",
        "id": 193745604,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586754090
    },
    {
        "content": "<p>although propositional extensionality still holds in HoTT, for a different reason</p>",
        "id": 193745646,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586754127
    },
    {
        "content": "<p>In HoTT there is a version of choice that is trivial, and then there is another version that is equivalent to the mathematician's axiom of choice, which requires inserting propositional truncations to make the exists have this \"forgetting\" behavior</p>",
        "id": 193745661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586754193
    },
    {
        "content": "<p>In lean, the reason we care about having Prop around is <em>so that</em> we can forget about witnesses</p>",
        "id": 193745705,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586754253
    },
    {
        "content": "<p>This has to do with the semantics behind VM computation and \"proof erasure\"</p>",
        "id": 193745711,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586754287
    },
    {
        "content": "<p>proofs are generally not good for computation so it is nice to be able to forget about them in programs. Reflecting this back into the logic entails that proofs have to be irrelevant, and exists cannot record the witness that proved it</p>",
        "id": 193745733,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586754353
    },
    {
        "content": "<p>If you want a proof relevant version of exists, you can use <code>\\Sigma</code>, but it is a conscious decision you have to make. This gives you a little extra bit of expressive power</p>",
        "id": 193745799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586754423
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193745733\" title=\"#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193745733\">said</a>:</p>\n<blockquote>\n<p>proofs are generally not good for computation so it is nice to be able to forget about them in programs. Reflecting this back into the logic entails that proofs have to be irrelevant, and exists cannot record the witness that proved it</p>\n</blockquote>\n<p>What do you mean by \"proofs are generally not good for computation\"? In what sense?</p>",
        "id": 193745870,
        "sender_full_name": "Chris M",
        "timestamp": 1586754568
    },
    {
        "content": "<p>They represent pieces of code that have to be evaluated when the code is run; it can lead to large amounts of overhead and inefficiency</p>",
        "id": 193746356,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1586755497
    },
    {
        "content": "<p>If I have a vector of length <code>5</code>, say <code>[1,2,3,4,5]</code>, and want to turn it into a vector of length <code>3 + 2</code>, I can do so by applying a theorem that says that <code>3 + 2 = 5</code>. But there is no need to evaluate this proof (which boils down to <code>refl 5</code>) to get the resulting vector, because in memory the resulting vector has the exact same representation <code>[1,2,3,4,5]</code> so it is a no-op in the computer</p>",
        "id": 193746777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586756187
    },
    {
        "content": "<p>If equality is proof irrelevant, then this \"cast\" operation is always a no-op, and the computer can just skip the proof, even though it was provided and may very well be computable</p>",
        "id": 193746815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586756249
    },
    {
        "content": "<p>Here the proof is being used to ensure that the program does not go wrong, but it is not needed for the program to actually get to the end result</p>",
        "id": 193746866,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586756318
    },
    {
        "content": "<p>My impression is that a proof NEVER has to be evaluated. So it seems to me that if Lean just has a general rule that says \"never evaluate proofs\", then there is no danger of inefficiency. I might have some kind of misconception though.</p>",
        "id": 193748285,
        "sender_full_name": "Chris M",
        "timestamp": 1586759025
    },
    {
        "content": "<p>What's your notion of \"proof\", then, for which they never have to be evaluated?<br>\nIt sounds like you are suggesting that <code>\\exists</code> effectively shouldn't exist; but its purpose is precisely to be usable in this \"proof\" context.</p>",
        "id": 193748875,
        "sender_full_name": "Reid Barton",
        "timestamp": 1586760042
    },
    {
        "content": "<p>My notion of proof is basically, it's a program that could <em>in principle</em> be evaluated, but we are not actually interested in doing so, we are only interested in <em>type checking</em> it to see if it's correct. Once we know it's correct, we know the theorem is true, and that's all there is to it. No need to actually run the proof. Is that wrong?</p>",
        "id": 193748951,
        "sender_full_name": "Chris M",
        "timestamp": 1586760187
    },
    {
        "content": "<p>I'm not an expert in this area, but it sounds to me like this is right. Proofs are typechecked and then instantly forgotten</p>",
        "id": 193749026,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586760296
    },
    {
        "content": "<p>Okay but if you want to extract a function from \"∀x, ∃y\", then you are actually interested in evaluating the \"proof\" after all, right?</p>",
        "id": 193749029,
        "sender_full_name": "Reid Barton",
        "timestamp": 1586760300
    },
    {
        "content": "<p>I mean, if you want to be able to evaluate the function, you'd better be able to figure out what <code>y</code> was used to construct the existential and that means evaluating the term of type <code>∃y, ...</code> (we can call it a proof or not).</p>",
        "id": 193749145,
        "sender_full_name": "Reid Barton",
        "timestamp": 1586760475
    },
    {
        "content": "<p>So, in Lean, we do have some things called \"proofs\" that are never evaluated, namely terms whose type is a proposition, and <code>∃y, P y</code> is a proposition. That means that from <code>h : ∀x, ∃y, P y</code>there is no way to extract the data of \"the <code>y</code> for a given <code>x</code>\" (or any other data for that matter) and so you need a nonconstructive axiom if you want to obtain a function. Other systems make different choices.</p>",
        "id": 193749443,
        "sender_full_name": "Reid Barton",
        "timestamp": 1586760860
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193749029\" title=\"#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193749029\">said</a>:</p>\n<blockquote>\n<p>Okay but if you want to extract a function from \"∀x, ∃y\", then you are actually interested in evaluating the \"proof\" after all, right?</p>\n</blockquote>\n<p>Well, it seems to me that I want to extract a function but again not actually evaluate that function. I just want to use it to construct further proofs, all of which won't ever be evaluated.</p>",
        "id": 193749525,
        "sender_full_name": "Chris M",
        "timestamp": 1586760973
    },
    {
        "content": "<p>Then that's precisely what <code>choice</code> is for</p>",
        "id": 193749532,
        "sender_full_name": "Reid Barton",
        "timestamp": 1586761006
    },
    {
        "content": "<p>But if we're saying \"we know that there exists such a function, but we have no access to the function\", then I don't see how it could be called constructive</p>",
        "id": 193749615,
        "sender_full_name": "Reid Barton",
        "timestamp": 1586761090
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284606\">Chris M</span> <a href=\"#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193749525\" title=\"#narrow/stream/113489-new-members/topic/Define.20function.20from.20.E2.88.80x.2C.20.E2.88.83y.3F/near/193749525\">said</a>:</p>\n<blockquote>\n<p>Well, it seems to me that I want to extract a function but again not actually evaluate that function. I just want to use it to construct further proofs, all of which won't ever be evaluated.</p>\n</blockquote>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"c1\">-- x is out!</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">1 goal</span>\n<span class=\"cm\">X : Type,</span>\n<span class=\"cm\">P : X → Prop,</span>\n<span class=\"cm\">x : X,</span>\n<span class=\"cm\">hx : P x</span>\n<span class=\"cm\">⊢ ∃ (x : X), P x ∧ P x</span>\n<span class=\"cm\">-/</span>\n  <span class=\"n\">use</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">tauto</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 193750213,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586762218
    },
    {
        "content": "<p>You can get to the existential witness without choice if your goal is a proposition.</p>",
        "id": 193750222,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586762243
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">|</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">induction tactic failed, recursor &#39;Exists.dcases_on&#39; can only eliminate into Prop</span>\n<span class=\"cm\">-/</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>but not if your goal is data.</p>",
        "id": 193750288,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586762307
    },
    {
        "content": "<p>I was surprised to see how well Lean can compute, so I just wanted to share this with you. In <a href=\"https://github.com/leanprover-community/mathlib/issues/2398\" title=\"https://github.com/leanprover-community/mathlib/issues/2398\">#2398</a>, I introduce compositions of an integer, i.e., ways to decompose <code>n</code> as a sum of positive integers, as</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">composition</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">blocks_pnat</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"bp\">ℕ+</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">blocks_pnat_sum</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">blocks_pnat</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ+</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>In the course of the file, I register an explicit equiv between <code>composition n</code> and <code>fin (n-1)</code>, to get that the cardinality of <code>composition n</code> is <code>2^(n-1)</code>. After this, Lean can check numerical stuff on compositions! For instance, if you want to check the number of compositions of 9 with length  4 in which the first term is 2, you can ask</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">composition</span> <span class=\"mi\">9</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">nth_le</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">blocks</span> <span class=\"mi\">3</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">composition</span><span class=\"bp\">.</span><span class=\"n\">blocks_length</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">],</span> <span class=\"n\">norm_num</span> <span class=\"o\">}))</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">}</span>\n</pre></div>\n\n\n<p>It works, and answers 15 (I didn't check this is the right answer, but I hope we can trust Lean :). What surprises me is that there is a proof in the definition of the set, needed to show that the set makes sense, but this is not a problem at all for the computation.</p>",
        "id": 193753879,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1586766889
    }
]
[
    {
        "content": "<p>I'm trying to re-implement fixed length vector type <code>vec α n</code> as an exercise and wanted to know if I'm I approaching this correctly? <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<p>I start of with the following inductive definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">vec</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">},</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I've defined a <code>concat</code> function that concatenates two fixed length vectors in the obvious way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">concat</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"mi\">0</span> <span class=\"n\">m</span> <span class=\"n\">nil</span> <span class=\"n\">v₂</span> <span class=\"o\">:=</span>\n    <span class=\"kd\">begin</span>\n      <span class=\"n\">rw</span> <span class=\"n\">nat.zero_add</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">v₂</span><span class=\"o\">,</span>\n    <span class=\"kd\">end</span>\n <span class=\"bp\">|</span> <span class=\"n\">α</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">e</span> <span class=\"n\">v₁</span><span class=\"o\">)</span> <span class=\"n\">v₂</span> <span class=\"o\">:=</span>\n    <span class=\"kd\">begin</span>\n      <span class=\"n\">rw</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">add_comm</span> <span class=\"mi\">1</span> <span class=\"n\">_x</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">add_assoc</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">concat</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span><span class=\"o\">)),</span>\n    <span class=\"kd\">end</span>\n</code></pre></div>\n<p>as well as a function to convert a fixed length vector into a list:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">v2l</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">list</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"mi\">0</span> <span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">e</span> <span class=\"n\">vs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">e</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">v2l</span> <span class=\"n\">vs</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I'm not trying to show that the <code>concat</code> operation on fixed length vectors is equivalent to the <code>++</code> operator on lists:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">vec_concat_equiv</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v₁</span> <span class=\"n\">v₂</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">},</span>\n    <span class=\"n\">v2l</span> <span class=\"o\">(</span><span class=\"n\">concat</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">v2l</span> <span class=\"n\">v₁</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">v2l</span> <span class=\"n\">v₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">v₁</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span> <span class=\"n\">v2l</span>\n       <span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">list.append_eq_has_append</span>\n       <span class=\"o\">,</span> <span class=\"n\">list.append</span>\n       <span class=\"o\">,</span> <span class=\"n\">concat</span>\n    <span class=\"o\">],</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">concat</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">v2l</span><span class=\"o\">,</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span>\n</code></pre></div>\n<p>In the base case of this proof, the application of <code>eq.mpr</code>, introduced by the use of the <code>rw</code> tactic in the definition of concat, can be \"eliminated\" by the use of the <code>refl</code> tactic, however,  I cannot find a way of eliminating them in subterms of my goals as is required in the inductive case.</p>",
        "id": 295615127,
        "sender_full_name": "Julian Sutherland",
        "timestamp": 1661616523
    },
    {
        "content": "<p>You definition of <code>concat</code> is awkward because it goes against definitional equality: <code>m</code> is defeq to <code>m+0</code> but not to <code>0+m</code>, and <code>(n+m)+1</code> is defeq to <code>n+(m+1)</code> but not to <code>(n+1)+m</code>. So if you define <code>concat</code> by induction on the <code>vec α m</code> argument, you wouldn't need any rewrite. But in order to do so, you also need to switch the order of the two arguments of the constructor <code>vec.cons</code>, and the following works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">vec</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">},</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">vec</span>\n<span class=\"kd\">def</span> <span class=\"n\">concat</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">n</span> <span class=\"mi\">0</span> <span class=\"n\">v₁</span> <span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"n\">v₁</span>\n<span class=\"bp\">|</span> <span class=\"n\">α</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">v₁</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">v₂</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">concat</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span><span class=\"o\">)</span> <span class=\"n\">e</span>\n</code></pre></div>",
        "id": 295617385,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661617944
    },
    {
        "content": "<p>Usually the answer (and this is still something that is being discussed and researched and argued about) is that if you see <code>eq.rec</code> in goals, the design is \"wrong\" in some way and you should see how you can work around that (e.g. by making more things defeq, or by passing a proof obligation; e.g. a <code>concat</code> of typr <code>vec a n -&gt; vec a m -&gt; \\forall k, k = n + m -&gt; vec a k</code>)</p>",
        "id": 295617714,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1661618147
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> Thank you very much for your help, flipping the order of addition of <code>n</code> and <code>m</code> in the type of <code>concat</code> yields a much simpler definition by exploiting definitional equality:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">concat</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"mi\">0</span> <span class=\"n\">m</span> <span class=\"n\">nil</span> <span class=\"n\">v₂</span> <span class=\"o\">:=</span> <span class=\"n\">v₂</span>\n <span class=\"bp\">|</span> <span class=\"n\">α</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">e</span> <span class=\"n\">v₁</span><span class=\"o\">)</span> <span class=\"n\">v₂</span> <span class=\"o\">:=</span> <span class=\"n\">cons</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">concat</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>In turn, this definition allows for a simple proof of a (slight variation) of the statement above:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">vec_concat_equiv</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v₁</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v₂</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">m</span><span class=\"o\">},</span>\n    <span class=\"n\">v2l</span> <span class=\"o\">(</span><span class=\"n\">concat</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">v2l</span> <span class=\"n\">v₁</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">v2l</span> <span class=\"n\">v₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">v₁</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span> <span class=\"n\">v2l</span>\n       <span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">list.append_eq_has_append</span>\n       <span class=\"o\">,</span> <span class=\"n\">list.append</span>\n       <span class=\"o\">,</span> <span class=\"n\">concat</span>\n    <span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">concat</span><span class=\"o\">,</span> <span class=\"n\">v2l</span><span class=\"o\">,</span> <span class=\"n\">v2l</span><span class=\"o\">,</span> <span class=\"n\">v₁_ih</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span>\n</code></pre></div>\n<p>Note that above I had accidentally bound the vector lengths to be the same, which was impeding the induction on <code>v₁</code>.</p>\n<p><span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> Thank you for your advice, I'll strive to apply this rule in future :)</p>",
        "id": 295620469,
        "sender_full_name": "Julian Sutherland",
        "timestamp": 1661619809
    },
    {
        "content": "<p>I think a subtype like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/vector\">docs#vector</a> is much more robust to defeq issues than an inductive definition like yours, and that's probably why mathlib doesn't use your definition, and why <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin\">docs#fin</a> has much more API than <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin2\">docs#fin2</a> ...</p>",
        "id": 295621749,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661620636
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"453259\">@Julian Sutherland</span> By the way, it would be helpful having a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> for this since there are some missing commands to get it working (you can put it in a <code>spoiler</code> block at the end of a post if you want to keep the flow).</p>\n<p>Here's a way to get your original setup to work (with the generalization of <code>vec_concat_equiv</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">vec</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">},</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">vec</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">concat</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"mi\">0</span> <span class=\"n\">m</span> <span class=\"n\">nil</span> <span class=\"n\">v₂</span> <span class=\"o\">:=</span>\n    <span class=\"kd\">begin</span>\n      <span class=\"n\">rw</span> <span class=\"n\">nat.zero_add</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">v₂</span><span class=\"o\">,</span>\n    <span class=\"kd\">end</span>\n <span class=\"bp\">|</span> <span class=\"n\">α</span> <span class=\"n\">_</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">cons</span> <span class=\"n\">_</span> <span class=\"n\">n</span> <span class=\"n\">e</span> <span class=\"n\">v₁</span><span class=\"o\">)</span> <span class=\"n\">v₂</span> <span class=\"o\">:=</span>\n    <span class=\"kd\">begin</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">add_assoc</span><span class=\"o\">],</span>\n      <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">concat</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span><span class=\"o\">)),</span>\n    <span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">v2l</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">list</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"mi\">0</span> <span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">e</span> <span class=\"n\">vs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">e</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">v2l</span> <span class=\"n\">vs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">v2l_cast</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">v2l</span> <span class=\"o\">(</span><span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">v2l</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">subst</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">vec_concat_equiv</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v₁</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v₂</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">m</span><span class=\"o\">},</span>\n    <span class=\"n\">v2l</span> <span class=\"o\">(</span><span class=\"n\">concat</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">v2l</span> <span class=\"n\">v₁</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">v2l</span> <span class=\"n\">v₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">v₁</span> <span class=\"n\">generalizing</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">v2l</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">list.append_eq_has_append</span><span class=\"o\">,</span> <span class=\"n\">list.append</span><span class=\"o\">,</span> <span class=\"n\">concat</span><span class=\"o\">],</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">v2l_cast</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">concat</span><span class=\"o\">,</span> <span class=\"n\">v2l</span><span class=\"o\">],</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">eq_mpr_eq_cast</span><span class=\"o\">,</span> <span class=\"n\">cast_eq</span><span class=\"o\">,</span> <span class=\"n\">cast_cast</span><span class=\"o\">,</span> <span class=\"n\">list.cons_append</span><span class=\"o\">],</span>\n      <span class=\"n\">rw</span> <span class=\"n\">v2l_cast</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">v2l</span><span class=\"o\">,</span> <span class=\"n\">v₁_ih</span><span class=\"o\">],</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">add_assoc</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 295626682,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1661624095
    },
    {
        "content": "<p>The key tool is <code>v2l_cast</code>, which shows <code>v2l</code> is invariant under a certain kind of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cast\">docs#cast</a>. I'm using <code>cast</code> rather than <code>eq.mpr</code> since <a href=\"https://leanprover-community.github.io/mathlib_docs/find/eq_mpr_eq_cast\">docs#eq_mpr_eq_cast</a> is a simp lemma.</p>",
        "id": 295626762,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1661624158
    },
    {
        "content": "<p>Generally speaking, the way you deal with <code>eq.rec</code>, <code>eq.mpr</code>, and <code>cast</code> is that you find some way to turn the <code>eq</code> into a definitional equality (i.e., rewrite things until you have <code>a = b</code> such that <code>(rfl : a = b)</code>). The <code>v2l_cast</code> lemma is doing this by using <code>subst</code> so that the <code>cast</code> reduces away.</p>",
        "id": 295627019,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1661624321
    },
    {
        "content": "<p>Here's another way to do it, which is to create your own <code>cast</code> function (maybe more often named <code>copy</code>?) that is specialized to rewriting the indices of a type.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">vec</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">},</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">vec</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">vec.cast</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"n\">eq.rec</span> <span class=\"n\">v</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">vec.cast_cast</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n₁</span> <span class=\"n\">n₂</span> <span class=\"n\">n₃</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n₁</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n₁</span> <span class=\"bp\">=</span> <span class=\"n\">n₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">n₂</span> <span class=\"bp\">=</span> <span class=\"n\">n₃</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">v.cast</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"n\">h'</span> <span class=\"bp\">=</span> <span class=\"n\">v.cast</span> <span class=\"o\">(</span><span class=\"n\">h.trans</span> <span class=\"n\">h'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">subst_vars</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">vec.cast_rfl</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">v.cast</span> <span class=\"n\">rfl</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">concat</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"mi\">0</span> <span class=\"n\">m</span> <span class=\"n\">nil</span> <span class=\"n\">v₂</span> <span class=\"o\">:=</span> <span class=\"n\">v₂.cast</span> <span class=\"o\">(</span><span class=\"n\">nat.zero_add</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n <span class=\"bp\">|</span> <span class=\"n\">α</span> <span class=\"n\">_</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">e</span> <span class=\"n\">v₁</span><span class=\"o\">)</span> <span class=\"n\">v₂</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">concat</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">cast</span>\n    <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">add_assoc</span><span class=\"o\">])</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">v2l</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">list</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"mi\">0</span> <span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">e</span> <span class=\"n\">vs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">e</span> <span class=\"o\">::</span> <span class=\"n\">v2l</span> <span class=\"n\">vs</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">v2l_cast</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">v2l</span> <span class=\"o\">(</span><span class=\"n\">v.cast</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">v2l</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">subst</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">vec_concat_equiv</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v₁</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v₂</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">m</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">v2l</span> <span class=\"o\">(</span><span class=\"n\">concat</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">v2l</span> <span class=\"n\">v₁</span> <span class=\"bp\">++</span> <span class=\"n\">v2l</span> <span class=\"n\">v₂</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">v₁</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">v2l</span><span class=\"o\">,</span> <span class=\"n\">concat</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">v2l</span><span class=\"o\">,</span> <span class=\"n\">concat</span><span class=\"o\">,</span> <span class=\"n\">v₁_ih</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 295627837,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1661624811
    },
    {
        "content": "<p>I like how these <code>cast</code>/<code>copy</code> functions tend to work out, since they lead to proofs that are mostly just <code>simp</code>. The key to its operation is that it syntactically gives you a proof that the indices are equal right in the <code>vec.cast</code> expression, which is what proofs about <code>vec.cast</code> can then make use of by a simple <code>subst</code> many times.</p>",
        "id": 295628042,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1661624929
    },
    {
        "content": "<p>If you write your simp lemmas to \"bubble up\" the casts to the top level of the expression, then you have a good shot at eliminating them completely. For example, <code>v2l</code> is able to consume them via <code>v2l_cast</code>.</p>",
        "id": 295628308,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1661625083
    }
]
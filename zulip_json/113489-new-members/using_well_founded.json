[
    {
        "content": "<p>I have a rather complicated recursive function and I'm having trouble getting Lean to accept the recursion. Hoping to get some advice. Below is a fake version that has enough of the same structure to illustrate my issue. When the third case hits, it uses <code>f</code> to select another element. Several facts seem relevant:<br>\n<code>E</code> is a fintype, so I can't keep decreasing forever.<br>\nApplying <code>f</code> will immediately land me in one of the previous non-recursive cases, so in fact, there should only ever be one recursive call.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">my_section</span>\n\n<span class=\"kd\">parameters</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">t1</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">E</span>\n<span class=\"bp\">|</span> <span class=\"n\">t2</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">E</span>\n<span class=\"bp\">|</span> <span class=\"n\">t3</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">E</span>\n<span class=\"kn\">open</span> <span class=\"n\">E</span>\n\n<span class=\"kd\">parameters</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- This mimic real parts of the file</span>\n<span class=\"kd\">parameter</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">E</span><span class=\"o\">)</span>\n<span class=\"kd\">parameter</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">t3</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">t3</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n<span class=\"kd\">parameter</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">t3</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">t1</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">t3</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">t2</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cs</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">t1</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">12</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">t2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">37</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">t3</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"c1\">--tried: have f (t3 n) &lt; (t3 n), from h n,</span>\n   <span class=\"n\">cs</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">t3</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n<span class=\"c1\">--tried: using_well_founded {dec_tac := `[tactic.assumption]}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">my_section</span>\n</code></pre></div>",
        "id": 267793628,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1642025527
    },
    {
        "content": "<p>If you use the fintype derive handler you can prove that <code>E</code> is a fintype rather than adding it as a parameter, unfortunately it doesn't work if <code>N</code> is a parameter, only a variable (parameters aren't really used so much in mathlib for this sort of reason)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.derive_fintype</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">my_section</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[derive fintype]</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">t1</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">E</span>\n<span class=\"bp\">|</span> <span class=\"n\">t2</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">E</span>\n<span class=\"bp\">|</span> <span class=\"n\">t3</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">E</span>\n<span class=\"kn\">open</span> <span class=\"n\">E</span>\n</code></pre></div>",
        "id": 267795031,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1642026064
    },
    {
        "content": "<p>Hopefully in your actual proof the <code>&lt;</code> is a partial order (or preorder). In that case, this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">my_section</span>\n\n<span class=\"kd\">parameters</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">t1</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">E</span>\n<span class=\"bp\">|</span> <span class=\"n\">t2</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">E</span>\n<span class=\"bp\">|</span> <span class=\"n\">t3</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">E</span>\n<span class=\"kn\">open</span> <span class=\"n\">E</span>\n\n<span class=\"kd\">parameters</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- This mimic real parts of the file</span>\n<span class=\"kd\">parameter</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">E</span><span class=\"o\">)</span>\n<span class=\"kd\">parameter</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">t3</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">t3</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n<span class=\"kd\">parameter</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">t3</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">t1</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">t3</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">t2</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cs</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">t1</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">12</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">t2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">37</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">t3</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">have</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">t3</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">t3</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"n\">h</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n   <span class=\"n\">cs</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">t3</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n<span class=\"n\">using_well_founded</span> <span class=\"o\">{</span> <span class=\"n\">rel_tac</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">exact</span> <span class=\"o\">⟨(</span><span class=\"bp\">&lt;</span><span class=\"o\">),</span>  <span class=\"n\">fintype.preorder.well_founded</span><span class=\"o\">⟩],</span>\n                     <span class=\"n\">dec_tac</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">tactic.assumption</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>I also had to tell Lean w.r.t. what relation the recursion is decreasing and why it is well-founded (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/fintype.preorder.well_founded\">docs#fintype.preorder.well_founded</a>)</p>",
        "id": 267795332,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1642026204
    },
    {
        "content": "<p>Interesting! I didn't know about <code>derive fintype</code>. Since I didn't want to bother proving it for the purposes of a mwe I just added it as a parameter. Good to know I didn't need to do any work.</p>",
        "id": 267795370,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1642026229
    },
    {
        "content": "<p>It is a partial order! Let me go try that and study it a bit to understand it.</p>",
        "id": 267795450,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1642026266
    },
    {
        "content": "<p>I was searching everywhere for something like <code>fintype.preorder.well_founded</code> but couldn't get the docs search to turn it up. That's exactly what I need. Thanks!</p>",
        "id": 267795789,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1642026498
    },
    {
        "content": "<p>Maybe I'm missing something or the MWE is  too minimal, but if as soon as it hits t3 it goes straight to one of the other cases then you can define a function which will have the same equational properties without worrying about well_founded, or a relation on <code>E</code> at all</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.derive_fintype</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">my_section</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[derive fintype]</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">t1</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">E</span>\n<span class=\"bp\">|</span> <span class=\"n\">t2</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">E</span>\n<span class=\"bp\">|</span> <span class=\"n\">t3</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">E</span>\n<span class=\"kn\">open</span> <span class=\"n\">E</span>\n\n<span class=\"c1\">--variable [has_lt (E N)]</span>\n\n<span class=\"c1\">-- This mimic real parts of the file</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n<span class=\"c1\">-- variable (h : ∀ (n : N), f (t3 n) &lt; (t3 n))</span>\n<span class=\"c1\">-- variable (h1 : ∀ (n : N), f (t3 n) = (t1 n) ∨ f (t3 n) = (t2 n))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cs_aux</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">t1</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">12</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">t2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">37</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">t3</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">cs_aux</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">t3</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">t3</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cs</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">cs_aux</span> <span class=\"n\">N</span> <span class=\"n\">f</span> <span class=\"mi\">1</span>\n<span class=\"kd\">end</span> <span class=\"n\">my_section</span>\n</code></pre></div>",
        "id": 267795903,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1642026573
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"300396\">Paul Rowe</span> <a href=\"#narrow/stream/113489-new-members/topic/using_well_founded/near/267795789\">said</a>:</p>\n<blockquote>\n<p>I was searching everywhere for something like <code>fintype.preorder.well_founded</code> but couldn't get the docs search to turn it up. That's exactly what I need. Thanks!</p>\n</blockquote>\n<p>I got it by searching for <code>​well_founded_of_fintype</code> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/well_founded_of_fintype\">https://leanprover-community.github.io/mathlib_docs/find/well_founded_of_fintype</a></p>",
        "id": 267796253,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1642026721
    },
    {
        "content": "<p>usually if you search for the names of what you want and what you have, separated by an underscore, the search engine will find it.</p>",
        "id": 267796476,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1642026765
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span>  Interesting idea. It's true that the mwe is much more minimal than the real thing. In fact, it does a few case splits on facts that might be true of the argument. So it might take some work for me to figure out the right aux function.</p>",
        "id": 267796921,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1642026939
    },
    {
        "content": "<p>I honestly didn't think about the fact that it should only ever have at most one recursive call until I was writing up the question!</p>",
        "id": 267797023,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1642026985
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/113489-new-members/topic/using_well_founded/near/267796476\">said</a>:</p>\n<blockquote>\n<p>usually if you search for the names of what you want and what you have, separated by an underscore, the search engine will find it.</p>\n</blockquote>\n<p>Yeah, I was trying to do things like that. I must have just missed the right combinations. Thanks for the advice though!</p>",
        "id": 267797145,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1642027080
    }
]
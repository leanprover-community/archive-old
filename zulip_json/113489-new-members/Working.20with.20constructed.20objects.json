[
    {
        "content": "<p>Hi, this is kind of a vague question. Sometimes I end up constructing an object in a convoluted way using lots of scaffolding involving things like auxiliary functions, <code>classical.some</code> and <code>nat.find</code> and whatever, and I then need to prove properties of this object. Then the proof of the property ends up looking exactly like the construction with <code>classical.some_spec</code> and <code>nat.find_spec</code> and <code>nat.find_eq_iff</code> and so on instead at the same places, and there is a lot of repetition, which feels sad.</p>\n<p>At the moment I end up with code like this,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">thing_aux</span> <span class=\"o\">(</span><span class=\"n\">assumptions</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">P1</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">P2</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">P3</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">thing</span> <span class=\"o\">(</span><span class=\"n\">assumptions</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">thing_aux</span> <span class=\"o\">(</span><span class=\"n\">assumptions</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prop1</span> <span class=\"o\">{</span><span class=\"n\">assumptions</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">P1</span> <span class=\"o\">(</span><span class=\"n\">thing</span> <span class=\"o\">(</span><span class=\"n\">assumptions</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">thing_aux</span> <span class=\"o\">(</span><span class=\"n\">assumptions</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">prop.1</span>\n</code></pre></div>\n<p>and so on, which feels a little bit better because the scaffolding needs to be constructed only once, but I feel like there must be a nicer way to proceed. What is the recommended best practice?</p>",
        "id": 270983567,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1644243212
    },
    {
        "content": "<p>I think this is close to optimal.</p>",
        "id": 270983885,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1644243341
    },
    {
        "content": "<p>You could imagine that after you have <code>thing_aux</code>, it should be a one-liner to extract <code>thing</code>, <code>prop1</code>, <code>prop2</code>, etc...</p>",
        "id": 270983993,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1644243376
    },
    {
        "content": "<p>Coincidentally, <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> recently wrote an <code>unpack</code> command for approximately that scenario. I'll copy his code here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Exists.some</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">classical.some</span> <span class=\"n\">h</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Exists.some_spec</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">h.some</span> <span class=\"o\">:=</span> <span class=\"n\">classical.some_spec</span> <span class=\"n\">h</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">open</span> <span class=\"n\">lean.parser</span> <span class=\"n\">interactive.types</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">inductive</span> <span class=\"n\">tuple</span>\n<span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">name</span> <span class=\"bp\">→</span> <span class=\"n\">tuple</span>\n<span class=\"bp\">|</span> <span class=\"n\">many</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">tuple</span> <span class=\"bp\">→</span> <span class=\"n\">tuple</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">tuple_parser</span> <span class=\"o\">:</span> <span class=\"n\">lean.parser</span> <span class=\"n\">tuple</span>\n<span class=\"bp\">|</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">tuple.one</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">ident_</span> <span class=\"bp\">&lt;|&gt;</span>\n  <span class=\"n\">brackets</span> <span class=\"s2\">\"⟨\"</span> <span class=\"s2\">\"⟩\"</span> <span class=\"o\">(</span><span class=\"n\">tuple.many</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">sep_by</span> <span class=\"o\">(</span><span class=\"n\">skip_info</span> <span class=\"o\">(</span><span class=\"n\">tk</span> <span class=\"s2\">\",\"</span><span class=\"o\">))</span> <span class=\"n\">tuple_parser</span><span class=\"o\">))</span> <span class=\"n\">e</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">tuple.split</span> <span class=\"o\">:</span> <span class=\"n\">tuple</span> <span class=\"bp\">→</span> <span class=\"n\">name</span> <span class=\"bp\">⊕</span> <span class=\"o\">(</span><span class=\"n\">tuple</span> <span class=\"bp\">×</span> <span class=\"n\">tuple</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">tuple.one</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sum.inl</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">tuple.many</span> <span class=\"o\">[])</span> <span class=\"o\">:=</span> <span class=\"n\">sum.inl</span> <span class=\"bp\">`</span><span class=\"n\">_</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">tuple.many</span> <span class=\"o\">[</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">t2</span><span class=\"o\">])</span> <span class=\"o\">:=</span> <span class=\"n\">sum.inr</span> <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">t2</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">tuple.many</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">::</span> <span class=\"n\">ts</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">sum.inr</span> <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">tuple.many</span> <span class=\"n\">ts</span><span class=\"o\">)</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">run_unpack</span> <span class=\"o\">:</span> <span class=\"n\">tuple</span> <span class=\"bp\">→</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">lean.parser</span> <span class=\"n\">unit</span>\n<span class=\"bp\">|</span> <span class=\"n\">t</span> <span class=\"n\">ty</span> <span class=\"n\">pr</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">t.split</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">sum.inl</span> <span class=\"bp\">`</span><span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n  <span class=\"bp\">|</span> <span class=\"n\">sum.inl</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"n\">ty</span> <span class=\"bp\">←</span> <span class=\"n\">pp</span> <span class=\"n\">ty</span><span class=\"o\">,</span>\n    <span class=\"n\">pr</span> <span class=\"bp\">←</span> <span class=\"n\">pp</span> <span class=\"n\">pr</span><span class=\"o\">,</span>\n    <span class=\"n\">with_input</span> <span class=\"n\">command_like</span> <span class=\"n\">sformat</span><span class=\"bp\">!</span><span class=\"s2\">\"lemma {n} : {ty} := {pr}\"</span><span class=\"o\">,</span>\n    <span class=\"n\">pure</span> <span class=\"o\">()</span>\n  <span class=\"bp\">|</span> <span class=\"n\">sum.inr</span> <span class=\"o\">(</span><span class=\"n\">t₁</span><span class=\"o\">,</span> <span class=\"n\">t₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">ty</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Exists</span> <span class=\"bp\">%%</span><span class=\"o\">(</span><span class=\"n\">expr.lam</span> <span class=\"n\">_</span> <span class=\"n\">bi</span> <span class=\"n\">d</span> <span class=\"n\">ty</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n      <span class=\"n\">sum.inl</span> <span class=\"n\">n</span> <span class=\"bp\">←</span> <span class=\"n\">pure</span> <span class=\"n\">t₁.split</span> <span class=\"bp\">|</span> <span class=\"n\">fail</span> <span class=\"s2\">\"pattern matching exists not supported\"</span><span class=\"o\">,</span>\n      <span class=\"n\">pd</span> <span class=\"bp\">←</span> <span class=\"n\">pp</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n      <span class=\"n\">ppr</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">mk_app</span> <span class=\"bp\">``</span><span class=\"n\">Exists.some</span> <span class=\"o\">[</span><span class=\"n\">pr</span><span class=\"o\">]</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">pp</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n      <span class=\"n\">with_input</span> <span class=\"n\">command_like</span> <span class=\"n\">sformat</span><span class=\"bp\">!</span><span class=\"s2\">\"def {n} : {pd} := {ppr}\"</span><span class=\"o\">,</span>\n      <span class=\"n\">var</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">resolve_name</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">to_expr</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n      <span class=\"n\">mk_app</span> <span class=\"bp\">``</span><span class=\"n\">Exists.some_spec</span> <span class=\"o\">[</span><span class=\"n\">pr</span><span class=\"o\">]</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">run_unpack</span> <span class=\"n\">t₂</span> <span class=\"o\">(</span><span class=\"n\">ty.instantiate_var</span> <span class=\"n\">var</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">%%</span><span class=\"n\">ty₁</span> <span class=\"bp\">∧</span> <span class=\"bp\">%%</span><span class=\"n\">ty₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n      <span class=\"n\">mk_app</span> <span class=\"bp\">``</span><span class=\"n\">and.left</span> <span class=\"o\">[</span><span class=\"n\">pr</span><span class=\"o\">]</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">run_unpack</span> <span class=\"n\">t₁</span> <span class=\"n\">ty₁</span><span class=\"o\">,</span>\n      <span class=\"n\">mk_app</span> <span class=\"bp\">``</span><span class=\"n\">and.right</span> <span class=\"o\">[</span><span class=\"n\">pr</span><span class=\"o\">]</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">run_unpack</span> <span class=\"n\">t₂</span> <span class=\"n\">ty₂</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">fail</span> <span class=\"s2\">\"pattern matching on this type not supported\"</span>\n    <span class=\"kd\">end</span>\n  <span class=\"kd\">end</span>\n\n<span class=\"kd\">@[user_command]</span> <span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">unpack</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">interactive.parse</span> <span class=\"o\">(</span><span class=\"n\">tk</span> <span class=\"s2\">\"unpack\"</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">lean.parser</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">args</span> <span class=\"bp\">←</span> <span class=\"n\">tuple_parser</span><span class=\"o\">,</span>\n  <span class=\"n\">tk</span> <span class=\"s2\">\":=\"</span><span class=\"o\">,</span>\n  <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">lean.parser.pexpr</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">tactic.to_expr</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n  <span class=\"n\">ty</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">infer_type</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">tactic.set_options</span> <span class=\"bp\">$</span> <span class=\"n\">options.mk.set_bool</span> <span class=\"bp\">`</span><span class=\"n\">pp.all</span> <span class=\"n\">tt</span><span class=\"o\">,</span>\n  <span class=\"n\">run_unpack</span> <span class=\"n\">args</span> <span class=\"n\">ty</span> <span class=\"n\">e</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">tactic</span>\n</code></pre></div>",
        "id": 270984147,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1644243458
    },
    {
        "content": "<p>It might be possible to adapt this so that it doesn't only work with <code>∃</code> but also with subtypes.</p>",
        "id": 270984258,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1644243509
    },
    {
        "content": "<p>But it is currently beyond my tactic writing skills.</p>",
        "id": 270984276,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1644243525
    },
    {
        "content": "<p>Nice! Going back and forth between exists and subtype with <code>subtype.exists_of_subtype</code> and <code>classical.subtype_of_exists</code> is always an option, I only chose the subtype because I got the impression that it was better to confine the classical part to one lemma rather than to use <code>some</code> all over the place.</p>",
        "id": 270985179,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1644243960
    }
]
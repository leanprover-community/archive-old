[
    {
        "content": "<p>In a separate thread I'm discussing the design of an affine space library. That's the context for this question. I need a mutually inductive definition of several types. I'm getting the following error message:</p>\n<div class=\"codehilite\"><pre><span></span>mutually inductive types compiled to invalid basic inductive type\nnested exception message:\nuniverse level of type_of(arg #4) of &#39;apoint._mut_.mk_0&#39; is too big for the corresponding inductive datatypeLean\n</pre></div>\n\n\n<p>The question is a basic one: how to debug this problem? It looks like I need to look at the compiled definition. Is that right? In that case, how? Or if it's obvious what's going wrong, I'd be happy simply to know the solution to this blocking problem, at least for right now.  I'm not posting the code at this point, hoping for insights without doing that, until the code's in better shape.</p>",
        "id": 167726011,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1560130235
    },
    {
        "content": "<p>use <code>Type*</code> instead of manually calculating the universe</p>",
        "id": 167726084,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1560130368
    },
    {
        "content": "<p>could you show the definition?</p>",
        "id": 167726246,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560130657
    },
    {
        "content": "<p>or at least the inductive itself, MWE not required</p>",
        "id": 167726299,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560130710
    },
    {
        "content": "<blockquote>\n<p>or at least the inductive itself, MWE not required</p>\n</blockquote>\n<div class=\"codehilite\"><pre><span></span>mutual inductive apoint, avector, aframe\n\nwith apoint :\n    Π (s : space), Type\n| mk :                      -- any point\n    Π {s : space}\n      (d : ℕ) [has_zero (fin d)]\n      (K: Type) [discrete_field K]\n      (coords : { c : tuple (d+1) K // c.nth 0 = 1 }),\n      apoint s\n| mk_std :\n    Π { s : space }         -- std point, (1, 0, 0, ..., 0)\n      (d : ℕ) [has_zero (fin d)]\n      (K: Type) [discrete_field K],\n      apoint s\n\nwith avector :\n    Π (s : space), Type\n| mk :\n    Π {s : space}\n      (d : ℕ) [has_zero (fin d)]\n      (K: Type) [discrete_field K]\n      (coords : { c : tuple (d+1) K // c.nth 0 = 1 }),\n      avector s     -- was: aframe s → scalar → avector s\n| mk_std :\n    Π { s : space }         -- std vector(0, 0, 0, ..., 0)\n      (d : ℕ) [has_zero (fin d)]\n      (K: Type) [discrete_field K],\n      avector s\n\nwith aframe :\n    Π (s : space), Type\n| mk : Π { s : space }, apoint s → avector s → aframe s\n| mk_std : Π { s : space }, aframe s -- not yet complete\n</pre></div>\n\n\n<p>If I use Type*, I get an error at the end about inductive types having to live in the same universe.</p>",
        "id": 167727591,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1560132899
    },
    {
        "content": "<p>It has a few things that need fixing, but this should give the idea.</p>",
        "id": 167727972,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1560133559
    },
    {
        "content": "<p>Change the types of <code>apoint</code>, <code>avector</code> and <code>aframe</code> to <code>space → Type (u+1)</code>(this is the same as <code>Π (s : space), Type (u+1)</code>), and change the types of all <code>K</code>s to <code>Type u</code>. If you don't like to worry about universe levels, you can set <code>u</code> to <code>0</code> (so only use <code>Type</code> - which is <code>Type 0</code> - and <code>Type 1</code>).</p>",
        "id": 167728689,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1560134651
    },
    {
        "content": "<p>Here is a simplified version of your MWE:</p>\n<div class=\"codehilite\"><pre><span></span>universe variable u\nconstant space : Type\n\nmutual inductive apoint, avector, aframe\n\nwith apoint :\n    Π (s : space), Type (u+1)\n| mk :                      -- any point\n    Π {s : space}\n      (d : ℕ) [has_zero (fin d)]\n      (K: Type u) [discrete_field K],\n      apoint s\n| mk_std :\n    Π { s : space }         -- std point, (1, 0, 0, ..., 0)\n      (d : ℕ) [has_zero (fin d)]\n      (K: Type u) [discrete_field K],\n      apoint s\n\nwith avector :\n    Π (s : space), Type (u+1)\n| mk :\n    Π {s : space}\n      (d : ℕ) [has_zero (fin d)]\n      (K: Type u) [discrete_field K],\n      avector s     -- was: aframe s → scalar → avector s\n| mk_std :\n    Π { s : space }         -- std vector(0, 0, 0, ..., 0)\n      (d : ℕ) [has_zero (fin d)]\n      (K: Type u) [discrete_field K],\n      avector s\n\nwith aframe :\n    Π (s : space), Type (u+1)\n| mk : Π { s : space }, apoint s → avector s → aframe s\n| mk_std : Π { s : space }, aframe s -- not yet complete\n</pre></div>",
        "id": 167728693,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1560134681
    },
    {
        "content": "<p>here is a simplified simplified version:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"n\">mutual</span> <span class=\"kn\">inductive</span> <span class=\"n\">apoint</span><span class=\"o\">,</span> <span class=\"n\">aframe</span>\n<span class=\"k\">with</span> <span class=\"n\">apoint</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"n\">apoint</span>\n<span class=\"k\">with</span> <span class=\"n\">aframe</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"n\">apoint</span> <span class=\"bp\">→</span> <span class=\"n\">aframe</span>\n</pre></div>",
        "id": 167728708,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1560134738
    },
    {
        "content": "<p>I'm coming back to this.  I'm having another problem knowing what an error message involving mutually defined types means. The context: I'm defining an affine space abstract data type. An affine space has points, vectors, frames. Points and vectors have coordinates and a frame. A frame has a point (origin) and a set of vectors (basis). </p>\n<p>The problem, in the logic below, is that if (as I need to do) I change the type of <a href=\"http://affine_frame.mk\" target=\"_blank\" title=\"http://affine_frame.mk\">affine_frame.mk</a>, from taking a point and a single vector to taking a point and a list of vectors (representing a basis), then I get the following error at the top of the inductive definition: </p>\n<div class=\"codehilite\"><pre><span></span>nested occurrence &#39;list.{1} (affine_vector s)&#39; contains variables that are not parameters\n</pre></div>\n\n\n<p>What variables are meant here? What have I done wrong? And how might I fix it? Thank you!</p>\n<p>Here's the self-contained code (which I'll be putting in an open GitHub repo once it works).</p>\n<div class=\"codehilite\"><pre><span></span>import algebra.module\nimport data.vector\n\n-- for testing\nimport data.real.basic\nset_option pp.notation false\n\n\n-- UNDERLYING REPRESENTATION\n\n--universe u\n\n/-\nBackground: the &quot;vector&quot; type in the Lean standard library\nis a type whose values are really just tuples. We define\na &quot;tuple&quot; type polymorphic as the type of tuples of length\nn over values of a type, K.\n-/\ndef tuple\n    (n : ℕ)\n    (K : Type) :=\n        vector K n\n\n-- testing\ndef aTuple : tuple 3 ℝ := ⟨[2,1,-1], rfl⟩\ndef aTuple&#39; : tuple 1 ℝ := ⟨[2], rfl⟩\n\n/-\nWith K a discrete field with zero and one values,\nwe define a function to return tuples of length n\nover K with all elements equal to the field&#39;s zero\nelement.\n-/\ndef mk_zero_tuple :\n    ∀ (n : ℕ)\n    (K : Type)\n    [f : discrete_field K]\n    [z : has_zero K],\n        vector K n\n| 0 K f z := vector.nil\n| (nat.succ n&#39;) K f z := vector.cons (z.zero) (@mk_zero_tuple n&#39; K f z)\n\n-- testing\ndef aReal3ZeroTuple : tuple 3 ℝ :=\n    subtype.mk [0,0,0] rfl\ndef aReal4ZeroTuple : tuple 4 ℝ :=\n    subtype.mk [0,0,0,0] rfl\n\n\nstructure space : Type 1 :=\nmk ::\n(name : string)\n(dim : ℕ)\n(field: Type)\n[isField : discrete_field field]\n[the_zero : has_zero field]\n[the_one : has_one field]\n\n-- testing\n\ndef time : space :=         -- non-computable\n    space.mk &quot;time&quot; 1 ℝ\n\ndef geometry : space :=\n    space.mk &quot;geometry&quot; 3 ℝ\n\n/-\nWe define affine point, vector, and frame types.\nThe space to which each such object belongs is a\npart of its type. The definitions are mutually\nrecursive, because point and a vector are defined\npartly in terms of a frame (in terms of which its\ncoordinates are interpreted), and a frame in turn\nis defined by a point (its origin) and a tuple of\nvectors (comprising a basis for its vector space).\n-/\n\nmutual inductive affine_point, affine_vector, affine_frame\nwith affine_point : space → Type 1\n    | mk :\n        Π { s : space },\n        affine_frame s →\n        tuple s.dim s.field  → affine_point s\n    | mk_std :\n        Π { s : space },         -- std point, (1, 0, 0, ..., 0) wrt std_frame\n        affine_point s\nwith affine_vector : space → Type 1\n    | mk :\n        Π {s : space},\n        affine_frame s →\n        tuple s.dim s.field →\n        affine_vector s\n    | mk_std :\n        Π { s : space },        -- std vector(0, 0, 0, ..., 0) wrt std_frame\n        affine_vector s\nwith affine_frame : space → Type 1\n    | mk : Π { s : space }, affine_point s → list (affine_vector s) → affine_frame s -- stub\n    | mk_std : Π { s : space },  affine_frame s  -- std frame\n</pre></div>\n\n\n<p>I've tried with a universe variable, u, substituting Type (u+1), and also Type (u+2), for Type 1 where it appears in the mutual definition, to no avail. Thanks, all, for your ongoing help with this stuff.</p>\n<p>Kevin</p>",
        "id": 168450627,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1560888440
    },
    {
        "content": "<p>I've done a bunch of maths in Lean and I have never once had to use a mutually inductive type. I know nothing about them and this is why I can't help. Is there any way of just taking things apart and defining some normal inductive types?</p>",
        "id": 168492943,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560938399
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209463\">@Ben Leedom</span> and I were faced with a mutual inductive definition when trying to define the product of CW complexes. Lean couldn't cope, so we unrolled it into a single inductive definition of a complicated structure (something like \"product of CW complexes along with inclusions of products of the k- and l- skeleta of the factors\")</p>",
        "id": 168495636,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1560941574
    },
    {
        "content": "<blockquote>\n<p>I've done a bunch of maths in Lean and I have never once had to use a mutually inductive type. I know nothing about them and this is why I can't help. Is there any way of just taking things apart and defining some normal inductive types?</p>\n</blockquote>\n<p>Yes. That is how Lean does it underneath, but it doesn't do it very well. There is a good way of doing it.</p>",
        "id": 168496613,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560942620
    },
    {
        "content": "<p>This looks difficult to debug, since you are using mutually inductive types with nested inductive types in <code>affine_frame</code>. I am no expert in these things - the only way I would know how to get to the bottom of the error is to unroll the definition into non-mutual/nested inductive types. Someone had a similar problem awhile back, here is the link to the conversation: <a href=\"#narrow/stream/113489-new-members/topic/Induction/near/160350668\" title=\"#narrow/stream/113489-new-members/topic/Induction/near/160350668\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Induction/near/160350668</a>.</p>",
        "id": 168499414,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1560945491
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>I've done a bunch of maths in Lean and I have never once had to use a mutually inductive type. I know nothing about them and this is why I can't help. Is there any way of just taking things apart and defining some normal inductive types?</p>\n</blockquote>\n<p>Yes. That is how Lean does it underneath, but it doesn't do it very well. There is a good way of doing it.</p>\n</blockquote>\n<p>I guess my first question is whether my definition violates a fundamental constraint (e.g., positivity), or whether what I'm seeing is the just that Lean isn't yet capable of  dealing with such a definition. My second question is, where do I go for a complete definition of the unrolling method?</p>",
        "id": 168508750,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1560952634
    },
    {
        "content": "<p>To help, I've abstracted from the affine space details and have reduced the problem instance to a very short piece of code. I give three versions here of almost the same definition. The first two work; the third is borked and isolates the problem.</p>\n<p>(1) Works: Two <em>non-polymorphic</em> mutually inductive types, the second taking a list of the first as an argument.<br>\n(2) Works: Two polymorphic mutually inductive types, the second taking only a single instance of the first as an argument.<br>\n(3) Borked: Two polymorphic mutually inductive types, the second taking a <em>list</em> of the first as an argument.</p>\n<div class=\"codehilite\"><pre><span></span>-- a type argument\naxiom S : Type\n\n-- #1 [WORKS] (Note: s arguments are ignored)\nmutual inductive X, Y\nwith X : Type\n    | mk : Π (s : S), Y → X\nwith Y : Type\n    | mk&#39; : Π (s : S), list X  → Y\n\n-- #2 [WORKS]\nmutual inductive A, B\nwith A : S → Type\n    | mk : Π (s : S), B s → A s\nwith B : S → Type\n    | mk&#39; : Π (s : S), A s → B s\n\n-- #3 [BORKED]\nmutual inductive P, Q\nwith P : S → Type\n    | mk : Π (s : S), Q s → P s\nwith Q : S → Type\n    | mk&#39; : Π (s : S), list (P s) → Q s    -- putting list in front of (P s) breaks it\n</pre></div>\n\n\n<p>I should know the answer to this but I don't: Will Lean print out the unrolled definitions of P, Q?</p>",
        "id": 168512572,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1560955155
    },
    {
        "content": "<p>The example that break Lean works in Coq. This suggests that the problem is in Lean, not in definition. Or maybe I don't understand a subtle difference between the logics of Lean and Coq, respectively.</p>\n<div class=\"codehilite\"><pre><span></span>--[BORKED IN LEAN]\nmutual inductive P, Q\nwith P : S → Type\n    | mk : Π (s : S), Q s → P s\nwith Q : S → Type\n    | mk&#39; : Π (s : S), list (P s) → Q s    -- putting list in front of (P s) breaks it\n</pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span>(* WORKS IN COQ *)\nAxiom S : Set.\nInductive P : S -&gt; Set :=\n| mk : forall (s : S), Q s -&gt; P s\nwith Q : S -&gt; Set :=\n| mk&#39; : forall (s : S), list (P s) -&gt; Q s.\n</pre></div>",
        "id": 168513922,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1560956111
    },
    {
        "content": "<p>You can see what your inductive type actually is with<code> #print affine_point</code></p>",
        "id": 168515045,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560956828
    },
    {
        "content": "<blockquote>\n<p>I've done a bunch of maths in Lean and I have never once had to use a mutually inductive type.</p>\n</blockquote>\n<p>Kevin B: Thanks. This is a good place for mutual inductive definitions. A point in an affine space can be given coordinates in terms of a frame. A vector can be given coordinates in the same way. A frame, in turn, comprises a point and a set of vectors constituting a basis for the vector space. These points and vectors, being points and vectors, in turn have coordinates in terms of some (possibly other) frame. It all bottoms out with the concept of a standard frame with a standard origin point and standard basis vectors. What this structure naturally supports is the situation where you have chains of changes in basis/coordinate-systems. This kind of situation arises frequently in domains like computer graphics and robotics.</p>",
        "id": 168515070,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1560956853
    },
    {
        "content": "<blockquote>\n<p>You can see what your inductive type actually is with<code> #print affine_point</code></p>\n</blockquote>\n<p>Ok, that's easy. Thank you.</p>",
        "id": 168515257,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1560956882
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>You can see what your inductive type actually is with<code> #print affine_point</code></p>\n</blockquote>\n<p>Ok, that's easy. Thank you.</p>\n</blockquote>\n<p>Except that the definition isn't accepted, so affine_point isn't defined. Any way to see what Lean is trying to reduce the definition to?</p>",
        "id": 168515436,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1560956992
    },
    {
        "content": "<p>This is mutual and nested, because you have <code>list (affine_vector s) </code> as a constructor. That might be the problem.</p>",
        "id": 168515804,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560957224
    },
    {
        "content": "<p>this example is given in  <a href=\"https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#mutual-and-nested-inductive-types\" target=\"_blank\" title=\"https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#mutual-and-nested-inductive-types\">https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#mutual-and-nested-inductive-types</a></p>",
        "id": 168516106,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1560957429
    },
    {
        "content": "<blockquote>\n<p>This is mutual and nested, because you have <code>list (affine_vector s) </code> as a constructor. That might be the problem.</p>\n</blockquote>\n<p>Example <a href=\"https://github.com/leanprover-community/mathlib/issues/1\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/issues/1\">#1</a> is mutual and nested but not polymorphic, and it works. Example <a href=\"https://github.com/leanprover-community/mathlib/issues/2\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/issues/2\">#2</a> is mutual and polymorphic but not nested, and it works. Example <a href=\"https://github.com/leanprover-community/mathlib/issues/3\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/issues/3\">#3</a> is mutual, polymorphic, and nested. That's where it breaks. Yet it works in Coq.</p>",
        "id": 168516123,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1560957449
    },
    {
        "content": "<p>as a quick fix, you could try to redo it giving the specialization of <code>list</code> explicitly as another type</p>",
        "id": 168516203,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1560957486
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">mutual</span> <span class=\"kn\">inductive</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">Q</span><span class=\"o\">,</span> <span class=\"n\">Q_list</span>  <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"k\">with</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">s</span>\n<span class=\"k\">with</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk&#39;</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span> <span class=\"n\">s</span>\n<span class=\"k\">with</span> <span class=\"n\">Q_list</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">{}</span> <span class=\"o\">:</span>  <span class=\"n\">Q_list</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">Q_list</span> <span class=\"bp\">→</span> <span class=\"n\">Q_list</span>\n</pre></div>",
        "id": 168516318,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1560957582
    },
    {
        "content": "<p>I have no idea if this translates exactly to the semantics of what you want, though</p>",
        "id": 168516346,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1560957599
    },
    {
        "content": "<p>interesting, your original example doesn't even need that </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variable</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">mutual</span> <span class=\"kn\">inductive</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">Q</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"k\">with</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">s</span>\n<span class=\"k\">with</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk&#39;</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span> <span class=\"n\">s</span>\n</pre></div>",
        "id": 168516630,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1560957798
    },
    {
        "content": "<blockquote>\n<p>this example is given in  <a href=\"https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#mutual-and-nested-inductive-types\" target=\"_blank\" title=\"https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#mutual-and-nested-inductive-types\">https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#mutual-and-nested-inductive-types</a></p>\n</blockquote>\n<p>Andrew, thank you. Your pointer set me off in a direction that seems to be working. The problem appears to be (thus this thread being in the beginners section) that I had the type arguments in the wrong place.</p>\n<p>Here are type definitions that at least so far seem good. I have yet to prove that instances are actually affine spaces, formalized as torsors over vector spaces. I might run into problems when I try to do that, but at least I now have a path to try. </p>\n<p>Here are type definitions, followed in the second code block by working \"test code\".</p>\n<div class=\"codehilite\"><pre><span></span>import algebra.module\nimport data.vector\n\nuniverse u\n\n/-\nTuples of length n over a type, K\n-/\ndef tuple\n    (n : ℕ)\n    (K : Type u) : Type u :=\n        vector K n\n\n/-\nA type, space, values of which we will use to\nuniquely identify a given affine space, while\ncharacterizing its key attributes, namely its\ndimension and the field over in terms of which\nscalars and coordinate tuples are defined. Such\na space has a name, allowing us to distinguish\nspaces with the same field and dimensionality.\n-/\nstructure space\n(dim : ℕ)\n(K: Type)\n[isField : discrete_field K]\n[theZero : has_zero K]\n[theOne : has_one K]\n: Type :=\nmk :: (name : string)\n\n/-\nA mutual inductive definition of affine point,\nvector, and frame types. A point in an affine space\nis given coordinates in terms of a frame. A vector\ncan be given coordinates in the same way. A frame,\nin turn, has a point, its origin, and a sequence of\nvectors, constituting a basis for the vector space.\nWe are not yet specifying or enforcing the linear\nindependence of the vectors. The points and vectors\nthat make up a frame, being points and vectors, in\nturn have coordinates expressed in terms of some\n(possible other) frame. The recursion bottoms out\nwith at a standard frame with a standard origin and\nstandard basis vectors. This structure naturally\nsupports situation where you have chains of changes\nin basis/coordinate-systems. This kind of situation\narises frequently in domains like computer graphics\nand robotics.\n-/\nmutual inductive affine_point, affine_vector, affine_frame\n    { d : ℕ }\n    { K: Type }\n    { f : discrete_field K }\n    { z : has_zero K }\n    { o : has_one K }\n    (s : space d K)\nwith affine_point : Type 1\n| mk_std : affine_point\n| mk : affine_frame → tuple d K → affine_point\nwith affine_vector : Type 1\n| mk_std : affine_vector\n| mk : affine_frame → tuple d K → affine_vector\nwith affine_frame : Type 1\n| mk_std : affine_frame\n| mk : affine_point → (list affine_vector) → affine_frame\n</pre></div>\n\n\n<p>Here's code giving the types a little test run.</p>\n<div class=\"codehilite\"><pre><span></span>import .affine_space_new\nimport data.real.basic\n\n\n-- Test tuple type\ndef oneTuple : tuple 1 ℝ := ⟨ [2], rfl ⟩\ndef aTuple : tuple 3 ℝ := ⟨[2,1,-1], rfl⟩\ndef aTuple&#39; : tuple 1 ℝ := ⟨[2], rfl⟩\ndef aReal3ZeroTuple : tuple 3 ℝ :=\n    subtype.mk [0,0,0] rfl\ndef aReal4ZeroTuple : tuple 4 ℝ :=\n    ⟨ [0,0,0,0], rfl⟩\n\n\n-- Test space type\ndef time : space 1 ℝ :=      -- non-computable\n    space.mk 1 ℝ &quot;time&quot;\ndef geometry : space 3 ℝ :=  -- non-computable\n    space.mk 3 ℝ &quot;geometry&quot;\n#check time\n#check space 1 real\n\n\n/-\nTest affine point, vector, frame types.\nTime as an affine space.\n-/\n\n-- standard frame\ndef timeFrame1 : affine_frame time :=\n    affine_frame.mk_std time\n\n-- standard point (t = 0)\ndef timePoint1 : affine_point time :=\n    affine_point.mk_std time\n\n-- standard vector (interpret as 1 minute duration)\ndef timeVector1 : affine_vector time :=\n    affine_vector.mk_std time\n\n-- point at 60 min (1 hr) wrt to std frame\ndef timePoint2 : affine_point time :=\n    affine_point.mk timeFrame1 ⟨ [60], rfl ⟩\n\n-- a vector of length 1hr wrt std frame\ndef timeVector2 : affine_vector time :=\n    affine_vector.mk timeFrame1 ⟨ [60], rfl ⟩\n\n-- new frame, origin at 1 hour and unit 1 hr, wrt std frame\ndef timeFrame2 : affine_frame time :=\n    affine_frame.mk timePoint2 [timeVector2]\n\n-- Point @ 24 hours from (t = one hour) wrt std frame\ndef timePoint3 := affine_point.mk timeFrame2 ⟨ [24], rfl ⟩\n\n/-\nTest affine point, vector, frame types.\n3D geometry as an affine space.\n-/\n\n-- std frame\ndef geomFrame1 : affine_frame geometry :=\n    affine_frame.mk_std geometry\n\n-- std origin\ndef geomPoint1 : affine_point geometry :=\n    affine_point.mk_std geometry\n\n-- std vector [one of them, anyway, need to enhance type]\ndef geomVector1 : affine_vector geometry :=\n    affine_vector.mk_std geometry\n\n-- new point at [1,1,1] wrt std frame\ndef geomPoint2 : affine_point geometry :=\n    affine_point.mk geomFrame1 ⟨ [1,1,1], rfl ⟩\n\n-- new vector at [-1,1,2] wrt std frame\ndef geomVector2 : affine_vector geometry :=\n    affine_vector.mk geomFrame1 ⟨ [-1,1,2], rfl ⟩\n\n-- new frame with new basis vectors (need to add constraints here)\ndef geomFrame2 : affine_frame geometry :=\n    affine_frame.mk geomPoint2 [geomVector1, geomVector2, geomVector1]\n</pre></div>",
        "id": 168527040,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1560965140
    },
    {
        "content": "<p>These work in Coq because the Coq kernel is crazy permissive</p>",
        "id": 168554127,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560986727
    },
    {
        "content": "<p>You can achieve a similar behavior in lean by putting <code>meta</code> in front of the definition</p>",
        "id": 168554143,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560986760
    },
    {
        "content": "<p>How close does \"crazy permissive\" come to \"I worry that we'll have another proof of <code>false</code> someday\"?</p>",
        "id": 168556170,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1560989477
    },
    {
        "content": "<p>There is no paper proof that we can't prove false</p>",
        "id": 168565313,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561003810
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>I've done a bunch of maths in Lean and I have never once had to use a mutually inductive type.</p>\n</blockquote>\n<p>Kevin B: Thanks. This is a good place for mutual inductive definitions. A point in an affine space can be given coordinates in terms of a frame. A vector can be given coordinates in the same way. A frame, in turn, comprises a point and a set of vectors constituting a basis for the vector space. These points and vectors, being points and vectors, in turn have coordinates in terms of some (possibly other) frame. It all bottoms out with the concept of a standard frame with a standard origin point and standard basis vectors. What this structure naturally supports is the situation where you have chains of changes in basis/coordinate-systems. This kind of situation arises frequently in domains like computer graphics and robotics.</p>\n</blockquote>\n<p>The mathematician's concepts involved here don't need inductive types at all. I'm not sure what exactly you are trying to model. but I suspect you're making things more complicated than they need to be.</p>",
        "id": 168588369,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561031491
    },
    {
        "content": "<p>The same point of an affine space can be described using coordinates in terms of two different frames. Put differently, points described using two different frames can be equal. But in your inductive types, <code>affine_point</code>s involving different frames are certainly not equal.</p>",
        "id": 168588584,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561031718
    },
    {
        "content": "<p>What you are trying to build looks more like a type of expressions which can be evaluated to yield a point of an affine space, according to certain rules of formation</p>",
        "id": 168588661,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561031782
    },
    {
        "content": "<blockquote>\n<p>What you are trying to build looks more like a type of expressions which can be evaluated to yield a point of an affine space, according to certain rules of formation</p>\n</blockquote>\n<p>Reid, Thank you. What I'm trying to build is a library for algebra/geometry:  more specifically one that accommodates different representations of the same points and vectors, in  coordinates expressed with respect to different frames. The idea will be that, as far as the user is concerned, coordinates are mostly hidden/abstracted behind information hiding interfaces once objects are built, so so the user will be able to write expressions involving these objects independent of the frames in terms of which their underlying coordinate-based representations are expressed.  The Lean terms representing a given mathematical point or vector with respect to different frames won't be equal, but they'll be equivalent as witnessed by their equality under change-of-frame operations that render their underlying coordinate-based representations with respect to a \"standard frame\" for a given space.</p>\n<p>It's also important in my application in any case that we distinguish the types of points and vectors that \"live in different spaces\", even if the dimensions and underlying field(s) are the same. In this way, we'll be able to represent, e.g., time and distance along some line both as 1-d real affine spaces, but the points and vectors in these spaces won't be compatible with respect to affine space operations. E.g., it won't make sense to subtract a point in time from a position in space.</p>\n<p>More generally, I'm being driven by a desire to hew as closely as I can to an elegant and traditional mathematical formalization, while also accommodating the demands of my application, which, for now, I can characterize as wanting to model mathematical physics in a type-safe manner.</p>\n<p>Kevin</p>",
        "id": 168598447,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1561039478
    },
    {
        "content": "<p>I don't understand why you want to use inductive types for this. It sounds like the standard math approach would be suitable. Have a type that represents a (possibly abstract) affine space, and functions that, given a frame for an affine space, convert between points of the space and their coordinate representations in that frame.</p>",
        "id": 168599302,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561040077
    },
    {
        "content": "<p>With the inductive type you're basically making the function <code>(frame on an affine space, coordinates in that frame) -&gt; point in affine space</code> into a constructor, but it can just be an ordinary function.</p>",
        "id": 168599359,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561040119
    },
    {
        "content": "<p>I think the sort of design for affine spaces that was being discussed a while ago would be a lot simpler.</p>",
        "id": 168599378,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561040139
    },
    {
        "content": "<blockquote>\n<p>I think the sort of design for affine spaces that was being discussed a while ago would be a lot simpler.</p>\n</blockquote>\n<p>I will think about that. At least in the application I have in mind, I need to be able to capture situations where, say, a point, p1, is represented in terms of a frame f1=(p2,(v_2_i)], where p2 and the vectors are expressed in terms of a frame f2=[p3,(v_3_i)], etc., to arbitrary depths. The mutual inductive type seems a reasonable way to get to that. I'm not controverting what you're saying. I'm listening and will think about it.</p>\n<p>Which other conversation did you have in mind?</p>",
        "id": 168599851,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1561040446
    },
    {
        "content": "<p>One way to encode this is to say that a frame is an affine isomorphism from k^n to the affine space A (not assumed to have any coordinatization). A coordinatized affine space is one with a designated frame, called the \"standard frame\"; for example k^n itself is coordinatized. A coordinatized affine space is also a vector space. Given a vector in k^n and an invertible matrix in k^(n x n), we can define an affine automorphism of k^n and so transform one frame to another via precomposition. And of course the frame itself provides functions for getting the point with given coordinates (the forward map) and getting the coordinates of a point (the reverse map).</p>",
        "id": 168605233,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561044053
    },
    {
        "content": "<p>As for distinguishing different types of affine spaces that have the same dimension and field, this is easy to do using a newtype. If you define</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">time</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">real</span><span class=\"o\">)</span>\n<span class=\"kn\">structure</span> <span class=\"n\">space</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">real</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>then <code>time</code> and <code>space</code> are isomorphic to <code>real</code>, but all three types are distinct and you can't confuse one for the other.</p>",
        "id": 168605613,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561044319
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>I think the sort of design for affine spaces that was being discussed a while ago would be a lot simpler.</p>\n</blockquote>\n<p>I will think about that. At least in the application I have in mind, I need to be able to capture situations where, say, a point, p1, is represented in terms of a frame f1=(p2,(v_2_i)], where p2 and the vectors are expressed in terms of a frame f2=[p3,(v_3_i)], etc., to arbitrary depths. The mutual inductive type seems a reasonable way to get to that. I'm not controverting what you're saying. I'm listening and will think about it.</p>\n</blockquote>\n<p>The Lean expression language itself has this kind of nested structure. You can represent this by a tree of function applications.<br>\nUnless you later need access to the particular structure of that tree, you don't need to make those functions be constructors of inductive types.<br>\nMore likely you want two different such representations of the same point to be equal.</p>",
        "id": 168606007,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561044594
    },
    {
        "content": "<blockquote>\n<p>One way to encode this is to say that a frame is an affine isomorphism from k^n to the affine space A (not assumed to have any coordinatization). A coordinatized affine space is one with a designated frame, called the \"standard frame\"; for example k^n itself is coordinatized. </p>\n</blockquote>\n<p>Yes,:where a frame comprises a point (the origin for that frame) and a basis for the vector space, which along with the origin induces a coordinatization on both the points and vectors of the affine space.  I have, at least so far, chosen to represent such isomorphisms by packaging (\"hidden\") frames and coordinates within each point and vector object. That might change at some point, but for now I'm trying to get at least to a first \"working\" specification. I think Reid is telling me I don't need to do all this work. I don't yet clearly see a much easier alternative that does everything I want. But I'm still open to a possible v.2 of this still nascent library.</p>\n<blockquote>\n<p>A coordinatized affine space is also a vector space.</p>\n</blockquote>\n<p>I'm formalizing an affine space as a torsor (of \"points\") over a vector space (of \"translations\" or \"vectors\", i.e., differences between points). Speaking in object-oriented terms, I'd say that an affine space \"has\" a vector space as a component rather than that is \"is\" a vector space. Not a deep point, but things are represented this way in the emerging library. See the definitions (not yet adequately developed) at the end of the file.</p>\n<blockquote>\n<p>Given a vector in k^n and an invertible matrix in k^(n x n), we can define an affine automorphism of k^n and so transform one frame to another via precomposition.</p>\n</blockquote>\n<p>Yes. I haven't yet specified the concept of an affine transform, but it is necessary and TBD. If you check out the material that I will post to GitHub, you'll see that this concept is missing. It's needed to enable proofs of affine-space properties for the coordinate tuples that I'm using to represent points and vectors. The idea will be that operations such as vector-vector addition will work by changes-of-frames of given arguments to standard frames followed by component-wise addition of coordinates, yielding results expressed in terms of the standard frame.</p>\n<blockquote>\n<p>And of course the frame itself provides functions for getting the point with given coordinates (the forward map) and getting the coordinates of a point (the reverse map).</p>\n</blockquote>\n<p>Yes. I've defined numerous functions to access different elements. More to come.</p>",
        "id": 168612184,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1561048888
    },
    {
        "content": "<p>The code is here. Issues and suggestions are welcome.</p>\n<p><a href=\"https://github.com/kevinsullivan/phys/blob/master/src/algebra/affine_space.lean\" target=\"_blank\" title=\"https://github.com/kevinsullivan/phys/blob/master/src/algebra/affine_space.lean\">https://github.com/kevinsullivan/phys/blob/master/src/algebra/affine_space.lean</a></p>",
        "id": 168612260,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1561048944
    },
    {
        "content": "<p>It is very easy to define an affine map and an affine isomorphism, probably easier than dealing with points and vectors as you are currently doing</p>",
        "id": 168612740,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561049394
    },
    {
        "content": "<p>When I say a coordinatized affine space is a vector space, I mean that because a coordinatized affine space has a designated point (the one with coordinate 0), you can construct a vector space structure on top of the affine space (using differences from the designated point)</p>",
        "id": 168613042,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561049591
    },
    {
        "content": "<blockquote>\n<p>It is very easy to define an affine map and an affine isomorphism, probably easier than dealing with points and vectors as you are currently doing</p>\n</blockquote>\n<p>I will put this on the eval-to-do list for a possible refactoring.</p>",
        "id": 168613173,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1561049707
    },
    {
        "content": "<blockquote>\n<p>When I say a coordinatized affine space is a vector space, I mean that because a coordinatized affine space has a designated point (the one with coordinate 0), you can construct a vector space structure on top of the affine space (using differences from the designated point)</p>\n</blockquote>\n<p>Yes.</p>",
        "id": 168613202,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1561049753
    }
]
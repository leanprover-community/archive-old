[
    {
        "content": "<p>I am trying to do the following exercise from the book: As exercises, we encourage you to develop a notion of composition for partial functions from α to β and β to γ, and show that it behaves as expected.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">option</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">my_comp</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">γ</span><span class=\"o\">):</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"k\">then</span> <span class=\"n\">none</span>\n     <span class=\"k\">else</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>reports error </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"o\">,</span>\n<span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"o\">,</span>\n<span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"o\">,</span>\n<span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">β</span><span class=\"o\">,</span>\n<span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">γ</span><span class=\"o\">,</span>\n<span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">none</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>How can I fix it?</p>",
        "id": 242578870,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1623667376
    },
    {
        "content": "<p>You can either fix it by assuming that <code>option beta</code> has decidable equality (e.g. with <code>open_locale classical</code>) or you can do the problem the way you're expected to do it, without using <code>if</code> and instead splitting on the constructors, like the way addition is defined on the naturals: we don't write \"a+b = if b = 0 then a else ...\", we write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 242579172,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1623667569
    },
    {
        "content": "<p>It seems that the first approach</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">option</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">my_comp</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">γ</span><span class=\"o\">):</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"k\">then</span> <span class=\"n\">none</span>\n     <span class=\"k\">else</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>gives me another error message: <code>command expected </code> for <code>open_locale</code>.</p>",
        "id": 242579672,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1623667926
    },
    {
        "content": "<p><code>import tactic</code> at the top</p>",
        "id": 242579704,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1623667949
    },
    {
        "content": "<p>but let me stress that this is not the way you are expected to do the problem.</p>",
        "id": 242579751,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1623667977
    },
    {
        "content": "<p>Yeah Yeah. I am doing the second way.</p>",
        "id": 242580412,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1623668397
    },
    {
        "content": "<p>The difference with the two methods is that the \"use the equation compiler\" method will give you better definitional equalities; \"x = if (true thing) then x else y\" is not true by definition, it's true because of the theorem <code>if_pos</code>, whereas using the equation compiler you'll get more stuff true by definition (for example x + 0 = x is true for naturals by definition in Lean).</p>",
        "id": 242580643,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1623668506
    },
    {
        "content": "<p>I am trying to do the exercise \"We also encourage you to show that bool and nat are inhabited, that the product of two inhabited types is inhabited, and that the type of functions to an inhabited type is inhabited\".<br>\nBut I am not sure what \"to show that bool and nat are inhabited\" exactly asks me to do. Am I expected to write a theorem claiming this or something else?</p>",
        "id": 242702909,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1623746141
    },
    {
        "content": "<p>I would say that for the case of nat, the exercise is to replace that <code>sorry</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 242703236,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1623746337
    },
    {
        "content": "<p>Is there a more concise way to prove the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">prod</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">inhabited.mk</span> <span class=\"o\">(</span><span class=\"n\">inhabited.cases_on</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"n\">inhabited.cases_on</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 242716014,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1623754147
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨⟨</span><span class=\"n\">arbitrary</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">arbitrary</span> <span class=\"n\">β</span><span class=\"o\">⟩⟩</span>\n</code></pre></div>",
        "id": 242735376,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1623765128
    },
    {
        "content": "<p><code>inhabited</code> is a class, so the idiomatic thing to do would be to use rectangular brackets and not name the term of type <code>inhabited alpha</code>. Lean gives it some auto-generated name like <code>_inst_37</code> or something, but more importantly it also adds it to the typeclass system, meaning that functions like <code>arbitrary</code> (which expect to find an <code>inhabited</code> instance using type class inference) will work.</p>\n<p>The first pointy brackets is <code>inhabited.mk</code>, the second is <code>prod.mk</code>. This pointy bracket trick is why you see a lot less of <code>mk</code> functions than you might expect.</p>",
        "id": 242735705,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1623765256
    },
    {
        "content": "<p>Thanks a lot!</p>",
        "id": 242741369,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1623767517
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨⟨</span><span class=\"n\">default</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">default</span> <span class=\"n\">β</span><span class=\"o\">⟩⟩</span>\n</code></pre></div>\n<p>I have no idea which is the best proof.</p>",
        "id": 242743087,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1623768187
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">β</span><span class=\"o\">],</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">⟨(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)⟩</span>\n</code></pre></div>",
        "id": 242760737,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623774468
    },
    {
        "content": "<p>kevin's is probably the best proof though</p>",
        "id": 242760856,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623774516
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/default\">docs#default</a> is usually better than <a href=\"https://leanprover-community.github.io/mathlib_docs/find/arbitrary\">docs#arbitrary</a>, I think</p>",
        "id": 242769200,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623778087
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Exercises.20in.20Theorem.20Proving.20in.20Lean/near/242760737\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">β</span><span class=\"o\">],</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">⟨(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)⟩</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Could you please explain the syntax of <code>| ⟨a⟩ ⟨b⟩ </code>?</p>",
        "id": 242833083,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1623823377
    },
    {
        "content": "<p>It's the same syntax as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span><span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It's explained in chapter 8 (IIRC) of <a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">#tpil</a></p>",
        "id": 242833166,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1623823451
    },
    {
        "content": "<p>it's a pattern match on <code>inhabited A</code>, which is an inductive type wrapping a single element of type <code>A</code></p>",
        "id": 242833167,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623823454
    },
    {
        "content": "<p>''Under the hood, this definition is compiled down to a single inductive type with an index i in a two-valued type (such as bool), where i encodes which of even or odd is intended. ''</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span> <span class=\"kd\">inductive</span> <span class=\"n\">even</span><span class=\"o\">,</span> <span class=\"n\">odd</span>\n<span class=\"k\">with</span> <span class=\"n\">even</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">even_zero</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">even_succ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">odd</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">even</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"k\">with</span> <span class=\"n\">odd</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">odd_succ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">even</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">odd</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>What is the single inductive type it  is compiled down to?</p>",
        "id": 243238106,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624092385
    },
    {
        "content": "<p>I think the output of <code>#print even._mut_</code> is the type that definition compiles to</p>",
        "id": 243238942,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1624093715
    },
    {
        "content": "<p>Of course, that's not very human-friendly. You can write that inductive using a bool index like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">even_odd</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">even_zero</span> <span class=\"o\">{</span><span class=\"n\">even</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"bp\">→</span> <span class=\"n\">even_odd</span> <span class=\"n\">tt</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">even_succ</span> <span class=\"o\">{</span><span class=\"n\">even</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">even_odd</span> <span class=\"n\">ff</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">even_odd</span> <span class=\"n\">tt</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">odd_succ</span> <span class=\"o\">{</span><span class=\"n\">even</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">even_odd</span> <span class=\"n\">tt</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">even_odd</span> <span class=\"n\">ff</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 243239016,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1624093872
    },
    {
        "content": "<p>Basically, you write <code>even_odd tt</code> for <code>even</code> and <code>even_odd ff</code> for <code>odd</code></p>",
        "id": 243239075,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1624093989
    },
    {
        "content": "<p>We tend to stay away from mutual inductives in Lean. The reason is this: whilst it no doubt gets compiled down to a single inductive type, it is almost certainly nowhere near as nice as the clean version which Horatiu has posted. Mario's recommendation is always to do the compiling-down yourself. Fortunately our experience in mathematics is that it is quite rare that one needs mutual inductive types, indeed it's surprisingly rare to need inductive types other than structures at all, at least in the kind of mathematics which I have been doing in Lean. Nat itself is a very weird outlier. Even and odd don't need to be defined mutually, and indeed in mathlib they are defined independently.</p>",
        "id": 243246547,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624104379
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span> <span class=\"kd\">inductive</span> <span class=\"n\">even</span><span class=\"o\">,</span> <span class=\"n\">odd</span>\n<span class=\"k\">with</span> <span class=\"n\">even</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">even_zero</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">even_succ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">odd</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">even</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"k\">with</span> <span class=\"n\">odd</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">odd_succ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">even</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">odd</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- BEGIN</span>\n<span class=\"kn\">open</span> <span class=\"n\">even</span> <span class=\"n\">odd</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">not_odd_zero</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">odd</span> <span class=\"mi\">0</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>Why does this theorem can be closed by a period?</p>",
        "id": 243293339,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624178187
    },
    {
        "content": "<p>Because the equation compiler, which basically knows something about induction, can do enough calculations dealing with cases itself to realise that no cases need to be dealt with by the human</p>",
        "id": 243294947,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624181079
    },
    {
        "content": "<p>The logic is this: we need to prove false given an input of <code>odd 0</code>. That term of type <code>odd 0</code> needs to come from a constructor of <code>odd</code>. The only constructor of <code>odd</code> ultimately makes a term of type <code>odd (n+1)</code> so before we figure out exactly what to ask the user for we had better find all solutions of n+1=0. The definition of n+1 is succ n so we had better ask the user to deal with all n such that succ n is zero. But these are different constructors for nat so there can't be any solutions at all and so we don't have to ask the user to do anything. Some argument of that nature is happening internally</p>",
        "id": 243295040,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624181281
    },
    {
        "content": "<p>If I were very stubborn and insist on proving this by myself, what can I do then to close the following proof?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span> <span class=\"kd\">inductive</span> <span class=\"n\">even</span><span class=\"o\">,</span> <span class=\"n\">odd</span>\n<span class=\"k\">with</span> <span class=\"n\">even</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">even_zero</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">even_succ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">odd</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">even</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"k\">with</span> <span class=\"n\">odd</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">odd_succ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">even</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">odd</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- BEGIN</span>\n<span class=\"kn\">open</span> <span class=\"n\">even</span> <span class=\"n\">odd</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">not_odd_zero</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">odd</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 243296102,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624183274
    },
    {
        "content": "<p><code>cases h</code> would be the next step</p>",
        "id": 243297774,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1624186346
    },
    {
        "content": "<p>and presumably the last step?</p>",
        "id": 243298874,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624188412
    },
    {
        "content": "<p>Yes!</p>",
        "id": 243304469,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624198035
    },
    {
        "content": "<p>This is an example copied from the book:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">vector</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">{}</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span>   <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">vector</span>\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"n\">h</span> <span class=\"o\">::</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">cons</span> <span class=\"n\">h</span> <span class=\"n\">t</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- BEGIN</span>\n<span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">)</span>   <span class=\"n\">nil</span>                <span class=\"n\">nil</span>        <span class=\"o\">:=</span> <span class=\"n\">nil</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">cons</span> <span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"n\">a</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">b</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"c1\">-- END</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">vector</span>\n</code></pre></div>\n<p>In the line <code>| .(n+1) (@cons .(α) n a v) (cons b w) := cons (a + b) (add v w)</code>, is there any difference between using <code>.(α)</code> and <code>α</code>?</p>",
        "id": 243305068,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624199016
    },
    {
        "content": "<p>If you change <code>.(n+1)</code> to <code>(n+1)</code> then it breaks, so yes. Perhaps the error you get gives you some sort of idea as to the problems going on here.</p>",
        "id": 243306303,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624200838
    },
    {
        "content": "<p>In this case you can get away with <code>(_+1)</code> by the way.</p>",
        "id": 243306382,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624200920
    },
    {
        "content": "<p>I will say again that the dependent type <code>vector n</code> implemented as an inductive type is very hard to work with and whilst it's good to struggle and learn what is hard, when you've finished becoming miserable about how difficult Lean is and how it can't do something as simple as vectors, I would urge you to try everything that you're doing with the subtype definition and discover how easy it all is again.</p>",
        "id": 243306449,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624201028
    },
    {
        "content": "<p>In the proof of the last theorem, is there a way to match <code>e</code> with the case split in the definition of <code>simp_const</code>? If I do as in the current proof, I will have trouble showing <code>simp_const e = e</code> in the last case.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">aexpr</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">const</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">aexpr</span>\n<span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">aexpr</span>\n<span class=\"bp\">|</span> <span class=\"n\">plus</span> <span class=\"o\">:</span> <span class=\"n\">aexpr</span> <span class=\"bp\">→</span> <span class=\"n\">aexpr</span> <span class=\"bp\">→</span> <span class=\"n\">aexpr</span>\n<span class=\"bp\">|</span> <span class=\"n\">times</span> <span class=\"o\">:</span> <span class=\"n\">aexpr</span> <span class=\"bp\">→</span> <span class=\"n\">aexpr</span> <span class=\"bp\">→</span> <span class=\"n\">aexpr</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">aexpr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">aeval</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">aexpr</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"n\">n</span><span class=\"o\">)</span>    <span class=\"o\">:=</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">n</span><span class=\"o\">)</span>      <span class=\"o\">:=</span> <span class=\"n\">v</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">plus</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"n\">aeval</span> <span class=\"n\">e₁</span> <span class=\"bp\">+</span> <span class=\"n\">aeval</span> <span class=\"n\">e₂</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">times</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">aeval</span> <span class=\"n\">e₁</span> <span class=\"bp\">*</span> <span class=\"n\">aeval</span> <span class=\"n\">e₂</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">simp_const</span> <span class=\"o\">:</span> <span class=\"n\">aexpr</span> <span class=\"bp\">→</span> <span class=\"n\">aexpr</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">plus</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"n\">n₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"n\">n₂</span><span class=\"o\">))</span>  <span class=\"o\">:=</span> <span class=\"n\">const</span> <span class=\"o\">(</span><span class=\"n\">n₁</span> <span class=\"bp\">+</span> <span class=\"n\">n₂</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">times</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"n\">n₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"n\">n₂</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">const</span> <span class=\"o\">(</span><span class=\"n\">n₁</span> <span class=\"bp\">*</span> <span class=\"n\">n₂</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">e</span>                             <span class=\"o\">:=</span> <span class=\"n\">e</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fuse</span> <span class=\"o\">:</span> <span class=\"n\">aexpr</span> <span class=\"bp\">→</span> <span class=\"n\">aexpr</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"n\">n</span><span class=\"o\">)</span>    <span class=\"o\">:=</span> <span class=\"n\">const</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">n</span><span class=\"o\">)</span>      <span class=\"o\">:=</span> <span class=\"n\">var</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">plus</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"n\">simp_const</span> <span class=\"o\">(</span><span class=\"n\">plus</span> <span class=\"o\">(</span><span class=\"n\">fuse</span> <span class=\"n\">e₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fuse</span> <span class=\"n\">e₂</span><span class=\"o\">))</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">times</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">simp_const</span> <span class=\"o\">(</span><span class=\"n\">times</span> <span class=\"o\">(</span><span class=\"n\">fuse</span> <span class=\"n\">e₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fuse</span> <span class=\"n\">e₂</span><span class=\"o\">))</span>\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">simp_const_eq</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">aexpr</span><span class=\"o\">,</span> <span class=\"n\">aeval</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">simp_const</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">aeval</span> <span class=\"n\">v</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">plus</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"n\">n₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"n\">n₂</span><span class=\"o\">))</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">aeval</span><span class=\"o\">,</span><span class=\"n\">simp_const</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">times</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"n\">n₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"n\">n₂</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">aeval</span><span class=\"o\">,</span><span class=\"n\">simp_const</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"n\">e</span>                             <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"k\">have</span> <span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">simp_const</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">e</span><span class=\"o\">,{</span><span class=\"gr\">sorry</span><span class=\"o\">},</span><span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 243337163,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624248039
    },
    {
        "content": "<p>Instead of match (which does <code>cases</code>) you could use the <code>induction</code> tactic. Does this help?</p>",
        "id": 243350765,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624262894
    },
    {
        "content": "<p>Thanks for the suggestion, but not quite.. (the actual problem is concerning using the third case in the defn of <code>simp_const</code> as the <code>sorry</code> indicates in the above code)</p>",
        "id": 243353042,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624264439
    },
    {
        "content": "<p>In the third case of the proof, Lean seems not clever enough to know that <code>e</code> is not in the first two cases.</p>",
        "id": 243353679,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624264839
    },
    {
        "content": "<p>Yes that's correct, Lean doesn't know. If you want it to know then you will need to do induction on <code>e</code>. But it is not clear to me that you are proving the right thing. My instinct is that you should just prove \"the big theorem\" following e.g. the example at the beginning of chapter 2 of \"Certified Programming with Dependent Types\" by Chlipala (it's written for Coq but a very early exercise I did in Lean was to port this example over to Lean) and then I would imagine that you will be able to deduce everything relatively easily.</p>\n<p>If there's one thing I've learnt from examples like this, it's that this kind of structural induction is much harder than a mathematician imagines. Fortunately I also learnt that there are plenty of computer scientists around here who know the tricks, and also that in practice in the kind of mathematics done  by most working mathematicians, this sort of complex induction procedure is rarely if ever needed.</p>",
        "id": 243359442,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624268592
    },
    {
        "content": "<p>If you really want to push this forward, then you need to remember that every definition comes with a cost, and the cost is that you have to make an API for the definition. You have made four definitions without any API at all, and are now trying to prove a theorem relating three of them. What you should be doing is that the moment you have defined <code>simp_const</code> (which, as I've said above, does not look to me like a useful definition, you really want the theorem which says \"my compiler is correct\" rather than some weaker partial versions) you need to make an API for it, proving things like <code>simp_const (var n) = var n</code> and many other things (you will have to deal with the case <code>simp_const (plus (const n) (times e f))</code> etc etc, it will be horrible). Once you have a robust API for <code>simp_const</code> you can press on. Every definition you make, you need to pay for.</p>",
        "id": 243359826,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624268835
    },
    {
        "content": "<p>Oh I see -- this is an actual exercise in TPIL? :-/ Then probably what I'm saying is inaccurate. Apart from the bit when I said \"I worked through the example in CPDT and it taught me a lot\".</p>",
        "id": 243360064,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624268984
    },
    {
        "content": "<p>So yes, on further experimentation, you can absolutely do this by doing induction on everything. I don't see how to do it using the method you're using.</p>",
        "id": 243360348,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624269189
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Solution</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">simp_const_eq</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">aexpr</span><span class=\"o\">,</span> <span class=\"n\">aeval</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">simp_const</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">aeval</span> <span class=\"n\">v</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">e</span> <span class=\"k\">with</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>",
        "id": 243360686,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624269435
    },
    {
        "content": "<p>Thanks for your long explanation, Kevin! Could you let me know what \"API\" here stands for?</p>",
        "id": 243363617,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624271489
    },
    {
        "content": "<p>A shorter solution using <code>repeat</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">simp_const_eq</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">aexpr</span><span class=\"o\">,</span> <span class=\"n\">aeval</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">simp_const</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">aeval</span> <span class=\"n\">v</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">e</span> <span class=\"k\">with</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">}},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 243363892,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624271674
    },
    {
        "content": "<p>Yes, I thought I'd leave the refls all in there just to show you that at the end of the day we really did have to take it apart into cases. API means \"interface\". For example you make the reals <code>real</code> as Dedekind cuts or Cauchy sequences (who knows which, the user is not supposed to know) and then you define <code>real.add</code> and <code>real.mul</code> and <code>real.a_non_empty_bounded_set_has_a_LUB</code> and <code>real.field</code> and the proofs of course depend on the definition but the user doesn't look at the proofs. The definition (<code>real</code>) comes with the cost (proving it's a complete archimedean ordered field) and then the user doesn't look at the innards of the definition but just uses the interface you've made for them.</p>",
        "id": 243365432,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624272838
    }
]
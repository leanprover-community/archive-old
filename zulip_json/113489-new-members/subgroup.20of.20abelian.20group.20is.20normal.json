[
    {
        "content": "<p>I am seeing if I can expand on groups and subgroups in formalising-mathematics and want to show that a subgroup of an abelian group is normal.<br>\nI am now in the sorry in the last bit, where I need to show <code>↑h ∈ H₁</code>, I have redefined in some places a few times to try and find something I know I can finish up but haven't quite hit the mark.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">paulo</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">group</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_mul</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">has_one</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">has_inv</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mul_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">one_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mul_left_inv</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">group</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_abelian</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">one_mem'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mul_mem'</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">inv_mem'</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_mem</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">H.carrier</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">H.carrier</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_carrier</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">∈</span> <span class=\"n\">H.carrier</span> <span class=\"bp\">↔</span> <span class=\"n\">g</span> <span class=\"bp\">∈</span> <span class=\"n\">H</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- true by definition</span>\n  <span class=\"n\">refl</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">one_mem</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">H</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">H.one_mem'</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"sd\">/-- A subgroup is closed under multiplication. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">mul_mem</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">H</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">H</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">H</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- what do you think?</span>\n  <span class=\"n\">apply</span> <span class=\"n\">H.mul_mem'</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"sd\">/-- A subgroup is closed under inverse -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">inv_mem</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">H</span> <span class=\"bp\">→</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">∈</span> <span class=\"n\">H</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- what do you think?</span>\n  <span class=\"n\">apply</span> <span class=\"n\">H.inv_mem'</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_coe</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">g</span> <span class=\"bp\">∈</span> <span class=\"n\">H</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- true by definition</span>\n  <span class=\"n\">refl</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">subgroup</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_normal_subgroup</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">),</span> <span class=\"n\">g</span><span class=\"bp\">*</span><span class=\"n\">h</span><span class=\"bp\">*</span><span class=\"n\">g</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">∈</span> <span class=\"n\">H</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">abelian_subgroups_normal</span> <span class=\"o\">{</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hyp</span> <span class=\"o\">:</span> <span class=\"n\">is_abelian</span> <span class=\"n\">G₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H₁</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G₁</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_normal_subgroup</span> <span class=\"n\">H₁</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">g</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">is_abelian</span> <span class=\"n\">at</span> <span class=\"n\">hyp</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">hyp</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mul_left_inv</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">one_mul</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">subgroup</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">group</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">paulo</span>\n</code></pre></div>",
        "id": 246742026,
        "sender_full_name": "Thomas Laraia",
        "timestamp": 1626884201
    },
    {
        "content": "<p>What about changing your last definition to <code>def is_normal_subgroup := ∀ (g : G), ∀ h, h ∈ H → g*h*g⁻¹ ∈ H</code>?</p>",
        "id": 246742461,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1626884407
    },
    {
        "content": "<p>Right, Patrick has hit the nail on the head. You can finish your proof with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">actual_h</span> <span class=\"n\">h_proof</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h_proof</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 246742516,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626884436
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">abelian_subgroups_normal</span> <span class=\"o\">{</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hyp</span> <span class=\"o\">:</span> <span class=\"n\">is_abelian</span> <span class=\"n\">G₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H₁</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G₁</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_normal_subgroup</span> <span class=\"n\">H₁</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"n\">h_in</span><span class=\"o\">,</span>\n  <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">hyp</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">mul_left_inv</span><span class=\"o\">,</span> <span class=\"n\">one_mul</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>(using my definition)</p>",
        "id": 246742628,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1626884492
    },
    {
        "content": "<p>Although <code>G</code> is a type (it has type <code>Type</code>), <code>H</code> is not a type; it's a term. It has type <code>subgroup G</code>. So <code>h : H</code> should not even make sense! The only reason it does make sense is that there is a coercion from <code>subgroup G</code> to <code>Type</code> sending the term <code>H</code> to the type <code>↥H</code> (this is what you see in your goal). If then you have a term <code>h : ↥H</code> then <code>h</code> is actually a <em>pair</em>, consisting of a term <code>actual_h : G</code> (otherwise known as <code>↑h : G</code>) and a proof <code>h_proof</code> that <code>actual_h \\in H</code>. You need to take your <code>h</code> apart to get to the actual group elements. Patrick's approach avoids this problem.</p>\n<p>It is a shock to mathematicians that subgroups are not \"the same as\" groups, but they are at different levels of the type hierarachy (universes, types, terms).</p>",
        "id": 246742941,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626884639
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113489-new-members/topic/subgroup.20of.20abelian.20group.20is.20normal/near/246742461\">said</a>:</p>\n<blockquote>\n<p>What about changing your last definition to <code>def is_normal_subgroup := ∀ (g : G), ∀ h, h ∈ H → g*h*g⁻¹ ∈ H</code>?</p>\n</blockquote>\n<p>Right, I think I had another questioned answered recently where I made the same error. I will try with the new definition.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/subgroup.20of.20abelian.20group.20is.20normal/near/246742516\">said</a>:</p>\n<blockquote>\n<p>Right, Patrick has hit the nail on the head. You can finish your proof with</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">actual_h</span> <span class=\"n\">h_proof</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h_proof</span><span class=\"o\">,</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I see! I'm struggling to recognize <code>actual_h ∈ has_coe_t_aux.coe H₁</code> and <code>⟨actual_h, h_proof⟩ ∈ H₁</code> as the same thing. I think your second explanation is giving me more of an understanding of coercion though, so positives all around.</p>",
        "id": 246745308,
        "sender_full_name": "Thomas Laraia",
        "timestamp": 1626885661
    },
    {
        "content": "<p><code>exact h_proof</code> solves that goal, so all that noise about coe must just definitionally vanish.</p>",
        "id": 246747795,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626886672
    }
]
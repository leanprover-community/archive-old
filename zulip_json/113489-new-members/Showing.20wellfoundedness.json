[
    {
        "content": "<p>I've got the following definition of the set of all powers of a given prime dividing a given <code>n</code> (where I have actually filled in the <code>sorry</code> but I don't think it's relevant to my question):</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">powers_dividing</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_prime</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">prime</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">finset</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"n\">n_pos</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">p_pos</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">prime</span><span class=\"bp\">.</span><span class=\"n\">one_lt</span> <span class=\"n\">is_prime</span> <span class=\"k\">in</span>\n  <span class=\"k\">have</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">p</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">div_lt_self</span> <span class=\"n\">n_pos</span> <span class=\"n\">p_pos</span><span class=\"o\">,</span>\n  <span class=\"n\">dite</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"err\">∣</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p_div_n</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"n\">pos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n      <span class=\"n\">insert</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">times_p</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">prime</span><span class=\"bp\">.</span><span class=\"n\">pos</span> <span class=\"n\">is_prime</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">powers_dividing</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">pos</span><span class=\"o\">))</span>\n    <span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">singleton</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>Lean complains that it can't prove the <code>powers_dividing</code> recursive call to be following a wellfounded relation; it ends up trying to show that <code>0 &lt; 0</code>, which I think I agree is not possible. But I don't see why it's trying to show that; I may have just woken up, but I think I've shown everything that's required for this function to be well-defined (namely that in the recursive case, we have strictly decreased the first argument while still providing a term <code>pos</code> for the second argument). Have I missed something?</p>",
        "id": 197236604,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589263413
    },
    {
        "content": "<p>Does <a href=\"https://github.com/leanprover-community/mathlib/blob/master/docs/extras/well_founded_recursion.md\">this</a> help?</p>",
        "id": 197238089,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589265427
    },
    {
        "content": "<p>Witchcraft, thanks - this was the \"Conjecture : this is because the type of h depends on n and the equation compiler can only synthesize useful relations on non dependent products\" case.</p>",
        "id": 197238393,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589265820
    },
    {
        "content": "<p>What's my quickest path to victory with the following wellfounded induction that Lean can't prove is wellfounded? It refuses both recursive calls, because it gets stuck trying to prove e.g. that <code>m + succ i &lt; succ m + succ i</code>. Writing inside this tactic context is quite a bit harder than writing in a normal context, I seem to be getting no help from Lean at all.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">freely_map</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">B</span>\n<span class=\"bp\">|</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n  <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">fold</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"err\">∪</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">empty</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">singleton</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"n\">s</span>\n\n<span class=\"n\">def</span> <span class=\"n\">subs_of_size</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">singleton</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">empty</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">singleton</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">empty</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"n\">from_lower</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">subs_of_size</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"k\">in</span>\n    <span class=\"k\">let</span> <span class=\"n\">from_upper</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">freely_map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">insert</span> <span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">subs_of_size</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"k\">in</span>\n    <span class=\"n\">from_lower</span> <span class=\"err\">∪</span> <span class=\"n\">from_upper</span>\n<span class=\"n\">using_well_founded</span> <span class=\"o\">{</span>\n  <span class=\"n\">rel_tac</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">exact</span> <span class=\"bp\">⟨</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">measure_wf</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">⟨</span> <span class=\"n\">x1</span><span class=\"o\">,</span> <span class=\"n\">x2</span> <span class=\"bp\">⟩</span> <span class=\"o\">,</span> <span class=\"n\">x1</span> <span class=\"bp\">+</span> <span class=\"n\">x2</span><span class=\"o\">)</span><span class=\"bp\">⟩</span><span class=\"o\">],</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 197377765,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589355781
    },
    {
        "content": "<p>(I'm aware that my definition is not actually the subsets of [0..m] of size i - I'll cross that bridge when I come to it)</p>",
        "id": 197378078,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589356055
    },
    {
        "content": "<p>the first <code>def</code> is called <code>finset.image</code></p>",
        "id": 197378186,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1589356133
    },
    {
        "content": "<p>swap <code>i</code> and <code>m</code></p>",
        "id": 197378259,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1589356183
    },
    {
        "content": "<p>Ah, and there I was with fifty lines of proof that</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">freely_map_is_map</span>\n  <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"n\">freely_map</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>Good practice, probably</p>",
        "id": 197378816,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589356645
    },
    {
        "content": "<p>In fact when I get the definition of <code>subs_of_size</code> expressing what I actually intended it to express, Lean is able to show that it's wellfounded</p>",
        "id": 197378932,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589356734
    }
]
[
    {
        "content": "<p>As a first exercise in formalisation after Kevin's natural number game and Lean maths challenges, I tried <a href=\"https://github.com/jsm28/bmo2-2020-lean\" title=\"https://github.com/jsm28/bmo2-2020-lean\">formalising solutions</a> to some problems from this year's <a href=\"https://bmos.ukmt.org.uk/home/bmo2-2020.pdf\" title=\"https://bmos.ukmt.org.uk/home/bmo2-2020.pdf\">British Mathematical Olympiad round 2</a>. A couple of questions that arose from this. (a) In the course of those formalisations I found I wanted various trivial lemmas that I couldn't locate in mathlib, but that seemed of more general relevance than just those particular olympiad problems; see p1_lemmas.lean, p3_lemmas.lean and p4_lemmas.lean at the link. Are some of those actually in mathlib in a different form, or do any of them belong there? (b) The proof of problem 3 (p3.lean) got very bogged down proving trivialities. Are there key Lean tricks I'm missing that could make it, say, five times shorter (which would still be longer than either of the other proofs there)?</p>",
        "id": 194557725,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1587234656
    },
    {
        "content": "<p>Thanks for mentioning this stuff here Joseph, I know you told me about it weeks ago but I've been focusing on other things.</p>",
        "id": 194559223,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587236891
    },
    {
        "content": "<p>I only briefly skimmed your lemmas, but mostly these look useful and appropriate for mathlib.</p>",
        "id": 194568695,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587252043
    },
    {
        "content": "<p>I'd double check on some of the simpler ones that <code>library_search</code> doesn't find any matches.</p>",
        "id": 194568698,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587252058
    },
    {
        "content": "<p>and then start PR'ing them. It's probably best to do them in small chunks, as it makes it more likely that the relevant reviewer who knows the file the lemmas belong in will have time to check them.</p>",
        "id": 194568704,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587252089
    },
    {
        "content": "<p>(But my first impression is that everything was written nicely, and had good mathlib-style names, so PRing should be pretty straightforward, beyond looking for existing matches.)</p>",
        "id": 194568708,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587252120
    },
    {
        "content": "<p>OK, I've filed PR  <a href=\"https://github.com/leanprover-community/mathlib/issues/2460\" title=\"https://github.com/leanprover-community/mathlib/issues/2460\">#2460</a> for some of the modular arithmetic lemmas after checking with <code>library_search</code>. Though as <code>library_search</code> is very sensitive to the exact form in which a lemma is stated, it's quite possible something very similar is already present. (E.g. at one point in doing these formalisations I wanted the name of the lemma that turns out to be <code>nat.add_mul_div_right</code>, but because I had the additions the other way round, <code>library_search</code> didn't find it.) I left out one of the modular arithmetic lemmas from this PR, both because it's more complicated and because I got a mysterious timeout after updating to the latest Lean and mathlib. Why does this code timeout on <code>use</code> (but not if <code>existsi</code> is used instead, or with different imports)? This is with Lean 3.9.0, mathlib commit 99245b33741b6b3adc6832858c88e7b0ce2de519, and didn't appear with Lean 3.8.0, mathlib commit d2db3e831a8f8e20564e7c702409bd3bdda691f5.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">-- This import is needed; the timeout does not appear with &quot;import tactic&quot; instead.</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">mod_mul_eq_cases</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hbpos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hcpos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hmod</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"err\">%</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">d</span> <span class=\"bp\">∧</span> <span class=\"n\">d</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">∧</span> <span class=\"n\">n</span> <span class=\"err\">%</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">use</span> <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"err\">%</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"bp\">/</span> <span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"c1\">-- Times out (works with &quot;existsi&quot;)</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 194603866,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1587311229
    },
    {
        "content": "<p>Having got a first few batches of lemmas intro mathlib, a couple of followup questions.</p>\n<ol>\n<li>One of the lemmas I have is one where the statement seems reasonable for mathlib, but the proof I have surely isn't.</li>\n</ol>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">cardinality</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- Any open interval of reals is uncountable. -/</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">not_countable_real_Ioo</span> <span class=\"o\">{</span><span class=\"n\">k1</span> <span class=\"n\">k2</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">k1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">k2</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">¬</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">countable</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">Ioo</span> <span class=\"n\">k1</span> <span class=\"n\">k2</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>The proof I have (in p4_lemmas.lean) deducing this from <code>not_countable_real</code> is about as long as the whole of <code>data.real.cardinality</code> once you include the auxiliary lemmas. Maybe someone can see a much simpler proof of this and can PR that to mathlib instead?</p>\n<ol start=\"2\">\n<li>I only formalised solutions to three of the four problems on the paper because the other one is geometry and mathlib doesn't have any Euclidean geometry. I know there have been various attempts at Euclidean geometry in Lean, are there any plans to add it (at least basic definitions) to mathlib? (I tend to think the natural starting point is the <a href=\"https://en.wikipedia.org/wiki/Euclidean_space#Technical_definition\" title=\"https://en.wikipedia.org/wiki/Euclidean_space#Technical_definition\">definition</a> of a Euclidean space as an affine space whose associated vector space is a finite-dimensional real inner product space. mathlib has real inner product spaces, but not affine spaces.)</li>\n</ol>",
        "id": 195620616,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1588104921
    },
    {
        "content": "<p>For 1, it would be nice to know that an open interval is homeomorphic to ℝ anyways, from which the uncountability follows. (Maybe <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> knows whether we have this already?)</p>",
        "id": 195622197,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588105637
    },
    {
        "content": "<p>For 2, I don't know of any plans to add Euclidean geometry to mathlib. But PRs are welcome!</p>",
        "id": 195622357,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588105701
    },
    {
        "content": "<p>Not having affine spaces is really really sad, especially now calculus is very advanced in the wrong direction (using linear spaces everywhere instead of affine spaces)</p>",
        "id": 195622504,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588105776
    },
    {
        "content": "<p>For 1. I would guess that it is not too hard to show that the interval <code>Ioo a b</code> is uncountable if the unit interval <code>Ioo 0 1</code> is.</p>",
        "id": 195622510,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588105777
    },
    {
        "content": "<p>I tried to define affine spaces a very very long time ago, but I never managed to get elaboration to cooperate.</p>",
        "id": 195622601,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588105805
    },
    {
        "content": "<p>And we know that <code>exp</code> is injective. So <code>R</code> injects into the positive reals. That's also only a couple of lines.</p>",
        "id": 195622655,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588105830
    },
    {
        "content": "<p>Then you apply negation, and another <code>exp</code>.</p>",
        "id": 195622762,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588105873
    },
    {
        "content": "<p>We know that exp is monotone as well, I htink.</p>",
        "id": 195622789,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588105888
    },
    {
        "content": "<p>Library-wise I don't think we should look for a tricky proof. We need to make sure we have an bijection from R to any nonempty open interval</p>",
        "id": 195623114,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588106041
    },
    {
        "content": "<p>The library should have (a) <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>≅</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(0, 1) \\cong (a, b)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mclose\">)</span></span></span></span> for any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a &lt; b</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>, (b) <a href=\"https://en.wikipedia.org/wiki/Sigmoid_function\" title=\"https://en.wikipedia.org/wiki/Sigmoid_function\">https://en.wikipedia.org/wiki/Sigmoid_function</a> or similar.</p>",
        "id": 195623282,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588106117
    },
    {
        "content": "<p>Hmmm, didn't <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> do the sigmoid function, or something similar?</p>",
        "id": 195623442,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588106176
    },
    {
        "content": "<p>Assuming of course <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≅</mo></mrow><annotation encoding=\"application/x-tex\">\\cong</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.589em;vertical-align:0em;\"></span><span class=\"mrel\">≅</span></span></span></span> means diffemorphism.</p>",
        "id": 195623475,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588106194
    },
    {
        "content": "<p>Oh I guess I always thought that the sigmoid function specifically meant what that page calls the logistic function, but the point is we should have at least one such function which also has some other utility.</p>",
        "id": 195623483,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588106198
    },
    {
        "content": "<p>Oooh, I was thinking of</p>\n<div class=\"codehilite\"><pre><span></span><code>src/analysis/calculus/specific_functions.lean:\nThe real function `exp_neg_inv_glue` given by `x ↦ exp (-1/x)` for `x &gt; 0` and `0`\n</code></pre></div>",
        "id": 195623725,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588106327
    },
    {
        "content": "<p>There is <code>exp_neg_inv_glue</code>, but this is a bit different (and more difficult)</p>",
        "id": 195623732,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588106332
    },
    {
        "content": "<p>But <code>exp_neg_inv_glue</code> would also do the trick, right?</p>",
        "id": 195623869,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588106412
    },
    {
        "content": "<p>For 2, one has to think about how to formalise a general Euclidean geometry question. If it says something like \"Let ABC be a triangle, now construct D,E,F,G,H and prove that ABDH all lie on a circle\" then you can either use a coordinate approach or a synthetic approach. There has been a lot of work towards getting the synthetic approach to work in a theorem prover, including some serious stuff done in Coq (<a href=\"https://mathoverflow.net/questions/337558/automatically-solving-olympiad-geometry-problems\" title=\"https://mathoverflow.net/questions/337558/automatically-solving-olympiad-geometry-problems\">some links here</a>). I had a student formalise a load of stuff in Lean <a href=\"https://github.com/ImperialCollegeLondon/xena-UROP-2018/tree/master/src/Geometry\" title=\"https://github.com/ImperialCollegeLondon/xena-UROP-2018/tree/master/src/Geometry\">here</a> but they didn't document what they did so the code is impenetrable.</p>",
        "id": 195623879,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588106417
    },
    {
        "content": "<p>I don't think we have the sigmoid (and I just learned this name). But it would be very easy to do.</p>",
        "id": 195623977,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1588106480
    },
    {
        "content": "<p>And then we can claim Lean does AI</p>",
        "id": 195623991,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588106494
    },
    {
        "content": "<p>Sébastien, this fancy sigmoid name is AI</p>",
        "id": 195624014,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588106514
    },
    {
        "content": "<p>I'm interested in formalising (e.g. olympiad) Euclidean geometry in Lean and I would love to learn from/contribute to any project related to this, something like Geocoq perhaps?</p>",
        "id": 195631489,
        "sender_full_name": "Alastair Horn",
        "timestamp": 1588110427
    },
    {
        "content": "<p>Geocoq is synthetic, right?</p>",
        "id": 195632945,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588111112
    },
    {
        "content": "<p>I was going to have a student look at this this summer but my plans are now a bit up in the air.</p>",
        "id": 195632988,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588111139
    },
    {
        "content": "<p>It's one thing formalising the theorems, it's another to make the tactics which prove them automatically</p>",
        "id": 195633036,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588111161
    },
    {
        "content": "<p>Assuming I understand what synthetic is, then yes I believe it is since it's based off Tarski's axioms</p>",
        "id": 195634375,
        "sender_full_name": "Alastair Horn",
        "timestamp": 1588111812
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/Some.20olympiad.20formalisations/near/195623869\" title=\"#narrow/stream/113489-new-members/topic/Some.20olympiad.20formalisations/near/195623869\">said</a>:</p>\n<blockquote>\n<p>But <code>exp_neg_inv_glue</code> would also do the trick, right?</p>\n</blockquote>\n<p>It does one trick (via Cantor-Schroeder-Bernstein) but not all tricks.</p>",
        "id": 195634377,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588111813
    },
    {
        "content": "<p>I suppose a synthetic approach wouldn't be appropriate for mathlib, since nothing else would really depend on it. Though synthetic would presumably be the logical choice for a formalisation of Olympiad geometry.</p>",
        "id": 195635728,
        "sender_full_name": "Alastair Horn",
        "timestamp": 1588112530
    },
    {
        "content": "<p>After writing the definition in terms of affine spaces, a natural starting point to make it usable might include proving lots of basic geometrical facts (both n-dimensional and 2-dimensional), including Tarski's axioms. At that point you could use either approach for proving further geometrical results. (To do coordinate proofs you'd also want functions of the form \"choose a frame with these properties\", like \"let A be (0, 0) and B be (c, 0)\".) Of course the reverse direction (constructing an affine space over a real inner product space from a structure satisfying Tarski's axioms) is also a theorem that could be proved.</p>",
        "id": 195645126,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1588119117
    },
    {
        "content": "<p>I tend to find combinatorial geometry more interesting than the \"here's a construction for a long sequence of points\" type of problem, and synthetic geometry reasoning seems less often relevant for combinatorial problems.</p>",
        "id": 195645432,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1588119369
    },
    {
        "content": "<p>I haven't tried defining any type classes in Lean, so don't know what would go wrong in a naive attempt to implement the definition of affine spaces and define Euclidean spaces on top of that. (But implementing it in terms of additive group actions would run into mathlib not having additive group actions, and I certainly don't understand the to_additive machinery for converting things between multiplicative and additive groups.)</p>",
        "id": 195645688,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1588119676
    },
    {
        "content": "<p>I tried writing definitions of affine and Euclidean spaces (in the <a href=\"https://github.com/jsm28/bmo2-2020-lean\">same repository</a> as before), to see if I could get to the point of being able to state and prove the geometry problem on the paper I was formalising.</p>\n<p>Although I proved very little to do with affine spaces, Lean didn't seem to have any particular problems with the definitions once I made types explicit in more places than might be ideal (otherwise it can't e.g. deduce the correct type of vectors for a subtraction of points to produce a vector). Should some such minimal definitions of affine and Euclidean spaces (whether or not these particular definitions) go in mathlib as a basis for any further work people wish to do in that area, even if many basic things people would want when using the definitions are likely missing?</p>\n<p>But I ran into type class issues working with Euclidean spaces. I have a <code>metric_space</code> instance for affine spaces over normed spaces, but Lean won't deduce a metric space structure for Euclidean spaces from that. Here's a simplified self-contained example.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">normed_space</span><span class=\"bp\">.</span><span class=\"n\">real_inner_product</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">basis</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">theory</span>\n\n<span class=\"n\">class</span> <span class=\"n\">has_vadd</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">vadd</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">vsub</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">vadd</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_vadd</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">has_vadd</span><span class=\"bp\">.</span><span class=\"n\">vadd</span>\n<span class=\"n\">def</span> <span class=\"n\">vsub</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_vadd</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">has_vadd</span><span class=\"bp\">.</span><span class=\"n\">vsub</span>\n\n<span class=\"kn\">infix</span> <span class=\"bp\">`+</span><span class=\"err\">ᵥ</span><span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"o\">:=</span> <span class=\"n\">vadd</span>\n<span class=\"kn\">infix</span> <span class=\"bp\">`-</span><span class=\"err\">ᵥ</span><span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"o\">:=</span> <span class=\"n\">vsub</span>\n\n<span class=\"n\">class</span> <span class=\"n\">affine_space</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_vadd</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">vadd_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v1</span> <span class=\"n\">v2</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">+</span><span class=\"err\">ᵥ</span> <span class=\"n\">v1</span> <span class=\"bp\">+</span><span class=\"err\">ᵥ</span> <span class=\"n\">v2</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"bp\">+</span><span class=\"err\">ᵥ</span> <span class=\"o\">(</span><span class=\"n\">v1</span> <span class=\"bp\">+</span> <span class=\"n\">v2</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">vadd_vsub</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p1</span> <span class=\"n\">p2</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">),</span> <span class=\"n\">p1</span> <span class=\"bp\">+</span><span class=\"err\">ᵥ</span> <span class=\"o\">(</span><span class=\"n\">p2</span> <span class=\"bp\">-</span><span class=\"err\">ᵥ</span> <span class=\"n\">p1</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">p2</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">vsub_vadd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">+</span><span class=\"err\">ᵥ</span> <span class=\"n\">v</span> <span class=\"bp\">-</span><span class=\"err\">ᵥ</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">affine_space_has_dist</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">normed_field</span> <span class=\"n\">k</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_vadd</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">affine_space</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_dist</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">dist</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"err\">∥</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span><span class=\"err\">ᵥ</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"err\">∥</span> <span class=\"o\">}</span>\n\n<span class=\"n\">class</span> <span class=\"n\">euclidean_vector_space</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inner_product_space</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"n\">class</span> <span class=\"n\">euclidean_affine_space</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inner_product_space</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">euclidean_vector_space</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_vadd</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">affine_space</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inner_product_space</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">euclidean_vector_space</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_vadd</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">affine_space</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">euclidean_affine_space</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">euclidean_affine_space_has_dist</span> <span class=\"o\">:</span> <span class=\"n\">has_dist</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">affine_space_has_dist</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span> <span class=\"n\">P</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">S</span>\n</code></pre></div>\n\n\n<p>And this is the error from that last instance (where the <code>@</code> and naming the affine space instance are just to get a more verbose error):</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"mi\">37</span><span class=\"o\">:</span><span class=\"mi\">59</span><span class=\"o\">:</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">affine_space_has_dist</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span> <span class=\"n\">P</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">S</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">affine_space</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span> <span class=\"n\">P</span> <span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">field</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">inner_product_space</span><span class=\"bp\">.</span><span class=\"n\">to_add_comm_group</span> <span class=\"n\">V</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">inner_product_space</span><span class=\"bp\">.</span><span class=\"n\">to_module</span> <span class=\"n\">V</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)</span>\n    <span class=\"bp\">_</span><span class=\"n\">inst_4</span>\n    <span class=\"bp\">_</span><span class=\"n\">inst_5</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">affine_space</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">normed_field</span><span class=\"bp\">.</span><span class=\"n\">to_field</span> <span class=\"n\">ℝ</span> <span class=\"n\">normed_field</span><span class=\"bp\">.</span><span class=\"n\">normed_field</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">normed_group</span><span class=\"bp\">.</span><span class=\"n\">to_add_comm_group</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">inner_product_space_is_normed_group</span> <span class=\"n\">V</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">normed_space</span><span class=\"bp\">.</span><span class=\"n\">to_module</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span> <span class=\"n\">normed_field</span><span class=\"bp\">.</span><span class=\"n\">normed_field</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">inner_product_space_is_normed_group</span> <span class=\"n\">V</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">inner_product_space_is_normed_space</span> <span class=\"n\">V</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">))</span>\n    <span class=\"bp\">_</span><span class=\"n\">inst_4</span>\n    <span class=\"bp\">_</span><span class=\"n\">inst_5</span>\n</code></pre></div>\n\n\n<p>What's the right way to get those instances to match up, without causing problems later? (The metric space instance itself seems quite fragile; it \"works\" in the form I have it in the repository, in the sense that Lean accepts the proofs of metric space axioms, but if I have a slightly different set of type class instances visible when it's defined I get problems with e.g. <code>norm_zero</code> not working because the two sides of the equation have found different paths to <code>add_comm_group</code> and <code>has_zero</code>.)</p>",
        "id": 197858180,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589734656
    },
    {
        "content": "<p>Would it be an idea to add the metric to the definition of euclidean space?</p>",
        "id": 197858957,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589735558
    },
    {
        "content": "<p>Just like the definition of a metric space includes an entire topology</p>",
        "id": 197858965,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589735579
    },
    {
        "content": "<p>You could then define a custom \"minimalist\" constructor that builds all the \"redundant\" info from some core data</p>",
        "id": 197858979,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589735620
    },
    {
        "content": "<p>There are two separate issues issues. First the issue of affine spaces. You don't include the minimal test case: are you able to define affine maps between affine spaces (without having <code>@</code> all over the place)?</p>",
        "id": 197859112,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1589735765
    },
    {
        "content": "<p>I was trying to make it more general, since the metric space structure doesn't need anything more than a norm on the underlying vector space so can apply to affine spaces that aren't Euclidean spaces. But I can see if a less general version works.</p>",
        "id": 197859121,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589735788
    },
    {
        "content": "<p>Affine maps are on the long list of things that obviously ought to be added for a more complete implementation of affine spaces.</p>",
        "id": 197859142,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589735827
    },
    {
        "content": "<p>Then the metric space issue. Here Johan already explained the main trick, but there are a lot more details  at <a href=\"https://hal.inria.fr/hal-02463336v2/document\">https://hal.inria.fr/hal-02463336v2/document</a></p>",
        "id": 197859227,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1589735910
    },
    {
        "content": "<p>Joseph, I strongly recommend you try to define affine maps very soon. This is a cruel test.</p>",
        "id": 197859241,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1589735938
    },
    {
        "content": "<p>The problem I think is that <code>inner_product_space.to_module </code> and <code>normed_space.to_module</code> are making different module structures.</p>",
        "id": 197859334,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589736038
    },
    {
        "content": "<p>I've added a definition of affine maps (and the composition of two affine maps, but not tried to do anything more with them).</p>",
        "id": 197860775,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589737846
    },
    {
        "content": "<p>I'd define <code>def Point := real × real</code> and introduce <code>inner_product_space</code> on it.</p>",
        "id": 197860942,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589738057
    },
    {
        "content": "<p>I tried this long before the fashion of bundled maps began, so maybe things are easier now (although you will face coercion to function hell if you go that way). I also used <code>+</code> without subscript at that time. Maybe this was too much for Lean.</p>",
        "id": 197860952,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1589738077
    },
    {
        "content": "<p>Then define lines, circles etc, and prove standard properties.</p>",
        "id": 197861033,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589738164
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>, including the distance and a requirement that it agrees with the norm worked for defining Euclidean spaces (and then deducing a metric space instance on them, rather than needing to bundle everything about the metric space properties in the Euclidean space definition).</p>\n<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>, I'm trying to implement the abstract definition of a Euclidean space from Wikipedia. I then have an instance <code>euclidean_affine_space (fin n → ℝ) (fin n → ℝ)</code> to put an n-dimensional Euclidean space structure on <code>fin n → ℝ</code>. Yes, concepts such as lines (= affine subspaces of dimension 1), circles etc. will need defining to do much geometry.</p>",
        "id": 197865218,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589744026
    },
    {
        "content": "<p>What's wrong with a real inner product space?</p>",
        "id": 197865370,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589744224
    },
    {
        "content": "<p>I do at least now have Pythagoras (one entry on the hundred-theorems list) for three points in a Euclidean affine space.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">dist_square_eq_dist_square_add_dist_square_iff_angle_eq_pi_div_two</span> <span class=\"o\">(</span><span class=\"n\">p1</span> <span class=\"n\">p2</span> <span class=\"n\">p3</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">dist</span> <span class=\"n\">p1</span> <span class=\"n\">p3</span> <span class=\"bp\">*</span> <span class=\"n\">dist</span> <span class=\"n\">p1</span> <span class=\"n\">p3</span> <span class=\"bp\">=</span> <span class=\"n\">dist</span> <span class=\"n\">p1</span> <span class=\"n\">p2</span> <span class=\"bp\">*</span> <span class=\"n\">dist</span> <span class=\"n\">p1</span> <span class=\"n\">p2</span> <span class=\"bp\">+</span> <span class=\"n\">dist</span> <span class=\"n\">p3</span> <span class=\"n\">p2</span> <span class=\"bp\">*</span> <span class=\"n\">dist</span> <span class=\"n\">p3</span> <span class=\"n\">p2</span> <span class=\"bp\">↔</span>\n    <span class=\"err\">∠</span> <span class=\"n\">V</span> <span class=\"n\">p1</span> <span class=\"n\">p2</span> <span class=\"n\">p3</span> <span class=\"bp\">=</span> <span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">pi</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 197865397,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589744269
    },
    {
        "content": "<p>This is true in any real inner product space</p>",
        "id": 197865467,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589744317
    },
    {
        "content": "<p>Only that points and vectors between points are generally thought of as different things in geometry, i.e. it's more precisely typed to state geometry theorems in the Euclidean affine space context.</p>",
        "id": 197865568,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589744405
    },
    {
        "content": "<p>What is your current definition?</p>",
        "id": 197865675,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589744608
    },
    {
        "content": "<p>I mean, the main <code>class</code></p>",
        "id": 197865679,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589744624
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\">- A `euclidean_vector_space V` is a finite-dimensional real inner</span>\n<span class=\"cm\">product space structure on the vectors `V`. -/</span>\n<span class=\"n\">class</span> <span class=\"n\">euclidean_vector_space</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inner_product_space</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- A `euclidean_affine_space V P` is an affine space with points `P`</span>\n<span class=\"cm\">over a `euclidean_vector_space V`. We bundle the distance and require</span>\n<span class=\"cm\">it to be the same as results from the inner product. -/</span>\n<span class=\"n\">class</span> <span class=\"n\">euclidean_affine_space</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inner_product_space</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">euclidean_vector_space</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_dist</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_vadd</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">affine_space</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">dist_eq_norm_vsub</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">),</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"err\">∥</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span><span class=\"err\">ᵥ</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"err\">∥</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 197865733,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589744670
    },
    {
        "content": "<p>Note that many theorems will not need <code>finite_dimensional</code>.</p>",
        "id": 197865813,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589744774
    },
    {
        "content": "<p>So I'd drop it.</p>",
        "id": 197865814,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589744779
    },
    {
        "content": "<p>And add as an additional requirement on <code>V</code> when actually needed.</p>",
        "id": 197865824,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589744805
    },
    {
        "content": "<p>It's part of the standard definition (that I took from Wikipedia), but I agree it will rarely be needed. Even things that need being finite-dimensional will often work in a finite-dimensional subspace of an infinite-dimensional space.</p>",
        "id": 197865884,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589744902
    },
    {
        "content": "<p>Instead of a typeclass <code>euclidean_vector_space</code>,  you can define <code>euclidean_space n</code> to be <code>fin n → real</code> and introduce an <code>inner_product_space</code> instance on <code>euclidean_space n</code>.</p>",
        "id": 197865916,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589744953
    },
    {
        "content": "<p>I don't understand why you say that Yury</p>",
        "id": 197865995,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1589745058
    },
    {
        "content": "<p>E.g. to define the circumcentre (in any number of dimensions) you need a finite affine-independent collection of points and can require the circumcentre to be in their affine span, rather than requiring n+1 points in a space that's n-dimensional.</p>",
        "id": 197865999,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589745070
    },
    {
        "content": "<p>We definitely want Euclidean spaces to have no preferred basis</p>",
        "id": 197866008,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1589745089
    },
    {
        "content": "<p>And I also agree with Joseph that replacing affine spaces with artificial linear spaces is lame</p>",
        "id": 197866054,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1589745122
    },
    {
        "content": "<p>And I'm very sad our calculus library is done in this artificial context</p>",
        "id": 197866059,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1589745146
    },
    {
        "content": "<p>For  instance, we discussed affine charts on projective spaces. How would you define a linear space structure on them (without choosing bases everywhere)?</p>",
        "id": 197866070,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1589745191
    },
    {
        "content": "<p>Probably you're right.</p>",
        "id": 197866073,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589745207
    },
    {
        "content": "<p>However we still to have the usual discussions about what should be parameters and what should be extended</p>",
        "id": 197866113,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1589745245
    },
    {
        "content": "<p>What I want is to avoid requirement <code>[finite_dimensional ...]</code> in theorems that don't need it.</p>",
        "id": 197866128,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589745304
    },
    {
        "content": "<p>Sure</p>",
        "id": 197866136,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1589745323
    },
    {
        "content": "<p>I'm happy to remove that requirement, it will just mean the definition isn't quite the same as the standard one.</p>",
        "id": 197866138,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589745330
    },
    {
        "content": "<p>I wonder if we can have some clever <code>abbreviation</code> here.</p>",
        "id": 197866183,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589745364
    },
    {
        "content": "<p>Wait, what's the difference between inner_product_space and euclidean_space then?</p>",
        "id": 197866189,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1589745389
    },
    {
        "content": "<p>You should just work with <code>inner_product_space</code>, almost all of your theorems will be true in this broader setting.</p>",
        "id": 197866194,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1589745419
    },
    {
        "content": "<p>Or we can avoid the words <code>euclidean_space</code> and use <code>inner_product_space</code></p>",
        "id": 197866198,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589745423
    },
    {
        "content": "<p>I was first!</p>",
        "id": 197866203,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1589745432
    },
    {
        "content": "<p>If we remove the requirement, there wouldn't be <code>euclidean_vector_space</code> any more, but there would be <code>euclidean_affine_space</code>.</p>",
        "id": 197866204,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589745435
    },
    {
        "content": "<p>Why not <code>normed_affine_space</code>?</p>",
        "id": 197866205,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589745465
    },
    {
        "content": "<p>And you separately impose typeclass requirements on the underlying vector space.</p>",
        "id": 197866249,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589745501
    },
    {
        "content": "<p>As for <code>euclidean_affine_space</code>, couldn't you rather require that you have a normed space structure on the vector space, and that the distance on the affine space should come from this distance, but without requiring a priori that the distance is euclidean?</p>",
        "id": 197866252,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1589745508
    },
    {
        "content": "<p>Yury, Patrick and I are saying exactly the same things in parallel. Maybe it's a hint that it's a natural design...</p>",
        "id": 197866257,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1589745542
    },
    {
        "content": "<p>I must admit that I started with something else but now I agree that I was wrong.</p>",
        "id": 197866279,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589745582
    },
    {
        "content": "<p>Isn't the inner product a stronger requirement than being normed? And attempting to define the metric for an affine space over a general normed space, then apply it with the extra requirement of the inner product, ran into the type class issues discussed above.</p>",
        "id": 197866341,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589745636
    },
    {
        "content": "<p>No, if you add <code>[normed_space k V]</code> as an argument.</p>",
        "id": 197866352,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589745667
    },
    {
        "content": "<p>In this case you can later require <code>[inner_product_space V]</code> and Lean will deduce <code>[normed_space real V]</code> automatically.</p>",
        "id": 197866364,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589745714
    },
    {
        "content": "<p>And I guess <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> wants some basic theory to be done over any normed field.</p>",
        "id": 197866417,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589745765
    },
    {
        "content": "<p>And then we'll want an instance saying that a linear space is an affine space over itself and the world will collapse</p>",
        "id": 197866432,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1589745809
    },
    {
        "content": "<p>Why?</p>",
        "id": 197866438,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589745838
    },
    {
        "content": "<p>But keep the bundled distance? Some other bits of theory (proving Tarski's axioms for betweenness) are for any affine space over an ordered field. I already have the instance that a vector space is an affine space over itself.</p>",
        "id": 197866480,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589745847
    },
    {
        "content": "<p>I don't why, it's simply we're already discussing a complicated class setup, and things are usually difficult.</p>",
        "id": 197866495,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1589745897
    },
    {
        "content": "<p>To summarize, we need</p>\n<ul>\n<li><code>affine_space k V P</code>;</li>\n<li><code>normed_affine_space k V P</code>.</li>\n</ul>",
        "id": 197866602,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589746060
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266253\">Joseph Myers</span> <a href=\"#narrow/stream/113489-new-members/topic/Some.20olympiad.20formalisations/near/197866138\">said</a>:</p>\n<blockquote>\n<p>I'm happy to remove that requirement, it will just mean the definition isn't quite the same as the standard one.</p>\n</blockquote>\n<p>I don't understand. Why is it important that your code is maximally close to the statement on wikipedia?</p>",
        "id": 197866664,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589746142
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Looking back in this thread, I think that I understand what happened. I badly formulated what I wanted.</p>\n<p>I never wanted the general theory to be written for <code>fin n → real</code> only. But we need a model Euclidean space sometimes, and once we drop the <code>euclidean_space</code> typeclass (and write the general theory for an <code>inner_product_space</code>) it seems natural to reuse this name as a type tag on <code>fin n → real</code>.</p>",
        "id": 197866770,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589746273
    },
    {
        "content": "<p>ok</p>",
        "id": 197866781,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1589746307
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252300\">@Jalex Stark</span> Each place where a definition means something different from the conventional mathematical meaning of a phrase is a potential source of confusion. In this case there probably isn't much scope for confusion (and we can't avoid cases where different sources use the same phrase with different meanings and we have to pick one).</p>",
        "id": 197866897,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589746457
    },
    {
        "content": "<p>I don't think \"the string of words you can find most easily on wikipedia\" and \"the conventional mathematical meaning\" are terribly related</p>",
        "id": 197866923,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589746527
    },
    {
        "content": "<p>\"the conventional mathematical meaning\" of something is never fully captured by one formal definition</p>",
        "id": 197866930,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589746553
    },
    {
        "content": "<p>in terms of mathlib, it's captured by an API with several equivalent definitions at the core</p>",
        "id": 197866971,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589746572
    },
    {
        "content": "<p>in terms of \"mathematics done without computers\" it's captured by sociological phenomena that are fuzzier than concrete sentences on paper</p>\n<p>namely the practice of doing and teaching mathematics</p>",
        "id": 197866982,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589746606
    },
    {
        "content": "<p>Defining <code>normed_affine_space</code> (with bundled dist) results in much the same type class issues as above.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">normed_space</span><span class=\"bp\">.</span><span class=\"n\">real_inner_product</span>\n\n<span class=\"n\">class</span> <span class=\"n\">has_vadd</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">vadd</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">vsub</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">vadd</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_vadd</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">has_vadd</span><span class=\"bp\">.</span><span class=\"n\">vadd</span>\n<span class=\"n\">def</span> <span class=\"n\">vsub</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_vadd</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">has_vadd</span><span class=\"bp\">.</span><span class=\"n\">vsub</span>\n\n<span class=\"kn\">infix</span> <span class=\"bp\">`+</span><span class=\"err\">ᵥ</span><span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"o\">:=</span> <span class=\"n\">vadd</span>\n<span class=\"kn\">infix</span> <span class=\"bp\">`-</span><span class=\"err\">ᵥ</span><span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"o\">:=</span> <span class=\"n\">vsub</span>\n\n<span class=\"n\">class</span> <span class=\"n\">affine_space</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_vadd</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">vadd_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v1</span> <span class=\"n\">v2</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">+</span><span class=\"err\">ᵥ</span> <span class=\"n\">v1</span> <span class=\"bp\">+</span><span class=\"err\">ᵥ</span> <span class=\"n\">v2</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"bp\">+</span><span class=\"err\">ᵥ</span> <span class=\"o\">(</span><span class=\"n\">v1</span> <span class=\"bp\">+</span> <span class=\"n\">v2</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">vadd_vsub</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p1</span> <span class=\"n\">p2</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">),</span> <span class=\"n\">p1</span> <span class=\"bp\">+</span><span class=\"err\">ᵥ</span> <span class=\"o\">(</span><span class=\"n\">p2</span> <span class=\"bp\">-</span><span class=\"err\">ᵥ</span> <span class=\"n\">p1</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">p2</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">vsub_vadd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">+</span><span class=\"err\">ᵥ</span> <span class=\"n\">v</span> <span class=\"bp\">-</span><span class=\"err\">ᵥ</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"n\">class</span> <span class=\"n\">normed_affine_space</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">normed_field</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_dist</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_vadd</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">affine_space</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">dist_eq_norm_vsub</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">),</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"err\">∥</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span><span class=\"err\">ᵥ</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"err\">∥</span><span class=\"o\">)</span>\n\n<span class=\"kn\">set_option</span> <span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">all</span> <span class=\"n\">true</span>\n\n<span class=\"n\">class</span> <span class=\"n\">euclidean_affine_space</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inner_product_space</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">has_dist</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_vadd</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">affine_space</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_affine_space</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n</code></pre></div>\n\n\n<p>Errors:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"mi\">26</span><span class=\"o\">:</span><span class=\"mi\">55</span><span class=\"o\">:</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"n\">class</span> <span class=\"kn\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"n\">l_1</span><span class=\"o\">,</span>\n<span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"n\">l_2</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">inner_product_space</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"err\">?</span><span class=\"n\">l_1</span><span class=\"o\">}</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"err\">?</span><span class=\"n\">l_2</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">P</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_3</span> <span class=\"o\">:</span> <span class=\"n\">has_dist</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"err\">?</span><span class=\"n\">l_2</span><span class=\"o\">}</span> <span class=\"n\">P</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_4</span> <span class=\"o\">:</span> <span class=\"n\">has_vadd</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"err\">?</span><span class=\"n\">l_1</span> <span class=\"err\">?</span><span class=\"n\">l_2</span><span class=\"o\">}</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_5</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">affine_space</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span> <span class=\"err\">?</span><span class=\"n\">l_1</span> <span class=\"err\">?</span><span class=\"n\">l_2</span><span class=\"o\">}</span> <span class=\"n\">real</span> <span class=\"n\">V</span> <span class=\"n\">P</span> <span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">field</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">inner_product_space</span><span class=\"bp\">.</span><span class=\"n\">to_add_comm_group</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"err\">?</span><span class=\"n\">l_1</span><span class=\"o\">}</span> <span class=\"n\">V</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">inner_product_space</span><span class=\"bp\">.</span><span class=\"n\">to_module</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"err\">?</span><span class=\"n\">l_1</span><span class=\"o\">}</span> <span class=\"n\">V</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)</span>\n    <span class=\"bp\">_</span><span class=\"n\">inst_2</span>\n    <span class=\"bp\">_</span><span class=\"n\">inst_4</span>\n<span class=\"err\">⊢</span> <span class=\"bp\">@</span><span class=\"n\">affine_space</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span> <span class=\"err\">?</span><span class=\"n\">l_1</span> <span class=\"err\">?</span><span class=\"n\">l_2</span><span class=\"o\">}</span> <span class=\"n\">real</span> <span class=\"n\">V</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">normed_field</span><span class=\"bp\">.</span><span class=\"n\">to_field</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">real</span> <span class=\"n\">normed_field</span><span class=\"bp\">.</span><span class=\"n\">normed_field</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">normed_group</span><span class=\"bp\">.</span><span class=\"n\">to_add_comm_group</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"err\">?</span><span class=\"n\">l_1</span><span class=\"o\">}</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">inner_product_space_is_normed_group</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"err\">?</span><span class=\"n\">l_1</span><span class=\"o\">}</span> <span class=\"n\">V</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">normed_space</span><span class=\"bp\">.</span><span class=\"n\">to_module</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span> <span class=\"err\">?</span><span class=\"n\">l_1</span><span class=\"o\">}</span> <span class=\"n\">real</span> <span class=\"n\">V</span> <span class=\"n\">normed_field</span><span class=\"bp\">.</span><span class=\"n\">normed_field</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">inner_product_space_is_normed_group</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"err\">?</span><span class=\"n\">l_1</span><span class=\"o\">}</span> <span class=\"n\">V</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">inner_product_space_is_normed_space</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"err\">?</span><span class=\"n\">l_1</span><span class=\"o\">}</span> <span class=\"n\">V</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">))</span>\n    <span class=\"bp\">_</span><span class=\"n\">inst_2</span>\n    <span class=\"bp\">_</span><span class=\"n\">inst_4</span>\n</code></pre></div>",
        "id": 197867770,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589747899
    },
    {
        "content": "<p>You could go for</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">normed_space</span><span class=\"bp\">.</span><span class=\"n\">real_inner_product</span>\n\n<span class=\"n\">class</span> <span class=\"n\">has_vadd</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">vadd</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">vsub</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">vadd</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_vadd</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">has_vadd</span><span class=\"bp\">.</span><span class=\"n\">vadd</span>\n<span class=\"n\">def</span> <span class=\"n\">vsub</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_vadd</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">has_vadd</span><span class=\"bp\">.</span><span class=\"n\">vsub</span>\n\n<span class=\"kn\">infix</span> <span class=\"bp\">`+</span><span class=\"err\">ᵥ</span><span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"o\">:=</span> <span class=\"n\">vadd</span>\n<span class=\"kn\">infix</span> <span class=\"bp\">`-</span><span class=\"err\">ᵥ</span><span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"o\">:=</span> <span class=\"n\">vsub</span>\n\n<span class=\"n\">class</span> <span class=\"n\">affine_space</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_vadd</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">vadd_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v1</span> <span class=\"n\">v2</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">+</span><span class=\"err\">ᵥ</span> <span class=\"n\">v1</span> <span class=\"bp\">+</span><span class=\"err\">ᵥ</span> <span class=\"n\">v2</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"bp\">+</span><span class=\"err\">ᵥ</span> <span class=\"o\">(</span><span class=\"n\">v1</span> <span class=\"bp\">+</span> <span class=\"n\">v2</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">vadd_vsub</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p1</span> <span class=\"n\">p2</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">),</span> <span class=\"n\">p1</span> <span class=\"bp\">+</span><span class=\"err\">ᵥ</span> <span class=\"o\">(</span><span class=\"n\">p2</span> <span class=\"bp\">-</span><span class=\"err\">ᵥ</span> <span class=\"n\">p1</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">p2</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">vsub_vadd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">+</span><span class=\"err\">ᵥ</span> <span class=\"n\">v</span> <span class=\"bp\">-</span><span class=\"err\">ᵥ</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"n\">class</span> <span class=\"n\">normed_affine_space</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">normed_field</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_vadd</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">metric_space</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">affine_space</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">dist_eq_norm_vsub</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">),</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"err\">∥</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span><span class=\"err\">ᵥ</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"err\">∥</span><span class=\"o\">)</span>\n\n<span class=\"n\">class</span> <span class=\"n\">euclidean_affine_space</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inner_product_space</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">metric_space</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_vadd</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_affine_space</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 197868051,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1589748339
    },
    {
        "content": "<p>What's the difference?</p>",
        "id": 197868096,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589748374
    },
    {
        "content": "<p>That one assumes the metric space structure rather than proving that the distance defines one.</p>",
        "id": 197868107,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589748410
    },
    {
        "content": "<p>The differences are that I have assumed that there is a metric space structure on <code>P</code>, not just a distance (so that you get the topology and everything), and that <code>normed_affine_space</code> now extends <code>affine_space</code>.</p>",
        "id": 197868117,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1589748425
    },
    {
        "content": "<p>A simple rule is that, if a typeclass does not depend on more type arguments than a previous typeclass, then it should extend it, not take it as a parameter.</p>",
        "id": 197868147,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1589748477
    },
    {
        "content": "<p>BTW, <code>affine_space</code> should extend <code>has_vadd</code>. Also I'd avoid <code>def vadd</code>. You can use <code>has_vadd.vadd</code> in notation instead.</p>",
        "id": 197868194,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589748494
    },
    {
        "content": "<p>It's not always a perfect rule, but quite often it's a good one.</p>",
        "id": 197868207,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1589748519
    },
    {
        "content": "<p>No, <code>affine_space</code> should not extend <code>has_vadd</code> as there is an additional type parameter, the field.</p>",
        "id": 197868219,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1589748544
    },
    {
        "content": "<p>I always forget about this.</p>",
        "id": 197868228,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589748568
    },
    {
        "content": "<p>I mean, the fact that we can't <code>extend</code> in this case.</p>",
        "id": 197868234,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589748594
    },
    {
        "content": "<p>I never understood it in the first place. I am just hoping that it will all be easier in lean 4</p>",
        "id": 197868281,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589748619
    },
    {
        "content": "<p>All I know is that there are experts here who can tell me how to set things up with the definitions, and then the theorems I'm ok with</p>",
        "id": 197868307,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589748646
    },
    {
        "content": "<p>The main issue with your definition, though, is that it's not the usual definition of an affine space. For instance, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}^2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> with the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span></span></span> action acting by addition on the first coordinate is an affine space in your sense.</p>",
        "id": 197868308,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1589748650
    },
    {
        "content": "<p>What is <code>vsub</code>?</p>",
        "id": 197868320,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589748674
    },
    {
        "content": "<p>No, I'm wrong, because of your <code>vsub</code>, sorry.</p>",
        "id": 197868331,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1589748718
    },
    {
        "content": "<p>Shouldn't an affine space be \"a faithful and transitive group action by the additive group of a vector space\"?</p>",
        "id": 197868370,
        "sender_full_name": "David Wärn",
        "timestamp": 1589748732
    },
    {
        "content": "<p>The full version (as opposed to the MWE) has comments explaining that it's defined directly since mathlib doesn't have additive group actions (and also <code>vadd_zero</code> isn't needed as an axiom because with this definition it can be deduced from the other axioms).</p>",
        "id": 197868382,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589748820
    },
    {
        "content": "<p>If <code>vadd</code> and <code>vsub</code> only show up in the definition of an affine space, I don't know if you should have a separate class for them as you do, or if you should bundle them in the definition. The only drawback I can see is when you want to see an affine complex space as an affine real space, sharing the same <code>vadd</code> and <code>vsub</code>.</p>",
        "id": 197868461,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1589748927
    },
    {
        "content": "<p>I think if they're defined as part of <code>affine_space</code> I then can't use the notation within that definition? That was why I defined them separately.</p>",
        "id": 197868521,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589748982
    },
    {
        "content": "<p>Thinking back about this, you should define an affine space with respect to an <code>add_comm_group</code>, not with respect to a <code>vector_space</code>: your axioms don't involve the field action. And a normed affine space should be with respect to a <code>normed_group</code>.</p>",
        "id": 197869141,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1589749916
    },
    {
        "content": "<p>Once I define affine subspaces and affine maps, the vector space becomes relevant. Should I still define <code>affine_space</code> as a torsor of a group action of an <code>add_comm_group</code> and then only introduce the field and vector space for those later definitions?</p>",
        "id": 197869393,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589750257
    },
    {
        "content": "<p>Yeah, why not. I remember when we defined group actions and the computer scientists looked at us and said \"you don't mention inverses -- define monoid actions instead\".</p>",
        "id": 197869806,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589750983
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266253\">Joseph Myers</span> <a href=\"#narrow/stream/113489-new-members/topic/Some.20olympiad.20formalisations/near/197869393\">said</a>:</p>\n<blockquote>\n<p>Once I define affine subspaces and affine maps, the vector space becomes relevant. Should I still define <code>affine_space</code> as a torsor of a group action of an <code>add_comm_group</code> and then only introduce the field and vector space for those later definitions?</p>\n</blockquote>\n<p>Yes, I think so. Then it means that you can extend <code>has_vadd</code> instead of taking it as a parameter, as you are not introducing new types into the game.</p>",
        "id": 197870050,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1589751336
    },
    {
        "content": "<p>OK, I've rearranged things along those lines. With <code>normed_affine_space</code> extending <code>affine_space</code> (both of them not depending on a field any more) and <code>euclidean_affine_space</code> extending <code>normed_affine_space</code>, it now works for <code>normed_affine_space</code> and thus <code>euclidean_affine_space</code> to bundle only <code>[has_dist P]</code> rather than the full metric space structure, with the metric space properties of the distance then being proved as an instance for any <code>normed_affine_space</code>.</p>",
        "id": 197870547,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589752021
    },
    {
        "content": "<p>Should any of this be PRed to mathlib, or is further work needed there first? I can think of at least four separate pieces: (a) affine spaces; (b) normed affine spaces; (c) the geometrical definitions and results (such as angles and Pythagoras) that are proved for real inner product spaces as an intermediate step to proving them for Euclidean affine spaces; (d) Euclidean affine spaces and corresponding geometrical results.</p>",
        "id": 197870632,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589752161
    },
    {
        "content": "<blockquote>\n<p>Should any of this be PRed to mathlib?</p>\n</blockquote>\n<p>You can start by opening a PR with what you already have.</p>",
        "id": 197870677,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589752230
    },
    {
        "content": "<p>I suppose affine spaces go in linear_algebra/affine_space.lean and normed affine spaces in something like analysis/normed_space/affine.lean?</p>",
        "id": 197870718,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589752313
    },
    {
        "content": "<p>Does \"affine space\" here mean torsor for an arbitrary additive group?</p>",
        "id": 197871000,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589752728
    },
    {
        "content": "<p>I only partly followed the conversation here.</p>",
        "id": 197871020,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589752770
    },
    {
        "content": "<p>That seems to be the conclusion</p>",
        "id": 197871029,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589752799
    },
    {
        "content": "<p>A commutative additive group is what we arrived at. I don't think that much actually depends on the commutative part, but if you remove that then you have to deal with left and right torsors (and the <code>+ᵥ</code> and <code>-ᵥ</code> notation becomes even less applicable).</p>",
        "id": 197871080,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589752830
    },
    {
        "content": "<p>Then it should be called something like <code>add_torsor</code> and go under ... <code>algebra</code>?</p>",
        "id": 197871106,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589752877
    },
    {
        "content": "<p>Or <code>add_comm_torsor</code> since some bits do use commutativity?</p>",
        "id": 197871163,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589752921
    },
    {
        "content": "<p>The docstring should mention affine spaces.</p>",
        "id": 197871229,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589752963
    },
    {
        "content": "<p>If at some point someone wants torsors for a nonabelian group, the group law will probably not be <code>+</code>.</p>",
        "id": 197871303,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589753080
    },
    {
        "content": "<p>Come to think of it, do we have general group actions on sets? I forget</p>",
        "id": 197871383,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589753176
    },
    {
        "content": "<p>Only multiplicative actions, not additive.</p>",
        "id": 197871388,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589753194
    },
    {
        "content": "<p>Filed PR <a href=\"https://github.com/leanprover-community/mathlib/issues/2720\">#2720</a> with the first piece (torsors of additive commutative group actions).</p>",
        "id": 197872871,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1589755515
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266253\">@Joseph Myers</span> Sorry for the outdated style guidelines. I've PR'd an update over here: <a href=\"https://github.com/leanprover-community/leanprover-community.github.io/pull/21\">https://github.com/leanprover-community/leanprover-community.github.io/pull/21</a><br>\n(And thanks for pointing out that they were out of date <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>)</p>",
        "id": 197929063,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589806200
    }
]
[
    {
        "content": "<p>I just wrote this for a quick test, and it gives me an unexpected error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">FinT</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>  <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">emb</span><span class=\"o\">:</span><span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">embinv</span><span class=\"o\">:</span><span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">finite</span><span class=\"o\">:</span><span class=\"bp\">∀</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">emb</span> <span class=\"n\">t</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bijective</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">embinv</span> <span class=\"o\">(</span><span class=\"n\">emb</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.eqn_compiler.elim_match</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">summation</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:(</span><span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">FinT</span> <span class=\"n\">T</span><span class=\"o\">]:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">T</span><span class=\"o\">,</span>\n<span class=\"k\">let</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"n\">h.emb</span><span class=\"o\">)</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>gives me the error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">field</span> <span class=\"kd\">notation</span><span class=\"o\">,</span> <span class=\"n\">function</span> <span class=\"bp\">'</span><span class=\"n\">FinT.emb'</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"k\">have</span> <span class=\"n\">explicit</span> <span class=\"n\">argument</span> <span class=\"k\">with</span> <span class=\"n\">type</span> <span class=\"o\">(</span><span class=\"n\">FinT</span> <span class=\"bp\">...</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>What is weird is that if I replace the <code>let</code> statement with the following, it doesn't give any errors:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">embbbb</span><span class=\"o\">:</span><span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"n\">h.emb</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"n\">embbbb</span><span class=\"o\">)</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n</code></pre></div>",
        "id": 215467364,
        "sender_full_name": "Chris M",
        "timestamp": 1604416995
    },
    {
        "content": "<p>Replacing <code>h.emb</code> with <code>FinT.emb</code> should work.</p>",
        "id": 215467544,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1604417058
    },
    {
        "content": "<p>typeclass arguments are implicit, so you typically can't use them with projection notation.</p>",
        "id": 215467596,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1604417076
    },
    {
        "content": "<p>thanks :)</p>",
        "id": 215468724,
        "sender_full_name": "Chris M",
        "timestamp": 1604417565
    },
    {
        "content": "<p>Actually a related weird problem :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">FinT</span>\n<span class=\"kd\">class</span> <span class=\"n\">FinT</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>  <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">emb</span><span class=\"o\">:</span><span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">embinv</span><span class=\"o\">:</span><span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">finite</span><span class=\"o\">:</span><span class=\"bp\">∀</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">emb</span> <span class=\"n\">t</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bijective</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">embinv</span> <span class=\"o\">(</span><span class=\"n\">emb</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span> <span class=\"n\">FinT</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">FinT</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">summation</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:(</span><span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">FinT</span> <span class=\"n\">T</span><span class=\"o\">]:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">T</span><span class=\"o\">,</span>\n<span class=\"k\">let</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">emb</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"mi\">4</span>\n<span class=\"kd\">end</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">summeasure</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">summeasure</span> <span class=\"n\">k</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span>     <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">zero</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">decidable</span>\n<span class=\"kd\">def</span> <span class=\"n\">pred_to_count</span> <span class=\"o\">{</span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"bp\">∀</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">t</span><span class=\"o\">)]:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">h</span><span class=\"o\">:(</span><span class=\"n\">f</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sumprednat</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">:</span><span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"bp\">∀</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">t</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">summeasure</span> <span class=\"o\">(</span><span class=\"n\">pred_to_count</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sumpred</span> <span class=\"o\">{</span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}[</span><span class=\"n\">FinT</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">:</span><span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"bp\">∀</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">t</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">FinT.embinv</span> <span class=\"n\">T</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"k\">in</span>\n<span class=\"k\">fun</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">summeasure</span> <span class=\"o\">(</span><span class=\"n\">pred_to_count</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>What is surprising to me about this, is that in the last definition, I have to write <code>(FinT.embinv T n)</code> instead of <code>(FinT.embinv n)</code> for it to type check. If I don't add it, I get the error </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">embinv</span> <span class=\"n\">n</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">n</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">ℕ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"bp\">?+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Why is this, given that typeclasses are supposed to be implicit, and given that the same is not needed for <code>let n:nat := (emb t) in</code> in the earlier definition of <code>summation</code>?</p>",
        "id": 215471737,
        "sender_full_name": "Chris M",
        "timestamp": 1604418776
    },
    {
        "content": "<p>typeclasses are implicit, but the types are not (necessarily)</p>",
        "id": 215471870,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604418826
    },
    {
        "content": "<p>if you want <code>FinT.embinv</code> to take <code>T</code> as implicit, write the field as <code> (embinv {} : nat → T)</code></p>",
        "id": 215472051,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604418874
    },
    {
        "content": "<p>ok that makes sense, thanks.</p>",
        "id": 215472687,
        "sender_full_name": "Chris M",
        "timestamp": 1604419091
    }
]
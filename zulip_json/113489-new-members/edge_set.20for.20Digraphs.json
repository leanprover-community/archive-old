[
    {
        "content": "<p>Hello everyone, I am working on directed Graphs and I am trying to analogously (to simple_graph) introduce a bunch of stuff.<br>\nRight now I am trying to get and analogue to :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">edge_set</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span> <span class=\"bp\">↪</span><span class=\"n\">o</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">order_embedding.of_map_le_iff</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">sym2.from_rel</span> <span class=\"n\">G.symm</span><span class=\"o\">)</span> <span class=\"bp\">$</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">G</span> <span class=\"n\">G'</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">h</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">sym2.ind</span> <span class=\"bp\">@</span><span class=\"n\">h</span> <span class=\"n\">e</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>Here an mwe : </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">directed_simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">directed_simple_graph</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">edge_set</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span> <span class=\"bp\">↪</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>  <span class=\"bp\">\\</span><span class=\"n\">lambda</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I am a little lost on how to implement the idea that set(V \\times V) is supposed to include all v1 v2 : V that fulfill G.adj </p>\n<p>Any help is appreciated.</p>",
        "id": 320086196,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673190041
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"573061\">@Christopher Schmidt</span> Here's an order embedding:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">directed_simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">directed_simple_graph</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Give `directed_simple_graph V` the induced partial order from the one already</span>\n<span class=\"c1\">-- defined on  `V → V → Prop`</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"o\">(</span><span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">partial_order.lift</span> <span class=\"n\">adj</span> <span class=\"n\">ext</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">edge_set</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span> <span class=\"bp\">↪</span><span class=\"n\">o</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">order_embedding.of_map_le_iff</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span> <span class=\"bp\">|</span> <span class=\"n\">G.adj</span> <span class=\"n\">p.1</span> <span class=\"n\">p.2</span><span class=\"o\">})</span> <span class=\"bp\">$</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">G</span> <span class=\"n\">G'</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">le_eq_subset</span><span class=\"o\">,</span> <span class=\"n\">set_of_subset_set_of</span><span class=\"o\">,</span> <span class=\"n\">prod.forall</span><span class=\"o\">],</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">directed_simple_graph</span>\n</code></pre></div>",
        "id": 320191590,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673260209
    },
    {
        "content": "<p>Here's just an embedding:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">edge_set</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span> <span class=\"bp\">↪</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span> <span class=\"bp\">|</span> <span class=\"n\">G.adj</span> <span class=\"n\">p.1</span> <span class=\"n\">p.2</span><span class=\"o\">},</span>\n  <span class=\"n\">inj'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">G</span> <span class=\"n\">G'</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.ext_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">),</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>It takes a different proof since <code>order_embedding.of_map_le_iff</code> is able to prove the injectivity condition using a order-based principle.</p>",
        "id": 320192659,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673260549
    },
    {
        "content": "<p>Here's a plain function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">edge_set</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span> <span class=\"bp\">|</span> <span class=\"n\">G.adj</span> <span class=\"n\">p.1</span> <span class=\"n\">p.2</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Not too long ago <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.edge_set\">docs#simple_graph.edge_set</a> used to be a plain function</p>",
        "id": 320192940,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673260627
    },
    {
        "content": "<p>Thank you so much <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> . <br>\nHowever, I have got a question. What is the difference between the embedding and the plain function when it comes to the use of G.edge_set ? Don't both just provide the same result ?</p>",
        "id": 320334462,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673299723
    },
    {
        "content": "<p>They all give the same functions, but the embeddings \"bundle\" additional proofs with the functions, which can make general lemmas about them become more easily available.</p>\n<p>Otherwise, you can give extra lemmas about edge sets yourself. (The \"unbundled\" approach.)</p>\n<p>I'm not sure exactly if there are applications of bundled edge sets in mathlib yet.</p>",
        "id": 320344430,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673303734
    },
    {
        "content": "<p>Ah I see. Thank you.</p>",
        "id": 320404971,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673342002
    }
]
[
    {
        "content": "<p>Hi, I hope I am at the right place here, I got redirected from Stackoverflow...</p>\n<p>So I am trying to learn Lean and I am trying to figure out how one would create a new R-module <code>I*M = {i*m | i in I, m in M}</code> from an ideal I and an R-module M.</p>\n<p>So my attempt was to define first a map ideal_mult that would create a new R-module and then figure out how to asign a nice notation for it.</p>\n<div class=\"codehilite\"><pre><span></span>import ring_theory.ideals\nimport algebra.module\n\nuniverses u v\nvariables {R : Type u} {M : Type v}\nvariables [comm_ring R] [add_comm_group M] [module R M]\nvariables (I: ideal R)\n\ndef ideal_mult (I: ideal R) (M: Type v)\n        [add_comm_group M] [module R M]: Type v\n        :=\n    sorry\n\n#check ideal_mult I M\n</pre></div>\n\n\n<p>How could I define this, so that I could for example state a hypothesis like <code>(h: I*M = M)</code>?</p>\n<p>Thank you for the help!</p>",
        "id": 162042579,
        "sender_full_name": "snowbunting",
        "timestamp": 1553863480
    },
    {
        "content": "<p>Welcome! Wouldn't you rather get a <code>submodule R M</code>?</p>",
        "id": 162042634,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553863553
    },
    {
        "content": "<p>There is currently a PR going on that is very much related to these things... so the code in mathlib might change</p>",
        "id": 162042747,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553863638
    },
    {
        "content": "<p>In fact, we already have what you want</p>",
        "id": 162042848,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553863710
    },
    {
        "content": "<p>Probably</p>\n<p>I mean <code>IM</code> is definitely a submodule of <code>M</code>.</p>\n<p>You do? how is it called?</p>",
        "id": 162042862,
        "sender_full_name": "snowbunting",
        "timestamp": 1553863732
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/ring_theory/ideal_operations.lean#L556\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/ring_theory/ideal_operations.lean#L556\">https://github.com/leanprover-community/mathlib/blob/master/src/ring_theory/ideal_operations.lean#L556</a></p>",
        "id": 162042886,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553863753
    },
    {
        "content": "<p>That's what you want, right?</p>",
        "id": 162043014,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553863868
    },
    {
        "content": "<p>Your hypothesis would become <code>I \\bu M = \\top</code></p>",
        "id": 162043043,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553863903
    },
    {
        "content": "<p>hmm, would you mind helping me getting started?<br>\n<code>#check I • M</code> gives \"has_scalar (ideal R) (Type u)\"<br>\nand<br>\n<code>#check semimodule I M</code> gives <code>semiring ↑I</code><br>\nas left-to-show</p>",
        "id": 162043389,
        "sender_full_name": "snowbunting",
        "timestamp": 1553864097
    },
    {
        "content": "<p>Did you import <code>ideal_operations</code>?</p>",
        "id": 162043434,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553864143
    },
    {
        "content": "<p>stupid me^^ also named my project \"ring_theory\" which might not be the best idea I ever had. Thanks</p>\n<p>(although VS Code seems really to struggle with \"import ring_theory.ideal_operations\"... is it normal that this destroys my CPU?)</p>",
        "id": 162044243,
        "sender_full_name": "snowbunting",
        "timestamp": 1553864742
    },
    {
        "content": "<p>Do you have a fully compiled lean and mathlib before you start doing anything? That's a good place to begin</p>",
        "id": 162044329,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553864793
    },
    {
        "content": "<p>And nowadays you can get it without compiling anything yourself</p>",
        "id": 162044347,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553864814
    },
    {
        "content": "<blockquote>\n<p>stupid me^^ also named my project \"ring_theory\" which might not be the best idea I ever had. Thanks</p>\n<p>(although VS Code seems really to struggle with \"import ring_theory.ideal_operations\"... is it normal that this destroys my CPU?)</p>\n</blockquote>\n<p>Yes, it is completely normal that this destroys your CPU if you don't have precompiled binaries.</p>",
        "id": 162044484,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553864900
    },
    {
        "content": "<p>Probably not. You have good instructions on how to set it up properly? I have a Macbook Pro and I think I used homebrew to install lean, not 100% sure though</p>",
        "id": 162044545,
        "sender_full_name": "snowbunting",
        "timestamp": 1553864965
    },
    {
        "content": "<p>You use VScode?</p>",
        "id": 162044575,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553864992
    },
    {
        "content": "<p>yes</p>",
        "id": 162044636,
        "sender_full_name": "snowbunting",
        "timestamp": 1553865005
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/master/docs/elan.md\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/docs/elan.md\">https://github.com/leanprover-community/mathlib/blob/master/docs/elan.md</a></p>",
        "id": 162044653,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553865019
    },
    {
        "content": "<p>Setting things up is a pain to start with but is really well worth it. You should make a new project with mathlib as a dependency</p>",
        "id": 162044668,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553865037
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib#obtaining-binaries\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib#obtaining-binaries\">https://github.com/leanprover-community/mathlib#obtaining-binaries</a></p>",
        "id": 162044676,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553865046
    },
    {
        "content": "<p>Once you have a directory <code>_target/deps/mathlib/src</code> stuffed full of olean files, you're in good shape</p>",
        "id": 162044735,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553865098
    },
    {
        "content": "<p>Then just be sure to never accidentally edit one of those files or else you have to recompile to fix it</p>",
        "id": 162044808,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553865141
    },
    {
        "content": "<p>I see, I've <code>_target/deps/mathlib/src</code> full with .lean files</p>",
        "id": 162044846,
        "sender_full_name": "snowbunting",
        "timestamp": 1553865202
    },
    {
        "content": "<p>Does VS code have a read-only mode?</p>",
        "id": 162044859,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1553865212
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"215945\">@snowbunting</span> You'll be mostly interested in the second link that I posted</p>",
        "id": 162044945,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553865272
    },
    {
        "content": "<p>If you have the lean files only, you're going to get pain when you try and use ideals. One fix is to run <code>lean --make</code> in <code>_target/deps/mathlib/src</code> but that will take a while. If things are set up perfectly, <code>update-mathlib</code> will download all the olean files from the internet</p>",
        "id": 162045242,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553865496
    },
    {
        "content": "<p>My workflow is usually \"leanpkg configure\" followed by \"update-mathlib\"</p>",
        "id": 162045281,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553865541
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"215945\">@snowbunting</span> For <code>update-mathlib</code> to work nicely, you should set <code>lean_version</code> to <code>3.4.2</code> in your <code>.toml</code> file in the root of your project.</p>",
        "id": 162045680,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553865842
    },
    {
        "content": "<p>See e.g. <a href=\"https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/leanpkg.toml\" target=\"_blank\" title=\"https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/leanpkg.toml\">https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/leanpkg.toml</a></p>",
        "id": 162045724,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553865862
    },
    {
        "content": "<p>Thanks, I definietely managed to do what you have told me - now there are .lean and .olean files in the deps. However, I am not so sure if the performance changed... still 200% CPU</p>\n<p>It might be worth to add to the description in the second link (obtaining binaries) that one needs the non-standard python module \"pip install GitPython\"</p>",
        "id": 162047000,
        "sender_full_name": "snowbunting",
        "timestamp": 1553866907
    },
    {
        "content": "<p>Hmm, maybe restart Lean (in VScode)</p>",
        "id": 162047131,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553866986
    },
    {
        "content": "<p>Ctrl-Shift-P, then type \"restart\"</p>",
        "id": 162047151,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553867011
    },
    {
        "content": "<p>Otherwise it might not have picked up your compiled binaries</p>",
        "id": 162047172,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553867036
    },
    {
        "content": "<p>ok, seem to be fine now.  Imports are fast. but...</p>",
        "id": 162047232,
        "sender_full_name": "snowbunting",
        "timestamp": 1553867054
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/_7LeIdpL-P5jzH4yOMKYruDh/Screen-Shot-2019-03-29-at-14.44.23.png\" target=\"_blank\" title=\"Screen-Shot-2019-03-29-at-14.44.23.png\">Screen-Shot-2019-03-29-at-14.44.23.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/_7LeIdpL-P5jzH4yOMKYruDh/Screen-Shot-2019-03-29-at-14.44.23.png\" target=\"_blank\" title=\"Screen-Shot-2019-03-29-at-14.44.23.png\"><img src=\"/user_uploads/3121/_7LeIdpL-P5jzH4yOMKYruDh/Screen-Shot-2019-03-29-at-14.44.23.png\"></a></div>",
        "id": 162047263,
        "sender_full_name": "snowbunting",
        "timestamp": 1553867088
    },
    {
        "content": "<p>Is that not how you said I should do it? why the \"has_scalar\"?</p>",
        "id": 162047412,
        "sender_full_name": "snowbunting",
        "timestamp": 1553867166
    },
    {
        "content": "<p>Oops, It should be <code>I • ⊤</code></p>",
        "id": 162047422,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553867176
    },
    {
        "content": "<p>I works, what does that \"\\top\" mean?</p>",
        "id": 162047477,
        "sender_full_name": "snowbunting",
        "timestamp": 1553867239
    },
    {
        "content": "<p>Its the largest submodule</p>",
        "id": 162047558,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553867285
    },
    {
        "content": "<p>Submodules are ordered by inclusion... they form a lattice. And <code>⊤</code> is the notation for the top element</p>",
        "id": 162047579,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553867306
    },
    {
        "content": "<p>This seems awkward to us mathematicians... but it allows you to apply a whole bunch of lemmas about ordered structures</p>",
        "id": 162047642,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553867365
    },
    {
        "content": "<p>makes sence,  but just one (last) question, how does then Lean know (or how do I tell them) it is the largest submodule of <code>M</code> and not say <code>N</code>?</p>\n<p>Thank you so much for helping me out btw!</p>",
        "id": 162047980,
        "sender_full_name": "snowbunting",
        "timestamp": 1553867657
    },
    {
        "content": "<blockquote>\n<p>It might be worth to add to the description in the second link (obtaining binaries) that one needs the non-standard python module \"pip install GitPython\"</p>\n</blockquote>\n<p>I've made a PR addressing this at the install-script level <a href=\"https://github.com/leanprover-community/mathlib/pull/860\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/pull/860\">https://github.com/leanprover-community/mathlib/pull/860</a><br>\nWe may want to check the docs again as well.</p>",
        "id": 162048078,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1553867761
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"215945\">@snowbunting</span> If Lean gets confused you type <code>(⊤ : submodule R M)</code></p>",
        "id": 162048267,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553867880
    },
    {
        "content": "<p>But if it figured out that <code>I • ⊤</code> had to be a <code>submodule R M</code> then it probably could figure out that there wasn't much room for <code>⊤</code>.</p>",
        "id": 162048355,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553867922
    },
    {
        "content": "<p>So it depends on how much info there is available for the type checker</p>",
        "id": 162048370,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553867941
    },
    {
        "content": "<p>ok thanks!</p>",
        "id": 162048623,
        "sender_full_name": "snowbunting",
        "timestamp": 1553868164
    },
    {
        "content": "<p>By the way, just out of curiosity... do have some goal in mind?</p>",
        "id": 162048795,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553868333
    },
    {
        "content": "<p>A particular lemma that you want to prove?</p>",
        "id": 162048801,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553868340
    },
    {
        "content": "<p>This here was nakayama, but more for educational purposes. I'm trying to figure out, whether it would be in the end feasible to use lean for defining and proving more interesting stuff, say homological algebra or just anything that would appear at graduate level.</p>",
        "id": 162049554,
        "sender_full_name": "snowbunting",
        "timestamp": 1553868924
    },
    {
        "content": "<p>But I haven't even figured out if there is a good way to search the library - say if I was asking if there was a krull-intersection theorem somewhere. And proper tutorials that are not about first order logic are also still to be found ;)</p>",
        "id": 162049691,
        "sender_full_name": "snowbunting",
        "timestamp": 1553869013
    },
    {
        "content": "<p>Ha! Since today we have <code>library_search</code>!</p>",
        "id": 162049725,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553869048
    },
    {
        "content": "<p>Also, Nakayama is already there.</p>",
        "id": 162049736,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553869055
    },
    {
        "content": "<p><a href=\"#narrow/stream/113488-general/topic/library_search.20has.20been.20merged\" title=\"#narrow/stream/113488-general/topic/library_search.20has.20been.20merged\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/library_search.20has.20been.20merged</a></p>",
        "id": 162049808,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553869088
    },
    {
        "content": "<p>Well <em>that</em> is pretty cool indeed.</p>\n<p>I know it is there, but you have to start reimplementing something if you want to learn the language.</p>",
        "id": 162050106,
        "sender_full_name": "snowbunting",
        "timestamp": 1553869350
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span> Thanks for the quick response! <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 162051831,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553870587
    },
    {
        "content": "<blockquote>\n<p>This here was nakayama, but more for educational purposes. I'm trying to figure out, whether it would be in the end feasible to use lean for defining and proving more interesting stuff, say homological algebra or just anything that would appear at graduate level.</p>\n</blockquote>\n<p>It most definitely is possible. Whether or not it is \"feasible\" depends on your definition of feasible. I would say it was feasible. <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  proved the five lemma as one of his first programming tasks in Lean. I've defined schemes. <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span>  did localisation of rings and <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> did completions. So we're pretty solid for MSc level commutative algebra. The reason nobody has done flatness yet was that there was some debate about implementation details for exact sequences which somehow we've never got beyond.</p>",
        "id": 162056262,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553873597
    },
    {
        "content": "<p>you can just define flat to mean that tensoring preserves injective maps</p>",
        "id": 162056417,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1553873704
    },
    {
        "content": "<p>so there's a definition -- but as you know well Kenny we now need an API. Like the one you wrote for localisation</p>",
        "id": 162057254,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553874265
    },
    {
        "content": "<p>It would be good to have criteria for flatness involving Ext groups etc, but somehow people don't know how best to define ext groups in Lean and as a result they never get defined. Did anyone ever do this in Coq?</p>",
        "id": 162057423,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553874367
    },
    {
        "content": "<p>Do we even have projective modules in Lean? Again I could imagine that we have enough for a definition, but we need an API.</p>",
        "id": 162057444,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553874390
    },
    {
        "content": "<p>And before people launch into this I think we should fix upon an answer to how to implement exact sequences. <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> do you have any thoughts on this? I remember you and Mario discussing it recently. It would be nice to have injective and projective resolutions, there's a whole bunch of quite formal stuff which one could do if we had them.</p>",
        "id": 162057523,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553874462
    },
    {
        "content": "<p>I am trying to define a perfectoid space...</p>",
        "id": 162057582,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553874489
    },
    {
        "content": "<p>But yes, there are pretty solid ideas for (short) exact sequences.</p>",
        "id": 162057601,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553874514
    },
    {
        "content": "<p>Hi, guys. Me again. Slowly Lean starts to be fun to use, and I'd have some follow-up questions...</p>\n<p>So <code>I•N</code> for <code>[comm_ring R]</code>, <code>I: ideal R</code> and <code>N: submodule R M</code> works fine, now I thought I could also define <code>r•N</code> for <code>r: R</code> (which seems not to be defined, is it?)</p>\n<p>so my attempt was: </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">has_scalar_from_ring</span><span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n        <span class=\"bp\">⟨λ</span> <span class=\"n\">r</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">N</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"err\">•</span><span class=\"n\">linear_map</span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p>(following the def. of <code>I•N</code>) but I think it would be better, to define it as <code>r•N := (r) • N</code> and use the definition of ideals, which already exists. Moreover, the most basic fact, I need is that a module is zero iff every element is zero:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">submodule_mul_scalar_is_zero</span> <span class=\"o\">(</span><span class=\"n\">N</span><span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"n\">R</span><span class=\"o\">):</span>\n    <span class=\"n\">r</span><span class=\"err\">•</span><span class=\"n\">N</span><span class=\"bp\">=</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">n</span><span class=\"err\">∈</span><span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"err\">•</span><span class=\"n\">n</span><span class=\"bp\">=</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"o\">))</span>\n</pre></div>\n\n\n<p>which I don't understand how that would work.</p>\n<p>Therefore I have two questions:</p>\n<ul>\n<li>How do I construct concrete objects like the ideal (r), a polynomial ring R[X] or some other very concrete construction?</li>\n<li>is there something in the <code>has_zero</code> or so, that would imply the statement above? Or how would I try to prove that <code>r•N</code> or <code>I•N</code> is zero?</li>\n</ul>\n<p>Thank you once more for helping me!</p>",
        "id": 162085727,
        "sender_full_name": "snowbunting",
        "timestamp": 1553895398
    },
    {
        "content": "<p>The ideal <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(r)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span></span></span></span> is <code>ideal.span {r}</code>. The polynomial ring <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi><mo>[</mo><mi>X</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">R[X]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span></span></span></span> in one variable is <code>polynomial R</code>, you need <code>import data.polynomial</code>.</p>",
        "id": 162112813,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553937062
    },
    {
        "content": "<p>These questions make it quite clear to me that we need some sort of example / manual pages of how to work with these things. When I was trying to pick up Sage I found the manual indispensible -- I knew the maths but didn't know how to make Sage work with e.g. elliptic curves over the rationals. But there are oodles of examples in the manual, so it wasn't hard to pick up. I am busy with work right now though :-/</p>",
        "id": 162112887,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553937183
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">ideals</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">module</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">has_scalar_from_ring</span><span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n        <span class=\"bp\">⟨λ</span> <span class=\"n\">r</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">N</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"err\">•</span><span class=\"n\">linear_map</span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">submodule_mul_scalar_is_zero</span> <span class=\"o\">(</span><span class=\"n\">N</span><span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"n\">R</span><span class=\"o\">):</span>\n    <span class=\"n\">r</span><span class=\"err\">•</span><span class=\"n\">N</span><span class=\"bp\">=</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">n</span><span class=\"err\">∈</span><span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"err\">•</span><span class=\"n\">n</span><span class=\"bp\">=</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">submodule</span><span class=\"bp\">.</span><span class=\"n\">ext&#39;_iff</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"err\">↑</span><span class=\"n\">N</span> <span class=\"bp\">∧</span> <span class=\"n\">r</span> <span class=\"err\">•</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↔</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n    <span class=\"c\">/-</span><span class=\"cm\"> showing my working for how I got the above line:</span>\n<span class=\"cm\">    I pulled off the LHS (using split and intro), called it h, and then I did this:</span>\n<span class=\"cm\">    unfold has_scalar.smul at h,</span>\n<span class=\"cm\">    rw submodule.map_coe _ N at h, -- proof is rfl</span>\n<span class=\"cm\">    unfold set.image at h,</span>\n<span class=\"cm\">    dsimp at h,</span>\n<span class=\"cm\">    unfold coe_fn has_coe_to_fun.coe has_scalar.smul at h,</span>\n<span class=\"cm\">    dsimp at h,</span>\n<span class=\"cm\">    -/</span>\n  <span class=\"n\">rw</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">ext_iff</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">n</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">mem_singleton_iff</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"err\">•</span> <span class=\"n\">n</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">hn</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">mem_singleton_iff</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">swap</span><span class=\"o\">,</span> <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"n\">submodule</span><span class=\"bp\">.</span><span class=\"n\">zero_mem</span> <span class=\"n\">N</span><span class=\"o\">,</span><span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">rintro</span> <span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">hn</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">n</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n  <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>This is not really how the proof should go; one should break things down into small steps, and also probably your definition of <code>has_scalar_from_ring</code> should maybe go via ideals and there should be extra lemmas in the API about how to manipulate these things. I just took everything apart; <code>submodule.ext'_iff</code> turns an equality of modules into an equality of sets and <code>set.mem_singleton_iff</code> says x is in {y} iff x = y and then it was just a case of checking that basically it was a triviality. The <code>change</code> line replaces the set <code>↑(r • N)</code> with its definition, which I found by unfolding.</p>",
        "id": 162114166,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553939411
    },
    {
        "content": "<p>But this is not really how good Lean should look. One should really be thinking more along the following lines: \"The underlying fact I seem to need is that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi><mi>N</mi><mo>⊆</mo><mi>P</mi><mspace width=\"0.277778em\"></mspace><mo>⟺</mo><mspace width=\"0.277778em\"></mspace><mi mathvariant=\"normal\">∀</mi><mi>i</mi><mo>∈</mo><mi>I</mi><mo separator=\"true\">,</mo><mi>i</mi><mi>N</mi><mo>⊆</mo><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">IN\\subseteq P\\iff\\forall i\\in I, iN\\subseteq P</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N</span><span class=\"mrel\">⊆</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mrel\"><span class=\"mspace thickspace\"></span><span class=\"mrel\">⟺</span></span><span class=\"mord mathrm\"><span class=\"mspace thickspace\"></span><span class=\"mord mathrm\">∀</span></span><span class=\"mord mathit\">i</span><span class=\"mrel\">∈</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span><span class=\"mpunct\">,</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N</span><span class=\"mrel\">⊆</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span></span></span></span> so this should be in the API; if <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span></span></span></span> is generated by a set <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span> then <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi><mi>N</mi><mo>⊆</mo><mi>P</mi><mspace width=\"0.277778em\"></mspace><mo>⟺</mo><mspace width=\"0.277778em\"></mspace><mi mathvariant=\"normal\">∀</mi><mi>s</mi><mo>∈</mo><mi>S</mi><mo separator=\"true\">,</mo><mi>s</mi><mi>N</mi><mo>⊆</mo><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">IN\\subseteq P\\iff \\forall s\\in S, sN\\subseteq P</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N</span><span class=\"mrel\">⊆</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mrel\"><span class=\"mspace thickspace\"></span><span class=\"mrel\">⟺</span></span><span class=\"mord mathrm\"><span class=\"mspace thickspace\"></span><span class=\"mord mathrm\">∀</span></span><span class=\"mord mathit\">s</span><span class=\"mrel\">∈</span><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span><span class=\"mpunct\">,</span><span class=\"mord mathit\">s</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N</span><span class=\"mrel\">⊆</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span></span></span></span> and this sort of thing -- general lemmas which one would use to prove the result in a more conceptual way; these lemmas should then have good names attached to them (I'm quite bad at that bit) and then added to the API, if they're not there already. Then the user can write a much sexier looking proof using these lemmas.</p>",
        "id": 162114289,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553939671
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> are you aware of two results I mention above being in mathlib?</p>",
        "id": 162114374,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553939806
    },
    {
        "content": "<p>smul_le</p>",
        "id": 162114385,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1553939846
    },
    {
        "content": "<p>You see, if I was better at names I might have found this myself without having to ask.</p>",
        "id": 162114725,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553940463
    },
    {
        "content": "<p>I've been playing with these actions in the perfectoid project.</p>",
        "id": 162114768,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553940494
    },
    {
        "content": "<p>So some stuff is in <code>ring_theory/ideal_operations.lean</code>.</p>",
        "id": 162114774,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553940533
    },
    {
        "content": "<p>But I don't see the generators one.</p>",
        "id": 162114785,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553940559
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"215945\">@snowbunting</span> You also want to be able to multiply a set with a submodule. So I think you should define <code>s \\bu N</code> as <code>(span s) \\bu N</code> (for <code>s</code> a set), and then <code>r \\bu N</code> as <code>{r} \\bu N</code> for <code>r : R</code>.</p>",
        "id": 162114788,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553940566
    },
    {
        "content": "<p>That's a nice idea. Then a lot of these lemmas can be phrased very naturally. They go in the API and then the user can just prove stuff without having to get their hands dirty like I did above. Do understand that this whole ring and module stuff is still under very active development -- there are implementation issues regarding bundled and unbundled structures which have only relatively recently been decided on</p>",
        "id": 162115097,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553941088
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"215945\">@snowbunting</span> There are currently two relevant open PRs <a href=\"https://github.com/leanprover-community/mathlib/issues/854\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/issues/854\">#854</a> and <a href=\"https://github.com/leanprover-community/mathlib/issues/856\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/issues/856\">#856</a>. One does pointwise multiplication of sets, the other shows that submodules of an algebra form a semiring.</p>",
        "id": 162116223,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553943166
    },
    {
        "content": "<p>After that, we should prove things like <code>span : set A → submodule R A</code> is a semiring hom, etc.</p>",
        "id": 162116239,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553943199
    },
    {
        "content": "<blockquote>\n<p>These questions make it quite clear to me that we need some sort of example / manual pages of how to work with these things.</p>\n</blockquote>\n<p>Yes, that would be very valuable. At the moment I have just all the 11 chapters of the official lean tutorial open, but they tell you one so much. Tbh I would prefer a tutorial that starts completely on the math side, lets say something like group theory and skips the logic part and implementation details at the beginning. I mean to get started, you don't really need to know what for example the square brackets do as long as you know, you have to write <code>[comm_ring R]</code>.</p>\n<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> That is a good idea, now I know <code>span</code>, I can do it that way.<br>\n<span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> Thx, that's exactly it. I see, searching the library is one of the biggest challenges for getting started.</p>\n<p>Thank you again! I also started to define kan-extensions of functors (just for fun),  so I might stop by again if I get stuck there.</p>",
        "id": 162118928,
        "sender_full_name": "snowbunting",
        "timestamp": 1553948015
    },
    {
        "content": "<p>Note that Reid Barton also did stuff with Kan extensions in one of his repos. (I know you are doing it just for fun.)</p>",
        "id": 162118975,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553948095
    },
    {
        "content": "<p>Also, I hope that <code>library_search</code> will aid in \"searching the library\"</p>",
        "id": 162118987,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553948113
    },
    {
        "content": "<p>for <code>library_search</code>, it searches only in the files you actively imported, doesn't it? While that is already super helpful, it is kind of peculiar why for example ideals are defined in <code>algebra.module</code>, while some of their properties are in <code>ring_theory.ideals</code> or <code>ring_theory.ideal_operations</code>, so if you don't know where to search, you probably won't find it. -- I would also never have figured out that Nakayama's lemma is stored under the memorable name <code>submodule.exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul</code> and is saved in <code>ring_theory.noetherian</code> ;)</p>",
        "id": 162120036,
        "sender_full_name": "snowbunting",
        "timestamp": 1553950069
    },
    {
        "content": "<p>or does it search all the library?</p>",
        "id": 162120084,
        "sender_full_name": "snowbunting",
        "timestamp": 1553950119
    },
    {
        "content": "<p>No, it only searches the imported part of the library</p>",
        "id": 162120480,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553950847
    },
    {
        "content": "<p>I think <code>ring_theory.noetherian</code> might as well be renamed <code>ring_theory.finitely_generated</code></p>",
        "id": 162120493,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553950879
    },
    {
        "content": "<p>At some point we have discussed the option of having \"master files\" that import a whole bunch of stuff.<br>\nSo you would write <code>import commutative_algebra</code> and be done with it. But we never fleshed out the details of the idea.</p>",
        "id": 162120542,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553950961
    },
    {
        "content": "<p>Now that we have <code>library_search</code> there might be extra motivation to have such master files</p>",
        "id": 162120550,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1553950986
    },
    {
        "content": "<p>if you search <code>Nakayama</code> you should be able to get that lemma</p>",
        "id": 162144252,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1553988913
    },
    {
        "content": "<p>because of the comment on top</p>",
        "id": 162144253,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1553988917
    }
]
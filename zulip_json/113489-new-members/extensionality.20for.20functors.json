[
    {
        "content": "<p>Hi,<br>\ncorrect me if I'm wrong: In mathlib, there seems to be no extensionality Lemma for functors. <br>\nMoreover, I noticed that I can't even <em>state</em> extensionality for functors without getting a type error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.functor</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n\n<span class=\"c1\">--doesn't even typecheck</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">‚•§</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h‚ÇÅ</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"bp\">=</span> <span class=\"n\">G.obj</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">F.map</span> <span class=\"bp\">=</span> <span class=\"n\">G.map</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">=</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>and it makes sense, because the types of <code>F.map</code> and <code>G.map</code> are a priori different, but of course they actually aren't because I'm requiring <code>F.obj = G.obj</code> as a hypothesis as well. I remember seeing issues like this in a CS class on Coq once, where because of dependently typed hypothesis, we couldn't even <em>state</em> a particular Lemma. Unfortunately, I don't remember how we worked around this problem, if we did...</p>\n<p>Is there a workaround? And how can I prove that two functors are equal, or is this something that we shouldn't even do in mathlib?</p>",
        "id": 231537373,
        "sender_full_name": "Justus Springer",
        "timestamp": 1616530876
    },
    {
        "content": "<p>We actually do have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.functor.ext\">docs#category_theory.functor.ext</a>, which uses <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.eq_to_hom\">docs#category_theory.eq_to_hom</a> to work around the problem you described. As you already guessed, this is rarely a good idea. In the vast majority of cases, it is much better to instead provide a natural isomorphism between the two functors.</p>",
        "id": 231539203,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1616531632
    },
    {
        "content": "<p>More generally, unless your category is some kind of partial order, the moment when you start talking about equality of objects, it is probably a good idea to think about whether there is a better approach that avoids this (and talks about isomorphisms instead).</p>",
        "id": 231539905,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1616531914
    },
    {
        "content": "<p>Note that you can state the lemma by using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/heq\">docs#heq</a> (<code>==</code>) between the maps</p>",
        "id": 231540785,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616532270
    },
    {
        "content": "<p>Oh, I didn't see that one, thanks!</p>",
        "id": 231541646,
        "sender_full_name": "Justus Springer",
        "timestamp": 1616532654
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260921\">Markus Himmel</span> <a href=\"#narrow/stream/113489-new-members/topic/extensionality.20for.20functors/near/231539905\">said</a>:</p>\n<blockquote>\n<p>More generally, unless your category is some kind of partial order, the moment when you start talking about equality of objects, it is probably a good idea to think about whether there is a better approach that avoids this (and talks about isomorphisms instead).</p>\n</blockquote>\n<p>If we are talking about paper-math, I 100% agree with this statement. But I thought since Lean doesn't have univalence, isomorphisms would be a pain to work with, since we can't rewrite with them. Is this not the case?</p>",
        "id": 231542281,
        "sender_full_name": "Justus Springer",
        "timestamp": 1616532964
    },
    {
        "content": "<p>I don't have any experience with isomorphisms in Lean yet, so any additional information about how to properly use them would be nice :)</p>",
        "id": 231542424,
        "sender_full_name": "Justus Springer",
        "timestamp": 1616533054
    },
    {
        "content": "<p>They're not exactly fun to work with, but I would argue that dealing with <code>heq</code> or <code>eq_to_hom</code> is even worse. In my experience, with well-chosen simp lemmas, many isomorphisms that could potentially be annoying are almost invisible.</p>",
        "id": 231543419,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1616533433
    },
    {
        "content": "<p>We also have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.functor.hext\">docs#category_theory.functor.hext</a> if you REALLY want to worry about heq</p>",
        "id": 231546411,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616534753
    },
    {
        "content": "<p>These are not marked with <code>@[ext]</code> because you should think twice about using them <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 231546649,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616534846
    },
    {
        "content": "<p>How does Coq handle heq?</p>",
        "id": 231548955,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616535942
    },
    {
        "content": "<p>Not very well, because it doesn't have proof irrelevance</p>",
        "id": 231562259,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616544030
    },
    {
        "content": "<p>It's possible to define, of course, but it doesn't have a lot of the properties you would want. It's better to use pathovers as in HoTT</p>",
        "id": 231562371,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616544090
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">path</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">fa</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">},</span> <span class=\"n\">F</span> <span class=\"n\">b</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">:</span> <span class=\"n\">path</span> <span class=\"n\">fa</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">a</span> <span class=\"bp\">`=</span><span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"n\">F</span><span class=\"bp\">`;`</span><span class=\"n\">p</span><span class=\"bp\">`</span><span class=\"o\">]</span><span class=\"bp\">`</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">path</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">p</span>\n</code></pre></div>",
        "id": 231562699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616544320
    },
    {
        "content": "<p>I remember seeing a thread about <code>path</code>s a while ago; has it been concluded they're less convenient to work with than <code>heq</code>, or has no one really tried them out seriously in lean?</p>",
        "id": 231590670,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616568797
    },
    {
        "content": "<p>No one has tried them out seriously. I think they would be better than <code>heq</code>, but not as good as avoiding them entirely using sigma-type encodings</p>",
        "id": 231590857,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616569036
    },
    {
        "content": "<p>One problem with pathovers is that you eventually find yourself needing pathoverovers too</p>",
        "id": 231590891,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616569082
    },
    {
        "content": "<p>Is <code>path F a b p</code> different to <code>eq.rec a p = b</code> other than having F explicit unlike the C of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/eq.rec\">docs#eq.rec</a>?</p>",
        "id": 231591349,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616569482
    },
    {
        "content": "<p>I tried out using <code>eq.rec</code> instead of <code>==</code>, but the elaborator makes it harder for me than I'd like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- With `heq` -/</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Œ≥</span> <span class=\"o\">:</span> <span class=\"bp\">Œ†</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">Œ≤</span> <span class=\"n\">a</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">Œ£</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">Œ≥</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">x.1</span> <span class=\"bp\">=</span> <span class=\"n\">y.1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">x.2.1</span> <span class=\"bp\">==</span> <span class=\"n\">y.2.1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">x.2.2</span> <span class=\"bp\">==</span> <span class=\"n\">y.2.2</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">x_snd</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">y_snd</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">h3</span><span class=\"o\">,</span> <span class=\"n\">refl</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">def</span> <span class=\"n\">sigma_ext_rec</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"bp\">‚àÄ</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">Œ£</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">Œ≤</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">x.fst</span> <span class=\"bp\">=</span> <span class=\"n\">y.fst</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">h1.rec</span> <span class=\"n\">x.2</span> <span class=\"bp\">=</span> <span class=\"n\">y.2</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n<span class=\"bp\">|</span> <span class=\"o\">‚ü®</span><span class=\"n\">x1</span><span class=\"o\">,</span> <span class=\"n\">x2</span><span class=\"o\">‚ü©</span> <span class=\"o\">‚ü®</span><span class=\"n\">y1</span><span class=\"o\">,</span> <span class=\"n\">xy</span><span class=\"o\">‚ü©</span> <span class=\"n\">rfl</span> <span class=\"n\">rfl</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"sd\">/-- With `eq.rec` -/</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Œ≥</span> <span class=\"o\">:</span> <span class=\"bp\">Œ†</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">Œ≤</span> <span class=\"n\">a</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">Œ£</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">Œ≥</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">x.1</span> <span class=\"bp\">=</span> <span class=\"n\">y.1</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- `(h1.rec x.2).1 = y.2.1` isn't accepted by the elaborator</span>\n  <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">eq.rec</span> <span class=\"n\">x.2</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">Œ£</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">Œ≥</span> <span class=\"n\">y.1</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">y.2.1</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- `h2.rec (h1.rec x.2).2 = y.2.2` isn't accepted by the elaborator</span>\n  <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">eq.rec</span> <span class=\"o\">(</span><span class=\"n\">eq.rec</span> <span class=\"n\">x.2</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">Œ£</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">Œ≥</span> <span class=\"n\">y.1</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">Œ≥</span> <span class=\"n\">y.1</span> <span class=\"n\">y.2.1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">y.2.2</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- the previous proof would work too</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h3</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 231611294,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616581602
    },
    {
        "content": "<p>I guess it's still preferable to replace isomorphisms by equalities whenever possible? For example I was just able to get :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">map_id'</span> <span class=\"o\">:</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"mi\">ùüô</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">ùü≠</span> <span class=\"o\">(</span><span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">unfold</span> <span class=\"n\">map</span><span class=\"o\">,</span> <span class=\"n\">congr</span><span class=\"o\">,</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"n\">ext</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>in place of <a href=\"https://leanprover-community.github.io/mathlib_docs/topology/category/Top/opens.html#topological_space.opens.map_id\">https://leanprover-community.github.io/mathlib_docs/topology/category/Top/opens.html#topological_space.opens.map_id</a><br>\nI'm looking into this because I want to prove an equality involving pushforward of sheaves, in turn because I want to show any pushforward of a sheaf is a sheaf (using the pairwise_intersection condition), where I'd like to show two cones (implemented as natural transformation between functors) inside <code>is_limit</code> are equal.</p>\n<p>BTW I find that initializing Lean in the file presheaf.lean (or maybe it's Top/opens.lean) cost a long time and 2-3 GB memory on my machine, even though I have freshly made .olean files with mk-cache and get-cache ...</p>",
        "id": 257877719,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1634435072
    },
    {
        "content": "<p>No, the opposite, when talking about functors it is better to replace equalities with isomorphisms, because relying on the equalities will result in badness (either eq.rec / cast in goals, or heavy refl proofs) down the line that you don't have control over, whereas working with isomorphisms (which is admittedly more cumbersome) you at least know what you're getting into.</p>",
        "id": 257878205,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634435551
    },
    {
        "content": "<p>(Opening <code>topology/sheaves/presheaf.lean</code> after restarting the Lean server takes &lt;5s on my machine. <code>Top/opens.lean</code> took more like 2s.)</p>",
        "id": 257878355,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634435734
    },
    {
        "content": "<p>Hmm, revert to an earlier commit fixes the problem (though it still takes several minutes to initialize on my machine, which is normal) and the memory used is now less than 1.5 GB.<br>\nI guess the problem is that I added lemmas named <code>op_comp</code> and <code>comp_assoc</code> to category_theory/opposite.lean and functor.lean and these may break some proofs in other files due to name conflict (in fact I fixed two in opposite.lean) and these broken proofs may be imported by the files opens.lean and presheaf.lean I am working on, so Lean is confused and stays in the yellow busy state. Is there an easy way to confirm this is the case? Lean doesn't output anything when busy, and mk-cache doesn't detect the problem (it doesn't abort or output anything).</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113489-new-members/topic/extensionality.20for.20functors/near/257878355\">said</a>:</p>\n<blockquote>\n<p>(Opening <code>topology/sheaves/presheaf.lean</code> after restarting the Lean server takes &lt;5s on my machine. <code>Top/opens.lean</code> took more like 2s.)</p>\n</blockquote>",
        "id": 257937374,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1634494163
    },
    {
        "content": "<p>I guess the equalities should still be useful; one can easily construct an iso from an eq. Maybe just add a <code>'</code> or <code>_eq</code> to the eq's name and construct the iso using it? Would you approve this kind of change?<br>\n<span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113489-new-members/topic/extensionality.20for.20functors/near/257878205\">said</a>:</p>\n<blockquote>\n<p>No, the opposite, when talking about functors it is better to replace equalities with isomorphisms, because relying on the equalities will result in badness (either eq.rec / cast in goals, or heavy refl proofs) down the line that you don't have control over, whereas working with isomorphisms (which is admittedly more cumbersome) you at least know what you're getting into.</p>\n</blockquote>",
        "id": 257937548,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1634494324
    },
    {
        "content": "<p>Compile the file you think you might have broken on the command line</p>",
        "id": 257953966,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1634509815
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/113489-new-members/topic/extensionality.20for.20functors/near/257877719\">said</a>:</p>\n<blockquote>\n<p>I'm looking into this because I want to prove an equality involving pushforward of sheaves, in turn because I want to show any pushforward of a sheaf is a sheaf (using the pairwise_intersection condition), where I'd like to show two cones (implemented as natural transformation between functors) inside <code>is_limit</code> are equal.</p>\n</blockquote>\n<p><a href=\"https://github.com/alreadydone/mathlib/commit/71230c42843765c05d0864e7309ca288b2fe18b5#diff-a88d397f1b2629d53f1609f24801d984c31d5553a27f873cef23c20a563c7535R87\">Alright I finished the proof</a>, but I'm not really sure how it works! Especially where the <code>congr</code> and <code>convert</code> tactics (or <code>functor.hext</code> which uses <code>congr</code>) which often reduces an eq goal to some eq goals but also some heq goals.<br>\nAlthough it's in mathlib that we can transfer <code>is_limit</code> between two isomorphic cones, we can't state that two cones / natural transformations are isomorphic before proving that they're over the same (defeq) functor / between the same two functors, and there doesn't seem to be a more sophisticated theorem that applies (maybe more higher category theory needs to be developed), so I'm content with the current approach. Would be fantastic if someone can further golf it.</p>",
        "id": 258143543,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1634621228
    },
    {
        "content": "<p>Probably best to make a PR so others can take a look taking advantage of precompiled oleans.</p>",
        "id": 258144248,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634621920
    },
    {
        "content": "<p>Done (<a href=\"https://github.com/leanprover-community/mathlib/issues/9801\">#9801</a>)! The branch doesn't have to be in the main leanprover-community repo for oleans to be generated, right?</p>",
        "id": 258144984,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1634622610
    },
    {
        "content": "<p>It does, unfortunately, because the oleans need to be deployed to our server.</p>",
        "id": 258145370,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634622978
    },
    {
        "content": "<p>I just sent you an invitation with write access to non-master branches. Could you close your PR and open a new one from a branch on the main repo?</p>",
        "id": 258145428,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634623062
    },
    {
        "content": "<p>On a side note, I am also actively working towards the adjunction based on the blueprints of Justus. If you are planning to your proofs into mathlib, it would be great if we could coordinate together and split the work to avoid stepping on each other's toes.</p>",
        "id": 258146040,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1634623555
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113489-new-members/topic/extensionality.20for.20functors/near/258145428\">said</a>:</p>\n<blockquote>\n<p>I just sent you an invitation with write access to non-master branches. Could you close your PR and open a new one from a branch on the main repo?</p>\n</blockquote>\n<p>Thanks! I accepted and made new PR <a href=\"https://github.com/leanprover-community/mathlib/issues/9802\">#9802</a></p>",
        "id": 258146546,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1634623977
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/113489-new-members/topic/extensionality.20for.20functors/near/258146040\">said</a>:</p>\n<blockquote>\n<p>On a side note, I am also actively working towards the adjunction based on the blueprints of Justus. If you are planning to your proofs into mathlib, it would be great if we could coordinate together and split the work to avoid stepping on each other's toes.</p>\n</blockquote>\n<p>Of course! All my current work is in the PR. Now that I proved f_* O_X is a sheaf, it's just a matter of plugging in the arguments to define the sheaf morphism in the counit of the adjunction.</p>",
        "id": 258146693,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1634624109
    },
    {
        "content": "<p>(Yeah, I now realize the unit-counit approach is simpler and no longer pursues the hom_equiv route.)</p>",
        "id": 258146800,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1634624199
    },
    {
        "content": "<p>As for gluing morphisms on sheaves, the equivalent formulation on my path was just finished some days ago at <a href=\"https://github.com/leanprover-community/mathlib/issues/9694\">#9694</a>.<br>\nI suppose it would be better to use that to avoid duplicate code.<br>\nAlso IMHO the fact that the pushforward of a sheaf is a sheaf should probably go in <code>src/topology/sheaves/stalks.lean</code>.<br>\n(another way to show this is to show that continuous maps induces continuous functors between sites, which could potentially unlock more stuff such as pullbacks, but I doubt we would need that generality for now).</p>",
        "id": 258148219,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1634625418
    },
    {
        "content": "<p>Congrats on your colossal series of work! If you can just prove <a href=\"https://github.com/leanprover-community/mathlib/pull/9802/files#diff-d7cc616887430b2cb5792e3d691f45c1bbc3eaa32c3abf1c4e735ab8b9a904d9R153\">the last theorem from basis_le.lean</a> then I can mostly abandon the rest of the file. <code>lim_basis_le_of_sheaf</code> and <code>mono_to_basis_le_of_sheaf</code> might be useful for other purposes and it would be nice to derive these specialized versions from more general versions that you probably already proved.<br>\nThe pushforward of sheaf thing doesn't involve stalks at all, so I think should just go into <code>topology/sheaves/sheaf.lean</code>, which should import the pairwise_intersection file and prove the is_sheaf version of the theorem. If pairwise_intersection is promoted to the official definition then there would be nothing to prove. In fact the proof is rather trivial and I expect the same for the sites version, but the type system complicates matters. I even think it should be proven by defeq under the \"ideal\" defeq, but Lean's algorithmic defeq doesn't recognize it. Probably Lean has problem defequating one morphism from <code>le_supr</code> and another from mapping <code>le_supr</code> by a functor (<code>opens.map f</code>); for sites this issue may not exist. (Or maybe the problem is elsewhere: preimage of intersection seems to be defeq, but preimage_Union seems not. <code>opens X</code> as subtype of <code>set X</code> seems fine, so seems the <code>plift</code> <code>ulift</code> to promote open set inclusion to a morphism.)</p>",
        "id": 258156397,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1634630567
    },
    {
        "content": "<p>Oh yes I mistyped...<br>\nI meant <code>sheaf.lean</code>. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 258159837,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1634632562
    },
    {
        "content": "<p>The sites version of the pushforward stuff is probably <a href=\"https://github.com/leanprover-community/mathlib/issues/9691\">#9691</a>.<br>\nThat said, to show that continuous functions are <code>compatible_preserving</code>, the right way is probably to show that it preserves finite limits and to use <a href=\"https://github.com/leanprover-community/mathlib/issues/9519\">#9519</a>. However, Bhavik seems to have some more thoughts on flat functors, and thus it would probably take some time before It goes into mathlib.</p>\n<p>At first glance, <code>mono_to_basis_le_of_sheaf_condition</code> seems to be either <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.presieve.is_separated_for.ext\">docs#category_theory.presieve.is_separated_for.ext</a> or <code>cover_dense.ext</code> in <a href=\"https://github.com/leanprover-community/mathlib/issues/9694\">#9694</a>. As for <code>lim_basis_le_of_sheaf</code>, the sheaf condition of sites is not defined in terms of limits, and thus there probably would not be an analogue for now.</p>",
        "id": 258161386,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1634633418
    },
    {
        "content": "<p>This is great that we are now beginning to be able to start defining the basic \"arithmetic\" of sheaves, e.g. pushing forward and pulling back. One goal would be to prove that these are adjoint functors (although strictly speaking this is a construction, not a proof). </p>\n<p>For me a good next challenge might be to start thinking about sheaves of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">O</mi><mi>X</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}_X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-modules. The reason that this will be a challenge is that my memory was that there were several competing proposals for what the definition of a sheaf of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">O</mi><mi>X</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}_X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-modules should be. Choosing a definition and then trying to define pushforward and pullback, and then proving the adjointness of the corresponding constructions, would surely be worth a paper. The category of quasicoherent <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">O</mi><mi>X</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}_X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-modules over a scheme is a fundamental object in algebraic geometry. Me+Amelia+Kenny+Chris+Ramon+Scott's paper on the definition of a scheme got published, and I should think that the Isabelle definition of a scheme will end up published too, but if we're in an algebraic geometry race with Isabelle (which I hope we are!) then this would be a really good marker to put down. The computer scientists might complain that it's definition, definition, definition and not theorem, theorem, theorem, but algebraic geometry is a complicated subject and we need all the definitions before we can start stating the theorems. Sheaf cohomology is another definition which we will need before too long, but there have been a bunch of breakthroughs in homological algebra recently as part of LTE and so it's only a matter of time. Once we have that, then we can start stating a whole bunch of theorems, and attempting to prove them will inform our API.</p>",
        "id": 258170194,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1634638212
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/5c5d818dd8b76450bebff89bf1719be5259f9672/src/topology/category/Top/opens.lean#L148\">Here</a> it says <code>map_comp_obj</code> is \"not quite <code>rfl</code>, since we don't have eta for records\", but currently it can actually be proven by <code>rfl</code>. Is this due to some change in the kernel? <code>map_id_obj</code> indeed isn't <code>rfl</code> but almost is, as it can be proven with <code>let ‚ü®_,_‚ü© := U in rfl</code>. Moreover, <code>le_map_top</code> can be proven simply by <code>le_top U</code>, and similarly the definition of the global section functor in presheafed_space.lean can omit the composition with le_top.<br>\nI'm going through these files (and presheaf.lean) to simplify many other such cases and make some additions, and I think it's a good idea to ask here to ensure that such simplifications aren't discouraged for some reason.</p>",
        "id": 258846371,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1635028836
    },
    {
        "content": "<p>I don't think <code>let ‚ü®_,_‚ü© := U in rfl</code> is substantially different than the existing proof of <code>map_id_obj</code>.</p>",
        "id": 258846648,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1635029248
    },
    {
        "content": "<p>For <code>map_comp_obj</code>, yes, this seems to be a mistake. There's enough code using this stuff downstream that you can safely just try out the change. If nothing breaks downstream then it's fine. If something does break downstream you can improve the comment to explain what's really going on!</p>",
        "id": 258846700,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1635029302
    },
    {
        "content": "<p>Removing the composition with <code>le_top</code> in the global section functor (I haven't actually looked at this recently, so take this with a grain of salt) sounds like a bad idea, however. It may be forcing Lean to do more definitional unfolding, so if it is there is may well be there to improve a performance issue. (Ideally there would be a comment explaining this if that is the case, but ....)</p>",
        "id": 258846778,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1635029431
    },
    {
        "content": "<p>Interesting that there are such tricks that make definitions more complicated to improve performance. However it's making one of my proofs more complicated and forced me to prove a lemma stating <code>Gamma.map f.op = f.1.c.app (op T)</code>for a morphism f of LocallyRingedSpace while it should really be <code>rfl</code>. Maybe I could also submit a PR and compare the compile time?</p>\n<p>By the way, a consequence of <code>map_comp_obj</code>'s rfl is that the equality version of <code>map_comp</code>is also rfl.</p>",
        "id": 258847032,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1635029829
    },
    {
        "content": "<p>Usually you don't even need to compare overall compile times (which are noisy and hard to compare anyway). Usually a problem like this exhibits itself as a deterministic timeout, so as long as you can <code>lean --make -T100000 src</code> successfully you probably haven't broken anything.</p>",
        "id": 258847095,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1635029944
    },
    {
        "content": "<p>I wrote a fair bit of this stuff, but it was a long time ago, and I remember struggling in places. I wouldn't be at all surprised if there are just mistakes.</p>",
        "id": 258847101,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1635029979
    },
    {
        "content": "<p>Thanks this is the first time I see the compile command. I'm recently getting (100 seconds?) deterministic timeouts in my working Spec-Gamma adjunction file in VSCode and had to increase the time limit (it's in the VSCode Lean setting), but hopefully it goes away when more lemmas are placed into appropriate files.</p>\n<p>So you think these are not due to changes in how the kernel checks defeq, and you just didn't try? In the same file, <code>map_comp_obj_unop</code> and <code>op_map_comp_obj</code> are also <code>rfl</code>s, but not <code>op_map_id_obj</code>, not even <code>let ‚ü®_,_‚ü© := U.unop in rfl</code> ...</p>",
        "id": 258847607,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1635030747
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113489-new-members/topic/extensionality.20for.20functors/near/258846648\">said</a>:</p>\n<blockquote>\n<p>I don't think <code>let ‚ü®_,_‚ü© := U in rfl</code> is substantially different than the existing proof of <code>map_id_obj</code>.</p>\n</blockquote>\n<p>Yes it's probably equivalent but would such term mode proof be faster in general?</p>",
        "id": 258847619,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1635030833
    },
    {
        "content": "<p>No, I wouldn't expect it to be faster.</p>",
        "id": 258847728,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1635031001
    },
    {
        "content": "<p>Please don't change the time limit in the VSCode extension.</p>",
        "id": 258847730,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1635031010
    },
    {
        "content": "<p>Commit to mathlib are all compiled with that time limit in place, and you are only going to cause yourself pain to develop code with the limit raised, only to have to get it back down afterwards.</p>",
        "id": 258847739,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1635031041
    },
    {
        "content": "<p>I'm pretty certain no kernel change could affect anything like this. It may be that some earlier definition has changed, or just I made a mistake at the time.</p>",
        "id": 258847793,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1635031104
    },
    {
        "content": "<p>If anything you should _lower_ the time limit, to be sure that you're contributing code that still has some margin. :-)</p>",
        "id": 258847801,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1635031136
    },
    {
        "content": "<p>Something which Scott doesn't seem to say but which is something I learnt from him in the past is that \"trying to make the proof <code>rfl</code>\" is something which is a great idea for simple objects but which can become an actively bad idea as your objects become more complicated. Rewriting a non-<code>rfl</code> proof can sometimes be much quicker than <code>rfl</code> once terms start getting big. My (perhaps ignorant) impression of people who work with different provers or on different kinds of questions can somehow become obsessed with making things <code>refl</code> perhaps because they're computer scientists so feel that everything should compute. In maths it doesn't work like that. I'd far rather have a quick <code>rw</code> proof than a slow <code>refl</code> proof because beyond some point in mathematics <code>refl</code> doesn't actually buy you anything.</p>",
        "id": 258866482,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635063519
    },
    {
        "content": "<p>Exactly. Expecting <code>rfl</code> proofs at some point just becomes a trap: Lean can unexpectedly go off and do very inefficient proofs by definitional unfolding. Often it's better to intentionally make definitions irreducible, or wrapped in structures, precisely so Lean <em>can't</em> see through them!</p>",
        "id": 258868887,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1635067310
    },
    {
        "content": "<p>I've finished the aforementioned planned changes to <a href=\"https://github.com/alreadydone/mathlib/commit/ea89922c5e6b12fb70fc342041e6b504d5b45c44#diff-252fb30c3a3221e6472db5ba794344dfb423898696e70299653d95f635de06ad\">presheafed_space.lean</a><br>\n and associated files, but Spec.lean and has_colimits.lean have some broken proofs not yet fixed, so I haven't compiled mathlib with the time limit yet. Nonetheless, here is a preview commit containing the main changes. You can see my philosophy is to prove and make use of equalities (to \"collapse tower of isomorphisms\") and take advantage of defeqs (which may or may not be bad, as discussed above) whenever possible, and use eq_to_hom if involved types are not defeq. As you can see the changes already resulted in a lot of simplified proofs (though I have no idea about the compile time yet), but I only made minimum changes in other files, and those proofs likely can be further optimized under the new definitions. Let me know if this seems like the right approach to you.</p>",
        "id": 258931018,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1635151504
    },
    {
        "content": "<p>I think I'd like to see no sorries and no timeouts before having any opinion. :-)</p>",
        "id": 258937004,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1635155312
    },
    {
        "content": "<p>(As I said before, developing with the timelimit turned off is counterproductive.)</p>",
        "id": 258937038,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1635155352
    },
    {
        "content": "<p>I developed this on another machine where time limit wasn't turned off. I didn't get any deterministic timeouts in the files I checked, but this computer is faster (MacBook Pro 2019, 2.3GHz 8-Core Intel i9, 32 GB memory).</p>",
        "id": 258968481,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1635172885
    },
    {
        "content": "<p>I fixed all proofs and compilation using the command you gave me finished in several minutes, so I opened PR <a href=\"https://github.com/leanprover-community/mathlib/issues/9972\">#9972</a>. I didn't merge latest mathlib before compiling though. Lean spat out about 20 lines of output and they are truncated to the window width so I can't see the full messages and am not sure if the compilation has been successful. Let's wait for the automated mathlib build with the PR.</p>",
        "id": 259049443,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1635220794
    },
    {
        "content": "<p>continuous integration / Build mathlib (push) Successful in 9m</p>",
        "id": 259050017,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1635221293
    },
    {
        "content": "<p>Looks great!!</p>",
        "id": 259056859,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1635230114
    },
    {
        "content": "<p>Apologies if I was skeptical earlier. This is a big improvement.</p>",
        "id": 259056875,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1635230137
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/extensionality.20for.20functors/near/258170194\">said</a>:</p>\n<blockquote>\n<p>Me+Amelia+Kenny+Chris+Ramon+Scott's paper on the definition of a scheme got published, and I should think that the Isabelle definition of a scheme will end up published too, </p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> <br>\nHopefully, this is currently in the hands of referees.</p>",
        "id": 269454125,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1643219906
    },
    {
        "content": "<p>For the record, our paper <em>Simple Type Theory is not too Simple: Grothendieck's Schemes Without Dependent Types</em> has been published in the journal Experimental Mathematics and is open access <a href=\"https://www.tandfonline.com/doi/full/10.1080/10586458.2022.2062073\">online</a>.</p>",
        "id": 288193375,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1656692545
    }
]
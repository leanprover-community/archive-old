[
    {
        "content": "<p>Dear All,</p>\n<p>I am trying to get Lean to check that the support of the sum of two polynomials is contained in the union of the supports.  I found the command <code>finsupp.support_add</code>, claiming to do exactly this.  Unfortunately, with the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> below, I get an error.  I imagine that Lean has coerced something in the wrong type, but I have been unable to figure out what...</p>\n<p>Can someone help me, please?</p>\n<p>Thank you!</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">polynomial</span><span class=\"bp\">.</span><span class=\"n\">degree</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">supps</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">+</span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"err\">⊆</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"err\">∪</span> <span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">exact</span> <span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">support_add</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>Error (with <code>finsupp</code> underlined in red in the code):</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">type</span> <span class=\"n\">ascription</span><span class=\"o\">,</span> <span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"o\">(</span><span class=\"err\">?</span><span class=\"n\">m_4</span> <span class=\"bp\">+</span> <span class=\"err\">?</span><span class=\"n\">m_5</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"err\">⊆</span> <span class=\"err\">?</span><span class=\"n\">m_4</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"err\">∪</span> <span class=\"err\">?</span><span class=\"n\">m_5</span><span class=\"bp\">.</span><span class=\"n\">support</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">+</span> <span class=\"n\">q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"err\">⊆</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"err\">∪</span> <span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">support</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">field</span> <span class=\"n\">R</span><span class=\"o\">,</span>\n<span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span>\n<span class=\"err\">⊢</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">+</span> <span class=\"n\">q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"err\">⊆</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"err\">∪</span> <span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">support</span>\n</code></pre></div>",
        "id": 209128481,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599245379
    },
    {
        "content": "<p><code>convert finsupp.support_add,</code> does it</p>",
        "id": 209128702,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599245493
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  Thank you so much!!  I wasted so much time trying to figure out what types Lean was inferring!!</p>",
        "id": 209128865,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599245573
    },
    {
        "content": "<p>What is <code>convert</code>?</p>",
        "id": 209128919,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599245607
    },
    {
        "content": "<p><code>#check convert</code> says unknown identifier...</p>",
        "id": 209128953,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599245629
    },
    {
        "content": "<p><code>exact @finsupp.support_add _ _ _ p q,</code> gives the following error:</p>\n<div class=\"codehilite\"><pre><span></span><code>invalid type ascription, term has type\n  (p + q).support ⊆\n    @finsupp.support ℕ R\n        (@add_monoid.to_has_zero R\n           (@add_group.to_add_monoid R\n              (@add_comm_group.to_add_group R\n                 (@ring.to_add_comm_group R (@division_ring.to_ring R (@field.to_division_ring R _inst_1))))))\n        p ∪\n      @finsupp.support ℕ R\n        (@add_monoid.to_has_zero R\n           (@add_group.to_add_monoid R\n              (@add_comm_group.to_add_group R\n                 (@ring.to_add_comm_group R (@division_ring.to_ring R (@field.to_division_ring R _inst_1))))))\n        q\nbut is expected to have type\n  @finsupp.support ℕ R\n      (@mul_zero_class.to_has_zero R\n         (@monoid_with_zero.to_mul_zero_class R\n            (@semiring.to_monoid_with_zero R\n               (@ring.to_semiring R (@division_ring.to_ring R (@field.to_division_ring R _inst_1))))))\n      (p + q) ⊆\n    @finsupp.support ℕ R\n        (@mul_zero_class.to_has_zero R\n           (@monoid_with_zero.to_mul_zero_class R\n              (@semiring.to_monoid_with_zero R\n                 (@ring.to_semiring R (@division_ring.to_ring R (@field.to_division_ring R _inst_1))))))\n        p ∪\n      @finsupp.support ℕ R\n        (@mul_zero_class.to_has_zero R\n           (@monoid_with_zero.to_mul_zero_class R\n              (@semiring.to_monoid_with_zero R\n                 (@ring.to_semiring R (@division_ring.to_ring R (@field.to_division_ring R _inst_1))))))\n        q\n</code></pre></div>\n\n\n<p>and we can see if we can debug this.</p>",
        "id": 209129018,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599245644
    },
    {
        "content": "<p><code>convert</code> is a tactic, so <code>#check</code> doesn't work. You can hover over it to see the docstring.</p>",
        "id": 209129045,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599245662
    },
    {
        "content": "<p>See also <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#convert\">tactic#convert</a></p>",
        "id": 209129106,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1599245708
    },
    {
        "content": "<p>They do look different, but I do not know why...</p>",
        "id": 209129130,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599245725
    },
    {
        "content": "<p>Me neither -- this is what type class inference is doing under the hood.</p>",
        "id": 209129231,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599245769
    },
    {
        "content": "<p>Ok, anyway, I am glad that I learned how to see what Lean is doing and I will now learn <code>convert</code>!</p>",
        "id": 209129312,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599245829
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"bp\">ℕ</span> <span class=\"n\">R</span>\n        <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_monoid</span><span class=\"bp\">.</span><span class=\"n\">to_has_zero</span> <span class=\"n\">R</span>\n           <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_group</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid</span> <span class=\"n\">R</span>\n              <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_comm_group</span><span class=\"bp\">.</span><span class=\"n\">to_add_group</span> <span class=\"n\">R</span>\n                 <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">to_add_comm_group</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">division_ring</span><span class=\"bp\">.</span><span class=\"n\">to_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">field</span><span class=\"bp\">.</span><span class=\"n\">to_division_ring</span> <span class=\"n\">R</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">))))))</span>\n\n<span class=\"n\">def</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"bp\">ℕ</span> <span class=\"n\">R</span>\n        <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mul_zero_class</span><span class=\"bp\">.</span><span class=\"n\">to_has_zero</span> <span class=\"n\">R</span>\n           <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">monoid_with_zero</span><span class=\"bp\">.</span><span class=\"n\">to_mul_zero_class</span> <span class=\"n\">R</span>\n              <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">semiring</span><span class=\"bp\">.</span><span class=\"n\">to_monoid_with_zero</span> <span class=\"n\">R</span>\n                 <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">to_semiring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">division_ring</span><span class=\"bp\">.</span><span class=\"n\">to_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">field</span><span class=\"bp\">.</span><span class=\"n\">to_division_ring</span> <span class=\"n\">R</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">))))))</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n\n\n<p>So those outputs were more similar than we thought.</p>",
        "id": 209129553,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599245994
    },
    {
        "content": "<p>I interpret this as Lean having found 2 separate ways of loosing information to obtain a semi-quasi-almost-monoid and then being confused about why they are the same... is this more or less correct?</p>",
        "id": 209129706,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599246082
    },
    {
        "content": "<p>Well, exact is failing so there are some things which really are not equal by definition. We have to dig deeper:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">polynomial</span><span class=\"bp\">.</span><span class=\"n\">degree</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">}</span>\n\n<span class=\"kn\">set_option</span> <span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">all</span> <span class=\"n\">true</span> <span class=\"c1\">-- NEW</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">supps</span>  <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">+</span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"err\">⊆</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"err\">∪</span> <span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">support_add</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 209129922,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599246184
    },
    {
        "content": "<p>Btw, also assuming <code>semiring</code> things do not work with <code>exact</code>: that might have less overhead of conversion...</p>",
        "id": 209130288,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599246385
    },
    {
        "content": "<p>(I'm feeding my cats, so I can only type with my phone for a couple minutes!)</p>",
        "id": 209130379,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599246443
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">polynomial</span><span class=\"bp\">.</span><span class=\"n\">degree</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">}</span>\n\n<span class=\"kn\">set_option</span> <span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">all</span> <span class=\"n\">true</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">supps</span>  <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">+</span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"err\">⊆</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"err\">∪</span> <span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">support_add</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n\n<span class=\"n\">def</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>  <span class=\"bp\">@</span><span class=\"n\">has_subset</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">has_subset</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"n\">R</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_monoid</span><span class=\"bp\">.</span><span class=\"n\">to_has_zero</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_comm_monoid</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">semiring</span><span class=\"bp\">.</span><span class=\"n\">to_add_comm_monoid</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)))</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">has_add</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"n\">R</span>\n             <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_monoid</span><span class=\"bp\">.</span><span class=\"n\">to_has_zero</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span>\n                <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_comm_monoid</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">semiring</span><span class=\"bp\">.</span><span class=\"n\">to_add_comm_monoid</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">))))</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">has_add</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"n\">R</span>\n             <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_comm_monoid</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">semiring</span><span class=\"bp\">.</span><span class=\"n\">to_add_comm_monoid</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)))</span>\n          <span class=\"n\">p</span>\n          <span class=\"n\">q</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">has_union</span><span class=\"bp\">.</span><span class=\"n\">union</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">has_union</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">prop_decidable</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)))</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"n\">R</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_monoid</span><span class=\"bp\">.</span><span class=\"n\">to_has_zero</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span>\n             <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_comm_monoid</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">semiring</span><span class=\"bp\">.</span><span class=\"n\">to_add_comm_monoid</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)))</span>\n          <span class=\"n\">p</span><span class=\"o\">)</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"n\">R</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_monoid</span><span class=\"bp\">.</span><span class=\"n\">to_has_zero</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span>\n             <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_comm_monoid</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">semiring</span><span class=\"bp\">.</span><span class=\"n\">to_add_comm_monoid</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)))</span>\n          <span class=\"n\">q</span><span class=\"o\">))</span>\n\n<span class=\"n\">def</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span>  <span class=\"bp\">@</span><span class=\"n\">has_subset</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">has_subset</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"n\">R</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mul_zero_class</span><span class=\"bp\">.</span><span class=\"n\">to_has_zero</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">monoid_with_zero</span><span class=\"bp\">.</span><span class=\"n\">to_mul_zero_class</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">semiring</span><span class=\"bp\">.</span><span class=\"n\">to_monoid_with_zero</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)))</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">has_add</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">polynomial</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">distrib</span><span class=\"bp\">.</span><span class=\"n\">to_has_add</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">polynomial</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)</span>\n             <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">semiring</span><span class=\"bp\">.</span><span class=\"n\">to_distrib</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">polynomial</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">polynomial</span><span class=\"bp\">.</span><span class=\"n\">semiring</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)))</span>\n          <span class=\"n\">p</span>\n          <span class=\"n\">q</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">has_union</span><span class=\"bp\">.</span><span class=\"n\">union</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">has_union</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">decidable_eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"n\">R</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mul_zero_class</span><span class=\"bp\">.</span><span class=\"n\">to_has_zero</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span>\n             <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">monoid_with_zero</span><span class=\"bp\">.</span><span class=\"n\">to_mul_zero_class</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">semiring</span><span class=\"bp\">.</span><span class=\"n\">to_monoid_with_zero</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)))</span>\n          <span class=\"n\">p</span><span class=\"o\">)</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"n\">R</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mul_zero_class</span><span class=\"bp\">.</span><span class=\"n\">to_has_zero</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span>\n             <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">monoid_with_zero</span><span class=\"bp\">.</span><span class=\"n\">to_mul_zero_class</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">semiring</span><span class=\"bp\">.</span><span class=\"n\">to_monoid_with_zero</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)))</span>\n          <span class=\"n\">q</span><span class=\"o\">))</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 209130511,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599246507
    },
    {
        "content": "<p>In case it's helpful, I've expanded out <code>convert</code> as tactics:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">supps</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">+</span> <span class=\"n\">q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"err\">⊆</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"err\">∪</span> <span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">support_add</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"bp\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">congr</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 209130543,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1599246531
    },
    {
        "content": "<p>Now it's <code>congr</code> that's doing the heavy lifting, somehow.</p>",
        "id": 209130578,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1599246546
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">X</span> <span class=\"n\">R</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">Y</span> <span class=\"n\">R</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">Y</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- refl, -- fails</span>\n  <span class=\"n\">congr&#39;</span> <span class=\"c1\">-- works</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>Right, so you've got to the same stage as me but without the ugly staring at types. Nice!</p>",
        "id": 209131010,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599246802
    },
    {
        "content": "<p>I've gotten down to <code>finset.has_union</code> not equaling <code>finset.has_union</code> by <code>refl</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">supps</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">+</span> <span class=\"n\">q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"err\">⊆</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"err\">∪</span> <span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">support_add</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"bp\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">congr_core&#39;</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- finset ℕ = finset ℕ</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- finset.has_subset = finset.has_subset</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- (p + q).support = (p + q).support</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- p.support ∪ q.support = p.support ∪ q.support</span>\n  <span class=\"c1\">-- refl doesn&#39;t work!</span>\n  <span class=\"n\">congr_core&#39;</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- finset ℕ = finset ℕ</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"n\">swap</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- p.support = p.support</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"n\">swap</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- q.support = q.support</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- finset.has_union = finset.has_union</span>\n  <span class=\"c1\">-- refl doesn&#39;t work!</span>\n\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 209131185,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1599246881
    },
    {
        "content": "<p>Here's another way:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">supps</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">+</span> <span class=\"n\">q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"err\">⊆</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"err\">∪</span> <span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">support_add</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"bp\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">congr&#39;</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"c1\">-- fails</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>Note <code>congr' 3</code> solves the goal.</p>",
        "id": 209131266,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599246934
    },
    {
        "content": "<p>It looks like it's the decidability proof for finset's union:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"err\">⊢</span> <span class=\"bp\">@</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">has_union</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">has_union</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">decidable_eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">has_union</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">prop_decidable</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)))</span>\n</code></pre></div>",
        "id": 209131285,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1599246943
    },
    {
        "content": "<p>Can I say that <code>finset</code>s are evil?  They <em>always</em> cause problems for me...</p>",
        "id": 209131357,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599246972
    },
    {
        "content": "<p>just put <code>open_locale classical</code> at the beginning</p>",
        "id": 209131377,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1599246985
    },
    {
        "content": "<p>edit: still doesn't work</p>",
        "id": 209131427,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1599247031
    },
    {
        "content": "<p>So <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> the solution is that <code>nat.decidable_eq a b</code> is not equal <em>by definition</em> to <code>classical.prop_decidable (@eq.{1} nat a b)</code>.</p>",
        "id": 209131430,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599247032
    },
    {
        "content": "<p>Ok, I am not sure that I understand, but at least I am getting a sense of what is happening...</p>",
        "id": 209131529,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599247087
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">decidable_eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">prop_decidable</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- fails</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">subsingleton</span> <span class=\"o\">(</span><span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- works</span>\n</code></pre></div>\n\n\n<p>This is why <code>exact</code> fails but <code>convert</code> works.</p>",
        "id": 209131672,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599247200
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> are your two examples equivalent mathematically?  I do not really understand what they say...</p>",
        "id": 209131917,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599247343
    },
    {
        "content": "<p>It turns out that the two terms were not exactly the same. Lean's type class inference system fills in a lot of missing information for you -- that's its job. When you have (a b : nat) and write <code>a + b</code> this literally means <code>has_add.add a b</code>. Lean now has to figure out exactly the addition you mean, and it asks the type class inference system for an addition on the naturals, and the type class inference system returns one. </p>\n<p>When you were trying to use the finsupp lemma to prove a result about polynomials, Lean twice had to ask the type class inference system for a proof that it is possible to decide whether two naturals are equal -- first when you stated the theorem, and secondly when you used the term that you hoped would prove it. However it got two different answers.</p>",
        "id": 209131952,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599247367
    },
    {
        "content": "<p>Ok, this is clearer, thanks!</p>",
        "id": 209132019,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599247430
    },
    {
        "content": "<p>By the way, the reason it's asking for this is that for finitely supported functions, the way they are implemented, the support is part of the data, and for Lean to figure out exactly which naturals are in the support it needs an algorithm to work out if two naturals are equal. It found two algorithms.</p>",
        "id": 209132111,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599247473
    },
    {
        "content": "<p>I had thought that the issue was with identifying the supports of the sum and the individual supports as being sets in the same ambient space...  If I understand correctly, the issue was at a deeper level</p>",
        "id": 209132151,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599247505
    },
    {
        "content": "<p>The first one is <code>nat.decidable_eq</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"bp\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span>     <span class=\"n\">zero</span>     <span class=\"o\">:=</span> <span class=\"n\">is_true</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">zero</span>     <span class=\"o\">:=</span> <span class=\"n\">is_false</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">no_confusion</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span>     <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">is_false</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">no_confusion</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">is_true</span> <span class=\"n\">xeqy</span> <span class=\"o\">:=</span> <span class=\"n\">is_true</span> <span class=\"o\">(</span><span class=\"n\">xeqy</span> <span class=\"bp\">▸</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n    <span class=\"bp\">|</span> <span class=\"n\">is_false</span> <span class=\"n\">xney</span> <span class=\"o\">:=</span> <span class=\"n\">is_false</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">no_confusion</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">xeqy</span><span class=\"o\">,</span> <span class=\"n\">absurd</span> <span class=\"n\">xeqy</span> <span class=\"n\">xney</span><span class=\"o\">))</span>\n    <span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>This is the algorithm which uses induction: zero = zero, and succ m = succ n iff m = n.</p>",
        "id": 209132171,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599247526
    },
    {
        "content": "<p>But <code>classical.prop_decidable</code> just says \"oh come on, x=y is a true-false statement, and mathematicians believe in the law of the excluded middle, which means that an algorithm exists for figuring out whether this is true or false, and let's use that algorithm.\"</p>",
        "id": 209132347,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599247649
    },
    {
        "content": "<p>These are definitely two different algorithms, not least because one of them isn't really an algorithm, it's just switching on a switch which says \"forget the algorithm stuff, we are mathematicians and do not care about decidable equality\"</p>",
        "id": 209132449,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599247697
    },
    {
        "content": "<p>However, Lean also knows that both these algorithms are correct, and hence must produce the same answer. Hence the algorithms must be equal, if we define equal algorithms in a highly mathematical way as \"must produce the same answer\".</p>",
        "id": 209132546,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599247775
    },
    {
        "content": "<p>This is making more sense.  This is now off a tangent and is completely irrelevant for the purpose of my original question: <em>why</em> did Lean once use <code>nat.decidable</code> and once <code>classical.prop_decidable</code>?</p>",
        "id": 209132626,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599247819
    },
    {
        "content": "<p>For example, there is only one \"sort\" function, which takes a finite list of natural numbers and returns the same list but sorted. Two functions are equal if and only if they output the same output given the same input, right?</p>",
        "id": 209132630,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599247824
    },
    {
        "content": "<p>But computer scientists would argue that there were many sorting algorithms, because they care about the implementation and not just the output.</p>",
        "id": 209132681,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599247856
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/support_add/near/209132630\">said</a>:</p>\n<blockquote>\n<p>For example, there is only one \"sort\" function, which takes a finite list of natural numbers and returns the same list but sorted. Two functions are equal if and only if they output the same output given the same input, right?</p>\n</blockquote>\n<p>It is similar to using or not using the bound given by GRH to compute class groups...</p>",
        "id": 209132734,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599247907
    },
    {
        "content": "<p><code>convert</code> is clever. It looks for subsingleton instances, and if it finds them then it uses them. So <code>convert</code> can find a proof that <code>a = b</code> if it knows that <code>a : T</code> and <code>b : T</code> and <code>subsingleton T</code>.</p>",
        "id": 209132736,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599247911
    },
    {
        "content": "<p>well the problem with the GRH algorithm is that we haven't yet proved that it works :-)</p>",
        "id": 209132800,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599247931
    },
    {
        "content": "<p>The reason Lean found both is because they are both in the system, and Lean used different methods to look for them and found them both.</p>",
        "id": 209132845,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599247981
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/support_add/near/209132800\">said</a>:</p>\n<blockquote>\n<p>well the problem with the GRH algorithm is that we haven't yet proved that it works :-)</p>\n</blockquote>\n<p>Right, but should GRH be true, the two algorithms are <code>the same</code>!  </p>\n<p>Anyway, I understand the difference, thanks!</p>",
        "id": 209132854,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599247988
    },
    {
        "content": "<p>This has been very informative: thanks!</p>",
        "id": 209132887,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599248019
    },
    {
        "content": "<p>One could fiddle with instance priorities to try and make this not happen, but this is beyond my pay grade. I have no idea why Lean finds them both.</p>",
        "id": 209132896,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599248024
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/support_add/near/209132896\">said</a>:</p>\n<blockquote>\n<p>One could fiddle with instance priorities to try and make this not happen, but this is beyond my pay grade. I have no idea why Lean finds them both.</p>\n</blockquote>\n<p>Sure and, for me, already just knowing that I could use <code>convert</code> was a pretty good answer!</p>",
        "id": 209132977,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599248058
    },
    {
        "content": "<p><code>convert</code> is a great tactic when something which should work, doesn't. It's also a cool way of reasoning -- I use it a lot. You kind of know what the last line of the proof is, approximately, early on, and <code>convert</code> lets you apply it it immediately.</p>",
        "id": 209144058,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599256042
    },
    {
        "content": "<p>I'll try it often, then!</p>",
        "id": 209144291,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599256232
    },
    {
        "content": "<p>I also think <code>convert</code> is great, but one thing to keep in mind: sometimes it spits out incomprehensible nonsense. When this has happened to me, it was always my fault, and just meant that I needed to do a bit more work before using it.</p>",
        "id": 209144531,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599256479
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> I looked into this a bit more. The file <code>data.finsupp.basic</code> in mathlib has the following warning at the beginning:</p>\n<div class=\"codehilite\"><pre><span></span><code>A general piece of advice is to not use `α →₀ β` directly, as the type class setup might not be a\ngood fit. Defining a copy and selecting the instances that are best suited for the application works\nbetter.\n\n## Implementation notes\n\nThis file is a `noncomputable theory` and uses classical logic throughout.\n\n## Notation\n\nThis file defines `α →₀ β` as notation for `finsupp α β`.\n</code></pre></div>\n\n\n<p>So what's happening is that when you use <code>finsupp.support_add</code> it uses classical logic to deal with the decidable equality issues, but when you use <code>polynomial</code> it uses constructive logic. </p>\n<p>I can't find <code>polynomial.support_add</code> in mathlib -- you should make a PR adding it, and proving it using <code>convert</code>.</p>",
        "id": 209182312,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599318527
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/support_add/near/209182312\">said</a>:</p>\n<blockquote>\n<p>I can't find <code>polynomial.support_add</code> in mathlib -- you should make a PR adding it, and proving it using <code>convert</code>.</p>\n</blockquote>\n<p>I will try it!</p>",
        "id": 209187707,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599326773
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/support_add/near/209182312\">said</a>:</p>\n<blockquote>\n<p>So what's happening is that when you use <code>finsupp.support_add</code> it uses classical logic to deal with the decidable equality issues, but when you use <code>polynomial</code> it uses constructive logic. </p>\n</blockquote>\n<p>Whut? <code>polynomial</code> is quite classical I would think.</p>",
        "id": 209187734,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599326858
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> There are lemmas called <code>support_add</code>. But maybe about multivariate polynomials.</p>",
        "id": 209187778,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599326884
    },
    {
        "content": "<p>They might serve as inspiration.</p>",
        "id": 209187782,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599326889
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">polynomial</span><span class=\"bp\">.</span><span class=\"n\">degree</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">set_option</span> <span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">all</span> <span class=\"n\">true</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">supps</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">+</span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"err\">⊆</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"err\">∪</span> <span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">support_add</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- h uses classical.prop_decidable</span>\n  <span class=\"c1\">-- polynomials (the goal) use nat.decidable</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 209192644,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599334548
    },
    {
        "content": "<p>Ouch, I see.</p>",
        "id": 209204904,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599358632
    },
    {
        "content": "<blockquote>\n<p><code>convert</code> is clever. It looks for subsingleton instances, and if it finds them then it uses them. So <code>convert</code> can find a proof that <code>a = b</code> if it knows that <code>a : T</code> and <code>b : T</code> and <code>subsingleton T</code>.</p>\n</blockquote>\n<p>Should this be mentioned in the docs somewhere? That's the first time I've heard that.</p>",
        "id": 209206085,
        "sender_full_name": "Chris Wong",
        "timestamp": 1599361199
    },
    {
        "content": "<p>Yes, it should be! Interested in making a documentation-only PR, that adds a sentence to the doc-string for <code>convert</code>?</p>",
        "id": 209209074,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1599367337
    },
    {
        "content": "<p>It's actually a feature of <code>congr</code>, which is inherited by <code>congr'</code> and <code>convert</code></p>",
        "id": 209209608,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599368477
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/4060\">https://github.com/leanprover-community/mathlib/pull/4060</a> <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 209257764,
        "sender_full_name": "Chris Wong",
        "timestamp": 1599455287
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 209260111,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599458734
    },
    {
        "content": "<p>I am glad that <span class=\"user-mention\" data-user-id=\"294142\">@Chris Wong</span> took care of this, since, even after looking at the suggestion, I am still unsure about what all this means!</p>\n<p>Thanks!</p>",
        "id": 209265568,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599464116
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> The job of tactics like <code>convert</code> and <code>congr</code> is to try and prove that two terms are equal.</p>",
        "id": 209285910,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599478697
    },
    {
        "content": "<p>This is also the job of <code>exact</code></p>",
        "id": 209285919,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599478713
    },
    {
        "content": "<p><code>exact</code> is quick because it works with definitional equality which is exactly what lean is good at</p>",
        "id": 209285950,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599478755
    },
    {
        "content": "<p>But <code>convert</code> is more powerful because it has a second trick up its sleeve</p>",
        "id": 209285976,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599478783
    },
    {
        "content": "<p>If it has <code>a : X</code> and <code>b : X</code> and it can't prove that they are definitionally equal, it asks the type class inference system if perchance it knows a proof that X is a subsingleton</p>",
        "id": 209286100,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599478861
    },
    {
        "content": "<p>It's a brilliant idea</p>",
        "id": 209286112,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599478868
    },
    {
        "content": "<p>Subsingleton is a class so the type class system is very happy to manage this job</p>",
        "id": 209286125,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599478883
    },
    {
        "content": "<p>What is a subsingleton?  I am reading <code>#print subsingleton</code>, but I cannot say that I understand the output.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">class</span><span class=\"o\">]</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">subsingleton</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">constructors</span><span class=\"o\">:</span>\n<span class=\"n\">subsingleton</span><span class=\"bp\">.</span><span class=\"n\">intro</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">subsingleton</span> <span class=\"n\">α</span>\n</code></pre></div>",
        "id": 209286230,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599478971
    },
    {
        "content": "<p>Which means that occasionally <code>convert</code> gets lucky, finds an instance of <code>subsingleton X</code>, unwraps it to get a proof of \"for all a and b : X, a=b\" (the definition of subsingleton) and then applies this and moves on</p>",
        "id": 209286239,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599478977
    },
    {
        "content": "<p>Just #check subsingleton and jump to definition</p>",
        "id": 209286261,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599478996
    },
    {
        "content": "<p>Or read the docs</p>",
        "id": 209286271,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479002
    },
    {
        "content": "<p>Use #print just to get technical information such as whether a certain lemma is tagged with <code>[simp]</code>. You almost always don't want <code>#print</code>.</p>",
        "id": 209286368,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479064
    },
    {
        "content": "<p>Ok, so subsingleton is a singleton where you do not assume that it has one element, right?  it is a type with at most one term, correct?</p>",
        "id": 209286371,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599479066
    },
    {
        "content": "<p>Right</p>",
        "id": 209286378,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479072
    },
    {
        "content": "<p>Ok, indeed looking at the definition was much easier to understand than print!</p>",
        "id": 209286392,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599479089
    },
    {
        "content": "<p>So lean knows that a bunch of things are subsingletons</p>",
        "id": 209286396,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479096
    },
    {
        "content": "<p>(I did not realize that <code>#print</code> and jumping to the definition were different)</p>",
        "id": 209286417,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599479117
    },
    {
        "content": "<p>Like presumably <code>fin 0</code> and <code>fin 1</code> (do you know how to check?)</p>",
        "id": 209286434,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479132
    },
    {
        "content": "<p>#print gives you a description which doesn't use any variables and which doesn't display the docstring</p>",
        "id": 209286500,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479165
    },
    {
        "content": "<p><code>#check (fin 0) : subsingleton </code> did not work...</p>",
        "id": 209286501,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599479165
    },
    {
        "content": "<p>That's not the type of <code>fin 0</code></p>",
        "id": 209286558,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479185
    },
    {
        "content": "<p><code>fin 0</code> has type <code>Type </code> because it's what I'd call a set</p>",
        "id": 209286594,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479220
    },
    {
        "content": "<p>So I asked \"can you see if the type class system knows that <code>fin 0</code> is a subsingleton\"</p>",
        "id": 209286659,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479262
    },
    {
        "content": "<p>Ok, so I do not know how to check whether <code>fin 0</code> is a subsingleton</p>",
        "id": 209286664,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599479265
    },
    {
        "content": "<p>And the thing we have to do is to turn this into a question of the form \"make a term of a type\"</p>",
        "id": 209286733,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479295
    },
    {
        "content": "<p>So the first question is \"what is the type\"</p>",
        "id": 209286745,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479309
    },
    {
        "content": "<p>And the second question is what to use to make the term</p>",
        "id": 209286778,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479336
    },
    {
        "content": "<p>You can try <code>#check @subsingleton</code></p>",
        "id": 209286827,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479390
    },
    {
        "content": "<p>That's the sort of output I'd find useful for making the type</p>",
        "id": 209286894,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479416
    },
    {
        "content": "<p>Also look at the docstring for subsingleton</p>",
        "id": 209286909,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479432
    },
    {
        "content": "<p>Lean says: <code>subsingleton : Sort u_1 → Prop</code>, so I understand that subsingleton takes a term of type u_1 and produces a proposition, likely saying whether or not what I feed to subsingleton is a subsingleton!</p>",
        "id": 209286955,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599479477
    },
    {
        "content": "<p>So what is the type that we want to construct a term of?</p>",
        "id": 209286982,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479505
    },
    {
        "content": "<p>The translation into Lean of the <em>statement</em> of the theorem that <code>fin 0</code> is a subsingleton?</p>",
        "id": 209287054,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479544
    },
    {
        "content": "<p>we would like <code>subsingleton (fin 0)</code> is the type whose terms will be proofs of what we want, right?</p>",
        "id": 209287085,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599479583
    },
    {
        "content": "<p>Right</p>",
        "id": 209287093,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479589
    },
    {
        "content": "<p>(and all those proofs will be the same!)</p>",
        "id": 209287100,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599479602
    },
    {
        "content": "<p>You can <code>#check</code> what you just posted</p>",
        "id": 209287102,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479603
    },
    {
        "content": "<p>I get <br>\n<code>subsingleton (fin 0) : Prop</code>, which I confirms that this is a proposition!</p>",
        "id": 209287126,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599479630
    },
    {
        "content": "<p>And observe that it has type <code>Prop</code> which means it's a theorem statement</p>",
        "id": 209287128,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479631
    },
    {
        "content": "<p>ok, good!</p>",
        "id": 209287139,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599479642
    },
    {
        "content": "<p>So now the question is how to prove it</p>",
        "id": 209287176,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479644
    },
    {
        "content": "<p>so now I would like to know that there are terms in this type</p>",
        "id": 209287181,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599479651
    },
    {
        "content": "<p>You can put <code>example : subsingleton $ fin 0 := begin</code></p>",
        "id": 209287210,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479684
    },
    {
        "content": "<p>Does the $ work there instead of the bracket? I'm on mobile</p>",
        "id": 209287236,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479705
    },
    {
        "content": "<p>library_search says</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">ss</span> <span class=\"o\">:</span> <span class=\"n\">subsingleton</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">exact</span> <span class=\"n\">subsingleton_fin_zero</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 209287243,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599479712
    },
    {
        "content": "<p>Oh you cheated!</p>",
        "id": 209287252,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479723
    },
    {
        "content": "<p>That's not the answer to the question</p>",
        "id": 209287258,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479730
    },
    {
        "content": "<p>You just proved the theorem yourself</p>",
        "id": 209287270,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479742
    },
    {
        "content": "<p>You don't want <code>convert</code> saying \"ok they're equal as long as you can prove that the following things are subsingletons\"</p>",
        "id": 209287346,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479784
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/support_add/near/209287210\">said</a>:</p>\n<blockquote>\n<p>You can put <code>example : subsingleton $ fin 0 := begin</code></p>\n</blockquote>\n<p>This compiles, I added <code>end</code> after and Lean interprets it as looking for a term of the correct type</p>",
        "id": 209287351,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599479789
    },
    {
        "content": "<p>We need to use a tactic which doesn't involve knowing the name of the term beforehand</p>",
        "id": 209287359,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479808
    },
    {
        "content": "<p>And that tactic is called <code>apply_instance</code></p>",
        "id": 209287373,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479822
    },
    {
        "content": "<p>And I don't know if it will solve the goal -- let me know!</p>",
        "id": 209287398,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479843
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">subsingleton</span> <span class=\"err\">$</span> <span class=\"n\">fin</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>solves the goal indeed!</p>",
        "id": 209287409,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599479855
    },
    {
        "content": "<p>Great. So here's how that magic worked</p>",
        "id": 209287418,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479866
    },
    {
        "content": "<p>Because lean does not do magic</p>",
        "id": 209287429,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479874
    },
    {
        "content": "<p>You found the name of the term already</p>",
        "id": 209287471,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479885
    },
    {
        "content": "<p>Maybe you used library_search (which might be very slow)</p>",
        "id": 209287487,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479902
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/support_add/near/209287487\">said</a>:</p>\n<blockquote>\n<p>Maybe you used library_search (which might be very slow)</p>\n</blockquote>\n<p>Yes, I do not like using it</p>",
        "id": 209287505,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599479924
    },
    {
        "content": "<p>But now let's <code>#print subsingleton_fin_zero</code></p>",
        "id": 209287521,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479943
    },
    {
        "content": "<p>To see what's going on under the hood. Can you post the output? I'm on mobile</p>",
        "id": 209287538,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479961
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span>\n<span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">subsingleton_fin_zero</span> <span class=\"o\">:</span> <span class=\"n\">subsingleton</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">fin_zero_equiv</span><span class=\"bp\">.</span><span class=\"n\">subsingleton</span>\n</code></pre></div>",
        "id": 209287554,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599479974
    },
    {
        "content": "<p>So that definition is tagged with <code>instance</code></p>",
        "id": 209287573,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599479993
    },
    {
        "content": "<p>And all the type class inference system does is that it's a fast program written in C or C++ or something which looks through everything tagged with <code>instance</code> and sees if anything helps</p>",
        "id": 209287666,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480056
    },
    {
        "content": "<p>That's why the tactic is called <code>apply_instance</code>.</p>",
        "id": 209287701,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480096
    },
    {
        "content": "<p>Ah, so <code>apply_instance</code> is similar to <code>library_search</code>, except that it only searches for statements tagged <code>instance</code>?</p>",
        "id": 209287710,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599480113
    },
    {
        "content": "<p>All of those @[derive decibable_equality, ext, simp]` things you see lying around in mathlib are just literally doing nothing more than tagging words onto the names of theorems and definitions</p>",
        "id": 209287815,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480163
    },
    {
        "content": "<p>And then other things like tactics can use the tags</p>",
        "id": 209287844,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480179
    },
    {
        "content": "<p>Right, <code>apply_instance</code> is similar but it's only looking at instances. But there's also another thing</p>",
        "id": 209287888,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480217
    },
    {
        "content": "<p>This tactic is running behind the scenes all of the time because the elaborator is calling it every time you write 2+2</p>",
        "id": 209287945,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480243
    },
    {
        "content": "<p>The elaborator sees this and says to the type class inference system \"do you happen to know an addition on the naturals\"</p>",
        "id": 209288005,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480291
    },
    {
        "content": "<p>(or integers or reals or p-adics)</p>",
        "id": 209288032,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480312
    },
    {
        "content": "<p>This probably explains why sometimes, when I type <code>1 : something</code>, Lean then asks me for a <code>has_one</code> instance, right?</p>",
        "id": 209288044,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599480321
    },
    {
        "content": "<p>And the type class inference system says \"sure, they're a semiring, let me just look up the addition for you\"</p>",
        "id": 209288074,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480351
    },
    {
        "content": "<p>Because there are functions defined in lean saying things like \"if you are a semiring then you have an addition\" and a carefully chosen collection are tagged with <code>instance</code></p>",
        "id": 209288171,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480410
    },
    {
        "content": "<p>Choosing the right ones to tag is a complicated research topic</p>",
        "id": 209288201,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480438
    },
    {
        "content": "<p>Ok</p>",
        "id": 209288228,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599480468
    },
    {
        "content": "<p>In Lean 4 the algorithm will be replaced by a completely different one so we will have to learn how to use it from scratch</p>",
        "id": 209288229,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480468
    },
    {
        "content": "<p>so, all terms in <code>Prop</code> are subsingletons, right?  (this is just to make sure that I understand the definitions)</p>",
        "id": 209288296,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599480497
    },
    {
        "content": "<p>But if you just want to do mathematics then we basically have worked out what works best in lean 3</p>",
        "id": 209288308,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480506
    },
    {
        "content": "<p>Right</p>",
        "id": 209288334,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480520
    },
    {
        "content": "<p>Ok</p>",
        "id": 209288344,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599480535
    },
    {
        "content": "<p>So that means lean will be able to make a term of type <code>subsingleton P</code> if P : Prop`</p>",
        "id": 209288394,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480577
    },
    {
        "content": "<p>But some things are <code>subsingleton</code> even though they don't have type <code>Prop</code>. Like <code>prime_spectrum K</code>.</p>",
        "id": 209288403,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599480584
    },
    {
        "content": "<p>yes, ok, I only meant it as an example, not an exhaustive one!</p>",
        "id": 209288476,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599480615
    },
    {
        "content": "<p>Or <code>fin 0</code>, which has type Type</p>",
        "id": 209288478,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480618
    },
    {
        "content": "<p>It's all the propositions and all the sets with at most one element</p>",
        "id": 209288503,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480635
    },
    {
        "content": "<p>for instance, I guess that you could formulate the valuative criterion of separatedness using subsingletons</p>",
        "id": 209288515,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599480644
    },
    {
        "content": "<p>You can model a false proposition as a set with no elements and a true one as a set with one element</p>",
        "id": 209288537,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480662
    },
    {
        "content": "<p>What do you mean about the valuative criterion?</p>",
        "id": 209288552,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480680
    },
    {
        "content": "<p>Oh you mean subsingleton schemes</p>",
        "id": 209288558,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480688
    },
    {
        "content": "<p>yes</p>",
        "id": 209288559,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599480692
    },
    {
        "content": "<p>Do you need Noetherian hypotheses here?</p>",
        "id": 209288578,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480711
    },
    {
        "content": "<p>I can't remember the non noeth story</p>",
        "id": 209288631,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480730
    },
    {
        "content": "<p>I think Hartshorne does it</p>",
        "id": 209288640,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480738
    },
    {
        "content": "<p>in the proof, you reduce to something being noetherian, but the statement may not require it</p>",
        "id": 209288642,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599480739
    },
    {
        "content": "<p>Is the statement about valuation rings?</p>",
        "id": 209288669,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480769
    },
    {
        "content": "<p>Wait they have two points</p>",
        "id": 209288706,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599480804
    },
    {
        "content": "<p>yes, so i think that you can formulate the valuative criterion without noetherian hypotheses, but then they crop up somewhere...</p>",
        "id": 209288782,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599480872
    },
    {
        "content": "<p>General valuation rings can have more than two primes. Subsingleton is less than two</p>",
        "id": 209289192,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599481120
    },
    {
        "content": "<p>Ok, I had in mind the statement of the valuative criterion for \"reasonable\" schemes: I think that if <code>X</code> is of finite type, then you only need to check dvrs in the valuative criteria</p>",
        "id": 209289663,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599481469
    },
    {
        "content": "<p>Yes and this doesn't change the fact that <code>fin 2</code> is not a subsingleton :-)</p>",
        "id": 209291887,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599482907
    },
    {
        "content": "<p>The criterion uses doubletons</p>",
        "id": 209291943,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599482960
    },
    {
        "content": "<p>Ok, I see what you are saying!  I was thinking that once you fix the generic morphism, then there is at most one way of filling it in...</p>",
        "id": 209292083,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599483040
    },
    {
        "content": "<p>so, one of the elements of the doubleton is fixed and the other one is... a subsingleton!  Ahahaha</p>",
        "id": 209292122,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599483070
    },
    {
        "content": "<p>(at least, this is how i view the valuative criteria: you are given the generic map and all you want to do is know if</p>\n<ol>\n<li>you can extend it;</li>\n<li>if so, can you extend it uniquely.<br>\n)</li>\n</ol>",
        "id": 209292169,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599483121
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> Yup, that makes sense</p>",
        "id": 209292436,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599483308
    },
    {
        "content": "<p>Oh I see! Yes you should have formalised what you meant. Yes, separated is at most one, there's some adjective which is at least one and then proper is <code>singleton</code></p>",
        "id": 209292471,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599483349
    },
    {
        "content": "<p>Great!  I realize that explaining <code>subsingleton</code> via the valuative criteria is maybe not the most direct route...</p>",
        "id": 209292568,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599483407
    },
    {
        "content": "<p>There's a way of formalising the definition of compact to mean some statement involving filters has at least one answer, and a way of formalising Hausdorff so that it says the same statement has at most one answer</p>",
        "id": 209292587,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599483422
    },
    {
        "content": "<p>Basically certain filters have at least one limit in a compact space and at most one limit in a Hausdorff space</p>",
        "id": 209292634,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599483458
    },
    {
        "content": "<p>That's why compact Hausdorff is such a powerful criterion</p>",
        "id": 209292652,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599483471
    },
    {
        "content": "<p>I think that what you described is very close to my intuition for proper</p>",
        "id": 209292837,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599483592
    }
]
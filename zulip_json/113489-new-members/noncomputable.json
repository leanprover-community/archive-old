[
    {
        "content": "<p>I'm trying</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">to_complex</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">[</span><span class=\"n\">ω</span><span class=\"o\">])</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">I</span> <span class=\"bp\">*</span> <span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span>\n</pre></div>\n\n\n<p>but getting <code>definition 'to_complex' is noncomputable, it depends on 'complex.discrete_field'</code>.<br>\nIs there some <code>import</code> or <code>open</code> that will \"deal\" with this? What are the consequences of ignoring the noncomputability of sqrt?<br>\nIt looks like an interesting exercise to make <code>real.sqrt</code> computable (looks like there is a proof sketch in the comments of <code>real.sqrt</code>'s definition). Is that worth trying? Is it just a matter of constructing the Cauchy sequence that converges to sqrt(n)?</p>",
        "id": 188389789,
        "sender_full_name": "Paul van Wamelen",
        "timestamp": 1581955687
    },
    {
        "content": "<p>The real numbers as implemented in mathlib have no useful computational structure anyways (they are Cauchy sequences without any explicit rate of convergence). You should just put <code>noncomputable theory</code> at the top of your file if you are going to use the reals a lot.</p>",
        "id": 188390057,
        "sender_full_name": "Reid Barton",
        "timestamp": 1581955949
    },
    {
        "content": "<p>Thanks!<br>\nAre you saying that even if we complete the proof of <code>sqrt_aux_converges</code> sqrt would still be \"uncomputable\"?</p>",
        "id": 188391256,
        "sender_full_name": "Paul van Wamelen",
        "timestamp": 1581956947
    },
    {
        "content": "<p>It would be computable in the sense that Lean wouldn't have the <code>noncomputable</code> tag, but it would not be computable in any practical sense. There is no computable function <code>real -&gt; bool</code> for example, so there's basically nothing you can do with a \"computable\" function on the current implementation of the reals.</p>",
        "id": 188391396,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1581957068
    },
    {
        "content": "<p>I think I see :)<br>\nThanks again! (I must say I'm blown away by the support here...)</p>",
        "id": 188391780,
        "sender_full_name": "Paul van Wamelen",
        "timestamp": 1581957453
    },
    {
        "content": "<p>I tend to not put <code>noncomputable theory</code> at the top of my files, and then every time Lean complains something is noncomputable I just write <code>noncomputable</code> in front of it, so e.g. <code>noncomputable def to_complex ...</code> would also remove the error.</p>",
        "id": 188394508,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581959805
    },
    {
        "content": "<p>Why for such simple theorems I need the <code>noncomputable</code> in front of the theorems? </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">constant</span> <span class=\"n\">Class</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"c1\">-- SUMO immediateSubclass</span>\n<span class=\"kn\">constant</span> <span class=\"n\">subClass</span> <span class=\"o\">:</span> <span class=\"n\">Class</span> <span class=\"bp\">→</span> <span class=\"n\">Class</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n\n<span class=\"c1\">-- SUMO subclass</span>\n<span class=\"kn\">constant</span> <span class=\"n\">Inherits</span> <span class=\"o\">:</span> <span class=\"n\">Class</span> <span class=\"bp\">→</span> <span class=\"n\">Class</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n\n<span class=\"kn\">constant</span> <span class=\"n\">inhz</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Class</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Inherits</span> <span class=\"n\">c</span> <span class=\"n\">c</span>\n<span class=\"kn\">constant</span> <span class=\"n\">inhs</span> <span class=\"o\">(</span><span class=\"n\">c1</span> <span class=\"n\">c2</span> <span class=\"n\">c3</span> <span class=\"o\">:</span> <span class=\"n\">Class</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">subClass</span> <span class=\"n\">c1</span> <span class=\"n\">c2</span> <span class=\"bp\">→</span> <span class=\"n\">Inherits</span> <span class=\"n\">c2</span> <span class=\"n\">c3</span> <span class=\"bp\">→</span> <span class=\"n\">Inherits</span> <span class=\"n\">c1</span> <span class=\"n\">c3</span>\n\n<span class=\"kn\">constants</span> <span class=\"n\">Human</span> <span class=\"n\">Hominid</span> <span class=\"n\">Entity</span> <span class=\"o\">:</span> <span class=\"n\">Class</span>\n\n<span class=\"kn\">constant</span> <span class=\"n\">human_hominid</span> <span class=\"o\">:</span> <span class=\"n\">subClass</span> <span class=\"n\">Human</span> <span class=\"n\">Hominid</span>\n<span class=\"kn\">constant</span> <span class=\"n\">hominid_entity</span> <span class=\"o\">:</span> <span class=\"n\">subClass</span> <span class=\"n\">Hominid</span> <span class=\"n\">Entity</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"kn\">theorem</span> <span class=\"n\">test1</span> <span class=\"o\">:</span> <span class=\"n\">Inherits</span> <span class=\"n\">Human</span> <span class=\"n\">Hominid</span> <span class=\"o\">:=</span>\n <span class=\"n\">inhs</span> <span class=\"n\">Human</span> <span class=\"n\">Hominid</span> <span class=\"n\">Hominid</span> <span class=\"n\">human_hominid</span> <span class=\"o\">(</span><span class=\"n\">inhz</span> <span class=\"n\">Hominid</span><span class=\"o\">)</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"kn\">theorem</span> <span class=\"n\">test2</span> <span class=\"o\">:</span> <span class=\"n\">Inherits</span> <span class=\"n\">Human</span> <span class=\"n\">Entity</span> <span class=\"o\">:=</span>\n <span class=\"n\">inhs</span> <span class=\"n\">Human</span> <span class=\"n\">Hominid</span> <span class=\"n\">Entity</span> <span class=\"n\">human_hominid</span> <span class=\"o\">(</span><span class=\"n\">inhs</span> <span class=\"n\">Hominid</span> <span class=\"n\">Entity</span> <span class=\"n\">Entity</span> <span class=\"n\">hominid_entity</span> <span class=\"o\">(</span><span class=\"n\">inhz</span> <span class=\"n\">Entity</span><span class=\"o\">))</span>\n</code></pre></div>\n\n\n<p>Is it possible, using some tactics, to let Lean come up of the proof terms automatically? That is, to synthesize the proof term?</p>",
        "id": 196719006,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1588815731
    },
    {
        "content": "<p><code>noncomputable</code> has nothing to do with computation in this sense</p>",
        "id": 196719042,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588815813
    },
    {
        "content": "<p>it's <code>noncomputable</code> because you can't directly execute the proofs because they use undefined constants</p>",
        "id": 196719112,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588815844
    },
    {
        "content": "<p>undefined constants? but in my example, they are all defined.</p>",
        "id": 196719141,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1588815908
    },
    {
        "content": "<p><code>noncomputable theorem</code> is an indication that you have incorrectly marked a <code>def</code> as a theorem, or you have a type where you wanted a prop. Are <code>subClass</code> and <code>Inherits</code> supposed to be propositions? They are named like such</p>",
        "id": 196719144,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588815923
    },
    {
        "content": "<p><code>constant</code> is the same as <code>axiom</code></p>",
        "id": 196719145,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588815933
    },
    {
        "content": "<p>No, subClass is supposed to be a dependent type and Inherits a function.</p>",
        "id": 196719208,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1588815998
    },
    {
        "content": "<p>You may want to consider using <code>variable</code> or <code>parameter</code> here</p>",
        "id": 196719236,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588816058
    },
    {
        "content": "<p>actually, I would like to be able to have a term like <code>inhs Human Hominid Hominid human_hominid (inhz Hominid)</code> produced automatically for a type <code>Inherits Human Hominid</code></p>",
        "id": 196719239,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1588816071
    },
    {
        "content": "<p>you can probably do that using typeclass inference</p>",
        "id": 196719286,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588816098
    },
    {
        "content": "<p>Wow! Thank you Mario. Can you give me any reference to understand it better? Probably I have to read <a href=\"https://leanprover.github.io/theorem_proving_in_lean/type_classes.html\" title=\"https://leanprover.github.io/theorem_proving_in_lean/type_classes.html\">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html</a>, right?</p>",
        "id": 196719362,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1588816230
    },
    {
        "content": "<p>BTW, nice, I don't need the noncomputable with variables </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">constant</span> <span class=\"n\">Class</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"c1\">-- SUMO immediateSubclass</span>\n<span class=\"kn\">constant</span> <span class=\"n\">subClass</span> <span class=\"o\">:</span> <span class=\"n\">Class</span> <span class=\"bp\">→</span> <span class=\"n\">Class</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n\n<span class=\"c1\">-- SUMO subclass</span>\n<span class=\"kn\">constant</span> <span class=\"n\">Inherits</span> <span class=\"o\">:</span> <span class=\"n\">Class</span> <span class=\"bp\">→</span> <span class=\"n\">Class</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n\n<span class=\"kn\">variable</span> <span class=\"n\">inhz</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Class</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Inherits</span> <span class=\"n\">c</span> <span class=\"n\">c</span>\n<span class=\"kn\">variable</span> <span class=\"n\">inhs</span> <span class=\"o\">(</span><span class=\"n\">c1</span> <span class=\"n\">c2</span> <span class=\"n\">c3</span> <span class=\"o\">:</span> <span class=\"n\">Class</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">subClass</span> <span class=\"n\">c1</span> <span class=\"n\">c2</span> <span class=\"bp\">→</span> <span class=\"n\">Inherits</span> <span class=\"n\">c2</span> <span class=\"n\">c3</span> <span class=\"bp\">→</span> <span class=\"n\">Inherits</span> <span class=\"n\">c1</span> <span class=\"n\">c3</span>\n\n<span class=\"kn\">variables</span> <span class=\"n\">Human</span> <span class=\"n\">Hominid</span> <span class=\"n\">Entity</span> <span class=\"o\">:</span> <span class=\"n\">Class</span>\n\n<span class=\"kn\">variable</span> <span class=\"n\">human_hominid</span> <span class=\"o\">:</span> <span class=\"n\">subClass</span> <span class=\"n\">Human</span> <span class=\"n\">Hominid</span>\n<span class=\"kn\">variable</span> <span class=\"n\">hominid_entity</span> <span class=\"o\">:</span> <span class=\"n\">subClass</span> <span class=\"n\">Hominid</span> <span class=\"n\">Entity</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">test1</span> <span class=\"o\">:</span> <span class=\"n\">Inherits</span> <span class=\"n\">Human</span> <span class=\"n\">Hominid</span> <span class=\"o\">:=</span>\n <span class=\"n\">inhs</span> <span class=\"n\">Human</span> <span class=\"n\">Hominid</span> <span class=\"n\">Hominid</span> <span class=\"n\">human_hominid</span> <span class=\"o\">(</span><span class=\"n\">inhz</span> <span class=\"n\">Hominid</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">test2</span> <span class=\"o\">:</span> <span class=\"n\">Inherits</span> <span class=\"n\">Human</span> <span class=\"n\">Entity</span> <span class=\"o\">:=</span>\n <span class=\"n\">inhs</span> <span class=\"n\">Human</span> <span class=\"n\">Hominid</span> <span class=\"n\">Entity</span> <span class=\"n\">human_hominid</span> <span class=\"o\">(</span><span class=\"n\">inhs</span> <span class=\"n\">Hominid</span> <span class=\"n\">Entity</span> <span class=\"n\">Entity</span> <span class=\"n\">hominid_entity</span> <span class=\"o\">(</span><span class=\"n\">inhz</span> <span class=\"n\">Entity</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 196719384,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1588816280
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">constant</span> <span class=\"n\">Class</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"c1\">-- SUMO immediateSubclass</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">class</span><span class=\"o\">]</span> <span class=\"kn\">constant</span> <span class=\"n\">subClass</span> <span class=\"o\">:</span> <span class=\"n\">Class</span> <span class=\"bp\">→</span> <span class=\"n\">Class</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n\n<span class=\"c1\">-- SUMO subclass</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">class</span><span class=\"o\">]</span> <span class=\"kn\">constant</span> <span class=\"n\">Inherits</span> <span class=\"o\">:</span> <span class=\"n\">Class</span> <span class=\"bp\">→</span> <span class=\"n\">Class</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"kn\">constant</span> <span class=\"n\">inhz</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Class</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Inherits</span> <span class=\"n\">c</span> <span class=\"n\">c</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"kn\">constant</span> <span class=\"n\">inhs</span> <span class=\"o\">(</span><span class=\"n\">c1</span> <span class=\"n\">c2</span> <span class=\"n\">c3</span> <span class=\"o\">:</span> <span class=\"n\">Class</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Inherits</span> <span class=\"n\">c2</span> <span class=\"n\">c3</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">subClass</span> <span class=\"n\">c1</span> <span class=\"n\">c2</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Inherits</span> <span class=\"n\">c1</span> <span class=\"n\">c3</span>\n\n<span class=\"kn\">constants</span> <span class=\"n\">Human</span> <span class=\"n\">Hominid</span> <span class=\"n\">Entity</span> <span class=\"o\">:</span> <span class=\"n\">Class</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"kn\">constant</span> <span class=\"n\">human_hominid</span> <span class=\"o\">:</span> <span class=\"n\">subClass</span> <span class=\"n\">Human</span> <span class=\"n\">Hominid</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"kn\">constant</span> <span class=\"n\">hominid_entity</span> <span class=\"o\">:</span> <span class=\"n\">subClass</span> <span class=\"n\">Hominid</span> <span class=\"n\">Entity</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">test1</span> <span class=\"o\">:</span> <span class=\"n\">Inherits</span> <span class=\"n\">Human</span> <span class=\"n\">Hominid</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">test2</span> <span class=\"o\">:</span> <span class=\"n\">Inherits</span> <span class=\"n\">Human</span> <span class=\"n\">Entity</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>",
        "id": 196719490,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588816420
    },
    {
        "content": "<p>thank you. I am getting two errors </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">.</span><span class=\"err\">…</span>    <span class=\"mi\">19</span>  <span class=\"mi\">19</span> <span class=\"n\">warning</span>         <span class=\"kn\">definition</span> <span class=\"err\">&#39;</span><span class=\"n\">test1&#39;</span> <span class=\"n\">was</span> <span class=\"n\">incorrectly</span> <span class=\"n\">marked</span> <span class=\"n\">as</span> <span class=\"n\">noncomputable</span> <span class=\"o\">(</span><span class=\"n\">lean</span><span class=\"bp\">-</span><span class=\"n\">checker</span><span class=\"o\">)</span>\n<span class=\"bp\">.</span><span class=\"err\">…</span>    <span class=\"mi\">19</span>  <span class=\"mi\">27</span> <span class=\"n\">error</span>           <span class=\"n\">maximum</span> <span class=\"n\">class</span><span class=\"bp\">-</span><span class=\"kn\">instance</span> <span class=\"n\">resolution</span> <span class=\"n\">depth</span> <span class=\"n\">has</span> <span class=\"n\">been</span> <span class=\"n\">reached</span> <span class=\"o\">(</span><span class=\"n\">the</span> <span class=\"n\">limit</span> <span class=\"n\">can</span> <span class=\"n\">be</span> <span class=\"n\">increased</span> <span class=\"k\">by</span> <span class=\"n\">setting</span> <span class=\"n\">option</span> <span class=\"err\">&#39;</span><span class=\"n\">class</span><span class=\"bp\">.</span><span class=\"n\">instance_max_depth&#39;</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">the</span> <span class=\"n\">class</span><span class=\"bp\">-</span><span class=\"kn\">instance</span> <span class=\"n\">resolution</span> <span class=\"n\">trace</span> <span class=\"n\">can</span> <span class=\"n\">be</span> <span class=\"n\">visualized</span> <span class=\"k\">by</span> <span class=\"n\">setting</span> <span class=\"n\">option</span> <span class=\"err\">&#39;</span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">class_instances&#39;</span><span class=\"o\">)</span>\n <span class=\"n\">state</span><span class=\"o\">:</span>\n <span class=\"err\">⊢</span> <span class=\"n\">Inherits</span> <span class=\"n\">Human</span> <span class=\"n\">Hominid</span> <span class=\"o\">(</span><span class=\"n\">lean</span><span class=\"bp\">-</span><span class=\"n\">checker</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 196719663,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1588816662
    },
    {
        "content": "<p>You won't be able to use a variable for typeclass inference here. Instances have to be <code>def</code>s or <code>constant</code>s</p>",
        "id": 196720067,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588817141
    },
    {
        "content": "<p>The error is because you missed that I swapped the arguments to <code>inhs</code></p>",
        "id": 196720121,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588817176
    },
    {
        "content": "<p>I make no guarantees about the behavior of this typeclass search, and there are issues with infinite searches if it follows the wrong path</p>",
        "id": 196720152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588817243
    },
    {
        "content": "<p>but it works in a pinch</p>",
        "id": 196720153,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588817256
    },
    {
        "content": "<p>I see. But I copied and pasted your code. So I didn't understand your point about the swapping of the arguments of inhs...</p>",
        "id": 196720203,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1588817293
    },
    {
        "content": "<p>Are you sure? What version of lean are you running</p>",
        "id": 196720248,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588817377
    },
    {
        "content": "<p>I guessed that you modified your code to look like mine</p>",
        "id": 196720259,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588817395
    },
    {
        "content": "<p>Oh, I got. Now I have just green marks</p>",
        "id": 196720303,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1588817404
    },
    {
        "content": "<p>but I don't know any version of lean where the <code>noncomputable</code> mark on the def is unnecessary</p>",
        "id": 196720318,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588817424
    },
    {
        "content": "<p>Hum, I see. So I guess that I can't expect too much from Lean to synthesize proof terms as I was expecting with this approach I was investigating.</p>",
        "id": 196720402,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1588817547
    },
    {
        "content": "<p>there are other ways to do it but they are more complicated</p>",
        "id": 196720430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588817621
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">constant</span> <span class=\"n\">Class</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"c1\">-- SUMO immediateSubclass</span>\n<span class=\"kn\">constant</span> <span class=\"n\">subClass</span> <span class=\"o\">:</span> <span class=\"n\">Class</span> <span class=\"bp\">→</span> <span class=\"n\">Class</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n\n<span class=\"c1\">-- SUMO subclass</span>\n<span class=\"kn\">constant</span> <span class=\"n\">Inherits</span> <span class=\"o\">:</span> <span class=\"n\">Class</span> <span class=\"bp\">→</span> <span class=\"n\">Class</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n\n<span class=\"kn\">constant</span> <span class=\"n\">inhz</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Class</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Inherits</span> <span class=\"n\">c</span> <span class=\"n\">c</span>\n<span class=\"kn\">constant</span> <span class=\"n\">inhs</span> <span class=\"o\">(</span><span class=\"n\">c1</span> <span class=\"n\">c2</span> <span class=\"n\">c3</span> <span class=\"o\">:</span> <span class=\"n\">Class</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">subClass</span> <span class=\"n\">c1</span> <span class=\"n\">c2</span> <span class=\"bp\">→</span> <span class=\"n\">Inherits</span> <span class=\"n\">c2</span> <span class=\"n\">c3</span> <span class=\"bp\">→</span> <span class=\"n\">Inherits</span> <span class=\"n\">c1</span> <span class=\"n\">c3</span>\n\n<span class=\"kn\">constants</span> <span class=\"n\">Human</span> <span class=\"n\">Hominid</span> <span class=\"n\">Entity</span> <span class=\"o\">:</span> <span class=\"n\">Class</span>\n\n<span class=\"kn\">constant</span> <span class=\"n\">human_hominid</span> <span class=\"o\">:</span> <span class=\"n\">subClass</span> <span class=\"n\">Human</span> <span class=\"n\">Hominid</span>\n<span class=\"kn\">constant</span> <span class=\"n\">hominid_entity</span> <span class=\"o\">:</span> <span class=\"n\">subClass</span> <span class=\"n\">Hominid</span> <span class=\"n\">Entity</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">prove_subclass</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">apply</span> <span class=\"n\">human_hominid</span><span class=\"o\">]</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">apply</span> <span class=\"n\">hominid_entity</span><span class=\"o\">]</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">prove_inherits</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">apply</span> <span class=\"n\">inhz</span><span class=\"o\">]</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"o\">(</span><span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">apply</span> <span class=\"n\">inhs</span><span class=\"o\">]</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">prove_subclass</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">prove_inherits</span><span class=\"o\">)</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">test1</span> <span class=\"o\">:</span> <span class=\"n\">Inherits</span> <span class=\"n\">Human</span> <span class=\"n\">Hominid</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">prove_inherits</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">test2</span> <span class=\"o\">:</span> <span class=\"n\">Inherits</span> <span class=\"n\">Human</span> <span class=\"n\">Entity</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">prove_inherits</span>\n</code></pre></div>",
        "id": 196720597,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588817798
    },
    {
        "content": "<p>In this article, <a href=\"https://www.molto-project.eu/sites/default/files/FinalSUMOCNL.pdf\" title=\"https://www.molto-project.eu/sites/default/files/FinalSUMOCNL.pdf\">https://www.molto-project.eu/sites/default/files/FinalSUMOCNL.pdf</a>, the authors have an interesting idea of mapping a KIF ontology (a knowledge representation language) to dependent type. They used <a href=\"https://www.grammaticalframework.org\" title=\"https://www.grammaticalframework.org\">https://www.grammaticalframework.org</a> that implements dependent types too. I am trying to adapt their solution to Lean. The idea is to model the taxonomy of classes. Later, I would expect Lean to automatically construct terms that proof a chain of subclasses like  Human &lt; Hominid &lt; CognitiveAgent &lt; Agent &lt; ... &lt; Entity.</p>",
        "id": 196720859,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1588818132
    },
    {
        "content": "<p>What impressed me was that I was expecting Lean to have a much more powerful type system. But in GF they were able to easily generate a term for a given type. Page 6 of the article. The command mean: give me a term for the type <code>Inherits Human Hominid</code>.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">&gt;</span> <span class=\"n\">gt</span> <span class=\"bp\">-</span><span class=\"n\">cat</span><span class=\"bp\">=</span><span class=\"s2\">&quot;Inherits Human Hominid&quot;</span>\n<span class=\"o\">(</span><span class=\"n\">inhs</span> <span class=\"n\">Human</span> <span class=\"n\">Hominid</span> <span class=\"n\">Hominid</span> <span class=\"n\">Human_Class</span> <span class=\"o\">(</span><span class=\"n\">inhz</span> <span class=\"n\">Hominid</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 196720960,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1588818266
    },
    {
        "content": "<p>Oh, sorry I was answering a question that you made in another thread! ;-)</p>",
        "id": 196721075,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1588818410
    },
    {
        "content": "<p>Reading the paper, I'm pretty sure you want <code>subClass</code> and <code>Inherits</code> to be props. The reason they use a dependent type is because that's the nearest equivalent to a proposition in a haskell-esque type theory</p>",
        "id": 196721121,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588818460
    },
    {
        "content": "<p>I think <code>gt -cat</code> is doing something similar to lean's typeclass inference</p>",
        "id": 196721181,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588818528
    },
    {
        "content": "<p>pages 5-6 read very much like a description of typeclass inference. I'm pretty sure that <code>gt -cat</code> is a prolog-like search</p>\n<blockquote>\n<p>However, there are some types of axioms which could not be ported to SUMOGF, such as the ones that use quantification over classes, negative type declarations and axioms which use the predicates subclass, range or domain.</p>\n</blockquote>\n<p>...which also predicts that negations in theorems would be problematic to represent this way, because instance search only works with horn clauses (from A , B, ... Y infer Z)</p>",
        "id": 196721382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588818823
    },
    {
        "content": "<p>Thank you, I will think more about the implications of moving to propositions. In the previous example of trying to prove a simple SUMO axiom in Lean, I used untyped FOL mapping to Lean - <a href=\"https://github.com/own-pt/common-sense-lean/blob/master/misc/bs.lean\" title=\"https://github.com/own-pt/common-sense-lean/blob/master/misc/bs.lean\">https://github.com/own-pt/common-sense-lean/blob/master/misc/bs.lean</a>. This makes the simple proof very verbose.  I had a single type <a href=\"https://github.com/own-pt/common-sense-lean/blob/master/misc/bs.lean#L21\" title=\"https://github.com/own-pt/common-sense-lean/blob/master/misc/bs.lean#L21\">https://github.com/own-pt/common-sense-lean/blob/master/misc/bs.lean#L21</a> and guards in the axioms <a href=\"https://github.com/own-pt/common-sense-lean/blob/master/misc/bs.lean#L96\" title=\"https://github.com/own-pt/common-sense-lean/blob/master/misc/bs.lean#L96\">https://github.com/own-pt/common-sense-lean/blob/master/misc/bs.lean#L96</a>. I am trying to better use types and have a way to move from the class hierarchy to types.  </p>\n<p>Anyway, the use of tactics was interesting, thank you for sharing. Unfortunately, we needed to go back to constants and noncomputable...</p>",
        "id": 196721644,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1588819198
    },
    {
        "content": "<p>The reason lean gets lost with the initial version of <code>inhs</code> is because it builds up a stack <code>subclass Human ?a /\\ subclass ?a ?b /\\ subclass ?b ?c /\\ Inherits ?c Hominid -&gt; Inherits Human Hominid</code> that doesn't resolve because it keeps applying <code>inhs</code> to the last <code>Inherits</code> subgoal. It's similar to the left recursion problem in context free grammars</p>",
        "id": 196721727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588819313
    },
    {
        "content": "<p>I am curious if GF has the same problem if you stated <code>inhs</code> as <code>Inherits c1 c2 → subClass c2 c3 → Inherits c1 c3</code> instead</p>",
        "id": 196721774,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588819349
    },
    {
        "content": "<p>This is interesting. I moved subclass back to the original position and it is working for me</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">constant</span> <span class=\"n\">Class</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"c1\">-- SUMO immediateSubclass</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">class</span><span class=\"o\">]</span> <span class=\"kn\">constant</span> <span class=\"n\">subClass</span> <span class=\"o\">:</span> <span class=\"n\">Class</span> <span class=\"bp\">→</span> <span class=\"n\">Class</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n\n<span class=\"c1\">-- SUMO subclass</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">class</span><span class=\"o\">]</span> <span class=\"kn\">constant</span> <span class=\"n\">Inherits</span> <span class=\"o\">:</span> <span class=\"n\">Class</span> <span class=\"bp\">→</span> <span class=\"n\">Class</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"kn\">constant</span> <span class=\"n\">inhz</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Class</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Inherits</span> <span class=\"n\">c</span> <span class=\"n\">c</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"kn\">constant</span> <span class=\"n\">inhs</span> <span class=\"o\">(</span><span class=\"n\">c1</span> <span class=\"n\">c2</span> <span class=\"n\">c3</span> <span class=\"o\">:</span> <span class=\"n\">Class</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">subClass</span> <span class=\"n\">c1</span> <span class=\"n\">c2</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Inherits</span> <span class=\"n\">c2</span> <span class=\"n\">c3</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Inherits</span> <span class=\"n\">c1</span> <span class=\"n\">c3</span>\n\n<span class=\"kn\">constants</span> <span class=\"n\">Human</span> <span class=\"n\">Hominid</span> <span class=\"n\">Entity</span> <span class=\"o\">:</span> <span class=\"n\">Class</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"kn\">constant</span> <span class=\"n\">human_hominid</span> <span class=\"o\">:</span> <span class=\"n\">subClass</span> <span class=\"n\">Human</span> <span class=\"n\">Hominid</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"kn\">constant</span> <span class=\"n\">hominid_entity</span> <span class=\"o\">:</span> <span class=\"n\">subClass</span> <span class=\"n\">Hominid</span> <span class=\"n\">Entity</span>\n\n<span class=\"kn\">set_option</span> <span class=\"n\">class</span><span class=\"bp\">.</span><span class=\"n\">instance_max_depth</span> <span class=\"mi\">100</span>\n<span class=\"kn\">set_option</span> <span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">class_instances</span> <span class=\"n\">true</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">test1</span> <span class=\"o\">:</span> <span class=\"n\">Inherits</span> <span class=\"n\">Human</span> <span class=\"n\">Hominid</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">test2</span> <span class=\"o\">:</span> <span class=\"n\">Inherits</span> <span class=\"n\">Human</span> <span class=\"n\">Entity</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>",
        "id": 196721855,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1588819489
    },
    {
        "content": "<p>Unfortunately, I can't test the change in GF, the code in <a href=\"https://github.com/GrammaticalFramework/gf-contrib/tree/master/SUMO\" title=\"https://github.com/GrammaticalFramework/gf-contrib/tree/master/SUMO\">https://github.com/GrammaticalFramework/gf-contrib/tree/master/SUMO</a> is incomplete.</p>",
        "id": 196722128,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1588819817
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/noncomputable/near/196720248\" title=\"#narrow/stream/113489-new-members/topic/noncomputable/near/196720248\">said</a>:</p>\n<blockquote>\n<p>Are you sure? What version of lean are you running</p>\n</blockquote>\n<p>% lean -v<br>\nLean (version 3.4.2, Release)</p>",
        "id": 196722253,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1588820038
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"121542\">@Alexandre Rademaker</span> So I had a go at simplifying your <a href=\"https://github.com/own-pt/common-sense-lean/blob/master/misc/bs.lean\" title=\"https://github.com/own-pt/common-sense-lean/blob/master/misc/bs.lean\">bs.lean</a>, see <a href=\"https://gist.github.com/digama0/16c62d1af34212de2e3fba380d87c043\" title=\"https://gist.github.com/digama0/16c62d1af34212de2e3fba380d87c043\">https://gist.github.com/digama0/16c62d1af34212de2e3fba380d87c043</a> . You can't quite take care of everything with typeclass inference but almost all the proofs that look like typeclass inference can be done using it</p>",
        "id": 196725430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588824554
    },
    {
        "content": "<p>I see, thank you so much for your attention.  I will read it carefully to understand the details. The main issue, I believe, is to understand the limitations of that approach. The comments <code>not provable</code> in the end means not probable with typeclass inference or not provable at all with this way to model classes and instances? </p>\n<p>Still, I think the predicates and functions are not really typed, right? I can't say that <code>partition : Class → Class → Class → Prop</code> and 'using it' like:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">axiom</span> <span class=\"n\">a67131</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"n\">row0</span> <span class=\"n\">row1</span> <span class=\"o\">:</span> <span class=\"n\">Class</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n <span class=\"o\">(</span><span class=\"n\">partition3</span> <span class=\"n\">c</span> <span class=\"n\">row0</span> <span class=\"n\">row1</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">exhaustiveDecomposition3</span> <span class=\"n\">c</span> <span class=\"n\">row0</span> <span class=\"n\">row1</span> <span class=\"bp\">∧</span> <span class=\"n\">disjointDecomposition3</span> <span class=\"n\">c</span> <span class=\"n\">row0</span> <span class=\"n\">row1</span><span class=\"o\">))</span>\n</code></pre></div>\n\n\n<p>That is, I can't really internalize the class hierarchy in the types.</p>\n<p>In Lean 3.4.2 almost all proofs reached the maximum class-instance resolution depth, and I set it to 1000.</p>",
        "id": 196765225,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1588856028
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"121542\">Alexandre Rademaker</span> <a href=\"#narrow/stream/113489-new-members/topic/noncomputable/near/196765225\" title=\"#narrow/stream/113489-new-members/topic/noncomputable/near/196765225\">said</a>:</p>\n<blockquote>\n<p>I see, thank you so much for your attention.  I will read it carefully to understand the details. The main issue, I believe, is to understand the limitations of that approach. The comments <code>not provable</code> in the end means not probable with typeclass inference or not provable at all with this way to model classes and instances? </p>\n</blockquote>\n<p>Not provable from the axioms that were provided. Presumably you have omitted some axioms that are needed to prove these.</p>",
        "id": 196975218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589003087
    },
    {
        "content": "<p>Indeed, these predicates and functions are essentially untyped, and typeclass inference is having to solve a harder problem than it normally would because there are so few classes and so many instances. One simple way to improve this is to have one typeclass per property and try to minimize the number of two-argument typeclasses. And things like <code>ins x Class</code> are really calling out for a <code>Class</code> type as you indicate, which would eliminate the need to do any type class search, although you still have to do something about subtyping.</p>",
        "id": 196975285,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589003244
    },
    {
        "content": "<p>What is the function of putting <code>noncomputable</code> before <code>instance</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">inner_product_space</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">inner_product_space.of_core</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 244001663,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624694462
    },
    {
        "content": "<p>Perhaps it helps to realize that <code>instance</code> is just short for <code>@[instance] def</code>, so this is just like putting <code>noncomputable</code> before a def.</p>",
        "id": 244002489,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1624695819
    },
    {
        "content": "<p>What will be the difference in practice if I don't put the <code>noncomputable</code>?</p>",
        "id": 244003170,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624696750
    },
    {
        "content": "<p>It's not you who chooses -- Lean will tell you what's computable and what isn't, and you tag appropriately. Noncomputability is irrelevant if you just want to prove theorems, it just stops you doing things like #eval and #reduce, but there are plenty of other ways to evaluate things eg use theorems</p>",
        "id": 244008502,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624704051
    },
    {
        "content": "<p>Lean will give an error if you put <code>noncomputable</code> on something that is computable, or don't put it on something that isn't. Lean is trying to make you tell the human reader what is and is not computable, even though lean itself knows without you telling it</p>",
        "id": 244008621,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1624704243
    },
    {
        "content": "<p>If you think your readers don't care, you can start your file with <code>noncomputable theory</code> and lean will stop complaining.</p>",
        "id": 244008658,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1624704288
    },
    {
        "content": "<p>Why is this def noncomputable?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">of_bijective</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">bijective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">of_injective</span> <span class=\"n\">f</span> <span class=\"n\">hf.1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"bp\">$</span> <span class=\"o\">(</span><span class=\"n\">set_congr</span> <span class=\"n\">hf.2.range_eq</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"bp\">$</span> <span class=\"n\">equiv.set.univ</span> <span class=\"n\">β</span>\n</code></pre></div>",
        "id": 246507301,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626725383
    },
    {
        "content": "<p>Because it does not actually provide an explicit inverse function to <code>f</code></p>",
        "id": 246507468,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626725445
    },
    {
        "content": "<p>Is it possible to make this computable by another proof?<br>\n<code> def of_bijective {α β} (f : α → β) (hf : bijective f) : α ≃ β := sorry</code></p>",
        "id": 246507681,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626725538
    },
    {
        "content": "<p>No.</p>",
        "id": 246507762,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626725587
    },
    {
        "content": "<p>Oh, I see</p>",
        "id": 246507776,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626725593
    },
    {
        "content": "<p>I depends on axiom of choice.</p>",
        "id": 246507800,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626725604
    },
    {
        "content": "<p><a href=\"https://xenaproject.wordpress.com/2019/06/11/the-inverse-of-a-bijection/\">https://xenaproject.wordpress.com/2019/06/11/the-inverse-of-a-bijection/</a></p>",
        "id": 246507840,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626725620
    },
    {
        "content": "<p>If you see the other thread, you'll see that you don't actually care about the computability of that iso, because you need it solely in the context of a proof.</p>",
        "id": 246507947,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626725664
    },
    {
        "content": "<p>Currently, for the purpose of my work, I actually don't need to care about the computability of anything at all :)</p>",
        "id": 246508111,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626725754
    },
    {
        "content": "<p>Is it possible to make a computable instance? <code>F</code> is a finite field.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.finite.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">char_p</span> <span class=\"n\">F</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_quad_residue</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"bp\">^</span><span class=\"mi\">2</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">is_quad_residue</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">is_quad_residue</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"n\">classical.dec</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">)}</span>\n</code></pre></div>",
        "id": 246597892,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626791998
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.finite.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">char_p</span> <span class=\"n\">F</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[derive decidable]</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_quad_residue</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"bp\">^</span><span class=\"mi\">2</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">is_quad_residue</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>",
        "id": 246598865,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626792164
    },
    {
        "content": "<p>Similarly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.finite.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">char_p</span> <span class=\"n\">F</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_quad_residue</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"bp\">^</span><span class=\"mi\">2</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">is_quad_residue</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">unfold</span> <span class=\"n\">is_quad_residue</span><span class=\"o\">,</span> <span class=\"n\">apply_instance</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 246599219,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1626792226
    },
    {
        "content": "<p>Just know that the decidable instance it generates is a brute force search over the entirety of F.</p>",
        "id": 246601551,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626792767
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/noncomputable/near/246601551\">said</a>:</p>\n<blockquote>\n<p>Just know that the decidable instance it generates is a brute force search over the entirety of F.</p>\n</blockquote>\n<p>As it should be!</p>",
        "id": 246601821,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626792889
    },
    {
        "content": "<p>It would be fun to make a decidable instance based on quadratic reciprocity <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 246602351,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626793124
    },
    {
        "content": "<p>Euler's criterion and exponentiation by squaring might be easier</p>",
        "id": 246605860,
        "sender_full_name": "David Wärn",
        "timestamp": 1626794417
    },
    {
        "content": "<p>My instinct is that the QR proof is faster?</p>",
        "id": 246605953,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626794464
    },
    {
        "content": "<p>Am I wrong?</p>",
        "id": 246605971,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626794475
    },
    {
        "content": "<p>One would have to be careful to use a binary_rec pow definition and not the unary one.</p>",
        "id": 246606457,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626794708
    },
    {
        "content": "<p>I guess the repeated squaring would work for finite fields other than Z/p</p>",
        "id": 246606934,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626794927
    },
    {
        "content": "<p>Euler's criterion is easier to prove correct, but mathlib probably has all the theory needed to prove correctness of the QR algorithm. Both algorithms are very fast (polynomial in number of digits), but I would also guess that QR is faster by some constant factor</p>",
        "id": 246618466,
        "sender_full_name": "David Wärn",
        "timestamp": 1626799968
    },
    {
        "content": "<p>One reason for doing this would be that there are fast primality tests which use this stuff -- they fail quickly for non-primes.</p>",
        "id": 246624183,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626802537
    },
    {
        "content": "<p>What exactly is the meaning of <code>noncomputable</code> in Lean?</p>",
        "id": 279765661,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1650590214
    },
    {
        "content": "<p>not executable by the lean VM</p>",
        "id": 279767802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1650592240
    },
    {
        "content": "<p>That makes it sound like one day it may become executable...</p>",
        "id": 279768909,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1650593202
    },
    {
        "content": "<p>And therefore become computable</p>",
        "id": 279769071,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1650593400
    },
    {
        "content": "<p>well sure, depending on what kind of evolution you have in mind</p>",
        "id": 279772318,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1650596675
    },
    {
        "content": "<p>you can rewrite a function to become computable</p>",
        "id": 279772335,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1650596696
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/12301\">#12301</a> is a recent example of exactly that</p>",
        "id": 279772380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1650596736
    },
    {
        "content": "<p>in particular, just because a function is marked <code>noncomputable</code> does not mean there is not an equal function which is computable</p>",
        "id": 279772587,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1650596945
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"n\">classical.some</span> <span class=\"o\">(⟨</span><span class=\"mi\">37</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">37</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"mi\">37</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"bp\">=</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"n\">classical.some_spec</span> <span class=\"o\">(⟨</span><span class=\"mi\">37</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">37</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 279772747,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1650597084
    },
    {
        "content": "<p>Using <code>noncomputable!</code> you can even force a computable definition to be noncomputable</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"mi\">37</span>\n<span class=\"kd\">noncomputable</span><span class=\"bp\">!</span> <span class=\"kd\">def</span> <span class=\"n\">baz</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"mi\">37</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"bp\">=</span> <span class=\"n\">baz</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 279772905,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1650597223
    },
    {
        "content": "<p>Hmm so in particular, noncomputable means \"Lean, don't try to compute a representation for this, just check whether it's logically correct\"?</p>",
        "id": 279782501,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1650606941
    },
    {
        "content": "<p>Usually it means \"lean has told me it is unable to compute this\"</p>",
        "id": 279782779,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650607227
    },
    {
        "content": "<p>In practice it means that your function can't be run from a tactic</p>",
        "id": 279811236,
        "sender_full_name": "Reid Barton",
        "timestamp": 1650627469
    }
]
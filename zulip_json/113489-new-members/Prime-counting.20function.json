[
    {
        "content": "<p>Dear all,<br>\nI have started learning Lean recently by doing some of the amazingly written exercises from prof. Buzzard's Formalising Mathematics workshop.<br>\nNow I am willing to formalize a simple theorem for myself: number 81 from Wiedijk's list, Divergence of Prime Reciprocals. I am having trouble figuring out how to define a function (n \\mapsto p_n) in Lean properly. The definition should clearly rely on the Euclid's theorem of the infinitude of primes somehow. Is there a built-in way to define 'n-th member of a set' in Lean?</p>",
        "id": 235367350,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618933811
    },
    {
        "content": "<p>Sets are inherently disordered, so there is no \"nth\" element. You might prefer lists, or just a function <code>nat -&gt; _</code></p>",
        "id": 235367993,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618934059
    },
    {
        "content": "<p>Basically, I want a function which takes a subset of a linearly ordered set, and produces a list which contains all its elements sorted.<br>\nAlthough, how is divergence of a series defined in Lean? It uses the definition of a sequence as nat -&gt; reals, right? Then I guess I want a function nat -&gt; reals.</p>",
        "id": 235368338,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618934181
    },
    {
        "content": "<p>The way series work is that they're just functions from a random type (e.g. the naturals) to a type which is an additive commutative monoid and a topological space :-)</p>",
        "id": 235368771,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618934340
    },
    {
        "content": "<p>I didn't even say \"topological monoid\" because for the <em>definition</em> of convergence you don't need the addition and the topology to be compatible :-) Oh those computer scientists are so funny.</p>",
        "id": 235368922,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618934395
    },
    {
        "content": "<p>So you would want a function from the naturals to the reals, and my instinct is to define this function by recursion, sending 0 to 2 and, if it sends <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">p(n)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>, then it sends <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n+1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> to <code>nextprime (p n + 1)</code></p>",
        "id": 235369227,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618934475
    },
    {
        "content": "<p>which means you'll have to write <code>nextprime</code> first.</p>",
        "id": 235369288,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618934502
    },
    {
        "content": "<p>which is already an interesting exercise.</p>",
        "id": 235369308,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618934510
    },
    {
        "content": "<p>And then the theorem you're after would say that the function sending <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>p</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">1/p(n)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> was not <code>summable</code> (you'd need to import <code>topology.algebra.infinite_sum</code> to get access to <code>summable</code>).</p>",
        "id": 235369630,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618934610
    },
    {
        "content": "<p>(Should we have a <code>list.primes_up_to</code>? Or a <code>stream.primes</code>?)</p>",
        "id": 235369761,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618934649
    },
    {
        "content": "<p>I dunno, those are CS questions. Maybe!</p>",
        "id": 235369957,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618934718
    },
    {
        "content": "<p>I cannot believe that it's 2021 and <code>nat.find</code> still does not have a docstring.</p>",
        "id": 235370002,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618934737
    },
    {
        "content": "<p>Looking through <a href=\"https://leanprover-community.github.io/mathlib_docs/data/nat/prime.html\">https://leanprover-community.github.io/mathlib_docs/data/nat/prime.html</a> I only found (n -&gt; list of factors of n) and no (n -&gt; all primes less than n), unfortunately.<br>\nI could just use nat.factors(n!), but that would be ugly.</p>",
        "id": 235370877,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618935064
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.prime</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">exists_infinite_primes</span>\n<span class=\"c1\">-- ∀ (n : ℕ), ∃ (p : ℕ), n ≤ p ∧ nat.prime p</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nextprime</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">nat.find</span> <span class=\"o\">(</span><span class=\"n\">exists_infinite_primes</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>I think that's the function.</p>",
        "id": 235370984,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618935107
    },
    {
        "content": "<p>oh no wait, is <code>nextprime 3</code> supposed to be 3 or 5? Hmm, pari-gp says 3.</p>",
        "id": 235371079,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618935131
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">nextprime</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">nat.find</span> <span class=\"o\">(</span><span class=\"n\">exists_infinite_primes</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>That's the function then.</p>",
        "id": 235371128,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618935147
    },
    {
        "content": "<p>with sad sad computational performance</p>",
        "id": 235371191,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618935170
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">nextprime</span> <span class=\"mi\">4</span> <span class=\"c1\">-- 5</span>\n<span class=\"k\">#eval</span> <span class=\"n\">nextprime</span> <span class=\"mi\">5</span> <span class=\"c1\">-- 5</span>\n</code></pre></div>\n<p>Looks good. Who cares about computational performance, we're proving a theorem.</p>",
        "id": 235371220,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618935183
    },
    {
        "content": "<p>Why is +1 an issue? Because it would skip 3?</p>",
        "id": 235371288,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618935212
    },
    {
        "content": "<p>I added 1 because I was jumping the gun: we do <code>nextprime(p(n)+1)</code> when defining <code>p(n)</code></p>",
        "id": 235371397,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618935246
    },
    {
        "content": "<p>Thanks, will try that out! :-)</p>",
        "id": 235371407,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618935248
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.prime</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">exists_infinite_primes</span>\n<span class=\"c1\">-- ∀ (n : ℕ), ∃ (p : ℕ), n ≤ p ∧ nat.prime p</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nextprime</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">nat.find</span> <span class=\"o\">(</span><span class=\"n\">exists_infinite_primes</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">nextprime</span> <span class=\"mi\">4</span> <span class=\"c1\">-- 5</span>\n<span class=\"k\">#eval</span> <span class=\"n\">nextprime</span> <span class=\"mi\">5</span> <span class=\"c1\">-- 5</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">prime</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">nextprime</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">p</span> <span class=\"mi\">3</span> <span class=\"c1\">-- 7 (note we start with p₀ = 2)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">prime</span>\n</code></pre></div>",
        "id": 235371592,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618935327
    },
    {
        "content": "<p>We've made some definitions so definitely the next thing to do is to prove some theorems about those definitions, for example some of the following might be helpful (and some might be hard): nextprime(n)&gt;=n, nextprime(n) is prime, p(n) is prime, every prime p is p(n) for some n. The function p is injective, etc etc. thinking about it I'm not sure that calling the function <code>p</code> is a good idea -- you might want to use <code>p</code> for a prime number. Maybe <code>pcount</code>?</p>",
        "id": 235371913,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618935447
    },
    {
        "content": "<p>If p is prime and n&lt;=p then nextprime(n)&lt;=p etc.</p>",
        "id": 235371996,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618935483
    },
    {
        "content": "<p>Just so you know, PR <a href=\"https://github.com/leanprover-community/mathlib/issues/7274\">#7274</a> has a proof of this! I'd encourage you to still do it (it'll be good fun) and it'll be interesting to compare your two approaches after</p>",
        "id": 235372042,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1618935490
    },
    {
        "content": "<p>(for example <a href=\"https://github.com/leanprover-community/mathlib/issues/7274\">#7274</a> doesn't use the next prime function)</p>",
        "id": 235372077,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1618935507
    },
    {
        "content": "<p>oh what a crazy coincidence -- I didn't know we had this</p>",
        "id": 235372130,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618935530
    },
    {
        "content": "<p>just 10 hours ago :b</p>",
        "id": 235372200,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1618935557
    },
    {
        "content": "<p>Isn't <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\pi(n)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> traditionally the number of primes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">\\le n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>?</p>",
        "id": 235372212,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618935561
    },
    {
        "content": "<p>sorry yes you're right, my point is that it doesn't use a \"next prime\" function</p>",
        "id": 235372282,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1618935592
    },
    {
        "content": "<p>Interesting! Now I'm curious to see how you even stated it :-)</p>",
        "id": 235372778,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618935781
    },
    {
        "content": "<p>Aah -- very nice!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">filter.tendsto</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">∑</span> <span class=\"n\">p</span> <span class=\"k\">in</span> <span class=\"o\">{</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span> <span class=\"bp\">|</span> <span class=\"n\">nat.prime</span> <span class=\"n\">p</span> <span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)))</span> <span class=\"n\">at_top</span> <span class=\"n\">at_top</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>You literally write down the finite sums by summing over finite sets.</p>",
        "id": 235372982,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618935860
    },
    {
        "content": "<p>A small follow-up question to be clear: does nat.find outputs a smallest element from a nonempty subset of nat?</p>",
        "id": 235374851,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618936540
    },
    {
        "content": "<p>Or from a proof that a set is nonempty, I guess</p>",
        "id": 235375121,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618936646
    },
    {
        "content": "<p><code>nat.find</code> finds the smallest nat that satisfies some <code>exists (n : nat) such that ...</code></p>",
        "id": 235375538,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618936824
    },
    {
        "content": "<p>A subset of nat, in Lean a term of type <code>set nat</code>, is like a function that takes a <code>x : nat</code> and gives you back the proposition that the <code>x</code> in the subset you're talking about</p>",
        "id": 235375706,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618936904
    },
    {
        "content": "<p>The definition in mathlib, of a nonempty subset is given by <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.nonempty\">docs#set.nonempty</a>, which is definitionally equal to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">s.nonempty</span> <span class=\"bp\">=</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span>\n</code></pre></div>",
        "id": 235375885,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618936966
    },
    {
        "content": "<p>So, in this piece of code above, is (exists_infinite_primes n) a proof of {p | prime p \\and p &gt; n}.nonempty?</p>",
        "id": 235375984,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618937005
    },
    {
        "content": "<p>So yes, if you have some <code>s : set nat</code> and a proof that <code>s.nonempty</code>, then <code>nat.find s.nonempty</code> will give you the least <code>x : nat</code> such that <code>x ∈ s</code></p>",
        "id": 235376024,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618937020
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.exists_infinite_primes\">docs#nat.exists_infinite_primes</a></p>",
        "id": 235376041,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618937029
    },
    {
        "content": "<p>Ok, thanks!</p>",
        "id": 235376132,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618937055
    },
    {
        "content": "<p>That lemma is definitionally equal to what you just wrote about <code>{ ... }.nonempty</code>. But it is phrased as the explicit existential statement</p>",
        "id": 235376215,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618937095
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean/issues/566\">lean#566</a></p>",
        "id": 235379056,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618938206
    },
    {
        "content": "<p>It's in core, that's why there's no docstring. I had to clone Lean! I felt like a real computer scientist :-)</p>",
        "id": 235379583,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618938431
    },
    {
        "content": "<p>there was no need to do that for such a small change btw - on the github website, you can press the little edit box and it'll auto-create a branch for you and let you edit/PR</p>",
        "id": 235380628,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1618938909
    },
    {
        "content": "<p>There is a very stupid problem I am running into.<br>\nSo I want to know that 1/2&gt;0, but when I just write have f : 1/2 &gt; 0 := or whatever, it just assumes that I mean 1, 2 and 0 as naturals, and under this interpretation the statement is wrong! How do I tell Lean that I mean the real 1, not 1 in any other mathematical structure?</p>",
        "id": 235400985,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618946844
    },
    {
        "content": "<p>(1 : ℝ) / 2</p>",
        "id": 235401175,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1618946926
    },
    {
        "content": "<p>Ok, thanks!</p>",
        "id": 235401698,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618947136
    },
    {
        "content": "<p><code>(1 / 2 : ℝ)</code> is fine too, and generally more readable.</p>",
        "id": 235440831,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618968235
    },
    {
        "content": "<p>Why does that work? I mean I guess it obviously works because Lean doesn't evaluate the <code>1 / 2</code> until after seeing it should be done in R? So Lean basically doesn't try to interpret the left side of a coersion until after seeing what type it's supposed to be?</p>",
        "id": 235441558,
        "sender_full_name": "Julian Berman",
        "timestamp": 1618968899
    },
    {
        "content": "<p>It's all a bit complicated, but at least when there is expected type information available, Lean works from the outside in. So here is goes to look for a <code>had_div ℝ</code> instance first, and then after that starts trying to interpret the numerals as terms in <code>ℝ</code>.</p>",
        "id": 235441693,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618969029
    },
    {
        "content": "<p>In the opposite direction we sometimes use the trick <code>(X : _)</code>, which basically forces Lean to forget the expected type as it interprets <code>X</code>.</p>",
        "id": 235441712,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618969063
    },
    {
        "content": "<p>Interesting. Thanks for the explanation.</p>",
        "id": 235441802,
        "sender_full_name": "Julian Berman",
        "timestamp": 1618969160
    },
    {
        "content": "<p>What is Lean's notation for restriction of a function?</p>",
        "id": 235475932,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618995263
    },
    {
        "content": "<p>You just compose with the inclusion.</p>",
        "id": 235475974,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618995296
    },
    {
        "content": "<p>It's easy to find names for functions in measure theory in mathlib, but I can't find a list with set-theoretic operations :(</p>",
        "id": 235476024,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618995327
    },
    {
        "content": "<p>Just ask here (but maybe in a new thread).</p>",
        "id": 235476076,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618995361
    },
    {
        "content": "<p>There's also this function for the ith prime which Mario wrote in another thread. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.prime</span>\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">find_prime</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">decidable_prime_1</span> <span class=\"n\">n</span><span class=\"bp\">;</span> <span class=\"n\">exact</span>\n  <span class=\"k\">if</span> <span class=\"n\">prime</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">n</span> <span class=\"k\">else</span> <span class=\"n\">find_prime</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ith_prime</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">ith_prime</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">find_prime</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ith_prime</span> <span class=\"mi\">4</span> <span class=\"bp\">=</span> <span class=\"mi\">11</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n</code></pre></div>",
        "id": 235594013,
        "sender_full_name": "Lucas Allen",
        "timestamp": 1619045255
    },
    {
        "content": "<p>(warning: that function computes well but proving that it produces primes requires Bertrand's postulate)</p>",
        "id": 235623656,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619070888
    },
    {
        "content": "<p>Which is almost in mathlib, I think.</p>",
        "id": 235626194,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619072969
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Prime-counting.20function/near/235371079\">said</a>:</p>\n<blockquote>\n<p>oh no wait, is <code>nextprime 3</code> supposed to be 3 or 5? Hmm, pari-gp says 3.</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">sage</span><span class=\"o\">:</span> <span class=\"n\">next_prime</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">)</span>\n<span class=\"mi\">5</span>\n</code></pre></div>",
        "id": 235645459,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1619083596
    },
    {
        "content": "<p>Mathlib's compromise:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">nextprime</span> <span class=\"mi\">3</span>\n<span class=\"c1\">-- 3</span>\n<span class=\"k\">#eval</span> <span class=\"n\">next_prime</span> <span class=\"mi\">3</span>\n<span class=\"c1\">-- 5</span>\n</code></pre></div>",
        "id": 235645552,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619083668
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"254058\">@Marc Masdeu</span> how about we go for 4 as a compromise ;-)</p>",
        "id": 235657033,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619089563
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">$</span> <span class=\"n\">gp</span>\n<span class=\"bp\">?</span> <span class=\"n\">nextprime</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">)</span>\n<span class=\"bp\">%</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span>\n<span class=\"bp\">?</span>\n</code></pre></div>",
        "id": 235657131,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619089626
    },
    {
        "content": "<p>Does mathlib have the following statement:<br>\nIf n is a natural number such that for any prime p, the order of p in n is even, then n is a perfect square?</p>",
        "id": 235803858,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619165718
    },
    {
        "content": "<p>I'm failing to even state it, so perhaps not :)</p>",
        "id": 235805780,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1619166767
    },
    {
        "content": "<p>Here's a proof sketch, combining <a href=\"https://leanprover-community.github.io/mathlib_docs/find/unique_factorization_monoid.factors\">docs#unique_factorization_monoid.factors</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/multiset.count\">docs#multiset.count</a>: Prove by strong induction on <code>m</code> that <code>∀ (m : multiset R), (∀ p, 2 \\dvd m.count p) -&gt; ∃ (x : R), m.prod = x * x</code>, and use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/unique_factorization_monoid.factors_prod\">docs#unique_factorization_monoid.factors_prod</a> to conclude <code>∀ x, (order_of_factors_is_even x) -&gt; ∃ y, associated x (y * y)</code>. Finally you need that all units in <code>ℕ</code> are squares (because they are all 1) to conclude that <code>∃ y, x = y * y</code>.</p>",
        "id": 235808017,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1619168076
    },
    {
        "content": "<p>I was trying to use <code>multiplicity</code>, though Anne's approach makes more sense - I even have a fair amount of that code written :)<br>\nWill send a pointer in a bit</p>",
        "id": 235809362,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1619168753
    },
    {
        "content": "<p>Ah good point, forgot about <code>multiplicity</code>. I guess we could split the difference via <a href=\"https://leanprover-community.github.io/mathlib_docs/find/unique_factorization_monoid.multiplicity_eq_count_factors\">docs#unique_factorization_monoid.multiplicity_eq_count_factors</a></p>",
        "id": 235809549,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1619168827
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.int.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">unique_factorization_monoid</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">multiset.exists_nsmul_of_dvd</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"bp\">∣</span> <span class=\"n\">multiset.count</span> <span class=\"n\">x</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">k</span> <span class=\"bp\">•</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">m.prime</span> <span class=\"bp\">→</span> <span class=\"n\">k</span> <span class=\"bp\">∣</span> <span class=\"o\">(</span><span class=\"n\">factors</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">count</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">^</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">m'</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">factors</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">•</span> <span class=\"n\">m'</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">m'</span><span class=\"o\">,</span> <span class=\"n\">hm'</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">apply_fun</span> <span class=\"n\">multiset.prod</span> <span class=\"n\">at</span> <span class=\"n\">hm'</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">factors_prod</span> <span class=\"n\">hn.ne'</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">associated_iff_eq</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">multiset.prod_nsmul</span><span class=\"o\">,</span> <span class=\"n\">this</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hm'</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">m'.prod</span><span class=\"o\">,</span> <span class=\"n\">hm'</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"n\">apply</span> <span class=\"n\">multiset.exists_nsmul_of_dvd</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">nat.factors_eq</span> <span class=\"n\">at</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">nat.prime_of_mem_factors</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>with the first lemma from <a href=\"https://github.com/Ruben-VandeVelde/flt/blob/main/src/multiset.lean\">https://github.com/Ruben-VandeVelde/flt/blob/main/src/multiset.lean</a></p>",
        "id": 235811415,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1619169757
    },
    {
        "content": "<p>Is this your Fermat's Last Theorem repo?</p>",
        "id": 235812190,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619170151
    },
    {
        "content": "<p>With Neil Strickland's little used API for prime multisets, this can be done as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.pnat.factors</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">multiset.exists_nsmul_of_dvd</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"bp\">∣</span> <span class=\"n\">multiset.count</span> <span class=\"n\">x</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">k</span> <span class=\"bp\">•</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span> <span class=\"bp\">∣</span> <span class=\"n\">n.factor_multiset.count</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"bp\">^</span><span class=\"n\">q</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">hm</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">multiset.exists_nsmul_of_dvd</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">hn</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"o\">⟨</span><span class=\"n\">prime_multiset.prod</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">n.prod_factor_multiset</span><span class=\"o\">,</span> <span class=\"n\">hm</span><span class=\"o\">,</span> <span class=\"n\">prime_multiset.prod_smul</span><span class=\"o\">]⟩</span>\n</code></pre></div>",
        "id": 235868086,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1619194506
    },
    {
        "content": "<p>I'd be inclined to try and do that computably as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">multiset.nsmul_of_dvd</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"bp\">∣</span> <span class=\"n\">multiset.count</span> <span class=\"n\">x</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">{</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">k</span> <span class=\"bp\">•</span> <span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 235872110,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619196293
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finsupp</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">to_multiset_symm_apply</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">finsupp.to_multiset.symm</span> <span class=\"n\">s</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">multiset.count</span> <span class=\"n\">x</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">convert</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">multiset.exists_nsmul_of_dvd</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"bp\">∣</span> <span class=\"n\">multiset.count</span> <span class=\"n\">x</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">{</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">k</span> <span class=\"bp\">•</span> <span class=\"n\">t</span> <span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨(</span><span class=\"n\">finsupp.map_range</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">t</span> <span class=\"bp\">/</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">finsupp.to_multiset.symm</span> <span class=\"n\">s</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">to_multiset</span><span class=\"o\">,</span>\n  <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nat.mul_div_cancel'</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">_</span><span class=\"o\">)]}</span> <span class=\"o\">⟩</span>\n</code></pre></div>\n<p>Not much more computable, but potentially could be improved</p>",
        "id": 235875542,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1619197656
    },
    {
        "content": "<p>Ah, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finsupp.to_multiset\">docs#finsupp.to_multiset</a> was something I was looking for</p>",
        "id": 235879632,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619199357
    },
    {
        "content": "<p>But <code>finsupp</code> is (almost) entirely non-computable, which is annoying here</p>",
        "id": 235879709,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619199374
    },
    {
        "content": "<p>Oh, it's even more annoying than that; <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finsupp.to_multiset\">docs#finsupp.to_multiset</a> is non-computable only because the addition needed to state <code>map_add</code> is noncomputable!</p>",
        "id": 235880244,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619199602
    },
    {
        "content": "<p>So I have found and used unique_factorization_monoid.factors_prod, to prove that a natural number is a product of a multiset of its prime factors. Is there a converse statement: if s is a multiset of primes, than unique_factorization_monoid.factors (<a href=\"http://s.prod\">s.prod</a>) = s?</p>",
        "id": 235980436,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619279320
    },
    {
        "content": "<p>I think that Neil Strickland proved that equivalence, yes. Hopefully it's somewhere in the same file.</p>",
        "id": 235983513,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619282045
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/prime_multiset.factor_multiset_prod\">docs#prime_multiset.factor_multiset_prod</a></p>",
        "id": 235983518,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1619282049
    },
    {
        "content": "<p>Ok, so now I really struggle with the fact that some useful lemmas are proved fo <code>unique_factorization_monoid.factors</code> and some for <code>pnat.factor_multiset</code>.</p>\n<p>I have started by </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">square_separation</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">r</span> <span class=\"bp\">∧</span> <span class=\"n\">squarefree</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">pnat.prod_factor_multiset</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">ev_sep</span> <span class=\"o\">:=</span> <span class=\"n\">even_separation</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">n.factor_multiset</span><span class=\"o\">),</span>\n  <span class=\"n\">cases</span> <span class=\"n\">ev_sep</span> <span class=\"k\">with</span> <span class=\"n\">t</span> <span class=\"n\">ht</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">ht</span> <span class=\"k\">with</span> <span class=\"n\">r</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">hr</span> <span class=\"k\">with</span> <span class=\"n\">n_uni</span> <span class=\"n\">hr'</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">hr'</span> <span class=\"k\">with</span> <span class=\"n\">t_ev</span> <span class=\"n\">r_sqf</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">t_sq</span> <span class=\"o\">:=</span> <span class=\"n\">multiset_square</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"n\">t</span> <span class=\"n\">t_ev</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">t_sq</span> <span class=\"k\">with</span> <span class=\"n\">v</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">v.prod</span><span class=\"o\">,</span> <span class=\"n\">use</span> <span class=\"n\">r.prod</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">multiset.prod_add</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">multiset.prod_add</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">hv</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">n_uni</span><span class=\"o\">,</span>\n  <span class=\"n\">symmetry</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>and then I fail to apply <code>nat.squarefree_iff_nodup_factors</code> because I have to work in <code>\\N+</code> and <code>unique_factorization_monoid.squarefree_iff_nodup_factors</code> because <code>\\N+</code> is not a unique factorization domain.<br>\nIs there a good way to deal with this issue?<br>\nFor example, is it easy to relate <code>squarefree r.prod</code> and <code>squarefree (\\u r.prod : \\N)?</code></p>",
        "id": 235998369,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619292598
    },
    {
        "content": "<p><del>#backticks?</del> Ok yay</p>",
        "id": 235998593,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619292769
    },
    {
        "content": "<p>But <code>pnat</code> is a unique factorization monoid, right? So hopefully that instance is in mathlib. And if not, then we should add it.</p>",
        "id": 235998764,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619292879
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"355764\">Hanting Zhang</span> <a href=\"#narrow/stream/113489-new-members/topic/Prime-counting.20function/near/235998593\">said</a>:</p>\n<blockquote>\n<p><del>#backticks?</del> Ok yay</p>\n</blockquote>\n<p>Thanks, they look nice :)</p>",
        "id": 235998826,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619292930
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/Prime-counting.20function/near/235998764\">said</a>:</p>\n<blockquote>\n<p>But <code>pnat</code> is a unique factorization monoid, right? So hopefully that instance is in mathlib. And if not, then we should add it.</p>\n</blockquote>\n<p>looks like <a href=\"https://leanprover-community.github.io/mathlib_docs/ring_theory/unique_factorization_domain.html#unique_factorization_monoid\">https://leanprover-community.github.io/mathlib_docs/ring_theory/unique_factorization_domain.html#unique_factorization_monoid</a> means that a unique factorization monoid has a zero by definition, so I guess not.</p>",
        "id": 235998923,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619292974
    },
    {
        "content": "<p>I found</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">ring_theory</span><span class=\"bp\">/</span><span class=\"n\">int</span><span class=\"bp\">/</span><span class=\"n\">basic.lean</span>\n<span class=\"mi\">86</span><span class=\"o\">:</span><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">unique_factorization_monoid</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 235998938,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619292981
    },
    {
        "content": "<p>But maybe <code>pnat</code> is missing</p>",
        "id": 235998943,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619292988
    },
    {
        "content": "<p>ooh, hmz</p>",
        "id": 235998946,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619292995
    },
    {
        "content": "<p>Is there a reason that you want to prove your result for <code>pnat</code>?</p>",
        "id": 235998980,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619293023
    },
    {
        "content": "<p>Maybe prove it for <code>nat</code> first?</p>",
        "id": 235998987,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619293033
    },
    {
        "content": "<p>Once you have it for <code>nat</code>, deducing it for <code>pnat</code> is easy.</p>",
        "id": 235998996,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619293049
    },
    {
        "content": "<p>And I guess that you might as well prove it for an arbitrary UFM first, right?</p>",
        "id": 235999067,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619293091
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/Prime-counting.20function/near/235998980\">said</a>:</p>\n<blockquote>\n<p>Is there a reason that you want to prove your result for <code>pnat</code>?</p>\n</blockquote>\n<p>I prove it for pnat because pnat has a lemma I asked about a few hours ago</p>",
        "id": 235999127,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619293145
    },
    {
        "content": "<p><em>Stepan Nesterov|407114</em>* <a href=\"#narrow/stream/113489-new-members/topic/Prime-counting.20function/near/235980436\">said</a>:</p>\n<blockquote>\n<p>So I have found and used unique_factorization_monoid.factors_prod, to prove that a natural number is a product of a multiset of its prime factors. Is there a converse statement: if s is a multiset of primes, than unique_factorization_monoid.factors (<a href=\"http://s.prod\">s.prod</a>) = s?</p>\n</blockquote>\n<p>this one</p>",
        "id": 235999142,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619293171
    },
    {
        "content": "<p>And I couldn't find a lemma that unique_factorization_monoid.factors (<a href=\"http://s.prod\">s.prod</a>) is associated to s for s a multiset in a UFM</p>",
        "id": 235999217,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619293219
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/Prime-counting.20function/near/235998980\">said</a>:</p>\n<blockquote>\n<p>Is there a reason that you want to prove your result for <code>pnat</code>?</p>\n</blockquote>\n<p>I think the issue is that Neil Strickland's nice results for prime multisets and pnats were done before unique factorization monoids and they haven't got linked between them</p>",
        "id": 236019014,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1619308165
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407114\">@Stepan Nesterov</span> one line, once I managed to state it :)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.unique_factorization_domain</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_cancel_monoid_with_zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">unique_factorization_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">nontrivial</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normalization_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">prime</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">s.prod</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">multiset.rel</span> <span class=\"n\">associated</span> <span class=\"o\">(</span><span class=\"n\">unique_factorization_monoid.factors</span> <span class=\"o\">(</span><span class=\"n\">s.prod</span><span class=\"o\">))</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"n\">prime_factors_unique</span> <span class=\"n\">unique_factorization_monoid.prime_of_factor</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">unique_factorization_monoid.factors_prod</span> <span class=\"n\">h'</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 236062590,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1619354512
    },
    {
        "content": "<p>Ok, thanks, works like a charm :)</p>",
        "id": 236063064,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619354964
    },
    {
        "content": "<p>Under these definitions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">nextprime</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">nat.find</span> <span class=\"o\">(</span><span class=\"n\">nat.exists_infinite_primes</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">primecount</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">nextprime</span> <span class=\"o\">(</span><span class=\"n\">primecount</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>how do I prove that, say,  primecount 1 = 3? I am able to reduce it to nextprime 3 = 3 by unfolding the definitions, but I don't know how to prove that if 3 is the smallest prime greater than 3, then 3 = nextprime 3.</p>",
        "id": 237986581,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1620510064
    },
    {
        "content": "<p>One of the lemmas about <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.find\">docs#nat.find</a> should do that</p>",
        "id": 237987545,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620511226
    },
    {
        "content": "<p>It seems that there are three lemmas, which collectively cover 'nat.find p' is the smallest number that satisfies p, but no converse statement.</p>",
        "id": 237988266,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1620512063
    },
    {
        "content": "<p>If this is a question, can you formalise what you're looking for in Lean?</p>",
        "id": 237990584,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620514758
    },
    {
        "content": "<p>PS I wrote that nat.find docstring a few weeks ago because I noticed that it was in fashion right now but didn't have a docstring. I notice from Eric's link that the docstring is now live, but there's no link to <code>nat.find_min'</code> whereas the other two things in the API seem to be live links.</p>",
        "id": 237990747,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620514904
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.find_min'\">docs#nat.find_min'</a> works at least? I guess the link heuristic doesn't like a trailing <code>'</code>.</p>",
        "id": 238015590,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620544348
    },
    {
        "content": "<p>I wanted something like this, but I realized it is actually provable from the lemmas:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">nat_find_criterion</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hsat</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hmin</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">nat.find</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">lt_trichotomy</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">nat.find</span> <span class=\"n\">s</span><span class=\"o\">),</span>\n  <span class=\"n\">cases</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">exfalso</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">nat.find_min</span> <span class=\"n\">s</span> <span class=\"n\">f</span> <span class=\"n\">hsat</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">exfalso</span><span class=\"o\">,</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">hmin</span> <span class=\"o\">(</span><span class=\"n\">nat.find</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hmin</span> <span class=\"o\">(</span><span class=\"n\">nat.find_spec</span> <span class=\"n\">s</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 238021093,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1620550850
    },
    {
        "content": "<p>But now, when I try to actually prove that 3 is the first prime with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">primecount_succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">primecount</span> <span class=\"o\">(</span><span class=\"n\">n.succ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">nextprime</span> <span class=\"o\">(</span><span class=\"n\">primecount</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">zeroth_prime</span> <span class=\"o\">:</span> <span class=\"n\">primecount</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">next_prime</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nextprime</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">nat.find</span> <span class=\"o\">(</span><span class=\"n\">nat.exists_infinite_primes</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">first_prime</span> <span class=\"o\">:</span> <span class=\"n\">primecount</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">primecount_succ</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">zeroth_prime</span><span class=\"o\">,</span>\n  <span class=\"n\">norm_num</span><span class=\"o\">,</span>\n  <span class=\"n\">symmetry</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">next_prime</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">nat_find_criterion</span> <span class=\"mi\">3</span> <span class=\"o\">(</span><span class=\"n\">nat.exists_infinite_primes</span> <span class=\"mi\">3</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Lean says <br>\ninvalid apply tactic, failed to unify<br>\n  3 = nat.find _\nwith<br>\n  3 = nat.find _</p>",
        "id": 238021207,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1620550937
    },
    {
        "content": "<p>How do I modify the lemma so that it becomes applicable?</p>",
        "id": 238021227,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1620550962
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 238021295,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620550996
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.prime</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.algebra.infinite_sum</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.squarefree</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.unique_factorization_domain</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.multiset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.parity</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.associated</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.pnat.factors</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nextprime</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">nat.find</span> <span class=\"o\">(</span><span class=\"n\">nat.exists_infinite_primes</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">primecount</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">nextprime</span> <span class=\"o\">(</span><span class=\"n\">primecount</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">primecount</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">primecount_succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">primecount</span> <span class=\"o\">(</span><span class=\"n\">n.succ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">nextprime</span> <span class=\"o\">(</span><span class=\"n\">primecount</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">zeroth_prime</span> <span class=\"o\">:</span> <span class=\"n\">primecount</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">next_prime</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nextprime</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">nat.find</span> <span class=\"o\">(</span><span class=\"n\">nat.exists_infinite_primes</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nat_find_criterion</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hsat</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hmin</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">nat.find</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">lt_trichotomy</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">nat.find</span> <span class=\"n\">s</span><span class=\"o\">),</span>\n  <span class=\"n\">cases</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">exfalso</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">nat.find_min</span> <span class=\"n\">s</span> <span class=\"n\">f</span> <span class=\"n\">hsat</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">exfalso</span><span class=\"o\">,</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">hmin</span> <span class=\"o\">(</span><span class=\"n\">nat.find</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hmin</span> <span class=\"o\">(</span><span class=\"n\">nat.find_spec</span> <span class=\"n\">s</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">first_prime</span> <span class=\"o\">:</span> <span class=\"n\">primecount</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">primecount_succ</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">zeroth_prime</span><span class=\"o\">,</span>\n  <span class=\"n\">norm_num</span><span class=\"o\">,</span>\n  <span class=\"n\">symmetry</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">next_prime</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">nat_find_criterion</span> <span class=\"mi\">3</span> <span class=\"o\">(</span><span class=\"n\">nat.exists_infinite_primes</span> <span class=\"mi\">3</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 238021447,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1620551138
    },
    {
        "content": "<p>The puzzling issue is you combined <code>open_locale classical</code> with wanting to compute. You can't have everything. So the first layer of fix is to go to </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.prime</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.algebra.infinite_sum</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.squarefree</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.unique_factorization_domain</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.multiset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.parity</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.associated</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.pnat.factors</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n<span class=\"c1\">--open_locale classical</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nextprime</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">nat.find</span> <span class=\"o\">(</span><span class=\"n\">nat.exists_infinite_primes</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">primecount</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">nextprime</span> <span class=\"o\">(</span><span class=\"n\">primecount</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">primecount</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">primecount_succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">primecount</span> <span class=\"o\">(</span><span class=\"n\">n.succ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">nextprime</span> <span class=\"o\">(</span><span class=\"n\">primecount</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">zeroth_prime</span> <span class=\"o\">:</span> <span class=\"n\">primecount</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">next_prime</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nextprime</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">nat.find</span> <span class=\"o\">(</span><span class=\"n\">nat.exists_infinite_primes</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nat_find_criterion</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hsat</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hmin</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">nat.find</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">hsat</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">first_prime</span> <span class=\"o\">:</span> <span class=\"n\">primecount</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">change</span> <span class=\"n\">nextprime</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span><span class=\"o\">,</span>\n  <span class=\"n\">symmetry</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">nat_find_criterion</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 238022629,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620552397
    },
    {
        "content": "<p>(I put everything so you can use a diff tool to compare with your file)</p>",
        "id": 238022637,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620552422
    },
    {
        "content": "<p>The second layer is to realize you criterion is already in mathlib:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">nat_find_criterion</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hsat</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hmin</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">nat.find</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">hsat</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span>\n<span class=\"o\">((</span><span class=\"n\">nat.find_eq_iff</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">hsat</span><span class=\"o\">⟩)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"o\">⟨</span><span class=\"n\">hsat</span><span class=\"o\">,</span> <span class=\"n\">hmin</span><span class=\"o\">⟩)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>",
        "id": 238022757,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620552580
    },
    {
        "content": "<p>So you can remove it and start the last proof with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">first_prime</span> <span class=\"o\">:</span> <span class=\"n\">primecount</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">erw</span> <span class=\"n\">nat.find_eq_iff</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 238022827,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620552627
    },
    {
        "content": "<p>Note the <code>e</code> in <code>erw</code> asks <code>rw</code> to unfold definitions, but you could also write <code>change nat.find _ = _,</code> as the first line and then use the ordinary <code>rw</code></p>",
        "id": 238022926,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620552771
    },
    {
        "content": "<p>Actually, if I remove open_locale classical, then my proof of nat_find_criterion stops working, and Lean objects with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>\n<span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span>\n<span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n<span class=\"n\">hsat</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n<span class=\"n\">hmin</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"n\">n</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">decidable_pred</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 238023052,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1620552868
    },
    {
        "content": "<p>Where can I read about what open_locale classical actually does?<br>\nIt seems to come up quite often</p>",
        "id": 238023057,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1620552893
    },
    {
        "content": "<p>Did you actually compare my version with yours?</p>",
        "id": 238023061,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620552900
    },
    {
        "content": "<p>I did change the statement of <code>nat_find_criterion</code></p>",
        "id": 238023075,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620552914
    },
    {
        "content": "<p>By adding <code>[decidable_pred p]</code>, I see</p>",
        "id": 238023182,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1620553043
    },
    {
        "content": "<p>I don't know if we have a web page gathering what different locales do. You can go in the src folder of mathlib and run <code>grep -R \"localized.*classical\"</code></p>",
        "id": 238023199,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620553076
    },
    {
        "content": "<p>That would show you everything, potentially including stuff you haven't imported. To make sure, you can write in your current lean file<br>\n<code>run_cmd print_localized_commands [`classical]</code>, as explained on <a href=\"https://leanprover-community.github.io/mathlib_docs/commands.html#localized%20notation\">https://leanprover-community.github.io/mathlib_docs/commands.html#localized%20notation</a> (whose title is a bit misleading)</p>",
        "id": 238023338,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620553205
    },
    {
        "content": "<p>Either way, you see that <code>open_locale classical</code> puts the instance tag on a bunch of declarations: <code>eq.decidable</code>, <code>decidable_eq_of_decidable_le</code>, <code>classical.prop_decidable</code>.</p>",
        "id": 238023394,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620553285
    },
    {
        "content": "<p>Oh, I thought all it did was <a href=\"https://leanprover-community.github.io/mathlib_docs/find/classical.dec/src\">src#classical.dec</a></p>",
        "id": 238023408,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620553319
    },
    {
        "content": "<p>The main thing is <code>classical.prop_decidable</code></p>",
        "id": 238023468,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620553347
    },
    {
        "content": "<p>Huh, I guess <a href=\"https://leanprover-community.github.io/mathlib_docs/find/classical.prop_decidable\">docs#classical.prop_decidable</a> is what <a href=\"https://leanprover-community.github.io/mathlib_docs/find/classical.dec\">docs#classical.dec</a> is short for.</p>",
        "id": 238023501,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620553406
    },
    {
        "content": "<p>Stepan, do you understand what all those instances are about, or do you need more explanations?</p>",
        "id": 238023520,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620553429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Prime-counting.20function/near/238023501\">said</a>:</p>\n<blockquote>\n<p>Huh, I guess <a href=\"https://leanprover-community.github.io/mathlib_docs/find/classical.prop_decidable\">docs#classical.prop_decidable</a> is what <a href=\"https://leanprover-community.github.io/mathlib_docs/find/classical.dec\">docs#classical.dec</a> is short for.</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"n\">classical.dec</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">@[nolint id.{1} (list.{0} name) (Prop def_lemma)]</span>\n<span class=\"cm\">noncomputable theorem classical.dec : Π (p : Prop), decidable p :=</span>\n<span class=\"cm\">λ (p : Prop), classical.prop_decidable p</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 238023613,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620553531
    },
    {
        "content": "<p>I have no idea we why this need this duplication</p>",
        "id": 238023621,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620553550
    },
    {
        "content": "<p>So I guess <code>open_locale classical</code> lets you use axiom of choice (which implies the law of excluded middle)?</p>",
        "id": 238023624,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1620553555
    },
    {
        "content": "<p>No, that's not at all about the axiom of choice.</p>",
        "id": 238023680,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620553593
    },
    {
        "content": "<p>But Lean is using classical logic by default, right? I'm using <code>by_contra</code> all the time and it is allowed</p>",
        "id": 238023681,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1620553595
    },
    {
        "content": "<p>It's about excluded middle only.</p>",
        "id": 238023689,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620553611
    },
    {
        "content": "<p>So if we are allowed to apply <code>classical.choice</code> only to <code>Prop</code>, then this is equivalent to excluded middle?</p>",
        "id": 238023809,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1620553734
    },
    {
        "content": "<p>You are always free to use <code>classical.choice</code> etc whenever. The locale just means that typeclass search will use it to produce <code>decidable</code> instances via LEM.</p>",
        "id": 238023890,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620553807
    },
    {
        "content": "<p>But now I'm confused on why do we have to open something if I can already use <code>by_contra</code> in Lean without opening it anyway?</p>",
        "id": 238023898,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1620553819
    },
    {
        "content": "<p>Because by_contra isn't typeclass search</p>",
        "id": 238023919,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620553836
    },
    {
        "content": "<p>Lean can do two things: it can do mathematical reasoning, and there of course you want excluded middle and choice, but it can also do programming, which is useful when you want to write tactics and, less crucially, can be convenient in some proofs about computable objects. In programming excluded middle doesn't make any sense. Whatever the language, you want to be able to write <code>if condition then ... else ...</code> without the program hanging forever. The decidable classes in Lean are a way to register decision procedures so that it can <em>execute</em> such <code>if</code> statements. If <code>classical.decidable_prop</code> is an instance you're telling Lean that the procedure for any condition is to use the excluded middle law, but this will block execution.</p>",
        "id": 238023940,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620553909
    },
    {
        "content": "<p>Many tactics will fall back on classical mode anyway, but if you are in term mode some things won't work, for example <code>if x = y then ...</code> if <code>x = y</code> isn't decidable</p>",
        "id": 238023941,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620553909
    },
    {
        "content": "<p>So if my definition is not <code>noncomputable</code>, then Lean will be able to actually calculate its output</p>",
        "id": 238024209,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1620554219
    },
    {
        "content": "<p>Then shouldn't there be some universal tactic that proves things like <code>primecount 1  = 3</code> by computation? If I type <code>#eval primecount 1</code>, then Lean correctly outputs <code>3</code>, which means that deep down it knows the answer somehow</p>",
        "id": 238024301,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1620554325
    },
    {
        "content": "<p>yes, that exists</p>",
        "id": 238024375,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620554415
    },
    {
        "content": "<p>due to recent changes in lean it doesn't quite work out of the box but you can do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.prime</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">nat.decidable_prime_1</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">nat.prime</span> <span class=\"mi\">7</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n</code></pre></div>",
        "id": 238024528,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620554551
    },
    {
        "content": "<p>Why is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.decidable_prime_1\">docs#nat.decidable_prime_1</a> not an instance?</p>",
        "id": 238024646,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620554655
    },
    {
        "content": "<p>because it's slower than the default instance, which is used by <code>#eval</code></p>",
        "id": 238024674,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620554701
    },
    {
        "content": "<p>if you want to do kernel computation you shouldn't use either one and use <code>num.prime</code> instead</p>",
        "id": 238024697,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620554727
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.num.prime</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">find_prime</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">num</span> <span class=\"bp\">→</span> <span class=\"n\">num</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">n.prime</span> <span class=\"k\">then</span> <span class=\"n\">n</span> <span class=\"k\">else</span> <span class=\"n\">find_prime</span> <span class=\"n\">i</span> <span class=\"n\">n.succ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ith_prime</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">num</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">ith_prime</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">find_prime</span> <span class=\"n\">n</span> <span class=\"n\">n.succ</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ith_prime</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ith_prime</span> <span class=\"mi\">4</span> <span class=\"bp\">=</span> <span class=\"mi\">11</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ith_prime</span> <span class=\"mi\">100</span> <span class=\"bp\">=</span> <span class=\"mi\">547</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n</code></pre></div>",
        "id": 238024908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620554971
    },
    {
        "content": "<p>The \"universal tactic that proves things like <code>primecount 1 = 3</code> by computation\" is called <code>norm_num</code></p>",
        "id": 238024976,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620555013
    },
    {
        "content": "<p>however you have to write plugins for it to support new functions, and it doesn't know about <code>primecount</code></p>",
        "id": 238025004,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620555044
    },
    {
        "content": "<p>If it did, it could do a lot better than this naive counting algorithm</p>",
        "id": 238025022,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620555092
    }
]
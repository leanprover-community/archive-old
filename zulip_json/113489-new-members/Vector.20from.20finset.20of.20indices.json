[
    {
        "content": "<p>Hi, it's my first time posting but I often come here to read the discussions, so thanks to everyone who answers questions on here!</p>\n<p>I'm having trouble defining the inverse of a function that sends binary words (which are defined in the same way as vectors in TPIL) to a set of nonzero indices. Here's a MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">bit</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">O</span> <span class=\"o\">:</span> <span class=\"n\">bit</span>\n<span class=\"bp\">|</span> <span class=\"n\">I</span>  <span class=\"o\">:</span> <span class=\"n\">bit</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">binary_word</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">{}</span> <span class=\"o\">:</span> <span class=\"n\">binary_word</span> <span class=\"n\">nat.zero</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">bit</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bw</span> <span class=\"o\">:</span> <span class=\"n\">binary_word</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">binary_word</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">binary_word</span>\n<span class=\"kn\">open</span> <span class=\"n\">bit</span>\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"n\">h</span> <span class=\"o\">::</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">cons</span> <span class=\"n\">h</span> <span class=\"n\">t</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">indices</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">finset.erase</span> <span class=\"o\">(</span><span class=\"n\">finset.range</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bw_to_nonzero_indices</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">binary_word</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">nil</span>       <span class=\"o\">:=</span> <span class=\"bp\">∅</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">O</span> <span class=\"o\">::</span> <span class=\"n\">tl</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">bw_to_nonzero_indices</span> <span class=\"n\">tl</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">::</span> <span class=\"n\">tl</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">insert</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">bw_to_nonzero_indices</span> <span class=\"n\">tl</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nonzero_indices_to_bw</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">binary_word</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">nil</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"k\">then</span>\n    <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">::</span> <span class=\"n\">nonzero_indices_to_bw</span> <span class=\"n\">n</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n  <span class=\"k\">else</span>\n    <span class=\"o\">(</span><span class=\"n\">O</span> <span class=\"o\">::</span> <span class=\"n\">nonzero_indices_to_bw</span> <span class=\"n\">n</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bw_to_nonzero_indices_inv_nonzero_indices_to_bw</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">indices</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">bw_to_nonzero_indices</span> <span class=\"o\">(</span><span class=\"n\">nonzero_indices_to_bw</span> <span class=\"n\">n</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">binary_word</span>\n</code></pre></div>\n<p>Does anyone have a suggestion for how I could define <code>nonzero_indices_to_bw</code>? The current definition doesn't really work for this proof.</p>",
        "id": 229110734,
        "sender_full_name": "George Tillisch",
        "timestamp": 1615048550
    },
    {
        "content": "<p>Hi! Normally someone here would made intelligent comment already but you must have slipped through the net. For what it's worth here are some of my (not quite so intelligent) thoughts...</p>\n<p>First of all I'm not a big fan of your definition of <code>indices</code>. It's not particularly easy to work with. As evidence I provide these two proofs which would surely have been much more easier to do for simple inequalities.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">a</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">indices</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">s.erase</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">indices</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">i</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n  <span class=\"n\">dunfold</span> <span class=\"n\">indices</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">finset.mem_of_mem_erase</span> <span class=\"n\">hi</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finset.mem_erase</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">h.1</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">finset.mem_range</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">lt_of_le_of_ne</span> <span class=\"n\">_</span> <span class=\"n\">hi.1</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">finset.mem_range_succ_iff</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">h.2</span><span class=\"o\">,</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">b</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">indices</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">indices</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">h'</span> <span class=\"n\">i</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n  <span class=\"n\">dunfold</span> <span class=\"n\">indices</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finset.mem_erase</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">h.1</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">finset.mem_range</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">lt_of_le_of_ne</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">finset.mem_range_succ_iff</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">h.2</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">h'</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 229136094,
        "sender_full_name": "Alistair Tucker",
        "timestamp": 1615071264
    },
    {
        "content": "<p>Then since you ask specifically about <code>nonzero_indices_to_bw</code>, I would suggest the following slight change.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">nonzero_indices_to_bw</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">binary_word</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">nil</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"k\">then</span>\n    <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">::</span> <span class=\"n\">nonzero_indices_to_bw</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">s.erase</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)))</span>\n  <span class=\"k\">else</span>\n    <span class=\"o\">(</span><span class=\"n\">O</span> <span class=\"o\">::</span> <span class=\"n\">nonzero_indices_to_bw</span> <span class=\"n\">n</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>With that I have been able to prove your lemma by</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">bw_to_nonzero_indices_inv_nonzero_indices_to_bw</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">indices</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">bw_to_nonzero_indices</span> <span class=\"o\">(</span><span class=\"n\">nonzero_indices_to_bw</span> <span class=\"n\">n</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">revert</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">s</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"bp\">∅</span> <span class=\"bp\">=</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n    <span class=\"n\">symmetry</span><span class=\"o\">,</span>\n    <span class=\"n\">rwa</span> <span class=\"bp\">←</span> <span class=\"n\">finset.subset_empty</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">t</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">dunfold</span> <span class=\"n\">nonzero_indices_to_bw</span><span class=\"o\">,</span>\n    <span class=\"n\">split_ifs</span> <span class=\"k\">with</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">specialize</span> <span class=\"n\">ih</span> <span class=\"o\">(</span><span class=\"n\">t.erase</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">),</span>\n      <span class=\"n\">dunfold</span> <span class=\"n\">bw_to_nonzero_indices</span><span class=\"o\">,</span>\n      <span class=\"n\">conv_rhs</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">finset.insert_erase</span> <span class=\"n\">h'</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">ih</span><span class=\"o\">],</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">ih</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">h</span> <span class=\"n\">h'</span><span class=\"o\">),</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 229136420,
        "sender_full_name": "Alistair Tucker",
        "timestamp": 1615071609
    },
    {
        "content": "<p>I think it would be a lot easier to just work with lists</p>",
        "id": 229139786,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615075047
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"111433\">@Alistair Tucker</span> ,  you've shown me some great new tactics there! I did have a go with a definition that used erase but I put an empty set in the base case and it didn't work.</p>\n<p>I agree with you <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> , this is definitely a bodge. I ended up with this definition because I was trying to prove the hamming bound, so I wanted to prove that there are <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo fence=\"true\">(</mo><mfrac linethickness=\"0px\"><mi>n</mi><mi>m</mi></mfrac><mo fence=\"true\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\binom{n}{m}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.20001em;vertical-align:-0.35001em;\"></span><span class=\"mord\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size1\">(</span></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7453919999999999em;\"><span style=\"top:-2.3550000000000004em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span style=\"top:-3.144em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size1\">)</span></span></span></span></span></span> binary words at a given distance from another binary word. I looked around but it seems that counting arguments aren't very easy to formalise. I found <a href=\"https://leanprover-community.github.io/mathlib_docs/data/finset/powerset.html#finset.card_powerset_len\"><code>finset.card_powerset_len</code></a> in mathlib so I thought a good strategy would be to translate the statement into one about sets. That's also the reason I defined <code>indices</code> as a set, so I can take <code>(indices n).powerset</code> and prove <code>finset.image (λ v : BW n, bw_to_nonzero_indices v) finset.univ = (indices n).powerset</code>. There is probably a more straightforward approach that doesn't involve finsets.</p>",
        "id": 229198773,
        "sender_full_name": "George Tillisch",
        "timestamp": 1615133591
    },
    {
        "content": "<p>You can make it a statement about <code>list.length</code></p>",
        "id": 229198857,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615133660
    },
    {
        "content": "<p>Or number of times you have to do <code>list.update_nth</code></p>",
        "id": 229198908,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615133723
    }
]
[
    {
        "content": "<p>Was trying to (set-theoretically) glue functions together in Lean. My first thought was to write down something like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">glue</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">s</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">j</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>and going on to prove some lemmas saying that the resultant function agrees on each <code>f i</code> on <code>s i</code>.</p>\n<p>Is it a good idea to do this? What would be the idiomatic way of doing something like this in Lean?</p>",
        "id": 167233178,
        "sender_full_name": "Jean Lo",
        "timestamp": 1559596756
    },
    {
        "content": "<p>omit <code>h</code> from the definition of <code>glue</code></p>",
        "id": 167233281,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1559596851
    },
    {
        "content": "<p>include it in the lemmas</p>",
        "id": 167233305,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1559596866
    },
    {
        "content": "<p>and add it as a hypothesis in the lemmas?</p>",
        "id": 167233310,
        "sender_full_name": "Jean Lo",
        "timestamp": 1559596873
    },
    {
        "content": "<p>right</p>",
        "id": 167233317,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1559596879
    },
    {
        "content": "<p>ah okay, got it. Thanks!</p>",
        "id": 167233318,
        "sender_full_name": "Jean Lo",
        "timestamp": 1559596879
    },
    {
        "content": "<p>What do you do when <code>ι</code> is empty?</p>",
        "id": 167233411,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1559596964
    },
    {
        "content": "<p>either <code>ι</code> or <code>Y</code> being nonempty would prevent the sadness, I think. Probably add nonemptiness of <code>ι</code>as a hypothesis?</p>",
        "id": 167233534,
        "sender_full_name": "Jean Lo",
        "timestamp": 1559597045
    },
    {
        "content": "<p>You could instead just ask that the Union of s is X, for one of the unions in Lean, I forget what it's called</p>",
        "id": 167234456,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559597915
    },
    {
        "content": "<p>Existence and uniqueness of the glued function is the sheaf axiom for the cover</p>",
        "id": 167234504,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559597984
    },
    {
        "content": "<p>that's very tempting because asking the union to be X would eliminate one of the <code>ite</code>'s that I currently have to deal with.</p>\n<p>there's maybe some loss in generality in that I don't get to glue together function whose values I only care about within some subset, but I don't know how much I should worry about that.</p>",
        "id": 167235538,
        "sender_full_name": "Jean Lo",
        "timestamp": 1559598775
    },
    {
        "content": "<p>You could define a glued function only on the union</p>",
        "id": 167235944,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559599119
    },
    {
        "content": "<p>got stuck.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">set</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">function</span>\n\n<span class=\"n\">def</span> <span class=\"n\">glue</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"err\">⋃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">l₁</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">mem_Union</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n<span class=\"k\">let</span> <span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">l₁</span> <span class=\"k\">in</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">x</span>\n</pre></div>\n\n\n<p>If I replace the <code>f i x</code> with an underscore, Lean tells me that it knows that <code>i</code> is of type <code>ι</code> and <code>hi</code> says <code>x ∈ s i</code>, but it's also unhappy about the <code>let</code> because <code>recursor 'Exists.dcases_on' can only eliminate into Prop</code>.</p>",
        "id": 167238395,
        "sender_full_name": "Jean Lo",
        "timestamp": 1559601276
    },
    {
        "content": "<p>You will need to use <code>choice</code> or something equivalent (and <code>glue</code> will have to be noncomputable)</p>",
        "id": 167238471,
        "sender_full_name": "Reid Barton",
        "timestamp": 1559601349
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">noncomputable</span> <span class=\"kn\">theorem</span> <span class=\"n\">indefinite_description</span>\n    <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n</pre></div>",
        "id": 167238614,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559601468
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">some</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n</pre></div>",
        "id": 167238678,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559601499
    },
    {
        "content": "<p>(and <code>some_spec</code> too). See <a href=\"https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#choice\" target=\"_blank\" title=\"https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#choice\">https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#choice</a></p>",
        "id": 167238698,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559601521
    },
    {
        "content": "<p>ow, I really need to go and actually understand the computability stuff. Thanks for the help!</p>",
        "id": 167238750,
        "sender_full_name": "Jean Lo",
        "timestamp": 1559601590
    },
    {
        "content": "<p>They're all in the <code>classical</code> namespace. You can't make this computable I don't think. Even with the hypothesis that the sub-functions agree on overlaps!</p>",
        "id": 167238752,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559601594
    },
    {
        "content": "<p>The example I found most jarring was that even if you can prove that <code>f : X \\to Y</code> is a bijection, and computable, you can't construct a computable inverse; you have to use <code>classical.some</code> to get from the abstract surjectivity statement (\"there exists x in X such that...\") to the actual value of x (even though it's unique!)</p>",
        "id": 167238860,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559601671
    },
    {
        "content": "<p>Patrick wrote a <code>choose</code> tactic to do exactly this, but using tactics to define data is not always a good idea.</p>",
        "id": 167238931,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559601723
    },
    {
        "content": "<p>You're moving from <code>Prop</code> to <code>Type</code>. We do it all the time in the maths department, but basically you have to switch on maths mode to get Lean to do it without complaining.</p>",
        "id": 167238987,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559601783
    },
    {
        "content": "<p>aha.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">set</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">glue</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"err\">⋃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">mem_Union</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">)))</span> <span class=\"n\">x</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">glue_eq</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"err\">⋃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">heq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">s</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">j</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">glue</span> <span class=\"n\">h</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">j</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"bp\">λ</span> <span class=\"n\">j</span> <span class=\"n\">hj</span><span class=\"o\">,</span>\n  <span class=\"n\">heq</span> <span class=\"n\">j</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"bp\">⟨</span><span class=\"n\">hj</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec2</span> <span class=\"bp\">_</span> <span class=\"n\">hq</span>\n</pre></div>\n\n\n<p>there! surely this looks sane now.</p>",
        "id": 167239460,
        "sender_full_name": "Jean Lo",
        "timestamp": 1559602291
    },
    {
        "content": "<p>and I guess actually proving the lemma is some exercise in fiddling around with <code>classical.some_spec</code>? will go try and do that.</p>\n<p>(...and done, i guess.)</p>",
        "id": 167239685,
        "sender_full_name": "Jean Lo",
        "timestamp": 1559602459
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132889\">@Jean Lo</span> You could go on to show that the union is the colimit...</p>",
        "id": 167261615,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559629784
    },
    {
        "content": "<p>I'm really excited about this stuff! Once we know what the correct picture is for gluing ordinary functions, I suggest we look into two things:</p>\n<p>1. Gluing of continuous functions<br>\n2. Extract a useful/informed formal definition of the sheaf condition.</p>",
        "id": 167262563,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559630728
    },
    {
        "content": "<p>It did start off with trying to glue continuous functions, actually - <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> has proven the pasting lemma(s) in <a href=\"https://github.com/leanprover-community/mathlib/issues/1110\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/issues/1110\">#1110</a>, and I'm trying to do this so that I can construct some continuous functions piecewise.</p>",
        "id": 167263901,
        "sender_full_name": "Jean Lo",
        "timestamp": 1559631829
    },
    {
        "content": "<p>actually showing that it's the colimit sounds fun, but I also have no idea how easy/hard that would be since I admittedly have never looked at the category theory in mathlib.</p>\n<p>I spent some more time yesterday finishing a proof that the glued function is unique (which I guess could be superceded by colimit arguments if there comes a proof for that?) and also versions for the different ways of doing unions in Lean. Is this stuff useful enough to other people be worth tossing in a PR? maybe appended to one of the files in <code>data/set</code> or something?</p>",
        "id": 167264442,
        "sender_full_name": "Jean Lo",
        "timestamp": 1559632360
    },
    {
        "content": "<p>I certainly think that it will be quite useful</p>",
        "id": 167265056,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559633029
    },
    {
        "content": "<p>It shouldn't be too hard to prove its a colimit. It would be a nice test case (-;</p>",
        "id": 167265113,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559633052
    },
    {
        "content": "<p>The code now exists on the <code>gluing-functions</code> branch: <a href=\"https://github.com/leanprover-community/mathlib/blob/gluing-functions/src/data/set/glue.lean\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/gluing-functions/src/data/set/glue.lean\">https://github.com/leanprover-community/mathlib/blob/gluing-functions/src/data/set/glue.lean</a></p>\n<p>Not PR'd yet because I'd like to ask for some thoughts:</p>\n<ul>\n<li>\n<p>I've been asking <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> earlier about use cases, and what the definitions should actually <em>be</em>. Currently to invoke <code>glue_on_Union</code> I'd need to provide a proof that the family of sets actually cover <code>univ</code> for the source type, but ideally I'd want to do gluing even without that hypothesis (as <code>glue_on_union</code> currently does for the union of just two sets.) Would it be a good idea to</p>\n<ul>\n<li>\n<p>have <code>glue_on_Union</code> instead return from a subtype, and maybe provide some separate way of getting back a function from the original type given an additional hypothesis? or</p>\n</li>\n<li>\n<p>have some a separate definition that doesn't require the covering hypothesis, but instead a proof/instance that one of the relevant types are nonempty?</p>\n</li>\n</ul>\n</li>\n<li>\n<p>also, should these definitions/results actually belong under some existing file and/or under the <code>set</code> or <code>function</code> namespaces?</p>\n</li>\n</ul>",
        "id": 167296137,
        "sender_full_name": "Jean Lo",
        "timestamp": 1559656713
    },
    {
        "content": "<p>Another possible approach is to use <code>pfun</code> and glue partial functions to a partial function, and prove that the domain of the resulting function is the union of the original domains</p>",
        "id": 167296887,
        "sender_full_name": "Reid Barton",
        "timestamp": 1559657145
    },
    {
        "content": "<p>I would recommend testing out the design in some application</p>",
        "id": 167297251,
        "sender_full_name": "Reid Barton",
        "timestamp": 1559657304
    },
    {
        "content": "<p>ooh, using <code>roption</code> stuff sounds like it might end up cleaner. It might even give me much of what I wanted with the subtype stuff, via <code>as_subtype</code> and friends. I think I'll have a go at implementing that and see how it handles in practice. Thanks for the pointers!</p>",
        "id": 167317601,
        "sender_full_name": "Jean Lo",
        "timestamp": 1559669720
    },
    {
        "content": "<p>wrote down the definition using <code>roption</code>, I like how tidy it looks:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">pfun</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">pfun</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">glue</span> <span class=\"o\">(</span><span class=\"n\">f_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→.</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→.</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">⟨∃</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">dom</span> <span class=\"o\">(</span><span class=\"n\">f_</span> <span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"bp\">λ</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f_</span> <span class=\"bp\">_</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"o\">(</span><span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span> <span class=\"n\">ha</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">glue_dom_eq_Union</span> <span class=\"o\">{</span><span class=\"n\">f_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→.</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">dom</span> <span class=\"o\">(</span><span class=\"n\">glue</span> <span class=\"n\">f_</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"err\">⋃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">dom</span> <span class=\"o\">(</span><span class=\"n\">f_</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">mem_Union</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">iff</span><span class=\"bp\">.</span><span class=\"n\">rfl</span> <span class=\"o\">}</span>\n</pre></div>\n\n\n<p>I'm less sure about the following theorem statement though:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">glue_eq</span> <span class=\"o\">{</span><span class=\"n\">f_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→.</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">i₁</span> <span class=\"n\">i₂</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f_</span> <span class=\"n\">i₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fn</span> <span class=\"n\">a</span> <span class=\"n\">h₁</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">f_</span> <span class=\"n\">i₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fn</span> <span class=\"n\">a</span> <span class=\"n\">h₂</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">dom</span> <span class=\"o\">(</span><span class=\"n\">f_</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">glue</span> <span class=\"n\">f_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fn</span> <span class=\"n\">x</span> <span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"bp\">⟩</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">f_</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fn</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"o\">:=</span>\n  <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>apart from being a little verbose and suspiciously non-idiomatic, I'm not entirely sure it actually says what I want. What would be the right way of stating this result?</p>\n<p>I'm using some code for paths and homotopies as a test case, and in some cases I found that I'd still want to glue (plain) functions together without worrying about this restriction stuff. I'm currently thinking about appending the lemmas about gluing partial functions to <code>pfun.lean</code>, and having helper definitions available for some plain-function cases in the <code>function</code> namespace or something.</p>",
        "id": 167329335,
        "sender_full_name": "Jean Lo",
        "timestamp": 1559677246
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">glue_eq</span> <span class=\"o\">{</span><span class=\"n\">f_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→.</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">i₁</span> <span class=\"n\">i₂</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f_</span> <span class=\"n\">i₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fn</span> <span class=\"n\">a</span> <span class=\"n\">h₁</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">f_</span> <span class=\"n\">i₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fn</span> <span class=\"n\">a</span> <span class=\"n\">h₂</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">dom</span> <span class=\"o\">(</span><span class=\"n\">f_</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">glue</span> <span class=\"n\">f_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fn</span> <span class=\"n\">x</span> <span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"bp\">⟩</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">f_</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fn</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"o\">:=</span>\n<span class=\"n\">h</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n</pre></div>",
        "id": 167339949,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559686340
    },
    {
        "content": "<p>I am not the person to talk to about idiomatic Lean but your theorem looks to me like it says what you want it to say.</p>",
        "id": 167339981,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559686389
    },
    {
        "content": "<p>Is that the proof? That was easy. Should we do the funny topology on <code>roption</code> idea, so if all the sets are open the function returnin roption is continuous iff the subtype function is continuous.</p>",
        "id": 167340179,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1559686621
    },
    {
        "content": "<p>Yes, that proof works for me. It was discovered like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">glue</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">h</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n  <span class=\"c1\">-- done?!</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>I thought the discussion about the topology on <code>roption</code> ended up undecided, with the issue being that Reid suggested several functors it could represent and we didn't know the best one.</p>",
        "id": 167340564,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559687058
    },
    {
        "content": "<p>I would say this is not idiomatic, in that you should avoid talking about <code>fn</code> or <code>get</code> if you can avoid it, in favor of the <code>mem</code> relation. Here is a theorem you can prove about the function value without the equality constraint:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">glue_mem</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→.</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">dom</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">glue</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n</pre></div>",
        "id": 167340721,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559687245
    },
    {
        "content": "<p>and with the equality constraint:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">glue_eq_mem</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→.</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">i&#39;</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">b&#39;</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b&#39;</span> <span class=\"err\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i&#39;</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b&#39;</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">glue</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n</pre></div>",
        "id": 167340841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559687389
    },
    {
        "content": "<p>I've always found the <code>mem</code> relation counterintuitive... but I guess I'll get used to it.</p>",
        "id": 167357063,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559708506
    },
    {
        "content": "<p>/me goes of to refactor some of his code</p>",
        "id": 167357067,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559708517
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">glue_eq_mem</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→.</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">i&#39;</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">b&#39;</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b&#39;</span> <span class=\"err\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i&#39;</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b&#39;</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">glue</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">ha</span> <span class=\"k\">with</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h1</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">H</span> <span class=\"bp\">_</span> <span class=\"n\">i</span> <span class=\"n\">a</span> <span class=\"bp\">_</span> <span class=\"n\">b</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 167364928,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559720403
    },
    {
        "content": "<p><code>  exact H _ _ _ _ _ ⟨_, rfl⟩ ⟨h1, h2⟩,</code> also works</p>",
        "id": 167364968,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559720449
    },
    {
        "content": "<p>oh, nice. I feel like the fact that the statements &amp; proofs are so much shorter is a sign that this is an appropriate way to formalise these things.</p>\n<p>Another idiom question: in <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> 's theorem statements, <code>glue_mem</code> asks for an existence statement <code>ha : ∃ i, a ∈ dom (f i)</code>, but <code>glue_eq_mem</code> wants the user to specify <em>which</em> <code>i</code> has <code>a</code> in the domain. What is the reason for this?</p>\n<p>About the <code>roption</code> topology thing: the  lemmas from the topology library that are currently relevant to the stuff I'm doing phrase things in terms of functions from subtypes, which I think will work pretty well with the code for gluing in this thread. I should go construct some concrete piecewise functions to see if anything turns out to be unexpectedly painful.</p>",
        "id": 167374538,
        "sender_full_name": "Jean Lo",
        "timestamp": 1559729512
    },
    {
        "content": "<p>Usually we don't put existence statements in the hypotheses, because it's easier to \"uncurry\" them as in <code>glue_eq_mem</code>. But I thought it might be easier to not get confused in <code>glue_mem</code> since the <code>i</code> in the assumption is not the same as the <code>i</code> in the conclusion. In <code>glue_eq_mem</code> there is only one <code>i</code></p>",
        "id": 167382567,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559737395
    },
    {
        "content": "<p>plus, that composite assumption can also be written a few other ways, like <code>a \\in dom (glue f)</code></p>",
        "id": 167382652,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559737445
    },
    {
        "content": "<p>I'm not happy with Kevin's proof for essentially the same reason - it's unfolding all the abstractions and proving stuff on the base representation. You should be able to prove <code>glue_eq_mem</code> using <code>glue_mem</code></p>",
        "id": 167382779,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559737551
    },
    {
        "content": "<p>good point; i did just spend a few minutes being confused about the <code>i</code>. That the composite assumption just says <code>a \\in dom (glue f)</code> means this proof is many <code>rfl</code>'s:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">glue_mem</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→.</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">dom</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">glue</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n</pre></div>",
        "id": 167383262,
        "sender_full_name": "Jean Lo",
        "timestamp": 1559737927
    },
    {
        "content": "<p>tried to write a nice-looking proof of <code>glue_eq_mem</code> using <code>glue_mem</code>, but I think I still ended up unfolding too many terms — having to spend two lines pulling <code>ha_w</code> from <code>ha</code> looks particularly upsetting:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">glue_eq_mem</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→.</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">i&#39;</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">b&#39;</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b&#39;</span> <span class=\"err\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i&#39;</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b&#39;</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">glue</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"o\">(</span><span class=\"n\">glue_mem</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">hi&#39;</span><span class=\"o\">,</span> <span class=\"n\">hb&#39;</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">hi&#39;</span> <span class=\"n\">ha</span><span class=\"o\">)</span> <span class=\"bp\">▸</span> <span class=\"n\">hb&#39;</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">ha_w</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 167385521,
        "sender_full_name": "Jean Lo",
        "timestamp": 1559739649
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">glue_eq_mem</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→.</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{{</span><span class=\"n\">i</span> <span class=\"n\">i&#39;</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">b&#39;</span><span class=\"o\">}},</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b&#39;</span> <span class=\"err\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i&#39;</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b&#39;</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">glue</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"bp\">⟨</span><span class=\"n\">i&#39;</span><span class=\"o\">,</span> <span class=\"n\">b&#39;</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">glue_mem</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">mem_dom</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"bp\">⟩⟩</span> <span class=\"k\">in</span>\n<span class=\"n\">H</span> <span class=\"n\">h₁</span> <span class=\"n\">ha</span> <span class=\"bp\">▸</span> <span class=\"n\">h₂</span>\n</pre></div>",
        "id": 167396813,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559746438
    },
    {
        "content": "<p>Nice! thanks for all the examples, it really helps with me trying to understand the reasoning behind how <code>pfun</code> works.</p>\n<p><del>some context from the topology stuff I'm trying to write: I guess an immediate goal for me is to be able to do things like (the pasting lemma, but stated with partial functions, with their domains being the closed cover.)</del></p>\n<p>realised that I was being a goof: <code>pcontinuous</code> doesn't mean what I thought it means — it checks continuity with respect to the topology on <code>α</code>, not the subspace topology on its domain! so the domains of a <code>pcontinuous</code> function are always open and that statement of the lemma made no sense.</p>",
        "id": 167400215,
        "sender_full_name": "Jean Lo",
        "timestamp": 1559748420
    },
    {
        "content": "<p>Meanwhile, some more problems: I felt like gluing <em>two</em> functions is a special case worth having separate statements for. I think these are okay:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">glue₂</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→.</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→.</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→.</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"n\">glue</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">cond</span> <span class=\"n\">b</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span><span class=\"o\">)</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">f₁</span> <span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→.</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">glue₂_dom_eq_union</span> <span class=\"o\">:</span> <span class=\"n\">dom</span> <span class=\"o\">(</span><span class=\"n\">glue₂</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">dom</span> <span class=\"n\">f₁</span> <span class=\"err\">∪</span> <span class=\"n\">dom</span> <span class=\"n\">f₂</span> <span class=\"o\">:=</span>\n<span class=\"k\">have</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">cond</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">dom</span> <span class=\"n\">f₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dom</span> <span class=\"n\">f₂</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">dom</span> <span class=\"o\">(</span><span class=\"n\">cond</span> <span class=\"n\">b</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span><span class=\"o\">)),</span> <span class=\"k\">from</span>\n  <span class=\"n\">funext</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">cases</span> <span class=\"n\">b</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">bool</span><span class=\"bp\">.</span><span class=\"n\">cond_tt</span><span class=\"o\">,</span> <span class=\"n\">bool</span><span class=\"bp\">.</span><span class=\"n\">cond_ff</span><span class=\"o\">],</span>\n<span class=\"k\">by</span> <span class=\"o\">{</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">union_eq_Union</span><span class=\"o\">,</span> <span class=\"n\">this</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">glue_dom_eq_Union</span> <span class=\"o\">}</span>\n</pre></div>\n\n\n<p>(I couldn't get Lean to figure out the lambdas without the <code>have</code>s, but that's, like, two lines, so it doesn't bother me that much yet.)</p>\n<p>but I can't seem to find a pretty way of doing the following proof:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">glue₂_eq_mem_left</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">b&#39;</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">f₁</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b&#39;</span> <span class=\"err\">∈</span> <span class=\"n\">f₂</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b&#39;</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">f₁</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">glue₂</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">cond</span> <span class=\"n\">b</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span> <span class=\"k\">in</span>\n<span class=\"k\">have</span> <span class=\"n\">hf₁</span> <span class=\"o\">:</span> <span class=\"n\">f₁</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">tt</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">bool</span><span class=\"bp\">.</span><span class=\"n\">cond_tt</span> <span class=\"bp\">_</span> <span class=\"n\">f₁</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">hf₂</span> <span class=\"o\">:</span> <span class=\"n\">f₂</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">bool</span><span class=\"bp\">.</span><span class=\"n\">cond_tt</span> <span class=\"bp\">_</span> <span class=\"n\">f₂</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">H&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">i&#39;</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">b&#39;</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b&#39;</span> <span class=\"err\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i&#39;</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b&#39;</span><span class=\"o\">,</span> <span class=\"k\">from</span>\n<span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">i&#39;</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">b&#39;</span> <span class=\"bp\">⟨</span><span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">hi&#39;</span><span class=\"o\">,</span> <span class=\"n\">hb&#39;</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hf₁</span><span class=\"o\">,</span> <span class=\"n\">hf₂</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- cases hell</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">f</span> <span class=\"n\">tt</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rwa</span> <span class=\"err\">←</span><span class=\"n\">hf₁</span><span class=\"o\">,</span>\n<span class=\"n\">glue_eq_mem</span> <span class=\"n\">H&#39;</span> <span class=\"n\">h₁</span>\n</pre></div>\n\n\n<p>This makes me a little sad. It'd be easier if  <code>glue₂</code> had been defined with some sort of <code>ite</code> instead of <code>glue</code>-ing functions indexed by <code>bool</code>, but that feels iffy.</p>",
        "id": 167436434,
        "sender_full_name": "Jean Lo",
        "timestamp": 1559774905
    }
]
[
    {
        "content": "<p>Hey everybody,</p>\n<p>I am trying to prove a basic algebra homework. If every element of a group (actually not necessarily finite, but let's forget about that) has order 2 the group is commutative. Here is my code snippet:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory</span><span class=\"bp\">.</span><span class=\"n\">order_of_element</span>\n\n<span class=\"kn\">variable</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span><span class=\"bp\">=</span><span class=\"n\">y</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">b</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">o</span> <span class=\"o\">:=</span> <span class=\"n\">mul_left_inj</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">o</span> <span class=\"k\">with</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"o\">(</span><span class=\"n\">mul_right_inj</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mul_one</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">mul_assoc</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">order_of</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">comm_group</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intro</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">mul_comm</span> <span class=\"o\">:</span> <span class=\"n\">comm_group</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">mul_comm</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>The lemma T type checks (ok it might not be pretty but it works). But I wanted to rewrite it in a way that looks more \"native\" (how you would find it on a exercise sheet). And I tried theorem U but somehow I don't really get the type class comm_group (or type classes in general). How do you repair this?</p>\n<p>Thanks for your help!</p>",
        "id": 181731847,
        "sender_full_name": "yuppie",
        "timestamp": 1574544185
    },
    {
        "content": "<p>Here is what I would do, I shortened <code>T</code> a bit by using a new lemma fixed the statement of <code>U</code> and try to explain typeclasses a little, hope it helps!</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- this is a useful lemma, it is used 3 times even in the on paper proof</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">W</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"err\">^</span><span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"o\">((</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">⁻¹</span><span class=\"o\">))</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"c1\">-- multiply by x⁻¹</span>\n    <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">pow_two</span><span class=\"o\">,</span> <span class=\"n\">inv_mul_cancel_left</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"err\">^</span><span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">W</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"c1\">-- our lemma applies here call it `this`</span>\n  <span class=\"c1\">-- instead of using this we can just write W (h (blah)) explicitly everywhere if we want</span>\n  <span class=\"k\">have</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">),</span>\n  <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">mul_inv_rev</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">this</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">this</span> <span class=\"n\">y</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"c1\">-- (a*b)⁻¹ = b⁻¹ *a⁻¹ and our lemma twice</span>\n<span class=\"kn\">end</span>\n\n<span class=\"c1\">-- the original formulation order_of x = 2 is bad, the order of 1 is always 1</span>\n<span class=\"c1\">-- so no such groups existed! instead we want the order to be divide 2</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">Q</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">order_of</span> <span class=\"n\">x</span> <span class=\"err\">∣</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"err\">^</span><span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h_1</span><span class=\"o\">,</span> <span class=\"n\">pow_mul</span><span class=\"o\">,</span> <span class=\"n\">pow_order_of_eq_one</span><span class=\"o\">,</span> <span class=\"n\">one_pow</span><span class=\"o\">],</span> <span class=\"c1\">-- use whatever divisibility we have</span>\n<span class=\"kn\">end</span>\n\n<span class=\"c1\">-- to add a typeclass for α we define an instance of it</span>\n<span class=\"c1\">-- in fact to give a comm_group we have to give the group structure</span>\n<span class=\"c1\">-- and the statement that multiplication commutes, so we assume a given group structure</span>\n<span class=\"c1\">-- [group α] like normal, but we name it g [g : group α], so we can refer to it</span>\n<span class=\"c1\">-- this is the last line ..g it says &quot;use the group structure coming from g&quot;</span>\n<span class=\"c1\">-- so we just have to prove commutativity by combining our lemmas</span>\n<span class=\"kn\">instance</span> <span class=\"n\">order_two_comm_group</span> <span class=\"o\">[</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">order_of</span> <span class=\"n\">x</span> <span class=\"err\">∣</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">comm_group</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">mul_comm</span> <span class=\"o\">:=</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"n\">h</span><span class=\"o\">),</span>\n  <span class=\"bp\">..</span><span class=\"n\">g</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 181733857,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1574548046
    },
    {
        "content": "<p>Hey, thanks for the answer!</p>\n<p>It works like a charm but I cannot find any documentation about this <code>..g</code> syntax. Is it syntactic sugar for something else and has an alternative name? Moreover when I delete the last line</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">..</span><span class=\"n\">g</span>\n</pre></div>\n\n\n<p>I get the following error message:</p>\n<div class=\"codehilite\"><pre><span></span>/home/double-curly.lean:36:0: error: invalid structure value { ... }, field &#39;mul&#39; was not provided\n/home/double-curly.lean:36:0: error: invalid structure value { ... }, field &#39;mul_assoc&#39; was not provided\n/home/double-curly.lean:36:0: error: invalid structure value { ... }, field &#39;one&#39; was not provided\n/home/double-curly.lean:36:0: error: invalid structure value { ... }, field &#39;one_mul&#39; was not provided\n/home/double-curly.lean:36:0: error: invalid structure value { ... }, field &#39;mul_one&#39; was not provided\n/home/double-curly.lean:36:0: error: invalid structure value { ... }, field &#39;inv&#39; was not provided\n/home/double-curly.lean:36:0: error: invalid structure value { ... }, field &#39;mul_left_inv&#39; was not provided\n/home/double-curly.lean:37:14: error: type mismatch at field &#39;mul_comm&#39;\n  T (Q h)\nhas type\n  ∀ (x y : α), x * y = y * x\nbut is expected to have type\n  ∀ (a b : α), a * b = b * a\n</pre></div>\n\n\n<p>The last two expressions - don't they have the same type?</p>",
        "id": 181996889,
        "sender_full_name": "yuppie",
        "timestamp": 1574840862
    },
    {
        "content": "<p>About <code>..g</code>: It roughly means \"for fields that I didn't bother to tell you, just copy them from <code>g</code>\"</p>",
        "id": 181996950,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1574840936
    },
    {
        "content": "<p>That's why you get all the \"field <code>bla</code> not provided\" errors when you delete <code>..g</code></p>",
        "id": 181996963,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1574840960
    },
    {
        "content": "<p>I thought that it roughly means that. But do you know where this is explained in more detail? What about the error message complaining about the different naming of variables? Why does that pop up?</p>",
        "id": 181998601,
        "sender_full_name": "yuppie",
        "timestamp": 1574842990
    },
    {
        "content": "<p>No, I've never read the documentation... so I can't help you there.</p>",
        "id": 181998672,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1574843061
    },
    {
        "content": "<p>The different variable names shouldn't matter. It's likely something else that's wrong under the hood. I agree that the second error is confusing and unhelpful</p>",
        "id": 181998683,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1574843099
    },
    {
        "content": "<p>Oh ok, thanks!</p>",
        "id": 181998784,
        "sender_full_name": "yuppie",
        "timestamp": 1574843223
    },
    {
        "content": "<p>Where did you look for documentation? It's explained in the chapter of TPIL about structure: <a href=\"https://leanprover.github.io/theorem_proving_in_lean/structures_and_records.html#objects\" target=\"_blank\" title=\"https://leanprover.github.io/theorem_proving_in_lean/structures_and_records.html#objects\">https://leanprover.github.io/theorem_proving_in_lean/structures_and_records.html#objects</a></p>",
        "id": 182000057,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1574844622
    },
    {
        "content": "<p>The confusing error message is probably because you have two multiplications on the same type.</p>",
        "id": 182000081,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1574844651
    },
    {
        "content": "<p>But it's hard to tell without code we could test.</p>",
        "id": 182000091,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1574844667
    },
    {
        "content": "<p>What the error isn't telling you is that the <code>*</code> in the first case has a type class instance that is constructed from the missing fields, but since you didn't provide the fields it put <code>sorry</code> in for the type class, while it is expecting a structure literal (which is what shows up in the \"official\" type for <code>mul_comm</code>)</p>",
        "id": 182006966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1574851273
    },
    {
        "content": "<p>Basically it is error compounding - the first few errors cause more errors down the line</p>",
        "id": 182006984,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1574851303
    },
    {
        "content": "<p>In short, \"field mul not provided\" also means \"don't take anything I say about multiplication seriously after this point\"</p>",
        "id": 182009278,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1574853297
    },
    {
        "content": "<blockquote>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- this is a useful lemma, it is used 3 times even in the on paper proof</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">W</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"err\">^</span><span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"o\">((</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">⁻¹</span><span class=\"o\">))</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"c1\">-- multiply by x⁻¹</span>\n    <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">pow_two</span><span class=\"o\">,</span> <span class=\"n\">inv_mul_cancel_left</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n</blockquote>\n<p>I'm still getting used to Lean so this is probably a stupid question, but why can I not write <code>have := congr_arg (group.mul (x⁻¹)) h</code> ?</p>\n<p>Hm, <code>has_mul.mul</code> works ...</p>",
        "id": 182049328,
        "sender_full_name": "Elvorfirilmathredia",
        "timestamp": 1574881776
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">fintype</span>\n\n<span class=\"kn\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- this is a useful lemma, it is used 3 times even in the on paper proof</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">W</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"err\">^</span><span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">⁻¹</span><span class=\"o\">))</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"err\">^</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">pow_two</span><span class=\"o\">,</span> <span class=\"n\">inv_mul_cancel_left</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>[sorry if someone else posted, I'm on the underground with sporadic reception]. <code>rw</code> works with syntactic equality not definitional equality.</p>",
        "id": 182049701,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1574882002
    }
]
[
    {
        "content": "<p>Hello,</p>\n<p>I find myself with lemmas that have many hypotheses and that directly solve the goal. I <code>apply</code> them (without passing the hypotheses) and end up with many new goals, each of which already in the context, so I do <code>repeat {assumption}</code> to close the goal. I would like to know if there is a nicer way to do that (in terms of less characters typed, for instance). A variation of the problem is when after the apply I can close the goal with <code>repeat {tauto}</code>.</p>\n<p>Here is a MWE which is a bit too silly but illustrates what I am trying to say:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">key_lemma</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">3</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">5</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n    <span class=\"n\">linarith</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">my_lemma</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n    <span class=\"n\">apply</span> <span class=\"n\">key_lemma</span><span class=\"o\">,</span> <span class=\"c1\">-- is there a tactic that does these two lines together automatically?</span>\n    <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">assumption</span><span class=\"o\">},</span> <span class=\"c1\">--</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 211917329,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1601561983
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">my_lemma</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n    <span class=\"n\">apply</span> <span class=\"n\">key_lemma</span> <span class=\"n\">h</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 211917540,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1601562060
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">my_lemma</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span>\n<span class=\"n\">key_lemma</span> <span class=\"n\">h</span> <span class=\"n\">g</span>\n</code></pre></div>",
        "id": 211917581,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1601562078
    },
    {
        "content": "<p>If you don't want to use the names, you could do <code>key_lemma ‹_› ‹_›</code></p>",
        "id": 211921179,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1601563500
    },
    {
        "content": "<p>Or <code>apply key_lemma; assumption</code></p>",
        "id": 211921867,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1601563739
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> , what you propose is exactly what I'm trying to avoid here: if key_lemma has 10 hypotheses, then I don't want to be typing the names that I have come up with before, since it makes maintenance harder and it's quite boring.</p>\n<p><span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span> this is similar to my solution and probably makes me content.  </p>\n<p>I guess that it wouldn't hurt that apply automatically checked if it can close the goal with the assumptions already in the context...</p>",
        "id": 211936970,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1601569772
    },
    {
        "content": "<p>It might make <code>apply</code> slow, and since it is used a lot, we want <code>apply</code> to be as fast as possible.<br>\nHence <code>apply foo; assumption</code> seems like the best idiom</p>",
        "id": 211937177,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1601569855
    },
    {
        "content": "<p>Yes, I was afraid that I was missing a tactic name, but fine.</p>",
        "id": 211937466,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1601569994
    },
    {
        "content": "<p>Can you give some concrete example where you really want to feed 10 hypotheses into a theorem? Normally things like type class inference and unification do a lot of the work for you.</p>",
        "id": 211943643,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1601572639
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">my_lemma</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n    <span class=\"n\">apply</span> <span class=\"n\">key_lemma</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">assumption</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">assumption</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 211943815,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1601572702
    },
    {
        "content": "<p>Here is a lemma I have proven, regarding HilbertPlane. It says given a line (implicit) and three point not on it (implicit, also), then if both B and C belong \"to the other side\" than A, then B and C are at the same side of the line.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">same_side.at_most_two_classes</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">A</span> <span class=\"bp\">∈</span> <span class=\"n\">ℓ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hB</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">B</span> <span class=\"bp\">∈</span> <span class=\"n\">ℓ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hC</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">C</span> <span class=\"bp\">∈</span> <span class=\"n\">ℓ</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">hBneqC</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">≠</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hAB</span><span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">same_side</span> <span class=\"n\">ℓ</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hAC</span><span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">same_side</span> <span class=\"n\">ℓ</span> <span class=\"n\">A</span> <span class=\"n\">C</span><span class=\"o\">):</span> <span class=\"n\">same_side</span> <span class=\"n\">ℓ</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n    <span class=\"n\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n\n<p>This gets used to the following theorem, which says that given a line then one can split its complement into two classes of points, S1 and S2.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">plane_separation</span> <span class=\"o\">(</span><span class=\"n\">ℓ</span> <span class=\"o\">:</span> <span class=\"bp\">Ω.</span><span class=\"n\">Line</span><span class=\"o\">):</span>  <span class=\"bp\">∃</span> <span class=\"n\">S1</span> <span class=\"n\">S2</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"bp\">Ω.</span><span class=\"n\">Point</span><span class=\"o\">),</span>\n        <span class=\"n\">S1</span> <span class=\"bp\">∩</span> <span class=\"n\">S2</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"bp\">∧</span> <span class=\"n\">S1</span> <span class=\"bp\">∪</span> <span class=\"n\">S2</span> <span class=\"bp\">∪</span> <span class=\"n\">ℓ</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"bp\">Ω.</span><span class=\"n\">Point</span> <span class=\"bp\">|</span> <span class=\"n\">tt</span><span class=\"o\">}</span> <span class=\"bp\">∧</span>\n        <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"bp\">Ω.</span><span class=\"n\">Point</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∉</span> <span class=\"n\">ℓ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">∉</span> <span class=\"n\">ℓ</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n            <span class=\"o\">((</span> <span class=\"n\">A</span> <span class=\"bp\">∈</span> <span class=\"n\">S1</span> <span class=\"bp\">∧</span> <span class=\"n\">B</span> <span class=\"bp\">∈</span> <span class=\"n\">S1</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∈</span> <span class=\"n\">S2</span> <span class=\"bp\">∧</span> <span class=\"n\">B</span> <span class=\"bp\">∈</span> <span class=\"n\">S2</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">#</span><span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">ℓ</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n\n<p>At some point of the proof I am at this state</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">Ω</span><span class=\"o\">:</span> <span class=\"n\">HilbertPlane</span>\n<span class=\"n\">ℓ</span><span class=\"o\">:</span> <span class=\"n\">HilbertPlane.Line</span>\n<span class=\"n\">CD</span><span class=\"o\">:</span> <span class=\"n\">HilbertPlane.Point</span>\n<span class=\"n\">hC</span><span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">∉</span> <span class=\"n\">ℓ</span>\n<span class=\"n\">hD</span><span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">∉</span> <span class=\"n\">ℓ</span>\n<span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">same_side</span> <span class=\"n\">ℓ</span> <span class=\"n\">C</span> <span class=\"n\">D</span>\n<span class=\"n\">S1</span><span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">HilbertPlane.Point</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">HilbertPlane.Point</span> <span class=\"bp\">|</span> <span class=\"n\">same_side</span> <span class=\"n\">ℓ</span> <span class=\"n\">P</span> <span class=\"n\">C</span><span class=\"o\">}</span>\n<span class=\"n\">S2</span><span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">HilbertPlane.Point</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">HilbertPlane.Point</span> <span class=\"bp\">|</span> <span class=\"n\">same_side</span> <span class=\"n\">ℓ</span> <span class=\"n\">P</span> <span class=\"n\">D</span><span class=\"o\">}</span>\n<span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">HilbertPlane.Point</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">ℓ</span>\n<span class=\"n\">hs</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">same_side</span> <span class=\"n\">ℓ</span> <span class=\"n\">C</span> <span class=\"n\">x</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">same_side</span> <span class=\"n\">ℓ</span> <span class=\"n\">x</span> <span class=\"n\">D</span>\n</code></pre></div>\n\n<p>and I prove it by</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">by_cases</span> <span class=\"n\">hxD</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">D</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">hxD</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">same_side.refl</span><span class=\"o\">,</span>\n<span class=\"n\">apply</span> <span class=\"n\">same_side.at_most_two_classes</span><span class=\"o\">,</span>\n<span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">assumption</span><span class=\"o\">},</span>\n</code></pre></div>\n\n<p>In this result this same patter occurs once more.</p>\n<p>This could use of class inference, but then I never know what kind of assumptions need to be put in this system...</p>",
        "id": 211945721,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1601573553
    },
    {
        "content": "<p>No, I don't think this should use type classes. It's just a lot of assumptions.</p>",
        "id": 211945918,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1601573636
    },
    {
        "content": "<p>Note that <code>assumption'</code> will try <code>assumption</code> on all goals.</p>",
        "id": 211946056,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1601573679
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> this seems very similar to the \";\" trick. I guess it's okay to have so much variety.</p>",
        "id": 211946282,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1601573767
    },
    {
        "content": "<p>No one has mentioned <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#solve_by_elim\">tactic#solve_by_elim</a>, which is very useful for sequences of <code>apply</code> and <code>assumption</code>.</p>",
        "id": 211990664,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601596897
    }
]
[
    {
        "content": "<p>I have a definition of a partition:</p>",
        "id": 202755739,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1593733004
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">partition</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">disjoint</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"err\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"bp\">≠</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"err\">∩</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"err\">∅</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">cover</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">A</span> <span class=\"err\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">nonempty</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">A</span> <span class=\"err\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"bp\">≠</span> <span class=\"err\">∅</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>And let's say I have a proof that if two sets in a partition share an element, it implies they're the same set.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">partition_els_eq_if_share_el&#39;</span>\n<span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">partition</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"err\">∈</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">F</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"err\">∈</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>The problem is if I use this lemma in some other proof the type inference system (elaborator?) tries to find a term of the form \"?.F\" so it searches for a partition in the context to match, but I want it to just fill with a set of sets in the context with the proofs that it is a partition also in the context. I.e. as currently written, my goal turns into this undesirable metavariable: <code>A ∈ ?m_1.F</code></p>\n<p>I can fix this by re-writing my lemma as so but it requires me to copy the definition of a partition, which is annoying. </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">partition_els_eq_if_share_el</span>\n<span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)}</span>\n<span class=\"o\">{</span><span class=\"n\">disjoint</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"err\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"bp\">≠</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"err\">∩</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"err\">∅</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">cover</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">A</span> <span class=\"err\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">A</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">nonempty</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">A</span> <span class=\"err\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"bp\">≠</span> <span class=\"err\">∅</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"err\">∈</span> <span class=\"n\">F</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span>\n</code></pre></div>\n\n\n<p>Is there another way to salvage the first, more concise lemma?</p>",
        "id": 202756092,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1593733322
    },
    {
        "content": "<p>Just make some stuff explicit in <code>partition_els_eq_if_share_el'</code></p>",
        "id": 202756162,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593733394
    },
    {
        "content": "<p>You're using <code>{ }</code> for inputs and Lean can't guess the inputs. Change some of the brackets to <code>( )</code> and supply them yourself.</p>",
        "id": 202756184,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593733421
    },
    {
        "content": "<p><code>h1</code> and <code>h2</code> should not be implicit in <code>partition_els_eq_if_share_el'</code> since they can't be inferred</p>",
        "id": 202756227,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593733436
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">partition_els_eq_if_share_el&#39;</span>\n<span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">partition</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"err\">∈</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"err\">∈</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 202756284,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593733453
    },
    {
        "content": "<p>and your problem suggests that <code>F</code> may also need to be explicit</p>",
        "id": 202756306,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593733482
    },
    {
        "content": "<p>ohh right,  that should work. I'm expecting too much of type inference. Thanks!</p>",
        "id": 202756311,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1593733490
    }
]
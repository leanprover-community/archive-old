[
    {
        "content": "<p>Hi all, I tried to start from scratch with a definition of the word metric on a group, and I'm stuck at some basics. Here is where I am now: I'm thinking of a basic object which is a group with fixed generating set</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed.group.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.free_group</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">function</span> <span class=\"n\">real</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">word_metric</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">marked_group</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"s2\">\"\"\"an S-generated group\"\"\"</span>\n<span class=\"kd\">class</span> <span class=\"n\">marked_group</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">group</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">marking</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_surjective</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"n\">marking</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">marked_group</span> <span class=\"n\">G</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">free_group_norm</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">free_group.to_word</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">marked_group_marking</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">marked_group</span> <span class=\"n\">G</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">marked_group.marking</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">group_norm</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">Inf</span> <span class=\"o\">((</span><span class=\"n\">free_group_norm</span><span class=\"o\">)</span><span class=\"bp\">''</span> <span class=\"o\">((</span><span class=\"n\">marked_group_marking</span> <span class=\"n\">G</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">g</span><span class=\"o\">}))</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">group_norm_finite</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">group_norm</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"c1\">-- say that the Inf argument is non-empty because of marked_group.is_surjective</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">group_norm_one</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">group_norm</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- etc.</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">marked_group</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">word_metric</span>\n</code></pre></div>\n<p>My basic questions, for which I hope I can get help, are:</p>\n<ul>\n<li>Why do I have to repeat the assumptions <code>[decidable_eq S]</code> in unpredictable ways?</li>\n<li>In <code>group_norm_finite</code> there is an error that Lean doesn't know how to synthesize a placeholder at <code>group_norm</code></li>\n<li>I intend to define <code>class normed_group extends group G, has_norm G, metric_space G</code> and create an instance of it from a <code>marked_group G S</code>. Does this sound reasonable?</li>\n</ul>\n<p>Many thanks in advance! Laurent</p>",
        "id": 289961580,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1658149131
    },
    {
        "content": "<p>The second <code>[decidable_eq S]</code> is needed because you introduced a new <code>S</code> in <code>`def free_group_norm</code>.</p>",
        "id": 289962146,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1658149433
    },
    {
        "content": "<p>The third one should be useless, but beware that you repeated <code>[group G]</code>, so now you have <em>two</em> group structure on <code>G</code>, and this surely not what you want.</p>",
        "id": 289962272,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1658149480
    },
    {
        "content": "<p>Also, you may want to use <code>finite S</code> instead of <code>fintype S</code> (and you need this only once).</p>",
        "id": 289962367,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1658149539
    },
    {
        "content": "<p>OK, thanks! I cleaned up a bit the code with these suggestions, and edited my first message. (sorry if the beginning of the conversation now looks strange).</p>\n<p>I forgot another question: I couldn't access the field \"marking\" in the <code>marked_group G</code> from <code>group_norm</code>, so I resorted to writing the lemma <code>marked_group_marking</code> to access it. What's the correct way of doing this?</p>",
        "id": 289963813,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1658150342
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"263407\">@Laurent Bartholdi</span> <span class=\"user-mention\" data-user-id=\"466727\">@Jim Fowler</span> Just making sure you are aware of each others' work here!</p>",
        "id": 290018835,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1658176190
    },
    {
        "content": "<p>Yes, I have some code posted at <a href=\"https://github.com/kisonecat/word-metric/tree/main/src\">https://github.com/kisonecat/word-metric/tree/main/src</a></p>",
        "id": 290019444,
        "sender_full_name": "Jim Fowler",
        "timestamp": 1658176478
    },
    {
        "content": "<p>I do think 'marked_group' is a better name than 'generated_group'.</p>",
        "id": 290019618,
        "sender_full_name": "Jim Fowler",
        "timestamp": 1658176565
    },
    {
        "content": "<p>Let me ping <span class=\"user-mention\" data-user-id=\"466209\">@Georgi Kocharyan</span> here too.</p>",
        "id": 290022622,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658178246
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"263407\">@Laurent Bartholdi</span> </p>\n<blockquote>\n<p>In group_norm_finite there is an error that Lean doesn't know how to synthesize a placeholder at group_norm</p>\n</blockquote>\n<p>This is because the statement doesn't mention <code>S</code> at all, so Lean doesn't know what to fill in for the <code>S</code> in <code>group_norm</code>. Making <code>S</code> explicit in <code>group_norm</code> helps; if you don't want to write <code>S</code> all the time you should probably include it as a field in the structure <code>marked_group</code>.</p>\n<p>If you don't choose to include <code>S</code> inside the structure, then it seems necessary to define <code>marked_group_marking</code> as you did, because <code>S</code> is implicit in <code>marked_group.marking</code>. If you change the inverse image <code>⁻¹'</code> by an explicit expression as I did above, you can make <code>G</code> implicit in <code>marked_group_marking</code> (btw, it should be a def not a lemma).</p>\n<p>Note that <code>⊤</code> still doesn't work since <code>ℕ</code> doesn't <code>has_top</code>. It seems nicer to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/well_founded.min\">docs#well_founded.min</a> to define <code>group_norm</code> (see below).</p>\n<p>Another comment: since your <code>marked_group</code> extends <code>group</code>, you should probably require <code>marking</code> to be a homomorphism.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed.group.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.free_group</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">function</span> <span class=\"n\">real</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">word_metric</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">marked_group</span>\n\n<span class=\"c1\">-- an S-generated group</span>\n<span class=\"kd\">class</span> <span class=\"n\">marked_group</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">group</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">marking</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_surjective</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"n\">marking</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">marked_group</span> <span class=\"n\">G</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">marked_group_marking</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">marked_group.marking</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">free_group_norm</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">free_group.to_word</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">group_norm</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">nat.lt.is_well_order.wf.min</span>\n  <span class=\"o\">(</span><span class=\"n\">free_group_norm</span> <span class=\"bp\">''</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">marked_group_marking</span> <span class=\"n\">S</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span><span class=\"o\">})</span>\n  <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">set.nonempty.image</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">marked_group.is_surjective</span> <span class=\"n\">g</span> <span class=\"o\">})</span>\n<span class=\"c1\">-- Inf (free_group_norm '' {x | marked_group_marking S x = g})</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">group_norm</span> <span class=\"n\">S</span> <span class=\"n\">x</span> <span class=\"c1\">-- now works</span>\n</code></pre></div>",
        "id": 290037883,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1658188125
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt/near/290022622\">said</a>:</p>\n<blockquote>\n<p>Let me ping <span class=\"user-mention silent\" data-user-id=\"466209\">Georgi Kocharyan</span> here too.</p>\n</blockquote>\n<p>thanks - my current attempt for the word metric and Cayley graphs is at <a href=\"https://github.com/GregorSamsa42/svarc-milnor/blob/main/src/cayleygraphs.lean\">https://github.com/GregorSamsa42/svarc-milnor/blob/main/src/cayleygraphs.lean</a></p>",
        "id": 290060300,
        "sender_full_name": "Georgi Kocharyan",
        "timestamp": 1658213307
    },
    {
        "content": "<p><code>marked_group</code> doesn't look like it can safely extend <code>group</code> to me</p>",
        "id": 290061834,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658214726
    },
    {
        "content": "<p>Although maybe it's safe if you change <code>S : Type*</code> to <code>S : out_param Type*</code></p>",
        "id": 290062125,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658214993
    },
    {
        "content": "<p>Thanks to all!<br>\n<span class=\"user-mention\" data-user-id=\"466727\">@Jim Fowler</span> , I see you're done a lot, and it will be very inspiring. However, I think that the notion of \"marked group\" is important enough to be in Lean, not just for the word metric. See e.g. <a href=\"http://math.univ-lyon1.fr/~altinel/ModelsGroupsArx/benli_gm2015.pdf\">http://math.univ-lyon1.fr/~altinel/ModelsGroupsArx/benli_gm2015.pdf</a> for some slides. <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> , it looks like a very nice shortcut to use simple_graph.dist. Are you working with Clara Löh on this? I see her name in a header. The Svarc-Milnor theorem is a great goal, it was on my todo list but I'll cross it out now :)</p>\n<p>I would nevertheless like the code to be a bit more general. In particular, separate the notions of marked_group and normed_group; and within normed_group, have word_normed_group in which one specifies a (positive real) length for each generator. That will make induction harder, since we'll have a well-founded set of real lengths to work with.</p>\n<p>WRT the first class, my heart goes now more in the direction of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">marked_group</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">group</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">decidable</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">marking</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"n\">S</span> <span class=\"bp\">→*</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_surjective</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"n\">marking</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Comments as always appreciated!</p>",
        "id": 290063712,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1658216325
    },
    {
        "content": "<p>If you have real numbers then the minimum may not be achieved, e.g. if G is the additive group of ℚ, S is {1/n | n ∈ ℕ+}, and 1/n is assigned length 1/n^2. But if S is finite then there's only a finite number of elements in free_group S of bounded norm.</p>",
        "id": 290064473,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1658216906
    },
    {
        "content": "<p>I'd also perhaps suggest:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">marked_group</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">marking</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"n\">S</span> <span class=\"bp\">→*</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_surjective</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"n\">marking</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and then you don't need the <code>decidable</code> instance as a field</p>",
        "id": 290073461,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658222782
    },
    {
        "content": "<p>This has the bonus of working for <code>comm_group</code> too, in case that's relevant'; with your spelling, you can't talk about marked commutative groups.</p>",
        "id": 290073526,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658222822
    },
    {
        "content": "<p>If you want to register your group as a metric space (where the distance depends on <code>S</code>), you will need to embrace the type synonym trick. Instead of a class, define a structure <code>marking S G</code> as you did. And then given a group <code>G</code> and a marking <code>m</code>, define a new type <code>marked_group m G := G</code>. On this new type, you can register the same group structure as on <code>G</code>, but you can also register a distance as <code>m</code> is now available to the system when you consider <code>x y : marked_group m G</code>.</p>",
        "id": 290077956,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1658225621
    },
    {
        "content": "<p>The <code>out_param</code> idea I don't like so much because often we discuss several generating sets on a given group.</p>",
        "id": 290078064,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1658225682
    },
    {
        "content": "<p>OK! <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> , I followed your suggestion, so the beginning looks like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">marked_group</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">marking</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"n\">S</span> <span class=\"bp\">→*</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_surjective</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"n\">marking</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">free_group_norm</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">free_group.to_word</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">MG</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">MG</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">marked_group</span> <span class=\"n\">MG</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">group_norm</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">MG</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">nat.lt.is_well_order.wf.min</span>\n  <span class=\"o\">(</span><span class=\"n\">free_group_norm</span> <span class=\"bp\">''</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">marked_group.marking</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span><span class=\"o\">})</span>\n  <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">set.nonempty.image</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">marked_group.is_surjective</span> <span class=\"n\">g</span> <span class=\"o\">})</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">group_norm_one</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">MG</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">group_norm</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Is this what you had in mind? I don't seem to be able to get away without repeating the assertions <code>[decidable_eq S]</code> everywhere, otherwise Lean doesn't know anything about <code>S</code>.</p>\n<p>Extra question: what is the interface for <code>nat.lt.is_well_order.wf.min</code>? All I want is to extract an element representing the minimum, and provide witnesses that upper-bound the minimum.</p>\n<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> , I just saw your message while typing. Do you think it's then best to keep it the way I did it before, with an explicit <code>S</code> field? (and of course your splitting into struct and type</p>",
        "id": 290078251,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1658225804
    },
    {
        "content": "<p>IIrc <code>nat.find</code> was a good alternative to <code>….wf.min</code> in the case of naturals?<br>\n<a href=\"https://leanprover-community.github.io/mathlib_docs/init/data/nat/lemmas.html#nat.find\">See here</a>.</p>",
        "id": 290078753,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658226123
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"263407\">Laurent Bartholdi</span> <a href=\"#narrow/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt/near/290063712\">said</a>:</p>\n<blockquote>\n<p>Are you working with Clara Löh on this? I see her name in a header.</p>\n</blockquote>\n<p>No, but Georgi is! and I'm casually helping Georgi out.</p>",
        "id": 290079175,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658226384
    },
    {
        "content": "<p>By the way, at the risk of thread-jacking, would it make sense to set up a space to coordinate the progress on formalizing GGT? I admit I haven't made nearly as much progress as expected until now, but would like to get back to it, and would love to have the possibility to work outside of my bubble and discuss formalization strategies and goals in a kind of communal way.</p>",
        "id": 290079915,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658226917
    },
    {
        "content": "<p>I am not quite the person to ask about this, but I strongly suggest you do! The most effective way to do this is to work on a common branch of mathlib (and create a new directory in there to keep the new files close to each other) or to create a new repository with CI (which is arguably much more work) + have either a Discord group chat, a Zulip topic or a Zulip stream.</p>",
        "id": 290080451,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658227259
    },
    {
        "content": "<p>The <code>out_param</code> should mean that lean works out what <code>S</code> is</p>",
        "id": 290082980,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658228939
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt/near/290078064\">said</a>:</p>\n<blockquote>\n<p>The <code>out_param</code> idea I don't like so much because often we discuss several generating sets on a given group.</p>\n</blockquote>\n<p>If my understanding is correct<code>out_param</code> doesn't really require that the generating set be unique, it just means that you can leave it unspecified and lean will find a default.</p>",
        "id": 290083137,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658229019
    },
    {
        "content": "<p>The rule is that for a given choice of non-instance-implicit non-<code>out_param</code> arguments, you can't have two instances that are not equal. (Instance-implicit parameters are the ones in [square brackets].) Equality of instances means:</p>\n<ul>\n<li>the fields of the underlying structure are definitionally equal, up to a reducibility somewhere between reducible and semireducible (I believe the correct reducibility depends on the specific situation)</li>\n<li>all values for <code>out_param</code> and instance-implicit parameters are similarly definitionally equal</li>\n</ul>",
        "id": 290083673,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1658229358
    },
    {
        "content": "<p>If you break this rule, you will get diamond errors (unless you are very careful with what you do).</p>",
        "id": 290083754,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1658229386
    },
    {
        "content": "<p>Equality doesn't even make sense to state though if the out_params arguments (indices) are different</p>",
        "id": 290086992,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658231327
    },
    {
        "content": "<p><code>out_param</code> stuff should definitely be unique, yes, otherwise you run into diamonds.</p>\n<p>A tentative scheme avoiding out_params would be the following:</p>\n<ul>\n<li>First, work with normed groups, and prove whatever you like here. Possibly adding new typeclass assumptions that say that the distance is proper or hyperbolic or whatever.</li>\n<li>Then, to construct instances of such normed groups, do it on type synonyms. For instance, given two types <code>S</code> and <code>G</code> with <code>[group G]</code>, define <code>marking S G</code> as the space of markings of <code>G</code> parameterized by <code>S</code>. Then, given a group <code>G</code> and a marking <code>m</code>, define a type<code>marked_group G S := G</code> as a copy of <code>G</code>, then define on it the group structure coming fro <code>G</code> (with <code>@[derive ...]</code>) and the norm associated to <code>S</code>. Then <code>marked_group G S</code> will be an instance of a normed group.</li>\n</ul>",
        "id": 290087025,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1658231347
    },
    {
        "content": "<p>If you want to have real distances, this fits perfectly well in this scheme, with another type synonym in which you will register a marking together with the length of each edge for each element of <code>S</code>.</p>",
        "id": 290087173,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1658231422
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt/near/290087025\">said</a>:</p>\n<blockquote>\n<p><code>out_param</code> stuff should definitely be unique, yes, otherwise you run into diamonds.</p>\n</blockquote>\n<p>Do you have an example in mind for what this looks like? Maybe you're right that <code>out_param</code>s aren't the right solution here, but I don't believe that diamonds (at least not in the usual sense) are possible from them</p>",
        "id": 290087619,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658231748
    },
    {
        "content": "<p>Does this count as a diamond?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fin.basic</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">artificial_example</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">o</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">ex0</span> <span class=\"o\">:</span> <span class=\"n\">artificial_example</span> <span class=\"n\">ℕ</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ex0_eq_0</span> <span class=\"o\">:</span> <span class=\"n\">artificial_example.foo</span> <span class=\"n\">ℕ</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">ex1</span> <span class=\"o\">:</span> <span class=\"n\">artificial_example</span> <span class=\"n\">ℕ</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ex0_eq_0'</span> <span class=\"o\">:</span> <span class=\"n\">artificial_example.foo</span> <span class=\"n\">ℕ</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">ex0_eq_0</span> <span class=\"c1\">-- Error: type mismatch</span>\n</code></pre></div>",
        "id": 290088721,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1658232416
    },
    {
        "content": "<p>Of course, this will work once you make <code>o</code> explicit in <code>foo</code>, but at that point you don't need the <code>out_param</code> anymore.</p>",
        "id": 290088949,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1658232544
    },
    {
        "content": "<p>Oh I see, the diamond no longer happens in the instance itself (because you can't state that any more), but the operations/projections derived from it. Thanks!</p>",
        "id": 290089001,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658232588
    },
    {
        "content": "<p>That's one way to see it indeed!</p>",
        "id": 290089097,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1658232639
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span> it'd be great to coordinate formalization efforts around GGT!</p>",
        "id": 290093635,
        "sender_full_name": "Jim Fowler",
        "timestamp": 1658235114
    },
    {
        "content": "<p>I agree with you <span class=\"user-mention silent\" data-user-id=\"263407\">Laurent Bartholdi</span> that <code>marked_group</code> is the correct notion.</p>",
        "id": 290095033,
        "sender_full_name": "Jim Fowler",
        "timestamp": 1658235736
    },
    {
        "content": "<p>OK, I guess the best place to start is by setting up a stream, but it seems you need to be an admin to do that. Am I right, <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> ? OK, started with a topic <a href=\"#narrow/stream/113488-general/topic/Geometric.20Group.20Theory.20coordination.20.3F/near/290098362\">here</a></p>",
        "id": 290095575,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658235990
    },
    {
        "content": "<p>I would suggest creating a stream only if the project starts getting big. There are only 39 public streams.</p>",
        "id": 290095707,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658236069
    },
    {
        "content": "<p>Perhaps create a ggt branch in mathlib, create a subdirectory geometric_group_theory ?</p>",
        "id": 290099072,
        "sender_full_name": "Jim Fowler",
        "timestamp": 1658237629
    },
    {
        "content": "<p>Or <code>group_theory.geometry</code>?</p>",
        "id": 290104794,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658240176
    },
    {
        "content": "<blockquote>\n<p>Extra question: what is the interface for nat.lt.is_well_order.wf.min? All I want is to extract an element representing the minimum, and provide witnesses that upper-bound the minimum.</p>\n</blockquote>\n<p>The interface you want is provided by <a href=\"https://leanprover-community.github.io/mathlib_docs/find/well_founded.min_le\">docs#well_founded.min_le</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/well_founded.min_mem\">docs#well_founded.min_mem</a>.<br>\nBut indeed <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.find\">docs#nat.find</a> is better. Thanks Rémi Bottinelli!</p>",
        "id": 290107018,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1658241047
    },
    {
        "content": "<p>OK, I just created a minuscule file at group_theory/geometric/marked_group.lean in a branch geometric-group-theory. All are welcome to play with it and modify! For now, I'm just testing whether the basic idea is sound. I'll try to incorporate the changes suggested by <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> </p>\n<p><span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span> and <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> and <span class=\"user-mention\" data-user-id=\"466727\">@Jim Fowler</span> , perhaps we can put all our ideas together in this subdirectory and sort out which approach works best?</p>\n<p>I hope I'm not doing anything untoward. Hopefully everybody has access to this branch and can make coordinated changes.</p>",
        "id": 290108880,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1658241791
    },
    {
        "content": "<p>I had some very WIP code on the ends of graphs and also a basic pull request about nets and separated sets in metric spaces <a href=\"https://github.com/leanprover-community/mathlib/pull/12010/files\">here</a>. I'm not sure either belongs to <code>group_theory/geometric</code> though?</p>",
        "id": 290114392,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658243927
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span> definitely they do!<br>\nA very nice result to formalize could be the 0-1-2-infty theorem on ends; and, perhaps even better, the new take by Yves de Cornulier that does not restrict to finitely generated groups. In essence, he considers a group G acting on a space X; the Boolean algebra of X-subsets modulo finite ones; its G-invariant subalgebra; and the Stone dual thereof. This is the space of ends of X_G, and for X=G has 0,1,2 elements or is a Cantor set. See [https://www.normalesup.org/~cornulier/spaends.pdf]<br>\nParticularly interesting would be to connect to the classical theory of ends in graph theory when the group is f.g.</p>",
        "id": 290115927,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1658244493
    },
    {
        "content": "<p>Hah, I had exactly that thing in mind (see the topic I started on General). I was thinking it might be easier to define both \"coarse\" and \"graphical\" notions of ends separately and link them later on. But that really stemmed from my failure at defining a coarse notion for which the 0-1-2-oo theorem is easily shown.<br>\nSo, it's a good question whether we should directly start with the most general result or not.</p>\n<p>By the way, it's not clear from just reading the abstract, but does Cornulier actually prove the \"generalized\" version of 0-1-2-oo ?</p>",
        "id": 290119742,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658245976
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"263407\">@Laurent Bartholdi</span> thank you for getting this going!</p>",
        "id": 290123272,
        "sender_full_name": "Jim Fowler",
        "timestamp": 1658247237
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span> I think it would be helpful to collect anything related (like ends of <em>graphs</em>) in <code>group_theory/geometric</code>.</p>",
        "id": 290124276,
        "sender_full_name": "Jim Fowler",
        "timestamp": 1658247631
    },
    {
        "content": "<p>I recall seeing some QIE definitions by Clara Löh which could also be put in this branch (or maybe quasi-isometry lives somewhere in mathlib already?).</p>",
        "id": 290124407,
        "sender_full_name": "Jim Fowler",
        "timestamp": 1658247695
    },
    {
        "content": "<p>As far as I knew, quasi-isometries weren't there yet. This one (I mean, the notion of quasi-isometry) also has lots of different definitions, and I'm not sure which one to start with first. My PR was actually headed in this direction, since some implications need to start with a maximal separated subset.</p>",
        "id": 290127256,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658248921
    },
    {
        "content": "<p>OK, it's 1am and I just managed to prove that |g|=0 iff g=1. If anyone wants to give a look to group_theory/geometric/marked_group.lean and provide golfing / structure suggestions, I'd love it!</p>",
        "id": 290172508,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1658271755
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"263407\">@Laurent Bartholdi</span> I moved some things into <code>variable</code>s and implicit arguments.</p>",
        "id": 290187650,
        "sender_full_name": "Jim Fowler",
        "timestamp": 1658284453
    },
    {
        "content": "<p>Ah, damn, I'm getting the yellow bar and vscodium crashes wnen trying to work with the <code>geometric-group-theory</code> branch. Should <code>leanproject get-cache --fallback=download-first</code>be the correct command to get the cache?</p>",
        "id": 290195780,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658295368
    },
    {
        "content": "<p>After some more work, I got to the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">to_word_inv_length</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹.</span><span class=\"n\">to_word.length</span> <span class=\"bp\">≤</span> <span class=\"n\">x.to_word.length</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">to_word_mul_length</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_word.length</span> <span class=\"bp\">≤</span> <span class=\"n\">x.to_word.length</span> <span class=\"bp\">+</span> <span class=\"n\">y.to_word.length</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">group_norm_comm_le</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">group_norm</span> <span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">≤</span> <span class=\"n\">group_norm</span> <span class=\"n\">m</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">group_norm</span> <span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">group_norms</span> <span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">nat.lt.is_well_order.wf.min_mem</span> <span class=\"o\">(</span><span class=\"n\">group_norms</span> <span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">group_norms_nonempty</span> <span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">set.mem_image_iff_bex.1</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"n\">ytox</span><span class=\"o\">,</span><span class=\"n\">yneqxn</span><span class=\"o\">⟩,</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">yitoxi</span> <span class=\"o\">:</span> <span class=\"n\">m.marking</span> <span class=\"n\">y</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span><span class=\"o\">,</span> <span class=\"kd\">by</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">map_inv</span><span class=\"o\">,</span><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">inv_inj</span><span class=\"o\">],</span><span class=\"n\">exact</span> <span class=\"n\">ytox</span> <span class=\"o\">},</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">mon</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_word.length</span> <span class=\"bp\">≤</span> <span class=\"n\">y.to_word.length</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">to_word_inv_length</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_word.length</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">group_norms</span> <span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span><span class=\"o\">),</span>\n    <span class=\"k\">from</span> <span class=\"n\">set.mem_image_iff_bex.2</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"bp\">⁻¹</span><span class=\"o\">,</span> <span class=\"n\">yitoxi</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">well_founded.min_le</span> <span class=\"n\">nat.lt.is_well_order.wf</span> <span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"n\">group_norms_nonempty</span> <span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span><span class=\"o\">)),</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">yneqxn</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">mon</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">group_norm_comm</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">group_norm</span> <span class=\"n\">m</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">group_norm</span> <span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">has_le.le.antisymm</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">group_norm_comm_le</span> <span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">(</span><span class=\"n\">inv_inv</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">assumption</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">group_norm_comm_le</span> <span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">group_norm_ineq</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">group_norm</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">group_norm</span> <span class=\"n\">m</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">group_norm</span> <span class=\"n\">m</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"c1\">-- extract reps for x, y, use product for x*y</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">group_norm</span> <span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">group_norms</span> <span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">nat.lt.is_well_order.wf.min_mem</span> <span class=\"o\">(</span><span class=\"n\">group_norms</span> <span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">group_norms_nonempty</span> <span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">set.mem_image_iff_bex.1</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"n\">ztox</span><span class=\"o\">,</span><span class=\"n\">zneqxn</span><span class=\"o\">⟩,</span>\n  <span class=\"k\">have</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">group_norm</span> <span class=\"n\">m</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">group_norms</span> <span class=\"n\">m</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">nat.lt.is_well_order.wf.min_mem</span> <span class=\"o\">(</span><span class=\"n\">group_norms</span> <span class=\"n\">m</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">group_norms_nonempty</span> <span class=\"n\">m</span> <span class=\"n\">y</span><span class=\"o\">),</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">set.mem_image_iff_bex.1</span> <span class=\"n\">k</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"n\">wtoy</span><span class=\"o\">,</span><span class=\"n\">wneqyn</span><span class=\"o\">⟩,</span>\n  <span class=\"k\">have</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">m.marking</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">wtoy</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">two</span> <span class=\"o\">:</span> <span class=\"n\">m.marking</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">ztox</span><span class=\"o\">,</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">zwtoxy</span> <span class=\"o\">:</span> <span class=\"n\">m.marking</span> <span class=\"o\">(</span><span class=\"n\">z</span><span class=\"bp\">*</span><span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">map_mul</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">one</span><span class=\"o\">,</span><span class=\"n\">two</span><span class=\"o\">],},</span>\n  <span class=\"k\">have</span> <span class=\"n\">mon</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">z</span><span class=\"bp\">*</span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_word.length</span> <span class=\"bp\">≤</span> <span class=\"n\">z.to_word.length</span> <span class=\"bp\">+</span> <span class=\"n\">w.to_word.length</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">to_word_mul_length</span> <span class=\"n\">z</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">z</span><span class=\"bp\">*</span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_word.length</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">group_norms</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span><span class=\"o\">)),</span>\n    <span class=\"k\">from</span> <span class=\"n\">set.mem_image_iff_bex.2</span> <span class=\"o\">⟨</span><span class=\"n\">z</span><span class=\"bp\">*</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">zwtoxy</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n\n  <span class=\"n\">apply</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">well_founded.min_le</span> <span class=\"n\">nat.lt.is_well_order.wf</span> <span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"n\">group_norms_nonempty</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">))),</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">zneqxn</span><span class=\"o\">,</span><span class=\"bp\">←</span><span class=\"n\">wneqyn</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">mon</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I'm not sure of the best way to prove the first two lemmas above. Surely they should follow from relatively simple manipulations in the free group: If <code>w</code> is a reduced word for <code>x</code>, then <code>w.reverse.map …</code> is a representative of x⁻¹, hence in the same class as <code>x⁻¹.to_word</code>, hence reduces to it, and by monotonocity we're done… but I can't quite get the correct tools to use for that. By the way, please tell me if I should play with something else while you're working on this file!</p>",
        "id": 290220427,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658315419
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466727\">@Jim Fowler</span> great! I looked at your \"properties.lean\" and added some stuff. Out of curiosity, why did you go to monoid quotients in \"residually P\"?</p>",
        "id": 290223129,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1658317106
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span> Very nice, of course I'm very happy to see you filled some sorries. Should I paste it into the file, or do you want to commit it yourself?</p>\n<p>About <code>to_word_inv_length</code>: the lemmas are definitely there, but I can't put them together: <code>free_group.mk</code> takes a list and uses <code>red</code>, <code>free_group.red.length</code> proves that length decreases under <code>red</code>, and <code>free_group.inv_mk</code> reverses a list, so preserves length. Hope that helps!</p>",
        "id": 290224371,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1658317899
    },
    {
        "content": "<p>Feel free to paste if you feel it's going in the direction you were headed at (this way there is fewer chances of commits crossing, etc). I'll think more about how to go forward with it, without much guarantee!</p>",
        "id": 290224723,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658318077
    },
    {
        "content": "<p>I had added some of the inv_rev lemmas to free_group on another branch -- it is in <a href=\"https://github.com/leanprover-community/mathlib/pull/15503\">https://github.com/leanprover-community/mathlib/pull/15503</a></p>",
        "id": 290229591,
        "sender_full_name": "Jim Fowler",
        "timestamp": 1658321212
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"263407\">@Laurent Bartholdi</span> the monoid stuff in the def of <code>residually</code> is just there to get it to find the instance of has_one.  I'm not sure how to quantify over groups and get type class inference to pick up the <code>group</code> instance.</p>",
        "id": 290229806,
        "sender_full_name": "Jim Fowler",
        "timestamp": 1658321339
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"263407\">@Laurent Bartholdi</span> Your additions to <code>properties.lean</code> are great!</p>",
        "id": 290234146,
        "sender_full_name": "Jim Fowler",
        "timestamp": 1658323718
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466727\">@Jim Fowler</span> Great, do you have any when your PR will get merged?</p>\n<p>In the meantime, I've tried tackling <code>to_word_inv_length</code> below: as far as I know, it works correctly, though the code is far from good.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">to_word_inv_length</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹.</span><span class=\"n\">to_word.length</span> <span class=\"bp\">≤</span> <span class=\"n\">x.to_word.length</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">xi</span> <span class=\"o\">:=</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">xw</span> <span class=\"o\">:=</span> <span class=\"n\">x.to_word</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">xiw</span> <span class=\"o\">:=</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹.</span><span class=\"n\">to_word</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">xwi</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x.to_word.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">×</span> <span class=\"n\">bool</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">y.fst</span><span class=\"o\">,</span> <span class=\"bp\">!</span><span class=\"n\">y.snd</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"o\">,</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">xi_eq_mk_xwi</span> <span class=\"o\">:</span> <span class=\"n\">xi</span> <span class=\"bp\">=</span> <span class=\"n\">free_group.mk</span> <span class=\"n\">xwi</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">free_group.inv_mk</span><span class=\"o\">,</span> <span class=\"n\">free_group.to_word.mk</span><span class=\"o\">],</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">free_group.reduce</span> <span class=\"n\">xwi</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">free_group.mk</span> <span class=\"n\">xwi</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_word</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">free_group.reduce</span> <span class=\"n\">xwi</span> <span class=\"bp\">=</span> <span class=\"n\">xiw</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">xi_eq_mk_xwi</span><span class=\"o\">],</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">free_group.red</span> <span class=\"n\">xwi</span> <span class=\"n\">xiw</span> <span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">this</span> <span class=\"bp\">▸</span> <span class=\"n\">free_group.reduce.red</span><span class=\"o\">,</span>\n\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">xwi.length</span> <span class=\"bp\">≥</span> <span class=\"n\">xiw.length</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">free_group.red.length</span> <span class=\"n\">this</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"n\">p</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">le_iff_exists_add.mpr</span> <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"n\">p</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">list.length_reverse</span><span class=\"o\">,</span><span class=\"n\">list.length_map</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 290235151,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658324163
    },
    {
        "content": "<p>Perhaps it's best to wait till <span class=\"user-mention\" data-user-id=\"466727\">@Jim Fowler</span> 's PR is merged? That will make all the lemmas shorter in marked_groups. I can then do the integration. Or is there a way to temporarily merge your PR without completely messing up git?</p>",
        "id": 290238048,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1658325426
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 290240276,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658326331
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"263407\">@Laurent Bartholdi</span> (I've updated my snippet with an impl for <code>to_word_mul_length</code> too)<br>\nWhichever way you prefer, though note that <span class=\"user-mention\" data-user-id=\"466727\">@Jim Fowler</span> 's PR is for <code>master</code>, if I'm not mistaken. This means both that it may take some time to get merged, and that our including a patchy version for the time being in <code>geometric-group-theory</code> won't mess up anything with git as far as I'm aware.</p>",
        "id": 290246253,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658328943
    },
    {
        "content": "<p>OK, I've included <span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span> 's code in marked_group.lean. In principle, we have all the lemmas to assert the existence of a metric space!</p>\n<p>I confess I haven't totally [= not at all] understood how to create a new type such that <code>[marked_group MG]</code> asserts that MG is a group with marking. I have created a tentative growth.lean file to see how the API could develop.</p>\n<p>For some practical applications I have in mind, it may be nice to have more general metrics: word metrics with weights, and restrictions of the word metric to a subgroup. There too, I'm not yet sure about how best to create the structures.</p>",
        "id": 290273921,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1658340278
    },
    {
        "content": "<p>I've made a few changes to <code>marked_group.lean</code> but it's not pushed to your branch: <a href=\"https://github.com/bottine/mathlib/blob/geometric-group-theory/src/group_theory/geometric/marked_group.lean\">see my repo</a>. I've split the <code>group_norm_one</code> into a sublemma because I needed it later on, and mostly I've started an attempt at showing that two finite generating sets induce equivalent norms. For this I've had to define a few more lemmas on the free group (unproved yet but should be easy enough). I've also added a few natural stubs: e.g. the only elements of norm one are letters.</p>",
        "id": 290340083,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658386778
    },
    {
        "content": "<p>Yes, that's definitely the right direction!<br>\n0) if I may ask, why do you prefer working in a fork?<br>\n1) my aims are multiple:<br>\n1.1) to be able to formalize lots of geometric group theory, which relies on having a metric space instance starting from a finitely generated group; this includes the Svarc-Milnor lemma, ends of groups, hyperbolic, CAT(0) groups, etc.<br>\n1.2) to formalize growth of groups; in particular, the Dixmier-Bass-Guivarch result that virtually nilpotent groups have polynomial growth; the Milnor-Wolf result that virtually solvable groups have either polynomial or exponential growth; the Grigorchuk result that there are groups of intermediate growth; and (probably harder) the Gromov result that polynomial-growth groups are virtually nilpotent.<br>\n1.3) to formalize, more generally, the \"space of marked groups\" as a compact topological space; and results about openness / closedness / G_delta genericity of various group properties.<br>\n2) here is my idea of a roadmap:<br>\n2.1) have a robust class \"marked_group\" which is a group on which a marking is registered; this will be useful for all the goals in 1)<br>\n2.2) different people can then develop independently the different consequences: growth, group properties, space of marked groups, and \"pure geometric group theory\" i.e. ends and actions on nice spaces (CAT(0), delta-hyperbolic, wall space, median space, ...)<br>\n3) in your lemma <code>lemma group_norm_letter</code> on line 120 there's a good reason the proof is <code>sorry</code>, and that the lemma's wrong! indeed nothing prevents an element of S to be mapped to 1:G. The correct one would have \"\\le 1\". For the same reason, <code>lemma group_norm_one_iff_is_letter</code> on line 121 is wrong if G is the trivial group.</p>\n<p>Now I must confess I feel a bit bad about writing this roadmap, feeling like an orchestra conductor who can't play a single instrument. It's just my opinion on what would be good, and I'd love a discussion about it.</p>",
        "id": 290363767,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1658403349
    },
    {
        "content": "<p>0) I don't prefer working in a fork at all: it's just that I'm not sure my changes were agreeable, and wanted to share them before committing them (my own \"fork\" is just a way to work without polluting the official repo).<br>\n1) Great: I pretty much have the exact same goals. I would very much like to prove Stalling's ends theorem eventually, hence working on ends and Bass-Serre seems like a good start.<br>\n2) I know the feeling!<br>\n3) Good point, what about adding <code>m.marking (free_group.mk p) ≠ 1</code>? Maybe that's useless as a lemma…</p>",
        "id": 290364836,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658403944
    },
    {
        "content": "<p>Please avoid touching the branch right now! I am implementing the type synonym approach.</p>",
        "id": 290365220,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658404209
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> great, I'll keep my hands off the keyboard.<br>\n<span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span> , I don't think it's a good idea to forbid trivial generators; for example, it's nice to know that if G is a marked group then every quotient of G inherits the marking. Also, you must have the trivial group in the space of marked groups. Also, your lemmas at line 120-121 aren't used. Did you have an application in mind?</p>",
        "id": 290367422,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1658405693
    },
    {
        "content": "<p>no use, I just felt they  (or a suitably corrected versions) might come handy later on. <br>\nAnd from the little I learned about mathlib, the rule of thumb looks to be: as few defs as possible, as many lemmas as possible. <br>\nBut we can drop them, obviously.</p>",
        "id": 290368077,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658406131
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span> Line 51 is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">free_group.mk.singleton</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">×</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">free_group.mk</span> <span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])</span><span class=\"bp\">.</span><span class=\"n\">to_word</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>and this isn't in <a href=\"https://github.com/leanprover-community/mathlib/pull/15503\">https://github.com/leanprover-community/mathlib/pull/15503</a> but it could be added.  There's a lot of relevant lemmas for words and the free group...</p>",
        "id": 290394101,
        "sender_full_name": "Jim Fowler",
        "timestamp": 1658418703
    },
    {
        "content": "<p>In terms of goals, I think ends of groups would be a great first goal.</p>",
        "id": 290394227,
        "sender_full_name": "Jim Fowler",
        "timestamp": 1658418749
    },
    {
        "content": "<p>I am not convinced that the basic object is marked groups. Instead, I'd go for groups with a left-invariant distance: there are many examples where the relevant distance is not a word distance (as a basic example, just think of the case where you don't give length 1 to all generators). Unfortunately, in mathlib currently <code>normed_group</code> is reserved for additive groups, but we could make the case that this should be renamed to <code>normed_add_group</code>.</p>",
        "id": 290409596,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1658425547
    },
    {
        "content": "<p>Have you seen the definitions of <code>normed_mul_group</code> and <code>isom_action</code> on <a href=\"https://github.com/leanprover-community/mathlib/tree/geometric-group-theory\">branch#geometric-group-theory</a>?</p>",
        "id": 290409847,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658425646
    },
    {
        "content": "<p>I am currently PRing group seminorms with the hope to turn around the dependency between <code>seminorm</code> and <code>normed_group</code> and eventually move <code>normed_mul_group</code> to mathlib.</p>",
        "id": 290410005,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658425719
    },
    {
        "content": "<p>No, I haven't opened the branch, I'm just writing random thoughts on Zulip :-)</p>\n<p>Changing the current <code>normed_group</code> to <code>normed_add_group</code> would make a lot of sense, IMHO.</p>",
        "id": 290411059,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1658426261
    },
    {
        "content": "<p>I agree, but I didn't dare to suggest it because it's used in 182 files :P</p>",
        "id": 290411175,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658426303
    },
    {
        "content": "<p><code>normed_add_group</code> seems like a great improvement.  I don't think there is any sort of automated way of renaming identifiers?</p>",
        "id": 290411443,
        "sender_full_name": "Jim Fowler",
        "timestamp": 1658426423
    },
    {
        "content": "<p>No but it's not hard to do by hand. If people agree on the rename, I can do that in a few minutes.</p>",
        "id": 290411588,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658426496
    },
    {
        "content": "<p>I would like to better understand current mathlib idioms for attaching a symmetry group to an object.</p>",
        "id": 290412003,
        "sender_full_name": "Jim Fowler",
        "timestamp": 1658426708
    },
    {
        "content": "<p>It's really great to see all of <span class=\"user-mention\" data-user-id=\"466209\">@Georgi Kocharyan</span> 's work in this branch too.</p>",
        "id": 290412225,
        "sender_full_name": "Jim Fowler",
        "timestamp": 1658426801
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> : in fact it was my initial hope to have more general metrics. The worry I had is that the process would never leave the ground if we aim for too general in the beginning: for example, you'll have to make the metric be proper even before mentioning growth functions. In an ideal world, I would see the following:</p>\n<ul>\n<li>metric spaces with a left action by isometries</li>\n<li>as a special case, a homogeneous space G/P with metric induced from a metric on G</li>\n<li>as a sub-special case, G/P with a metric induced by weights on a [finite?] generating set of G</li>\n<li>as a sub^2-special case, G/P with the word metric from G</li>\n<li>as another sub^2-special case, G with a metric induced by weights on a [finite?] generating set of G</li>\n<li>as a sub^3 special case, G with the word metric</li>\n</ul>\n<p>and automatic ways of converting each special case to less special one whenever the more general theorem holds.</p>\n<p>I don't think I have enough wizard powers to implement this, though. Do you think it's feasible?</p>",
        "id": 290414367,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1658427869
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> I just looked at your code, it's beautiful!<br>\nThough I have a problem with the \"normed_mul_group\": defining the metric by <code>dist x y =  ∥x/y∥</code> makes is right invariant, while all of lean seems to be built on left actions and left invariance. I tried to change it to <code>dist x y =  ∥x⁻¹*y∥</code> (see the most recent commit), but of course nothing works quite as before. Feel free to revert.</p>",
        "id": 290419946,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1658430267
    },
    {
        "content": "<p>Thanks! Glad you like it <span aria-label=\"smiling face\" class=\"emoji emoji-263a\" role=\"img\" title=\"smiling face\">:smiling_face:</span></p>",
        "id": 290420064,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658430334
    },
    {
        "content": "<p>I picked this direction because eventually we will refactor <a href=\"https://leanprover-community.github.io/mathlib_docs/find/normed_group\">docs#normed_group</a> to be the additivized version of <code>normed_mul_group</code>, and it uses <code>dist x y = ∥x - y∥</code>.</p>",
        "id": 290420318,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658430462
    },
    {
        "content": "<p>Note however that <code>normed_group</code> is already assumed to be commutative, so we might be able to work around it, but it will be painful.</p>",
        "id": 290420435,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658430514
    },
    {
        "content": "<p>There's no doubt that mathematically Laurent's definition is the right one. Even in the additive case, it would feel more natural to me to have <code>dist x y = ∥y - x∥</code>, by the way.</p>",
        "id": 290421971,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1658431274
    },
    {
        "content": "<p><code>∥y - x∥</code> is still right-invariant, right?</p>",
        "id": 290425955,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658433391
    },
    {
        "content": "<p>On a side note, I had to add lemmas</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">mul_mul_inv_cancel</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">⁻¹*</span><span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">⁻¹*</span><span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"bp\">⁻¹*</span><span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">group</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">inv_of_inv_mul</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">⁻¹*</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"bp\">⁻¹*</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">group</span>\n</code></pre></div>\n<p>which I couldn't find in the library -- algebra.group.basic seems to mainly consist of lemmas for commutative (multiplicative and additive) groups, and I found no basic lemmas in group_theory.</p>\n<p>Yet another side note: I would like (with the help of a student) to extend group_theory.commutator. I respect the fact that left actions are used by default in Lean; but it would be nice to have a notation for it (it's exponentiation for a right action). Is there some standard one? Otherwise, I would propose ⇀, ⇁ or ⊸, something like <code>infix `⊸`:200 := λ x y,x*y/x </code>. It would also be nice to have iterated commutators; I can use</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span> <span class=\"bp\">`⁅`</span><span class=\"n\">x</span><span class=\"bp\">`</span><span class=\"o\">,</span><span class=\"bp\">`</span> <span class=\"n\">y</span><span class=\"bp\">`</span><span class=\"o\">,</span><span class=\"bp\">`</span> <span class=\"n\">z</span><span class=\"bp\">`⁆`</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">has_bracket.bracket</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">has_bracket.bracket</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">))</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⁅</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"bp\">⁆=</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">group</span>\n</code></pre></div>\n<p>but it would be nice to have right associativity for the non-infix operation.</p>",
        "id": 290426152,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1658433492
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> and <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> we want <code>∥-x + y∥</code> if we're ever going to consider non-commutative additive groups :tongue-in-cheek:</p>",
        "id": 290426635,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1658433716
    },
    {
        "content": "<p>There is little point in adding all possible lemmas about group operations, when you can get there with one or two existing ones. The first is <code>rw [mul_assoc, mul_inv_cancel_left]</code>, and the second is <code>rw [mul_inv_rev, inv_inv]</code>.</p>",
        "id": 290427207,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658433977
    },
    {
        "content": "<p><a href=\"https://tqft.net/mathlib/algebra\">file#algebra</a>.group.basic is the right file to look at. I do not quite get what you mean about it being mostly for commutative groups, given that there are 99 lemmas in there that apply to the noncommutative setting.</p>",
        "id": 290427654,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658434189
    },
    {
        "content": "<p>Thanks, I golfed the proofs and just pushed them using your suggestion. I also removed a sorry from instance:normed_mul_group</p>",
        "id": 290432322,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1658436557
    },
    {
        "content": "<p>Re \"the right basic object\", the <a href=\"https://www.normalesup.org/~cornulier/MetricLC.pdf\">Proposition 1.A.1 in Cornulier &amp; de la Harpe,p. 10 </a> seemed to me to be exactly what we should aim for (see also the text up until 1.B) but I had the same fear that it might be too general to start with?</p>",
        "id": 290462711,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658463334
    },
    {
        "content": "<p>Looking forward to working on this with everyone! Would I be able to have writing rights on the repo? My github is GregorSamsa42 :)</p>",
        "id": 290473738,
        "sender_full_name": "Georgi Kocharyan",
        "timestamp": 1658474837
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466209\">@Georgi Kocharyan</span>: by the way, if there are places in your code where you'd trust a beginner to fill in some holes, I'd welcome the opportunity.</p>",
        "id": 290475198,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658476084
    },
    {
        "content": "<p>As I am also a beginner you are more than welcome !</p>",
        "id": 290481295,
        "sender_full_name": "Georgi Kocharyan",
        "timestamp": 1658480408
    },
    {
        "content": "<p>Alright! anything in particular?</p>",
        "id": 290510569,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658499026
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span> I just pushed some definitions from Cornulier&amp;Harpe to your (nice) new file on coarse pseudometric spaces. Hopefully this will connect nicely with the rest of the code</p>",
        "id": 290521841,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1658502101
    },
    {
        "content": "<p>Beware, though! After discussing on github (I have a pull request open for this file), i noticed that my definitions are quite (dangerously?) different from the official ones. For density, I'm using the existence of a close point with \"≤\", instead of Hausdorff distance with \"&lt;\", and for separation I use \"&lt;\" instead of \"≤\". I admit I like my definitions, since they allow a very clean statement in the last theorem, but wonder if they are dangerous as of now…</p>",
        "id": 290523295,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658502703
    }
]
[
    {
        "content": "<p>In Lean, how to state/formalize a theorem involving a1,..., an for an arbitrary pos integer n, taking the following trivial theorem as an example: for any pos integer n, for any real numbers a1,..., an, a1^2+...+an^2&gt;=0.</p>",
        "id": 240429477,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1622100814
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"408694\">@Alex Zhang</span> There are two ways to approach this:<br>\n(1) Pick a function from <code>fin n</code> to the real numbers. <code>fin n</code> is the type of numbers <code>{0, 1, ..., n-1}</code>.</p>",
        "id": 240429810,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622101000
    },
    {
        "content": "<p>(2) Pick an infinite sequence <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>a</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo separator=\"true\">,</mo><mo>…</mo><mtext> </mtext><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(a_0, a_1, \\dots, a_n, \\dots)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mclose\">)</span></span></span></span> and only talk about the first <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> elements.</p>",
        "id": 240429882,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622101050
    },
    {
        "content": "<p>What I would actually do is to drop the <code>n</code> completely, and prove this for arbitrary finite sums, indexed by any finite set.</p>",
        "id": 240429956,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622101087
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">sum_of_squares_nonneg</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 240430224,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622101207
    },
    {
        "content": "<p>The next thing I would do, is try to generalize <code>real</code> away. Because the theorem also holds for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85556em;vertical-align:-0.16667em;\"></span><span class=\"mord mathbb\">Q</span></span></span></span>.</p>",
        "id": 240430473,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622101360
    },
    {
        "content": "<p>So then I wonder if it's true in any <code>linear_ordered_comm_semiring</code>.</p>",
        "id": 240430495,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622101374
    },
    {
        "content": "<p>And that might actually not be true. I frankly don't know.</p>",
        "id": 240430528,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622101397
    },
    {
        "content": "<p>Many thanks, Johan!<br>\n To prove the first trivial theorem, I think the next thing I will do is to do induction on the cardinal of s. I am still quite new to Lean.. I know how to do induction, but the achieve the next step, how do I know what files do I need to import to use \"cardinal\" and where to find a manual illustrating the use of \"cardinal\"?</p>",
        "id": 240431090,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1622101768
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"408694\">@Alex Zhang</span> in fact, you can do induction on <code>s</code> itself.<br>\nTry</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">begin</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">finset.induction_on</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 240431195,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622101823
    },
    {
        "content": "<p>That will give you to goals: (i) prove it for empty <code>s</code>, and (ii) prove it for <code>s \\union {x}</code> assuming you know the theorem for <code>s</code></p>",
        "id": 240431242,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622101869
    },
    {
        "content": "<p>Thanks, Johan! Could you please explain, if I do want to use something like \"cardinal\" in the future, how should I figure out the above questions?</p>",
        "id": 240431554,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1622102103
    },
    {
        "content": "<p>In VScode you can click the <span aria-label=\"magnifying glass\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"magnifying glass\">:magnifying_glass:</span> button in the bar on the left, and search for <code>cardinal</code>. If that doesn't give you what you want, asking here should usually give you a fast answer as well.</p>",
        "id": 240431697,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622102194
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">set_theory.cardinal</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">cardinal.mk</span> <span class=\"n\">ℝ</span>\n</code></pre></div>\n<p>This gives me the error message <code>result type does not have an instance of type class 'has_repr', dumping internal representation</code>.</p>",
        "id": 240433278,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1622103312
    },
    {
        "content": "<p>What are you expecting the answer to be?</p>",
        "id": 240433305,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622103330
    },
    {
        "content": "<p>It says \"this is some random equivalence class which doesn't have a string attached to it so I don't know what string to print\"</p>",
        "id": 240433331,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622103356
    },
    {
        "content": "<p><code>#eval</code> means \"turn the internal representation of this object into a string, by \"evaluating\" it in some way, and print the string\"</p>",
        "id": 240433426,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622103405
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">list.cons</span> <span class=\"mi\">4</span> <span class=\"n\">list.nil</span> <span class=\"c1\">-- [4]</span>\n</code></pre></div>\n<p>This works because someone wrote some code which takes a list and turns it into a string starting with a <code>[</code> and puts commas between the string representations of the elements of the list etc etc</p>",
        "id": 240433574,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622103524
    },
    {
        "content": "<p>What does \"induction on a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal\">docs#cardinal</a>\" mean for uncountable cardinalities?</p>",
        "id": 240434212,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622103978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Theorem.20Formalization/near/240433305\">said</a>:</p>\n<blockquote>\n<p>What are you expecting the answer to be?</p>\n</blockquote>\n<p>I would expect  <code>cardinal.mk ℝ</code> can give me c (or what is used to represent this in Lean), and expect <code>cardinal.mk (fin 5)</code> can give me 5, but <code>cardinal.mk</code> does not work as I thought.</p>",
        "id": 240434459,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1622104132
    },
    {
        "content": "<p>It is a <em>theorem</em> that <code>cardinal.mk (fin 5)</code> is 5.</p>",
        "id": 240434507,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622104167
    },
    {
        "content": "<p>Is there any function already defined in Lean which outputs the cardinal of S as a natural number when S is finite and given as input?</p>",
        "id": 240434857,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1622104357
    },
    {
        "content": "<p><code>fintype.card</code></p>",
        "id": 240434929,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622104414
    },
    {
        "content": "<p>But depending on what you input, it cannot compute the natural number.</p>",
        "id": 240434956,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622104433
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/fintype.card\">docs#fintype.card</a></p>",
        "id": 240435018,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622104454
    },
    {
        "content": "<p>We also have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.card\">docs#finset.card</a>, which is better if you started with a finset.</p>",
        "id": 240435032,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622104471
    },
    {
        "content": "<p>For example,  Lean will probably timeout on <code>fintype.card {p : fin 100 // nat.prime p}</code></p>",
        "id": 240435076,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622104508
    },
    {
        "content": "<p>Will timeout <em>if you use <code>#eval</code> / <code>#reduce</code></em>, I assume you mean</p>",
        "id": 240435142,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622104561
    },
    {
        "content": "<p>any analogical function for infinite sets or countable sets?</p>",
        "id": 240435501,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1622104763
    },
    {
        "content": "<p>There is no function which takes an arbitrary type and, for example, figures out magically whether it is countable or uncountable, no. Such a function cannot exist.</p>",
        "id": 240435609,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622104825
    },
    {
        "content": "<p>That's <code>cardinal.mk</code></p>",
        "id": 240435620,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622104830
    },
    {
        "content": "<p>Sure there is, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/classical.dec\">docs#classical.dec</a> is \"for any statement p, figure out magically if it's true\". Unfortunately you're just not allowed to ask lean what its conclusion was!</p>",
        "id": 240436554,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622105514
    },
    {
        "content": "<p>I guess we have different mental models of <code>or</code>.</p>",
        "id": 240436796,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622105666
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/Theorem.20Formalization/near/240435076\">said</a>:</p>\n<blockquote>\n<p>For example,  Lean will probably timeout on <code>fintype.card {p : fin 100 // nat.prime p}</code></p>\n</blockquote>\n<p>(For the record, <code>#eval</code> is still quite fast on natural numbers. Only around <code>#eval fintype.card {p : fin 100000 // nat.prime p}</code> does it start to take over a second on my machine.)</p>",
        "id": 240444698,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622110708
    },
    {
        "content": "<p>(Meanwhile, <code>#reduce</code> takes longer than I care to wait on <code>#reduce fintype.card {p : fin 4 // nat.prime p}</code>.)</p>",
        "id": 240444792,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622110779
    },
    {
        "content": "<p>Ooh, right! But for proofs it is <code>#reduce</code> which is what matters, right?</p>",
        "id": 240450116,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622114012
    },
    {
        "content": "<p>Interestingly <code>#reduce fintype.card {p : fin 3 // nat.prime p}</code> is instant</p>",
        "id": 240452087,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622115317
    },
    {
        "content": "<p>This makes it faster:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.prime</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">nat.decidable_prime_1</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">fintype.card</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">12</span> <span class=\"bp\">//</span> <span class=\"n\">nat.prime</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">fintype.card</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">12</span> <span class=\"bp\">//</span> <span class=\"n\">nat.prime</span> <span class=\"n\">p</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 240452269,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622115440
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/Theorem.20Formalization/near/240450116\">said</a>:</p>\n<blockquote>\n<p>Ooh, right! But for proofs it is <code>#reduce</code> which is what matters, right?</p>\n</blockquote>\n<p>Not exactly. <code>rfl</code> is similar but not quite as \"thorough\" as <code>#reduce</code>, and so it is usually a lot faster</p>",
        "id": 240541688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622155787
    },
    {
        "content": "<p>I defined Kronecker product to be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>  <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Kronecker</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">*</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I omitted the exact definition.<br>\nThen I want to formalize the associativity.<br>\nBut <code>lemma K_assoc : (A ⊗ (B ⊗ C) = (A ⊗ B) ⊗ C :=sorry</code> gives me the error message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">Kronecker</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">⊗</span><span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">A</span><span class=\"bp\">⊗</span><span class=\"n\">B</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">*</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"n\">α</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>How can I fix this issue? Could anyone please give me a help?</p>",
        "id": 244129405,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624878777
    },
    {
        "content": "<p>Can you please post a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ?</p>",
        "id": 244129495,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624878844
    },
    {
        "content": "<p>But I know what the problem will be :-)</p>",
        "id": 244129537,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624878862
    },
    {
        "content": "<p>Lean sees your lemma, and figures that it's an equality of two terms of a type, but it doesn't immediately know what the type is. So it looks at the left hand side to figure it out, and realises that the type is <code>matrix (fin (m * (p * s)) (fin (n * (q * t))</code> or something (this is where having a mwe would help me), and then it tries to make sense of the RHS, and it sees _ otimes C so decides that C should have type matrix (fin (ps)) (fin (qt)) and _ should have type matrix (fin m) (fin n), and then it takes a look at _ and realises that it can figure out the type and that it's not that.</p>",
        "id": 244129790,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624879046
    },
    {
        "content": "<p>The issue is that <code>a * (b * c)</code> is equal, but not definitionally equal, to <code>(a * b) * c</code>, and hence Lean is reluctant to identify <code>fin (a * (b * c))</code> and <code>fin ((a * b) * c)</code> as equal. It would rather you used <code>eq.subst</code> to get a map from one to the other.</p>",
        "id": 244130010,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624879186
    },
    {
        "content": "<p>I understand this is a type mismatch problem, but have no idea how to fix it :(<br>\nHere is a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>. I tried to make is as short as possible.</p>",
        "id": 244130041,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624879202
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.matrix.notation</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Kronecker</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">*</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">default</span> <span class=\"n\">α</span>\n\n<span class=\"n\">localized</span> <span class=\"s2\">\"infix `⊗`:100 := Kronecker\"</span> <span class=\"k\">in</span> <span class=\"n\">Kronecker</span>\n\n<span class=\"kd\">variables</span>\n<span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">semigroup</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">K_assoc</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⊗</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">⊗</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⊗</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">⊗</span> <span class=\"n\">C</span> <span class=\"o\">:=</span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 244130094,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624879212
    },
    {
        "content": "<p>I could do the unhelpful thing of inserting the eq.rec into the statement of the lemma so that it compiles, but that would not solve the problem of how to prove the lemma, which would probably be a pretty nasty one.</p>",
        "id": 244130313,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624879351
    },
    {
        "content": "<p>Let's take a step back. Your Kronecker product is really two constructions. Firstly there is a much more natural (from the point of view of functional programming at least) multiplication <code>matrix F1 F2 alpha -&gt; matrix F3 F4 alpha -&gt; matrix (F1 x F2) (F3 x F4) alpha</code>. Your Kronecker is this composed with some functorial map coming from matrices and a construction <code>fin m x fin n -&gt; fin (m*n)</code></p>",
        "id": 244130542,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624879499
    },
    {
        "content": "<p>I am going to prove the lemma myself (and I gave an incorrect definition in the first place in the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> anyway).<br>\nThe trouble I am facing is just there is an error in the statement.</p>",
        "id": 244130574,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624879516
    },
    {
        "content": "<p>yes, but want to explain how there is something odd about the statement</p>",
        "id": 244130602,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624879536
    },
    {
        "content": "<p>The map <code>fin m x fin n -&gt; fin (m*n)</code> is rather artificial, there are many such maps.</p>",
        "id": 244130674,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624879570
    },
    {
        "content": "<p>It would also be great if you can help to fix the problem by rewriting the defn.</p>",
        "id": 244130694,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624879591
    },
    {
        "content": "<p>That will in some sense make the problem worse</p>",
        "id": 244130722,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624879603
    },
    {
        "content": "<p>because what I am getting around to suggesting is that you should be proving something more abstract first</p>",
        "id": 244130739,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624879621
    },
    {
        "content": "<p>The multiplication I indicated above, with products of finite sets, is a more low-level object and the problem already arises there, and my instinct is that we should deal with it there before we get into all the mess of the combinatorics of bijections fin m x fin n -&gt; fin (mn).</p>",
        "id": 244130801,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624879676
    },
    {
        "content": "<p>Now an interesting question is how to state associativity of this more fundamental product, and here you see that we still have the problem that it cannot be stated naively in Lean, because one matrix has type <code>matrix ((F1 x F3) x F5) ((F2 x F4) x F6) alpha</code> and the other has type <code>matrix (F1 x (F3 x F5)) (F2 x (F4 x F6)) alpha</code> and these types are not equal, they're just canonically isomorphic</p>",
        "id": 244130958,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624879784
    },
    {
        "content": "<p>so one should define, or perhaps just find in Lean because it's probably already there, the way to move between <code>matrix A B alpha</code> and <code>matrix  C D alpha</code> given maps from C to A and D to B (maybe it will be called <a href=\"https://leanprover-community.github.io/mathlib_docs/find/matrix.comap\">docs#matrix.comap</a> or something)</p>",
        "id": 244131091,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624879868
    },
    {
        "content": "<p>and then the statement of associativity would say that mapping a matrix along such a map gave you another matrix</p>",
        "id": 244131129,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624879901
    },
    {
        "content": "<p>so then you can solve that knotty problem without all the extra fin noise, and then build the fin stuff on top where you'll have to prove some elementary number theory lemma saying that your two maps fin a -&gt; fin b -&gt; fin c -&gt; fin (abc) coincide (where you do the multiplications in two different orders)</p>",
        "id": 244131233,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624879964
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Theorem.20Formalization/near/244130958\">said</a>:</p>\n<blockquote>\n<p>Now an interesting question is how to state associativity of this more fundamental product, and here you see that we still have the problem that it cannot be stated in Lean, because one matrix has type <code>matrix ((F1 x F3) x F5) ((F2 x F4) x F6) alpha</code> and the other has type <code>matrix (F1 x (F3 x F5)) (F2 x (F4 x F6)) alpha</code> and these types are not equal, they're just canonically isomorphic</p>\n</blockquote>\n<p>Yes. Thanks for your explanations! At this step, we still face the same (almost) problem. (By the way, I think it would be more convenient to use <code>fin n</code> for the defn than using <code>n</code> as a fintpye as I do want elements to have orders to define the Kronecker product.)</p>",
        "id": 244131401,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624880110
    },
    {
        "content": "<p>I don't know if it's there already, but you seem to need a map <code>equiv A B -&gt; equiv C D -&gt; equiv (matrix A C alpha) (matrix B D alpha)</code>. This construction (for it's a definition, not a theorem) will be needed in your statement of the more foundational product.</p>",
        "id": 244131541,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624880198
    },
    {
        "content": "<p>Could you please a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> illustrating your way of solving this?</p>",
        "id": 244131616,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624880259
    },
    {
        "content": "<p>The relevant map is either <a href=\"https://leanprover-community.github.io/mathlib_docs/find/matrix.reindex\">docs#matrix.reindex</a> (if you don't care whether the equivalence is linear) or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/matrix.reindex_linear_equiv\">docs#matrix.reindex_linear_equiv</a>.</p>",
        "id": 244131693,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1624880286
    },
    {
        "content": "<p>(There is also <a href=\"https://leanprover-community.github.io/mathlib_docs/find/matrix.reindex_alg_equiv\">docs#matrix.reindex_alg_equiv</a> if you only want to work with square matrices)</p>",
        "id": 244131734,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1624880315
    },
    {
        "content": "<p>Thank you both! I have to leave for a moment... before going back to solve the problem.</p>",
        "id": 244132095,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624880534
    },
    {
        "content": "<p>Why do you need the elements to have an order to define the Kronecker product? Perhaps proofs about the definition might use the order. But the definition itself need not have it.</p>",
        "id": 244132356,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1624880728
    },
    {
        "content": "<p>I haven't left. Basically,  I used this to define the product (omitted many things here)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span>  <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">/</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"bp\">/</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">%</span> <span class=\"n\">p</span><span class=\"o\">)(</span><span class=\"n\">j</span> <span class=\"bp\">%</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>What is the way not using indices?</p>",
        "id": 244132973,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624881142
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 244133444,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624881446
    },
    {
        "content": "<p>I think Kevin's point here holds, about two separate constructions. First you make the \"full\" product, then you can use matrix.reindex or matrix.minor</p>",
        "id": 244134360,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1624882055
    },
    {
        "content": "<p>In my <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> code, <br>\n<code>(A ⊗ B) ⊗ C</code> has type <code>A⊗B⊗C : matrix (fin (s * (p * m))) (fin (t * (q * n))) α</code><br>\nthe other has type <code>A⊗(B⊗C) : matrix (fin (s * p * m)) (fin (t * q * n)) α</code>.<br>\n<code>fin (s * (p * m))</code> is not only isomorphic but also IDENTICAL to <code>fin (s * p * m)</code>.<br>\nIt is trivial to prove this fact</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">aux1</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">*</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">p</span> <span class=\"bp\">*</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ring_nf</span>\n<span class=\"kd\">def</span> <span class=\"n\">aux2</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"n\">q</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ring_nf</span>\n</code></pre></div>\n<p>How can I make Lean to recognise these two identities when parsing the statement of the lemma in <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> (perhaps by adding attributes to <code>aux</code>?)?</p>",
        "id": 244135882,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624882987
    },
    {
        "content": "<p><a href=\"#narrow/stream/267928-condensed-mathematics/topic/Kronecker.20product/near/244007513\">https://leanprover.zulipchat.com/#narrow/stream/267928-condensed-mathematics/topic/Kronecker.20product/near/244007513</a> might be relevant. It's also about Kronecker products</p>",
        "id": 244136079,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1624883106
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"408694\">Alex Zhang</span> <a href=\"#narrow/stream/113489-new-members/topic/Theorem.20Formalization/near/244135882\">said</a>:</p>\n<blockquote>\n<p>In my <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> code, <br>\n<code>(A ⊗ B) ⊗ C</code> has type <code>A⊗B⊗C : matrix (fin (s * (p * m))) (fin (t * (q * n))) α</code><br>\nthe other has type <code>A⊗(B⊗C) : matrix (fin (s * p * m)) (fin (t * q * n)) α</code>.<br>\n<code>fin (s * (p * m))</code> is not only isomorphic but also IDENTICAL to <code>fin (s * p * m)</code>.<br>\nIt is trivial to prove this fact</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">aux1</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">*</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">p</span> <span class=\"bp\">*</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ring_nf</span>\n<span class=\"kd\">def</span> <span class=\"n\">aux2</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"n\">q</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ring_nf</span>\n</code></pre></div>\n<p>How can I make Lean to recognise these two identities when parsing the statement of the lemma in <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> (perhaps by adding attributes to <code>aux</code>?)?</p>\n</blockquote>\n<p>Right, it's also about the Kronecer product. I didn't find things relevant to this particular question, however.</p>",
        "id": 244136680,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624883405
    },
    {
        "content": "<p>Agreed that it's not relevant to your question. I should have said \"just wanna make sure you are aware of this other effort going on\".</p>",
        "id": 244136986,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1624883567
    },
    {
        "content": "<p>In this case, I think Lean is very bad at using the equalities <code>aux1</code> and <code>aux2</code>. So I would turn them into  <code>equiv</code>s, and then use <code>reindex</code> mentioned above.</p>",
        "id": 244137226,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1624883668
    },
    {
        "content": "<p>Alex, you need to use something like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.cast\">docs#equiv.cast</a>, and compose in your definition. Or use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin.cast\">docs#fin.cast</a>. But it'll be easier if you generalize away from actual fin multiplication</p>",
        "id": 244137301,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1624883707
    },
    {
        "content": "<p>Your claim that they're identical requires a proof. Just because it's a relatively trivial proof doesn't mean it can be skipped, when doing type manipulations. And I don't know if I would call it \"trivial\" if you used a pretty heavy-handed tactic like ring_nf to prove it.</p>",
        "id": 244137644,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1624883873
    },
    {
        "content": "<p>I guess <code>congr_arg _ (mul_assoc _ _ _)</code> might also prove it...</p>",
        "id": 244137949,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1624884019
    },
    {
        "content": "<p>Another <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>. Is there a way to fix the error occurring in the statement of <code>silly</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">variables</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">variables</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"kd\">def</span> <span class=\"n\">g</span><span class=\"o\">:</span><span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">silly</span><span class=\"o\">:</span> <span class=\"n\">f</span><span class=\"bp\">=</span><span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 244138013,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624884067
    },
    {
        "content": "<p>Of course, but there isn't support for inferring what is or isn't simple type proof munging. One could imagine having a \"fin (BB(n))\".</p>",
        "id": 244138030,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1624884077
    },
    {
        "content": "<p>Johan, thank you for letting me know.</p>",
        "id": 244138236,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624884177
    },
    {
        "content": "<p>First, you are working with different types. It's only a proposition that they're equal. And you haven't included that proposition in your lemma. You might also have a proposition that they're not equal! What should the system infer then about the types?</p>",
        "id": 244138273,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1624884195
    },
    {
        "content": "<p>what if I include it in the lemma <code>lemma silly (h: m=n): f=g := sorry</code></p>",
        "id": 244138416,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624884256
    },
    {
        "content": "<p>As a rule of thumb: equality of types is evil, bad-behaved, and should be avoided, unless it is definitional equality.</p>",
        "id": 244138521,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1624884321
    },
    {
        "content": "<p>(Note: a rule of thumb is exactly that: a rule of thumb.)</p>",
        "id": 244138562,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1624884346
    },
    {
        "content": "<p>Alex, equality of two terms of different types will always be an error. Do you mean, that for all inputs, the two functions are the same, modulo type modification?</p>",
        "id": 244138912,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1624884498
    },
    {
        "content": "<p>That requires an axiom (functional extensionality) to prove, and using equiv.cast or other casts to state.</p>",
        "id": 244138995,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1624884542
    },
    {
        "content": "<p>In the previous one <code>fin (s * (p * m)) = fin (s * p * m)</code> is decidedly equal if I am correct. The trouble is that I don't know how to make Lean recognise this when parsing.</p>",
        "id": 244138997,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624884543
    },
    {
        "content": "<p>The trouble is not how to prove it. It is that the statement reports an error.</p>",
        "id": 244139096,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624884601
    },
    {
        "content": "<p>One way to make it recognize it is by providing the explicit cast, which is fin.cast (your_proof)</p>",
        "id": 244139097,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1624884601
    },
    {
        "content": "<p>Thanks, Yakov. Could you please give a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 244139207,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624884649
    },
    {
        "content": "<p>It might be enlightening for you to read <a href=\"https://xenaproject.wordpress.com/2020/07/03/equality-specifications-and-implementations/\">https://xenaproject.wordpress.com/2020/07/03/equality-specifications-and-implementations/</a></p>",
        "id": 244139538,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1624884825
    },
    {
        "content": "<p>What I'm saying is that lean+mathlib doesn't do arbitrary type equality \"fixing\" like you're trying to do unless you tell it to, using cast or its relatives. And the proof can of course be a tactic, or any strength you like. \"cast\" and its relatives are exactly the ways to get it to consider types as equal.</p>",
        "id": 244139551,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1624884832
    },
    {
        "content": "<p>Here's an example from mathlib:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Given a finset `s` of cardinality `k` in a linear order `α`, the map `order_iso_of_fin s h`</span>\n<span class=\"sd\">is the increasing bijection between `fin k` and `s` as an `order_iso`. Here, `h` is a proof that</span>\n<span class=\"sd\">the cardinality of `s` is `k`. We use this instead of an iso `fin s.card ≃o s` to avoid</span>\n<span class=\"sd\">casting issues in further uses of this function. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">order_iso_of_fin</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">k</span> <span class=\"bp\">≃</span><span class=\"n\">o</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">order_iso.trans</span> <span class=\"o\">(</span><span class=\"n\">fin.cast</span> <span class=\"o\">((</span><span class=\"n\">length_sort</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span> <span class=\"bp\">$</span>\n  <span class=\"o\">(</span><span class=\"n\">s.sort_sorted_lt.nth_le_iso</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"bp\">$</span> <span class=\"n\">order_iso.set_congr</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">$</span>\n    <span class=\"n\">set.ext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">mem_sort</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 244139930,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1624885044
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"408694\">@Alex Zhang</span> Sorry, I messed up. My rule of thumb should have mentioned \"definitional equality\" not decidable equality.</p>",
        "id": 244140043,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1624885093
    },
    {
        "content": "<p>With the caveat that definitional equality might hide a very expensive computation.</p>",
        "id": 244140188,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1624885166
    },
    {
        "content": "<p>Suppose a = b is a propositional equality and <code>h: a=b</code>. Is there a way to \"cheat\" Lean such that Lean will recognise <code>a=b</code> as a definitional equality after?</p>",
        "id": 244141892,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624885963
    },
    {
        "content": "<p>What do you mean by cheat? That expressions like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">examples</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>are valid expressions?</p>",
        "id": 244142142,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1624886089
    },
    {
        "content": "<p>Nope. I'm not an expert, but I think you are looking for an extensional type theory, or something like that. Those exist, but have their own set of problems...</p>",
        "id": 244142151,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1624886092
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/Theorem.20Formalization/near/244142142\">said</a>:</p>\n<blockquote>\n<p>What do you mean by cheat? That expressions like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">examples</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>are valid expressions?</p>\n</blockquote>\n<p>Yes, just like this.</p>",
        "id": 244142619,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624886315
    },
    {
        "content": "<p>That shouldn't typecheck, right?</p>",
        "id": 244142668,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1624886341
    },
    {
        "content": "<p>Correct, that is not a valid expression. But this is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">cast</span> <span class=\"n\">h.symm</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 244142713,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1624886368
    },
    {
        "content": "<p>Equality needs both arguments to be of the same type. You either need a cast with <code>h</code> or use <code>heq</code> instead</p>",
        "id": 244142741,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1624886384
    },
    {
        "content": "<p>You could extend lean (probably easier in lean4) to try to unify types more aggressively. That might approximate what you want. For example (also, don't do this please!)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.basic</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"n\">x</span> <span class=\"bp\">`</span> <span class=\"bp\">=</span><span class=\"n\">F</span> <span class=\"bp\">`</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">cast</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span><span class=\"n\">F</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 244143010,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1624886515
    },
    {
        "content": "<p>There are probably some scary type-theory contradictions or undecidability issues with approaches like this, having to do with <code>\\omega</code> and <code>\\Omega</code>. One could probably write a heuristic based unifier that could avoid such issues and have pretty errors...</p>",
        "id": 244143199,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1624886608
    },
    {
        "content": "<p>OR just use <code>cast</code> and its relatives explicitly when you want to do type equality. This is nice because you can get other nice properties, for example, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin.cast\">docs#fin.cast</a> is order-preserving. There are many lemmas about <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.cast\">docs#equiv.cast</a> and how it operates when used in composition and simplifies.</p>",
        "id": 244143355,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1624886676
    },
    {
        "content": "<p>But this topic is some of the friction of formalization. And the ways to formalize a particular statement require using the tools of formalization, rather than trying to cram set-theoretic like operations into the formalization.</p>",
        "id": 244143461,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1624886730
    },
    {
        "content": "<p>What are you referring to by omega?</p>",
        "id": 244143604,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1624886781
    },
    {
        "content": "<p>Kevin's, Anne's, and others' suggestions regarding generalizing your definitions to arbitrary types, breaking them up into digestable functions, etc -- these came from much experience working with the formalization and internalizing approaches that don't hit the \"issue\" you're faced with at the moment.</p>",
        "id": 244143680,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1624886814
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329243\">@Horatiu Cheval</span> There was a recent paper shared in Zulip about forming expressions that do not terminate when trying to normalize them, that had to do with the Omega combinator. Let me see if I can find it.</p>",
        "id": 244143951,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1624886942
    },
    {
        "content": "<p>Oh, I heard about that. No need to search for it</p>",
        "id": 244144156,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1624887026
    },
    {
        "content": "<p>I just didn't know if it was that, or some other well established omega terminology I didn't know</p>",
        "id": 244144271,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1624887074
    },
    {
        "content": "<p>Many thanks to all of you!!</p>",
        "id": 244154211,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624891012
    },
    {
        "content": "<p>Although I can now get around this problem by using cast as Yakov suggested or using coercions, Kevin's suggestion of defining the product in a more general setting seems pretty good, and I may change my defn later and change my current defn to like <code>fin_Kronecker_prodcut</code>.</p>",
        "id": 244156628,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624891937
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  Thank you for letting me know this. As I noticed that the more abstract tensor product has already been in the matlib, I am working with the Kronecker product in a direct and non-abstract way. It seems that that thread is doing a very abstract way as well. If you have any suggestion, please let me know!</p>",
        "id": 244157667,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624892365
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Kevin, in your way of getting around this problem, should the statement of the associativity actually be'' A  \\ox B \\ox C isomorphic to A  \\ox (B \\ox C)''?</p>",
        "id": 244372003,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1625021296
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"408694\">@Alex Zhang</span> yes, isomorphisms are the way to go</p>",
        "id": 244376976,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1625028211
    },
    {
        "content": "<p>I have the goal</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⊢</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">×</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">⊗</span><span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">C</span><span class=\"bp\">⊗</span><span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">),</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">i_1</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"o\">),</span> <span class=\"n\">A</span> <span class=\"n\">i</span> <span class=\"n\">i_1</span> <span class=\"bp\">*</span> <span class=\"n\">C</span> <span class=\"n\">i_1</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">⊗λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">i_1</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">B</span> <span class=\"n\">i</span> <span class=\"n\">i_1</span> <span class=\"bp\">*</span> <span class=\"n\">D</span> <span class=\"n\">i_1</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>after using <code>simp [dot_product]</code>.<br>\nBut I do want to have <code>i</code> in the goal written as the form <code>( , )</code>. What can I do?</p>",
        "id": 244380953,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1625033270
    },
    {
        "content": "<p>Wait, in your question above, are <code>A</code>, <code>B</code>, <code>C</code> matrices or rings?</p>",
        "id": 244381006,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1625033313
    },
    {
        "content": "<p>Johan, they are matrices.</p>",
        "id": 244381060,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1625033369
    },
    {
        "content": "<p>Hmm, then I'm confused. What do you mean by matrices being isomorphic?</p>",
        "id": 244381282,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1625033568
    },
    {
        "content": "<p>Oh, sorry for the confusion. I am just asking a question unrelated to the previous one.</p>",
        "id": 244381389,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1625033702
    },
    {
        "content": "<p>The problem is just that I would like to express the first <code>i</code> in the goal after using <code>simp [dot_product]</code> as a pair... but I don't know if there is a way to doing this.</p>",
        "id": 244381516,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1625033833
    },
    {
        "content": "<p>Well, that means you need to show that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∑</mo><mo stretchy=\"false\">(</mo><mi>i</mi><mo>:</mo><mi>J</mi><mo>×</mo><mi>M</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>f</mi><mi>o</mi><mi>o</mi><mi>b</mi><mi>a</mi><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">\\sum (i : J \\times M), foobar</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">oo</span><span class=\"mord mathnormal\">ba</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> is the same as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∑</mo><mo stretchy=\"false\">(</mo><msub><mi>i</mi><mn>1</mn></msub><mo>:</mo><mi>J</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo>∑</mo><mo stretchy=\"false\">(</mo><msub><mi>i</mi><mn>2</mn></msub><mo>:</mo><mi>M</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>f</mi><mi>o</mi><mi>o</mi><mi>b</mi><mi>a</mi><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">\\sum (i_1 : J), \\sum (i_2 : M), foobar</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">oo</span><span class=\"mord mathnormal\">ba</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span>.</p>",
        "id": 244381780,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1625034118
    },
    {
        "content": "<p>There must be some lemmas about <code>sum</code> and <code>product</code>.</p>",
        "id": 244381827,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1625034141
    },
    {
        "content": "<p><code>rw</code> to the left with <code>finset.univ_product_univ</code>, and then use <code>finset.sum_product</code></p>",
        "id": 244381864,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1625034202
    },
    {
        "content": "<p>Thanks a lot! I think your answer is one step further from my question. As Lean know that <code>i</code> has type <code> J prod M</code>, my question is simply to represent <code>i</code> as a pair somehow. I am not sure whether Lean supports such a feature. Anyway, I think your solution does help!</p>",
        "id": 244382153,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1625034478
    },
    {
        "content": "<p>If you know a way of just rewriting <code>i</code> without split the sum into two sums, please also let me know!</p>",
        "id": 244382220,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1625034547
    },
    {
        "content": "<p>It seems that lean does not allow me to naively rewrite <code>i</code> to say <code>\\&lt;i1, i2&gt;</code> as <code>i</code> is not in the context.</p>",
        "id": 244382425,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1625034743
    },
    {
        "content": "<p>You could try to simp backwards with something like <code>prod.eta</code> or whatever it is called.</p>",
        "id": 244382727,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1625035065
    }
]
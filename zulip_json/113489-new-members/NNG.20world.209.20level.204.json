[
    {
        "content": "<p><a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/?world=9&amp;level=4\">world 9 level 4</a> shows an example where a stronger (more general) version of the theorem is provable but (supposedly) a weaker version can't be proved. This is very counter-intuitive. Is this a limitation of Lean? And honestly I can't tell the differences between the \"stronger\" theorem <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mtext> </mtext><mi>c</mi><mo>:</mo><mi mathvariant=\"double-struck\">N</mi><mo separator=\"true\">,</mo><mi>h</mi><mi>a</mi><mo>:</mo><mi>a</mi><mo mathvariant=\"normal\">≠</mo><mn>0</mn><mo>⊢</mo><mi mathvariant=\"normal\">∀</mi><mi>b</mi><mo separator=\"true\">,</mo><mi>a</mi><mi>b</mi><mo>=</mo><mi>a</mi><mi>c</mi><mo>⇒</mo><mi>b</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding=\"application/x-tex\"> a \\, c: \\N, ha: a \\ne 0 \\vdash \\forall b, ab = ac \\Rightarrow b = c </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">ha</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">b</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">ab</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span> and the \"weaker\" theorem <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mtext> </mtext><mi>b</mi><mtext> </mtext><mi>c</mi><mo>:</mo><mi mathvariant=\"double-struck\">N</mi><mo separator=\"true\">,</mo><mi>h</mi><mi>a</mi><mo>:</mo><mi>a</mi><mo mathvariant=\"normal\">≠</mo><mn>0</mn><mo>⊢</mo><mi>a</mi><mi>b</mi><mo>=</mo><mi>a</mi><mi>c</mi><mo>⇒</mo><mi>b</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding=\"application/x-tex\"> a\\, b\\, c : \\N,  ha: a \\ne 0 \\vdash ab = ac \\Rightarrow b = c </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">ha</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">ab</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span>. It feels a bit weird to have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi></mrow><annotation encoding=\"application/x-tex\"> \\forall </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span></span></span></span> in the game for the first time (a mix of set-theoretic language and type-theoretic language)?</p>",
        "id": 271093035,
        "sender_full_name": "Matt Yan",
        "timestamp": 1644307828
    },
    {
        "content": "<p>That's very common with induction, isn't it? You sometimes have to strengthen the induction hypothesis for the induction to carry through.</p>",
        "id": 271093680,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644308318
    },
    {
        "content": "<p>Ha no it's not a limitation of Lean! It's the way mathematics works.</p>",
        "id": 271094874,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644309122
    },
    {
        "content": "<p>Guess I'll just have to step up my induction game. Personally, I think there is a more intuitive proof without modifying the theorem, which can't be used somehow? If you just do a basic <code>induction c with n hn</code>, you'll end up with <code>hn: ab = an -&gt; b=n</code>. In a classical proof, I would immediately discuss by cases: <br>\nCase 1.  ab = an is true<br>\nthis can then nicely substituted into the goal to show it's vacuously true (the antecedent becomes a = 0 and is false)<br>\nCase 2. ab = an is false<br>\nthis means the induction hypothesis is vacously true and anything follows.</p>\n<p>I remember doing similar stuff with <code>by_cases</code> to a term of Proposition type...but somehow this can't be done for <code>a = b</code> types?</p>",
        "id": 271094934,
        "sender_full_name": "Matt Yan",
        "timestamp": 1644309138
    },
    {
        "content": "<p>Wait what is your goal in that context?</p>",
        "id": 271095479,
        "sender_full_name": "Daniel Roca González",
        "timestamp": 1644309459
    },
    {
        "content": "<p>Probably the way to think about this is to step back and actually ask yourself \"what <em>is</em> induction?\" . Here's what it is. You have some context (some variables, or whatever, which are fixed and which you can use to make mathematical statements) and then infinitely many true-false statements P(0), P(1), P(2), ... . You want to prove them all. The principle of induction says that if you prove P(0) and \"forall n, P(n) - P(n+1)\" then you can deduce them all. The subtlety in this level is that if you have some stuff in your context, like a variable b, then that variable is fixed. If the P(n) all depend on b then b can't change as you start manipulating the P(n). However if your context doesn't contain the variable b but P(n) is of the form \"for all b, (something to do with b and n)\" then this is different, because if you know P(n) then you know a statement about all b, and you might want to prove P(n+1) for a specific b by using P(n) for b+1 or something like that. You can't do this if b is in your context, you can only do it if it's being universally quantified over as part of P.</p>\n<p>In short, when you're doing induction to prove a statement P, in a language like Lean, you have to really think hard about precisely what P says, and in particular which variables are free and which are bound.</p>",
        "id": 271095500,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644309464
    }
]
[
    {
        "content": "<p>Hi, I'm having problems figuring out this simple example.  My second subgoal seems to bring me back to what I am trying to prove to begin with, so my argument is circular:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">simplify_or</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">hpq</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">hnp</span><span class=\"o\">,</span>\n    <span class=\"n\">by_cases</span>\n      <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"k\">show</span> <span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">hnp</span> <span class=\"n\">hp</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 216803393,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605461180
    },
    {
        "content": "<p>Do you have a paper proof? It seems to me your problems have nothing to with lean here</p>",
        "id": 216803866,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605461773
    },
    {
        "content": "<p>And I will again assert that in some sense your main problem is that you're not using tactic mode. Did you play through the natural number game yet? There are a bunch of levels like this. My understanding is that your ultimate goal is to do mathematics in Lean. I teach students how to do mathematics in lean and I certainly don't teach them all this assume stuff. Theorem proving in lean, at least the earlier chapters, are written mainly with computer scientists in mind. Those early chapters teach you that a proof is a function, but you don't actually need to know this.</p>",
        "id": 216804053,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605461990
    },
    {
        "content": "<p>Well I do happen to have a PhD in Computer Science and a long time ago I worked for Dana Scott and later on spent time in Gerard Huet's lab, so in that sense \"computer scientists in mind\" works for me.   The above is a subgoal of this proof, for a point where I am getting stuck:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">or_distributivity2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∧</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hl</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">h.left</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hr</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">h.right</span><span class=\"o\">,</span>\n    <span class=\"n\">by_cases</span>\n      <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">or.inl</span> <span class=\"n\">hp</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>where the larger context is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">or_distributivity1</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∧</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">⟨</span> <span class=\"n\">h.elim</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">or.inl</span> <span class=\"n\">h1</span><span class=\"o\">)</span>\n                <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"n\">or.inr</span> <span class=\"n\">h2.left</span><span class=\"o\">)</span> <span class=\"o\">,</span>\n         <span class=\"n\">h.elim</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">or.inl</span> <span class=\"n\">h1</span><span class=\"o\">)</span>\n                <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"n\">or.inr</span> <span class=\"n\">h2.right</span><span class=\"o\">)</span> <span class=\"o\">⟩</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">or_distributivity</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∧</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span>  <span class=\"o\">⟩</span>\n</code></pre></div>\n<p>Apparently the direction of <code>or_distributivity2</code> is harder than <code>or_distributivity1</code> because ProofWiki punts on it with the comment <a href=\"https://proofwiki.org/wiki/Rule_of_Distribution/Disjunction_Distributes_over_Conjunction/Left_Distributive/Formulation_2/Reverse_Implication\">This needs considerable tedious hard slog to complete it</a>.</p>\n<p>Above it was suggested I explore _ mode which is what I'm doing.  Tactic mode is Chapter 5, I'm not there yet!</p>",
        "id": 216804478,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605462385
    },
    {
        "content": "<p>I will go try the natural number game now and see if that gives me more intuition.</p>",
        "id": 216804507,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605462414
    },
    {
        "content": "<p>I know tactic mode (easy mode) is chapter 5 and I know you're not there yet, and what I'm trying to say is that if your ultimate goal is to do probability in lean then it's not clear to me why you are struggling through basic logic proofs in hard mode.</p>",
        "id": 216804612,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605462517
    },
    {
        "content": "<p>I'm struggling through because I don't know Lean and I am trying to do baby steps before I do something fancy like find a type for probability spaces that lets me generalize the type of probability distribution functions.  Since I am getting stuck on not A and A or B implies B, baby steps seem prudent.</p>",
        "id": 216804765,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605462681
    },
    {
        "content": "<p>I'm on natural number game now, then I will come back to this when done.</p>",
        "id": 216804776,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605462700
    },
    {
        "content": "<p>Try the natural number game. Tactic mode makes all this stuff easy.</p>",
        "id": 216804804,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605462723
    },
    {
        "content": "<p>I'm <a href=\"https://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/\">there now</a>, thank you for your help!</p>",
        "id": 216804858,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605462756
    },
    {
        "content": "<p>It is also written for beginners but shows you how to do logic puzzles like this in what I believe is a far more intuitive way.</p>",
        "id": 216804871,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605462767
    },
    {
        "content": "<p>Disclaimer: I wrote it ;-)</p>",
        "id": 216804880,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605462787
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> , I'm stuck on level 2 of Addition World.  I got to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">add_assoc</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">zero_add</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">zero_add</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>but this puts me at</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">case</span> <span class=\"n\">mynat.succ</span>\n<span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">succ</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which seems one <code>succ</code> more complicated than what I was trying to prove to begin with.</p>\n<p>I looked at <a href=\"https://proofwiki.org/wiki/Integer_Addition_is_Associative/Proof_2\">ProofWiki</a> and they do something very very fancy which I think would be interesting to do in Lean once I finish the number game tutorial.  It looks like they are doing something with set theory and integer equivalence classes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Let</span> <span class=\"bp\">𝑥=</span><span class=\"o\">[[</span><span class=\"bp\">𝑎</span><span class=\"o\">,</span><span class=\"bp\">𝑏</span><span class=\"o\">]],</span> <span class=\"bp\">𝑦=</span><span class=\"o\">[[</span><span class=\"bp\">𝑐</span><span class=\"o\">,</span><span class=\"bp\">𝑑</span><span class=\"o\">]]</span> <span class=\"n\">and</span> <span class=\"bp\">𝑧=</span><span class=\"o\">[[</span><span class=\"bp\">𝑒</span><span class=\"o\">,</span><span class=\"bp\">𝑓</span><span class=\"o\">]]</span> <span class=\"n\">for</span> <span class=\"n\">some</span> <span class=\"bp\">𝑥</span><span class=\"o\">,</span><span class=\"bp\">𝑦</span><span class=\"o\">,</span><span class=\"bp\">𝑧∈</span><span class=\"n\">ℤ.</span>\n\n<span class=\"n\">Then</span><span class=\"o\">:</span>\n\n<span class=\"bp\">𝑥+</span><span class=\"o\">(</span><span class=\"bp\">𝑦+𝑧</span><span class=\"o\">)</span> <span class=\"bp\">=</span>               <span class=\"o\">[[</span><span class=\"bp\">𝑎</span><span class=\"o\">,</span><span class=\"bp\">𝑏</span><span class=\"o\">]]</span><span class=\"bp\">+</span><span class=\"o\">([[</span><span class=\"bp\">𝑐</span><span class=\"o\">,</span><span class=\"bp\">𝑑</span><span class=\"o\">]]</span><span class=\"bp\">+</span><span class=\"o\">[[</span><span class=\"bp\">𝑒</span><span class=\"o\">,</span><span class=\"bp\">𝑓</span><span class=\"o\">]])</span>           <span class=\"n\">Definition</span> <span class=\"n\">of</span> <span class=\"n\">Integers</span>\n<span class=\"bp\">=</span>               <span class=\"o\">[[</span><span class=\"bp\">𝑎</span><span class=\"o\">,</span><span class=\"bp\">𝑏</span><span class=\"o\">]]</span><span class=\"bp\">+</span><span class=\"o\">[[</span><span class=\"bp\">𝑐+𝑒</span><span class=\"o\">,</span><span class=\"bp\">𝑑+𝑓</span><span class=\"o\">]]</span>         <span class=\"n\">Definition</span> <span class=\"n\">of</span> <span class=\"n\">Integer</span> <span class=\"n\">Addition</span>\n<span class=\"bp\">=</span>               <span class=\"o\">[[</span><span class=\"bp\">𝑎+</span><span class=\"o\">(</span><span class=\"bp\">𝑐+𝑒</span><span class=\"o\">),</span><span class=\"bp\">𝑏+</span><span class=\"o\">(</span><span class=\"bp\">𝑑+𝑓</span><span class=\"o\">)]]</span>         <span class=\"n\">Definition</span> <span class=\"n\">of</span> <span class=\"n\">Integer</span> <span class=\"n\">Addition</span>\n<span class=\"bp\">=</span>               <span class=\"o\">[[(</span><span class=\"bp\">𝑎+𝑐</span><span class=\"o\">)</span><span class=\"bp\">+𝑒</span><span class=\"o\">,(</span><span class=\"bp\">𝑏+𝑑</span><span class=\"o\">)</span><span class=\"bp\">+𝑓</span><span class=\"o\">]]</span>         <span class=\"n\">Natural</span> <span class=\"n\">Number</span> <span class=\"n\">Addition</span> <span class=\"n\">is</span> <span class=\"n\">Associative</span>\n<span class=\"bp\">=</span>               <span class=\"o\">[[</span><span class=\"bp\">𝑎+𝑐</span><span class=\"o\">,</span><span class=\"bp\">𝑏+𝑑</span><span class=\"o\">]]</span><span class=\"bp\">+</span><span class=\"o\">[[</span><span class=\"bp\">𝑒</span><span class=\"o\">,</span><span class=\"bp\">𝑓</span><span class=\"o\">]]</span>         <span class=\"n\">Definition</span> <span class=\"n\">of</span> <span class=\"n\">Integer</span> <span class=\"n\">Addition</span>\n<span class=\"bp\">=</span>               <span class=\"o\">([[</span><span class=\"bp\">𝑎</span><span class=\"o\">,</span><span class=\"bp\">𝑏</span><span class=\"o\">]]</span><span class=\"bp\">+</span><span class=\"o\">[[</span><span class=\"bp\">𝑐</span><span class=\"o\">,</span><span class=\"bp\">𝑑</span><span class=\"o\">]])</span><span class=\"bp\">+</span><span class=\"o\">[[</span><span class=\"bp\">𝑒</span><span class=\"o\">,</span><span class=\"bp\">𝑓</span><span class=\"o\">]]</span>           <span class=\"n\">Definition</span> <span class=\"n\">of</span> <span class=\"n\">Integer</span> <span class=\"n\">Addition</span>\n<span class=\"bp\">=</span>               <span class=\"o\">(</span><span class=\"bp\">𝑥+𝑦</span><span class=\"o\">)</span><span class=\"bp\">+𝑧</span>         <span class=\"n\">Definition</span> <span class=\"n\">of</span> <span class=\"n\">Integers</span>\n</code></pre></div>\n<p>Is this representation of integers already in Lean somewhere?  They are using this <a href=\"https://proofwiki.org/wiki/Definition:Integer/Formal_Definition\">extremely complicated construction</a>.</p>",
        "id": 216820538,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605482670
    },
    {
        "content": "<p>Well, you have the list of things you've proved so far in the frame on the left.</p>",
        "id": 216820730,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605483090
    },
    {
        "content": "<p>Is there some way to get the expression to be of a form such that one of the lemmas on the left can be used?</p>",
        "id": 216820744,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605483107
    },
    {
        "content": "<p>I see I could left-rewrite <code>add_succ</code> maybe.</p>",
        "id": 216820797,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605483162
    },
    {
        "content": "<p>Yes, integers are in Lean. But they are constructed by using the naturals, which is exactly what you're proving things about right now. In any case, one shouldn't need integers to solve this world.</p>",
        "id": 216820806,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605483182
    },
    {
        "content": "<p>What do you mean by \"left-rewrite <code>add_succ</code>\"?</p>",
        "id": 216820824,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605483223
    },
    {
        "content": "<p>I don't see a <code>x + succ y</code> in your goal expression, not a <code>succ (x + y)</code>.</p>",
        "id": 216820868,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605483259
    },
    {
        "content": "<p>In fact, I don't think there _is_ a way to get the expression you have currently into a form where <code>add_succ</code> will help you, given the theorems you have in your toolset.</p>",
        "id": 216820895,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605483335
    },
    {
        "content": "<p>Perhaps there was a step in your proof that led you down the wrong path.</p>",
        "id": 216820900,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605483352
    },
    {
        "content": "<p>What I mean by left-rewrite is to use this notation rw ← h but it doesn't really apply because the <code>succ</code> is showing up on the left and not the right.</p>\n<p>I will try to start over. </p>\n<p>Separately, is the proof wiki complicated construction an interesting exercise to do in Lean?  Where is that coming from?  Why do they do that as opposed to starting with the Peano axioms?</p>",
        "id": 216820976,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605483437
    },
    {
        "content": "<p>I.e. the Construction of Inverse Completion thing.  It seems rather the long way around, but I'm sure there's some interesting motivation for it.</p>",
        "id": 216821025,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605483501
    },
    {
        "content": "<p>I don't know anything about proof wiki but I do know that the reason you're stuck is that you didn't follow the hint.</p>",
        "id": 216821049,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605483580
    },
    {
        "content": "<p>When they say \"Definition of Integer Addition\", I'm not sure exactly what they mean -- they are distributing the addition into the pairs. Then they say \"Natural Number Addition is Associative\". That is exactly what you're trying to prove here.</p>",
        "id": 216821111,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605483648
    },
    {
        "content": "<p>My statement seems tautological, but I guess it is an even stronger hint than the hint in the NNG, since I now checked ProofWiki, and there is a link to the solution. <span aria-label=\"oh no\" class=\"emoji emoji-1f615\" role=\"img\" title=\"oh no\">:oh_no:</span></p>",
        "id": 216821140,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605483723
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"364351\">Lars Ericson</span> <a href=\"#narrow/stream/113489-new-members/topic/need.20help.20on.20simple.20proof/near/216820976\">said</a>:</p>\n<blockquote>\n<p>Separately, is the proof wiki complicated construction an interesting exercise to do in Lean?  Where is that coming from?  Why do they do that as opposed to starting with the Peano axioms?</p>\n</blockquote>\n<p>You linked to a proof of associativity about the <strong>integers</strong> but the Peano axioms are about the <strong>natural numbers</strong>.</p>",
        "id": 216821230,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605483919
    },
    {
        "content": "<p>Or in handwavy CS lingo, a statement about unbounded <code>int</code> vs unbounded <code>uint</code>.</p>",
        "id": 216821290,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605484002
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>  you're right!  For the Z, as opposed to N, I suppose that Lean does the same construction as <a href=\"https://proofwiki.org/wiki/Definition:Integer/Formal_Definition\">ProofWiki</a>, which is also replicated in <a href=\"https://en.wikipedia.org/wiki/Integer#Construction\">Wikipedia</a>. Is that correct?</p>",
        "id": 216821349,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605484095
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> you're right I followed the hint the wrong way, I applied it to leftmost variable, not rightmost variable.  Thanks!</p>",
        "id": 216821371,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605484193
    },
    {
        "content": "<p>At this early stage you can manipulate a+0 and a+succ(b) but are less good at things like succ(b)+a so it's really important that you induct on the variable as far to the right as possible. Later on this becomes less of an issue.</p>",
        "id": 216821484,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605484373
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"364351\">Lars Ericson</span> <a href=\"#narrow/stream/113489-new-members/topic/need.20help.20on.20simple.20proof/near/216821349\">said</a>:</p>\n<blockquote>\n<p>Thanks <span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span>  you're right!  For the Z, as opposed to N, I suppose that Lean does the same construction as <a href=\"https://proofwiki.org/wiki/Definition:Integer/Formal_Definition\">ProofWiki</a>, which is also replicated in <a href=\"https://en.wikipedia.org/wiki/Integer#Construction\">Wikipedia</a>. Is that correct?</p>\n</blockquote>\n<p>No. Lean uses a representation of <code>int = nat + nat</code> rather than <code>(nat x nat) / ~</code> where <code>(a, b) ~ (c, d) &lt;-&gt; a + d = b + c</code></p>",
        "id": 216821491,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605484410
    },
    {
        "content": "<p>That is, in lean an integer is either a number of the form <code>n</code> or <code>-(n+1)</code> where <code>n : nat</code></p>",
        "id": 216821536,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605484465
    },
    {
        "content": "<p>and all the operations are defined by cases</p>",
        "id": 216821539,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605484477
    },
    {
        "content": "<p>The quotient construction is avoided because it is less constructive. Metamath would normally use a construction like this using equivalence classes, but in this case it also avoids the construction for <code>int</code> because it brings in usage of the axiom of infinity earlier than necessary (the equivalence classes are infinite sets, so you don't know they exist without the axiom of infinity, even though you are just proving properties about a discrete countable set).</p>",
        "id": 216821661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605484697
    },
    {
        "content": "<p>I think Metamath uses the subset of <code>nat x nat</code> of elements which are zero in at least one coordinate, and still kind of works with the equivalence relation as a \"reduction\" to the canonical elements</p>",
        "id": 216821674,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605484754
    },
    {
        "content": "<p>Thank <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> for the detail on Z.<br>\n<span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> doing the induction on the rightmost variable, I am stuck in a loop again.  This:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">add_assoc</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n <span class=\"kd\">begin</span>\n<span class=\"n\">induction</span> <span class=\"n\">c</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">add_zero</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">add_succ</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">add_zero</span><span class=\"o\">,</span>\n<span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">add_succ</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">add_succ</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">add_succ</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">add_succ</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>leaves me with </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">case</span> <span class=\"n\">mynat.succ</span>\n<span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>which is what I was trying to prove wrapped with a <code>succ</code>.</p>",
        "id": 216821910,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605485133
    },
    {
        "content": "<p>yes, but now notice that <code>hd</code> is useful</p>",
        "id": 216821957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605485167
    },
    {
        "content": "<p>Oh right thank you I should be able to do <code>rw hd</code>.</p>",
        "id": 216821984,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605485248
    },
    {
        "content": "<p>by the way are you still trying to solve the first question in this thread? The important step is to use <code>or.elim hpq</code></p>",
        "id": 216822034,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605485289
    },
    {
        "content": "<p>you don't need <code>by_cases</code></p>",
        "id": 216822043,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605485319
    },
    {
        "content": "<p>Thanks, I will return to that when I am finished the the Natural Number Game.  How do I apply <code>hd</code> as a rewrite rule?  <code>rw hd</code> doesn't work.</p>",
        "id": 216822111,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605485405
    },
    {
        "content": "<p>it should</p>",
        "id": 216822115,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605485415
    },
    {
        "content": "<p>You're right, forgot the comma!</p>",
        "id": 216822118,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605485437
    },
    {
        "content": "<p>we need an emoji for this</p>",
        "id": 216822122,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605485449
    },
    {
        "content": "<p>Proof complete!</p>",
        "id": 216822133,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605485478
    },
    {
        "content": "<p>Hi, I'm getting stuck on this one.  It seems like I should be able to use the inductive hypothesis with substitution of terms, but I don't know how to do that.  This is level 6 of Multiplication World:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">succ_mul</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"n\">induction</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">zero_mul</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">zero_add</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">one_eq_succ_zero</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">one_mul</span><span class=\"o\">,</span>\n<span class=\"n\">refl</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>I am at</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">tactic</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">there</span> <span class=\"n\">are</span> <span class=\"n\">unsolved</span> <span class=\"n\">goals</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">case</span> <span class=\"n\">mynat.succ</span>\n<span class=\"n\">b</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"n\">d</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">d</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">b</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">d</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>Intuitively if I replaced the <code>d</code> in <code>hd</code> with <code>succ d</code> I should be done, but I don't know the tactic for that.</p>",
        "id": 216873088,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605534846
    },
    {
        "content": "<p>That isn't how induction works. You need to assume <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(n)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> and prove <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(n+1)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>; you can't just say \"well let's replace <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n+1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> in the inductive hypothesis and we're done\".</p>",
        "id": 216873512,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605535077
    },
    {
        "content": "<p>You can't replace d with succ(d) in an induction proof, or you'd be able to prove everything by induction (think about it: you know P(d), you want to prove P(d+1), so if you could just replace d in the hypothesis P(d) with d+1 then you'd be done). Your problem is that you have still not internalised the hint given on addition world level 2.</p>",
        "id": 216873518,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605535080
    },
    {
        "content": "<p>Put differently, the hypothesis <code>hd</code> in the proof state is something you know about the specific value <code>d</code> in the proof state. If <code>hd</code> was about all <code>d</code> then there would be a <code>∀</code> in it.</p>",
        "id": 216874025,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605535314
    },
    {
        "content": "<p>Does this one need to start with an induction?  Or do the other tactics suffice?  I've been starting proofs with induction as a magic wand.  In this case I don't have any tactics or prior theorems available which would rewrite <code>succ(succ d)</code> or <code>succ (d*b)</code> so I'm stuck.  I've tried induction on  <code>b</code> and <code>a</code> and they both come to this point.</p>",
        "id": 216874488,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605535506
    },
    {
        "content": "<p>Is the addition world level 2 hint \"figure out the math proof first\"?</p>",
        "id": 216874715,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605535599
    },
    {
        "content": "<p>I guess it's a bit unfair because the key point is the proof structure needs to match the definition of <code>*</code></p>",
        "id": 216874853,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605535668
    },
    {
        "content": "<p>The addition world level 2 hint is that if in doubt, do induction on the rightmost variable because that's the variable you know the most theorems about</p>",
        "id": 216875867,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605536068
    },
    {
        "content": "<p>Following <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> 's suggestion I did the proof by hand and I'll see if I can translate this with the available tactics:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">succ</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">*</span><span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"n\">qed</span>\n</code></pre></div>",
        "id": 216881735,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605538689
    },
    {
        "content": "<p>How can I apply <code>one_mul</code> only to the rightmost occurrence of <code>b</code> in <code>(a + 1) * b = a * b + b</code>?</p>",
        "id": 216882582,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605539024
    },
    {
        "content": "<p>That is, with the tactics available, instead of above proof, I want to do something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">succ</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span>\n<span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span>\n<span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span>\n<span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">b</span>\n</code></pre></div>",
        "id": 216883004,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605539174
    },
    {
        "content": "<p>It doesn't seem that I can restrict application of the tactic to a single term, so if I start with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">succ_mul</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"n\">rw</span> <span class=\"n\">succ_eq_add_one</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">one_mul</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>this gives</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>I want to \"undo\" the first two <code>1*b</code> substitutions.  However <code>rw one_mul</code> does 3 applications at once and simulatenously undoes all of them so I get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>which undoes the <code>1*b</code> I'm trying to get on the rightmost term in the equation.</p>",
        "id": 216887123,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605540863
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"364351\">Lars Ericson</span> <a href=\"#narrow/stream/113489-new-members/topic/need.20help.20on.20simple.20proof/near/216881735\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">*</span><span class=\"n\">b</span>\n</code></pre></div>\n</blockquote>\n<p>Is this left distributivity really a fact that you have available at this point? It looks to me like you are proving a lemma that will be needed to prove distributivity later.</p>",
        "id": 216887307,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605540943
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> at this level I have available</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">mul_add</span>\n  <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>However now i see this is going in the wrong direction.  I amt rying to rewrite <code>a*b+1*b</code> to <code>(a+1)*b</code> so I actually need a <code>right_mul_add</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">right_mul_add</span>\n  <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"n\">t</span> <span class=\"bp\">=</span><span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">t</span><span class=\"bp\">+</span><span class=\"n\">b</span><span class=\"bp\">*</span><span class=\"n\">t</span>\n</code></pre></div>\n<p>so I guess I should prove that as a subgoal.</p>",
        "id": 216889061,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605541665
    },
    {
        "content": "<p>Well, that's true, except that I don't advise trying to prove it because you will find yourself needing the statement you're currently proving to do so!</p>",
        "id": 216889588,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605541891
    },
    {
        "content": "<p>In fact I expect this statement to show up in a couple levels.</p>",
        "id": 216889621,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605541908
    },
    {
        "content": "<p>I am confused about how often tactics are applied.  Often I need to type in a tactic multiple times to get it applied to more than one place in the equation.  In the above example a single application produced 3 substitutions.   Also the previous level pointed out <code>repeat {rw mul_succ}</code> to explicitly do multiple applications, which implies that otherwise I should only be seeing one application at a time.</p>",
        "id": 216891436,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605542599
    },
    {
        "content": "<p>So <code>rw mul_succ</code> is short for <code>rw mul_succ ?m1 ?m2</code>, so lean tries to find the first occurrence of <code>?m1 * succ (?m2)</code>; when it finds such an occurrence, it fills in actual values for ?m1 and ?m2, for example with <code>x</code> and <code>y</code>. Then it replaces all cases of <code>x * succ (y)</code>, but not any cases with other values for ?m1 and ?m2</p>",
        "id": 216898659,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1605545498
    },
    {
        "content": "<p>Did that make sense?</p>",
        "id": 216898788,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1605545529
    },
    {
        "content": "<p>Yes <span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span> thanks, what you are saying is that if <code>E</code> is the equation, it unifies <code>?m1 * succ (?m2)</code> with some subterm of  <code>E</code>.   Then (in Pythonish terms) it replaces <code>E</code> with <code>E.replace('{m1}*succ({m2}', '{m1}*{m2}+{m1}') </code>, where the replace will apply to all concrete matches.</p>",
        "id": 216901369,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605546651
    },
    {
        "content": "<p>So finally QED but steep learning curve for me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"n\">succ_eq_add_one</span><span class=\"o\">,</span>\n<span class=\"n\">induction</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">mul_zero</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">mul_zero</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">add_zero</span><span class=\"o\">,</span>\n<span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">mul_succ</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">mul_succ</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">succ_eq_add_one</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">add_assoc</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">add_assoc</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">d</span><span class=\"o\">),</span>\n<span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">add_assoc</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">add_comm</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"n\">refl</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 216908780,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605549946
    },
    {
        "content": "<p>Actually finally I can take the easy way out:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"n\">succ_eq_add_one</span><span class=\"o\">,</span>\n<span class=\"n\">induction</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">mul_zero</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">mul_zero</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">add_zero</span><span class=\"o\">,</span>\n<span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">mul_succ</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">mul_succ</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">succ_eq_add_one</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">simp</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 216909233,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605550139
    },
    {
        "content": "<p>I did quite  a bad job of making <code>simp</code> do what it is capable of, because when I made the game last year I didn't really know much at all about rewriting systems.</p>",
        "id": 216911095,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605550981
    },
    {
        "content": "<p>I finished all levels of Multiplication World (check marks on every level), but when I go to Main Page it is still blue, not green.</p>",
        "id": 216918013,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605554222
    },
    {
        "content": "<p>I'm afraid that part of the story was not the bit I did :-) But you can just go to any level, you can just ignore the blue/green thing.</p>",
        "id": 216918101,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605554274
    },
    {
        "content": "<p>I'm in level 6/8 of Power world and it is telling us to look at an invocation in level 9 of Multiplication World, namely</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">mul_assoc</span> <span class=\"n\">mul_comm</span> <span class=\"n\">mul_left_comm</span>\n</code></pre></div>\n<p>However it doesn't like this to be used inside a proof, and the GUI only allows typing into the proof.</p>",
        "id": 216923604,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605556952
    },
    {
        "content": "<p>The magic incantation has been whispered, you don't need to whisper it yourself.</p>",
        "id": 216924587,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605557375
    },
    {
        "content": "<p>In fact, it has to be whispered outside of the proof itself. What it means is that <code>mul_assoc</code>, <code>mul_comm</code>, <code>mul_left_comm</code> are now part of the <code>simp</code> set.</p>",
        "id": 216924703,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605557409
    },
    {
        "content": "<p>And you can just write <code>simp</code> to take care of any steps that you'd before need to rely on those lemmas. That's what the actual end of the MulWorld 9 info indicates:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"o\">(((</span><span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"n\">e</span><span class=\"bp\">=</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"bp\">*</span><span class=\"o\">((</span><span class=\"n\">b</span><span class=\"bp\">*</span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"n\">a</span><span class=\"o\">))</span><span class=\"bp\">*</span><span class=\"n\">d</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 216924786,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605557451
    },
    {
        "content": "<p>if you want to do that inside a proof, you would use <code>simp [mul_assoc, mul_comm, mul_left_comm]</code> instead of <code>simp</code>, but the magic incantation means that the latter means the same as the former</p>",
        "id": 216924792,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605557454
    },
    {
        "content": "<p>Thanks, I got there for <code>mul_pow</code>, it works as <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> mentioned it has already been whispered:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">pow_zero</span><span class=\"o\">},</span>\n<span class=\"n\">rw</span> <span class=\"n\">mul_one</span><span class=\"o\">,</span>\n<span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">pow_succ</span><span class=\"o\">},</span>\n<span class=\"n\">rw</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">simp</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 216935568,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605562450
    },
    {
        "content": "<p>Just curious, I am on 7 of Power world.  I found myself doing this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">pow_zero</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">mul_zero</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">pow_zero</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>I tried to shortcut the 3 <code>rw</code>s with this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">pow_zero</span><span class=\"o\">,</span> <span class=\"n\">mul_zero</span><span class=\"o\">],</span>\n</code></pre></div>\n<p>It didn't work, giving me the result</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rewrite</span> <span class=\"n\">tactic</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">did</span> <span class=\"n\">not</span> <span class=\"n\">find</span> <span class=\"kd\">instance</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">pattern</span> <span class=\"k\">in</span> <span class=\"n\">the</span> <span class=\"n\">target</span> <span class=\"n\">expression</span>\n  <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">^</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>So when would <code>simp [x,y,z]</code> work for tactics x,y,z?</p>",
        "id": 216936317,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605562817
    },
    {
        "content": "<p>that doesn't look like an error <code>simp</code> would give</p>",
        "id": 216937068,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605563218
    },
    {
        "content": "<p><code>simp</code> doesn't take tactics, it takes lemmas</p>",
        "id": 216937115,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605563242
    },
    {
        "content": "<p>Sorry <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> you're right, it actually eliminated the top inductive goal.  So I can shorten this proof a little:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">pow_zero</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">mul_zero</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">pow_zero</span><span class=\"o\">,</span>\n<span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">pow_succ</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">succ_eq_add_one</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">mul_add</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">mul_one</span><span class=\"o\">,</span>\n<span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">pow_add</span><span class=\"o\">,</span>\n<span class=\"n\">refl</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">pow_zero</span><span class=\"o\">,</span> <span class=\"n\">mul_zero</span><span class=\"o\">],</span>\n<span class=\"n\">rw</span> <span class=\"n\">pow_succ</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">succ_eq_add_one</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">mul_add</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">mul_one</span><span class=\"o\">,</span>\n<span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">pow_add</span><span class=\"o\">,</span>\n<span class=\"n\">refl</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 216937587,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605563492
    },
    {
        "content": "<p>I'm stuck on Advanced Proposition Level 8.  I have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">and_or_distrib_left</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n <span class=\"n\">split</span><span class=\"o\">,</span>\n<span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">left</span><span class=\"o\">,</span>\n<span class=\"n\">split</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">h.left</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">p</span> <span class=\"n\">qORr</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">qORr</span> <span class=\"k\">with</span> <span class=\"n\">q</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>This gets me to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"mi\">2</span> <span class=\"n\">goals</span>\n<span class=\"n\">case</span> <span class=\"n\">or.inr</span>\n<span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span>\n<span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">,</span>\n<span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">Q</span>\n\n<span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The first goal seems to be a dead end, I have no way of proving <code>Q</code>.</p>\n<p>I've tried a couple of different paths and I still end at this point.</p>",
        "id": 216965319,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605586976
    },
    {
        "content": "<p>Try holding off on using <code>left</code> until later.</p>",
        "id": 216965685,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1605587470
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span>  I got it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">split</span><span class=\"o\">,</span>\n<span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">h.left</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">hqr</span> <span class=\"o\">:=</span> <span class=\"n\">h.right</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">hqr</span> <span class=\"k\">with</span> <span class=\"n\">q</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n<span class=\"n\">left</span><span class=\"o\">,</span>\n<span class=\"n\">split</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n<span class=\"n\">right</span><span class=\"o\">,</span>\n<span class=\"n\">split</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n<span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">split</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">pq</span> <span class=\"n\">qr</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">pq.left</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">qr.left</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">pq</span> <span class=\"n\">qr</span><span class=\"o\">,</span>\n<span class=\"n\">left</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">pq.right</span><span class=\"o\">,</span>\n<span class=\"n\">right</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">qr.right</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>However that doesn't seem nearly as compact as the term mode proof <a href=\"https://github.com/leanprover-community/mathlib/blob/b588fc4c4eaf77031ad82b5712bef458389e92b9/src/logic/basic.lean#L383\">here</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hbc</span><span class=\"o\">⟩,</span> <span class=\"n\">hbc.imp</span> <span class=\"o\">(</span><span class=\"n\">and.intro</span> <span class=\"n\">ha</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">and.intro</span> <span class=\"n\">ha</span><span class=\"o\">),</span> <span class=\"n\">or.rec</span> <span class=\"o\">(</span><span class=\"n\">and.imp_right</span> <span class=\"n\">or.inl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">and.imp_right</span> <span class=\"n\">or.inr</span><span class=\"o\">)⟩</span>\n</code></pre></div>\n<p>I know term mode is more terse but still based on this compactness I wonder if there is something redundant in my proof.</p>",
        "id": 216966270,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605588323
    },
    {
        "content": "<p>Here's a proof that avoids any mathlib lemmas like <code>imp_right</code>, just relies on a more powerful tactic that combines intro with cases. You can get it to generate the right pattern using <code>rintro?</code> and then rename the auto-generated names.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.basic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">and_or_distrib_left'</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span> <span class=\"bp\">|</span> <span class=\"n\">r</span><span class=\"o\">⟩,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">or.inl</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">or.inr</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">⟩</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">(⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">⟩),</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">or.inl</span> <span class=\"n\">q</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">or.inr</span> <span class=\"n\">r</span><span class=\"o\">⟩</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 216967739,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605590636
    },
    {
        "content": "<p><code>rintro</code> is able to handle conjunctions and disjunctions.</p>",
        "id": 216967789,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605590657
    },
    {
        "content": "<p>I am starting Advanced Addition world.  The context is a little confusing.  I first assume that we are trying to prove <code>succ_inj</code>.  Then I see in bottom left that it is an axiom and that we are trying to prove <code>succ_inj'</code> which just seems to be a restatement of <code>succ_inj</code>.  A few questions:</p>\n<ol>\n<li>\n<p>I notice it elsewhere in the Lean sources, that if there is a <code>foo</code> there may also be a <code>foo'</code>.  What does the convention of using <code>'</code> after a name tell the reader?</p>\n</li>\n<li>\n<p>I can do this in one step with <code>cc</code>. </p>\n</li>\n<li>\n<p>Without <code>cc</code> I don't know how to get started.   I tried this path, but it doesn't leave me in a situation where I can apply <code>succ_inj</code>:</p>\n</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">succ_inj'</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">succ</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">:</span>  <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"n\">induction</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">induction</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"n\">e</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n<span class=\"n\">refl</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>leaves me in state</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"mi\">2</span> <span class=\"n\">goals</span>\n<span class=\"n\">case</span> <span class=\"n\">mynat.succ</span>\n<span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">he</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">e</span> <span class=\"bp\">→</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n<span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n<span class=\"bp\">⊢</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">e</span>\n\n<span class=\"n\">case</span> <span class=\"n\">mynat.succ</span>\n<span class=\"n\">b</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">b</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">succ</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n</code></pre></div>",
        "id": 217012753,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605624916
    },
    {
        "content": "<p>If you just want to continue this way,  then looking at the goal, surely <code>hs</code> is contradictory. <code>s 0 = s $ s e</code> would imply <code>0 = s e</code> but <code>zero</code> and <code>s</code> are different constructors. <code>cases hs</code> will likely be your best friend.</p>",
        "id": 217013915,
        "sender_full_name": "Moses Schönfinkel",
        "timestamp": 1605625401
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110027\">@Moses Schönfinkel</span> , I just figure it out by lookin at <a href=\"https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Using.20.60rw.60.html\">another post</a> that gives the syntax to apply the axiom:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"n\">succ_inj</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n<span class=\"n\">refl</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>This is more enlightening than just doing <code>cc</code>.  I am still curious about the <code>foo'</code> confusion.  What is the <code>'</code> used to signify?</p>",
        "id": 217014085,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605625470
    },
    {
        "content": "<p>It's used fluidly, often indicating it's an \"alternative\" version of an already existing lemma / restatement with different argument order, etc.</p>",
        "id": 217014302,
        "sender_full_name": "Moses Schönfinkel",
        "timestamp": 1605625575
    },
    {
        "content": "<p>That <code>'</code> in succ_inj'<code> means nothing more than \"this is quite like </code>succ_inj` but not quite the same\".</p>",
        "id": 217019785,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605627953
    },
    {
        "content": "<p>I'm on Advanced Addition Level 2/13.  I'm confused about  a comment in the text \"remember that <code>rw</code> should not be used with <code>succ_inj</code> -- rw works only with equalities or ↔ statements, not implications or functions\" .  But this is exactly what I did above for level 1:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"n\">succ_inj</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 217021842,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605628816
    },
    {
        "content": "<p>I'm trying to warn readers away from a mistake I saw constantly in beta testing, which was that if <code>h : P -&gt; Q</code> then people would constantly try to <code>rw h</code> to turn P into Q (either in a hypothesis or a goal). You didn't <code>rw succ_inj</code> though, you rewrote <code>succ_inj hs</code>, which <em>is</em> an equality rather than an implication.</p>",
        "id": 217022015,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605628910
    },
    {
        "content": "<p>As you no doubt realise by now, an implication in Lean is a function: <code>h : P -&gt; Q</code> can be thought of as a function from proofs of <code>P</code> to proofs of <code>Q</code>.  You can't <code>rw h</code> usually, but if you feed <code>h</code> a proof of <code>P</code> (e.g. <code>hs</code>) then it spits out a proof of <code>Q</code>, and if <code>Q</code> is an equality, it can be rewritten.</p>",
        "id": 217022258,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605628989
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> for Advanced Addition level 5, I am here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">add_right_cancel</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">t</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">induction</span> <span class=\"n\">t</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">add_zero</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n<span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">add_succ</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n</code></pre></div>\n<p>the state is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">case</span> <span class=\"n\">mynat.succ</span>\n<span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>I want to apply <code>succ_inj</code> to rewrite the hypothesis <code>h</code>.  It is an implication, not an equality.  How do I apply an implication on a hypothesis?</p>\n<p>Note: I can finish the proof with <code>cc</code> but that is magic. I want to apply <code>succ_inj</code> to simplify <code>h</code> and then <code>apply hd h</code> to finish.</p>\n<p>So something like this but this doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">apply</span> <span class=\"n\">hd</span> <span class=\"o\">(</span><span class=\"n\">rw</span> <span class=\"n\">succ_inj</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">),</span>\n</code></pre></div>",
        "id": 217027620,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605630991
    },
    {
        "content": "<p><code>succ_inj</code> is a function, so you can just do something like <code>have h2 := succ_inj h,</code></p>",
        "id": 217029112,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605631613
    },
    {
        "content": "<p>Alternatively you could write the proof backwards with <code>apply hd</code> and then <code>apply succ_inj</code>. Mathematicians are trained to write forwards, but this results in the state getting clogged up with one-used-then-forgotten hypotheses. In Lean it's sometimes easier to work on the goal rather than defining new things.</p>",
        "id": 217029361,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605631716
    },
    {
        "content": "<p>Probably <code>exact hd (succ_inj h)</code> would work. <code>hd</code> is a function too.</p>",
        "id": 217029422,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605631751
    },
    {
        "content": "<p>Thanks with your first hint I did it like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">induction</span> <span class=\"n\">t</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">add_zero</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n<span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">add_succ</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n<span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"n\">succ_inj</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">apply</span> <span class=\"n\">hd</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 217029496,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605631781
    },
    {
        "content": "<p>Probably even <code>exact hd h2</code> would work, because <code>hd h2</code> is exactly a proof of the goal. <code>apply h</code> is used when <code>h : P -&gt; Q</code> and the goal is <code>Q</code>, to turn the goal to <code>P</code>.</p>",
        "id": 217029609,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605631823
    },
    {
        "content": "<p>However it's a very smart tactic and sometimes works outside this situation :-)</p>",
        "id": 217029666,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605631855
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  I am on to Advanced Addition level 6.  I think I just figured out how to put Lean in an infinite loop, as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">add_left_cancel</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">add_comm</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n</code></pre></div>\n<p>where the state before the <code>repeat</code> is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">t</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"bp\">+</span> <span class=\"n\">b</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>I want to rewrite <code>h:t+a=t+b</code> to <code>h:a+t=b+t</code>.  I can only do half of this.  I don't know how to get it to apply to the right hand side. The following doesn't work, only the first one works, on the left:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">add_comm</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">add_comm</span> <span class=\"n\">at</span> <span class=\"n\">h.right</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 217030423,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605632157
    },
    {
        "content": "<p>Yes, it is possible to put computers in infinite loops. Try <code>rw add_comm t b at h</code>, that will explicitly change t+b into b+t and not change anything else into anything.</p>",
        "id": 217031495,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605632631
    },
    {
        "content": "<p><code>add_comm</code> is a function too. It takes as input two numbers x and y, and returns a proof of <code>x+y=y+x</code>.</p>",
        "id": 217031624,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605632688
    },
    {
        "content": "<p><code>rw</code> is a clever tactic. If you try <code>rw add_comm</code> Lean will think \"the user didn't tell me which numbers, so I will just look through the goal until I find something add something, and assume they meant that\".</p>",
        "id": 217031845,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605632778
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> on the looping I was curious whether <code>repeat</code> automatically detected repetitive reasoning chains as a heuristic in the internals.  I.e. a cycle where it is clear that a sequence of states is repeating in an observable way which computably indicates non-termination.  So I guess the answer is No for <code>repeat</code>.  Not that there's anything wrong with that, I was just curious.</p>\n<p>So I've moved a long a little bit further:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">add_left_cancel</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span><span class=\"n\">rw</span> <span class=\"n\">add_comm</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span><span class=\"n\">rw</span> <span class=\"n\">add_comm</span> <span class=\"n\">t</span> <span class=\"n\">b</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span><span class=\"n\">rw</span> <span class=\"n\">add_right_cancel</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n<span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">add_comm</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">add_comm</span> <span class=\"n\">t</span> <span class=\"n\">b</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The state is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">t</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">t</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>I want to do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"n\">add_right_cancel</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>to turn <code>a+t=b+t</code> into <code>a=b</code>, but it is not matching:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">add_right_cancel</span> <span class=\"n\">h</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">h</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">mynat</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">t</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">t</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>Or this, but this also doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">apply</span> <span class=\"n\">add_right_cancel</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>giving</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">add_right_cancel</span> <span class=\"n\">h</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">h</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">mynat</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">t</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">t</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>How do I apply this correctly?</p>\n<p>P.S. I accidentally found a back door going the other way, but I'm still interested in why I can't apply <code>add_right_cancel</code> directly to rewrite <code>h</code>.  Here is the back door:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">apply</span> <span class=\"n\">add_right_cancel</span> <span class=\"n\">a</span> <span class=\"n\">t</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 217036260,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605634711
    },
    {
        "content": "<p>You can read the error message. The errors are saying \"you're giving me h but I don't want h yet\"</p>",
        "id": 217041622,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605637129
    },
    {
        "content": "<p>\"I want a, t and b first\"</p>",
        "id": 217041659,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605637148
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> .  I am on level 7 now.  I am here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">add_right_cancel_iff</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">t</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">split</span><span class=\"o\">,</span>\n<span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">apply</span> <span class=\"n\">add_right_cancel</span> <span class=\"n\">a</span> <span class=\"n\">t</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>My state is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">t</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">t</span>\n</code></pre></div>\n<p>I guess I need to turn <code>h:a=b</code> into <code>h:a+t=b+t</code>.  This is what I'm trying to prove though.  Do I need an induction step here?</p>\n<p>NOTE: I can finish with <code>cc</code> but as before that is less explainable.</p>",
        "id": 217043036,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605637777
    },
    {
        "content": "<p>Looks like <code>rw h</code> would do this?</p>",
        "id": 217043612,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1605638000
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span>  I figured it out:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">split</span><span class=\"o\">,</span>\n<span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">apply</span> <span class=\"n\">add_right_cancel</span> <span class=\"n\">a</span> <span class=\"n\">t</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">induction</span> <span class=\"n\">t</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">add_zero</span> <span class=\"o\">},</span>\n<span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">refl</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 217044819,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605638518
    },
    {
        "content": "<p>I've got another right-hand-side of hypothesis rewrite question, for Advanced Addition level 8.  I am here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">eq_zero_of_add_right_eq_self</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>My state is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>I want to apply <code>rw ← add_zero a at h,</code> only to the right-hand side of <code>h</code>, so I can get <code>h: a+b=a+0</code>.  However, I'm getting <code>h:a+0+b=a+0</code>.  Is there a way to restrict the rewrite to only the right hand side occurrence of  <code>a</code>?</p>\n<p>EDIT: Never mind, I figured it out, but it's not as compact as being able to point to the right hand side of <code>h</code> only:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">add_zero</span> <span class=\"n\">a</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">add_assoc</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">zero_add</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 217045905,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605639094
    },
    {
        "content": "<p>There is a way to do this but I don't know whether it works in the natural number game.</p>",
        "id": 217046565,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605639414
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>  I am now here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">eq_zero_of_add_right_eq_self</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">add_zero</span> <span class=\"n\">a</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">add_assoc</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">zero_add</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>My state is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>I want to do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"n\">add_left_cancel</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>to rewrite <code>h</code> to <code>b=0</code>.  How do I do that?  <code>rw add_left_cancel at h,</code> doesn't work.</p>\n<p>EDIT: Never mind, I got it</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">apply</span> <span class=\"n\">add_left_cancel</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"mi\">0</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 217047122,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605639685
    },
    {
        "content": "<p>I'm just finished Inequality 1.  A few notes:</p>\n<ol>\n<li>\n<p><code>ring</code> is mentioned but isn't listed in the Tactics menu that I can see.  <code>use 1, ring,</code> makes a nice short proof.  On the other hand <code>tauto</code> and <code>revert</code> are there but I don't recall any example where those were suggested or necessary.  I've done every example of every preceding level up to this point.</p>\n</li>\n<li>\n<p>On all the levels, there is a big lag between 'no goals left' and 'Proof complete'.  What's happening that I'm waiting for? It's a small point but I don't think it marks the level complete until it prints the 'Proof complete'.</p>\n</li>\n</ol>",
        "id": 217072609,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605652356
    },
    {
        "content": "<p>The game is laggy because it's running a hacked together Javascript version of a supercomplicated C++ program all within a web browser. It's a miracle it works at all. Lean has a ton of tactics and rather than disable all the ones I've not mentioned I just left them in but didn't always import them, so random tactics may or may not work.</p>",
        "id": 217075688,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605654303
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> it's great, thanks for putting this together!   I'm almost done.  I'm on level 5 of Inequailty World.  I am here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hbc</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"n\">rw</span> <span class=\"n\">le_iff_exists_add</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">le_iff_exists_add</span> <span class=\"n\">at</span> <span class=\"n\">hab</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">le_iff_exists_add</span> <span class=\"n\">at</span> <span class=\"n\">hbc</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>I'm doing these rewrites so I can think more clearly about the system of equations that results.  That leaves me in this state:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n<span class=\"n\">hbc</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c_1</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c_1</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c_1</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c_1</span>\n</code></pre></div>\n<p>Now I would like to do a replacement for <code>c</code> in the goal.  I try this, and it doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"n\">hbc</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>This also doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">hbc</span>\n</code></pre></div>\n<p>What should I really be doing at this point?  The other approach I'm looking at is to start with an 8-case induction:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">induction</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"n\">e</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n<span class=\"n\">induction</span> <span class=\"n\">c</span> <span class=\"k\">with</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 217080524,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605658026
    },
    {
        "content": "<p>Ii would greatly appreciate help on level 6 of Inequality.  I am here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hba</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n   <span class=\"n\">cases</span> <span class=\"n\">hab</span> <span class=\"k\">with</span> <span class=\"n\">c</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n   <span class=\"n\">cases</span> <span class=\"n\">hba</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n   <span class=\"n\">induction</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">e</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n   <span class=\"n\">induction</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n   <span class=\"n\">refl</span><span class=\"o\">,</span>\n   <span class=\"n\">exfalso</span><span class=\"o\">,</span>\n   <span class=\"n\">rw</span> <span class=\"n\">succ_add</span> <span class=\"n\">at</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n   <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">zero_ne_succ</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">+</span><span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"n\">hd</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>This leaves me in state:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">case</span> <span class=\"n\">mynat.succ</span>\n<span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">he</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">e</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"bp\">→</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">e</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n<span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">d</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">succ</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>I want to pick <code>d=0</code> earlier on but <code>cases hba with d hd</code> doesn't allow me to create the equivalent of a <code>use 0</code>.  How do I get a <code>use 0</code> into the picture so that I can simplify <code>hd</code> to <code>succ e = b</code>?</p>",
        "id": 217090001,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605667248
    },
    {
        "content": "<p>Well if you did cases on your <code>hab</code> to make a <code>b = a + c</code>, and then <code>hba</code> to get <code>a = b + d</code>, why would you do induction on <code>a</code> or <code>b</code>? You can induct directly on <code>c</code> or <code>d</code>.</p>",
        "id": 217090520,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605667833
    },
    {
        "content": "<p>You can use the new equalities you've generated directly to <code>rw</code> in the other.</p>",
        "id": 217090538,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605667866
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span>  that takes me all the way!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hba</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">cases</span> <span class=\"n\">hab</span> <span class=\"k\">with</span> <span class=\"n\">c</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">hba</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">induction</span> <span class=\"n\">c</span> <span class=\"k\">with</span> <span class=\"n\">e</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n<span class=\"n\">induction</span> <span class=\"n\">d</span> <span class=\"k\">with</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">add_zero</span> <span class=\"n\">at</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">add_zero</span> <span class=\"n\">at</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n<span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"n\">apply</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">hc</span> <span class=\"n\">at</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">add_assoc</span> <span class=\"n\">at</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">add_succ</span> <span class=\"n\">at</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">succ_add</span> <span class=\"n\">e</span> <span class=\"n\">d</span> <span class=\"n\">at</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">exfalso</span><span class=\"o\">,</span>\n<span class=\"n\">symmetry</span> <span class=\"n\">at</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">eq_zero_of_add_right_eq_self</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">hp</span> <span class=\"o\">:=</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 217094886,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605673155
    },
    {
        "content": "<p>Hi I'm stuck on Level 8.  I think I'm going in circles, any hints would be greatly appreciated.  I am here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">succ_le_succ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">succ</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">induction</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"n\">induction</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"n\">e</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">hp</span> <span class=\"o\">:=</span> <span class=\"n\">le_refl</span><span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n<span class=\"n\">exact</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">hp</span> <span class=\"o\">:=</span> <span class=\"n\">zero_le</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">),</span>\n<span class=\"k\">have</span> <span class=\"n\">hp1</span> <span class=\"o\">:=</span> <span class=\"n\">he</span><span class=\"o\">(</span><span class=\"n\">hp</span><span class=\"o\">),</span>\n<span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">le_succ</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"n\">hp1</span><span class=\"o\">),</span>\n<span class=\"n\">cases</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">d</span> <span class=\"k\">with</span> <span class=\"n\">g</span> <span class=\"n\">hg</span><span class=\"o\">,</span>\n<span class=\"n\">exfalso</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">one_eq_succ_zero</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"n\">zero_le</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">),</span>\n<span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:=</span> <span class=\"n\">le_antisymm</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"n\">h2</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">one_eq_succ_zero</span> <span class=\"n\">at</span> <span class=\"n\">h3</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">ne_succ_self</span> <span class=\"mi\">0</span> <span class=\"n\">h3</span><span class=\"o\">,</span>\n<span class=\"n\">exfalso</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">h4</span> <span class=\"o\">:=</span> <span class=\"n\">zero_le</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">g</span><span class=\"o\">)),</span>\n<span class=\"k\">have</span> <span class=\"n\">h5</span> <span class=\"o\">:=</span> <span class=\"n\">le_antisymm</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"n\">h4</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">zero_ne_succ</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">h5</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>This leaves me in state</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">case</span> <span class=\"n\">mynat.succ</span>\n<span class=\"n\">d</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"bp\">≤</span> <span class=\"n\">succ</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">succ</span> <span class=\"n\">d</span> <span class=\"bp\">≤</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">f</span><span class=\"o\">),</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"n\">d</span> <span class=\"bp\">≤</span> <span class=\"n\">succ</span> <span class=\"n\">f</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which is right back to what I am supposed to prove to begin with, plus a <code>succ</code>.  Where am I going wrong?</p>",
        "id": 217191350,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605730865
    },
    {
        "content": "<p>You don't actually need induction here. \\le is defined in the game as the existence of a <code>c</code> that you add to <code>a</code> to get <code>b</code>. What's the relation between the <code>c</code>'s for the \\le in the hypothesis and the goal?</p>",
        "id": 217192192,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1605731269
    },
    {
        "content": "<p>Lars, your preference to employ induction makes you prove things you've already proven before. Through the worlds, you've proven and made accessible an API about <code>le</code>. Now all you need to do is use it.</p>",
        "id": 217193579,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605731956
    },
    {
        "content": "<p>That is, what does it mean for <code>a &lt;= b</code>?</p>",
        "id": 217193649,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605732000
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span>  and <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> starting new this way, I am having problems applying rules in presence of existential quantifiers.  For example if I start with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">succ_le_succ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">succ</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">rw</span> <span class=\"n\">le_iff_exists_add</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">le_iff_exists_add</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>my state is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">succ</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span>\n</code></pre></div>\n<p>If I then try to rewrite the goal from <code>succ a + c </code> to <code>succ (a+c)</code> using</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"n\">succ_add</span> <span class=\"n\">a</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>I get the error </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unknown</span> <span class=\"n\">identifier</span> <span class=\"sc\">'c'</span>\n</code></pre></div>\n<p>Similarly if I try to rewrite the hypothesis <code>b=a+c</code> as <code>succ b = succ(a+c)</code> using</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"n\">succ_eq_succ_of_eq</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>I also get <code>unknown identifier 'c'</code>.  If I try to do just</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">use</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>it also complains <code>failed to instantiate goal with c</code>.  It also doesn't really help in the sense that what I need to do is a <code>use c</code> of some sort on the hypothesis </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span>\n</code></pre></div>\n<p>That is, I don't know how to either apply a rewrite rule to an existentially quantified hypothesis and I don't know how to get rid of the quantifier.  Which is why I was trying induction because it seemed like my only way to get rid of a quantifier.</p>\n<p>I have the <code>cases</code> tactic but that seems to be syntactic sugar for induction.  I really want to be able to apply <code>succ_eq_succ_of_eq</code> inside quantified expressions.  Is there a way to do that?</p>\n<p>Sorry I am getting really lost here.</p>",
        "id": 217206287,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605738902
    },
    {
        "content": "<p>There is no <code>c</code>. <code>h : ∃ (c : mynat), b = a + c</code> is the same as <code>h : ∃ (w : mynat), b = a + w</code>. You need to extract the natural from <code>h</code> using <code>cases</code>.</p>",
        "id": 217206370,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605738962
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, I see now that the starting pattern I need, to be able to apply a rule like <code>succ_eq_succ_of_eq</code>, is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"n\">le_iff_exists_add</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 217206979,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605739342
    },
    {
        "content": "<p>In the NNG, you don't even need to do the first <code>rw</code>, you can just <code>cases h with c hc</code> if you want.</p>",
        "id": 217207060,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605739398
    },
    {
        "content": "<p>\"Give me the <code>c : mynat</code> such that <code>hc : b = a + c</code>\"</p>",
        "id": 217207106,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605739431
    },
    {
        "content": "<p>Ooh I discourage use of definitional equalities like that in NNG. But it is true :-)</p>",
        "id": 217207196,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605739491
    },
    {
        "content": "<p>You could make <code>le</code> irreducible if you want to block that</p>",
        "id": 217207264,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605739548
    },
    {
        "content": "<p>then you could just write <code>rw le at h</code> <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 217207352,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605739592
    },
    {
        "content": "<p>that's still using the lemma though</p>",
        "id": 217207375,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605739607
    },
    {
        "content": "<p>you could also give it a really obscure definition, filter all the operations through an opaque typeclass, or axiomatize everything</p>",
        "id": 217207440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605739646
    },
    {
        "content": "<p>I think you can also break <code>rw le</code> if you remove the equation lemma or add the definition by tactics so it doesn't have one</p>",
        "id": 217207630,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605739769
    },
    {
        "content": "<p>Alas I am still on the edge but not there.  If I do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">succ_le_succ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">succ</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">c</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">hp</span> <span class=\"o\">:=</span> <span class=\"n\">succ_eq_succ_of_eq</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">succ_add</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"n\">at</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>then I get to state</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n<span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">succ</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">succ</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>My <code>hp</code> seems to be the fact I'm  looking for, but it's not in the form of an inequality.  If I say</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">exact</span> <span class=\"n\">hp</span>\n</code></pre></div>\n<p>it says</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">type</span> <span class=\"n\">ascription</span><span class=\"o\">,</span> <span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">succ</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">succ</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">succ</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>On the other hand if I say</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"n\">le_iff_exists_add</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">hp</span>\n</code></pre></div>\n<p>I get to state</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n<span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">succ</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span>\n</code></pre></div>\n<p>but it still refuses to match <code>hp</code> with the goal.  This is really hard.</p>",
        "id": 217208145,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605740118
    },
    {
        "content": "<p>Have you used <code>use</code> in any level?</p>",
        "id": 217208541,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605740385
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span>  that got me over the line</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">c</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">hp</span> <span class=\"o\">:=</span> <span class=\"n\">succ_eq_succ_of_eq</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">succ_add</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"n\">at</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">le_iff_exists_add</span><span class=\"o\">,</span>\n<span class=\"n\">use</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 217208683,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605740480
    },
    {
        "content": "<p>Abusing the definitional equalities that Kevin is trying to avoid:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">c</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n<span class=\"n\">use</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">succ_add</span><span class=\"o\">,</span>\n<span class=\"n\">refl</span>\n</code></pre></div>",
        "id": 217208792,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605740535
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span>  nice!  The <code>cases h with c hc</code> is declaring a <code>c</code> which is now available for <code>use c</code> which is quietly \"seeing\" the existential quantifier in <code>⊢ succ a ≤ succ b</code> and then eliminating it without it ever being displayed.  I will try to remember that.  The quantifier is there hiding behind the <code>≤</code>.  If I remember the pattern then I don't have to bring it out to reason about it.  There's a lot to keep in mind.</p>",
        "id": 217211302,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605742412
    },
    {
        "content": "<p>But as Kevin said, it's not polite to access the existential behind the <code>le</code> definition the way I did it. So you could do </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"n\">le_iff_exists_add</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">c</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n<span class=\"n\">use</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">succ_add</span><span class=\"o\">,</span>\n<span class=\"n\">refl</span>\n</code></pre></div>\n<p>and that is more polite.</p>",
        "id": 217211471,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605742509
    },
    {
        "content": "<p>Hi I'm on level 9 of Inequality World.  The goal is <code>⊢ a ≤ b ∨ b ≤ a</code>.  I see that as an application of the Law of the Excluded Middle, which was not discussed in Proposition World or Advanced Proposition World.   This would be more clear if the goal was  <br>\n<code>⊢ a ≤ b ∨ b &lt; a</code><br>\nwhich seems to be equivalent, because  <br>\n<code>⊢ a ≤ b ∨ b ≤ a</code><br>\n is really saying  <br>\n<code>⊢ a &lt;b ∨ a=b ∨ b&lt;a ∨ a=b</code><br>\n which is saying<br>\n<code> ⊢ a ≤ b ∨ b &lt; a</code><br>\nwhen you take out the extra <code>a=b</code>, and that is really<br>\n<code> ⊢ a ≤ b ∨ ¬ (a ≤ b)</code></p>\n<p>How can I apply Law of Excluded Middle in this example?  Is it necessary?  I clearly can't operate on each goal individually because <code>a ≤ b</code> and <code>b ≤ a</code> do not stand on their own, they are connected by Law of Excluded Middle.   Just saying <code>left</code> or <code>right</code> gives me unprovable statements.  There isn't any other discussion in Natural Number Game of how to deal with what might be called a \"mutually dependent disjunction\".</p>",
        "id": 217215417,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605745473
    },
    {
        "content": "<p>You can use <code>cases</code> on excluded middle to reason separately about the two branches</p>",
        "id": 217217787,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605747648
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <code>cases</code> works on a hypothesis.  My opening state is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>so there is no hypothesis. I can't invoke <code>cases</code> in this context.  I need to do an <code>induction</code> first but in a previous problem I was suggested to skip the induction.   In this case it seems like I can't.</p>",
        "id": 217218865,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605748562
    },
    {
        "content": "<p>cases works on an expression. <code>cases (em (a &lt;= b))</code> will case on whether a &lt;= b is true or false</p>",
        "id": 217218927,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605748598
    },
    {
        "content": "<p>you can also use <code>have</code> and then <code>cases</code> if you want a hypothesis:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">em</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">b</span><span class=\"o\">),</span>\n<span class=\"n\">cases</span> <span class=\"n\">this</span>\n</code></pre></div>",
        "id": 217218951,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605748636
    },
    {
        "content": "<p>I don't have <code>em</code> yet.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Goals</span>\n<span class=\"n\">Messages</span>\n<span class=\"mi\">14</span><span class=\"o\">:</span><span class=\"mi\">7</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span>\n<span class=\"n\">unknown</span> <span class=\"n\">identifier</span> <span class=\"bp\">'</span><span class=\"n\">em'</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 217218976,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605748671
    },
    {
        "content": "<p>trying <code>cases (em (a ≤ b)),</code></p>",
        "id": 217219024,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605748693
    },
    {
        "content": "<p>You said that EM comes up in this proof? What does the description call the theorem?</p>",
        "id": 217219040,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605748715
    },
    {
        "content": "<p>the lean name is <code>classical.em</code>, so that probably works regardless</p>",
        "id": 217219048,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605748734
    },
    {
        "content": "<p>but NNG changes some things and it would have been reasonable to open <code>classical</code> for this theorem</p>",
        "id": 217219061,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605748764
    },
    {
        "content": "<p>It only comes up in the sense that I look at \"a ≤ b ∨ b ≤ a\" and it intuitively looks like a 1-step application of excluded middle.</p>",
        "id": 217219064,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605748767
    },
    {
        "content": "<p>NNG doesn't talk about excluded middle at all which makes me think I am going at this wrong.</p>",
        "id": 217219079,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605748787
    },
    {
        "content": "<p>It is also true that you can prove this without EM by induction</p>",
        "id": 217219080,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605748791
    },
    {
        "content": "<p>you do induction on <code>a</code> generalizing <code>b</code></p>",
        "id": 217219130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605748815
    },
    {
        "content": "<p>and then try to prove <code>a &lt;= b \\/ b &lt;= a -&gt; succ a &lt;= succ b \\/ succ b &lt;= succ a</code></p>",
        "id": 217219146,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605748847
    },
    {
        "content": "<p>with special cases when either <code>a</code> or <code>b</code> is 0</p>",
        "id": 217219156,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605748865
    },
    {
        "content": "<p>It let me do the cases in this form</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">cases</span> <span class=\"o\">(</span><span class=\"n\">classical.em</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 217219159,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605748874
    },
    {
        "content": "<p>I think that will get me done, it looks easy from there.</p>",
        "id": 217219172,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605748903
    },
    {
        "content": "<p>If you go at it that way, you will want to prove that <code>not (a &lt;= b) -&gt; b &lt;= a</code>, which might not be as easy as you think</p>",
        "id": 217219227,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605748931
    },
    {
        "content": "<p>depending on what theorems you have proven so far</p>",
        "id": 217219269,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605748986
    },
    {
        "content": "<p>In this section of NNG  it would be helpful for other students to introduce <code>classical.em</code>.</p>\n<p>It's giving me these two goals:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"mi\">2</span> <span class=\"n\">goals</span>\n<span class=\"n\">case</span> <span class=\"n\">or.inl</span>\n<span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span>\n\n<span class=\"n\">case</span> <span class=\"n\">or.inr</span>\n<span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>The first one looks immediate and the other one could get interesting.</p>",
        "id": 217219281,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605749005
    },
    {
        "content": "<p>that's right</p>",
        "id": 217219296,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605749026
    },
    {
        "content": "<p>NNG doesn't really hide much of the tactic framework from you. I can give you tips equivalent to skipping a dozen levels accidentally <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 217219392,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605749103
    },
    {
        "content": "<p>Thanks for the help I think it looks do-able.</p>",
        "id": 217219393,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605749103
    },
    {
        "content": "<p>I am getting <a href=\"https://github.com/ImperialCollegeLondon/natural_number_game/issues/65\">this error which was supposed to be fixed</a> in Inequality World 9.  I would rather convert <code>¬a ≤ b</code> to implication than carry the negation around which ends up outside of existential quantifiers which becomes confusing.</p>",
        "id": 217221578,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605751398
    },
    {
        "content": "<p>That is, <code>not_iff_imp_false</code> is not directly available.</p>",
        "id": 217221652,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605751451
    },
    {
        "content": "<p>you can use <code>unfold not</code> instead</p>",
        "id": 217222384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605752388
    },
    {
        "content": "<p>but mostly I would suggest getting used to it as a logical connective</p>",
        "id": 217222474,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605752461
    },
    {
        "content": "<p>Without being able to get rid of negation, I am stuck.  I can get rid of ≤, but then I've got negative existential quantifiers.  I am doing this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">le_total</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">cases</span> <span class=\"o\">(</span><span class=\"n\">classical.em</span><span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)),</span>\n<span class=\"n\">left</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">right</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">le_iff_exists_add</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">le_iff_exists_add</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>which brings me to state</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span>\n</code></pre></div>\n<p>I don't know how to deal with this.  Any advice would be greatly appreciated.</p>",
        "id": 217222487,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605752489
    },
    {
        "content": "<p>that's what I meant earlier: <br>\n<span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/need.20help.20on.20simple.20proof/near/217219227\">said</a>:</p>\n<blockquote>\n<p>If you go at it that way, you will want to prove that <code>not (a &lt;= b) -&gt; b &lt;= a</code>, which might not be as easy as you think</p>\n</blockquote>",
        "id": 217222547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605752530
    },
    {
        "content": "<p>Yes so I am out of ideas.  Let me try the <code>unfold not</code>.</p>",
        "id": 217222558,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605752556
    },
    {
        "content": "<p>The induction idea is probably a better path</p>",
        "id": 217222577,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605752587
    },
    {
        "content": "<p>ultimately, you need to prove that le is a total order, and pure logical manipulation isn't going to get you far because it's not true that all partial orders are total</p>",
        "id": 217222579,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605752593
    },
    {
        "content": "<p>OK so induction and arithmetic relationships.</p>",
        "id": 217222601,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605752641
    },
    {
        "content": "<p>I don't think you need properties of +, you probably have everything you need about le already</p>",
        "id": 217222657,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605752675
    },
    {
        "content": "<p>you just need to know that 0 &lt;= n and a &lt;= b -&gt; succ a &lt;= succ b</p>",
        "id": 217222675,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605752716
    },
    {
        "content": "<p>Yes because this path:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">cases</span> <span class=\"o\">(</span><span class=\"n\">classical.em</span><span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)),</span>\n<span class=\"n\">left</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">right</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>brings me to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>which is equivalent to <code>a ≤ b ∨ b ≤ a</code>, so that's just a round trip.</p>",
        "id": 217222765,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605752868
    },
    {
        "content": "<p>right</p>",
        "id": 217223219,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605753309
    },
    {
        "content": "<p>em is a tautology, so it's not going to take you anywhere logically different from the goal</p>",
        "id": 217223251,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605753356
    },
    {
        "content": "<p>From this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"n\">c</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n<span class=\"n\">right</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">zero_le</span> <span class=\"n\">a</span><span class=\"o\">),</span>\n<span class=\"n\">cases</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n<span class=\"n\">left</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">hp</span> <span class=\"o\">:=</span> <span class=\"n\">le_succ</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>it leaves me having to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">succ</span> <span class=\"n\">c</span> <span class=\"bp\">∨</span> <span class=\"n\">succ</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>In my head I can reason that either <code>c&lt;a</code> or <code>c=a</code>.  If <code>c=a</code> then <code>a ≤ succ c=succ a</code>.  If <code>c&lt;a</code> then either <code>succ c=a</code> or <code>succ c &lt; a</code>.   I'm not quite sure how to get the mechanics of that done in Lean.  If I do </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"n\">c</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n<span class=\"n\">right</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">zero_le</span> <span class=\"n\">a</span><span class=\"o\">),</span>\n<span class=\"n\">cases</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n<span class=\"n\">left</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">hp</span> <span class=\"o\">:=</span> <span class=\"n\">le_succ</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">hc</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">succ_eq_add_one</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>then I am in state</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">∨</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span>\n</code></pre></div>\n<p>This seems like it should reduce to <code>⊢ d ≤ 1 ∨ 1 ≤  d</code>.  I don't have the equivalent of <code>add_left_cancel</code> for inequalities so I have to get rid of the inequalities at this point.  Then I have a univariate form of the original goal.  I should be able to do induction on the univariate form to finish.  I hope that doesn't result in another round trip.</p>",
        "id": 217224187,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605754359
    },
    {
        "content": "<p>Have you learned how to generalize variables in an induction?</p>",
        "id": 217224218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605754428
    },
    {
        "content": "<p>for this theorem you want to do induction on <code>a</code> generalizing <code>b</code></p>",
        "id": 217224268,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605754459
    },
    {
        "content": "<p>you want your goal to look like <code>succ a &lt;= succ b \\/ succ b &lt;= succ a</code></p>",
        "id": 217224377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605754591
    },
    {
        "content": "<p>after the induction and cases</p>",
        "id": 217224385,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605754600
    },
    {
        "content": "<p>I am trying it but it introduces a <code>∀</code> quantifier, not discussed up to this point.  I start with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">le_total</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">induction</span> <span class=\"n\">a</span> <span class=\"n\">generalizing</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"n\">left</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">zero_le</span> <span class=\"n\">b</span><span class=\"o\">),</span>\n<span class=\"n\">right</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">zero_le</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">a_n</span><span class=\"o\">)),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>leading to state</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">case</span> <span class=\"n\">mynat.succ</span>\n<span class=\"n\">a_n</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">a_ih</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">a_n</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a_n</span><span class=\"o\">,</span>\n<span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">succ</span> <span class=\"n\">p</span> <span class=\"bp\">≤</span> <span class=\"n\">succ</span> <span class=\"n\">a_n</span>\n</code></pre></div>\n<p>I don't know how to work with the disjunction <code>a_ih</code>.  The left disjunct leads to proof.  The right disjunct does not.</p>",
        "id": 217225919,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605756505
    },
    {
        "content": "<p>So I have to think of </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">le_total</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>as saying</p>\n<p><strong>Theorem.</strong> For all a,b in N, either</p>\n<ul>\n<li>TA. a=b</li>\n<li>TB. Exists z &gt; 0. a = b + z</li>\n<li>TC. Exists z &gt; 0. b = a + z</li>\n</ul>\n<p><strong>Proof.</strong></p>\n<p>By induction on a</p>\n<p>Base Case: a=0<br>\n   0 = b =&gt; a = b (TA)<br>\n  a != b = b = a+ b (TC)</p>\n<p>Inductive Step:<br>\nAssume a &gt; 0, show s(a).</p>\n<p>Case. a=b</p>\n<p>s(a) = s(b) = b+z so s(a) = b+z for z=q (TB)</p>\n<p>Case. a = b + z<br>\ns(a) = s(b+z) = b + s(z) (TB)</p>\n<p>Case b = a + z</p>\n<p>Subcase z=1</p>\n<p>s(x) = y (TB)</p>\n<p>Subcase z != 1 and Exists v != 0 : z = s(v)</p>\n<p>b = a+s(v) = s(a) + v (TC)</p>\n<p>QED</p>\n<p>Still a lot of mental machinery to translate that into Lean but it's closer to looking automatable.</p>",
        "id": 217325640,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605817476
    },
    {
        "content": "<p>The proof I am leading you towards doesn't need any of that</p>",
        "id": 217326828,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605818098
    },
    {
        "content": "<p>you need to <code>cases b</code> not <code>cases a_ih</code>. The point is to separate into the case <code>0</code> and <code>succ b</code> so that your goal is <code>succ a &lt;= succ b \\/ succ b &lt;= succ a</code></p>",
        "id": 217326909,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605818145
    },
    {
        "content": "<p>The proofwiki version is proving <code>a &lt; b \\/ a = b \\/ b &lt; a</code> instead of <code>a &lt;= b \\/ b &lt;= a</code> and it is doing it with a different definition of <code>&lt;</code></p>",
        "id": 217327046,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605818218
    },
    {
        "content": "<p>There are two proofs that I've worked out, one that uses <code>induction ... generalizing ...</code> which is the simplest one and the one that Mario is referring to. There is another one that does not need <code>generalizing</code> that has you prove some other things along the way like <code>le_succ_self</code>.</p>",
        "id": 217329052,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605819317
    },
    {
        "content": "<p>The above proof is from Franz Lemmermeyer at Bilkent University in Turkey, not from Proofwiki but from his course notes: <a href=\"http://www.fen.bilkent.edu.tr/~franz/nt/ch1.pdf\">http://www.fen.bilkent.edu.tr/~franz/nt/ch1.pdf</a></p>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>   I follow your lead.  Lemmermeyer's proof may give me some guidance  on how to work the inductive step.</p>",
        "id": 217330300,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605820010
    },
    {
        "content": "<p>Now I am here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">le_total</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">induction</span> <span class=\"n\">a</span> <span class=\"n\">generalizing</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"n\">left</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">zero_le</span> <span class=\"n\">b</span><span class=\"o\">),</span>\n<span class=\"n\">right</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"n\">hp</span> <span class=\"n\">hq</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">zero_le</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">a_n</span><span class=\"o\">)),</span>\n<span class=\"n\">rw</span> <span class=\"n\">le_iff_exists_add</span><span class=\"o\">,</span>\n<span class=\"n\">use</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">add_zero</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>which brings me to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">a_n</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">a_ih</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">a_n</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a_n</span><span class=\"o\">,</span>\n<span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">succ</span> <span class=\"n\">a_n</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">hp</span>\n</code></pre></div>\n<p>How do I instantiate the universal quantifier with <code>succ hp</code> in place of <code>b</code> to get something I can work on further?</p>",
        "id": 217331410,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605820606
    },
    {
        "content": "<p><code>have := a_ih (succ hp)</code></p>",
        "id": 217331748,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605820794
    },
    {
        "content": "<p>although <code>hp</code> is a weird name for a nat</p>",
        "id": 217331818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605820813
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I'm getting used to the syntax for cases I didn't realize I was naming variables.</p>",
        "id": 217331877,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605820843
    },
    {
        "content": "<p>I will fix it.</p>",
        "id": 217331896,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605820855
    },
    {
        "content": "<p>I prefer <code>obtain</code>'s syntax, which should also be available in NNG: <code>obtain _ | b := b</code></p>",
        "id": 217331997,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605820915
    },
    {
        "content": "<p>I don't think <code>hq</code> names anything there</p>",
        "id": 217332092,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605820951
    },
    {
        "content": "<p>alternatively, <code>rcases b with _ | b</code> looks a bit more like <code>cases</code></p>",
        "id": 217332183,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605820989
    },
    {
        "content": "<p>Now I'm here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction</span> <span class=\"n\">a</span> <span class=\"n\">generalizing</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"n\">left</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">zero_le</span> <span class=\"n\">b</span><span class=\"o\">),</span>\n<span class=\"n\">right</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"n\">e</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">zero_le</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">a_n</span><span class=\"o\">)),</span>\n<span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:=</span> <span class=\"n\">a_ih</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>with state</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">a_n</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">a_ih</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">a_n</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a_n</span><span class=\"o\">,</span>\n<span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">a_n</span> <span class=\"bp\">≤</span> <span class=\"n\">e</span> <span class=\"bp\">∨</span> <span class=\"n\">e</span> <span class=\"bp\">≤</span> <span class=\"n\">a_n</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">succ</span> <span class=\"n\">e</span> <span class=\"bp\">≤</span> <span class=\"n\">succ</span> <span class=\"n\">a_n</span>\n</code></pre></div>\n<p>I think I am busted again because right of <code>h1</code> proves the goal but left of <code>h1</code> does not.</p>",
        "id": 217332369,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605821060
    },
    {
        "content": "<p>maybe don't use right so early</p>",
        "id": 217332430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605821097
    },
    {
        "content": "<p>otherwise this is looking good</p>",
        "id": 217332521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605821159
    },
    {
        "content": "<p>Yeah, <code>left</code> and <code>right</code> are unsafe tactics - they can transform a provable goal into an unprovable one</p>",
        "id": 217338559,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1605824202
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"364351\">@Lars Ericson</span> Expanding on Mario's point, from my experience, the safest thing to do when trying to prove a disjunction is often to try to perform case analysis on existing hypotheses as far as possible before attempting to do <code>left</code>/<code>right</code> on the goal, since this leaves you with more flexibility with which side to prove later on.</p>",
        "id": 217353734,
        "sender_full_name": "Donald Sebastian Leung",
        "timestamp": 1605837450
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"314358\">@Donald Sebastian Leung</span> .  This snippet of proof from Lemmermeyer is a pretty clear guide to what I should be driving Lean to do.  Lean's goal summary on the right hand panel, the notation, maps very closely into the proof's notation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Inductive</span> <span class=\"n\">Step</span><span class=\"o\">:</span>\n<span class=\"n\">Assume</span> <span class=\"n\">a</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"k\">show</span> <span class=\"n\">s</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span>\n <span class=\"n\">Case.</span> <span class=\"n\">a</span><span class=\"bp\">=</span><span class=\"n\">b</span>\n         <span class=\"n\">s</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">s</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"n\">z</span> <span class=\"n\">so</span> <span class=\"n\">s</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"n\">z</span> <span class=\"n\">for</span> <span class=\"n\">z</span><span class=\"bp\">=</span><span class=\"n\">q</span>\n <span class=\"n\">Case.</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">z</span>\n        <span class=\"n\">s</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">s</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">s</span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"o\">)</span>\n <span class=\"n\">Case</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">z</span>\n       <span class=\"n\">Subcase</span> <span class=\"n\">z</span><span class=\"bp\">=</span><span class=\"mi\">1</span>\n             <span class=\"n\">s</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n     <span class=\"n\">Subcase</span> <span class=\"n\">z</span> <span class=\"bp\">!=</span> <span class=\"mi\">1</span> <span class=\"n\">and</span> <span class=\"n\">Exists</span> <span class=\"n\">v</span> <span class=\"bp\">!=</span> <span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">s</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">)</span>\n            <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"n\">s</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">s</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">v</span>\n</code></pre></div>\n<p>There is a lot to learn about the tactics and their application.   I can clearly see from the proof state whether the tactics I apply are taking  the state in the direction of the above proof snippet or not, so I think I'm pretty close now.</p>",
        "id": 217355512,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605839797
    },
    {
        "content": "<p>I'm telling you it's a lot easier than that</p>",
        "id": 217357804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605842840
    },
    {
        "content": "<p>that's not the same theorem anyway</p>",
        "id": 217357809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605842858
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> what is the material difference between</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">le_total</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Theorem.</span> <span class=\"n\">For</span> <span class=\"n\">any</span> <span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span> <span class=\"k\">in</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"k\">then</span> <span class=\"n\">exactly</span> <span class=\"n\">one</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">following</span> <span class=\"n\">is</span> <span class=\"n\">true</span><span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"bp\">=</span><span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"o\">(</span><span class=\"n\">ii</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"bp\">=</span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"n\">c</span> <span class=\"n\">for</span> <span class=\"n\">c</span> <span class=\"bp\">&gt;</span><span class=\"mi\">0</span><span class=\"o\">,</span>\n<span class=\"o\">(</span><span class=\"n\">iii</span><span class=\"o\">)</span> <span class=\"n\">b</span><span class=\"bp\">=</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"n\">c</span> <span class=\"n\">for</span> <span class=\"n\">c</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>given </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">le_iff_exists_add</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span>\n    <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span>\n</code></pre></div>\n<p>They seem to describe exactly the same situation.</p>",
        "id": 217359438,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605844800
    },
    {
        "content": "<p>They are both true of course, but they logically have very distinct forms. (The \"exactly one of these three\" makes the second one even more different, but I will ignore that.) If we use the iff statement you have identified, the actual translation will be something more like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Theorem.</span> <span class=\"n\">For</span> <span class=\"n\">any</span> <span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span> <span class=\"k\">in</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">at</span> <span class=\"n\">least</span> <span class=\"n\">one</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">following</span> <span class=\"n\">is</span> <span class=\"n\">true</span><span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"bp\">=</span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"n\">c</span> <span class=\"n\">for</span> <span class=\"n\">some</span> <span class=\"n\">c</span> <span class=\"bp\">&gt;=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n<span class=\"o\">(</span><span class=\"n\">ii</span><span class=\"o\">)</span> <span class=\"n\">b</span><span class=\"bp\">=</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"n\">c</span> <span class=\"n\">for</span> <span class=\"n\">some</span> <span class=\"n\">c</span> <span class=\"bp\">&gt;=</span> <span class=\"mi\">0</span><span class=\"bp\">.</span>\n</code></pre></div>",
        "id": 217359619,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605844952
    },
    {
        "content": "<p>While it is useful to ignore minor differences in formulation to an extent, it makes a big difference to how to go about proving a theorem so you shouldn't overdo it. At the extreme, all of these theorems just look equivalent to \"true\" so it provides no help on how to go about proving them</p>",
        "id": 217359713,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605845060
    },
    {
        "content": "<p>In this case, the biggest difference with the inductive proof I'm suggesting is that it doesn't use <code>le_of_exists_add</code> at all; so you never need any theorems about <code>+</code></p>",
        "id": 217359887,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605845280
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I am starting to develop a better sense of the \"state of the proof engine\" and how various rules move that state. </p>\n<p>While in one sense all provable theorems just look equivalent to true, what I was trying to say about the <code>le_total</code> versus the Lemmerman formulation is this:  If <code>le_total</code> or <code>Lemmerman</code> was the only thing you knew about <code>N</code>, is there anything that you could prove knowing the one that you could not prove knowing the other, or are the sets of provable statements exactly the same?  So that's more than saying <code>true iff true</code>.</p>\n<p>In that sense, the two statements looked equivalent to me.  One of the suggestions above was to always write down the proof before trying to do it in Lean.  Lemmerman gave me a proof of an equivalent statement.  Under the hood, the text says that <code>a ≤ b</code> is really just syntactic sugar for <code>∃ (c : mynat), b = a + c</code>.  Although it may not be the shortest path, the Lemmerman proof gives a say of thinking about induction on the successor operation.</p>\n<p>I'm still struggling with it and I greatly appreciate your suggestions, I'm just trying to explain why I looked at this -- basically because I was looking for any and all written proofs that would give me a guide, and after quite a lot of Googling, this was the only satisfying, directly related proof that I came across.</p>",
        "id": 217361043,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605846623
    },
    {
        "content": "<blockquote>\n<p>While in one sense all provable theorems just look equivalent to true, what I was trying to say about the le_total versus the Lemmerman formulation is this: If le_total or Lemmerman was the only thing you knew about N, is there anything that you could prove knowing the one that you could not prove knowing the other, or are the sets of provable statements exactly the same? So that's more than saying true iff true.</p>\n</blockquote>\n<p>The thing is, in a formal proof setting (well more generally in mathematics but you sense this especially in a formal setting), the set of things you \"know\" is constantly changing, and with it your sense of \"equivalent\" also changes. So things can be not equivalent at the beginning of a file and become equivalent by the end. Plus there is a cost metric associated with the equivalence, the amount of proof work that would be needed to go from A to B. When you find a random proof off the internet the set of previously proved facts will be different and with it the costs will be off; so an optimal proof in that setting may not be an optimal proof in your setting.</p>",
        "id": 217361215,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605846835
    },
    {
        "content": "<p>Generally, if you want to follow a book you should stick with it for a whole sequence of proofs, so that the set of facts available to you matches up well with the set of facts available to the book. In your case NNG picks the theorems and the order, so you should try to find a proof that leverages recently proven theorems</p>",
        "id": 217361311,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605846957
    },
    {
        "content": "<p>I don't have NNG, but here's a plain lean proof of the theorem in a way that should translate well to NNG:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">nat.le_total'</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">a</span> <span class=\"n\">IH</span> <span class=\"n\">generalizing</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">zero_le</span> <span class=\"o\">},</span>\n  <span class=\"n\">cases</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">zero_le</span> <span class=\"o\">},</span>\n  <span class=\"n\">cases</span> <span class=\"n\">IH</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">nat.succ_le_succ</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">nat.succ_le_succ</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>",
        "id": 217361606,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605847206
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>NNG proof with induction generalizing</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>induction a with a ha generalizing b,<br>\n{ exact or.inl (zero_le _) },<br>\n{ cases b,<br>\n  { exact or.inr (zero_le _) },<br>\n  { cases ha b with h h,<br>\n    { exact or.inl (succ_le_succ _ _ h) },<br>\n    { exact or.inr (succ_le_succ _ _ h) } } }</p>\n</div></div>",
        "id": 217408858,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605883314
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>NNG proof with induction, no generalizing, uses underlying addition</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>induction a with a ha,<br>\n{ exact or.inl (zero_le _) },<br>\n{ cases ha with hab hba,<br>\n  { rw le_iff_exists_add a b at hab,<br>\n    cases hab with c hc,<br>\n    rw hc,<br>\n    cases c,<br>\n    { rw add_zero,<br>\n      exact or.inr (le_succ _ _ (le_refl _)) },<br>\n    { left,<br>\n      rw le_iff_exists_add,<br>\n      use c,<br>\n      rw add_succ,<br>\n      rw succ_add,<br>\n      refl } },<br>\n  { rw le_iff_exists_add b a at hba,<br>\n    cases hba with c hc,<br>\n    rw hc,<br>\n    cases c,<br>\n    { rw add_zero,<br>\n      exact or.inr (le_succ _ _ (le_refl _)) },<br>\n    { right,<br>\n      rw le_iff_exists_add,<br>\n      use succ (succ c),<br>\n      rw add_succ,<br>\n      rw add_succ,<br>\n      rw add_succ,<br>\n      refl } } }</p>\n</div></div>",
        "id": 217408976,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1605883358
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> and <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span>  for these spoilers.  There is a lot of new notation in these such as underscores and nested cases and the ability to name variables in the <code>induction</code> that I will learn from.  The last two lines of Mario's proof need to be rewritten slightly to work in NNG:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">succ_le_succ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">succ_le_succ</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n</code></pre></div>\n<p>I am still working on my own proof.  It starts like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"n\">le_iff_exists_add</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">le_iff_exists_add</span><span class=\"o\">,</span>\n<span class=\"n\">induction</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"n\">left</span><span class=\"o\">,</span>\n<span class=\"n\">use</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"n\">symmetry</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">zero_add</span> <span class=\"n\">b</span><span class=\"o\">),</span>\n<span class=\"n\">induction</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">a_ih</span> <span class=\"k\">with</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n<span class=\"n\">right</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>This leaves me with 3 goals:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"mi\">3</span> <span class=\"n\">goals</span>\n<span class=\"n\">a_n</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">a_n</span> <span class=\"bp\">+</span> <span class=\"n\">c</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">succ</span> <span class=\"n\">a_n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">c</span>\n\n<span class=\"n\">case</span> <span class=\"n\">or.inr</span>\n<span class=\"n\">a_n</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">a_n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">c</span>\n<span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">a_n</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">succ</span> <span class=\"n\">a_n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">c</span>\n\n<span class=\"n\">case</span> <span class=\"n\">mynat.succ</span>\n<span class=\"n\">a_n</span> <span class=\"n\">b_n</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span>\n<span class=\"n\">b_ih</span> <span class=\"o\">:</span>\n  <span class=\"o\">((</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">b_n</span> <span class=\"bp\">=</span> <span class=\"n\">a_n</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">a_n</span> <span class=\"bp\">=</span> <span class=\"n\">b_n</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">((</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">b_n</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">a_n</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">succ</span> <span class=\"n\">a_n</span> <span class=\"bp\">=</span> <span class=\"n\">b_n</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">),</span>\n<span class=\"n\">a_ih</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">succ</span> <span class=\"n\">b_n</span> <span class=\"bp\">=</span> <span class=\"n\">a_n</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">a_n</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">b_n</span> <span class=\"bp\">+</span> <span class=\"n\">c</span>\n<span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">succ</span> <span class=\"n\">b_n</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">a_n</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">),</span> <span class=\"n\">succ</span> <span class=\"n\">a_n</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">b_n</span> <span class=\"bp\">+</span> <span class=\"n\">c</span>\n</code></pre></div>\n<p>I know this is the \"wrong approach\" but I will try to learn from techniques in your examples to make it go through.  I will feel like I am cheating if I don't either carry the thought process through or come to a self-realization that it is wrong headed.  What I am trying to avoid is a situation where I am turning the crank on the proof engine without insight into the meaning of what I am trying to prove, i.e. I would like to avoid a gaming mindset where my skill is in finding the right reduction rules to eliminate a goal, as opposed to knowing the meaning of the underlying space and using that meaning to guide tactic selection.</p>\n<p>In that sense if I can finish the above proof, then I think I can claim I got some insight from Lemmerman's proof.  I understand Mario's comments about the setup providing the direction.  I really want to avoid that.  I should be able to step back from one path of breadcrumbs being laid down in the forest, to a different path of breadcrumbs on a different path through the forest, and see how both paths lead to the same spot.</p>\n<p>I have a language question.   I have two theorems <code>X</code> and <code>Y</code>.  I have a logic with a set of axioms <code>A</code> and a proof engine <code>P</code> which allows me to apply the axioms of <code>A</code> to a goal state to generate a proof.  There is some infinite set of theorems that can be derived from <code>A</code>.  Let's call that infinite set <code>Proofs(P,A)</code>. <code>X</code> and <code>Y</code> are both in <code>Proofs(P,A)</code>.  I'm trying to say something like <code>Proofs(P,{X})=Proofs(P,{Y})</code>.  I don't know what the usual logicianly language is for discussing that.  It's not the same as saying all models of <code>X</code> are models of <code>Y</code>.   I'm not talking about models, just enumerable sets of proofs.  So, without arguing the merits of context, what is the correct logicianly way of expressing the idea <code>Proofs(P,{X})=Proofs(P,{Y})</code>?</p>",
        "id": 217428764,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605891478
    },
    {
        "content": "<p>Your first two goals look easy, your third just looks like what you would get if you just tried to prove the original question by induction. Note that you are using induction twice and every complete proof only uses it once. As for your logic question, isn't the answer just <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X\\iff Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.70733em;vertical-align:-0.024em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⟺</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>?</p>",
        "id": 217434587,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605894064
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  I didn't get where I was going with the Turkish proof.  I was able to slightly personalize Yakov's second proof  and learn some new notation.  This is what I got, you can give me a D- for asking for too many hints:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n<span class=\"n\">left</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">zero_le</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">ha</span> <span class=\"k\">with</span> <span class=\"n\">hab</span> <span class=\"n\">hba</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">le_iff_exists_add</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">at</span> <span class=\"n\">hab</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">hab</span> <span class=\"k\">with</span> <span class=\"n\">c</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n<span class=\"n\">right</span><span class=\"o\">,</span>\n<span class=\"n\">ring</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">hasa</span> <span class=\"o\">:=</span> <span class=\"n\">le_refl</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">le_succ</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"n\">hasa</span><span class=\"o\">),</span>\n<span class=\"n\">left</span><span class=\"o\">,</span>\n<span class=\"n\">use</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">add_one_eq_succ</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">add_one_eq_succ</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"n\">ring</span><span class=\"o\">,</span>\n<span class=\"n\">right</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">le_succ</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"n\">hba</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 217443976,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605898722
    },
    {
        "content": "<p>One criticism of the natural number game is that it does not encourage people to write well-structured proofs (I felt it was something which didn't need to be emphasized to people who were just playing for fun). But really you should only ever have one goal, and use <code>{ }</code>s when suddenly you have two. It makes proofs easier to read.</p>",
        "id": 217444228,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605898822
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">le_total</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">zero_le</span> <span class=\"n\">b</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">ha</span> <span class=\"k\">with</span> <span class=\"n\">hab</span> <span class=\"n\">hba</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">le_iff_exists_add</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">at</span> <span class=\"n\">hab</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">hab</span> <span class=\"k\">with</span> <span class=\"n\">c</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">add_zero</span><span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"n\">hasa</span> <span class=\"o\">:=</span> <span class=\"n\">le_refl</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">le_succ</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"n\">hasa</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span>\n        <span class=\"n\">use</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">add_one_eq_succ</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">add_one_eq_succ</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n        <span class=\"n\">ring</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">le_succ</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"n\">hba</span><span class=\"o\">,}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 217445088,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605899238
    },
    {
        "content": "<p>I golfed your proof a bit:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n<span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">zero_le</span> <span class=\"n\">b</span> <span class=\"o\">},</span>\n<span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">succ_eq_add_one</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">ha</span> <span class=\"k\">with</span> <span class=\"n\">hab</span> <span class=\"n\">hba</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">hab</span> <span class=\"k\">with</span> <span class=\"n\">c</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n    <span class=\"n\">subst</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span>\n      <span class=\"n\">use</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n      <span class=\"n\">ring</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span>\n      <span class=\"n\">use</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n      <span class=\"n\">ring</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">le_succ</span><span class=\"o\">,</span>\n    <span class=\"n\">assumption</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>By the way, the game itself knows all the solutions. If you want to see the solutions I wrote last year, you can check out <a href=\"https://github.com/ImperialCollegeLondon/natural_number_game\">the github repository</a></p>",
        "id": 217450667,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605901918
    },
    {
        "content": "<p>Note that my proof does something called \"abusing definitional equality\". This is a non-mathematical idea. There is more than one kind of equality in computer science, as I discovered to my genuine surprise a few years ago. You might recall from the first addition world that <code>add_zero</code> is an axiom but <code>zero_add</code> had to be proved by induction. As a consequence, <code>n + 0 = n</code> is true <em>by definition</em>, but <code>0 + n = n</code> is true because of a theorem. If two things are equal by definition then Lean will often treat them as being identical, and I used this in e.g. the last <code>assumption</code>. As a mathematician I would not like to distinguish between the two theorems really, but Lean really treats them differently.</p>",
        "id": 217451085,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605902112
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I have finished the NNG and I can finally close this thread with a tactic-style proof of the theorem I  started with, which is one of the exercises in <a href=\"https://leanprover.github.io/theorem_proving_in_lean/propositions_and_proofs.html\">3.7.1</a>.  Here is the proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">variables</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">or_distributivity</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∧</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span>  <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n       <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n       <span class=\"o\">},</span>\n       <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n         <span class=\"n\">simp</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n       <span class=\"o\">}</span>\n    <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n      <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n      <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I am using <code>simp</code> a lot because I still don't understand some basic things.  For example when I get down to here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">or_distributivity</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∧</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span>  <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n       <span class=\"o\">{</span>\n</code></pre></div>\n<p>then I have goal state</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">case</span> <span class=\"n\">or.inl</span>\n<span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span>\n</code></pre></div>\n<p>I don't know the syntax or tactic that allows me to go from <code>h:p</code> to <code>⊢ p ∨ q</code>. From the above goal state, how do I prove the disjunction using a tactic without invoking <code>simp *</code>? </p>\n<p>There is no example that I can find in Proposition World or Advanced Proposition World that proves a disjunction.  I couldn't find a clear example of a tactic that results in a disjunction in Chapter 5.  I did stumble across <code>simp *</code>, which works fine but is a black box.   The end of section 3.6 gives a proof but it is in term style.  I can't step through the term style proof in the same way as in tactic mode, so I can't see where the disjunction is introduced.  Also I can't look at the terms and directly map them into tactics, I don't know the equivalences.  Is there a cheat sheet somewhere that maps between term style and tactic style?  Also is there a master list of tactics that is compact where I can look up tactics like the one to prove a disjunction by proving one of the disjuncts?</p>",
        "id": 217484197,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605933056
    },
    {
        "content": "<p>The tactics <code>left</code> and <code>right</code> convert a goal of the form <code>p ∨ q</code> to either <code>p</code> or <code>q</code>.  From there, <code>exact _</code> should work.  Alternatively, you can use <code>exact or.inl _</code> or <code>exact or.inr _</code>, replacing the <code>_</code> with the appropriate assumption.</p>",
        "id": 217487739,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605939700
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> , here is the de-<code>simp</code>ified pure tactic proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">variables</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">or_distributivity</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∧</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span>  <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n       <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span>\n         <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n       <span class=\"o\">},</span>\n       <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n         <span class=\"n\">right</span><span class=\"o\">,</span>\n         <span class=\"n\">exact</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n       <span class=\"o\">}</span>\n    <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n      <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">g</span> <span class=\"k\">with</span> <span class=\"n\">hq</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n        <span class=\"n\">right</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n      <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n      <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span>\n        <span class=\"n\">split</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n      <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 217505752,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1605972033
    }
]
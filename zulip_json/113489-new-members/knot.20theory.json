[
    {
        "content": "<p>is it a good idea to do work on knot theory?</p>",
        "id": 275457386,
        "sender_full_name": "Monica",
        "timestamp": 1647393733
    },
    {
        "content": "<p>Do you have any knot theory in mind that you'd want to formalize?</p>\n<p>I've been meaning to formalize knot diagrams via a variation on PD codes, but I haven't gotten around to it yet...</p>",
        "id": 275457663,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647394076
    },
    {
        "content": "<p>I think it should be fairly doable to formalize many of the sorts of things that you might find in virtual knot theory -- things that are diagrammatic.</p>\n<p>It seem like it would be a lot of work to formalize the geometric topology side of knot theory. For example, the basic (but nontrivial) fact that a knot is the unknot iff the fundamental group of its complement is isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span>.</p>",
        "id": 275457914,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647394349
    },
    {
        "content": "<p>yeah, that sounds about right. what about formalising the Alexander polynomial and the Jones polynomial, though?</p>",
        "id": 275457968,
        "sender_full_name": "Monica",
        "timestamp": 1647394441
    },
    {
        "content": "<p>or even the colouring invariant?</p>",
        "id": 275458049,
        "sender_full_name": "Monica",
        "timestamp": 1647394528
    },
    {
        "content": "<p>I think I know how to formalize the Jones polynomial, with the caveat that there might be some hidden surprises when formalizing a certain operad (edit: not sure actually what kind of object what I have in mind is; it's more some disks with arbitrary gluing data).</p>\n<p>The Alexander polynomial has a nice presentation by Kauffman using determinants (based on Alexander's original definition via the Dehn presentation), and if I'm remembering it correctly it's not so hard to show it's a knot invariant.</p>",
        "id": 275458129,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647394624
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/quandle\">docs#quandle</a> is sitting there (and in particular <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quandle.dihedral\">docs#quandle.dihedral</a>), waiting for its use in coloring invariants.</p>",
        "id": 275458145,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647394668
    },
    {
        "content": "<p>That depends on defining the fundamental quandle and showing Reidemeister moves correspond to quandle isomorphisms.</p>",
        "id": 275458219,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647394751
    },
    {
        "content": "<p>hmm, I'll give it a go tomorrow and create a new file called knot_theory then! this sounds exciting!</p>",
        "id": 275458434,
        "sender_full_name": "Monica",
        "timestamp": 1647394973
    },
    {
        "content": "<p>If we can do that, then we can do the same for fundamental groups of knot complements and give another definition of the (un-normalized) Alexander polynomial as the GCD of the 0th Fitting ideal of the abelianization of the commutator subgroup of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><msup><mi>S</mi><mn>3</mn></msup><mo>−</mo><mi>K</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\pi_1(S^3-K)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">)</span></span></span></span> as a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><msup><mi>S</mi><mn>3</mn></msup><mo>−</mo><mi>K</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\pi_1(S^3-K)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">)</span></span></span></span>-module. (Not sure how much work <em>that</em> would be! But it would be nice because the higher Fitting ideals give higher Alexander invariants.)</p>",
        "id": 275458438,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647394979
    },
    {
        "content": "<p>The Seifert surface definition I'm going to say is completely out of reach.  Doing a skein-theoretic definition (for either the Jones, Alexander-Conway polynomials, or even HOMFLY) might be fun</p>",
        "id": 275458466,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647395033
    },
    {
        "content": "<p>Probably the way to formulate the main theorem in those cases is that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">D</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{D}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> is the set of all knot diagrams and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>⋅</mo><mi mathvariant=\"script\">D</mi></mrow><annotation encoding=\"application/x-tex\">R\\cdot\\mathcal{D}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> is free <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module generated by diagrams, then if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\">R</span></span></span></span> is the submodule generated by Reidemeister moves and the skein relation (where the ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> might be, for example, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><msup><mi>q</mi><mrow><mo>±</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}[q^{\\pm 1/2}]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.138em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">±</span><span class=\"mord mtight\">1/2</span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> for the Jones polynomial), <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>R</mi><mo>⋅</mo><mi mathvariant=\"script\">D</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mi mathvariant=\"script\">R</mi></mrow><annotation encoding=\"application/x-tex\">(R\\cdot\\mathcal{D})/\\mathcal{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord mathcal\">R</span></span></span></span> is generated by the unknot and is isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, with the isomorphism sending the image of the unknot to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>.</p>",
        "id": 275458760,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647395322
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/knot.20theory/near/275457663\">said</a>:</p>\n<blockquote>\n<p>Do you have any knot theory in mind that you'd want to formalize?</p>\n<p>I've been meaning to formalize knot diagrams via a variation on PD codes, but I haven't gotten around to it yet...</p>\n</blockquote>\n<p>So <span class=\"user-mention\" data-user-id=\"130575\">@Siddharth Bhat</span>  and I are currently working on this, but we aren't quite sure what the best way to define knot is. Did you have a particular thought in mind defining it via a variation of PD codes?</p>",
        "id": 280761200,
        "sender_full_name": "Monica",
        "timestamp": 1651360114
    },
    {
        "content": "<p>I've been also doing some things with knots in the meantime, writing some code (in Lean 4) to calculate generalizations of Jones polynomials. What I've done is not very good for proving things about the invariants, though -- I just had a lot of polynomials to calculate and wanted a language I was more confident I wouldn't make a mistake in.</p>\n<p>The first ingredient is the Node type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Node</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Xp</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Xm</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Xp: Represents a right-handed oriented crossing like</span>\n\n<span class=\"cm\">  c ^ ^ b</span>\n<span class=\"cm\">     /</span>\n<span class=\"cm\">  d / \\ a</span>\n\n<span class=\"cm\">  where a, b, c, and d are edge ids. -/</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Xm: Represents a left-handed oriented crossing like</span>\n\n<span class=\"cm\">  d ^ ^ c</span>\n<span class=\"cm\">     \\</span>\n<span class=\"cm\">  a / \\ b</span>\n\n<span class=\"cm\">  where a, b, c, and d are edge ids. -/</span>\n</code></pre></div>\n<p>and then a PD is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">PD</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">Node</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>A PD should have the constraint that every index appears at most twice.  A \"complete\" PD would be one where every index appears exactly 0 or 2 times.</p>",
        "id": 280761388,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651360438
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> So, we don't start with the geometric definition of a knot? We rather directly encode the combinatorial information about the crossings via <code>PD</code>?</p>",
        "id": 280761475,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1651360566
    },
    {
        "content": "<p>What's your goal?  If you start with the geometric definition, there's a <em>whole</em> lot of work ahead of you.</p>",
        "id": 280761493,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651360630
    },
    {
        "content": "<p>By the way, this was just the version of PD codes that was useful for me for calculating these Jones-like polynomials.</p>",
        "id": 280761574,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651360789
    },
    {
        "content": "<p>We'd like to work through the first four chapters of the \"knots knotes\" text (<a href=\"https://mathweb.ucsd.edu/~justin/Papers/knotes.pdf\">https://mathweb.ucsd.edu/~justin/Papers/knotes.pdf</a>), which culminates with defining the Jones polynomial</p>",
        "id": 280761620,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1651360837
    },
    {
        "content": "<p>There's another version, that could be useful, where indices appear exactly once, there is a fixed-point-free involution on the indices to connect them up, and there is some way to tell orientation information from the indices themselves.</p>",
        "id": 280761638,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651360883
    },
    {
        "content": "<p>For example, negative vs positive integers, the involution being negation, and positive integers are used for where you're coming from</p>",
        "id": 280761654,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651360922
    },
    {
        "content": "<p>That way it's easier to keep track of where you are in a knot. You just need the index itself.</p>",
        "id": 280761691,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651360959
    },
    {
        "content": "<p>That should make describing things like Reidemeister moves easier, since there's a way to explain how to trace out faces in the knot diagram as a sequence of moves of the type \"go clockwise/counterclockwise around the current node\" and \"flip to other index\"</p>",
        "id": 280761765,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651361055
    },
    {
        "content": "<p>what about defining braids? and defining the Jones polynomial via braids? any thoughts on that?</p>",
        "id": 280762266,
        "sender_full_name": "Monica",
        "timestamp": 1651361957
    },
    {
        "content": "<p>Yeah, you could do that -- define the Artin braid group, define a trace on it, and show it's a \"Markov trace,\" as Jones called it.</p>\n<p>There's some code for braid groups on the zulip somewhere, if I remember correctly.</p>",
        "id": 280762495,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651362320
    },
    {
        "content": "<p>It's less clearly about knots, though, since you need Markov's theorem (every knot is the closure of a braid, and two braids represent the same knot iff they're related by Markov moves)</p>",
        "id": 280762554,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651362412
    },
    {
        "content": "<p>I haven't looked whether it already exists in some form in mathlib, but there's also a braided monoidal category for tangles, braids being a special case. (<span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Is there the free braided monoidal category generated by a single dualizable object? Hopefully I'm calling it the right thing here.)</p>",
        "id": 280762905,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651363049
    },
    {
        "content": "<p>I wasn't aware of PD codes, so I googled and found the <a href=\"http://katlas.org/wiki/Planar_Diagrams\">KnotAtlas page</a> which looks like a nice reference. It also mentions Conway and DT notations and braid representatives which I was aware of but have no idea how easy they're to work with. Let me also mention that there are <a href=\"https://arxiv.org/abs/0910.0078\">grid diagrams</a> that are amenable to computation of Heegaard--Floer homology.</p>",
        "id": 280764488,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651365604
    },
    {
        "content": "<p>if we can work with knots maybe we could also unlock Kirby calculus. I've always wondered about formalizing of geometric topology which is so much connected to spatial intuition that seems hard to formalize. (And I suspect AI might be able to develop superhuman higher-dimensional (&gt;3D) intuition.) There's the sphere eversion project, but it's more on the differential geometry side.</p>\n<p>I wonder whether people have thought about what it takes to formalize the <a href=\"https://en.wikipedia.org/wiki/Loop_theorem\">loop theorem</a> and the <a href=\"https://en.wikipedia.org/wiki/Sphere_theorem_(3-manifolds)\">sphere theorem</a> (which probably haven't been formalized elsewhere, and would be a real demonstration of the capability of Lean IMO). Of course we don't even have Jordan's curve theorem yet, but I assume it won't be hard as it's been formalized in other theorem provers and we already have developed homological algebra library. We have simply connected spaces in the PRs (<a href=\"https://github.com/leanprover-community/mathlib/pull/12788\">#12788</a>) now and hopefully some covering space theory soon.</p>",
        "id": 280765288,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651366960
    },
    {
        "content": "<p>Of course, \"it's essential to do all the ways\", as is well said by Kevin, so I don't think we should discourage anyone from working on their favorite definition! We want to have all definitions used by mathematicians and build API freely convert between them, not just a single preferred definition. Here's a recent exchange on the <a href=\"https://discord.com/channels/954089080197611551/966041092460011521/966122268046532718\">agda-unimath Discord</a> which seems also appropriate here:</p>\n<blockquote>\n<p>Boarders: <span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span>  algebraic geometers love doing functor of points and not worrying about the underlying space, and in fact one could do the definition purely in terms of functors and grothendieck topologies</p>\n</blockquote>\n<blockquote>\n<p>Kevin: It is true that we like functor of points when doing some things (moduli spaces) but we also really need the topological space sometimes. You're saying \"we can do one way\" but maths is not like that -- it's essential to do all the ways.<br>\nOr at least offer the API for every way of thinking about schemes<br>\nOn top of this there is the danger that if you tell an algebraic geometer \"I defined schemes\" and they say \"where's the topological space\" it's not an acceptable answer to say \"we don't have it because you don't need it\" because you don't know what they need<br>\nI have a PhD student formalising GAGA in Lean and here you need some kind of topological space because on the analytic side you can't get away with abstract nonsense, you need to do it the old fashioned way as far as I know</p>\n</blockquote>",
        "id": 280766202,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651368506
    },
    {
        "content": "<p>May I suggest that if you use PD codes, you do <em>oriented</em> PD codes instead. I wrote a significant fraction of the in the KnotTheory package for mathematica (which is what underlies the KnotAtlas), and unoriented PD codes are just asking for trouble. :-) They cannot cope properly with hopf link connect summands to knots.</p>",
        "id": 280766509,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651369028
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> The code I posted above is for oriented PD codes</p>",
        "id": 280766516,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651369050
    },
    {
        "content": "<p>Excellent!</p>",
        "id": 280766519,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651369056
    },
    {
        "content": "<p>I would love love to see some geometric topology done in mathlib, as it feels like a very hard subject for formalisation. :-)</p>",
        "id": 280766566,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651369087
    },
    {
        "content": "<p>Starting with some combinatorial aspects (e.g. knot diagrams and calculating invariants from them) sounds good.</p>",
        "id": 280766573,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651369107
    },
    {
        "content": "<p>I did spend a while trying to formalise either the Temperley-Lieb algebra, the Jones polynomial, or Jones' planar algebras, or Kuperberg's spiders ... and I don't have any PRs to show for it. :-)</p>",
        "id": 280766583,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651369145
    },
    {
        "content": "<p>Answering the question above, no, we do not yet have any free braided categories.</p>",
        "id": 280766640,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651369206
    },
    {
        "content": "<p>Starting off just by defining the braid groups via Artin's presentations would be a good exercise.</p>",
        "id": 280766645,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651369224
    },
    {
        "content": "<p>I have some Lean 4 code for calculating a generalization of the Kauffman bracket for virtual knots up to 45 crossings, but I wouldn't call it a formalization</p>",
        "id": 280766646,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651369230
    },
    {
        "content": "<p>Cool!</p>",
        "id": 280766649,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651369239
    },
    {
        "content": "<p>It uses fake \"nonplanar\" algebras. I say \"fake\" because I don't bother to encode the boundary in the type or anything like that</p>",
        "id": 280766668,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651369280
    },
    {
        "content": "<p>(it's like the Temperley-Lieb planar algebra, but strands also have a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span>-valued disorientation, which is what I think you called them for su2. It's for the arrow polynomial, if you're familiar with it.)</p>",
        "id": 280766734,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651369356
    },
    {
        "content": "<p>I wrote it all in Javascript a while back, and I wasn't too confident that the code was bug-free, so I did a from-scratch rewrite in Lean 4, and I'm happy to say I got the same results!</p>",
        "id": 280766797,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651369490
    },
    {
        "content": "<p>I once had a massive computer calculation in code that I wasn't super confident in (written in scala), and a helpful grad student did a clean room re-implementation. I never attempted to read her code (it was written in C, commented in Persian), but was very very happy when it gave all the same results.</p>",
        "id": 280766882,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651369663
    },
    {
        "content": "<p>Yes: I think encoding the boundary in the type is generally asking for dependent-type-theory-hell style trouble. Much better to fake it for the data and operations, and then have theorems keeping track of the boundary.</p>",
        "id": 280766934,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651369738
    },
    {
        "content": "<p>What I was thinking was having the type record how many boundary strands there are, or rather what the signature of the boundary is (in/out), and then the data is a PD along with a list of edge indices that are supposed to match up with that boundary data. For my purposes, that was too much dependent type theory to be worth it in the short term, but compatibility guarantees would be nice.</p>\n<p>Likely, to get around some DTT hell, the signature should be represented in a tree structure where you need to do explicit reassociation operations.</p>",
        "id": 280767050,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651369935
    },
    {
        "content": "<p>There are probably good data structures from work on higher category theory -- this reminds me a little of what I understand of opetopes.</p>",
        "id": 280767063,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651370002
    },
    {
        "content": "<blockquote>\n<p>Starting off just by defining the braid groups via Artin's presentations would be a good exercise.</p>\n</blockquote>\n<p>Here's some code from Zulip:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.zmod.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.presented_group</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.free_group</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.equiv.mul_add</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.group_power</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">alt</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">free_group</span> <span class=\"n\">S</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">free_group.of</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">alt</span> <span class=\"n\">n</span> <span class=\"n\">t</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">artin_tits_rels</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">free_group</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">alt</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">alt</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">t</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">t</span> <span class=\"n\">s</span><span class=\"o\">)}</span>\n\n<span class=\"sd\">/-- Artin-Tits groups.  Traditionally we require that</span>\n<span class=\"sd\">`∀ s t, m s t = m t s` but the hypothesis isn't used in the definition. -/</span>\n<span class=\"kd\">abbreviation</span> <span class=\"n\">artin_tits</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">presented_group</span> <span class=\"o\">(</span><span class=\"n\">artin_tits_rels</span> <span class=\"n\">S</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">braid_group</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">artin_tits</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">abs</span> <span class=\"o\">((</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"k\">then</span> <span class=\"mi\">3</span> <span class=\"k\">else</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 280767378,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651370483
    },
    {
        "content": "<p>Nice! I hadn't realised just how compact that could be. In fact Michael Howes, who started <code>group_theory.presented_group</code>, wrote it with exactly this application in mind, but didn't PR the braid groups.</p>",
        "id": 280767509,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651370648
    },
    {
        "content": "<p>Someone should define the Burau representation, to exercise our new <code>Rep k G</code>. :-)</p>",
        "id": 280767514,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651370696
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"477483\">@Monica</span> Here's a variant on PDs I had in mind, more fleshed out. It's a translation of the knot representation I used in <a href=\"https://kmill.github.io/knotfolio/\">https://kmill.github.io/knotfolio/</a> (<a href=\"https://github.com/kmill/knotfolio/blob/master/src/knotgraph.mjs\">source code</a>). I think this would need more research&amp;development for the Lean implementation, but it's something I think is worth thinking about.  The benefit of it is that you can use a <code>dart α</code> as a pointer into a particular place on the knot, and then it's relatively easy to walk around the knot in different ways. This way of representing the knot is essentially a <a href=\"https://en.wikipedia.org/wiki/Combinatorial_map\">combinatorial map</a> along with some vertex data for crossing information.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">dart</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">src</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">dart</span>\n<span class=\"bp\">|</span> <span class=\"n\">tgt</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">dart</span>\n<span class=\"c1\">-- this could also be a structure with a bool for whether it's the src</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dart.opp</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">dart</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">dart</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">dart.src</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">dart.tgt</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">dart.tgt</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">dart.src</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dart.opp_ori</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">dart</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">dart</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">dart.src</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dart.tgt</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">dart.tgt</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dart.src</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dart.arc</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">dart</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">dart.src</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">dart.tgt</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n\n<span class=\"sd\">/--</span>\n\n<span class=\"sd\">X:</span>\n\n<span class=\"sd\">  c   b</span>\n<span class=\"sd\">   \\ /</span>\n<span class=\"sd\">    /</span>\n<span class=\"sd\">   / \\</span>\n<span class=\"sd\">  d   a</span>\n\n<span class=\"sd\">P:</span>\n\n<span class=\"sd\">  a ---- b</span>\n\n<span class=\"sd\">-/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">dart</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">node</span>\n<span class=\"bp\">|</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">dart</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">node</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> darts across node have opposite orientations -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">node.valid_ori</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">node.X</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a.opp_ori</span> <span class=\"n\">c</span> <span class=\"bp\">∧</span> <span class=\"n\">b.opp_ori</span> <span class=\"n\">d</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">node.P</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a.opp_ori</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">node.darts</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">dart</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">node.X</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">d</span><span class=\"o\">}</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">node.P</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">}</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">arc</span> <span class=\"o\">(</span><span class=\"n\">κ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">fst</span> <span class=\"o\">:</span> <span class=\"n\">κ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">snd</span> <span class=\"o\">:</span> <span class=\"n\">κ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">link</span> <span class=\"o\">(</span><span class=\"n\">κ</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">κ</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">nodes</span> <span class=\"o\">:</span> <span class=\"n\">κ</span> <span class=\"bp\">→</span> <span class=\"n\">node</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">arcs</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">arc</span> <span class=\"n\">κ</span><span class=\"o\">)</span>\n<span class=\"c1\">-- orientations are valid</span>\n<span class=\"o\">(</span><span class=\"n\">valid_oris</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">κ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">nodes</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">valid_ori</span><span class=\"o\">)</span>\n<span class=\"c1\">-- the fst of each arc appears as a dart.src</span>\n<span class=\"o\">(</span><span class=\"n\">fst_is_src</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">dart.src</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">nodes</span> <span class=\"o\">(</span><span class=\"n\">arcs</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">darts</span><span class=\"o\">)</span>\n<span class=\"c1\">-- the snd of each arc appears as a dart.tgt</span>\n<span class=\"o\">(</span><span class=\"n\">snd_is_tgt</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">dart.tgt</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">nodes</span> <span class=\"o\">(</span><span class=\"n\">arcs</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">darts</span><span class=\"o\">)</span>\n<span class=\"c1\">-- every dart appears at most once</span>\n<span class=\"o\">(</span><span class=\"n\">darts_unique</span> <span class=\"o\">:</span> <span class=\"n\">multiset.nodup</span> <span class=\"o\">((</span><span class=\"n\">finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">κ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val.bind</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">nodes</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">darts</span><span class=\"o\">)))</span>\n</code></pre></div>",
        "id": 280770702,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651375482
    },
    {
        "content": "<p>In knotfolio, there's also some data for 2D positions of nodes, used for drawing the knot. These aren't needed for the isotopy class of the knot diagram.</p>",
        "id": 280770844,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651375655
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/113489-new-members/topic/knot.20theory/near/280765288\">said</a>:</p>\n<blockquote>\n<p>There's the sphere eversion project, but it's more on the differential geometry side. I wonder whether people have thought about what it takes to formalize the <a href=\"https://en.wikipedia.org/wiki/Loop_theorem\">loop theorem</a> and the <a href=\"https://en.wikipedia.org/wiki/Sphere_theorem_(3-manifolds)\">sphere theorem</a> (which probably haven't been formalized elsewhere, and would be a real demonstration of the capability of Lean IMO). </p>\n</blockquote>\n<p>There is no geometry at all in the sphere eversion project, in the sense that all manifolds are plain differentiable manifolds without any extra structure (riemannian, symplectic...). This is clearly topology. However it is crucially <em>differential</em> topology. Derivatives explicitly play a prominent role. The loop and sphere theorems can be stated in a purely <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mn>0</mn></msup></mrow><annotation encoding=\"application/x-tex\">C^0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span> world and I agree that their proof will be much more challenging to formalize. They would make an extremely nice project.</p>",
        "id": 280782727,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1651394799
    },
    {
        "content": "<p>All the combinatorial knot theory  (encoding knots with PD, grid diagrams etc.) is an interesting target because we could get certified knot atlases, and those atlases are well known to be useful tools. But this is completely orthogonal to discussing whether a proof assistant can do the geometric side of geometric topology.</p>",
        "id": 280782809,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1651394949
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113489-new-members/topic/knot.20theory/near/280766583\">said</a>:</p>\n<blockquote>\n<p>I did spend a while trying to formalise either the Temperley-Lieb algebra, the Jones polynomial, or Jones' planar algebras, or Kuperberg's spiders ... and I don't have any PRs to show for it. :-)</p>\n</blockquote>\n<p>I don't think it should be too difficult to formalise the representation of braid groups onto the Temperley-Lieb algebras tho. We can define the TL-algebras diagrammatically or via vN algebras (which I think is already in <code>mathlib</code>?). We can also then introduce a lot of quantum algebra like the Jones-Wenzl idempotents and other useful results. I haven't tried doing this yet tho, this is just off of the top of my head</p>",
        "id": 280785451,
        "sender_full_name": "Monica",
        "timestamp": 1651398624
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/knot.20theory/near/280767378\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Starting off just by defining the braid groups via Artin's presentations would be a good exercise.</p>\n</blockquote>\n<p>Here's some code from Zulip:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.zmod.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.presented_group</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.free_group</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.equiv.mul_add</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.group_power</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">alt</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">free_group</span> <span class=\"n\">S</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">free_group.of</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">alt</span> <span class=\"n\">n</span> <span class=\"n\">t</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">artin_tits_rels</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">free_group</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">alt</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">alt</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">t</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">t</span> <span class=\"n\">s</span><span class=\"o\">)}</span>\n\n<span class=\"sd\">/-- Artin-Tits groups.  Traditionally we require that</span>\n<span class=\"sd\">`∀ s t, m s t = m t s` but the hypothesis isn't used in the definition. -/</span>\n<span class=\"kd\">abbreviation</span> <span class=\"n\">artin_tits</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">presented_group</span> <span class=\"o\">(</span><span class=\"n\">artin_tits_rels</span> <span class=\"n\">S</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">braid_group</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">artin_tits</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">abs</span> <span class=\"o\">((</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"k\">then</span> <span class=\"mi\">3</span> <span class=\"k\">else</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I like the definitions from here more: <a href=\"#narrow/stream/113489-new-members/topic/braid.20group/near/249146660\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/braid.20group/near/249146660</a></p>",
        "id": 280785637,
        "sender_full_name": "Monica",
        "timestamp": 1651398916
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/knot.20theory/near/280762554\">said</a>:</p>\n<blockquote>\n<p>It's less clearly about knots, though, since you need Markov's theorem (every knot is the closure of a braid, and two braids represent the same knot iff they're related by Markov moves)</p>\n</blockquote>\n<p>it should be easy to prove Alexander's theorem (i.e., every link is ambient isotopic to a braid closure). As for Markov's theorem, proving that every braid is Markov equivalent if their braid closures are Reidemeister equivalent is a lot less clear how to formalise. It would be a lot of work, but it seems worth it</p>",
        "id": 280786103,
        "sender_full_name": "Monica",
        "timestamp": 1651399497
    },
    {
        "content": "<p>Also, <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>  / <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, can I get write access to <code>mathlib</code>. Github username is @themathqueen</p>",
        "id": 280787570,
        "sender_full_name": "Monica",
        "timestamp": 1651401867
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"477483\">@Monica</span>, invited!</p>",
        "id": 280787689,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651402050
    },
    {
        "content": "<p>\"Defining the TL-algebra diagrammatically\" is unfortunately harder than it sounds. :-)</p>",
        "id": 280787695,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651402071
    },
    {
        "content": "<p>We can certainly define the TL-algebras by generators and relations, and we should start with that. Getting them as a monoidal category would be really lovely, however.</p>",
        "id": 280787801,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651402224
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"477483\">@Monica Omar</span> this looks like a super project. It's certainly in scope for mathlib, there are people in the community who know enough about it to help out, there's plenty to do and it's mathematically interesting. Please feel free to ask here any questions you may run into, people are very happy to help out with questions, however basic.</p>",
        "id": 280791276,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1651407100
    },
    {
        "content": "<p>One observation is that if you write a ton of code with definition X and only then start showing it to people, you might get a comment of the form \"well yes, the Lean issues you're running into here are well-known to the experts and we now know that the best way to get around them is to actually make mathematically equivalent definition X' instead, meaning that you will have to refactor everything\". So run key definitions past the community early before building an API for them.</p>",
        "id": 280791356,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1651407233
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"477483\">@Monica Omar</span> von Neumann algebras are <em>defined</em> in mathlib thanks to Scott, but there is no theory developed yet. We have a lot of work to do before we can do anything interesting with von Neumann algebras.</p>",
        "id": 280801994,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1651421732
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113489-new-members/topic/knot.20theory/near/280787695\">said</a>:</p>\n<blockquote>\n<p>\"Defining the TL-algebra diagrammatically\" is unfortunately harder than it sounds. :-)</p>\n</blockquote>\n<p>At least it's not so hard to define the TL-category diagrammatically in Mathematica (\"diagrammatically\" as in elements are linear combinations of the combinatorial data of diagrams). <a href=\"https://github.com/kmill/planalg/blob/master/Planalg/Planalg.wl#L338\">https://github.com/kmill/planalg/blob/master/Planalg/Planalg.wl#L338</a></p>\n<p><a href=\"/user_uploads/3121/AILNjTGdIKTTX4UWBrsfbd6g/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/AILNjTGdIKTTX4UWBrsfbd6g/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/AILNjTGdIKTTX4UWBrsfbd6g/image.png\"></a></div><p>(That's following the convention in <a href=\"https://arxiv.org/abs/1503.00384\">https://arxiv.org/abs/1503.00384</a>)</p>",
        "id": 280802399,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651422334
    }
]
[
    {
        "content": "<p>I come across a tutorial on defining mathematical classes from the use of equivalence classes <a href=\"https://github.com/ImperialCollegeLondon/formalising-mathematics/blob/master/src/week_7/Part_A_quotients.lean\">here</a> on Dr. Buzzards web page.  I did the tutorial and as a further exercise I want to define an ordering on <code>Z</code>.  So I added the appropriate le_aux, le_aux_def, le functions/proofs.  I added the line <code>instance : has_le Z := ⟨le⟩</code> to allow me (I thought) to use the (less or equal) symbol like I could use the plus sign for addition and the star for multiplication.  </p>\n<p>If anyone can tell me what I did wrong in the following code, I would appreciate it.</p>\n<p>The following code is probably overkill, but I wanted to show that lean had no issue with accepting has_zero, has_one, has_add, etc.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">N2</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">N2</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"n\">cd</span> <span class=\"o\">:</span> <span class=\"n\">N2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">ab.1</span> <span class=\"bp\">+</span> <span class=\"n\">cd.2</span> <span class=\"bp\">=</span> <span class=\"n\">cd.1</span> <span class=\"bp\">+</span> <span class=\"n\">ab.2</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">r_def</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"n\">cd</span> <span class=\"o\">:</span> <span class=\"n\">N2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"n\">ab</span> <span class=\"n\">cd</span> <span class=\"bp\">↔</span> <span class=\"n\">ab.1</span> <span class=\"bp\">+</span> <span class=\"n\">cd.2</span> <span class=\"bp\">=</span> <span class=\"n\">cd.1</span> <span class=\"bp\">+</span> <span class=\"n\">ab.2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">refl</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">r_def'</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">refl</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">r_refl</span> <span class=\"o\">:</span> <span class=\"n\">reflexive</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">r_symm</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">r_trans</span> <span class=\"o\">:</span> <span class=\"n\">transitive</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">setoid</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"n\">N2</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">r_refl</span><span class=\"o\">,</span> <span class=\"n\">r_symm</span><span class=\"o\">,</span> <span class=\"n\">r_trans</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">N2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≈</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">refl</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">equiv_def</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"n\">cd</span> <span class=\"o\">:</span> <span class=\"n\">N2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ab</span> <span class=\"bp\">≈</span> <span class=\"n\">cd</span> <span class=\"bp\">↔</span> <span class=\"n\">ab.1</span> <span class=\"bp\">+</span> <span class=\"n\">cd.2</span> <span class=\"bp\">=</span> <span class=\"n\">cd.1</span> <span class=\"bp\">+</span> <span class=\"n\">ab.2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">refl</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">equiv_def'</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">≈</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n<span class=\"kd\">end</span> <span class=\"n\">N2</span>\n\n<span class=\"c1\">-- Now we can take the quotient!</span>\n<span class=\"kd\">def</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"n\">quotient</span> <span class=\"n\">N2.setoid</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Z</span>\n<span class=\"c1\">--## Giving Z a commutative ring structure</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">⟧</span>\n<span class=\"kd\">def</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">⟧</span>\n\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_zero</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">zero</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_one</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">one</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- let's start to train the simplifier</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">zero_def</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- works</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">one_def</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">--## Addition</span>\n<span class=\"kd\">def</span> <span class=\"n\">add_aux</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"n\">cd</span> <span class=\"o\">:</span> <span class=\"n\">N2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">ab.1</span> <span class=\"bp\">+</span> <span class=\"n\">cd.1</span><span class=\"o\">,</span> <span class=\"n\">ab.2</span> <span class=\"bp\">+</span> <span class=\"n\">cd.2</span><span class=\"o\">)</span><span class=\"bp\">⟧</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">add_aux_def</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"n\">cd</span> <span class=\"o\">:</span> <span class=\"n\">N2</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">add_aux</span> <span class=\"n\">ab</span> <span class=\"n\">cd</span> <span class=\"bp\">=</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">ab.1</span> <span class=\"bp\">+</span> <span class=\"n\">cd.1</span><span class=\"o\">,</span> <span class=\"n\">ab.2</span> <span class=\"bp\">+</span> <span class=\"n\">cd.2</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"o\">:=</span><span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"n\">quotient.lift₂</span> <span class=\"n\">add_aux</span> <span class=\"gr\">sorry</span>\n\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">add</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- train the simplifier, because we have some axioms to prove about `+`</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">add_def</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"bp\">+</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"o\">:</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- THIS IS THE STUFF I ADDED</span>\n<span class=\"c1\">-- I don't understand why has_add seemed to work but my has_le didn't.</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">le_aux</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"n\">cd</span> <span class=\"o\">:</span> <span class=\"n\">N2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">ab.fst</span> <span class=\"bp\">+</span> <span class=\"n\">cd.snd</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">cd.fst</span> <span class=\"bp\">+</span> <span class=\"n\">ab.snd</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">le_aux_def</span> <span class=\"o\">(</span><span class=\"n\">a0</span> <span class=\"n\">a1</span> <span class=\"n\">b0</span> <span class=\"n\">b1</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">le_aux</span> <span class=\"o\">(</span><span class=\"n\">a0</span><span class=\"o\">,</span> <span class=\"n\">a1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b0</span><span class=\"o\">,</span> <span class=\"n\">b1</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">a0</span> <span class=\"bp\">+</span> <span class=\"n\">b1</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">b0</span> <span class=\"bp\">+</span> <span class=\"n\">a1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">refl</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">le</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">quotient.lift₂</span> <span class=\"n\">le_aux</span> <span class=\"gr\">sorry</span>\n\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_le</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">le</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">le_def</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"o\">:</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"bp\">≤</span>  <span class=\"o\">(</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"o\">:</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n\n<span class=\"kd\">end</span> <span class=\"n\">Z</span>\n</code></pre></div>\n<p>Lean tells me that it </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n <span class=\"bp\">⊢</span> <span class=\"n\">has_le</span> <span class=\"o\">(</span><span class=\"n\">quotient</span> <span class=\"n\">N2.setoid</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">lean</span><span class=\"bp\">-</span><span class=\"n\">checker</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>on the <code>le_def</code> line.  Any help will be appreciated.  Thanks.</p>",
        "id": 295111920,
        "sender_full_name": "kvanvels",
        "timestamp": 1661369239
    },
    {
        "content": "<p>I am wondering if <code>quotient.lift</code> is inappropriate since the \"return value\" of the function is a proposition and not element of <code>Z</code>.</p>",
        "id": 295115488,
        "sender_full_name": "kvanvels",
        "timestamp": 1661370579
    },
    {
        "content": "<p>It's because it interprets <code>⟦(a,b)⟧</code> as having type <code>quotient N2.setoid</code>, not <code>ℤ</code>. Those are definitionally equal, but not syntactically so, and that's what typeclass inference needs. One solution is to define a specialisation of <code>quotient.mk</code> to your <code>ℤ</code>.</p>",
        "id": 295116127,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661370837
    },
    {
        "content": "<p>I thought that the the <code>: Z</code> made it into an element of Z.  I honestly don't know what you it would mean to define a specialization of <a href=\"http://quotient.mk\">quotient.mk</a>.  Any pointers/links would be appreciated.  </p>\n<p>I just checked, and lean has no problem if I tell it that <a href=\"http://Z.zero\">Z.zero</a> &lt;= <a href=\"http://Z.one\">Z.one</a>.  So what you told me makes sense.  Thanks for the response.</p>",
        "id": 295117027,
        "sender_full_name": "kvanvels",
        "timestamp": 1661371150
    },
    {
        "content": "<p>It's because a type-ascription doesn't actually mean \"Make the type be this\" but rather \"Check that this is defeq to the type you found\". And here indeed the type it found is defeq to <code>ℤ</code>.</p>",
        "id": 295118235,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661371632
    },
    {
        "content": "<p>What I'm talking about is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"n\">quotient.mk</span>\n</code></pre></div>",
        "id": 295118342,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661371679
    },
    {
        "content": "<p>Thanks for the response.  I will post more when I find out if I can get this to work.</p>",
        "id": 295118773,
        "sender_full_name": "kvanvels",
        "timestamp": 1661371850
    },
    {
        "content": "<p>As Yaël mentioned, type-ascription is more of a suggestion to Lean.  If you really want to force the type, a common trick is to use <code>(id a : α)</code>.  Sticking the identity in guarantees (I think) that the type will be α.</p>",
        "id": 295121445,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661372904
    },
    {
        "content": "<p>I think the <code>(id a : \\alpha)</code> trick is working.   Thank you.</p>",
        "id": 295123723,
        "sender_full_name": "kvanvels",
        "timestamp": 1661373869
    },
    {
        "content": "<p>You can also use <code>show α, from a</code>, which is a <em>macro</em> that basically unfolds to the <code>id</code> trick.</p>",
        "id": 295123755,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661373880
    },
    {
        "content": "<p>The problem is that this changes the syntactic form of your lemma, which is undesirable for rewriting.</p>",
        "id": 295123852,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661373923
    },
    {
        "content": "<p>I was just wondering about that the fact that.  I hope the addition of (id) wont till be a problem.  Like you said, I need to use this for rewriting.  Any ideas on why the other operations worked?  I wonder if the return type helped it figure things out. </p>\n<p>I will post more if I have more questions.  Thank you.</p>",
        "id": 295124141,
        "sender_full_name": "kvanvels",
        "timestamp": 1661374062
    },
    {
        "content": "<p>Yes exactly, the return type is enough for Lean to infer what you actually mean. This is not the case when you only have type-ascriptions.</p>",
        "id": 295124558,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661374227
    },
    {
        "content": "<p>Yeah, it isn't working with the id's.    Is there any way i could do <code>Z.le</code> or something like  <code>Z.operator&lt;=</code> like in C++?  By the way, I didn't get very far with the <a href=\"http://quotient.mk\">quotient.mk</a> idea very far.</p>",
        "id": 295124954,
        "sender_full_name": "kvanvels",
        "timestamp": 1661374408
    },
    {
        "content": "<p>Define <code>def mk : ℕ × ℕ → ℤ := quotient.mk</code> and use it instead of the square brackets notation.</p>",
        "id": 295126678,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661375121
    },
    {
        "content": "<p>It works as a theorem/lemma, but I can't use it to rewrite terms in other proofs.   Maybe I could to another level and have a theorem/lemma to write things with brackets in terms of the mk.</p>",
        "id": 295127528,
        "sender_full_name": "kvanvels",
        "timestamp": 1661375430
    },
    {
        "content": "<p>THANK YOU.  I got it to work, using an extra level (another theorem to transform mk's to square bracket terms).  I really appreciate the help.</p>",
        "id": 295128033,
        "sender_full_name": "kvanvels",
        "timestamp": 1661375588
    },
    {
        "content": "<p>I turned on a bunch of \"messages\" (the <code>pp.universes, pp.implicit</code> ,etc. switches ) and was able to figure out that  that the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo></mrow><annotation encoding=\"application/x-tex\"> \\le</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mrel\">≤</span></span></span></span>  sign I needed can be called by the incantation <code>@has_le.le Z Z.has_le</code> so I didn't need to use the idea of (that worked great) of the <code>quotient.mk</code>.  I suppose I could run into problems later from this hack, but I am just trying to learn the library.  Again, thanks for your help.</p>",
        "id": 295149520,
        "sender_full_name": "kvanvels",
        "timestamp": 1661392227
    }
]
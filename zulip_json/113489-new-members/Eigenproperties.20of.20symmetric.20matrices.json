[
    {
        "content": "<p>Hello! I have been working towards a file that contains properties of symmetric matrices with real coefficients, like the fact that all their eigenvalues are real and each has a corresponding real eigenvector, as I did not see them in the documentation on linear algebra. The thing is that I am not an experienced Lean programmer, and although I tried to make the code as clear as possible and with minimal repeated work, I am not sure that the code is PR-worthy. Another thing is that the whole file is 400-lines and it has a substantial amount of helping lemmas, so it would be hard to review, but I don't know if I can break it into smaller pieces, as statements follow from previous ones and so on. Should I have a \"more experienced\" opinion on what I wrote and maybe discuss its potential? <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 235470337,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1618992285
    },
    {
        "content": "<p>Sure, you can link to your code here. If some of those helper lemmas are really about something slightly more general, you can probably PR those to other files.</p>",
        "id": 235470501,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618992363
    },
    {
        "content": "<p>And then have a second PR about eigenvalues of symmetric matrices, and such</p>",
        "id": 235470533,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618992378
    },
    {
        "content": "<p><a href=\"https://github.com/gabrielmoise/Lean-work/blob/master/symm_matrix.lean\">https://github.com/gabrielmoise/Lean-work/blob/master/symm_matrix.lean</a><br>\nYes, some of the lemmas are more general (delimitated them with comments) and would fit into the data.matrix.basic file</p>",
        "id": 235471352,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1618992787
    },
    {
        "content": "<p>The stuff up to line 186 seems generic matrix stuff. So that would make a great first PR. You will have to scatter those lemmas into their natural places in the library, which means you'll be editing 2 or 3 files probably. You might discover some duplicates, I didn't look carefully for those though.</p>",
        "id": 235471634,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618992937
    },
    {
        "content": "<p>If you are not scared of getting 50 constructive feedback comments on your PR, then I would say \"go for it!\"</p>",
        "id": 235471721,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618992977
    },
    {
        "content": "<p>Thank you for the module docstring! There is quite a precise format which we ask is followed, and which your docstring doesn't quite match yet: it's <a href=\"https://leanprover-community.github.io/contribute/doc.html\">here</a>.</p>",
        "id": 235471931,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618993101
    },
    {
        "content": "<p>I see a number of lemmas there that are hiding in the library already (eg <code>vec_eq_unfold'</code> is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/funext_iff\">docs#funext_iff</a>), but the code certainly looks ready-for-mathlib-review even if not ready-for-mathlib-merge</p>",
        "id": 235471936,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618993106
    },
    {
        "content": "<p><code>vec_smul_zero</code> should be covered by <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi.no_zero_smul_divisors\">docs#pi.no_zero_smul_divisors</a> <del>but perhaps that doesn't exist yet...</del>. You should be able to replace it with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/smul_eq_zero\">docs#smul_eq_zero</a></p>",
        "id": 235472210,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618993262
    },
    {
        "content": "<p>What do you mean by ready-for-mathlib-review? That I should PR it? Btw thanks already for the feedback, it helps a lot <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 235472535,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1618993415
    },
    {
        "content": "<p>I meant to backup what <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> said about going for a PR if not afraid of 50 or so comments</p>",
        "id": 235472965,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618993628
    },
    {
        "content": "<p>Yes, please PR it :-) And if you don't change the module docstring beforehand then this will be my first comment :-)</p>",
        "id": 235473173,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618993751
    },
    {
        "content": "<p>I am doing that right now, hopefully it will be up to the standard.</p>",
        "id": 235473337,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1618993842
    },
    {
        "content": "<p>Another quick thing to address before PRing; take a quick look at #style</p>",
        "id": 235473366,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618993870
    },
    {
        "content": "<p>Oh. That link doesn't work</p>",
        "id": 235473391,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618993883
    },
    {
        "content": "<p>Well, what jumps out now is the lack of spaces inside <code>{}</code> and the multiple tactics on a single line</p>",
        "id": 235473441,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618993916
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/contribute/style.html#tactic-mode\">https://leanprover-community.github.io/contribute/style.html#tactic-mode</a></p>",
        "id": 235473514,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618993935
    },
    {
        "content": "<p>If you fix those part-way through PRing them github will start hiding comments</p>",
        "id": 235473551,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618993959
    },
    {
        "content": "<p>And btw how can I make a PR to an already existing file from mathlib? I should mention that I have an outdated mention of mathlib.</p>",
        "id": 235473580,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1618993979
    },
    {
        "content": "<p>You can create a branch that starts on the version of mathlib you were using</p>",
        "id": 235473707,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618994036
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/contribute/style.html\">#style</a> hopefully works now?</p>",
        "id": 235473799,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618994074
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Eigenproperties.20of.20symmetric.20matrices/near/235472965\">said</a>:</p>\n<blockquote>\n<p>I meant to backup what <span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> said about going for a PR if not afraid of 50 or so comments</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"366674\">@Gabriel Moise</span> Note that those 50 comments are standard for everyone who makes a first PR. We all started that way <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 235474472,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618994417
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"366674\">@Gabriel Moise</span> to follow up what Eric was sayign abuot <code>{}</code> and lines, here's what your first lemma shoudl look like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">vec_eq_unfold</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">y</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">hyp</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">congr_fun</span> <span class=\"n\">hyp</span> <span class=\"n\">i</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">hyp</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span> <span class=\"n\">i</span><span class=\"bp\">;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hyp</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 235474742,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618994582
    },
    {
        "content": "<p>Oh I really want as many comments as possible.<br>\nNow I am following some guides on how to make the first PR as I am not very experienced with GitHub either.</p>",
        "id": 235474775,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1618994602
    },
    {
        "content": "<p>If you do those fixes (e.g. <code>simp[</code> -&gt; <code>simp [</code>, <code>repeat{</code> -&gt; <code>repeat {</code> etc) <em>before</em> you PR then it will save a lot of noise during the PR process.</p>",
        "id": 235474890,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618994662
    },
    {
        "content": "<p><code>{intro</code> -&gt; <code>{ intro</code>. Also you have a non-terminal <code>simp</code> on line 119 and another on line 145 ,148 etc.</p>",
        "id": 235474996,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618994742
    },
    {
        "content": "<p>So the goal is to only use simp only when I want to close goals, and not throughout the proof as intermediate steps as well.</p>",
        "id": 235475306,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1618994913
    },
    {
        "content": "<p>Right, but there are tricks, eg change <code>simp</code> to <code>squeeze_simp</code> to find out what it actually did, and then do it manually yourself</p>",
        "id": 235476823,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618995774
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Eigenproperties.20of.20symmetric.20matrices/near/235471936\">said</a>:</p>\n<blockquote>\n<p>I see a number of lemmas there that are hiding in the library already (eg <code>vec_eq_unfold'</code> is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/funext_iff\">docs#funext_iff</a>), but the code certainly looks ready-for-mathlib-review even if not ready-for-mathlib-merge</p>\n</blockquote>\n<p>This link doesn't work for me.</p>",
        "id": 235478883,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1618996748
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.funext_iff\">docs#function.funext_iff</a></p>",
        "id": 235478942,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618996791
    },
    {
        "content": "<p>If you're looking for a tiny first PR to practice on, your <code>mul_vec_smul_assoc</code> lemma looks like one that mathlib is missing, and it would go in <code>data/matrix/basic.lean</code> (after addressing your <code>could not turn ℂ into general R</code> comment)</p>",
        "id": 235482854,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618998919
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Eigenproperties.20of.20symmetric.20matrices/near/235482854\">said</a>:</p>\n<blockquote>\n<p>If you're looking for a tiny first PR to practice on, your <code>mul_vec_smul_assoc</code> lemma looks like one that mathlib is missing, and it would go in <code>data/matrix/basic.lean</code> (after addressing your <code>could not turn ℂ into general R</code> comment)</p>\n</blockquote>\n<p>Was working on PR-ing the <code>vec_mul_mul_vec_assoc</code> lemma, but thanks for the advice.</p>",
        "id": 235483599,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1618999301
    },
    {
        "content": "<p>That one is probably easier anyway!</p>",
        "id": 235484058,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618999549
    },
    {
        "content": "<p>Although you can prove it much more succinctly!</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">dot_product_assoc</span> <span class=\"n\">y</span> <span class=\"n\">M</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>\n</div></div>",
        "id": 235485061,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619000087
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Eigenproperties.20of.20symmetric.20matrices/near/235482854\">said</a>:</p>\n<blockquote>\n<p>If you're looking for a tiny first PR to practice on, your <code>mul_vec_smul_assoc</code> lemma looks like one that mathlib is missing, and it would go in <code>data/matrix/basic.lean</code> (after addressing your <code>could not turn ℂ into general R</code> comment)</p>\n</blockquote>\n<p>My problem with (could not turn C into general R) was that I needed to instantiate R with <code>[comm_semigroup R]</code> and then (since I already had <code>[ring R]</code>) some weird interactions happened. Trying to understand the root of the problem, I noticed that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">test_mul_comm</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semigroup</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">exact</span> <span class=\"n\">mul_comm</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test_mul_comm2</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semigroup</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">exact</span> <span class=\"n\">mul_comm</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"c1\">-- no longer works</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>and this is a little confusing to me.</p>",
        "id": 235487489,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1619001376
    },
    {
        "content": "<p><code>comm_semigroup alpha</code> means \"put a commutative semigroup structure on alpha\". And <code>ring alpha</code> then means \"put a totally unrelated ring structure on alpha (but use the same symbol <code>*</code> for the multiplication)\". This is surely not what you want. Do you want <code>comm_ring alpha</code>?</p>",
        "id": 235487616,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619001478
    },
    {
        "content": "<p>If you've proved theorems about rings and then want to prove some more theorems about commutative rings, you could use sections, and have variable assumptions in the sections, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">ring_stuff</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"bp\">&lt;</span><span class=\"n\">ringy</span> <span class=\"n\">theorems</span><span class=\"bp\">&gt;</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">ring_stuff</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">comm_ring_stuff</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"bp\">&lt;</span><span class=\"n\">comm_ringy</span> <span class=\"n\">theorems</span><span class=\"bp\">&gt;</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">comm_ring_stuff</span>\n</code></pre></div>",
        "id": 235487846,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619001624
    },
    {
        "content": "<p>Alternatively you could let all your rings be called R and all your comm_rings be called A. I tend to do this when I'm doing groups, with groups called G and abelian groups called A.</p>",
        "id": 235487929,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619001677
    },
    {
        "content": "<p>Can't I include the <code>comm_ring_stuff</code> section in the <code>ring_stuff</code> section (nesting them) or is it a bad idea?</p>",
        "id": 235488291,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1619001906
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"366674\">@Gabriel Moise</span> If you have <code>variables {R : Type*} [ring R] [comm_ring R]</code> then you get two completely unrelated ring structures on <code>R</code> and Lean will get mightily confused.</p>",
        "id": 235491014,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619003294
    },
    {
        "content": "<p>So nesting will not work.</p>",
        "id": 235491034,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619003303
    },
    {
        "content": "<p>Can I get permission to push a branch to <code>mathlib</code>, please? My username is gabrielmoise</p>",
        "id": 235493469,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1619004625
    },
    {
        "content": "<p>Invitation sent: <a href=\"https://github.com/leanprover-community/mathlib/invitations\">https://github.com/leanprover-community/mathlib/invitations</a></p>",
        "id": 235494128,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619004946
    },
    {
        "content": "<p>Thanks a lot!</p>",
        "id": 235496527,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1619006089
    },
    {
        "content": "<p>Does the <code>continuous integration / Build mathlib (push)</code> part of the check of a PR generally take a lot?</p>",
        "id": 235519808,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1619015424
    },
    {
        "content": "<p>yep ^^</p>",
        "id": 235520128,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1619015524
    },
    {
        "content": "<p>It mostly depends on how deep the changes you've made are in the import graph. A modification to a leaf file will probably compile in a few seconds, but adding stuff to a basic algebra or order file will force a recompilation of almost all of mathlib.</p>",
        "id": 235520674,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1619015723
    },
    {
        "content": "<p>I'm late to the party but I'm extremely worried about trying to merge this into mathlib. Why working with matrices instead of endomorphisms? I think going down the mathematical road (first endomorphisms and then deduce results about matrices if they are needed somewhere) would be much cleaner.</p>",
        "id": 235540774,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1619022497
    },
    {
        "content": "<p>We already have things in <a href=\"https://leanprover-community.github.io/mathlib_docs/linear_algebra/eigenspace.html\">https://leanprover-community.github.io/mathlib_docs/linear_algebra/eigenspace.html</a></p>",
        "id": 235540962,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1619022582
    },
    {
        "content": "<p>Even with that being the case, I think doing this the matrix way will have filled a bunch of lemma gaps in the existing matrix API; we don't have to merge everything to extract value out of this effort</p>",
        "id": 235542220,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619023010
    },
    {
        "content": "<p>I agree that we should use the endomorphism definitions wherever possible though</p>",
        "id": 235542304,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619023053
    },
    {
        "content": "<p>I agree with what Patrick said. We definitely don't want to do a whole lot of work on matrices that is better done for endomorphisms first. But I also think that all the helper lemmas that you found are helping to fill out the matrix API.<br>\nSo when those api gaps are filled, we should discuss here on zulip what is the best way to move forward with the symmetric stuff. It should tie in well with the rest of the library (e.g. the file that Patrick linked to).</p>",
        "id": 235545953,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619024527
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Eigenproperties.20of.20symmetric.20matrices/near/235542304\">said</a>:</p>\n<blockquote>\n<p>I agree that we should use the endomorphism definitions wherever possible though</p>\n</blockquote>\n<p>I've always found this weird, but is there any particular reason why <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.trace\">docs#linear_map.trace</a> is defined using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/matrix.trace\">docs#matrix.trace</a>? It could be defined in terms of the roots of the characteristic polynomial, right? I don't know about infinite dimensional stuff though.</p>",
        "id": 235546802,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619024884
    },
    {
        "content": "<p>And the characteristic polynomial of an endomorphism is presumably defined using the determinant of a matrix? I don't see how you can get away from matrices here.</p>",
        "id": 235551460,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619026706
    },
    {
        "content": "<p>Oh, true.</p>",
        "id": 235552556,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619027152
    },
    {
        "content": "<p>Wikipedia explains a coordinate-free definition of trace (<a href=\"https://en.wikipedia.org/wiki/Trace_(linear_algebra)#Coordinate-free_definition\">https://en.wikipedia.org/wiki/Trace_(linear_algebra)#Coordinate-free_definition</a>), so it seems like something can be done?</p>",
        "id": 235553039,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619027341
    },
    {
        "content": "<p>To write down the inverse map Hom(V,V) -&gt; V tensor V^* (necessary to do the computation) you need to pick a basis. The map V tensor V^* -&gt; Hom(V,V) is not a bijection in the infinite-dimensional case (it's an injection, with image the finite rank maps)</p>",
        "id": 235553329,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619027456
    },
    {
        "content": "<p><span aria-label=\"anguish\" class=\"emoji emoji-1f62b\" role=\"img\" title=\"anguish\">:anguish:</span> Ooh, thanks for clarifying! The assumption is still hidden in there</p>",
        "id": 235553958,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619027737
    },
    {
        "content": "<p>Writing maps from tensor products is easy because of the universal property. To write down a map into a tensor product is a different story; to access all elements of the tensor product you typically need a \"model\", i.e. a basis for each of the vector spaces, giving you a basis for the tensor product.</p>",
        "id": 235554099,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619027784
    },
    {
        "content": "<p>But there is a coordinate-free definition of determinant via top exterior powers. Then det(1+tA)=1+t*tr(A) in k[t]/(t^2) does the job, right?</p>",
        "id": 235554288,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619027870
    },
    {
        "content": "<p>Models of objects in mathematics are fascinating and I knew nothing about this stuff until I started formalising. The universal property only gets you so far. To prove that the kernel of the canonical map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>→</mo><mi>R</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>S</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">R\\to R[1/S]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">]</span></span></span></span> is the r such that there exists s with rs=0 you don't seem to be able to get this from the universal property alone: you seem to need the explicit model of R[1/S] as R x S / ~. Picking a model for the localisation is like picking a basis for the vector space.</p>",
        "id": 235554407,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619027913
    },
    {
        "content": "<p>I guess you can push everything into the computation that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mo>⋀</mo><mi>n</mi></msup><mi>V</mi><mo>≅</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">\\bigwedge^n V \\cong k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.054302em;vertical-align:-0.25001em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">⋀</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.804292em;\"><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>dim</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>V</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">\\dim(V) = n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">dim</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>. You will need to use a basis at some point.</p>",
        "id": 235554451,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619027942
    },
    {
        "content": "<p>Yes, in this approach the basis is hidden in the proof that the n'th wedge power is 1-dimensional.</p>",
        "id": 235554526,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619027997
    },
    {
        "content": "<p>Even talking about dimension is problematic if you're not allowed to pick a basis. Dimension is \"size of any basis\".</p>",
        "id": 235554777,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619028089
    },
    {
        "content": "<p>We need a constructivist to explain to us what's going on. I'll ask on Twitter.</p>",
        "id": 235554929,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619028151
    },
    {
        "content": "<p>We probably need bases at some point in development, but not matrices.<br>\nI was just making the point that there is a fancy definition which is independent of a basis by construction.</p>",
        "id": 235555202,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619028245
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Eigenproperties.20of.20symmetric.20matrices/near/235554777\">said</a>:</p>\n<blockquote>\n<p>Even talking about dimension is problematic if you're not allowed to pick a basis. Dimension is \"size of any basis\".</p>\n</blockquote>\n<p>Dimension is a size of a maximal flag of subspaces minus 1 ;)</p>",
        "id": 235555250,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619028272
    },
    {
        "content": "<p>Aha, and then you prove by induction that the top wedge is 1-dimensional. Sweet.</p>",
        "id": 235555698,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619028396
    },
    {
        "content": "<p>How do you know a maximal flag exists? Wait -- I don't even understand the question. What does it mean to say a vector space is finite-dimensional? Is the definition that it's Noetherian? In which case we might be on to something.</p>",
        "id": 235556723,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619028724
    },
    {
        "content": "<p>In mathlib <code>finite_dimensional</code> is in terms of noetherian, yes.</p>",
        "id": 235556835,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619028771
    },
    {
        "content": "<p>But how do we know that all max flags have the same size?</p>",
        "id": 235556943,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619028827
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Eigenproperties.20of.20symmetric.20matrices/near/235553329\">said</a>:</p>\n<blockquote>\n<p>To write down the inverse map Hom(V,V) -&gt; V tensor V^* (necessary to do the computation) you need to pick a basis. The map V tensor V^* -&gt; Hom(V,V) is not a bijection in the infinite-dimensional case (it's an injection, with image the finite rank maps)</p>\n</blockquote>\n<p>But we don't need to write it down, right? You can characterize the image of id uniquely as the only GL(V)-invariant vector such that the natural pairing V tensor V* sends it to 1.</p>",
        "id": 235557242,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619028961
    },
    {
        "content": "<p>But how do we prove it exists though</p>",
        "id": 235557301,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619028974
    },
    {
        "content": "<p>Developing even basics of representation theory of GL(V), which we do not know to be an algebraic group lacking (g \\in GL(V) \\iff det(g) \\neq 0) seems challenging</p>",
        "id": 235557431,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619029033
    },
    {
        "content": "<p>challenging unless you pick a basis, which I thoroughly recommend doing :-)</p>",
        "id": 235557469,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619029061
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Eigenproperties.20of.20symmetric.20matrices/near/235556943\">said</a>:</p>\n<blockquote>\n<p>But how do we know that all max flags have the same size?</p>\n</blockquote>\n<p>Because GL(V) acts transitively on the set of all complete flags by induction</p>",
        "id": 235557848,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619029229
    },
    {
        "content": "<p>It suffices to prove that GL(V) acts transitively on vectors</p>",
        "id": 235557879,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619029249
    },
    {
        "content": "<p>Which you can reduce to the 2-dimensional case</p>",
        "id": 235557937,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619029271
    },
    {
        "content": "<p>I don't think we can induct. I think this is the problem. It's like trying to prove things on fintype by inducting, but not every fintype is equal to a disjoint union of two smaller fintypes.</p>",
        "id": 235557992,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619029284
    },
    {
        "content": "<p>I am still not convinced we can define dimension without picking a basis. For all I know in a Noetherian F-vector space there are flags of arbitrarily large finite length.</p>",
        "id": 235558041,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619029317
    },
    {
        "content": "<p>That's like Noetherian induction in algebraic geometry, yes</p>",
        "id": 235558045,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619029319
    },
    {
        "content": "<p>All proper subtypes ok =&gt; type ok</p>",
        "id": 235558127,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619029344
    },
    {
        "content": "<p>Maybe the right proof is to figure out exterior powers and than obtain invariance of dimension as a corollary?</p>",
        "id": 235558250,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619029400
    },
    {
        "content": "<p>When you define determinant by a formula, you don't use that all bases have the same size at all, you just define</p>",
        "id": 235558292,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619029430
    },
    {
        "content": "<p>I'm not sure how to do this in type theory. Coincidentally I was thinking about this today when formalising liquid stuff. We're supposed to be proving a theorem about fintypes by induction on size of the fintype but I realised that this was a bit terrifying because I would need to prove that the truth value of my statement about fintypes factored through the cardinality function.</p>",
        "id": 235558363,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619029450
    },
    {
        "content": "<p>Another characterization of f.d.v.s. is as the compact objects in the category of vector spaces</p>",
        "id": 235558396,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1619029463
    },
    {
        "content": "<p>In the end I decided to switch to finsets.</p>",
        "id": 235558398,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619029464
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/Eigenproperties.20of.20symmetric.20matrices/near/235558396\">said</a>:</p>\n<blockquote>\n<p>Another characterization of f.d.v.s. is as the compact objects in the category of vector spaces</p>\n</blockquote>\n<p>This still doesn't give you a well-defined dimension without picking a basis.</p>",
        "id": 235558435,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619029488
    },
    {
        "content": "<p>The dimension is the trace of the identity morphism</p>",
        "id": 235558545,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1619029555
    },
    {
        "content": "<p>sorry I'm just catching up on this discussion now</p>",
        "id": 235558715,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1619029634
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/Eigenproperties.20of.20symmetric.20matrices/near/235558545\">said</a>:</p>\n<blockquote>\n<p>The dimension is the trace of the identity morphism</p>\n</blockquote>\n<p>does not work in char p :(</p>",
        "id": 235558813,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619029679
    },
    {
        "content": "<p>bah take Witt vectors</p>",
        "id": 235558918,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1619029708
    },
    {
        "content": "<p>(obviously that's not a real suggestion, but I'm trying to come up with a basis-free definition like Kevin was asking)</p>",
        "id": 235558976,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1619029733
    },
    {
        "content": "<p>What if we define finite-dimensional as V -&gt; V** is surjective?</p>",
        "id": 235559092,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619029791
    },
    {
        "content": "<p>What's wrong with the compact object definition?</p>",
        "id": 235559241,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1619029854
    },
    {
        "content": "<p>There's this notion of a compact closed monoidal category where objects have duals. If you have some general closed monoidal category which also happens to be locally presentable (and maybe one needs some compatibility with the monoidal structure) is it not the case that the subcategory of compact objects is compact closed monoidal? I couldn't find anything along these lines on the nLab, but I'm sure something along these lines has been written down somewhere...</p>",
        "id": 235560268,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1619030298
    },
    {
        "content": "<p>Oh, and you can define the dimension of a vector space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> as the Krull dimension of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">y</mi><mi mathvariant=\"normal\">m</mi></mrow><mi>k</mi><mo>∗</mo></msubsup><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Sym}_k^*V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.008926em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">S</span><span class=\"mord mathrm\" style=\"margin-right:0.01389em;\">y</span><span class=\"mord mathrm\">m</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.761926em;\"><span style=\"top:-2.4530000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span><span style=\"top:-3.1362300000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 235560645,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1619030477
    },
    {
        "content": "<p>(again, not a serious suggestion)</p>",
        "id": 235560667,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1619030495
    },
    {
        "content": "<p>The problem with that definition is that a general Noetherian ring might have infinite Krull dimension.</p>",
        "id": 235560700,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619030507
    },
    {
        "content": "<p>Why is that a problem?</p>",
        "id": 235560785,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1619030534
    },
    {
        "content": "<p>The following seems to be (an overcomplicated) strategy:<br>\nStep 1. If k is the field of real numbers, and V is a finite-dimensional vector space, then V is locally compact with respect to the weak topology defined by V*. Therefore, V has a unique Haar measure up to scaling. Define for an f: V -&gt; V its determinant to be the constant, on which it multiplies the Haar measure if f is in the connected component of GL(V), and negative that constant otherwise. Define tr(f)=d/dt det(1+tf) at 0.<br>\nStep 2. If k is a field of complex numbers, then End_k(V) is a subspace of End_R(V). Define trace over k as half the trace over the reals.<br>\nStep 3. If k is a ring Z[x1,...,xn], embed it into C and use step 2.<br>\nStep 4. If k a ring of finite type over Z, use step 4, and then pass to colimits.</p>",
        "id": 235560959,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619030641
    },
    {
        "content": "<p>We don't even need to care about the sign of det, I guess</p>",
        "id": 235561090,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619030696
    },
    {
        "content": "<p>I would be happy with a construction over the reals and I can quite believe that you can then spread out. So my instinct is to look for the sneaky basis-choosing in step 1.</p>",
        "id": 235561223,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619030757
    },
    {
        "content": "<p>Ok, one issue is to prove V is Hausdorff aka that linear functions separate points of V.</p>",
        "id": 235561459,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619030836
    },
    {
        "content": "<p>Maybe it's hard to prove that V is locally compact? My model for a \"bad\" V is one which has linearly independent subsets of size n for all n but which is still Noetherian.</p>",
        "id": 235561484,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619030840
    },
    {
        "content": "<p>If we're defining V to be finite-dimensional if it's Noetherian then we need to rule out the possibility that there are Noetherian modules with arbitrary large ascending chains all of which are finite. This is what choosing the basis does for you -- you can show the basis is a concrete bound for the length of any chain. But a random Noetherian module can I think have arbitrarily large ascending chains -- there are infinite-dimensional Noetherian rings, right?</p>",
        "id": 235561731,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619030961
    },
    {
        "content": "<p>Yeah I think there are examples by Nagata?</p>",
        "id": 235561999,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1619031075
    },
    {
        "content": "<p>Guess you can prove existence of linear functionals by just throwing in Zorn lemma and not caring.<br>\nIf we know that V* is finitely generated, then you can get a closed embedding V -&gt; R^n, hence V is locally compact. Not sure if that counts as picking a basis, more of a usage that V is a projective R-module.</p>",
        "id": 235562033,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619031093
    },
    {
        "content": "<p>The thing I'm not so sure about is why det(1+tf) is differentiable</p>",
        "id": 235562159,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619031151
    },
    {
        "content": "<p>Well, let's say that differentiability in V makes sense somehow and that we have an access to a smooth bump function \\phi with integral 1. Then det(1+tf)= \\int \\phi(1+tf(x)) dx, which is smooth by some Analysis 2, I guess?</p>",
        "id": 235562434,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619031284
    },
    {
        "content": "<p>I think that when it has got to this point it's just better to ask a constructivist/foundational person to prove that it can't be done without picking a basis, rather than trying to construct more elaborate arguments. My mental model of mathematics says that if you can't do it with easy stuff then you're never going to be doing it with Haar measure.</p>",
        "id": 235562823,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619031448
    },
    {
        "content": "<p>Well, it does sometimes happen that an elaborate argument for a simple fact is actually non-circular. There is a proof of the fundamental theorem of algebra using Gauss-Bonnet theorem: <a href=\"https://arxiv.org/abs/1106.0924\">https://arxiv.org/abs/1106.0924</a><br>\nThere was also the proof using stochastic integration, I believe</p>",
        "id": 235563387,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1619031636
    },
    {
        "content": "<p>The sensible constructive definition of \"V is finite dimensional\" is \"V is merely isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>k</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">k^n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> for some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>\". In mathlib the type for this is <code>trunc (Σ n : ℕ, V ≃ₗ[k] fin n → k)</code>. This is by definition a subsingleton but it still carries data. It's perfectly analogous to the definition of \"A is a finite type\", which is (equivalent to) \"A merely bijects with <code>fin n</code> for some n\" (even in Lean!).</p>\n<p>So basically, as in real mathematics, if V is finite dimensional, then it has a basis, and you can use this basis in your constructions, <strong>provided</strong> that you then check that the choice of basis doesn't matter (this is part of <code>trunc</code>-elimination). For example if you want to define the dimension of a finite-dimensional vector space, you have to check that all bases have the same size. In other words, if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>k</mi><mi>m</mi></msup><mo>≅</mo><msup><mi>k</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">k^m \\cong k^n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">m = n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>. This is not totally obvious but it's something we learn how to do. Again this is perfectly analogous to the cardinality of a finite type -- you have to check that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>m</mi><mo stretchy=\"false\">]</mo><mo>≅</mo><mo stretchy=\"false\">[</mo><mi>n</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[m] \\cong [n]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">]</span></span></span></span> implies <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">m = n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>.</p>\n<p>Returning to the definition of trace, consider the fact that if V is finite-dimensional then the evaluation map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>→</mo><msup><mi>V</mi><mrow><mo>∗</mo><mo>∗</mo></mrow></msup></mrow><annotation encoding=\"application/x-tex\">V \\to V^{**}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.688696em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">∗</span><span class=\"mord mtight\">∗</span></span></span></span></span></span></span></span></span></span></span></span> is an isomorphism. This is a subsingleton (a map has at most one two-sided inverse), so the second part of <code>trunc</code>-elimination is trivial and we can just assume <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> has a finite basis. So it suffices to check it for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>k</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">k^n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> basically, which is straightforward. Same thing with the fact that the obvious map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>⊗</mo><msup><mi>V</mi><mo>∗</mo></msup><mo>→</mo><mi>H</mi><mi>o</mi><msub><mi>m</mi><mi>k</mi></msub><mo stretchy=\"false\">(</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>V</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">V \\otimes V^* \\to Hom_k(V, V)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.688696em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mclose\">)</span></span></span></span> is an isomorphism when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> is finite-dimensional, or the fact that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mo>⋀</mo><mi>n</mi></msup><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">\\bigwedge^n V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.054302em;vertical-align:-0.25001em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">⋀</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.804292em;\"><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> is one-dimensional for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mi>dim</mi><mo>⁡</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">n = \\dim V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mop\">dim</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span>.</p>",
        "id": 235567009,
        "sender_full_name": "David Wärn",
        "timestamp": 1619033068
    },
    {
        "content": "<p>NB there are weaker definitions of \"A is a finite set\" for which the cardinality of A becomes noncomputable. For example knowing that A embeds in a finite set does not let you compute the cardinality of A -- any proposition embeds in <code>unit</code>, but computing the cardinality of a proposition means deciding if it's true or false. (Similarly knowing that A has a surjection from a finite set does not help.) By the same token, knowing that V embeds in a finite-dimensional vector space (or doesn't have an infinite independent set or whatever) doesn't let you compute the dimension of V.</p>",
        "id": 235570299,
        "sender_full_name": "David Wärn",
        "timestamp": 1619034509
    },
    {
        "content": "<p>I see, so the issue is that we have a nonconstructive definition of finite-dimensional (\"V is Noetherian\") and then we're trying to do something which moves from the Prop world (\"there exists a basis\") to the Type world (\"this is its size\" / \"this is a matrix\").</p>",
        "id": 235586638,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619041085
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113489-new-members/topic/Eigenproperties.20of.20symmetric.20matrices/near/235540774\">said</a>:</p>\n<blockquote>\n<p>I'm late to the party but I'm extremely worried about trying to merge this into mathlib. Why working with matrices instead of endomorphisms? I think going down the mathematical road (first endomorphisms and then deduce results about matrices if they are needed somewhere) would be much cleaner.</p>\n</blockquote>\n<p>Thanks for the suggestion! I made that file to practice solving some lemmas for a uni project I have. Clearly, my approach is clumsy, but maybe some of the simple lemmas that I use could be added to mathlib to make calculations easier (so far I am trying to add simple lemmas to the data.matrix.basic file about dot_products and stuff like that).</p>",
        "id": 235804560,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1619166096
    },
    {
        "content": "<p>I do have a question though, do you think it would something desired to also add a section about vectors on C and operations with them? Like in my file I have a definition <code>vec_conj</code> and some lemmas with dot_product and norm_sq? Would those help mathlib and if so, where do they fit in?</p>",
        "id": 235804741,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1619166192
    },
    {
        "content": "<p>With <code>C</code> you mean the complex numbers?</p>",
        "id": 235805145,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619166382
    },
    {
        "content": "<p>I think there is already a bunch of stuff for an \"arbitrary\" field that is <code>is_R_or_C</code>.</p>",
        "id": 235805183,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619166417
    },
    {
        "content": "<p>But I haven't used that much. Hopefully others can chime in.</p>",
        "id": 235805231,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619166461
    },
    {
        "content": "<p>Yes, I meant the complex numbers.</p>",
        "id": 235805348,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1619166527
    },
    {
        "content": "<p>Oh, I will have a look into that then.</p>",
        "id": 235805423,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1619166588
    },
    {
        "content": "<p>But for that I think I would need to prove that <code>(V -&gt; C)</code> is an instance of <code>is_R_or_C</code>, with V an indexing type.</p>",
        "id": 235806511,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1619167161
    },
    {
        "content": "<p>No, that won't work. The coefficients of a vector live in such a field, but the vector itself doesn't.</p>",
        "id": 235806695,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619167247
    },
    {
        "content": "<p>Does it make sense to define a pi.star_ring which would provide <code>vec_conj</code> as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/star\">docs#star</a>?</p>",
        "id": 235807954,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619168048
    },
    {
        "content": "<p>We already imbue pi types with most operations elementwise</p>",
        "id": 235808091,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619168121
    },
    {
        "content": "<p>So doing the same for the star \"operator\" doesn't seem totally unreasonable</p>",
        "id": 235808112,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619168139
    },
    {
        "content": "<p>I like it.</p>",
        "id": 235819311,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619174264
    },
    {
        "content": "<p>I'll make the quick PR</p>",
        "id": 235820124,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619174780
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/7342\">#7342</a></p>",
        "id": 235821614,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619175667
    },
    {
        "content": "<p>I noticed that having a coercion from real-valued matrices to complex-valued matrices means that I need to write a lot of  explicit coercions<code>(M : matrix V V ℂ)</code>, but that makes reading difficult especially when I have equations like in line 248 from <a href=\"https://github.com/gabrielmoise/Lean-work/blob/master/symm_matrix.lean\">https://github.com/gabrielmoise/Lean-work/blob/master/symm_matrix.lean</a> :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">mul_vec</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">V</span> <span class=\"n\">V</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">•</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">mul_vec</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">V</span> <span class=\"n\">V</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">mul_vec</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">V</span> <span class=\"n\">V</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">•</span> <span class=\"n\">w</span><span class=\"o\">),</span>\n</code></pre></div>\n<p>and I would like to transform this thing into a notation. Can I create a notation that depends on an input M of a certain type (matrix V V ℝ)?</p>",
        "id": 235963871,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1619264310
    },
    {
        "content": "<p>Sure --- just set up the notation, and it won't typecheck if you give it the wrong input. This is not something you really have to specify at the notation level.</p>",
        "id": 235964641,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619265175
    },
    {
        "content": "<p>Are you sure you need the coercions at all?</p>",
        "id": 235964841,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619265424
    },
    {
        "content": "<p>That is, can you state the lemmas for a more general case than \\C which includes <code>\\R</code>?</p>",
        "id": 235964863,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619265467
    },
    {
        "content": "<p>I commend <code>is_R_or_C</code> to you!</p>",
        "id": 235965030,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619265612
    },
    {
        "content": "<p>Well, my proofs  require the fact that I am using a matrix that is real-valued and my matrix-vector operations require that this matrix is coerced to a complex-valued operation. So that was my first idea, but I can adjust it.  What I wanted to try for now is something like this: (don't mind the notation, it will probably be changed to something more appropriate)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">n</span><span class=\"o\">]</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">M</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">⟩)⟩</span>\n\n<span class=\"kd\">notation</span> <span class=\"bp\">`$`</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"c1\">-- invalid notation declaration, contains reference to local variables</span>\n</code></pre></div>\n<p>But apparently this doesn't work.</p>",
        "id": 235965253,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1619265800
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113489-new-members/topic/Eigenproperties.20of.20symmetric.20matrices/near/235965030\">said</a>:</p>\n<blockquote>\n<p>I commend <code>is_R_or_C</code> to you!</p>\n</blockquote>\n<p>I am exploring this idea as well, thank you! <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 235965271,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1619265828
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366674\">Gabriel Moise</span> <a href=\"#narrow/stream/113489-new-members/topic/Eigenproperties.20of.20symmetric.20matrices/near/235471352\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/gabrielmoise/Lean-work/blob/master/symm_matrix.lean\">https://github.com/gabrielmoise/Lean-work/blob/master/symm_matrix.lean</a><br>\nYes, some of the lemmas are more general (delimitated them with comments) and would fit into the data.matrix.basic file</p>\n</blockquote>\n<p>I updated the file so that now it is hopefully up to a better standard. I'll probably try to PR some lemmas from there. Thanks for the help! <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> (any other suggestion is more than welcomed)</p>",
        "id": 236085579,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1619376846
    },
    {
        "content": "<p>The <code>star_test</code> instance you have is provided for you if you import <code>algebra.star.pi</code></p>",
        "id": 236085832,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619377180
    },
    {
        "content": "<p>Oh thanks for the PR you did then! <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 236085970,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1619377291
    },
    {
        "content": "<p>Although from what I can tell you didn't end up using it anyway</p>",
        "id": 236085982,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619377307
    },
    {
        "content": "<p>Yeah, I had two lemmas using the star instances, but I managed to avoid using them in the important theorems. But it was a good exercise.</p>",
        "id": 236086496,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1619377750
    },
    {
        "content": "<p>I think there's some glue missing between <code>is_R_or_C</code> and <code>has_star</code> that might help eventually</p>",
        "id": 236087214,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619378562
    },
    {
        "content": "<p>How can I specify that I am working on a ring structure that has <code>(1 : R) ≠ 0</code> i.e. that this is not a zero ring? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">specify</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 236633171,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1619682825
    },
    {
        "content": "<p><code>[nontrivial R]</code></p>",
        "id": 236633487,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619682971
    },
    {
        "content": "<p>Which gives you access to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/zero_ne_one\">docs#zero_ne_one</a></p>",
        "id": 236633509,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619682984
    }
]
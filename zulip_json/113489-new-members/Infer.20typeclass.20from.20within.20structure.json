[
    {
        "content": "<p>Here is a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> of the issue I'm running into. I have a typeclass I want to use as an inferred argument <code>[my_class X]</code> and a structure that bundles the data of an <code>X : Type</code> and a corresponding <code>my_class X</code> instance. But then the instance doesn't seem to be visible for automatic typeclass inference later on.</p>\n<p>Toy example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">my_class</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">elem</span> <span class=\"o\">[]</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">my_class</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cool_map</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">my_class</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">my_class</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">elem</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">elem</span> <span class=\"n\">Y</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">cool_structure</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">my_class</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">my_class</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">cool_map</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">some_lemma</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">my_class</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">cool_structure</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">elem</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">elem</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">cool_map</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">∘</span> <span class=\"n\">C.f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">failed to synthesize type class instance for</span>\n<span class=\"cm\">Y : Type,</span>\n<span class=\"cm\">_inst_1 : my_class Y,</span>\n<span class=\"cm\">C : cool_structure Y,</span>\n<span class=\"cm\">g : Y → Y,</span>\n<span class=\"cm\">hg : g (elem Y) = elem Y</span>\n<span class=\"cm\">⊢ my_class C.X</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>Of course, there <em>is</em> a <code>my_class C.X</code> instance, namely <code>C.α</code>. If I write <code>@cool_map _ _ C.α _ (g ∘ C.f)</code> then it works, but this is sort of annoying (even in this toy example it takes a bunch of dashes; in my actual example I want to avoid the <code>@</code> notation).</p>\n<p>Is there a way to make this kind of structure work? Or, a better way to do this? It seems like a design question (what goes in the structure and what stays outside of it) that would come up a lot...</p>",
        "id": 252960328,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1631423833
    },
    {
        "content": "<blockquote>\n<p>Of course, there is a my_class C.X instance, namely C.α.</p>\n</blockquote>\n<p>But that's not an <em>instance</em>: You never declared it as such. If you use <code>instance : my_class C.X := C.α</code> then it should work</p>",
        "id": 252960529,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631424113
    },
    {
        "content": "<p>Or just <code>attribute [instance] C.α</code></p>",
        "id": 252967520,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1631432445
    },
    {
        "content": "<p>Ah, I see. Looks like either of those lines can go right below the structure definition:</p>\n<p><code>instance (Y : Type) [my_class Y] (C : cool_structure Y) : my_class C.X := C.α</code><br>\nor<br>\n<code>attribute [instance] cool_structure.α</code></p>\n<p>That's exactly what I needed. Thank you both!</p>",
        "id": 252991965,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1631458444
    },
    {
        "content": "<p>The usual thing to do is to declare a <code>has_coe_to_sort</code> using your <code>cool_structure.X</code> and then declare a <code>my_class C</code> instance for <code>C : cool_structure</code> using <code>C.\\alpha</code>. <br>\nTake a look e.g. at the code around <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Group/src\">src#Group</a></p>",
        "id": 252992280,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1631458803
    },
    {
        "content": "<p>Followup question to all this (possibly related to Adam Topaz's suggestion re: coercions, I think this question is undoubtedly already answered by the choices made in defining group and ring maps, but the code in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Group/src\">src#Group</a> is quite abstract for me, I don't get what's going on in it).</p>\n<p>In the toy setting above (I guess my toy example was maps of pointed sets, plus \"pointed sets over a base pointed set\" or something). Would it be better to have defined <code>cool_map</code> as a structure containing both the map and the property? So instead of</p>\n<p><code>def cool_map {X Y : Type} [my_class X] [my_class Y] (map : X → Y) :=  map (elem X) = elem Y)</code></p>\n<p>I would do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">cool_map</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">my_class</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">my_class</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">elem</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">elem</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">my_class</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">my_class</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">cool_map</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">α.map</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>Maybe I would rather use this approach since, for one thing, it makes cleaner theorem statements to have the information in a <code>cool_map</code> packaged together. Likewise for continuous functions or whatever other category.</p>\n<p>But, then I am not sure the best way to declare other structures on top of it. For example, say I want to define a <code>cool_equiv X Y</code> that consists of an <code>equiv X Y</code> using <code>cool_map</code>s instead of arbitrary functions. In this situation I would want to be able to go <em>either</em> from a <code>cool_equiv</code> (or whatever) to a normal <code>equiv</code>, or to the associated <code>cool_map</code>s. I can say</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">cool_equiv</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">my_class</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">my_class</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">equiv</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">cool</span> <span class=\"o\">:</span> <span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">elem</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">elem</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">inv_cool</span> <span class=\"o\">:</span> <span class=\"n\">inv_fun</span> <span class=\"o\">(</span><span class=\"n\">elem</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">elem</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">my_class</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">my_class</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">cool_equiv</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">cool_equiv.to_cool_map</span> <span class=\"o\">:</span> <span class=\"n\">cool_map</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">φ.to_fun</span><span class=\"o\">,</span> <span class=\"n\">φ.cool</span><span class=\"o\">⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">cool_equiv.inv_cool_map</span> <span class=\"o\">:</span> <span class=\"n\">cool_map</span> <span class=\"n\">Y</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">φ.inv_fun</span><span class=\"o\">,</span> <span class=\"n\">φ.inv_cool</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>or I can instead package in the <code>cool_map</code>s and write the coercion to <code>equiv X Y</code> separately.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">cool_equiv'</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">my_class</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">my_class</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">to_cool_map</span> <span class=\"o\">:</span> <span class=\"n\">cool_map</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">inv_cool_map</span> <span class=\"o\">:</span> <span class=\"n\">cool_map</span> <span class=\"n\">Y</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">left_inv</span> <span class=\"o\">:</span> <span class=\"n\">function.left_inverse</span> <span class=\"n\">inv_cool_map</span> <span class=\"n\">to_cool_map</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">right_inv</span> <span class=\"o\">:</span> <span class=\"n\">function.right_inverse</span> <span class=\"n\">inv_cool_map</span> <span class=\"n\">to_cool_map</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">my_class</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">my_class</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">cool_equiv'</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">equiv</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">φ</span><span class=\"o\">,</span> <span class=\"n\">equiv.mk</span> <span class=\"n\">φ.to_cool_map</span> <span class=\"n\">φ.inv_cool_map</span> <span class=\"n\">φ.left_inv</span> <span class=\"n\">φ.right_inv</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>I'm just wondering which of these approaches is better, and/or if either would cause me pain further down the road. Or, maybe there's some other way that's better?</p>",
        "id": 252997899,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1631464991
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"391579\">@Jake Levinson</span>  is there some mathematical concept you're trying to model here? Pointed types?</p>",
        "id": 252999568,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1631466834
    },
    {
        "content": "<p>The way ring_equivs are set up are independent of ring_hom. One does not need two ring_hom to make a ring_equiv. But I think there is a helper constructor that can take two ring_homs and make a ring_equiv, with the proper constraint that they are inverses</p>",
        "id": 252999815,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1631467114
    },
    {
        "content": "<p>So I think that implies that the structure extends equiv is the better approach.</p>",
        "id": 252999847,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1631467178
    },
    {
        "content": "<p>You can always bake in the forward direction proof of coolness by doing</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">my_cool_equiv</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"bp\">..</span><span class=\"n\">my_cool_hom</span><span class=\"o\">,</span> <span class=\"n\">other_field</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 252999942,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1631467278
    },
    {
        "content": "<p>It doesn't really matter if you make the right API e.g. you can just define a <code>cool_equiv.to_equiv</code> function and a <code>cool_equiv.mk'</code> constructor</p>",
        "id": 253000454,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1631467898
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/Infer.20typeclass.20from.20within.20structure/near/252999568\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"391579\">Jake Levinson</span>  is there some mathematical concept you're trying to model here? Pointed types?</p>\n</blockquote>\n<p>The actual example that prompted my post isn't so different from pointed types: continuous fiber bundle maps, and in particular the \"continuous\" part. I had already made some working API for \"maps of fiber bundles\" without any continuity conditions, so I was trying to <code>extend</code> my various fiber-bundle-related structures to add hypotheses about all the maps being continuous. I ran into the issue sketched about above when defining a <code>cts_bundle_equiv</code> since I had to decide how to relate it to <code>bundle_equiv</code> and <code>cts_bundle_map</code> which I had defined previously.</p>\n<p>(I also ran into the simpler version of this question when defining continuous functions originally, and for whatever reason chose the other way -- defining <code>cts</code> as a property of functions rather than as part of a <code>cts_map</code> structure.)</p>",
        "id": 253019088,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1631488790
    },
    {
        "content": "<p>I see. Presumably you need to add <a href=\"https://leanprover-community.github.io/mathlib_docs/find/continuous\">docs#continuous</a> properties for the functions you use, or perhaps use bundled continuous maps instead of functions (we have such bundled continuous maps in mathlib)</p>",
        "id": 253020438,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1631490482
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/continuous_map\">docs#continuous_map</a></p>",
        "id": 253020503,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1631490572
    }
]
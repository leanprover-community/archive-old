[
    {
        "content": "<p>Why does the second example below not even type check?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">set</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"err\">∪</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"err\">∪</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">union_comm</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"c1\">-- this works, of course</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"err\">∪</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"err\">∪</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"c1\">-- why does this not even typecheck?</span>\n</code></pre></div>",
        "id": 207764003,
        "sender_full_name": "Robert Brijder",
        "timestamp": 1598174231
    },
    {
        "content": "<p>Ah, sorry, I see it now. It seems to be a parenthesis thing</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">s</span> <span class=\"err\">∪</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">t</span> <span class=\"err\">∪</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"c1\">-- this typechecks</span>\n</code></pre></div>",
        "id": 207764170,
        "sender_full_name": "Robert Brijder",
        "timestamp": 1598174546
    },
    {
        "content": "<p>oh that looks like trouble coming</p>",
        "id": 207764853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598175853
    },
    {
        "content": "<p>equality of types is a Bad Thing</p>",
        "id": 207764854,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598175867
    },
    {
        "content": "<p>Yes, I am beginning to realize that I am in trouble. Here is a MWE of the problem I faced when trying to formalize something </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">set</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">union_comm_func</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">s</span> <span class=\"err\">∪</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">t</span> <span class=\"err\">∪</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">union_comm</span> <span class=\"n\">s</span> <span class=\"n\">t</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">reducible</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">f_ones</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">f_ones</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"err\">∪</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"o\">(</span><span class=\"n\">union_comm_func</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f_ones</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"err\">∪</span> <span class=\"n\">t</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>This example looks not very nice and I don't know how to prove it. I would just like to say</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">f_ones</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"err\">∪</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f_ones</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"err\">∪</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>but I can't. What is the Good Thing to do?</p>",
        "id": 207765133,
        "sender_full_name": "Robert Brijder",
        "timestamp": 1598176334
    },
    {
        "content": "<p>And is there some documentation about good and bad practices for formalizing in Lean?</p>",
        "id": 207765769,
        "sender_full_name": "Robert Brijder",
        "timestamp": 1598177249
    },
    {
        "content": "<p>Don't talk about equality of functions between non-definitionally equal types I guess</p>",
        "id": 207765775,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598177278
    },
    {
        "content": "<p>This is a pretty vague question, but there are lots of resources listed at <a href=\"https://leanprover-community.github.io/learn.html\">https://leanprover-community.github.io/learn.html</a></p>",
        "id": 207765817,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1598177302
    },
    {
        "content": "<p>See also the playlist at <a href=\"https://www.youtube.com/watch?v=8mVOIGW5US4&amp;list=PLlF-CfQhukNlxexiNJErGJd2dte_J1t1N\">https://www.youtube.com/watch?v=8mVOIGW5US4&amp;list=PLlF-CfQhukNlxexiNJErGJd2dte_J1t1N</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"8mVOIGW5US4\" href=\"https://www.youtube.com/watch?v=8mVOIGW5US4&amp;list=PLlF-CfQhukNlxexiNJErGJd2dte_J1t1N\"><img src=\"https://i.ytimg.com/vi/8mVOIGW5US4/default.jpg\"></a></div>",
        "id": 207765834,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1598177362
    },
    {
        "content": "<p>Actually, why don't we prove that <code>eq.rec</code> is a group hom etc?</p>",
        "id": 207767945,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598180924
    },
    {
        "content": "<p>instead of just avoiding it like the plague</p>",
        "id": 207767949,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598180932
    },
    {
        "content": "<p>is this infeasible?</p>",
        "id": 207767952,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598180937
    },
    {
        "content": "<p>I have a dream: that one day we will stop relying on definitional equality</p>",
        "id": 207767964,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598180975
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/stream/113489-new-members/topic/Function.20on.20equal.20types/near/207767949\">said</a>:</p>\n<blockquote>\n<p>instead of just avoiding it like the plague</p>\n</blockquote>\n<p>OK, so the Good Thing is to avoid non-definitionally equal types like the plague. But how do I do this? Should I just refrain from proving certain mathematical statements or is there always a way around it? In particular, is there some alternative formalization of the (trivial) mathematical statement <code>f_ones (t ∪ s) = f_ones (s ∪ t)</code>in my example that avoids non-definitionally equal types?</p>",
        "id": 207775627,
        "sender_full_name": "Robert Brijder",
        "timestamp": 1598192346
    },
    {
        "content": "<p>There is a way. You are clearly fighting the system instead of playing with it, but we don't have enough context to understand what you are trying to do (see also <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>).</p>",
        "id": 207775880,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1598192736
    },
    {
        "content": "<p>Oh, I didn't know I was fighting the system. I do think a problem similar to the MWE arised naturally.</p>\n<p>Sure, I'll give some context. I want to formalize a result about a database query language in <a href=\"https://arxiv.org/abs/1904.03934\">this paper</a>. The theory is low-level and self-contained,  so it seems doable. This <a href=\"https://github.com/rbrijder/ARAk_lean\">lean code</a> is what I have now. It is mostly definitions. The problem is the commutativity of the union operation for relations: <code>theorem rel_union_comm</code>.</p>",
        "id": 207779499,
        "sender_full_name": "Robert Brijder",
        "timestamp": 1598198590
    },
    {
        "content": "<p>From a mathematical point of view, it boils down to this:  I am trying to define higher-dimensional matrices (tensors) and I am interested in formalizing a result about the expressivity of a certain set of operations on them (i.e., what kind of computations/queries I can do). If <code>X</code> is some finite set of dimensions of one tensor and <code>Y</code> of another, then union operation obtains a tensor with <code>X \\cup Y</code> as the set of dimensions. I would like to show (as a first tiny step) that union is commutative, but now I run into the trouble that I have a tensor with <code>X \\cup Y</code> as the set of dimensions and another with <code>Y \\cup X</code> as the set of dimensions. In the case of an ordinary matrix <code>X</code> would be {row, col}, and in the case of a column vector <code>X</code> would be {col}, but in this case <code>X</code> is arbitrary. Now, just like in matrix multiplication, we also need to keep track of the sizes of each dimension (or, more generally, assign of set of indices to each dimension) for things to make sense. The notion of relation in the linked github repo captures this notion of a tensor (it is called a relation instead of a tensor because of the database context).</p>\n<p>Any help on how to avoid non-definitionally equal types here is appreciated.</p>",
        "id": 207876956,
        "sender_full_name": "Robert Brijder",
        "timestamp": 1598292912
    },
    {
        "content": "<p>Instead of defining a function on s union t, why not define it on all of alpha and then ignore its values outside s union t?</p>",
        "id": 207877966,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598293344
    },
    {
        "content": "<p>You might want to look at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/holor\">docs#holor</a></p>",
        "id": 207878307,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1598293529
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Function.20on.20equal.20types/near/207877966\">said</a>:</p>\n<blockquote>\n<p>Instead of defining a function on s union t, why not define it on all of alpha and then ignore its values outside s union t?</p>\n</blockquote>\n<p>Perhaps that would work. So, I should store the \"real\" set of dimensions separately, say together as a structure?</p>",
        "id": 207878696,
        "sender_full_name": "Robert Brijder",
        "timestamp": 1598293688
    },
    {
        "content": "<p>I don't really know the type of the things you're talking about. I'm just saying that sets are terms and when you promote them to types, equal sets may become non-defeq types. On the other hand if you're only interested in equality of functions on these sets then you could define functions on a bigger type without doing the promotion which is causing the problem</p>",
        "id": 207879538,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598294082
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/Function.20on.20equal.20types/near/207878307\">said</a>:</p>\n<blockquote>\n<p>You might want to look at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/holor\">docs#holor</a></p>\n</blockquote>\n<p>Yes. The problem for me with that definition (and mine for that matter) is that the index set is baked-in the type, which apparently is something I should avoid.</p>",
        "id": 207879653,
        "sender_full_name": "Robert Brijder",
        "timestamp": 1598294133
    },
    {
        "content": "<p>It seems like you already have a way of moving <code>relation</code>s across subset inclusions, so one option is to move the two sides together using the inclusion of <code>X \\cup Y</code> in <code>Y \\cup X</code></p>",
        "id": 207880158,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598294343
    },
    {
        "content": "<p>Another option is to move the <code>X</code> index of the <code>relation</code> type into a structure field, so effectively work with <code>\\Sigma X, relation D X alpha</code></p>",
        "id": 207880434,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598294489
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Function.20on.20equal.20types/near/207879538\">said</a>:</p>\n<blockquote>\n<p>if you're only interested in equality of functions on these sets</p>\n</blockquote>\n<p>Unfortunately, I am not only interested in this. I do want to keep track of the real set of dimensions. Like in linear algebra, where one would need to be able to distinguish a vector from a matrix.</p>",
        "id": 207880564,
        "sender_full_name": "Robert Brijder",
        "timestamp": 1598294540
    },
    {
        "content": "<p>this can be awkward if you have operations which require two <code>relation</code>s with the same <code>X</code>, for example, but your existing operations don't appear to be of this sort</p>",
        "id": 207880618,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598294575
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/Function.20on.20equal.20types/near/207880618\">said</a>:</p>\n<blockquote>\n<p>this can be awkward if you have operations which require two <code>relation</code>s with the same <code>X</code>, for example, but your existing operations don't appear to be of this sort</p>\n</blockquote>\n<p>Unfortunately, one such operation requires this! (Actually, it is the union operation; I didn't want to over-complicate my message by saying that union is actually only defined if the index sets are equal. Details are in the above mentioned lean repo and paper.)</p>",
        "id": 207881134,
        "sender_full_name": "Robert Brijder",
        "timestamp": 1598294807
    },
    {
        "content": "<p>I'm actually looking at the repo and paper and I'm confused about this point</p>",
        "id": 207881179,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598294839
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">rel_union</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">D</span> <span class=\"n\">X</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r&#39;</span> <span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">D</span> <span class=\"n\">X&#39;</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n              <span class=\"n\">relation</span> <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">∪</span> <span class=\"n\">X&#39;</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">(</span><span class=\"n\">tuple_comp</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"n\">inclusion_compat</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">subset_union_left</span> <span class=\"n\">X</span> <span class=\"n\">X&#39;</span><span class=\"o\">)))</span> <span class=\"bp\">+</span>\n                                            <span class=\"n\">r&#39;</span><span class=\"o\">(</span><span class=\"n\">tuple_comp</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"n\">inclusion_compat</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">subset_union_right</span> <span class=\"n\">X</span> <span class=\"n\">X&#39;</span><span class=\"o\">))))</span>\n</code></pre></div>",
        "id": 207881196,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598294853
    },
    {
        "content": "<p>Indeed, isn't this the very function which originated this topic?</p>",
        "id": 207881297,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598294899
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/Function.20on.20equal.20types/near/207881297\">said</a>:</p>\n<blockquote>\n<p>Indeed, isn't this the very function which originated this topic?</p>\n</blockquote>\n<p>Yes, it is! I am defining it in the lean code in higher generality (thinking this might help in formalization), but the query language requires that X' = X. I have defined a notion of well-typed expressions in the lean code which says that the schemas should coincide.</p>",
        "id": 207881474,
        "sender_full_name": "Robert Brijder",
        "timestamp": 1598294999
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">ARA_well_typed</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">ARAe</span> <span class=\"n\">rel</span> <span class=\"n\">att</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">rel</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">att</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">ARAe</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"c1\">-- relnm</span>\n              <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">e1</span> <span class=\"n\">e2</span> <span class=\"n\">e1W</span> <span class=\"n\">e2W</span><span class=\"o\">,</span> <span class=\"n\">e1W</span> <span class=\"bp\">∧</span> <span class=\"n\">e2W</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">ARAschema</span> <span class=\"n\">e1</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">ARAschema</span> <span class=\"n\">e2</span> <span class=\"n\">S</span><span class=\"o\">))</span> <span class=\"c1\">-- union</span>\n              <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">Y</span> <span class=\"n\">e1</span> <span class=\"n\">e1W</span><span class=\"o\">,</span> <span class=\"n\">e1W</span><span class=\"o\">)</span> <span class=\"c1\">-- proj</span>\n              <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">Y</span> <span class=\"n\">hmutc</span> <span class=\"n\">e1</span> <span class=\"n\">e1W</span><span class=\"o\">,</span> <span class=\"n\">e1W</span><span class=\"o\">)</span> <span class=\"c1\">-- selection</span>\n              <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">φ</span> <span class=\"n\">hinj</span> <span class=\"n\">hc</span> <span class=\"n\">e1</span> <span class=\"n\">e1W</span><span class=\"o\">,</span> <span class=\"n\">e1W</span><span class=\"o\">)</span> <span class=\"c1\">-- rename</span>\n              <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">e1</span> <span class=\"n\">e2</span> <span class=\"n\">e1W</span> <span class=\"n\">e2W</span><span class=\"o\">,</span> <span class=\"n\">e1W</span> <span class=\"bp\">∧</span> <span class=\"n\">e2W</span><span class=\"o\">)</span> <span class=\"c1\">-- join</span>\n</code></pre></div>",
        "id": 207881672,
        "sender_full_name": "Robert Brijder",
        "timestamp": 1598295100
    },
    {
        "content": "<p>If you have a <code>relation</code> with <code>X</code> as a structure field then you can still impose a propositional condition <code>r.X = r'.X</code> if you want to.</p>",
        "id": 207881782,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598295143
    },
    {
        "content": "<p>It just might be less convenient than if you knew they were definitionally equal.</p>",
        "id": 207881823,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598295169
    },
    {
        "content": "<p>It looks like you're halfway down that road already with this definition of <code>ARA_well_typed</code></p>",
        "id": 207882056,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598295301
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/Function.20on.20equal.20types/near/207881823\">said</a>:</p>\n<blockquote>\n<p>It just might be less convenient than if you knew they were definitionally equal.</p>\n</blockquote>\n<p>Whatever is most convenient. If restricting the definition of union is better, then great.</p>",
        "id": 207882192,
        "sender_full_name": "Robert Brijder",
        "timestamp": 1598295365
    },
    {
        "content": "<p>It is not yet clear to me how I should define the notion of a relation.</p>",
        "id": 207882420,
        "sender_full_name": "Robert Brijder",
        "timestamp": 1598295485
    },
    {
        "content": "<p>so to be explicit, I am suggesting something like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">relation</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">dom_assign</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">schema</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">att</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">rel</span> <span class=\"o\">:</span> <span class=\"n\">tuple</span> <span class=\"n\">D</span> <span class=\"n\">schema</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">rel_join</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">D</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r&#39;</span> <span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">D</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>     <span class=\"c1\">-- for example</span>\n              <span class=\"n\">relation</span> <span class=\"n\">D</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">schema</span> <span class=\"o\">:=</span> <span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">schema</span> <span class=\"err\">∪</span> <span class=\"n\">r&#39;</span><span class=\"bp\">.</span><span class=\"n\">schema</span><span class=\"o\">,</span> <span class=\"n\">rel</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span> <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">rel_union</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">D</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r&#39;</span> <span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">D</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">schema</span> <span class=\"bp\">=</span> <span class=\"n\">r&#39;</span><span class=\"bp\">.</span><span class=\"n\">schema</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n              <span class=\"n\">relation</span> <span class=\"n\">D</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">schema</span> <span class=\"o\">:=</span> <span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">schema</span><span class=\"o\">,</span> <span class=\"c1\">--say</span>\n  <span class=\"n\">rel</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 207882454,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598295504
    },
    {
        "content": "<p>now that the schema is not exposed in the type of relations, it won't get in the way of formulating statements like commutativity</p>",
        "id": 207882524,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598295544
    },
    {
        "content": "<p>I see! By bundling the schema you make the types definitially equal. Thank you very much! I will try this.</p>",
        "id": 207882983,
        "sender_full_name": "Robert Brijder",
        "timestamp": 1598295738
    },
    {
        "content": "<p>Another situation you might think about is an expression like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">rel_union</span>\n  <span class=\"o\">(</span><span class=\"n\">rel_join</span> <span class=\"n\">r</span> <span class=\"n\">r&#39;</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">rel_join</span> <span class=\"n\">r&#39;</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>where <code>rel_union</code> has a type that enforces that the schemas agree.<br>\nThis expression is valid, but only because of a theorem in propositional logic. So either you have to reject this expression, or extend <code>rel_union</code> to the situation where the schemas might not be equal, or explain to Lean somehow why the expression makes sense.</p>",
        "id": 207883296,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598295871
    },
    {
        "content": "<p>This is just to point out that the issue is going to crop up other places besides <code>rel_union_comm</code>.</p>",
        "id": 207883439,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598295945
    },
    {
        "content": "<p>Oh dear, this is a valid expression in the language so I cannot reject this. It is the same problem of non-definitially-equal types again.</p>",
        "id": 207883835,
        "sender_full_name": "Robert Brijder",
        "timestamp": 1598296164
    },
    {
        "content": "<p>You might also be interested in the <a href=\"#narrow/stream/116395-maths/topic/CDGAs/near/167848869\">CDGA challenge topic</a> (where, probably not by coincidence, addition and multiplication play very similar roles to your <code>union</code> and <code>join</code>).</p>",
        "id": 207884207,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598296375
    },
    {
        "content": "<p>I see, a challenge for </p>\n<blockquote>\n<p>Anyone who doesn't already believe that this will be a mess</p>\n</blockquote>\n<p>And I was thinking formalizing this low-level self-contained paper would be a doable exercise for a beginner like me....</p>",
        "id": 207884992,
        "sender_full_name": "Robert Brijder",
        "timestamp": 1598296808
    },
    {
        "content": "<p>Bundling the domain indeed solved my problem: I can now prove that union on relations commutes. However, my proof is very slow using tactics <code>congr' 3</code> and <code>finish</code>. This seems unnecessary because I can get in a sane and fast way to this state:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">att</span> <span class=\"n\">dom</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"n\">att</span><span class=\"o\">,</span>\n<span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">dom_assign</span><span class=\"o\">,</span>\n<span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">semiring</span> <span class=\"n\">K</span><span class=\"o\">,</span>\n<span class=\"n\">r</span> <span class=\"n\">r&#39;</span> <span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">D</span> <span class=\"n\">K</span><span class=\"o\">,</span>\n<span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">tuple</span> <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">schema</span> <span class=\"err\">∪</span> <span class=\"n\">r&#39;</span><span class=\"bp\">.</span><span class=\"n\">schema</span><span class=\"o\">),</span>\n<span class=\"n\">a&#39;</span> <span class=\"o\">:</span> <span class=\"n\">tuple</span> <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"n\">r&#39;</span><span class=\"bp\">.</span><span class=\"n\">schema</span> <span class=\"err\">∪</span> <span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">schema</span><span class=\"o\">),</span>\n<span class=\"n\">a_1</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">==</span> <span class=\"n\">a&#39;</span>\n<span class=\"err\">⊢</span> <span class=\"n\">r&#39;</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"n\">tuple_comp</span> <span class=\"n\">a</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"n\">tuple_comp</span> <span class=\"n\">a</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"bp\">==</span> <span class=\"n\">r&#39;</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"n\">tuple_comp</span> <span class=\"n\">a&#39;</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"n\">tuple_comp</span> <span class=\"n\">a&#39;</span> <span class=\"bp\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>How do I finish such a goal in a proper way?</p>",
        "id": 208796269,
        "sender_full_name": "Robert Brijder",
        "timestamp": 1599037072
    },
    {
        "content": "<p>MWE</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span>\n<span class=\"kn\">import</span> <span class=\"n\">init</span><span class=\"bp\">.</span><span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">quot</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">setoid</span><span class=\"bp\">.</span><span class=\"n\">partition</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">theory</span>\n<span class=\"n\">local</span> <span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">prop_decidable</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ARA</span>\n<span class=\"kn\">section</span> <span class=\"n\">ARA</span>\n\n<span class=\"kn\">parameters</span> <span class=\"o\">{</span><span class=\"n\">rel</span> <span class=\"n\">att</span> <span class=\"n\">dom</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">setoid</span> <span class=\"n\">att</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">dom_assign</span> <span class=\"o\">:=</span> <span class=\"n\">quotient</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">dom</span>\n<span class=\"n\">def</span> <span class=\"n\">tuple</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">dom_assign</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">att</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">att</span><span class=\"o\">)),</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"o\">(</span><span class=\"n\">D</span><span class=\"err\">⟦</span><span class=\"n\">A</span><span class=\"err\">⟧</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">dom</span><span class=\"o\">)</span>\n<span class=\"kn\">structure</span> <span class=\"n\">relation</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">dom_assign</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">schema</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">att</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">rel</span> <span class=\"o\">:</span> <span class=\"n\">tuple</span> <span class=\"n\">D</span> <span class=\"n\">schema</span> <span class=\"bp\">→</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n<span class=\"n\">def</span> <span class=\"n\">compat_func</span> <span class=\"o\">{</span><span class=\"n\">att</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">setoid</span> <span class=\"n\">att</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">att</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">att</span><span class=\"o\">)</span> <span class=\"bp\">≈</span> <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">att</span><span class=\"o\">)</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">dom_assign</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">X&#39;</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">att</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">inclusion_compat</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">⊆</span> <span class=\"n\">X&#39;</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">compat_func</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inclusion</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">compat_att_eq_dom</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">att</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"err\">⟦</span><span class=\"n\">A</span><span class=\"err\">⟧</span> <span class=\"bp\">=</span> <span class=\"err\">⟦</span><span class=\"n\">B</span><span class=\"err\">⟧</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"err\">↥</span><span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"o\">(</span><span class=\"n\">D</span><span class=\"err\">⟦</span><span class=\"n\">A</span><span class=\"err\">⟧</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">dom</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"err\">↥</span><span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"o\">(</span><span class=\"n\">D</span><span class=\"err\">⟦</span><span class=\"n\">B</span><span class=\"err\">⟧</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">dom</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">congr</span> <span class=\"n\">rfl</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">coe</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">D</span> <span class=\"n\">h</span><span class=\"o\">))</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">func_compat_eq_dom</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">X&#39;</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">att</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">att</span><span class=\"o\">)}</span>\n<span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">compat_func</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">X&#39;</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">att</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"err\">⟦</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">att</span><span class=\"o\">)</span><span class=\"err\">⟧</span> <span class=\"bp\">=</span> <span class=\"err\">⟦</span><span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">att</span><span class=\"o\">)</span><span class=\"err\">⟧</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">eq_rel</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">compat_func</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">set_coe</span><span class=\"bp\">.</span><span class=\"k\">forall</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">setoid</span><span class=\"bp\">.</span><span class=\"n\">symm&#39;</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">A_val</span> <span class=\"n\">A_property</span><span class=\"o\">),</span>\n<span class=\"kn\">end</span>\n\n<span class=\"n\">def</span> <span class=\"n\">tuple_comp</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">X&#39;</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">att</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">att</span><span class=\"o\">)}</span>\n  <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">tuple</span> <span class=\"n\">D</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">compat_func</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tuple</span> <span class=\"n\">D</span> <span class=\"n\">X&#39;</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"o\">(</span><span class=\"n\">compat_att_eq_dom</span> <span class=\"o\">(</span><span class=\"n\">func_compat_eq_dom</span> <span class=\"n\">h</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">A</span><span class=\"o\">))))</span>\n\n<span class=\"n\">def</span> <span class=\"n\">rel_union</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">r&#39;</span> <span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">D</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">D</span> <span class=\"n\">K</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">schema</span> <span class=\"o\">:=</span> <span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">schema</span> <span class=\"err\">∪</span> <span class=\"n\">r&#39;</span><span class=\"bp\">.</span><span class=\"n\">schema</span><span class=\"o\">,</span>\n  <span class=\"n\">rel</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">rel</span><span class=\"o\">(</span><span class=\"n\">tuple_comp</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"n\">inclusion_compat</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">subset_union_left</span> <span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">schema</span> <span class=\"n\">r&#39;</span><span class=\"bp\">.</span><span class=\"n\">schema</span><span class=\"o\">)))</span> <span class=\"bp\">+</span>\n                <span class=\"n\">r&#39;</span><span class=\"bp\">.</span><span class=\"n\">rel</span><span class=\"o\">(</span><span class=\"n\">tuple_comp</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"n\">inclusion_compat</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">subset_union_right</span> <span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">schema</span> <span class=\"n\">r&#39;</span><span class=\"bp\">.</span><span class=\"n\">schema</span><span class=\"o\">))))</span>\n<span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">rel_has_union</span> <span class=\"o\">:</span> <span class=\"n\">has_union</span> <span class=\"o\">(</span><span class=\"n\">relation</span> <span class=\"n\">D</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">rel_union</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">rel_union_comm</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">r&#39;</span> <span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">D</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"err\">∪</span> <span class=\"n\">r&#39;</span> <span class=\"bp\">=</span> <span class=\"n\">r&#39;</span> <span class=\"err\">∪</span> <span class=\"n\">r</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">has_union</span><span class=\"bp\">.</span><span class=\"n\">union</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">rel_union</span><span class=\"o\">,</span>\n  <span class=\"n\">congr&#39;</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">union_comm</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">union_comm</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span><span class=\"o\">,</span>\n  <span class=\"n\">conv</span>\n    <span class=\"k\">begin</span>\n      <span class=\"n\">to_lhs</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span>\n    <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">ARA</span>\n<span class=\"kn\">end</span> <span class=\"n\">ARA</span>\n</code></pre></div>",
        "id": 208796364,
        "sender_full_name": "Robert Brijder",
        "timestamp": 1599037118
    },
    {
        "content": "<p>the solution to heq is not to use heq</p>",
        "id": 208802186,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1599041097
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/stream/113489-new-members/topic/Function.20on.20equal.20types/near/208802186\">said</a>:</p>\n<blockquote>\n<p>the solution to heq is not to use heq</p>\n</blockquote>\n<p>Right. But the problem is that I never use heq in my code. For some reason it is introduced by invoking tactic <code>congr' 1</code> in my proof. Perhaps I should have used some alternative to <code>congr' 1</code>?</p>",
        "id": 208853475,
        "sender_full_name": "Robert Brijder",
        "timestamp": 1599065134
    },
    {
        "content": "<p>the first step is to prove an extensionality lemma for <code>relation</code>, preferably one that doesn't involve heq</p>",
        "id": 208905177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599091681
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"269768\">@Robert Brijder</span> </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">theory</span>\n<span class=\"n\">local</span> <span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">prop_decidable</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ARA</span>\n<span class=\"kn\">section</span> <span class=\"n\">ARA</span>\n\n<span class=\"kn\">parameters</span> <span class=\"o\">{</span><span class=\"n\">rel</span> <span class=\"n\">att</span> <span class=\"n\">dom</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">setoid</span> <span class=\"n\">att</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">dom_assign</span> <span class=\"o\">:=</span> <span class=\"n\">quotient</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">dom</span>\n<span class=\"n\">def</span> <span class=\"n\">tuple</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">dom_assign</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">att</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">A</span> <span class=\"err\">∈</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">dom</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">D</span><span class=\"err\">⟦</span><span class=\"n\">A</span><span class=\"err\">⟧</span><span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">tuple</span><span class=\"bp\">.</span><span class=\"n\">sub</span> <span class=\"o\">{</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">dom_assign</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">att</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">⊆</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">tuple</span> <span class=\"n\">D</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tuple</span> <span class=\"n\">D</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">T</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- @[ext]</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">tuple</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"o\">{</span><span class=\"n\">D</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t₁</span> <span class=\"n\">t₂</span> <span class=\"o\">:</span> <span class=\"n\">tuple</span> <span class=\"n\">D</span> <span class=\"n\">X</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">att</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"err\">∈</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">t₁</span> <span class=\"n\">A</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">dom</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">t₂</span> <span class=\"n\">A</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t₁</span> <span class=\"bp\">=</span> <span class=\"n\">t₂</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">ext</span> <span class=\"n\">a</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">3</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">H</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">relation</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">dom_assign</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">schema</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">att</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">rel</span> <span class=\"o\">:</span> <span class=\"n\">tuple</span> <span class=\"n\">D</span> <span class=\"n\">schema</span> <span class=\"bp\">→</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n<span class=\"n\">def</span> <span class=\"n\">compat_func</span> <span class=\"o\">{</span><span class=\"n\">att</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">setoid</span> <span class=\"n\">att</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">att</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">att</span><span class=\"o\">)</span> <span class=\"bp\">≈</span> <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">att</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- @[ext]</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">relation_ext</span> <span class=\"o\">{</span><span class=\"n\">D</span> <span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r₁</span> <span class=\"n\">r₂</span> <span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">D</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">r₁</span><span class=\"bp\">.</span><span class=\"n\">schema</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">r₂</span><span class=\"bp\">.</span><span class=\"n\">schema</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">tuple</span> <span class=\"n\">D</span> <span class=\"n\">r₂</span><span class=\"bp\">.</span><span class=\"n\">schema</span><span class=\"o\">),</span> <span class=\"n\">r₁</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">sub</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">r₂</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">r₁</span> <span class=\"bp\">=</span> <span class=\"n\">r₂</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">r₁</span> <span class=\"k\">with</span> <span class=\"n\">S₁</span> <span class=\"n\">R₁</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">r₂</span> <span class=\"k\">with</span> <span class=\"n\">S₂</span> <span class=\"n\">R₂</span><span class=\"o\">,</span>\n  <span class=\"k\">obtain</span> <span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">S₁</span> <span class=\"bp\">=</span> <span class=\"n\">S₂</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">h₁</span><span class=\"o\">},</span>\n  <span class=\"n\">congr</span><span class=\"o\">,</span> <span class=\"n\">ext</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">h₂</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">dom_assign</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">X&#39;</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">att</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">rel_union</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">r&#39;</span> <span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">D</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">D</span> <span class=\"n\">K</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">schema</span> <span class=\"o\">:=</span> <span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">schema</span> <span class=\"err\">∪</span> <span class=\"n\">r&#39;</span><span class=\"bp\">.</span><span class=\"n\">schema</span><span class=\"o\">,</span>\n  <span class=\"n\">rel</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">sub</span> <span class=\"err\">$</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">subset_union_left</span> <span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">schema</span> <span class=\"n\">r&#39;</span><span class=\"bp\">.</span><span class=\"n\">schema</span><span class=\"o\">)</span> <span class=\"bp\">+</span>\n              <span class=\"n\">r&#39;</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">sub</span> <span class=\"err\">$</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">subset_union_right</span> <span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">schema</span> <span class=\"n\">r&#39;</span><span class=\"bp\">.</span><span class=\"n\">schema</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">rel_has_union</span> <span class=\"o\">:</span> <span class=\"n\">has_union</span> <span class=\"o\">(</span><span class=\"n\">relation</span> <span class=\"n\">D</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">rel_union</span><span class=\"bp\">⟩</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">rel_union_mem</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"n\">r&#39;</span> <span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">D</span> <span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"err\">∪</span> <span class=\"n\">r&#39;</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">schema</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">schema</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">r&#39;</span><span class=\"bp\">.</span><span class=\"n\">schema</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[(</span><span class=\"err\">∪</span><span class=\"o\">),</span> <span class=\"n\">rel_union</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">refl</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">rel_union_rel</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"n\">r&#39;</span> <span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">D</span> <span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"err\">∪</span> <span class=\"n\">r&#39;</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"n\">t</span> <span class=\"bp\">=</span>\n  <span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">sub</span> <span class=\"err\">$</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">subset_union_left</span> <span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">schema</span> <span class=\"n\">r&#39;</span><span class=\"bp\">.</span><span class=\"n\">schema</span><span class=\"o\">)</span> <span class=\"bp\">+</span>\n  <span class=\"n\">r&#39;</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">sub</span> <span class=\"err\">$</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">subset_union_right</span> <span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">schema</span> <span class=\"n\">r&#39;</span><span class=\"bp\">.</span><span class=\"n\">schema</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">rel_union_comm</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">r&#39;</span> <span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">D</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"err\">∪</span> <span class=\"n\">r&#39;</span> <span class=\"bp\">=</span> <span class=\"n\">r&#39;</span> <span class=\"err\">∪</span> <span class=\"n\">r</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">fapply</span> <span class=\"n\">relation_ext</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">or_comm</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span><span class=\"o\">],</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">ARA</span>\n<span class=\"kn\">end</span> <span class=\"n\">ARA</span>\n</code></pre></div>",
        "id": 208907368,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599093603
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> The two commented <code>@[ext]</code> lemmas fail with <code>match failed</code>. Do you know what's happening?</p>",
        "id": 208907391,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599093641
    },
    {
        "content": "<p>Can you minimize it?</p>",
        "id": 208909942,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1599096359
    },
    {
        "content": "<p>It's a parameter problem.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">ext</span>\n<span class=\"kn\">section</span>\n\n<span class=\"kn\">parameters</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">tuple</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">ext</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">tuple</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t₁</span> <span class=\"n\">t₂</span> <span class=\"o\">:</span> <span class=\"n\">tuple</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">t₁</span> <span class=\"bp\">=</span> <span class=\"n\">t₂</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"c1\">-- match failed</span>\n\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 208910894,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599097446
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span></p>",
        "id": 208910910,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599097484
    },
    {
        "content": "<p>Yes I see. When we call <code>resolve_constant</code>, it calls <code>resolve_name</code> expecting that the result will be a <code>const</code>. Because of the parameter, we get this as a response instead: <code>as_atomic ((«@» tuple) («@» A))</code></p>",
        "id": 208913264,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1599099932
    },
    {
        "content": "<p>whoa that's new</p>",
        "id": 208913720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599100478
    },
    {
        "content": "<p>Yeah. I think that's because pre-elaboration terms have much more annotations. What we can do is implement an alternative <code>resolve_constant</code> that checks if <code>resolve_name</code> gives a <code>const</code> and, if not, use <code>e &lt;- to_expr</code> and then use <code>e.get_app_fn.const_name</code></p>",
        "id": 208914014,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1599100641
    },
    {
        "content": "<p>resolve_name returns a pexpr?</p>",
        "id": 208914204,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599100682
    },
    {
        "content": "<p>It does</p>",
        "id": 208914242,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1599100689
    },
    {
        "content": "<p>but you already have an expr, don't you?</p>",
        "id": 208914283,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599100710
    },
    {
        "content": "<p>no, it's right after parsing the parameters of <code>ext</code>. They come as a list of names and they're not necessarily fully qualified. We need <code>resolve_constant</code> (and <code>resolve_name</code>) to figure out what their full name is</p>",
        "id": 208914438,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1599100881
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">resolve_constant&#39;</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">name</span> <span class=\"o\">:=</span>\n<span class=\"n\">do</span> <span class=\"n\">e</span> <span class=\"err\">←</span> <span class=\"n\">resolve_name</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">const_name</span> <span class=\"err\">∘</span> <span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">app_fn</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span><span class=\"err\">$</span><span class=\"bp\">&gt;</span> <span class=\"n\">to_expr</span> <span class=\"n\">e</span> <span class=\"n\">tt</span> <span class=\"n\">ff</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 208914921,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599101419
    },
    {
        "content": "<p><code>resolve_constant</code> is in core though so this will have to be a patch until the next version</p>",
        "id": 208914966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599101494
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/4032\">#4032</a></p>",
        "id": 208915249,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1599101879
    },
    {
        "content": "<p>I did something similar. In the normal case, we don't need to go through elaboration so I only call <code>to_expr</code> when <code>resolve_constant</code> would crash</p>",
        "id": 208915308,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1599101939
    },
    {
        "content": "<p>Oh and I use <code>expr.get_app_fn</code> (which is recursive) instead of <code>expr.app_fn</code></p>",
        "id": 208915400,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1599102060
    },
    {
        "content": "<p>Wow, thank you very much Mario for the rewrite of my code! I am learning a lot from this.</p>",
        "id": 208924334,
        "sender_full_name": "Robert Brijder",
        "timestamp": 1599113315
    }
]
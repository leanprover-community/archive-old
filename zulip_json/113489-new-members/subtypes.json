[
    {
        "content": "<p>I'm a bit confused about how subtypes work. This <code>simp [h]</code> doesn't close the subgoal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.power_series.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"bp\">//</span> <span class=\"n\">tendsto</span> <span class=\"n\">f</span> <span class=\"n\">cofinite</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"mi\">0</span><span class=\"o\">)}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">mv_restricted_power_series</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_zero</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">mv_power_series.has_zero.zero</span><span class=\"o\">,</span> <span class=\"n\">tendsto_const_nhds</span><span class=\"o\">⟩}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_max</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">f.val</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">≥</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">f.val</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">em</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">],</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>But if I change <code>cases em (f = 0)</code> to <code>cases em (f.val = 0)</code> it does close the goal. I don't get why this makes such a big difference; wouldn't it be more natural to write <code>f  = 0</code>?</p>",
        "id": 226251679,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613232028
    },
    {
        "content": "<p>what imports do I need to make this a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 226252295,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613232371
    },
    {
        "content": "<p>Edited, added them.</p>",
        "id": 226252336,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613232472
    },
    {
        "content": "<p>I think there are some simp lemmas missing.</p>",
        "id": 226252418,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613232579
    },
    {
        "content": "<p>Some simp lemmas that need to be written for <code>mv_restricted_power_series</code>? Or things missing from one of the imports?</p>",
        "id": 226252505,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613232659
    },
    {
        "content": "<p>If <code>h : f = 0</code> then  <code>simp [h]</code> takes you to <code>0.val x</code> and then to <code>↑0 x</code> and then it gets stuck</p>",
        "id": 226252544,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613232719
    },
    {
        "content": "<p>If <code>h : f.val = 0</code> then the simp does a <code>pi.zero_apply</code>, which I guess it doesn't want to do if <code>h : f = 0</code></p>",
        "id": 226252643,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613232832
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">subtype.val</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[simp, norm_cast]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_zero</span> <span class=\"o\">:</span>\n  <span class=\"o\">((</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_max</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">f.val</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">≥</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">f.val</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">em</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">},</span> <span class=\"c1\">-- works now</span>\n  <span class=\"o\">{</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 226252836,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613233060
    },
    {
        "content": "<p>ahh amazing, thanks!</p>",
        "id": 226252896,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613233104
    },
    {
        "content": "<p><code>simp</code> changes <code>f.val</code> into <code>↑f</code> it seems, so you need a simp lemma saying that the coerced 0 is still 0.</p>",
        "id": 226252917,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613233138
    },
    {
        "content": "<p>Right ok that makes sense</p>",
        "id": 226252927,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613233149
    },
    {
        "content": "<p>The trick with these things is to look at the goal left by <code>simp</code> (in this case one involving <code>↑0</code>) and to ask \"why did it not get any further than this?\" and the answer is that the lemma you want to apply next (namely <code>↑0 = 0</code>) is not there.</p>",
        "id": 226252941,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613233192
    },
    {
        "content": "<p>Making definitions is much harder than proving theorems, but after a while you just pick up the tricks of what needs to be done.</p>",
        "id": 226252992,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613233221
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- don't want them to be explicit for this next function</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">mv_power_series</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">coeff</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"n\">coeff</span> <span class=\"n\">R</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[ext]</span> <span class=\"kd\">lemma</span> <span class=\"n\">ext</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">coeff</span> <span class=\"n\">f</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">coeff</span> <span class=\"n\">g</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">ext</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">c</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ext_iff</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">coeff</span> <span class=\"n\">f</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">coeff</span> <span class=\"n\">g</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">ext</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_max</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">f.val</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">≥</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">f.val</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">em</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">},</span> <span class=\"c1\">-- works now</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">ext_iff</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">push_neg</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p><span class=\"user-mention\" data-user-id=\"235423\">@Ashwin Iyengar</span>  that's how I'd start. Any new type needs an extensionality lemma.</p>",
        "id": 226253635,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613233936
    },
    {
        "content": "<p>Nice, thanks</p>",
        "id": 226253811,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613234134
    },
    {
        "content": "<p>In fact looking at <code>mv_power_series</code> the <code>coeff</code> function should be an R-module hom really.</p>",
        "id": 226253883,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613234176
    },
    {
        "content": "<p>so another thing you might want to do is to make <code>mv_restricted_power_series σ R</code> into an <code>R</code>-module and then beef up the definition of <code>coeff</code></p>",
        "id": 226253911,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613234220
    },
    {
        "content": "<p>Of course it's entirely up to you how you do this. If you're thinking about a PR (and you perhaps should be) then you might want to look at the beginning of the <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/ring_theory/power_series/basic.lean\">power series file</a> in mathlib, where they do exactly what I decided was the best idea -- give it an R-module structure and then define coeff and ext. They also defined monomial. These things will ultimately make your life easier in the end.</p>",
        "id": 226254174,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613234503
    },
    {
        "content": "<p>Cool yeah that's basically what I was planning to do after getting to grips with the library a bit more</p>",
        "id": 226254276,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613234612
    },
    {
        "content": "<p>I know several cases of beginners who have started exactly this way -- made a PR to mathlib generalising something which was already there.</p>",
        "id": 226254326,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613234647
    },
    {
        "content": "<p>Ashvni (who you know), Amelia and Jason (both IC UGs) all started like this.</p>",
        "id": 226254338,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613234683
    },
    {
        "content": "<p>If you do nothing more than to make it a ring under the assumption of the ultrametric inequality then this is already really useful. Then you come back to look at it 3 months later and other random people have built on top of it. It's the way the library grows.</p>",
        "id": 226254390,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613234759
    },
    {
        "content": "<p>I would expect that in my instantiation of an <code>add_comm_group</code>, I should just be able to do <code>rfl</code> for <code>add_assoc</code> because I added a <code>coe_add</code> but it doesn't work. Is there a simple way to prove <code>add_assoc</code> which essentially just says \"it's true because it's true for the supertype\"? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.power_series.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">normed_field</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"bp\">//</span> <span class=\"n\">tendsto</span> <span class=\"n\">f</span> <span class=\"n\">cofinite</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"mi\">0</span><span class=\"o\">)}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">mv_restricted_power_series</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_field</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">subtype.val</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_zero</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">mv_power_series.has_zero.zero</span><span class=\"o\">,</span> <span class=\"n\">tendsto_const_nhds</span><span class=\"o\">⟩}</span>\n\n<span class=\"kd\">@[simp, norm_cast]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_zero</span> <span class=\"o\">:</span>\n  <span class=\"o\">((</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">f.val</span> <span class=\"bp\">+</span> <span class=\"n\">g.val</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">tendsto.add</span> <span class=\"n\">f.2</span> <span class=\"n\">g.2</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[simp, norm_cast]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_add</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">((</span><span class=\"n\">a.add</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">neg</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">-</span><span class=\"n\">f.val</span><span class=\"o\">,</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">f_conv</span> <span class=\"o\">:=</span> <span class=\"n\">metric.tendsto_nhds.1</span> <span class=\"n\">f.2</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">f_conv</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">metric.tendsto_nhds</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">f_conv</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">add</span><span class=\"o\">,</span>\n  <span class=\"n\">add_assoc</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_add</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">add_zero</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">neg</span> <span class=\"o\">:=</span> <span class=\"n\">neg</span><span class=\"o\">,</span>\n  <span class=\"n\">add_left_neg</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">add_comm</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 226378684,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613392688
    },
    {
        "content": "<p>One thing that seems to work is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">add_assoc</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add</span><span class=\"o\">,</span> <span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">],</span> <span class=\"n\">apply</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span>  <span class=\"o\">},</span>\n</code></pre></div>",
        "id": 226381254,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1613394326
    },
    {
        "content": "<p><code>ext</code> ought to help here too, after those rintros</p>",
        "id": 226383645,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613395718
    },
    {
        "content": "<p><code>  add_assoc := λ _ _ _, by {ext, simp only [add_assoc, coe_add]},</code> would be the way I would prove it. <code>by {ext, simp [add_assoc]} works too, but is slower. Note that </code>add_assoc<code> is not a </code>simp` lemma so needs to be added explicitly.</p>",
        "id": 226383982,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613395931
    },
    {
        "content": "<p><code>rfl</code> means \"this is true by definition, if you unfold all the definitions\", so it won't work here, because if you unfold all the definitions you are reduced to associativity of addition for multivariable power series, which is true, but not true by definition -- it's true because of a theorem (in fact an axiom, namely associativity of addition on R).</p>",
        "id": 226384060,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613395989
    },
    {
        "content": "<p>Thanks all! <code>ext</code> was the key that I wasn't aware existed.</p>",
        "id": 226384502,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613396267
    },
    {
        "content": "<p>The <code>ext</code> lemma we proved earlier was tagged with <code>@[ext]</code>, which means that the <code>ext</code> tactic will use it. But actually I guess the reason it's working without that ext lemma is that the <code>ext</code> tactic is using <code>subtype.ext</code> and then the <code>ext</code> lemma for <code>mv_power_series</code>.</p>\n<p>Here's a proof of <code>neg</code> which just says \"f.2 says some filter tends to 0, so the corresponding filter for -f tends to -0\".</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">neg</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">-</span><span class=\"n\">f.val</span><span class=\"o\">,</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">convert</span> <span class=\"n\">tendsto.comp</span> <span class=\"n\">continuous_at_neg</span> <span class=\"n\">f.2</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">neg_zero.symm</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 226385836,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613396936
    },
    {
        "content": "<p>The implementation for something like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submonoid.to_monoid/src\">src#submonoid.to_monoid</a> ought to show how <code>ext</code> is normally used here</p>",
        "id": 226385944,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613397003
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">add_assoc</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">show_term</span><span class=\"o\">{</span><span class=\"n\">ext</span><span class=\"o\">},</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">coe_add</span><span class=\"o\">]},</span>\n</code></pre></div>\n<p>shows that it's using subtype.ext and then the ext lemma for mv power series</p>",
        "id": 226386050,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613397044
    },
    {
        "content": "<p>Actually it seems like <code>ext</code> isn't used at all, and the proofs are just transferred across the injectivity of <code>coe</code>, using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.injective.add_comm_monoid\">docs#function.injective.add_comm_monoid</a></p>",
        "id": 226386132,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613397082
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">coe_injective</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">subtype.coe_injective</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">add</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_neg</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">neg</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">coe_injective.add_comm_group</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 226386931,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613397460
    },
    {
        "content": "<p>There's the <code>rfl</code>s you were hoping to see</p>",
        "id": 226387009,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613397487
    },
    {
        "content": "<p>How can this work? One has to check that the subtype condition is preserved by addition and negation.</p>",
        "id": 226387113,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613397539
    },
    {
        "content": "<p>That's why you have to define<code> add</code> and <code>neg</code> yourself</p>",
        "id": 226387208,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613397589
    },
    {
        "content": "<p>Oh I see, you use the contructions of add and neg</p>",
        "id": 226387216,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613397594
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 226387308,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613397628
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">neg</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">-</span><span class=\"n\">f.val</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">tendsto.comp</span> <span class=\"n\">continuous_at_neg</span> <span class=\"n\">f.2</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 226387623,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613397766
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">neg</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">-</span><span class=\"n\">f.val</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">tendsto.neg</span> <span class=\"n\">f.2</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 226387751,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613397827
    },
    {
        "content": "<p>No need to ever translate into epsilons.</p>",
        "id": 226387879,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613397869
    },
    {
        "content": "<p>Thanks. This code works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">f.val</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">tendsto.comp</span> <span class=\"o\">((</span><span class=\"n\">mul_left_continuous</span> <span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tendsto</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"n\">f.property</span><span class=\"o\">⟩}</span>\n</code></pre></div>\n<p>but now I want to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.injective.semimodule\">docs#function.injective.semimodule</a> to show that restricted power series are an R-module. The problem is that it's not clear that <code>coe</code> is an additive monoid homomorphism. My understanding is that morphisms should be bundled. So what's the best way of stating that <code>coe</code> is a homomorphism? Then I can do something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">coe_injective.semimodule</span> <span class=\"n\">_</span> <span class=\"bp\">???</span>\n</code></pre></div>",
        "id": 226415479,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613412594
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">coe_hom</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"bp\">→+</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">coe</span><span class=\"o\">,</span>\n  <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"n\">coe_zero</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"n\">coe_add</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 226415902,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613412885
    },
    {
        "content": "<p>Ah ok so treat it as a separate thing. Thanks!</p>",
        "id": 226415918,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613412903
    },
    {
        "content": "<p>yeah it's kind of annoying. In Lean 4 we might be able to go back to the <code>instance : is_add_monoid_hom coe</code> approach but in Lean 3 the separate thing approach turned out to be nicer.</p>",
        "id": 226415984,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613412957
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">function.injective.semimodule</span> <span class=\"n\">R</span> <span class=\"n\">coe_hom</span> <span class=\"n\">coe_hom_injective</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">c</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>works but I can't get <code>coe_hom_injective.semimodule ...</code> to work.</p>",
        "id": 226416421,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613413297
    },
    {
        "content": "<p>Yeah I guess <code>coe_injective</code> doesn't know that <code>coe</code> is a hom</p>",
        "id": 226416591,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613413405
    },
    {
        "content": "<p>Can you post an updated <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 226416697,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613413469
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.power_series.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"bp\">//</span> <span class=\"n\">tendsto</span> <span class=\"n\">f</span> <span class=\"n\">cofinite</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"mi\">0</span><span class=\"o\">)}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">mv_restricted_power_series</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_field</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">subtype.val</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">coe_injective</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">subtype.coe_injective</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">f.val</span> <span class=\"bp\">+</span> <span class=\"n\">g.val</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">tendsto.add</span> <span class=\"n\">f.2</span> <span class=\"n\">g.2</span><span class=\"o\">⟩⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_zero</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">tendsto_const_nhds</span><span class=\"o\">⟩⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_neg</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"bp\">-</span><span class=\"n\">f.val</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">tendsto.neg</span> <span class=\"n\">f.2</span><span class=\"o\">⟩⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">f.val</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">tendsto.comp</span> <span class=\"o\">((</span><span class=\"n\">mul_left_continuous</span> <span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tendsto</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"n\">f.property</span><span class=\"o\">⟩}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">coe_injective.add_comm_group</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">coe_hom</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"bp\">→+</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">coe</span><span class=\"o\">,</span>\n    <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">function.injective.semimodule</span> <span class=\"n\">R</span> <span class=\"n\">coe_hom</span> <span class=\"n\">coe_injective</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 226416718,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613413498
    },
    {
        "content": "<p>Hey, nice <code>has_scalar.smul</code> proof :-) You can use <code>f.2</code> for <code>f.property</code> if you want (and <code>f.1</code> for <code>f.val</code>) -- but I'm not sure that there is any particular preference for one over the other, I'm just noting this general trick of X.1 and X.2 which works in large generality. Note that X.3 doesn't work :-( (in situations where it's meaningful, e.g. if X is a proof of P and Q and R) -- it's X.2.2.</p>",
        "id": 226416991,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613413713
    },
    {
        "content": "<p>Ok, yeah either way I should probably pick a convention and stick to it</p>",
        "id": 226417335,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613413931
    },
    {
        "content": "<p>I sort of like <code>f.val</code> and <code>f.property</code> because they're less ambiguous, but maybe that hasn't been the design principle?</p>",
        "id": 226417369,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613413973
    },
    {
        "content": "<p>No, I agree about the lack of ambiguity, stick with them, I was just pointing out a trick.</p>",
        "id": 226417406,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613414000
    },
    {
        "content": "<p>Honestly, the only reason I said it was that </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"o\">{</span><span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">f.val</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">tendsto.comp</span> <span class=\"o\">((</span><span class=\"n\">mul_left_continuous</span> <span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tendsto</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"n\">f.property</span><span class=\"o\">⟩}</span>\n</code></pre></div>\n<p>is over 100 characters long, and there's a 100 character limit per line in mathlib, and this trick got it back down to under 100 characters :-)</p>",
        "id": 226417485,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613414048
    },
    {
        "content": "<p>Ah good to know</p>",
        "id": 226417556,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613414110
    },
    {
        "content": "<p>Usually coercion is used as the simp-normal form in place of <code>.val</code> or <code>.1</code></p>",
        "id": 226418204,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613414575
    },
    {
        "content": "<p>That is,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">tendsto.comp</span> <span class=\"o\">((</span><span class=\"n\">mul_left_continuous</span> <span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tendsto</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"n\">f.prop</span><span class=\"o\">⟩}</span>\n</code></pre></div>",
        "id": 226418252,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613414612
    },
    {
        "content": "<blockquote>\n<p>Note that X.3 doesn't work :-( (in situations where it's meaningful, e.g. if X is a proof of P and Q and R) -- it's X.2.2.</p>\n</blockquote>\n<p>By the way, while I would be all for such an abbreviation, it makes X.2 ambiguous</p>",
        "id": 226418512,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613414792
    },
    {
        "content": "<p>Also <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I would think that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span> <span class=\"kd\">lemma</span> <span class=\"n\">ext</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">f.val</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">g.val</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>is more natural than</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span> <span class=\"kd\">lemma</span> <span class=\"n\">ext</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">coeff</span> <span class=\"n\">R</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">coeff</span> <span class=\"n\">R</span> <span class=\"n\">n</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>but maybe  I'm missing something? Is the idea that using <code>coeff</code> is more elegant because it doesn't rely on the precise definition of <code>mv_power_series</code> or <code>mv_restricted_power_series</code>?</p>",
        "id": 226423757,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613418290
    },
    {
        "content": "<p>I am always a bit edgy about abuse of definitional equality. What you say is exactly what worries me -- but I know that some computer scientists would find your suggestion more elegant. Your code breaks if someone refactors mv_power_series to be e.g. a completion of k[sigma]/I^n with I the ideal generated by the sigma, whereas mine uses the interface so doesn't break. I've seen definitions change in the past in mathlib. On the other hand the current definition of power series seems to be one which makes everyone happy right now so maybe it's unlikely to change in future. Abuse of definitional equality is really handy when you're writing slick term mode proofs at the beginning of your API. After a while it basically becomes irrelevant though, because e.g. if you're trying to prove that Tate algebras in finitely many variables over a complete nonarchimedean normed field are Noetherian then these issues are not really the important ones -- you're going to write a long tactic proof there so who cares what the definition is under the hood.</p>",
        "id": 226424431,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613418741
    },
    {
        "content": "<p>I see. Yeah it's the little things like this I get perplexed by, like e.g. right now I'm stuck trying to convert <code>hd: ¬⇑(coeff R d) f = 0</code> to <code>hd: ¬∥f.val d∥ = 0</code></p>",
        "id": 226424679,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613418959
    },
    {
        "content": "<p>You can probably <code>change ¬(f.val d = 0) at hd</code> because these will be definitional.</p>",
        "id": 226424783,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613419027
    },
    {
        "content": "<p>But one thing you should definitely do is to decide once and for all whether you're going to refer to to the d'th coefficient of f via f.val d or coeff R d f or whatever, and then stick to your convention, and write simp lemmas changing every other convention to your convention.</p>",
        "id": 226424823,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613419082
    },
    {
        "content": "<p>A tactic a day...</p>",
        "id": 226425081,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613419292
    }
]
[
    {
        "content": "<p>When I'm instantiating a typeclass A that extends typeclasses B and C, and when I've already instantiated B and C, to what extent can I count on Lean finding and using the B and C instances so that I don't have to provide values for their field values when specifying those of A?</p>",
        "id": 233853087,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1617985926
    },
    {
        "content": "<p>I think you always have to put <code>..(show B, by apply_instance)</code> in, even if the instance is in the type class cache.</p>",
        "id": 233853269,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617985996
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Typeclass.20instantiation.20and.20extension/near/233853269\">said</a>:</p>\n<blockquote>\n<p>I think you always have to put <code>..(show B, by apply_instance)</code> in, even if the instance is in the type class cache.</p>\n</blockquote>\n<p>Kevin B, thanks very much. Here's a piece of code that works without my saying anything about instances of superclasses (if I may use that terminology). Is it just by coincidence? If so, can you perhaps pencil in what I should have written?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">A</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">B</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"mi\">1</span> <span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"mi\">2</span> <span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"mi\">3</span> <span class=\"o\">⟩</span>  <span class=\"c1\">-- works but maybe just by good luck</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">c</span>                  <span class=\"c1\">-- {to_A := {n := 1}, to_B := {m := 2}, k := 3}</span>\n</code></pre></div>\n<p>It's clear that we can't always rely on Lean finding superclass instances. And in cases where we can't, it's often unclear which or even how many fields need to be filled in, and in what order. Perhaps the right rule is to always use \"show _, by apply_instance?\" Is there documentation somewhere as to how resolution of superclass instances works and/or what we need to do to make it work?</p>",
        "id": 233877110,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1617996140
    },
    {
        "content": "<p>If the constructor actually takes a typeclass argument, you don't have to provide it like that. It's mainly when you use old structures that you need it since the <code>C.mk</code> doesn't actually have <code>A</code> and <code>B</code> as arguments but rather their fields</p>",
        "id": 233925465,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618029583
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Typeclass.20instantiation.20and.20extension/near/233925465\">said</a>:</p>\n<blockquote>\n<p>If the constructor actually takes a typeclass argument, you don't have to provide it like that. It's mainly when you use old structures that you need it since the <code>C.mk</code> doesn't actually have <code>A</code> and <code>B</code> as arguments but rather their fields</p>\n</blockquote>\n<p>Thank you.</p>",
        "id": 234006501,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1618106505
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124175\">Kevin Sullivan</span> <a href=\"#narrow/stream/113489-new-members/topic/Typeclass.20instantiation.20and.20extension/near/233877110\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Typeclass.20instantiation.20and.20extension/near/233853269\">said</a>:</p>\n<blockquote>\n<p>I think you always have to put <code>..(show B, by apply_instance)</code> in, even if the instance is in the type class cache.</p>\n</blockquote>\n<p>Kevin B, thanks very much. The reason I ask is that Lean's behavior is inconsistent. Here's a piece of code that works without my saying anything about instances of superclasses (if I may use that terminology). I had mistakenly assumed that this is how Lean would work, in general. But clearly it's not. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">A</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">B</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"mi\">1</span> <span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"mi\">2</span> <span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"mi\">3</span> <span class=\"o\">⟩</span>  <span class=\"c1\">-- works but maybe just by good luck</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">c</span>                  <span class=\"c1\">-- {to_A := {n := 1}, to_B := {m := 2}, k := 3}</span>\n</code></pre></div>\n<p>Ok, I see where my confusion was. First, my example above uses anonymous constructor notation, ⟨ ... ⟩. Typeclass inference appears to work to fill in the missing fields in the example  I've given, but it doesn't appear to work in all cases. That's what had me misled: I'd drawn an inference from its working in simple cases to conclude that it works in general. I haven't yet quite figured out what's going on with that: when it works and when it doesn't.  Second, it also appears that the ..p notation does not work at all with anonymous constructor notation. So,  conclusion, it appears that combining standard { ... } structure instance definition notation with ..p, ..q, ..r notation (telling Lean to try to fill in missing field values from fields defined in p, q, r in that order) is what I need.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"mi\">1</span> <span class=\"o\">⟩</span>     <span class=\"c1\">-- anonymous constructor notation</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"mi\">2</span> <span class=\"o\">⟩</span>     <span class=\"c1\">-- anonymous constructor notation</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">A</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">B</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"bp\">..</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">..</span><span class=\"n\">b</span> <span class=\"o\">}</span>  <span class=\"c1\">-- curly brace / field assignment notation</span>\n</code></pre></div>\n</blockquote>",
        "id": 234226348,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1618259888
    }
]